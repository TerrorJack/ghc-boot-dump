
==================== Output Cmm ====================
2018-03-16 16:11:46.945538056 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:46.947024761 UTC

[section ""data" . Data.Functor.Sum.$fEq1Sum_$cliftEq_closure" {
     Data.Functor.Sum.$fEq1Sum_$cliftEq_closure:
         const Data.Functor.Sum.$fEq1Sum_$cliftEq_info;
 },
 Data.Functor.Sum.$fEq1Sum_$cliftEq_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfY4W,
                       label: Data.Functor.Sum.$fEq1Sum_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY4W: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfY4X; else goto cfY4Y;
       cfY4X: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEq1Sum_$cliftEq_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfY4Y: // global
           I64[Sp - 40] = block_cfY4P_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufY5z; else goto cfY4Q;
       ufY5z: // global
           call _cfY4P(R1) args: 0, res: 0, upd: 0;
       cfY4Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfY4P() //  [R1]
         { info_tbl: [(cfY4P,
                       label: block_cfY4P_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY4P: // global
           _sfXPB::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfY4T; else goto cfY4U;
       cfY4T: // global
           I64[Sp] = block_cfY51_info;
           _sfXPD::P64 = P64[R1 + 7];
           R1 = _sfXPB::P64;
           P64[Sp + 32] = _sfXPD::P64;
           if (R1 & 7 != 0) goto ufY5x; else goto cfY53;
       ufY5x: // global
           call _cfY51(R1) args: 0, res: 0, upd: 0;
       cfY53: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfY4U: // global
           I64[Sp + 8] = block_cfY5g_info;
           _sfXPH::P64 = P64[R1 + 6];
           R1 = _sfXPB::P64;
           P64[Sp + 32] = _sfXPH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufY5y; else goto cfY5i;
       ufY5y: // global
           call _cfY5g(R1) args: 0, res: 0, upd: 0;
       cfY5i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfY51() //  [R1]
         { info_tbl: [(cfY51,
                       label: block_cfY51_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY51: // global
           if (R1 & 7 == 1) goto cfY59; else goto ufY5w;
       cfY59: // global
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ufY5w: // global
           Sp = Sp + 40;
           call _cfY5o() args: 0, res: 0, upd: 0;
     }
 },
 _cfY5g() //  [R1]
         { info_tbl: [(cfY5g,
                       label: block_cfY5g_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY5g: // global
           if (R1 & 7 == 1) goto ufY5v; else goto cfY5s;
       ufY5v: // global
           Sp = Sp + 32;
           call _cfY5o() args: 0, res: 0, upd: 0;
       cfY5s: // global
           R4 = P64[R1 + 6];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfY5o() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY5o: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.948984731 UTC

[section ""data" . Data.Functor.Sum.$fEq1Sum_closure" {
     Data.Functor.Sum.$fEq1Sum_closure:
         const Data.Functor.Sum.$fEq1Sum_info;
 },
 Data.Functor.Sum.$fEq1Sum_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfY5G,
                       label: Data.Functor.Sum.$fEq1Sum_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY5G: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fEq1Sum_$cliftEq_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.950400093 UTC

[section ""data" . Data.Functor.Sum.$fOrd1Sum_$cliftCompare_closure" {
     Data.Functor.Sum.$fOrd1Sum_$cliftCompare_closure:
         const Data.Functor.Sum.$fOrd1Sum_$cliftCompare_info;
 },
 Data.Functor.Sum.$fOrd1Sum_$cliftCompare_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cfY5U,
                       label: Data.Functor.Sum.$fOrd1Sum_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY5U: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfY5V; else goto cfY5W;
       cfY5V: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrd1Sum_$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfY5W: // global
           I64[Sp - 40] = block_cfY5N_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufY6v; else goto cfY5O;
       ufY6v: // global
           call _cfY5N(R1) args: 0, res: 0, upd: 0;
       cfY5O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfY5N() //  [R1]
         { info_tbl: [(cfY5N,
                       label: block_cfY5N_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY5N: // global
           _sfXPP::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfY5R; else goto cfY5S;
       cfY5R: // global
           I64[Sp] = block_cfY5Z_info;
           _sfXPR::P64 = P64[R1 + 7];
           R1 = _sfXPP::P64;
           P64[Sp + 32] = _sfXPR::P64;
           if (R1 & 7 != 0) goto ufY6t; else goto cfY61;
       ufY6t: // global
           call _cfY5Z(R1) args: 0, res: 0, upd: 0;
       cfY61: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfY5S: // global
           I64[Sp + 8] = block_cfY6e_info;
           _sfXPV::P64 = P64[R1 + 6];
           R1 = _sfXPP::P64;
           P64[Sp + 32] = _sfXPV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufY6u; else goto cfY6g;
       ufY6u: // global
           call _cfY6e(R1) args: 0, res: 0, upd: 0;
       cfY6g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfY5Z() //  [R1]
         { info_tbl: [(cfY5Z,
                       label: block_cfY5Z_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY5Z: // global
           if (R1 & 7 == 1) goto cfY67; else goto cfY6b;
       cfY67: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
       cfY6b: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfY6e() //  [R1]
         { info_tbl: [(cfY6e,
                       label: block_cfY6e_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY6e: // global
           if (R1 & 7 == 1) goto cfY6m; else goto cfY6q;
       cfY6m: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfY6q: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.95274201 UTC

[section ""data" . Data.Functor.Sum.$fOrd1Sum1_closure" {
     Data.Functor.Sum.$fOrd1Sum1_closure:
         const Data.Functor.Sum.$fOrd1Sum1_info;
 },
 Data.Functor.Sum.$fOrd1Sum1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfY6H,
                       label: Data.Functor.Sum.$fOrd1Sum1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY6H: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfY6I; else goto cfY6J;
       cfY6I: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrd1Sum1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfY6J: // global
           I64[Sp - 40] = block_cfY6A_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufY7k; else goto cfY6B;
       ufY7k: // global
           call _cfY6A(R1) args: 0, res: 0, upd: 0;
       cfY6B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfY6A() //  [R1]
         { info_tbl: [(cfY6A,
                       label: block_cfY6A_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY6A: // global
           _sfXQ3::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfY6E; else goto cfY6F;
       cfY6E: // global
           I64[Sp] = block_cfY6M_info;
           _sfXQ5::P64 = P64[R1 + 7];
           R1 = _sfXQ3::P64;
           P64[Sp + 32] = _sfXQ5::P64;
           if (R1 & 7 != 0) goto ufY7i; else goto cfY6O;
       ufY7i: // global
           call _cfY6M(R1) args: 0, res: 0, upd: 0;
       cfY6O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfY6F: // global
           I64[Sp + 8] = block_cfY71_info;
           _sfXQ9::P64 = P64[R1 + 6];
           R1 = _sfXQ3::P64;
           P64[Sp + 32] = _sfXQ9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufY7j; else goto cfY73;
       ufY7j: // global
           call _cfY71(R1) args: 0, res: 0, upd: 0;
       cfY73: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfY6M() //  [R1]
         { info_tbl: [(cfY6M,
                       label: block_cfY6M_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY6M: // global
           if (R1 & 7 == 1) goto cfY6U; else goto ufY7h;
       cfY6U: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
       ufY7h: // global
           Sp = Sp + 40;
           call _cfY79() args: 0, res: 0, upd: 0;
     }
 },
 _cfY71() //  [R1]
         { info_tbl: [(cfY71,
                       label: block_cfY71_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY71: // global
           if (R1 & 7 == 1) goto ufY7g; else goto cfY7d;
       ufY7g: // global
           Sp = Sp + 32;
           call _cfY79() args: 0, res: 0, upd: 0;
       cfY7d: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cfY79() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY79: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.955023328 UTC

[section ""data" . Data.Functor.Sum.$fOrd1Sum_closure" {
     Data.Functor.Sum.$fOrd1Sum_closure:
         const Data.Functor.Sum.$fOrd1Sum_info;
 },
 sat_sfXQg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfY7w,
                       label: sat_sfXQg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY7w: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fOrd1Sum_$cliftCompare_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfY7E,
                       label: sat_sfXQf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY7E: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fOrd1Sum1_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fOrd1Sum_entry() //  [R2, R3]
         { info_tbl: [(cfY7I,
                       label: Data.Functor.Sum.$fOrd1Sum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY7I: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfY7M; else goto cfY7L;
       cfY7M: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrd1Sum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfY7L: // global
           I64[Hp - 64] = sat_sfXQg_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sfXQf_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 37;
           P64[Hp] = Hp - 61;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.956289466 UTC

[section ""cstring" . Data.Functor.Sum.$fRead1Sum8_bytes" {
     Data.Functor.Sum.$fRead1Sum8_bytes:
         I8[] [73,110,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.957021985 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum7_closure" {
     Data.Functor.Sum.$fRead1Sum7_closure:
         const Data.Functor.Sum.$fRead1Sum7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fRead1Sum7_entry() //  [R1]
         { info_tbl: [(cfY7T,
                       label: Data.Functor.Sum.$fRead1Sum7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY7T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfY7U; else goto cfY7V;
       cfY7U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfY7V: // global
           (_cfY7Q::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfY7Q::I64 == 0) goto cfY7S; else goto cfY7R;
       cfY7S: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfY7R: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfY7Q::I64;
           R2 = Data.Functor.Sum.$fRead1Sum8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.95793126 UTC

[section ""cstring" . Data.Functor.Sum.$fRead1Sum4_bytes" {
     Data.Functor.Sum.$fRead1Sum4_bytes:
         I8[] [73,110,82]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.958645592 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum3_closure" {
     Data.Functor.Sum.$fRead1Sum3_closure:
         const Data.Functor.Sum.$fRead1Sum3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fRead1Sum3_entry() //  [R1]
         { info_tbl: [(cfY82,
                       label: Data.Functor.Sum.$fRead1Sum3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY82: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfY83; else goto cfY84;
       cfY83: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfY84: // global
           (_cfY7Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfY7Z::I64 == 0) goto cfY81; else goto cfY80;
       cfY81: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfY80: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfY7Z::I64;
           R2 = Data.Functor.Sum.$fRead1Sum4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.959513856 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum2_closure" {
     Data.Functor.Sum.$fRead1Sum2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Sum.$fRead1Sum3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.960063218 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum5_closure" {
     Data.Functor.Sum.$fRead1Sum5_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.960635928 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum6_closure" {
     Data.Functor.Sum.$fRead1Sum6_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.963373568 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum1_closure" {
     Data.Functor.Sum.$fRead1Sum1_closure:
         const Data.Functor.Sum.$fRead1Sum1_info;
         const 0;
 },
 ds_sfXQl_entry() //  [R1]
         { info_tbl: [(cfY8d,
                       label: ds_sfXQl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY8d: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfY8e; else goto cfY8f;
       cfY8e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfY8f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds1_sfXQm_entry() //  [R1]
         { info_tbl: [(cfY8k,
                       label: ds1_sfXQm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY8k: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfY8l; else goto cfY8m;
       cfY8l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfY8m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sfXQu_entry() //  [R1, R2]
         { info_tbl: [(cfY8H,
                       label: sat_sfXQu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY8H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfY8L; else goto cfY8K;
       cfY8L: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfY8K: // global
           _sfXQp::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           R1 = _sfXQp::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQv_entry() //  [R1, R2]
         { info_tbl: [(cfY8M,
                       label: sat_sfXQv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY8M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfY8Q; else goto cfY8P;
       cfY8Q: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfY8P: // global
           _sfXQl::P64 = P64[R1 + 7];
           _sfXQp::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sfXQu_info;
           P64[Hp] = _sfXQp::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Sum.$fRead1Sum5_closure+1;
           R1 = _sfXQl::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQC_entry() //  [R1, R2]
         { info_tbl: [(cfY98,
                       label: sat_sfXQC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY98: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfY9c; else goto cfY9b;
       cfY9c: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfY9b: // global
           _sfXQp::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _sfXQp::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQD_entry() //  [R1, R2]
         { info_tbl: [(cfY9d,
                       label: sat_sfXQD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY9d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfY9h; else goto cfY9g;
       cfY9h: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfY9g: // global
           _sfXQm::P64 = P64[R1 + 7];
           _sfXQp::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sfXQC_info;
           P64[Hp] = _sfXQp::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Sum.$fRead1Sum5_closure+1;
           R1 = _sfXQm::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQG_entry() //  [R1]
         { info_tbl: [(cfY9l,
                       label: sat_sfXQG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY9l: // global
           _sfXQG::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cfY9m; else goto cfY9n;
       cfY9n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfY9p; else goto cfY9o;
       cfY9p: // global
           HpAlloc = 24;
           goto cfY9m;
       cfY9m: // global
           R1 = _sfXQG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfY9o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXQG::P64;
           _sfXQm::P64 = P64[_sfXQG::P64 + 16];
           _sfXQp::P64 = P64[_sfXQG::P64 + 24];
           I64[Hp - 16] = sat_sfXQD_info;
           P64[Hp - 8] = _sfXQm::P64;
           P64[Hp] = _sfXQp::P64;
           I64[Sp - 24] = block_cfY9i_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Sum.$fRead1Sum2_closure+4;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfY9i() //  [R1]
         { info_tbl: [(cfY9i,
                       label: block_cfY9i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY9i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfY9s; else goto cfY9r;
       cfY9s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfY9r: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_sfXQn_entry() //  [R1, R2, R3]
         { info_tbl: [(cfY9w,
                       label: $wlvl_sfXQn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY9w: // global
           _sfXQp::P64 = R3;
           _sfXQo::I64 = R2;
           _sfXQn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cfY9x; else goto cfY9y;
       cfY9y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfY9A; else goto cfY9z;
       cfY9A: // global
           HpAlloc = 24;
           goto cfY9x;
       cfY9x: // global
           R3 = _sfXQp::P64;
           R2 = _sfXQo::I64;
           R1 = _sfXQn::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfY9z: // global
           if (%MO_S_Gt_W64(_sfXQo::I64, 10)) goto cfY9u; else goto cfY9v;
       cfY9u: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfY9v: // global
           _sfXQl::P64 = P64[_sfXQn::P64 + 6];
           _sfXQm::P64 = P64[_sfXQn::P64 + 14];
           I64[Hp - 16] = sat_sfXQv_info;
           P64[Hp - 8] = _sfXQl::P64;
           P64[Hp] = _sfXQp::P64;
           I64[Sp - 24] = block_cfY8R_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Sum.$fRead1Sum6_closure+4;
           P64[Sp - 16] = _sfXQm::P64;
           P64[Sp - 8] = _sfXQp::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfY8R() //  [R1]
         { info_tbl: [(cfY8R,
                       label: block_cfY8R_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY8R: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfY9E; else goto cfY9D;
       cfY9E: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfY9D: // global
           I64[Hp - 40] = sat_sfXQG_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R3 = Hp - 40;
           R2 = Hp - 6;
           Sp = Sp + 24;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 lvl8_sfXQH_entry() //  [R1, R2, R3]
         { info_tbl: [(cfY9N,
                       label: lvl8_sfXQH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY9N: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfY9O; else goto cfY9P;
       cfY9O: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfY9P: // global
           I64[Sp - 24] = block_cfY9K_info;
           _sfXQn::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sfXQn::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufY9T; else goto cfY9L;
       ufY9T: // global
           call _cfY9K(R1) args: 0, res: 0, upd: 0;
       cfY9L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfY9K() //  [R1]
         { info_tbl: [(cfY9K,
                       label: block_cfY9K_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY9K: // global
           R3 = P64[Sp + 16];
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call $wlvl_sfXQn_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQO_entry() //  [R1, R2, R3]
         { info_tbl: [(cfY9Z,
                       label: sat_sfXQO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY9Z: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfYa2,
                       label: Data.Functor.Sum.$fRead1Sum1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYa2: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cfYa6; else goto cfYa5;
       cfYa6: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYa5: // global
           I64[Hp - 128] = ds_sfXQl_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R4;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = ds1_sfXQm_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = $wlvl_sfXQn_info;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 88;
           I64[Hp - 24] = lvl8_sfXQH_info;
           P64[Hp - 16] = Hp - 46;
           I64[Hp - 8] = sat_sfXQO_info;
           P64[Hp] = Hp - 22;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.968907389 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure" {
     Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure:
         const Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_info;
         const 0;
 },
 sat_sfXQZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYao,
                       label: sat_sfXQZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYao: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYap; else goto cfYaq;
       cfYap: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYaq: // global
           I64[Sp - 8] = block_cfYal_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfYal() //  [R1]
         { info_tbl: [(cfYal,
                       label: block_cfYal_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYal: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfYat; else goto cfYas;
       cfYat: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYas: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQU_entry() //  [R1, R2]
         { info_tbl: [(cfYaz,
                       label: sat_sfXQU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYaz: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sfXQT_entry() //  [R1]
         { info_tbl: [(cfYaC,
                       label: ds_sfXQT_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYaC: // global
           _sfXQT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfYaD; else goto cfYaE;
       cfYaE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfYaG; else goto cfYaF;
       cfYaG: // global
           HpAlloc = 32;
           goto cfYaD;
       cfYaD: // global
           R1 = _sfXQT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYaF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXQT::P64;
           _sfXQP::P64 = P64[_sfXQT::P64 + 16];
           _sfXQQ::P64 = P64[_sfXQT::P64 + 24];
           _sfXQR::P64 = P64[_sfXQT::P64 + 32];
           _sfXQS::P64 = P64[_sfXQT::P64 + 40];
           I64[Hp - 24] = sat_sfXQZ_info;
           P64[Hp - 16] = _sfXQS::P64;
           I64[Hp - 8] = sat_sfXQU_info;
           P64[Hp] = _sfXQR::P64;
           R5 = Hp - 22;
           R4 = Hp - 7;
           R3 = _sfXQQ::P64;
           R2 = _sfXQP::P64;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXR1_entry() //  [R1]
         { info_tbl: [(cfYaQ,
                       label: sat_sfXR1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYaQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYaR; else goto cfYaS;
       cfYaR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYaS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXR2_entry() //  [R1, R2]
         { info_tbl: [(cfYaT,
                       label: sat_sfXR2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYaT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfYaX; else goto cfYaW;
       cfYaX: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYaW: // global
           _sfXQT::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sfXR1_info;
           P64[Hp - 8] = _sfXQT::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cfYaY,
                       label: Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYaY: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfYb2; else goto cfYb1;
       cfYb2: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYb1: // global
           I64[Hp - 56] = ds_sfXQT_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = sat_sfXR2_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.971837889 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure" {
     Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure:
         const Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_info;
         const 0;
 },
 sat_sfXR7_entry() //  [R1]
         { info_tbl: [(cfYbb,
                       label: sat_sfXR7_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYbb: // global
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cfYbe,
                       label: Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYbe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfYbi; else goto cfYbh;
       cfYbi: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYbh: // global
           I64[Hp - 40] = sat_sfXR7_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.973928947 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum_closure" {
     Data.Functor.Sum.$fRead1Sum_closure:
         const Data.Functor.Sum.$fRead1Sum_info;
         const 0;
 },
 sat_sfXRd_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYbs,
                       label: sat_sfXRd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYbs: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXRc_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYbA,
                       label: sat_sfXRc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYbA: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXRb_entry() //  [R1]
         { info_tbl: [(cfYbH,
                       label: sat_sfXRb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYbH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYbI; else goto cfYbJ;
       cfYbI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYbJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum_$cliftReadList_entry(R3,
                                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXRa_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYbP,
                       label: sat_sfXRa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYbP: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_entry(R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum_entry() //  [R2, R3]
         { info_tbl: [(cfYbT,
                       label: Data.Functor.Sum.$fRead1Sum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYbT: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cfYbX; else goto cfYbW;
       cfYbX: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYbW: // global
           I64[Hp - 136] = sat_sfXRd_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sfXRc_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sfXRb_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sfXRa_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 54;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 134;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure" {
     Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure:
         const Data.Functor.Sum.$fRead1Sum_$cliftReadList_info;
         const 0;
 },
 sat_sfXRg_entry() //  [R1]
         { info_tbl: [(cfYc6,
                       label: sat_sfXRg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYc6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYc7; else goto cfYc8;
       cfYc7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYc8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum_entry(R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fRead1Sum_$cliftReadList_entry() //  [R2, R3]
         { info_tbl: [(cfYc9,
                       label: Data.Functor.Sum.$fRead1Sum_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYc9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfYcd; else goto cfYcc;
       cfYcd: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYcc: // global
           I64[Hp - 24] = sat_sfXRg_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.977093208 UTC

[section ""data" . Data.Functor.Sum.$w$cliftShowsPrec_closure" {
     Data.Functor.Sum.$w$cliftShowsPrec_closure:
         const Data.Functor.Sum.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Sum.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYcf: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sfXRp_entry() //  [R1]
         { info_tbl: [(cfYcs,
                       label: sat_sfXRp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYcs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfYct; else goto cfYcu;
       cfYct: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYcu: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfXRr_entry() //  [R1]
         { info_tbl: [(cfYcB,
                       label: sat_sfXRr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYcB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfYcC; else goto cfYcD;
       cfYcC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYcD: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYcI,
                       label: Data.Functor.Sum.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYcI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYcJ; else goto cfYcK;
       cfYcJ: // global
           R1 = Data.Functor.Sum.$w$cliftShowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cfYcK: // global
           I64[Sp - 40] = block_cfYcj_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYcR; else goto cfYck;
       ufYcR: // global
           call _cfYcj(R1) args: 0, res: 0, upd: 0;
       cfYck: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYcj() //  [R1]
         { info_tbl: [(cfYcj,
                       label: block_cfYcj_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYcj: // global
           _sfXRj::P64 = P64[Sp + 16];
           _sfXRk::P64 = P64[Sp + 24];
           _sfXRl::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cfYcF; else goto cfYcG;
       cfYcF: // global
           Hp = Hp + 40;
           _sfXRn::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYcQ; else goto cfYcM;
       cfYcM: // global
           _sfXRo::P64 = P64[_sfXRn::P64 + 7];
           I64[Hp - 32] = sat_sfXRp_info;
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = _sfXRj::P64;
           P64[Hp] = _sfXRk::P64;
           R5 = _sfXRo::P64;
           R4 = _sfXRl::I64;
           R3 = Data.Functor.Sum.$fRead1Sum7_closure;
           R2 = Hp - 32;
           Sp = Sp + 48;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cfYcG: // global
           Hp = Hp + 40;
           _sfXRn::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYcQ; else goto cfYcP;
       cfYcQ: // global
           HpAlloc = 40;
           R1 = _sfXRn::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYcP: // global
           _sfXRq::P64 = P64[_sfXRn::P64 + 6];
           I64[Hp - 32] = sat_sfXRr_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sfXRj::P64;
           P64[Hp] = _sfXRk::P64;
           R5 = _sfXRq::P64;
           R4 = _sfXRl::I64;
           R3 = Data.Functor.Sum.$fRead1Sum3_closure;
           R2 = Hp - 32;
           Sp = Sp + 48;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.979562254 UTC

[section ""data" . Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure" {
     Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure:
         const Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cfYcZ,
                       label: Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYcZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYd0; else goto cfYd1;
       cfYd0: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfYd1: // global
           I64[Sp - 40] = block_cfYcW_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYd5; else goto cfYcX;
       ufYd5: // global
           call _cfYcW(R1) args: 0, res: 0, upd: 0;
       cfYcX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYcW() //  [R1]
         { info_tbl: [(cfYcW,
                       label: block_cfYcW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYcW: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.980704312 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum6_closure" {
     Data.Functor.Sum.$fFoldableSum6_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.981740509 UTC

[section ""data" . Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure" {
     Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure:
         const Data.Functor.Sum.$fShow1Sum_$cliftShowList_info;
         const 0;
 },
 sat_sfXRH_entry() //  [R1, R2]
         { info_tbl: [(cfYdf,
                       label: sat_sfXRH_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYdf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYdg; else goto cfYdh;
       cfYdg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYdh: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sfXRG::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sfXRG::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShow1Sum_$cliftShowList_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cfYdi,
                       label: Data.Functor.Sum.$fShow1Sum_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYdi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfYdm; else goto cfYdl;
       cfYdm: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfYdl: // global
           I64[Hp - 32] = sat_sfXRH_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 31;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.983513278 UTC

[section ""data" . Data.Functor.Sum.$fShow1Sum_closure" {
     Data.Functor.Sum.$fShow1Sum_closure:
         const Data.Functor.Sum.$fShow1Sum_info;
         const 0;
 },
 sat_sfXRL_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfYdw,
                       label: sat_sfXRL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYdw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYdx; else goto cfYdy;
       cfYdx: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYdy: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$fShow1Sum_$cliftShowList_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_sfXRK_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfYdE,
                       label: sat_sfXRK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYdE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYdF; else goto cfYdG;
       cfYdF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYdG: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShow1Sum_entry() //  [R2, R3]
         { info_tbl: [(cfYdI,
                       label: Data.Functor.Sum.$fShow1Sum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYdI: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfYdM; else goto cfYdL;
       cfYdM: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShow1Sum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYdL: // global
           I64[Hp - 64] = sat_sfXRL_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sfXRK_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 36;
           P64[Hp] = Hp - 60;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.985463634 UTC

[section ""data" . Data.Functor.Sum.$fEqSum_$c==_closure" {
     Data.Functor.Sum.$fEqSum_$c==_closure:
         const Data.Functor.Sum.$fEqSum_$c==_info;
 },
 sat_sfXRR_entry() //  [R1]
         { info_tbl: [(cfYdV,
                       label: sat_sfXRR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYdV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYdW; else goto cfYdX;
       cfYdW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYdX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fEqSum_$c==_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYdY,
                       label: Data.Functor.Sum.$fEqSum_$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYdY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYe2; else goto cfYe1;
       cfYe2: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEqSum_$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYe1: // global
           I64[Hp - 16] = sat_sfXRR_info;
           P64[Hp] = R4;
           R6 = R6;
           R5 = R5;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fEq1Sum_$cliftEq_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.987827297 UTC

[section ""data" . Data.Functor.Sum.$fEqSum_$c/=_closure" {
     Data.Functor.Sum.$fEqSum_$c/=_closure:
         const Data.Functor.Sum.$fEqSum_$c/=_info;
 },
 sat_sfXS1_entry() //  [R1]
         { info_tbl: [(cfYel,
                       label: sat_sfXS1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYel: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYem; else goto cfYen;
       cfYem: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYen: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXS8_entry() //  [R1]
         { info_tbl: [(cfYeA,
                       label: sat_sfXS8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYeA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYeB; else goto cfYeC;
       cfYeB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYeC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fEqSum_$c/=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYeH,
                       label: Data.Functor.Sum.$fEqSum_$c/=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYeH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYeI; else goto cfYeJ;
       cfYeI: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEqSum_$c/=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYeJ: // global
           I64[Sp - 40] = block_cfYe7_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYfD; else goto cfYe8;
       ufYfD: // global
           call _cfYe7(R1) args: 0, res: 0, upd: 0;
       cfYe8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYe7() //  [R1]
         { info_tbl: [(cfYe7,
                       label: block_cfYe7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYe7: // global
           _sfXRW::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfYeE; else goto cfYeF;
       cfYeE: // global
           I64[Sp] = block_cfYec_info;
           _sfXRY::P64 = P64[R1 + 7];
           R1 = _sfXRW::P64;
           P64[Sp + 32] = _sfXRY::P64;
           if (R1 & 7 != 0) goto ufYfz; else goto cfYed;
       ufYfz: // global
           call _cfYec(R1) args: 0, res: 0, upd: 0;
       cfYed: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfYeF: // global
           I64[Sp + 8] = block_cfYeq_info;
           _sfXS4::P64 = P64[R1 + 6];
           R1 = _sfXRW::P64;
           P64[Sp + 32] = _sfXS4::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufYfA; else goto cfYer;
       ufYfA: // global
           call _cfYeq(R1) args: 0, res: 0, upd: 0;
       cfYer: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYec() //  [R1]
         { info_tbl: [(cfYec,
                       label: block_cfYec_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYec: // global
           if (R1 & 7 == 1) goto cfYeN; else goto ufYfw;
       cfYeN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYeQ; else goto cfYeP;
       cfYeQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYeP: // global
           _sfXS0::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXS1_info;
           P64[Hp] = P64[Sp + 24];
           _sfXRY::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cfYeL_info;
           R4 = _sfXS0::P64;
           R3 = _sfXRY::P64;
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ufYfw: // global
           Sp = Sp + 40;
           call _cfYfk() args: 0, res: 0, upd: 0;
     }
 },
 _cfYeL() //  [R1]
         { info_tbl: [(cfYeL,
                       label: block_cfYeL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYeL: // global
           if (R1 & 7 == 1) goto ufYfx; else goto ufYfy;
       ufYfx: // global
           Sp = Sp + 8;
           call _cfYfk() args: 0, res: 0, upd: 0;
       ufYfy: // global
           Sp = Sp + 8;
           call _cfYfo() args: 0, res: 0, upd: 0;
     }
 },
 _cfYeq() //  [R1]
         { info_tbl: [(cfYeq,
                       label: block_cfYeq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYeq: // global
           if (R1 & 7 == 1) goto ufYft; else goto cfYfb;
       ufYft: // global
           Sp = Sp + 32;
           call _cfYfk() args: 0, res: 0, upd: 0;
       cfYfb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYfe; else goto cfYfd;
       cfYfe: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYfd: // global
           _sfXS7::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXS8_info;
           P64[Hp] = P64[Sp + 16];
           _sfXS4::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cfYfa_info;
           R4 = _sfXS7::P64;
           R3 = _sfXS4::P64;
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYfa() //  [R1]
         { info_tbl: [(cfYfa,
                       label: block_cfYfa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYfa: // global
           if (R1 & 7 == 1) goto ufYfu; else goto ufYfv;
       ufYfu: // global
           Sp = Sp + 8;
           call _cfYfk() args: 0, res: 0, upd: 0;
       ufYfv: // global
           Sp = Sp + 8;
           call _cfYfo() args: 0, res: 0, upd: 0;
     }
 },
 _cfYfk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYfk: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYfo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYfo: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.991392917 UTC

[section ""data" . Data.Functor.Sum.$fEqSum_closure" {
     Data.Functor.Sum.$fEqSum_closure:
         const Data.Functor.Sum.$fEqSum_info;
 },
 sat_sfXSe_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYfR,
                       label: sat_sfXSe_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYfR: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fEqSum_$c/=_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXSd_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYfZ,
                       label: sat_sfXSd_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYfZ: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fEqSum_$c==_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fEqSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYg3,
                       label: Data.Functor.Sum.$fEqSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYg3: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfYg7; else goto cfYg6;
       cfYg7: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEqSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYg6: // global
           I64[Hp - 80] = sat_sfXSe_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sfXSd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 78;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.99305471 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$ccompare_closure" {
     Data.Functor.Sum.$fOrdSum_$ccompare_closure:
         const Data.Functor.Sum.$fOrdSum_$ccompare_info;
 },
 sat_sfXSk_entry() //  [R1]
         { info_tbl: [(cfYgg,
                       label: sat_sfXSk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYgg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYgh; else goto cfYgi;
       cfYgh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYgi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$ccompare_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cfYgj,
                       label: Data.Functor.Sum.$fOrdSum_$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYgj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYgn; else goto cfYgm;
       cfYgn: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYgm: // global
           I64[Hp - 16] = sat_sfXSk_info;
           P64[Hp] = R4;
           R6 = R6;
           R5 = R5;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fOrd1Sum_$cliftCompare_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.994690181 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$cp1Ord_closure" {
     Data.Functor.Sum.$fOrdSum_$cp1Ord_closure:
         const Data.Functor.Sum.$fOrdSum_$cp1Ord_info;
 },
 sat_sfXSq_entry() //  [R1]
         { info_tbl: [(cfYgw,
                       label: sat_sfXSq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYgw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYgx; else goto cfYgy;
       cfYgx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYgy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXSp_entry() //  [R1]
         { info_tbl: [(cfYgD,
                       label: sat_sfXSp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYgD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYgE; else goto cfYgF;
       cfYgE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYgF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXSo_entry() //  [R1]
         { info_tbl: [(cfYgK,
                       label: sat_sfXSo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYgK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYgL; else goto cfYgM;
       cfYgL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYgM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$cp1Ord_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYgN,
                       label: Data.Functor.Sum.$fOrdSum_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYgN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfYgR; else goto cfYgQ;
       cfYgR: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$cp1Ord_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYgQ: // global
           I64[Hp - 64] = sat_sfXSq_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sfXSp_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sfXSo_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Sum.$fEqSum_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.997488156 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c<_closure" {
     Data.Functor.Sum.$fOrdSum_$c<_closure:
         const Data.Functor.Sum.$fOrdSum_$c<_info;
 },
 sat_sfXSA_entry() //  [R1]
         { info_tbl: [(cfYha,
                       label: sat_sfXSA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYha: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYhb; else goto cfYhc;
       cfYhb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYhc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXSH_entry() //  [R1]
         { info_tbl: [(cfYhp,
                       label: sat_sfXSH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYhp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYhq; else goto cfYhr;
       cfYhq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYhr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYhw,
                       label: Data.Functor.Sum.$fOrdSum_$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYhw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYhx; else goto cfYhy;
       cfYhx: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYhy: // global
           I64[Sp - 40] = block_cfYgW_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYis; else goto cfYgX;
       ufYis: // global
           call _cfYgW(R1) args: 0, res: 0, upd: 0;
       cfYgX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYgW() //  [R1]
         { info_tbl: [(cfYgW,
                       label: block_cfYgW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYgW: // global
           _sfXSv::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfYht; else goto cfYhu;
       cfYht: // global
           I64[Sp] = block_cfYh1_info;
           _sfXSx::P64 = P64[R1 + 7];
           R1 = _sfXSv::P64;
           P64[Sp + 32] = _sfXSx::P64;
           if (R1 & 7 != 0) goto ufYio; else goto cfYh2;
       ufYio: // global
           call _cfYh1(R1) args: 0, res: 0, upd: 0;
       cfYh2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfYhu: // global
           I64[Sp + 8] = block_cfYhf_info;
           _sfXSD::P64 = P64[R1 + 6];
           R1 = _sfXSv::P64;
           P64[Sp + 32] = _sfXSD::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufYip; else goto cfYhg;
       ufYip: // global
           call _cfYhf(R1) args: 0, res: 0, upd: 0;
       cfYhg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYh1() //  [R1]
         { info_tbl: [(cfYh1,
                       label: block_cfYh1_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYh1: // global
           if (R1 & 7 == 1) goto cfYhC; else goto ufYil;
       cfYhC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYhF; else goto cfYhE;
       cfYhF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYhE: // global
           _sfXSz::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXSA_info;
           P64[Hp] = P64[Sp + 24];
           _sfXSx::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cfYhA_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sfXSx::P64;
           P64[Sp + 24] = _sfXSz::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ufYil: // global
           Sp = Sp + 40;
           call _cfYid() args: 0, res: 0, upd: 0;
     }
 },
 _cfYhA() //  [R1]
         { info_tbl: [(cfYhA,
                       label: block_cfYhA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYhA: // global
           if (R1 & 7 == 1) goto ufYim; else goto ufYin;
       ufYim: // global
           Sp = Sp + 8;
           call _cfYid() args: 0, res: 0, upd: 0;
       ufYin: // global
           Sp = Sp + 8;
           call _cfYi9() args: 0, res: 0, upd: 0;
     }
 },
 _cfYhf() //  [R1]
         { info_tbl: [(cfYhf,
                       label: block_cfYhf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYhf: // global
           if (R1 & 7 == 1) goto ufYii; else goto cfYi0;
       ufYii: // global
           Sp = Sp + 32;
           call _cfYi9() args: 0, res: 0, upd: 0;
       cfYi0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYi3; else goto cfYi2;
       cfYi3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYi2: // global
           _sfXSG::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXSH_info;
           P64[Hp] = P64[Sp + 16];
           _sfXSD::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cfYhZ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sfXSD::P64;
           P64[Sp + 16] = _sfXSG::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfYhZ() //  [R1]
         { info_tbl: [(cfYhZ,
                       label: block_cfYhZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYhZ: // global
           if (R1 & 7 == 1) goto ufYij; else goto ufYik;
       ufYij: // global
           Sp = Sp + 8;
           call _cfYid() args: 0, res: 0, upd: 0;
       ufYik: // global
           Sp = Sp + 8;
           call _cfYi9() args: 0, res: 0, upd: 0;
     }
 },
 _cfYid() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYid: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYi9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYi9: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.001563279 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c>=_closure" {
     Data.Functor.Sum.$fOrdSum_$c>=_closure:
         const Data.Functor.Sum.$fOrdSum_$c>=_info;
 },
 sat_sfXSS_entry() //  [R1]
         { info_tbl: [(cfYiP,
                       label: sat_sfXSS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYiP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYiQ; else goto cfYiR;
       cfYiQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYiR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXSZ_entry() //  [R1]
         { info_tbl: [(cfYj4,
                       label: sat_sfXSZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYj4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYj5; else goto cfYj6;
       cfYj5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYj6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c>=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYjb,
                       label: Data.Functor.Sum.$fOrdSum_$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYjb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYjc; else goto cfYjd;
       cfYjc: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYjd: // global
           I64[Sp - 40] = block_cfYiB_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYk7; else goto cfYiC;
       ufYk7: // global
           call _cfYiB(R1) args: 0, res: 0, upd: 0;
       cfYiC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYiB() //  [R1]
         { info_tbl: [(cfYiB,
                       label: block_cfYiB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYiB: // global
           _sfXSN::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfYj8; else goto cfYj9;
       cfYj8: // global
           I64[Sp] = block_cfYiG_info;
           _sfXSP::P64 = P64[R1 + 7];
           R1 = _sfXSN::P64;
           P64[Sp + 32] = _sfXSP::P64;
           if (R1 & 7 != 0) goto ufYk3; else goto cfYiH;
       ufYk3: // global
           call _cfYiG(R1) args: 0, res: 0, upd: 0;
       cfYiH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfYj9: // global
           I64[Sp + 8] = block_cfYiU_info;
           _sfXSV::P64 = P64[R1 + 6];
           R1 = _sfXSN::P64;
           P64[Sp + 32] = _sfXSV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufYk4; else goto cfYiV;
       ufYk4: // global
           call _cfYiU(R1) args: 0, res: 0, upd: 0;
       cfYiV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYiG() //  [R1]
         { info_tbl: [(cfYiG,
                       label: block_cfYiG_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYiG: // global
           if (R1 & 7 == 1) goto cfYjh; else goto ufYk0;
       cfYjh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYjk; else goto cfYjj;
       cfYjk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYjj: // global
           _sfXSR::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXSS_info;
           P64[Hp] = P64[Sp + 24];
           _sfXSP::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cfYjf_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sfXSP::P64;
           P64[Sp + 24] = _sfXSR::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ufYk0: // global
           Sp = Sp + 40;
           call _cfYjS() args: 0, res: 0, upd: 0;
     }
 },
 _cfYjf() //  [R1]
         { info_tbl: [(cfYjf,
                       label: block_cfYjf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYjf: // global
           if (R1 & 7 == 1) goto ufYk1; else goto ufYk2;
       ufYk1: // global
           Sp = Sp + 8;
           call _cfYjS() args: 0, res: 0, upd: 0;
       ufYk2: // global
           Sp = Sp + 8;
           call _cfYjO() args: 0, res: 0, upd: 0;
     }
 },
 _cfYiU() //  [R1]
         { info_tbl: [(cfYiU,
                       label: block_cfYiU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYiU: // global
           if (R1 & 7 == 1) goto ufYjX; else goto cfYjF;
       ufYjX: // global
           Sp = Sp + 32;
           call _cfYjO() args: 0, res: 0, upd: 0;
       cfYjF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYjI; else goto cfYjH;
       cfYjI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYjH: // global
           _sfXSY::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXSZ_info;
           P64[Hp] = P64[Sp + 16];
           _sfXSV::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cfYjE_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sfXSV::P64;
           P64[Sp + 16] = _sfXSY::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfYjE() //  [R1]
         { info_tbl: [(cfYjE,
                       label: block_cfYjE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYjE: // global
           if (R1 & 7 == 1) goto ufYjY; else goto ufYjZ;
       ufYjY: // global
           Sp = Sp + 8;
           call _cfYjS() args: 0, res: 0, upd: 0;
       ufYjZ: // global
           Sp = Sp + 8;
           call _cfYjO() args: 0, res: 0, upd: 0;
     }
 },
 _cfYjS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYjS: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYjO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYjO: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.005641612 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c>_closure" {
     Data.Functor.Sum.$fOrdSum_$c>_closure:
         const Data.Functor.Sum.$fOrdSum_$c>_info;
 },
 sat_sfXTa_entry() //  [R1]
         { info_tbl: [(cfYku,
                       label: sat_sfXTa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYku: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYkv; else goto cfYkw;
       cfYkv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYkw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXTh_entry() //  [R1]
         { info_tbl: [(cfYkJ,
                       label: sat_sfXTh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYkJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYkK; else goto cfYkL;
       cfYkK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYkL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYkQ,
                       label: Data.Functor.Sum.$fOrdSum_$c>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYkQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYkR; else goto cfYkS;
       cfYkR: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYkS: // global
           I64[Sp - 40] = block_cfYkg_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYlM; else goto cfYkh;
       ufYlM: // global
           call _cfYkg(R1) args: 0, res: 0, upd: 0;
       cfYkh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYkg() //  [R1]
         { info_tbl: [(cfYkg,
                       label: block_cfYkg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYkg: // global
           _sfXT5::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfYkN; else goto cfYkO;
       cfYkN: // global
           I64[Sp] = block_cfYkl_info;
           _sfXT7::P64 = P64[R1 + 7];
           R1 = _sfXT5::P64;
           P64[Sp + 32] = _sfXT7::P64;
           if (R1 & 7 != 0) goto ufYlI; else goto cfYkm;
       ufYlI: // global
           call _cfYkl(R1) args: 0, res: 0, upd: 0;
       cfYkm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfYkO: // global
           I64[Sp + 8] = block_cfYkz_info;
           _sfXTd::P64 = P64[R1 + 6];
           R1 = _sfXT5::P64;
           P64[Sp + 32] = _sfXTd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufYlJ; else goto cfYkA;
       ufYlJ: // global
           call _cfYkz(R1) args: 0, res: 0, upd: 0;
       cfYkA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYkl() //  [R1]
         { info_tbl: [(cfYkl,
                       label: block_cfYkl_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYkl: // global
           if (R1 & 7 == 1) goto cfYkW; else goto ufYlF;
       cfYkW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYkZ; else goto cfYkY;
       cfYkZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYkY: // global
           _sfXT9::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXTa_info;
           P64[Hp] = P64[Sp + 24];
           _sfXT7::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cfYkU_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sfXT7::P64;
           P64[Sp + 24] = _sfXT9::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ufYlF: // global
           Sp = Sp + 40;
           call _cfYlt() args: 0, res: 0, upd: 0;
     }
 },
 _cfYkU() //  [R1]
         { info_tbl: [(cfYkU,
                       label: block_cfYkU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYkU: // global
           if (R1 & 7 == 3) goto ufYlG; else goto ufYlH;
       ufYlG: // global
           Sp = Sp + 8;
           call _cfYlx() args: 0, res: 0, upd: 0;
       ufYlH: // global
           Sp = Sp + 8;
           call _cfYlt() args: 0, res: 0, upd: 0;
     }
 },
 _cfYkz() //  [R1]
         { info_tbl: [(cfYkz,
                       label: block_cfYkz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYkz: // global
           if (R1 & 7 == 1) goto ufYlC; else goto cfYlk;
       ufYlC: // global
           Sp = Sp + 32;
           call _cfYlx() args: 0, res: 0, upd: 0;
       cfYlk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYln; else goto cfYlm;
       cfYln: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYlm: // global
           _sfXTg::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXTh_info;
           P64[Hp] = P64[Sp + 16];
           _sfXTd::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cfYlj_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sfXTd::P64;
           P64[Sp + 16] = _sfXTg::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfYlj() //  [R1]
         { info_tbl: [(cfYlj,
                       label: block_cfYlj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYlj: // global
           if (R1 & 7 == 3) goto ufYlD; else goto ufYlE;
       ufYlD: // global
           Sp = Sp + 8;
           call _cfYlx() args: 0, res: 0, upd: 0;
       ufYlE: // global
           Sp = Sp + 8;
           call _cfYlt() args: 0, res: 0, upd: 0;
     }
 },
 _cfYlx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYlx: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYlt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYlt: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.009724792 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c<=_closure" {
     Data.Functor.Sum.$fOrdSum_$c<=_closure:
         const Data.Functor.Sum.$fOrdSum_$c<=_info;
 },
 sat_sfXTs_entry() //  [R1]
         { info_tbl: [(cfYm9,
                       label: sat_sfXTs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYm9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYma; else goto cfYmb;
       cfYma: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYmb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXTz_entry() //  [R1]
         { info_tbl: [(cfYmo,
                       label: sat_sfXTz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYmo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYmp; else goto cfYmq;
       cfYmp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYmq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYmv,
                       label: Data.Functor.Sum.$fOrdSum_$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYmv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYmw; else goto cfYmx;
       cfYmw: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYmx: // global
           I64[Sp - 40] = block_cfYlV_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYnr; else goto cfYlW;
       ufYnr: // global
           call _cfYlV(R1) args: 0, res: 0, upd: 0;
       cfYlW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYlV() //  [R1]
         { info_tbl: [(cfYlV,
                       label: block_cfYlV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYlV: // global
           _sfXTn::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfYms; else goto cfYmt;
       cfYms: // global
           I64[Sp] = block_cfYm0_info;
           _sfXTp::P64 = P64[R1 + 7];
           R1 = _sfXTn::P64;
           P64[Sp + 32] = _sfXTp::P64;
           if (R1 & 7 != 0) goto ufYnn; else goto cfYm1;
       ufYnn: // global
           call _cfYm0(R1) args: 0, res: 0, upd: 0;
       cfYm1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfYmt: // global
           I64[Sp + 8] = block_cfYme_info;
           _sfXTv::P64 = P64[R1 + 6];
           R1 = _sfXTn::P64;
           P64[Sp + 32] = _sfXTv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufYno; else goto cfYmf;
       ufYno: // global
           call _cfYme(R1) args: 0, res: 0, upd: 0;
       cfYmf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYm0() //  [R1]
         { info_tbl: [(cfYm0,
                       label: block_cfYm0_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYm0: // global
           if (R1 & 7 == 1) goto cfYmB; else goto ufYnk;
       cfYmB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYmE; else goto cfYmD;
       cfYmE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYmD: // global
           _sfXTr::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXTs_info;
           P64[Hp] = P64[Sp + 24];
           _sfXTp::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cfYmz_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sfXTp::P64;
           P64[Sp + 24] = _sfXTr::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ufYnk: // global
           Sp = Sp + 40;
           call _cfYn8() args: 0, res: 0, upd: 0;
     }
 },
 _cfYmz() //  [R1]
         { info_tbl: [(cfYmz,
                       label: block_cfYmz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYmz: // global
           if (R1 & 7 == 3) goto ufYnl; else goto ufYnm;
       ufYnl: // global
           Sp = Sp + 8;
           call _cfYnc() args: 0, res: 0, upd: 0;
       ufYnm: // global
           Sp = Sp + 8;
           call _cfYn8() args: 0, res: 0, upd: 0;
     }
 },
 _cfYme() //  [R1]
         { info_tbl: [(cfYme,
                       label: block_cfYme_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYme: // global
           if (R1 & 7 == 1) goto ufYnh; else goto cfYmZ;
       ufYnh: // global
           Sp = Sp + 32;
           call _cfYnc() args: 0, res: 0, upd: 0;
       cfYmZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYn2; else goto cfYn1;
       cfYn2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYn1: // global
           _sfXTy::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXTz_info;
           P64[Hp] = P64[Sp + 16];
           _sfXTv::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cfYmY_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sfXTv::P64;
           P64[Sp + 16] = _sfXTy::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfYmY() //  [R1]
         { info_tbl: [(cfYmY,
                       label: block_cfYmY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYmY: // global
           if (R1 & 7 == 3) goto ufYni; else goto ufYnj;
       ufYni: // global
           Sp = Sp + 8;
           call _cfYnc() args: 0, res: 0, upd: 0;
       ufYnj: // global
           Sp = Sp + 8;
           call _cfYn8() args: 0, res: 0, upd: 0;
     }
 },
 _cfYnc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYnc: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYn8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYn8: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.012833185 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$cmax_closure" {
     Data.Functor.Sum.$fOrdSum_$cmax_closure:
         const Data.Functor.Sum.$fOrdSum_$cmax_info;
 },
 Data.Functor.Sum.$fOrdSum_$cmax_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYnG,
                       label: Data.Functor.Sum.$fOrdSum_$cmax_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYnG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfYnH; else goto cfYnI;
       cfYnH: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$cmax_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYnI: // global
           I64[Sp - 24] = block_cfYnA_info;
           _sfXTF::P64 = R6;
           R6 = R6;
           _sfXTE::P64 = R5;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           P64[Sp - 16] = _sfXTE::P64;
           P64[Sp - 8] = _sfXTF::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fOrdSum_$c<=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfYnA() //  [R1]
         { info_tbl: [(cfYnA,
                       label: block_cfYnA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYnA: // global
           if (R1 & 7 == 1) goto cfYnD; else goto cfYnE;
       cfYnD: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfYnE: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.014278515 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$cmin_closure" {
     Data.Functor.Sum.$fOrdSum_$cmin_closure:
         const Data.Functor.Sum.$fOrdSum_$cmin_info;
 },
 Data.Functor.Sum.$fOrdSum_$cmin_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYnZ,
                       label: Data.Functor.Sum.$fOrdSum_$cmin_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYnZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfYo0; else goto cfYo1;
       cfYo0: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$cmin_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYo1: // global
           I64[Sp - 24] = block_cfYnT_info;
           _sfXTL::P64 = R6;
           R6 = R6;
           _sfXTK::P64 = R5;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           P64[Sp - 16] = _sfXTK::P64;
           P64[Sp - 8] = _sfXTL::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fOrdSum_$c<=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfYnT() //  [R1]
         { info_tbl: [(cfYnT,
                       label: block_cfYnT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYnT: // global
           if (R1 & 7 == 1) goto cfYnW; else goto cfYnX;
       cfYnW: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfYnX: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.016619223 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_closure" {
     Data.Functor.Sum.$fOrdSum_closure:
         const Data.Functor.Sum.$fOrdSum_info;
 },
 sat_sfXTX_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYoh,
                       label: sat_sfXTX_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYoh: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$cmin_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTW_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYop,
                       label: sat_sfXTW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYop: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$cmax_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTV_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYox,
                       label: sat_sfXTV_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYox: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c>=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTU_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYoF,
                       label: sat_sfXTU_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYoF: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c>_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTT_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYoN,
                       label: sat_sfXTT_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYoN: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c<=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTS_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYoV,
                       label: sat_sfXTS_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYoV: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c<_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTR_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYp3,
                       label: sat_sfXTR_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYp3: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$ccompare_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTQ_entry() //  [R1]
         { info_tbl: [(cfYpa,
                       label: sat_sfXTQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYpa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYpb; else goto cfYpc;
       cfYpb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYpc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fOrdSum_$cp1Ord_entry(R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYpe,
                       label: Data.Functor.Sum.$fOrdSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYpe: // global
           Hp = Hp + 336;
           if (Hp > HpLim) (likely: False) goto cfYpi; else goto cfYph;
       cfYpi: // global
           HpAlloc = 336;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYph: // global
           I64[Hp - 328] = sat_sfXTX_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           I64[Hp - 296] = sat_sfXTW_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           P64[Hp - 272] = R4;
           I64[Hp - 264] = sat_sfXTV_info;
           P64[Hp - 256] = R2;
           P64[Hp - 248] = R3;
           P64[Hp - 240] = R4;
           I64[Hp - 232] = sat_sfXTU_info;
           P64[Hp - 224] = R2;
           P64[Hp - 216] = R3;
           P64[Hp - 208] = R4;
           I64[Hp - 200] = sat_sfXTT_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           P64[Hp - 176] = R4;
           I64[Hp - 168] = sat_sfXTS_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = sat_sfXTR_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sat_sfXTQ_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 104;
           P64[Hp - 48] = Hp - 134;
           P64[Hp - 40] = Hp - 166;
           P64[Hp - 32] = Hp - 198;
           P64[Hp - 24] = Hp - 230;
           P64[Hp - 16] = Hp - 262;
           P64[Hp - 8] = Hp - 294;
           P64[Hp] = Hp - 326;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.020211162 UTC

[section ""data" . Data.Functor.Sum.$fReadSum1_closure" {
     Data.Functor.Sum.$fReadSum1_closure:
         const Data.Functor.Sum.$fReadSum1_info;
         const 0;
 },
 sat_sfXU2_entry() //  [R1]
         { info_tbl: [(cfYpr,
                       label: sat_sfXU2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYpr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYps; else goto cfYpt;
       cfYps: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYpt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXU1_entry() //  [R1]
         { info_tbl: [(cfYpy,
                       label: sat_sfXU1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYpy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYpz; else goto cfYpA;
       cfYpz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYpA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fReadSum1_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYpB,
                       label: Data.Functor.Sum.$fReadSum1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYpB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfYpF; else goto cfYpE;
       cfYpF: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYpE: // global
           I64[Hp - 40] = sat_sfXU2_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sfXU1_info;
           P64[Hp] = R4;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.022470124 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_$creadsPrec_closure" {
     Data.Functor.Sum.$fReadSum_$creadsPrec_closure:
         const Data.Functor.Sum.$fReadSum_$creadsPrec_info;
         const 0;
 },
 sat_sfXU8_entry() //  [R1]
         { info_tbl: [(cfYpS,
                       label: sat_sfXU8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYpS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYpT; else goto cfYpU;
       cfYpT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYpU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXU7_entry() //  [R1]
         { info_tbl: [(cfYpZ,
                       label: sat_sfXU7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYpZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYq0; else goto cfYq1;
       cfYq0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYq1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sfXU6_entry() //  [R1]
         { info_tbl: [(cfYq2,
                       label: ds_sfXU6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYq2: // global
           _sfXU6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfYq3; else goto cfYq4;
       cfYq4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfYq6; else goto cfYq5;
       cfYq6: // global
           HpAlloc = 48;
           goto cfYq3;
       cfYq3: // global
           R1 = _sfXU6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYq5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXU6::P64;
           _sfXU3::P64 = P64[_sfXU6::P64 + 16];
           _sfXU4::P64 = P64[_sfXU6::P64 + 24];
           _sfXU5::P64 = P64[_sfXU6::P64 + 32];
           I64[Hp - 40] = sat_sfXU8_info;
           P64[Hp - 24] = _sfXU5::P64;
           I64[Hp - 16] = sat_sfXU7_info;
           P64[Hp] = _sfXU5::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sfXU4::P64;
           R2 = _sfXU3::P64;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUa_entry() //  [R1]
         { info_tbl: [(cfYqg,
                       label: sat_sfXUa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYqg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYqh; else goto cfYqi;
       cfYqh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYqi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUb_entry() //  [R1, R2]
         { info_tbl: [(cfYqj,
                       label: sat_sfXUb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYqj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfYqn; else goto cfYqm;
       cfYqn: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYqm: // global
           _sfXU6::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sfXUa_info;
           P64[Hp - 8] = _sfXU6::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fReadSum_$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYqo,
                       label: Data.Functor.Sum.$fReadSum_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYqo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfYqs; else goto cfYqr;
       cfYqs: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYqr: // global
           I64[Hp - 48] = ds_sfXU6_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sfXUb_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.025392146 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_$creadListPrec_closure" {
     Data.Functor.Sum.$fReadSum_$creadListPrec_closure:
         const Data.Functor.Sum.$fReadSum_$creadListPrec_info;
         const 0;
 },
 sat_sfXUg_entry() //  [R1]
         { info_tbl: [(cfYqF,
                       label: sat_sfXUg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYqF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYqG; else goto cfYqH;
       cfYqG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYqH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUf_entry() //  [R1]
         { info_tbl: [(cfYqM,
                       label: sat_sfXUf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYqM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYqN; else goto cfYqO;
       cfYqN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYqO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUh_entry() //  [R1]
         { info_tbl: [(cfYqP,
                       label: sat_sfXUh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYqP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfYqT; else goto cfYqS;
       cfYqT: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYqS: // global
           _sfXUc::P64 = P64[R1 + 16];
           _sfXUd::P64 = P64[R1 + 24];
           _sfXUe::P64 = P64[R1 + 32];
           I64[Hp - 40] = sat_sfXUg_info;
           P64[Hp - 24] = _sfXUe::P64;
           I64[Hp - 16] = sat_sfXUf_info;
           P64[Hp] = _sfXUe::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sfXUd::P64;
           R2 = _sfXUc::P64;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fReadSum_$creadListPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYqU,
                       label: Data.Functor.Sum.$fReadSum_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYqU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfYqY; else goto cfYqX;
       cfYqY: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_$creadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYqX: // global
           I64[Hp - 32] = sat_sfXUh_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.027380401 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_$creadList_closure" {
     Data.Functor.Sum.$fReadSum_$creadList_closure:
         const Data.Functor.Sum.$fReadSum_$creadList_info;
         const 0;
 },
 sat_sfXUl_entry() //  [R1]
         { info_tbl: [(cfYr7,
                       label: sat_sfXUl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYr7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYr8; else goto cfYr9;
       cfYr8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYr9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call Data.Functor.Sum.$fReadSum_$creadListPrec_entry(R4,
                                                                R3,
                                                                R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fReadSum_$creadList_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYra,
                       label: Data.Functor.Sum.$fReadSum_$creadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYra: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfYre; else goto cfYrd;
       cfYre: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_$creadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYrd: // global
           I64[Hp - 32] = sat_sfXUl_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.029373693 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_closure" {
     Data.Functor.Sum.$fReadSum_closure:
         const Data.Functor.Sum.$fReadSum_info;
         const 0;
 },
 sat_sfXUs_entry() //  [R1]
         { info_tbl: [(cfYrn,
                       label: sat_sfXUs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYrn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYro; else goto cfYrp;
       cfYro: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYrp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum_$creadListPrec_entry(R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUr_entry() //  [R1]
         { info_tbl: [(cfYru,
                       label: sat_sfXUr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYru: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYrv; else goto cfYrw;
       cfYrv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYrw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum1_entry(R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUq_entry() //  [R1]
         { info_tbl: [(cfYrB,
                       label: sat_sfXUq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYrB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYrC; else goto cfYrD;
       cfYrC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYrD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum_$creadList_entry(R4,
                                                            R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUp_entry() //  [R1]
         { info_tbl: [(cfYrI,
                       label: sat_sfXUp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYrI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYrJ; else goto cfYrK;
       cfYrJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYrK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum_$creadsPrec_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fReadSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYrM,
                       label: Data.Functor.Sum.$fReadSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYrM: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cfYrQ; else goto cfYrP;
       cfYrQ: // global
           HpAlloc = 200;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYrP: // global
           I64[Hp - 192] = sat_sfXUs_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           I64[Hp - 152] = sat_sfXUr_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_sfXUq_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sfXUp_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.032054144 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_$cshowsPrec_closure" {
     Data.Functor.Sum.$fShowSum_$cshowsPrec_closure:
         const Data.Functor.Sum.$fShowSum_$cshowsPrec_info;
         const 0;
 },
 sat_sfXUB_entry() //  [R1]
         { info_tbl: [(cfYs4,
                       label: sat_sfXUB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYs4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYs5; else goto cfYs6;
       cfYs5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYs6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUA_entry() //  [R1]
         { info_tbl: [(cfYsb,
                       label: sat_sfXUA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYsb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYsc; else goto cfYsd;
       cfYsc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYsd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fShowSum_$cshowsPrec_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cfYse,
                       label: Data.Functor.Sum.$fShowSum_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYse: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYsf; else goto cfYsg;
       cfYsf: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_$cshowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYsg: // global
           I64[Sp - 40] = block_cfYrV_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYsk; else goto cfYrW;
       ufYsk: // global
           call _cfYrV(R1) args: 0, res: 0, upd: 0;
       cfYrW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYrV() //  [R1]
         { info_tbl: [(cfYrV,
                       label: block_cfYrV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYrV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfYsj; else goto cfYsi;
       cfYsj: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYsi: // global
           _sfXUz::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sfXUB_info;
           _sfXUv::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sfXUv::P64;
           I64[Hp - 16] = sat_sfXUA_info;
           P64[Hp] = _sfXUv::P64;
           R6 = _sfXUz::I64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.035129026 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_$cshow_closure" {
     Data.Functor.Sum.$fShowSum_$cshow_closure:
         const Data.Functor.Sum.$fShowSum_$cshow_info;
         const 0;
 },
 sat_sfXUJ_entry() //  [R1]
         { info_tbl: [(cfYsC,
                       label: sat_sfXUJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYsC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYsD; else goto cfYsE;
       cfYsD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYsE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUI_entry() //  [R1]
         { info_tbl: [(cfYsJ,
                       label: sat_sfXUI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYsJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYsK; else goto cfYsL;
       cfYsK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYsL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUK_entry() //  [R1]
         { info_tbl: [(cfYsM,
                       label: sat_sfXUK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYsM: // global
           _sfXUK::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cfYsN; else goto cfYsO;
       cfYsO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfYsQ; else goto cfYsP;
       cfYsQ: // global
           HpAlloc = 48;
           goto cfYsN;
       cfYsN: // global
           R1 = _sfXUK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYsP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXUK::P64;
           _sfXUC::P64 = P64[_sfXUK::P64 + 16];
           _sfXUE::P64 = P64[_sfXUK::P64 + 24];
           _sfXUH::P64 = P64[_sfXUK::P64 + 32];
           I64[Hp - 40] = sat_sfXUJ_info;
           P64[Hp - 24] = _sfXUE::P64;
           I64[Hp - 16] = sat_sfXUI_info;
           P64[Hp] = _sfXUE::P64;
           R2 = _sfXUC::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = Hp - 16;
           P64[Sp - 48] = Hp - 40;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sfXUH::P64;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 sat_sfXUO_entry() //  [R1]
         { info_tbl: [(cfYt1,
                       label: sat_sfXUO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYt1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYt2; else goto cfYt3;
       cfYt2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYt3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUN_entry() //  [R1]
         { info_tbl: [(cfYt8,
                       label: sat_sfXUN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYt8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYt9; else goto cfYta;
       cfYt9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYta: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUP_entry() //  [R1]
         { info_tbl: [(cfYtb,
                       label: sat_sfXUP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYtb: // global
           _sfXUP::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cfYtc; else goto cfYtd;
       cfYtd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfYtf; else goto cfYte;
       cfYtf: // global
           HpAlloc = 48;
           goto cfYtc;
       cfYtc: // global
           R1 = _sfXUP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYte: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXUP::P64;
           _sfXUD::P64 = P64[_sfXUP::P64 + 16];
           _sfXUE::P64 = P64[_sfXUP::P64 + 24];
           _sfXUM::P64 = P64[_sfXUP::P64 + 32];
           I64[Hp - 40] = sat_sfXUO_info;
           P64[Hp - 24] = _sfXUE::P64;
           I64[Hp - 16] = sat_sfXUN_info;
           P64[Hp] = _sfXUE::P64;
           R2 = _sfXUD::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = Hp - 16;
           P64[Sp - 48] = Hp - 40;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sfXUM::P64;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fShowSum_$cshow_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfYtk,
                       label: Data.Functor.Sum.$fShowSum_$cshow_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYtk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYtl; else goto cfYtm;
       cfYtl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_$cshow_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYtm: // global
           I64[Sp - 32] = block_cfYsp_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufYtv; else goto cfYsq;
       ufYtv: // global
           call _cfYsp(R1) args: 0, res: 0, upd: 0;
       cfYsq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYsp() //  [R1]
         { info_tbl: [(cfYsp,
                       label: block_cfYsp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYsp: // global
           _sfXUE::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfYth; else goto cfYti;
       cfYth: // global
           Hp = Hp + 64;
           _sfXUG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYtu; else goto cfYtp;
       cfYtp: // global
           _sfXUH::P64 = P64[_sfXUG::P64 + 7];
           I64[Hp - 56] = sat_sfXUK_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sfXUE::P64;
           P64[Hp - 24] = _sfXUH::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = Data.Functor.Sum.$fRead1Sum7_closure;
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cfYti: // global
           Hp = Hp + 64;
           _sfXUG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYtu; else goto cfYtt;
       cfYtu: // global
           HpAlloc = 64;
           R1 = _sfXUG::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYtt: // global
           _sfXUM::P64 = P64[_sfXUG::P64 + 6];
           I64[Hp - 56] = sat_sfXUP_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = _sfXUE::P64;
           P64[Hp - 24] = _sfXUM::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = Data.Functor.Sum.$fRead1Sum3_closure;
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.039006923 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_$cshowList_closure" {
     Data.Functor.Sum.$fShowSum_$cshowList_closure:
         const Data.Functor.Sum.$fShowSum_$cshowList_info;
         const 0;
 },
 lvl8_sfXUW_entry() //  [R1]
         { info_tbl: [(cfYtE,
                       label: lvl8_sfXUW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYtE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYtF; else goto cfYtG;
       cfYtF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYtG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sfXUX_entry() //  [R1]
         { info_tbl: [(cfYtL,
                       label: lvl9_sfXUX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYtL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYtM; else goto cfYtN;
       cfYtM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYtN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUZ_entry() //  [R1, R2]
         { info_tbl: [(cfYtT,
                       label: sat_sfXUZ_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYtT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYtU; else goto cfYtV;
       cfYtU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYtV: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sfXUY::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sfXUY::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShowSum_$cshowList_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cfYtW,
                       label: Data.Functor.Sum.$fShowSum_$cshowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYtW: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfYu0; else goto cfYtZ;
       cfYu0: // global
           HpAlloc = 88;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_$cshowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYtZ: // global
           I64[Hp - 80] = lvl8_sfXUW_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl9_sfXUX_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sfXUZ_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 31;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.044795504 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_closure" {
     Data.Functor.Sum.$fShowSum_closure:
         const Data.Functor.Sum.$fShowSum_info;
         const 0;
 },
 sat_sfXV5_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYua,
                       label: sat_sfXV5_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYua: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fShowSum_$cshowList_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXV4_entry() //  [R1, R2]
         { info_tbl: [(cfYui,
                       label: sat_sfXV4_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYui: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fShowSum_$cshow_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXV3_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYuq,
                       label: sat_sfXV3_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYuq: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fShowSum_$cshowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShowSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYuu,
                       label: Data.Functor.Sum.$fShowSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYuu: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cfYuy; else goto cfYux;
       cfYuy: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYux: // global
           I64[Hp - 120] = sat_sfXV5_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sfXV4_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sfXV3_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 118;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.047123692 UTC

[section ""data" . Data.Functor.Sum.$fFunctorSum_$cfmap_closure" {
     Data.Functor.Sum.$fFunctorSum_$cfmap_closure:
         const Data.Functor.Sum.$fFunctorSum_$cfmap_info;
 },
 sat_sfXVc_entry() //  [R1]
         { info_tbl: [(cfYuM,
                       label: sat_sfXVc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYuM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYuN; else goto cfYuO;
       cfYuN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYuO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sfXVe_entry() //  [R1]
         { info_tbl: [(cfYuV,
                       label: sat_sfXVe_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYuV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYuW; else goto cfYuX;
       cfYuW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYuX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fFunctorSum_$cfmap_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfYv2,
                       label: Data.Functor.Sum.$fFunctorSum_$cfmap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYv2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYv3; else goto cfYv4;
       cfYv3: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFunctorSum_$cfmap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYv4: // global
           I64[Sp - 32] = block_cfYuD_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufYvd; else goto cfYuE;
       ufYvd: // global
           call _cfYuD(R1) args: 0, res: 0, upd: 0;
       cfYuE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYuD() //  [R1]
         { info_tbl: [(cfYuD,
                       label: block_cfYuD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYuD: // global
           _sfXV8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfYuZ; else goto cfYv0;
       cfYuZ: // global
           Hp = Hp + 56;
           _sfXVa::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYvc; else goto cfYv7;
       cfYv7: // global
           _sfXVb::P64 = P64[_sfXVa::P64 + 7];
           I64[Hp - 48] = sat_sfXVc_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sfXV8::P64;
           P64[Hp - 16] = _sfXVb::P64;
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfYv0: // global
           Hp = Hp + 56;
           _sfXVa::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYvc; else goto cfYvb;
       cfYvc: // global
           HpAlloc = 56;
           R1 = _sfXVa::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYvb: // global
           _sfXVd::P64 = P64[_sfXVa::P64 + 6];
           I64[Hp - 48] = sat_sfXVe_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sfXV8::P64;
           P64[Hp - 16] = _sfXVd::P64;
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.049348409 UTC

[section ""data" . Data.Functor.Sum.$fFunctorSum_$c<$_closure" {
     Data.Functor.Sum.$fFunctorSum_$c<$_closure:
         const Data.Functor.Sum.$fFunctorSum_$c<$_info;
 },
 sat_sfXVk_entry() //  [R1]
         { info_tbl: [(cfYvn,
                       label: sat_sfXVk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYvn: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFunctorSum_$c<$_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfYvq,
                       label: Data.Functor.Sum.$fFunctorSum_$c<$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYvq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfYvu; else goto cfYvt;
       cfYvu: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFunctorSum_$c<$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYvt: // global
           I64[Hp - 8] = sat_sfXVk_info;
           P64[Hp] = R4;
           R5 = R5;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fFunctorSum_$cfmap_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.050806663 UTC

[section ""data" . Data.Functor.Sum.$fFunctorSum_closure" {
     Data.Functor.Sum.$fFunctorSum_closure:
         const Data.Functor.Sum.$fFunctorSum_info;
 },
 sat_sfXVo_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYvE,
                       label: sat_sfXVo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYvE: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFunctorSum_$c<$_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXVn_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYvM,
                       label: sat_sfXVn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYvM: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFunctorSum_$cfmap_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFunctorSum_entry() //  [R2, R3]
         { info_tbl: [(cfYvQ,
                       label: Data.Functor.Sum.$fFunctorSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYvQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfYvU; else goto cfYvT;
       cfYvU: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFunctorSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYvT: // global
           I64[Hp - 64] = sat_sfXVo_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sfXVn_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.05245801 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldMap_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldMap_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldMap_info;
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldMap_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cfYw6,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYw6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYw7; else goto cfYw8;
       cfYw7: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYw8: // global
           I64[Sp - 40] = block_cfYvZ_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYwf; else goto cfYw0;
       ufYwf: // global
           call _cfYvZ(R1) args: 0, res: 0, upd: 0;
       cfYw0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYvZ() //  [R1]
         { info_tbl: [(cfYvZ,
                       label: block_cfYvZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYvZ: // global
           _sfXVr::P64 = P64[Sp + 24];
           _sfXVs::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfYw3; else goto cfYw4;
       cfYw3: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = _sfXVr::P64;
           P64[Sp + 24] = _sfXVs::P64;
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cfYw4: // global
           R2 = P64[Sp + 16];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = _sfXVr::P64;
           P64[Sp + 24] = _sfXVs::P64;
           P64[Sp + 32] = P64[R1 + 6];
           Sp = Sp + 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.05418947 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfold_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfold_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfold_info;
 },
 Data.Functor.Sum.$fFoldableSum_$cfold_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfYwr,
                       label: Data.Functor.Sum.$fFoldableSum_$cfold_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYwr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYws; else goto cfYwt;
       cfYws: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfold_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYwt: // global
           I64[Sp - 32] = block_cfYwk_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufYwA; else goto cfYwl;
       ufYwA: // global
           call _cfYwk(R1) args: 0, res: 0, upd: 0;
       cfYwl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYwk() //  [R1]
         { info_tbl: [(cfYwk,
                       label: block_cfYwk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYwk: // global
           _sfXVz::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfYwo; else goto cfYwp;
       cfYwo: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXVz::P64;
           P64[Sp + 16] = GHC.Base.id_closure+1;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cfYwp: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXVz::P64;
           P64[Sp + 16] = GHC.Base.id_closure+1;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.055535472 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum2_closure" {
     Data.Functor.Sum.$fFoldableSum2_closure:
         const Data.Functor.Sum.$fFoldableSum2_info;
 },
 Data.Functor.Sum.$fFoldableSum2_entry() //  [R2]
         { info_tbl: [(cfYwF,
                       label: Data.Functor.Sum.$fFoldableSum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYwF: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.056863307 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum3_closure" {
     Data.Functor.Sum.$fFoldableSum3_closure:
         const Data.Functor.Sum.$fFoldableSum3_info;
         const 0;
 },
 $dMonoid_sfXVI_entry() //  [R1]
         { info_tbl: [(cfYwQ,
                       label: $dMonoid_sfXVI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYwQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYwR; else goto cfYwS;
       cfYwR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYwS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXVN_entry() //  [R1, R2]
         { info_tbl: [(cfYx5,
                       label: sat_sfXVN_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYx5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYx6; else goto cfYx7;
       cfYx6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYx7: // global
           I64[Sp - 32] = block_cfYwY_info;
           _sfXVF::P64 = P64[R1 + 7];
           _sfXVG::P64 = P64[R1 + 15];
           _sfXVI::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXVF::P64;
           P64[Sp - 16] = _sfXVG::P64;
           P64[Sp - 8] = _sfXVI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufYxe; else goto cfYwZ;
       ufYxe: // global
           call _cfYwY(R1) args: 0, res: 0, upd: 0;
       cfYwZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYwY() //  [R1]
         { info_tbl: [(cfYwY,
                       label: block_cfYwY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYwY: // global
           _sfXVI::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfYx2; else goto cfYx3;
       cfYx2: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXVI::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cfYx3: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXVI::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum3_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYxf,
                       label: Data.Functor.Sum.$fFoldableSum3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYxf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfYxj; else goto cfYxi;
       cfYxj: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYxi: // global
           I64[Hp - 48] = $dMonoid_sfXVI_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sfXVN_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.058603753 UTC

[section ""cstring" . lvl_rfXP1_bytes" {
     lvl_rfXP1_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.059384322 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum4_closure" {
     Data.Functor.Sum.$fFoldableSum4_closure:
         const Data.Functor.Sum.$fFoldableSum4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum4_entry() //  [R1]
         { info_tbl: [(cfYxs,
                       label: Data.Functor.Sum.$fFoldableSum4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYxs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfYxt; else goto cfYxu;
       cfYxt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYxu: // global
           (_cfYxn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfYxn::I64 == 0) goto cfYxp; else goto cfYxo;
       cfYxp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfYxo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfYxn::I64;
           I64[Sp - 24] = block_cfYxq_info;
           R2 = lvl_rfXP1_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfYxq() //  [R1]
         { info_tbl: [(cfYxq,
                       label: block_cfYxq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYxq: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.061277023 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cminimum_closure" {
     Data.Functor.Sum.$fFoldableSum_$cminimum_closure:
         const Data.Functor.Sum.$fFoldableSum_$cminimum_info;
         const 0;
 },
 g1_sfXVS_entry() //  [R1]
         { info_tbl: [(cfYxG,
                       label: g1_sfXVS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYxG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYxH; else goto cfYxI;
       cfYxH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYxI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXW1_entry() //  [R1, R2]
         { info_tbl: [(cfYxV,
                       label: sat_sfXW1_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYxV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYxW; else goto cfYxX;
       cfYxW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYxX: // global
           I64[Sp - 32] = block_cfYxO_info;
           _sfXVP::P64 = P64[R1 + 7];
           _sfXVQ::P64 = P64[R1 + 15];
           _sfXVS::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXVP::P64;
           P64[Sp - 16] = _sfXVQ::P64;
           P64[Sp - 8] = _sfXVS::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufYyu; else goto cfYxP;
       ufYyu: // global
           call _cfYxO(R1) args: 0, res: 0, upd: 0;
       cfYxP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYxO() //  [R1]
         { info_tbl: [(cfYxO,
                       label: block_cfYxO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYxO: // global
           _sfXVS::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfYxS; else goto cfYxT;
       cfYxS: // global
           I64[Sp + 24] = block_cfYy0_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sfXVS::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cfYxT: // global
           I64[Sp + 24] = block_cfYye_info;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sfXVS::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 6];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfYy0() //  [R1]
         { info_tbl: [(cfYy0,
                       label: block_cfYy0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYy0: // global
           if (R1 & 7 == 1) goto ufYyt; else goto cfYyb;
       ufYyt: // global
           Sp = Sp + 8;
           call _cfYyl() args: 0, res: 0, upd: 0;
       cfYyb: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYye() //  [R1]
         { info_tbl: [(cfYye,
                       label: block_cfYye_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYye: // global
           if (R1 & 7 == 1) goto ufYys; else goto cfYyp;
       ufYys: // global
           Sp = Sp + 8;
           call _cfYyl() args: 0, res: 0, upd: 0;
       cfYyp: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYyl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYyl: // global
           R1 = Data.Functor.Sum.$fFoldableSum4_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cminimum_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYyx,
                       label: Data.Functor.Sum.$fFoldableSum_$cminimum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYyx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfYyB; else goto cfYyA;
       cfYyB: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cminimum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYyA: // global
           I64[Hp - 48] = g1_sfXVS_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sfXW1_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.06340321 UTC

[section ""cstring" . lvl1_rfXP2_bytes" {
     lvl1_rfXP2_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.064199601 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum5_closure" {
     Data.Functor.Sum.$fFoldableSum5_closure:
         const Data.Functor.Sum.$fFoldableSum5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum5_entry() //  [R1]
         { info_tbl: [(cfYyK,
                       label: Data.Functor.Sum.$fFoldableSum5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYyK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfYyL; else goto cfYyM;
       cfYyL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYyM: // global
           (_cfYyF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfYyF::I64 == 0) goto cfYyH; else goto cfYyG;
       cfYyH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfYyG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfYyF::I64;
           I64[Sp - 24] = block_cfYyI_info;
           R2 = lvl1_rfXP2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfYyI() //  [R1]
         { info_tbl: [(cfYyI,
                       label: block_cfYyI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYyI: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.066121053 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cmaximum_closure" {
     Data.Functor.Sum.$fFoldableSum_$cmaximum_closure:
         const Data.Functor.Sum.$fFoldableSum_$cmaximum_info;
         const 0;
 },
 g1_sfXW6_entry() //  [R1]
         { info_tbl: [(cfYyY,
                       label: g1_sfXW6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYyY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYyZ; else goto cfYz0;
       cfYyZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYz0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXWf_entry() //  [R1, R2]
         { info_tbl: [(cfYzd,
                       label: sat_sfXWf_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYzd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYze; else goto cfYzf;
       cfYze: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYzf: // global
           I64[Sp - 32] = block_cfYz6_info;
           _sfXW3::P64 = P64[R1 + 7];
           _sfXW4::P64 = P64[R1 + 15];
           _sfXW6::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXW3::P64;
           P64[Sp - 16] = _sfXW4::P64;
           P64[Sp - 8] = _sfXW6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufYzM; else goto cfYz7;
       ufYzM: // global
           call _cfYz6(R1) args: 0, res: 0, upd: 0;
       cfYz7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYz6() //  [R1]
         { info_tbl: [(cfYz6,
                       label: block_cfYz6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYz6: // global
           _sfXW6::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfYza; else goto cfYzb;
       cfYza: // global
           I64[Sp + 24] = block_cfYzi_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sfXW6::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cfYzb: // global
           I64[Sp + 24] = block_cfYzw_info;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sfXW6::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 6];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfYzi() //  [R1]
         { info_tbl: [(cfYzi,
                       label: block_cfYzi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYzi: // global
           if (R1 & 7 == 1) goto ufYzL; else goto cfYzt;
       ufYzL: // global
           Sp = Sp + 8;
           call _cfYzD() args: 0, res: 0, upd: 0;
       cfYzt: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYzw() //  [R1]
         { info_tbl: [(cfYzw,
                       label: block_cfYzw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYzw: // global
           if (R1 & 7 == 1) goto ufYzK; else goto cfYzH;
       ufYzK: // global
           Sp = Sp + 8;
           call _cfYzD() args: 0, res: 0, upd: 0;
       cfYzH: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYzD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYzD: // global
           R1 = Data.Functor.Sum.$fFoldableSum5_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cmaximum_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYzP,
                       label: Data.Functor.Sum.$fFoldableSum_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYzP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfYzT; else goto cfYzS;
       cfYzT: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cmaximum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYzS: // global
           I64[Hp - 48] = g1_sfXW6_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sfXWf_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.068933067 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$celem_closure" {
     Data.Functor.Sum.$fFoldableSum_$celem_closure:
         const Data.Functor.Sum.$fFoldableSum_$celem_info;
         const 0;
 },
 f1_sfXWk_entry() //  [R1]
         { info_tbl: [(cfYA2,
                       label: f1_sfXWk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYA2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYA3; else goto cfYA4;
       cfYA3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYA4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfXWp_entry() //  [R1, R2]
         { info_tbl: [(cfYAh,
                       label: sat_sfXWp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYAh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYAi; else goto cfYAj;
       cfYAi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYAj: // global
           I64[Sp - 32] = block_cfYAa_info;
           _sfXWg::P64 = P64[R1 + 7];
           _sfXWh::P64 = P64[R1 + 15];
           _sfXWk::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXWg::P64;
           P64[Sp - 16] = _sfXWh::P64;
           P64[Sp - 8] = _sfXWk::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufYAq; else goto cfYAb;
       ufYAq: // global
           call _cfYAa(R1) args: 0, res: 0, upd: 0;
       cfYAb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYAa() //  [R1]
         { info_tbl: [(cfYAa,
                       label: block_cfYAa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYAa: // global
           _sfXWk::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfYAe; else goto cfYAf;
       cfYAe: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp + 16] = _sfXWk::P64;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cfYAf: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp + 16] = _sfXWk::P64;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$celem_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfYAr,
                       label: Data.Functor.Sum.$fFoldableSum_$celem_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYAr: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfYAv; else goto cfYAu;
       cfYAv: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$celem_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYAu: // global
           I64[Hp - 56] = f1_sfXWk_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = sat_sfXWp_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.071193453 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum10_closure" {
     Data.Functor.Sum.$fFoldableSum10_closure:
         const Data.Functor.Sum.$fFoldableSum10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum10_entry() //  [R1]
         { info_tbl: [(cfYAC,
                       label: Data.Functor.Sum.$fFoldableSum10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYAC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYAD; else goto cfYAE;
       cfYAD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYAE: // global
           (_cfYAz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfYAz::I64 == 0) goto cfYAB; else goto cfYAA;
       cfYAB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfYAA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfYAz::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.072624024 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldl_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldl_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldl_info;
         const 0;
 },
 f2_sfXWv_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYAO,
                       label: f2_sfXWv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYAO: // global
           _sfXWx::P64 = R3;
           R3 = R2;
           R2 = _sfXWx::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldl_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cfYAY,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYAY: // global
           _sfXWu::P64 = R6;
           _sfXWt::P64 = R5;
           _sfXWs::P64 = R4;
           _sfXWr::P64 = R3;
           _sfXWq::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cfYAZ; else goto cfYB0;
       cfYB0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfYB2; else goto cfYB1;
       cfYB2: // global
           HpAlloc = 16;
           goto cfYAZ;
       cfYAZ: // global
           R6 = _sfXWu::P64;
           R5 = _sfXWt::P64;
           R4 = _sfXWs::P64;
           R3 = _sfXWr::P64;
           R2 = _sfXWq::P64;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYB1: // global
           I64[Hp - 8] = f2_sfXWv_info;
           P64[Hp] = _sfXWs::P64;
           I64[Sp - 40] = block_cfYAR_info;
           R1 = _sfXWu::P64;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = _sfXWq::P64;
           P64[Sp - 16] = _sfXWr::P64;
           P64[Sp - 8] = _sfXWt::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYB9; else goto cfYAS;
       ufYB9: // global
           call _cfYAR(R1) args: 0, res: 0, upd: 0;
       cfYAS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYAR() //  [R1]
         { info_tbl: [(cfYAR,
                       label: block_cfYAR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYAR: // global
           _cfYAJ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cfYAV; else goto cfYAW;
       cfYAV: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 16] = _cfYAJ::P64;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
       cfYAW: // global
           R2 = P64[Sp + 24];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 16] = _cfYAJ::P64;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.074177256 UTC

[section ""cstring" . lvl2_rfXP3_bytes" {
     lvl2_rfXP3_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.074969597 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum9_closure" {
     Data.Functor.Sum.$fFoldableSum9_closure:
         const Data.Functor.Sum.$fFoldableSum9_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum9_entry() //  [R1]
         { info_tbl: [(cfYBi,
                       label: Data.Functor.Sum.$fFoldableSum9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYBi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfYBj; else goto cfYBk;
       cfYBj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYBk: // global
           (_cfYBd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfYBd::I64 == 0) goto cfYBf; else goto cfYBe;
       cfYBf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfYBe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfYBd::I64;
           I64[Sp - 24] = block_cfYBg_info;
           R2 = lvl2_rfXP3_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfYBg() //  [R1]
         { info_tbl: [(cfYBg,
                       label: block_cfYBg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYBg: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.077666597 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldl1_info;
         const 0;
 },
 sat_sfXWM_entry() //  [R1]
         { info_tbl: [(cfYBN,
                       label: sat_sfXWM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYBN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYBO; else goto cfYBP;
       cfYBO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYBP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfYBG_info;
           _sfXWE::P64 = P64[R1 + 16];
           _sfXWI::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sfXWE::P64;
           P64[Sp - 24] = _sfXWI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYBW; else goto cfYBH;
       ufYBW: // global
           call _cfYBG(R1) args: 0, res: 0, upd: 0;
       cfYBH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfYBG() //  [R1]
         { info_tbl: [(cfYBG,
                       label: block_cfYBG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYBG: // global
           _sfXWI::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfYBK; else goto cfYBL;
       cfYBK: // global
           R1 = _sfXWI::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cfYBL: // global
           R3 = _sfXWI::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXWN_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYBY,
                       label: sat_sfXWN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYBY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfYC2; else goto cfYC1;
       cfYC2: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYC1: // global
           _sfXWE::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sfXWM_info;
           P64[Hp - 32] = _sfXWE::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXWV_entry() //  [R1]
         { info_tbl: [(cfYCl,
                       label: sat_sfXWV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYCl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYCm; else goto cfYCn;
       cfYCm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYCn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfYCe_info;
           _sfXWE::P64 = P64[R1 + 16];
           _sfXWR::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sfXWE::P64;
           P64[Sp - 24] = _sfXWR::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYCu; else goto cfYCf;
       ufYCu: // global
           call _cfYCe(R1) args: 0, res: 0, upd: 0;
       cfYCf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfYCe() //  [R1]
         { info_tbl: [(cfYCe,
                       label: block_cfYCe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYCe: // global
           _sfXWR::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfYCi; else goto cfYCj;
       cfYCi: // global
           R1 = _sfXWR::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cfYCj: // global
           R3 = _sfXWR::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXWW_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYCw,
                       label: sat_sfXWW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYCw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfYCA; else goto cfYCz;
       cfYCA: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYCz: // global
           _sfXWE::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sfXWV_info;
           P64[Hp - 32] = _sfXWE::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldl1_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cfYCF,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYCF: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfYCG; else goto cfYCH;
       cfYCG: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYCH: // global
           I64[Sp - 32] = block_cfYBs_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufYDe; else goto cfYBt;
       ufYDe: // global
           call _cfYBs(R1) args: 0, res: 0, upd: 0;
       cfYBt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYBs() //  [R1]
         { info_tbl: [(cfYBs,
                       label: block_cfYBs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYBs: // global
           _sfXWE::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfYCC; else goto cfYCD;
       cfYCC: // global
           Hp = Hp + 16;
           _sfXWG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYCZ; else goto cfYCK;
       cfYCK: // global
           _sfXWH::P64 = P64[_sfXWG::P64 + 7];
           I64[Hp - 8] = sat_sfXWN_info;
           P64[Hp] = _sfXWE::P64;
           I64[Sp + 24] = block_cfYCI_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp] = Hp - 6;
           P64[Sp + 8] = _sfXWH::P64;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
       cfYCD: // global
           Hp = Hp + 16;
           _sfXWG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYCZ; else goto cfYCY;
       cfYCZ: // global
           HpAlloc = 16;
           R1 = _sfXWG::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYCY: // global
           _sfXWQ::P64 = P64[_sfXWG::P64 + 6];
           I64[Hp - 8] = sat_sfXWW_info;
           P64[Hp] = _sfXWE::P64;
           I64[Sp + 24] = block_cfYCW_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp] = Hp - 6;
           P64[Sp + 8] = _sfXWQ::P64;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cfYCI() //  [R1]
         { info_tbl: [(cfYCI,
                       label: block_cfYCI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYCI: // global
           if (R1 & 7 == 1) goto ufYDd; else goto cfYCV;
       ufYDd: // global
           Sp = Sp + 8;
           call _cfYD5() args: 0, res: 0, upd: 0;
       cfYCV: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYCW() //  [R1]
         { info_tbl: [(cfYCW,
                       label: block_cfYCW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYCW: // global
           if (R1 & 7 == 1) goto ufYDc; else goto cfYD9;
       ufYDc: // global
           Sp = Sp + 8;
           call _cfYD5() args: 0, res: 0, upd: 0;
       cfYD9: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYD5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYD5: // global
           R1 = Data.Functor.Sum.$fFoldableSum9_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.08225745 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldr'_info;
         const 0;
 },
 sat_sfXXa_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfYDx,
                       label: sat_sfXXa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYDx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYDy; else goto cfYDz;
       cfYDy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYDz: // global
           I64[Sp - 16] = block_cfYDv_info;
           _sfXX7::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sfXX7::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYDv() //  [R1]
         { info_tbl: [(cfYDv,
                       label: block_cfYDv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYDv: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXXg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfYDK,
                       label: sat_sfXXg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYDK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYDL; else goto cfYDM;
       cfYDL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYDM: // global
           I64[Sp - 16] = block_cfYDI_info;
           _sfXXd::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sfXXd::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYDI() //  [R1]
         { info_tbl: [(cfYDI,
                       label: block_cfYDI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYDI: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldr'_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cfYDS,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYDS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfYDT; else goto cfYDU;
       cfYDT: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYDU: // global
           I64[Sp - 40] = block_cfYDl_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYE1; else goto cfYDm;
       ufYE1: // global
           call _cfYDl(R1) args: 0, res: 0, upd: 0;
       cfYDm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYDl() //  [R1]
         { info_tbl: [(cfYDl,
                       label: block_cfYDl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYDl: // global
           _sfXX1::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfYDP; else goto cfYDQ;
       cfYDP: // global
           Hp = Hp + 16;
           _sfXX4::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYE0; else goto cfYDW;
       cfYDW: // global
           _sfXX5::P64 = P64[_sfXX4::P64 + 7];
           I64[Hp - 8] = sat_sfXXa_info;
           P64[Hp] = _sfXX1::P64;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppppp_info;
           P64[Sp] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 8] = Hp - 5;
           P64[Sp + 16] = _sfXX5::P64;
           P64[Sp + 24] = GHC.Base.id_closure+1;
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
       cfYDQ: // global
           Hp = Hp + 16;
           _sfXX4::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYE0; else goto cfYDZ;
       cfYE0: // global
           HpAlloc = 16;
           R1 = _sfXX4::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYDZ: // global
           _sfXXb::P64 = P64[_sfXX4::P64 + 6];
           I64[Hp - 8] = sat_sfXXg_info;
           P64[Hp] = _sfXX1::P64;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_ppppp_info;
           P64[Sp] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 8] = Hp - 5;
           P64[Sp + 16] = _sfXXb::P64;
           P64[Sp + 24] = GHC.Base.id_closure+1;
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.08482984 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldr_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldr_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldr_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldr_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cfYEd,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYEd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYEe; else goto cfYEf;
       cfYEe: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYEf: // global
           I64[Sp - 40] = block_cfYE6_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYEm; else goto cfYE7;
       ufYEm: // global
           call _cfYE6(R1) args: 0, res: 0, upd: 0;
       cfYE7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYE6() //  [R1]
         { info_tbl: [(cfYE6,
                       label: block_cfYE6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYE6: // global
           _sfXXj::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfYEa; else goto cfYEb;
       cfYEa: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp + 16] = _sfXXj::P64;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
       cfYEb: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp + 16] = _sfXXj::P64;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.086497127 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldl'_info;
         const 0;
 },
 sat_sfXXy_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfYEy,
                       label: sat_sfXXy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYEy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYEz; else goto cfYEA;
       cfYEz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYEA: // global
           I64[Sp - 16] = block_cfYEw_info;
           _sfXXv::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sfXXv::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYEw() //  [R1]
         { info_tbl: [(cfYEw,
                       label: block_cfYEw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYEw: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldl'_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cfYEC,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYEC: // global
           _sfXXt::P64 = R6;
           _sfXXs::P64 = R5;
           _sfXXr::P64 = R4;
           _sfXXq::P64 = R3;
           _sfXXp::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cfYED; else goto cfYEE;
       cfYEE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfYEG; else goto cfYEF;
       cfYEG: // global
           HpAlloc = 16;
           goto cfYED;
       cfYED: // global
           R6 = _sfXXt::P64;
           R5 = _sfXXs::P64;
           R4 = _sfXXr::P64;
           R3 = _sfXXq::P64;
           R2 = _sfXXp::P64;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYEF: // global
           I64[Hp - 8] = sat_sfXXy_info;
           P64[Hp] = _sfXXr::P64;
           R6 = _sfXXt::P64;
           R5 = GHC.Base.id_closure+1;
           R4 = Hp - 5;
           R3 = _sfXXq::P64;
           R2 = _sfXXp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sfXXs::P64;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.088295189 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum7_closure" {
     Data.Functor.Sum.$fFoldableSum7_closure:
         const Data.Functor.Sum.$fFoldableSum7_info;
 },
 Data.Functor.Sum.$fFoldableSum7_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYEO,
                       label: Data.Functor.Sum.$fFoldableSum7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYEO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYEV; else goto cfYEW;
       cfYEV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYEW: // global
           I64[Sp - 16] = block_cfYEL_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufYF0; else goto cfYEM;
       ufYF0: // global
           call _cfYEL(R1) args: 0, res: 0, upd: 0;
       cfYEM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYEL() //  [R1]
         { info_tbl: [(cfYEL,
                       label: block_cfYEL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYEL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfYEZ; else goto cfYEY;
       cfYEZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYEY: // global
           _sfXXE::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sfXXE::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.089595558 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$clength_closure" {
     Data.Functor.Sum.$fFoldableSum_$clength_closure:
         const Data.Functor.Sum.$fFoldableSum_$clength_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$clength_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYF5,
                       label: Data.Functor.Sum.$fFoldableSum_$clength_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYF5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYF6; else goto cfYF7;
       cfYF6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$clength_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYF7: // global
           R6 = R4;
           R5 = GHC.Base.id_closure+1;
           R4 = Data.Functor.Sum.$fFoldableSum7_closure+3;
           R3 = R3;
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Functor.Sum.$fFoldableSum6_closure+1;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.090488379 UTC

[section ""cstring" . lvl3_rfXP4_bytes" {
     lvl3_rfXP4_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.091279702 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum11_closure" {
     Data.Functor.Sum.$fFoldableSum11_closure:
         const Data.Functor.Sum.$fFoldableSum11_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum11_entry() //  [R1]
         { info_tbl: [(cfYFg,
                       label: Data.Functor.Sum.$fFoldableSum11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYFg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfYFh; else goto cfYFi;
       cfYFh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYFi: // global
           (_cfYFb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfYFb::I64 == 0) goto cfYFd; else goto cfYFc;
       cfYFd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfYFc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfYFb::I64;
           I64[Sp - 24] = block_cfYFe_info;
           R2 = lvl3_rfXP4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfYFe() //  [R1]
         { info_tbl: [(cfYFe,
                       label: block_cfYFe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYFe: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.093055287 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldr1_info;
         const 0;
 },
 sat_sfXXS_entry() //  [R1]
         { info_tbl: [(cfYFG,
                       label: sat_sfXXS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYFG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYFH; else goto cfYFI;
       cfYFH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYFI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfYFz_info;
           _sfXXM::P64 = P64[R1 + 16];
           _sfXXO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sfXXM::P64;
           P64[Sp - 24] = _sfXXO::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYFP; else goto cfYFA;
       ufYFP: // global
           call _cfYFz(R1) args: 0, res: 0, upd: 0;
       cfYFA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfYFz() //  [R1]
         { info_tbl: [(cfYFz,
                       label: block_cfYFz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYFz: // global
           _sfXXO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfYFD; else goto cfYFE;
       cfYFD: // global
           R1 = _sfXXO::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cfYFE: // global
           R3 = P64[R1 + 6];
           R2 = _sfXXO::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXXT_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYFR,
                       label: sat_sfXXT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYFR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfYFV; else goto cfYFU;
       cfYFV: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYFU: // global
           _sfXXM::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sfXXS_info;
           P64[Hp - 32] = _sfXXM::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldr1_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cfYG2,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYG2: // global
           _sfXXN::P64 = R5;
           _sfXXM::P64 = R4;
           _sfXXL::P64 = R3;
           _sfXXK::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cfYG3; else goto cfYG4;
       cfYG4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfYG6; else goto cfYG5;
       cfYG6: // global
           HpAlloc = 16;
           goto cfYG3;
       cfYG3: // global
           R5 = _sfXXN::P64;
           R4 = _sfXXM::P64;
           R3 = _sfXXL::P64;
           R2 = _sfXXK::P64;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYG5: // global
           I64[Hp - 8] = sat_sfXXT_info;
           P64[Hp] = _sfXXM::P64;
           I64[Sp - 8] = block_cfYFW_info;
           R6 = _sfXXN::P64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = Hp - 6;
           R3 = _sfXXL::P64;
           R2 = _sfXXK::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfYFW() //  [R1]
         { info_tbl: [(cfYFW,
                       label: block_cfYFW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYFW: // global
           if (R1 & 7 == 1) goto cfYFZ; else goto cfYG0;
       cfYFZ: // global
           R1 = Data.Functor.Sum.$fFoldableSum11_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfYG0: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.095225099 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum8_closure" {
     Data.Functor.Sum.$fFoldableSum8_closure:
         const Data.Functor.Sum.$fFoldableSum8_info;
 },
 Data.Functor.Sum.$fFoldableSum8_entry() //  []
         { info_tbl: [(cfYGh,
                       label: Data.Functor.Sum.$fFoldableSum8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYGh: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.096093522 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cnull_closure" {
     Data.Functor.Sum.$fFoldableSum_$cnull_closure:
         const Data.Functor.Sum.$fFoldableSum_$cnull_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$cnull_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYGo,
                       label: Data.Functor.Sum.$fFoldableSum_$cnull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYGo: // global
           R6 = R4;
           R5 = GHC.Types.True_closure+2;
           R4 = Data.Functor.Sum.$fFoldableSum8_closure+2;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.09764576 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum1_closure" {
     Data.Functor.Sum.$fFoldableSum1_closure:
         const Data.Functor.Sum.$fFoldableSum1_info;
         const 0;
 },
 $dMonoid_sfXY4_entry() //  [R1]
         { info_tbl: [(cfYGz,
                       label: $dMonoid_sfXY4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYGz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYGA; else goto cfYGB;
       cfYGA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYGB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXY9_entry() //  [R1, R2]
         { info_tbl: [(cfYGO,
                       label: sat_sfXY9_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYGO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYGP; else goto cfYGQ;
       cfYGP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYGQ: // global
           I64[Sp - 32] = block_cfYGH_info;
           _sfXY1::P64 = P64[R1 + 7];
           _sfXY2::P64 = P64[R1 + 15];
           _sfXY4::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXY1::P64;
           P64[Sp - 16] = _sfXY2::P64;
           P64[Sp - 8] = _sfXY4::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufYGX; else goto cfYGI;
       ufYGX: // global
           call _cfYGH(R1) args: 0, res: 0, upd: 0;
       cfYGI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYGH() //  [R1]
         { info_tbl: [(cfYGH,
                       label: block_cfYGH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYGH: // global
           _sfXY4::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfYGL; else goto cfYGM;
       cfYGL: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXY4::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cfYGM: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXY4::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum1_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYGY,
                       label: Data.Functor.Sum.$fFoldableSum1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYGY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfYH2; else goto cfYH1;
       cfYH2: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYH1: // global
           I64[Hp - 48] = $dMonoid_sfXY4_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sfXY9_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.099529553 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$ctoList_closure" {
     Data.Functor.Sum.$fFoldableSum_$ctoList_closure:
         const Data.Functor.Sum.$fFoldableSum_$ctoList_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$ctoList_entry() //  [R2, R3, R4]
         { info_tbl: [(cfYH7,
                       label: Data.Functor.Sum.$fFoldableSum_$ctoList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYH7: // global
           R6 = R4;
           R5 = GHC.Types.[]_closure+1;
           R4 = GHC.Types.:_closure+2;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.102514415 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_closure" {
     Data.Functor.Sum.$fFoldableSum_closure:
         const Data.Functor.Sum.$fFoldableSum_info;
         const 0;
 },
 sat_sfXYu_entry() //  [R1, R2]
         { info_tbl: [(cfYHj,
                       label: sat_sfXYu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYHj: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYt_entry() //  [R1, R2]
         { info_tbl: [(cfYHr,
                       label: sat_sfXYt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYHr: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum3_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYs_entry() //  [R1, R2]
         { info_tbl: [(cfYHz,
                       label: sat_sfXYs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYHz: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$cminimum_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYr_entry() //  [R1, R2]
         { info_tbl: [(cfYHH,
                       label: sat_sfXYr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYHH: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$cmaximum_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYq_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYHP,
                       label: sat_sfXYq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYHP: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$celem_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYp_entry() //  [R1, R2]
         { info_tbl: [(cfYHX,
                       label: sat_sfXYp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYHX: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$clength_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYo_entry() //  [R1, R2]
         { info_tbl: [(cfYI5,
                       label: sat_sfXYo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYI5: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$cnull_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYn_entry() //  [R1, R2]
         { info_tbl: [(cfYId,
                       label: sat_sfXYn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYId: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$ctoList_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYm_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYIl,
                       label: sat_sfXYm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYIl: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$cfoldl1_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYl_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYIt,
                       label: sat_sfXYl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYIt: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$cfoldr1_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfYIB,
                       label: sat_sfXYk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYIB: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldl'_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYj_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfYIJ,
                       label: sat_sfXYj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYIJ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldl_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYi_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfYIR,
                       label: sat_sfXYi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYIR: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldr'_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYh_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfYIZ,
                       label: sat_sfXYh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYIZ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfYJ7,
                       label: sat_sfXYg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYJ7: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldMap_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYf_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYJf,
                       label: sat_sfXYf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYJf: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$cfold_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_entry() //  [R2, R3]
         { info_tbl: [(cfYJj,
                       label: Data.Functor.Sum.$fFoldableSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYJj: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cfYJn; else goto cfYJm;
       cfYJn: // global
           HpAlloc = 520;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYJm: // global
           I64[Hp - 512] = sat_sfXYu_info;
           P64[Hp - 504] = R2;
           P64[Hp - 496] = R3;
           I64[Hp - 488] = sat_sfXYt_info;
           P64[Hp - 480] = R2;
           P64[Hp - 472] = R3;
           I64[Hp - 464] = sat_sfXYs_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           I64[Hp - 440] = sat_sfXYr_info;
           P64[Hp - 432] = R2;
           P64[Hp - 424] = R3;
           I64[Hp - 416] = sat_sfXYq_info;
           P64[Hp - 408] = R2;
           P64[Hp - 400] = R3;
           I64[Hp - 392] = sat_sfXYp_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           I64[Hp - 368] = sat_sfXYo_info;
           P64[Hp - 360] = R2;
           P64[Hp - 352] = R3;
           I64[Hp - 344] = sat_sfXYn_info;
           P64[Hp - 336] = R2;
           P64[Hp - 328] = R3;
           I64[Hp - 320] = sat_sfXYm_info;
           P64[Hp - 312] = R2;
           P64[Hp - 304] = R3;
           I64[Hp - 296] = sat_sfXYl_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           I64[Hp - 272] = sat_sfXYk_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_sfXYj_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_sfXYi_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_sfXYh_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sfXYg_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sfXYf_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = Data.Foldable.C:Foldable_con_info;
           P64[Hp - 120] = Hp - 150;
           P64[Hp - 112] = Hp - 173;
           P64[Hp - 104] = Hp - 197;
           P64[Hp - 96] = Hp - 221;
           P64[Hp - 88] = Hp - 245;
           P64[Hp - 80] = Hp - 269;
           P64[Hp - 72] = Hp - 294;
           P64[Hp - 64] = Hp - 318;
           P64[Hp - 56] = Hp - 343;
           P64[Hp - 48] = Hp - 367;
           P64[Hp - 40] = Hp - 391;
           P64[Hp - 32] = Hp - 414;
           P64[Hp - 24] = Hp - 439;
           P64[Hp - 16] = Hp - 463;
           P64[Hp - 8] = Hp - 487;
           P64[Hp] = Hp - 511;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.107642283 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$ctraverse_closure" {
     Data.Functor.Sum.$fTraversableSum_$ctraverse_closure:
         const Data.Functor.Sum.$fTraversableSum_$ctraverse_info;
 },
 sat_sfXYD_entry() //  [R1]
         { info_tbl: [(cfYJB,
                       label: sat_sfXYD_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYJB: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfYJC; else goto cfYJD;
       cfYJC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYJD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sfXYG_entry() //  [R1]
         { info_tbl: [(cfYJK,
                       label: sat_sfXYG_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYJK: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfYJL; else goto cfYJM;
       cfYJL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYJM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cfYJR,
                       label: Data.Functor.Sum.$fTraversableSum_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYJR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYJS; else goto cfYJT;
       cfYJS: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYJT: // global
           I64[Sp - 40] = block_cfYJs_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYKa; else goto cfYJt;
       ufYKa: // global
           call _cfYJs(R1) args: 0, res: 0, upd: 0;
       cfYJt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYJs() //  [R1]
         { info_tbl: [(cfYJs,
                       label: block_cfYJs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYJs: // global
           _sfXYx::P64 = P64[Sp + 24];
           _sfXYy::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfYJO; else goto cfYJP;
       cfYJO: // global
           Hp = Hp + 48;
           _sfXYA::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYK5; else goto cfYJW;
       cfYJW: // global
           _sfXYB::P64 = P64[_sfXYA::P64 + 7];
           I64[Hp - 40] = sat_sfXYD_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sfXYx::P64;
           P64[Hp - 8] = _sfXYy::P64;
           P64[Hp] = _sfXYB::P64;
           I64[Sp + 24] = block_cfYJU_info;
           R2 = _sfXYx::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
       cfYJP: // global
           Hp = Hp + 48;
           _sfXYA::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYK5; else goto cfYK4;
       cfYK5: // global
           HpAlloc = 48;
           R1 = _sfXYA::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYK4: // global
           _sfXYE::P64 = P64[_sfXYA::P64 + 6];
           I64[Hp - 40] = sat_sfXYG_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sfXYx::P64;
           P64[Hp - 8] = _sfXYy::P64;
           P64[Hp] = _sfXYE::P64;
           I64[Sp + 24] = block_cfYK2_info;
           R2 = _sfXYx::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfYJU() //  [R1]
         { info_tbl: [(cfYJU,
                       label: block_cfYJU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYJU: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Sum.InL_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cfYK2() //  [R1]
         { info_tbl: [(cfYK2,
                       label: block_cfYK2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYK2: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Sum.InR_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.110547533 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure" {
     Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure:
         const Data.Functor.Sum.$fTraversableSum_$cp2Traversable_info;
         const 0;
 },
 sat_sfXYK_entry() //  [R1]
         { info_tbl: [(cfYKj,
                       label: sat_sfXYK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYKj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYKk; else goto cfYKl;
       cfYKk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYKl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXYJ_entry() //  [R1]
         { info_tbl: [(cfYKq,
                       label: sat_sfXYJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYKq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYKr; else goto cfYKs;
       cfYKr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYKs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cfYKt,
                       label: Data.Functor.Sum.$fTraversableSum_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYKt: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfYKx; else goto cfYKw;
       cfYKx: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYKw: // global
           I64[Hp - 40] = sat_sfXYK_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sfXYJ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Sum.$fFoldableSum_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.112248407 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$cp1Traversable_closure" {
     Data.Functor.Sum.$fTraversableSum_$cp1Traversable_closure:
         const Data.Functor.Sum.$fTraversableSum_$cp1Traversable_info;
 },
 sat_sfXYO_entry() //  [R1]
         { info_tbl: [(cfYKG,
                       label: sat_sfXYO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYKG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYKH; else goto cfYKI;
       cfYKH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYKI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXYN_entry() //  [R1]
         { info_tbl: [(cfYKN,
                       label: sat_sfXYN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYKN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYKO; else goto cfYKP;
       cfYKO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYKP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cfYKQ,
                       label: Data.Functor.Sum.$fTraversableSum_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYKQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfYKU; else goto cfYKT;
       cfYKU: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYKT: // global
           I64[Hp - 40] = sat_sfXYO_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sfXYN_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Sum.$fFunctorSum_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.113686017 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$csequenceA_closure" {
     Data.Functor.Sum.$fTraversableSum_$csequenceA_closure:
         const Data.Functor.Sum.$fTraversableSum_$csequenceA_info;
 },
 Data.Functor.Sum.$fTraversableSum_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cfYKZ,
                       label: Data.Functor.Sum.$fTraversableSum_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYKZ: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.114739483 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$cmapM_closure" {
     Data.Functor.Sum.$fTraversableSum_$cmapM_closure:
         const Data.Functor.Sum.$fTraversableSum_$cmapM_info;
 },
 Data.Functor.Sum.$fTraversableSum_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cfYL8,
                       label: Data.Functor.Sum.$fTraversableSum_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYL8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYL9; else goto cfYLa;
       cfYL9: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYLa: // global
           I64[Sp - 40] = block_cfYL6_info;
           _sfXYS::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sfXYS::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfYL6() //  [R1]
         { info_tbl: [(cfYL6,
                       label: block_cfYL6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYL6: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.116075599 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$csequence_closure" {
     Data.Functor.Sum.$fTraversableSum_$csequence_closure:
         const Data.Functor.Sum.$fTraversableSum_$csequence_info;
 },
 Data.Functor.Sum.$fTraversableSum_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cfYLk,
                       label: Data.Functor.Sum.$fTraversableSum_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYLk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYLl; else goto cfYLm;
       cfYLl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYLm: // global
           I64[Sp - 32] = block_cfYLi_info;
           _sfXYY::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sfXYY::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfYLi() //  [R1]
         { info_tbl: [(cfYLi,
                       label: block_cfYLi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYLi: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.11815802 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_closure" {
     Data.Functor.Sum.$fTraversableSum_closure:
         const Data.Functor.Sum.$fTraversableSum_info;
         const 0;
 },
 sat_sfXZa_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYLz,
                       label: sat_sfXZa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYLz: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fTraversableSum_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXZ9_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfYLH,
                       label: sat_sfXZ9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYLH: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fTraversableSum_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXZ8_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYLP,
                       label: sat_sfXZ8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYLP: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fTraversableSum_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXZ7_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfYLX,
                       label: sat_sfXZ7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYLX: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXZ6_entry() //  [R1]
         { info_tbl: [(cfYM4,
                       label: sat_sfXZ6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYM4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYM5; else goto cfYM6;
       cfYM5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYM6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fTraversableSum_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXZ5_entry() //  [R1]
         { info_tbl: [(cfYMb,
                       label: sat_sfXZ5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYMb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYMc; else goto cfYMd;
       cfYMc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYMd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fTraversableSum_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_entry() //  [R2, R3]
         { info_tbl: [(cfYMf,
                       label: Data.Functor.Sum.$fTraversableSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYMf: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cfYMj; else goto cfYMi;
       cfYMj: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYMi: // global
           I64[Hp - 208] = sat_sfXZa_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sfXZ9_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sfXZ8_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sfXZ7_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sfXZ6_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sfXZ5_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.120721073 UTC

[section ""data" . Data.Functor.Sum.$fGeneric1Sum_$cto1_closure" {
     Data.Functor.Sum.$fGeneric1Sum_$cto1_closure:
         const Data.Functor.Sum.$fGeneric1Sum_$cto1_info;
 },
 Data.Functor.Sum.$fGeneric1Sum_$cto1_entry() //  [R2]
         { info_tbl: [(cfYMu,
                       label: Data.Functor.Sum.$fGeneric1Sum_$cto1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYMu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYMv; else goto cfYMw;
       cfYMv: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGeneric1Sum_$cto1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYMw: // global
           I64[Sp - 8] = block_cfYMo_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYMo() //  [R1]
         { info_tbl: [(cfYMo,
                       label: block_cfYMo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYMo: // global
           if (R1 & 7 == 1) goto cfYMr; else goto cfYMs;
       cfYMr: // global
           Hp = Hp + 16;
           _sfXZc::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYMI; else goto cfYMB;
       cfYMB: // global
           _sfXZd::P64 = P64[_sfXZc::P64 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = _sfXZd::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfYMs: // global
           Hp = Hp + 16;
           _sfXZc::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYMI; else goto cfYMH;
       cfYMI: // global
           HpAlloc = 16;
           R1 = _sfXZc::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYMH: // global
           _sfXZe::P64 = P64[_sfXZc::P64 + 6];
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = _sfXZe::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.122309498 UTC

[section ""data" . Data.Functor.Sum.$fGeneric1Sum1_closure" {
     Data.Functor.Sum.$fGeneric1Sum1_closure:
         const Data.Functor.Sum.$fGeneric1Sum1_info;
 },
 Data.Functor.Sum.$fGeneric1Sum1_entry() //  [R2]
         { info_tbl: [(cfYMU,
                       label: Data.Functor.Sum.$fGeneric1Sum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYMU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYMV; else goto cfYMW;
       cfYMV: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGeneric1Sum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYMW: // global
           I64[Sp - 8] = block_cfYMN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYN9; else goto cfYMO;
       ufYN9: // global
           call _cfYMN(R1) args: 0, res: 0, upd: 0;
       cfYMO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYMN() //  [R1]
         { info_tbl: [(cfYMN,
                       label: block_cfYMN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYMN: // global
           if (R1 & 7 == 1) goto cfYMR; else goto cfYMS;
       cfYMR: // global
           Hp = Hp + 16;
           _sfXZg::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYN8; else goto cfYN1;
       cfYN1: // global
           _sfXZh::P64 = P64[_sfXZg::P64 + 7];
           I64[Hp - 8] = GHC.Generics.L1_con_info;
           P64[Hp] = _sfXZh::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfYMS: // global
           Hp = Hp + 16;
           _sfXZg::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYN8; else goto cfYN7;
       cfYN8: // global
           HpAlloc = 16;
           R1 = _sfXZg::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYN7: // global
           _sfXZi::P64 = P64[_sfXZg::P64 + 6];
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = _sfXZi::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.123549691 UTC

[section ""data" . Data.Functor.Sum.$fGeneric1Sum_closure" {
     Data.Functor.Sum.$fGeneric1Sum_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Sum.$fGeneric1Sum1_closure+1;
         const Data.Functor.Sum.$fGeneric1Sum_$cto1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.127252141 UTC

[section ""data" . Data.Functor.Sum.$fGenericSum_$cto_closure" {
     Data.Functor.Sum.$fGenericSum_$cto_closure:
         const Data.Functor.Sum.$fGenericSum_$cto_info;
 },
 Data.Functor.Sum.$fGenericSum_$cto_entry() //  [R2]
         { info_tbl: [(cfYNk,
                       label: Data.Functor.Sum.$fGenericSum_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYNk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYNl; else goto cfYNm;
       cfYNl: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGenericSum_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYNm: // global
           I64[Sp - 8] = block_cfYNe_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYNe() //  [R1]
         { info_tbl: [(cfYNe,
                       label: block_cfYNe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYNe: // global
           if (R1 & 7 == 1) goto cfYNh; else goto cfYNi;
       cfYNh: // global
           Hp = Hp + 16;
           _sfXZk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYNy; else goto cfYNr;
       cfYNr: // global
           _sfXZl::P64 = P64[_sfXZk::P64 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = _sfXZl::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfYNi: // global
           Hp = Hp + 16;
           _sfXZk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYNy; else goto cfYNx;
       cfYNy: // global
           HpAlloc = 16;
           R1 = _sfXZk::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYNx: // global
           _sfXZm::P64 = P64[_sfXZk::P64 + 6];
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = _sfXZm::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.128836646 UTC

[section ""data" . Data.Functor.Sum.$fGenericSum1_closure" {
     Data.Functor.Sum.$fGenericSum1_closure:
         const Data.Functor.Sum.$fGenericSum1_info;
 },
 Data.Functor.Sum.$fGenericSum1_entry() //  [R2]
         { info_tbl: [(cfYNK,
                       label: Data.Functor.Sum.$fGenericSum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYNK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYNL; else goto cfYNM;
       cfYNL: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGenericSum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYNM: // global
           I64[Sp - 8] = block_cfYND_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYNZ; else goto cfYNE;
       ufYNZ: // global
           call _cfYND(R1) args: 0, res: 0, upd: 0;
       cfYNE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYND() //  [R1]
         { info_tbl: [(cfYND,
                       label: block_cfYND_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYND: // global
           if (R1 & 7 == 1) goto cfYNH; else goto cfYNI;
       cfYNH: // global
           Hp = Hp + 16;
           _sfXZo::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYNY; else goto cfYNR;
       cfYNR: // global
           _sfXZp::P64 = P64[_sfXZo::P64 + 7];
           I64[Hp - 8] = GHC.Generics.L1_con_info;
           P64[Hp] = _sfXZp::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfYNI: // global
           Hp = Hp + 16;
           _sfXZo::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYNY; else goto cfYNX;
       cfYNY: // global
           HpAlloc = 16;
           R1 = _sfXZo::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYNX: // global
           _sfXZq::P64 = P64[_sfXZo::P64 + 6];
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = _sfXZq::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.130103423 UTC

[section ""data" . Data.Functor.Sum.$fGenericSum_closure" {
     Data.Functor.Sum.$fGenericSum_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Sum.$fGenericSum1_closure+1;
         const Data.Functor.Sum.$fGenericSum_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.13153749 UTC

[section ""data" . Data.Functor.Sum.$w$cgunfold_closure" {
     Data.Functor.Sum.$w$cgunfold_closure:
         const Data.Functor.Sum.$w$cgunfold_info;
         const 0;
 },
 sat_sfXZG_entry() //  [R1]
         { info_tbl: [(cfYOl,
                       label: sat_sfXZG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYOl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYOm; else goto cfYOn;
       cfYOm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYOn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InR_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXZH_entry() //  [R1]
         { info_tbl: [(cfYOt,
                       label: sat_sfXZH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYOt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYOu; else goto cfYOv;
       cfYOu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYOv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InL_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgunfold_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYOA,
                       label: Data.Functor.Sum.$w$cgunfold_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYOA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYOB; else goto cfYOC;
       cfYOB: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$w$cgunfold_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfYOC: // global
           I64[Sp - 40] = block_cfYO4_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYOU; else goto cfYO5;
       ufYOU: // global
           call _cfYO4(R1) args: 0, res: 0, upd: 0;
       cfYO5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYO4() //  [R1]
         { info_tbl: [(cfYO4,
                       label: block_cfYO4_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYO4: // global
           if (R1 & 7 == 1) goto cfYOy; else goto cfYOx;
       cfYOy: // global
           I64[Sp] = block_cfYOa_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto ufYOT; else goto cfYOb;
       ufYOT: // global
           call _cfYOa(R1) args: 0, res: 0, upd: 0;
       cfYOb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfYOx: // global
           _sfXZw::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cfYOE_info;
           R1 = _sfXZw::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ufYOS; else goto cfYOG;
       ufYOS: // global
           call _cfYOE(R1) args: 0, res: 0, upd: 0;
       cfYOG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYOa() //  [R1]
         { info_tbl: [(cfYOa,
                       label: block_cfYOa_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYOa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYOO; else goto cfYON;
       cfYOO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYON: // global
           _sfXZt::P64 = P64[Sp + 24];
           _sfXZu::P64 = P64[Sp + 32];
           if (I64[R1 + 7] == 1) goto cfYOR; else goto cfYOQ;
       cfYOR: // global
           I64[Hp - 16] = sat_sfXZH_info;
           P64[Hp] = _sfXZu::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 8];
           R1 = _sfXZt::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYOQ: // global
           I64[Hp - 16] = sat_sfXZG_info;
           P64[Hp] = _sfXZu::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _sfXZt::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYOE() //  [R1]
         { info_tbl: [(cfYOE,
                       label: block_cfYOE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYOE: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Data.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.134324279 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgunfold_closure" {
     Data.Functor.Sum.$fDataSum_$cgunfold_closure:
         const Data.Functor.Sum.$fDataSum_$cgunfold_info;
         const 0;
 },
 Data.Functor.Sum.$fDataSum_$cgunfold_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYOW: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgunfold_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgunfold_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cfYP3,
                       label: Data.Functor.Sum.$fDataSum_$cgunfold_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYP3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYP4; else goto cfYP5;
       cfYP4: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgunfold_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cfYP5: // global
           I64[Sp - 8] = block_cfYP0_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYP9; else goto cfYP1;
       ufYP9: // global
           call _cfYP0(R1) args: 0, res: 0, upd: 0;
       cfYP1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYP0() //  [R1]
         { info_tbl: [(cfYP0,
                       label: block_cfYP0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYP0: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 39];
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgunfold_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.136536866 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgfoldl_closure" {
     Data.Functor.Sum.$fDataSum_$cgfoldl_closure:
         const Data.Functor.Sum.$fDataSum_$cgfoldl_info;
 },
 Data.Functor.Sum.$fDataSum_$cgfoldl_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYPb: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgfoldl_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_sfY08_entry() //  [R1]
         { info_tbl: [(cfYPo,
                       label: sat_sfY08_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYPo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYPp; else goto cfYPq;
       cfYPp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYPq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InL_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfY0a_entry() //  [R1]
         { info_tbl: [(cfYPx,
                       label: sat_sfY0a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYPx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYPy; else goto cfYPz;
       cfYPy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYPz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InR_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgfoldl_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cfYPE,
                       label: Data.Functor.Sum.$fDataSum_$cgfoldl_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYPE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYPF; else goto cfYPG;
       cfYPF: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgfoldl_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cfYPG: // global
           I64[Sp - 8] = block_cfYPf_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYPN; else goto cfYPg;
       ufYPN: // global
           call _cfYPf(R1) args: 0, res: 0, upd: 0;
       cfYPg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYPf() //  [R1]
         { info_tbl: [(cfYPf,
                       label: block_cfYPf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYPf: // global
           _sfY03::P64 = P64[Sp + 16];
           _sfY04::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfYPB; else goto cfYPC;
       cfYPB: // global
           Hp = Hp + 24;
           _sfY06::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYPM; else goto cfYPI;
       cfYPI: // global
           _sfY07::P64 = P64[_sfY06::P64 + 7];
           I64[Hp - 16] = sat_sfY08_info;
           P64[Hp] = _sfY04::P64;
           R4 = _sfY07::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 32];
           R1 = _sfY03::P64;
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYPC: // global
           Hp = Hp + 24;
           _sfY06::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYPM; else goto cfYPL;
       cfYPM: // global
           HpAlloc = 24;
           R1 = _sfY06::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYPL: // global
           _sfY09::P64 = P64[_sfY06::P64 + 6];
           I64[Hp - 16] = sat_sfY0a_info;
           P64[Hp] = _sfY04::P64;
           R4 = _sfY09::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 8];
           R1 = _sfY03::P64;
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.13865604 UTC

[section ""cstring" . Data.Functor.Sum.$fDataSum8_bytes" {
     Data.Functor.Sum.$fDataSum8_bytes:
         I8[] [83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.139376986 UTC

[section ""data" . $tSum1_rfXP5_closure" {
     $tSum1_rfXP5_closure:
         const $tSum1_rfXP5_info;
         const 0;
         const 0;
         const 0;
 },
 $tSum1_rfXP5_entry() //  [R1]
         { info_tbl: [(cfYPU,
                       label: $tSum1_rfXP5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYPU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYPV; else goto cfYPW;
       cfYPV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYPW: // global
           (_cfYPR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfYPR::I64 == 0) goto cfYPT; else goto cfYPS;
       cfYPT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfYPS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfYPR::I64;
           R2 = Data.Functor.Sum.$fDataSum8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.140956204 UTC

[section ""data" . go61_rfXP6_closure" {
     go61_rfXP6_closure:
         const go61_rfXP6_info;
         const 0;
 },
 go61_rfXP6_entry() //  [R2, R3]
         { info_tbl: [(cfYQ8,
                       label: go61_rfXP6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYQ8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYQ9; else goto ufYQM;
       cfYQ9: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rfXP6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ufYQM: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cfYPY() args: 0, res: 0, upd: 0;
     }
 },
 _cfYPY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYPY: // global
           _sfY0b::P64 = P64[Sp];
           I64[Sp] = block_cfYQ1_info;
           R1 = _sfY0b::P64;
           if (R1 & 7 != 0) goto ufYQQ; else goto cfYQ2;
       ufYQQ: // global
           call _cfYQ1(R1) args: 0, res: 0, upd: 0;
       cfYQ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYQ1() //  [R1]
         { info_tbl: [(cfYQ1,
                       label: block_cfYQ1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYQ1: // global
           if (R1 & 7 == 1) goto ufYQN; else goto cfYQ6;
       ufYQN: // global
           Sp = Sp + 16;
           call _cfYQo() args: 0, res: 0, upd: 0;
       cfYQ6: // global
           I64[Sp - 8] = block_cfYQg_info;
           _sfY0e::P64 = P64[R1 + 6];
           _sfY0f::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sfY0f::P64;
           P64[Sp + 8] = _sfY0e::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYQR; else goto cfYQi;
       ufYQR: // global
           call _cfYQg(R1) args: 0, res: 0, upd: 0;
       cfYQi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYQg() //  [R1]
         { info_tbl: [(cfYQg,
                       label: block_cfYQg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYQg: // global
           if (R1 & 7 == 1) goto ufYQO; else goto cfYQt;
       ufYQO: // global
           Sp = Sp + 24;
           call _cfYQo() args: 0, res: 0, upd: 0;
       cfYQt: // global
           I64[Sp - 8] = block_cfYQr_info;
           _sfY0h::P64 = P64[R1 + 6];
           _sfY0i::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sfY0i::P64;
           P64[Sp + 16] = _sfY0h::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYQU; else goto cfYQu;
       ufYQU: // global
           call _cfYQr(R1) args: 0, res: 0, upd: 0;
       cfYQu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYQo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYQo: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfYQr() //  [R1]
         { info_tbl: [(cfYQr,
                       label: block_cfYQr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYQr: // global
           I64[Sp] = block_cfYQy_info;
           R3 = Data.Functor.Sum.$fRead1Sum7_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfYQy() //  [R1]
         { info_tbl: [(cfYQy,
                       label: block_cfYQy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYQy: // global
           if (R1 & 7 == 1) goto cfYQF; else goto cfYQJ;
       cfYQF: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cfYPY() args: 0, res: 0, upd: 0;
       cfYQJ: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.14356765 UTC

[section ""data" . go1_rfXP7_closure" {
     go1_rfXP7_closure:
         const go1_rfXP7_info;
         const 0;
 },
 section ""relreadonly" . ufYRX_srtd" {
     ufYRX_srtd:
         const SfYa7_srt+88;
         const 51;
         const 1266637395197953;
 },
 go1_rfXP7_entry() //  [R2, R3]
         { info_tbl: [(cfYR8,
                       label: go1_rfXP7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYR8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYR9; else goto ufYRM;
       cfYR9: // global
           R3 = R3;
           R2 = R2;
           R1 = go1_rfXP7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ufYRM: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cfYQY() args: 0, res: 0, upd: 0;
     }
 },
 _cfYQY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYQY: // global
           _sfY0q::P64 = P64[Sp];
           I64[Sp] = block_cfYR1_info;
           R1 = _sfY0q::P64;
           if (R1 & 7 != 0) goto ufYRQ; else goto cfYR2;
       ufYRQ: // global
           call _cfYR1(R1) args: 0, res: 0, upd: 0;
       cfYR2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ufYRY_srtd" {
     ufYRY_srtd:
         const SfYa7_srt+88;
         const 48;
         const 140737488355329;
 },
 _cfYR1() //  [R1]
         { info_tbl: [(cfYR1,
                       label: block_cfYR1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYR1: // global
           if (R1 & 7 == 1) goto ufYRN; else goto cfYR6;
       ufYRN: // global
           Sp = Sp + 16;
           call _cfYRo() args: 0, res: 0, upd: 0;
       cfYR6: // global
           I64[Sp - 8] = block_cfYRg_info;
           _sfY0t::P64 = P64[R1 + 6];
           _sfY0u::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sfY0u::P64;
           P64[Sp + 8] = _sfY0t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYRR; else goto cfYRi;
       ufYRR: // global
           call _cfYRg(R1) args: 0, res: 0, upd: 0;
       cfYRi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ufYRZ_srtd" {
     ufYRZ_srtd:
         const SfYa7_srt+88;
         const 48;
         const 140737488355329;
 },
 _cfYRg() //  [R1]
         { info_tbl: [(cfYRg,
                       label: block_cfYRg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYRg: // global
           if (R1 & 7 == 1) goto ufYRO; else goto cfYRt;
       ufYRO: // global
           Sp = Sp + 24;
           call _cfYRo() args: 0, res: 0, upd: 0;
       cfYRt: // global
           I64[Sp - 8] = block_cfYRr_info;
           _sfY0w::P64 = P64[R1 + 6];
           _sfY0x::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sfY0x::P64;
           P64[Sp + 16] = _sfY0w::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYRU; else goto cfYRu;
       ufYRU: // global
           call _cfYRr(R1) args: 0, res: 0, upd: 0;
       cfYRu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYRo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYRo: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ufYS0_srtd" {
     ufYS0_srtd:
         const SfYa7_srt+88;
         const 48;
         const 140737488355329;
 },
 _cfYRr() //  [R1]
         { info_tbl: [(cfYRr,
                       label: block_cfYRr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYRr: // global
           I64[Sp] = block_cfYRy_info;
           R3 = Data.Functor.Sum.$fRead1Sum3_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ufYS1_srtd" {
     ufYS1_srtd:
         const SfYa7_srt+88;
         const 48;
         const 140737488355329;
 },
 _cfYRy() //  [R1]
         { info_tbl: [(cfYRy,
                       label: block_cfYRy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYRy: // global
           if (R1 & 7 == 1) goto cfYRF; else goto cfYRJ;
       cfYRF: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cfYQY() args: 0, res: 0, upd: 0;
       cfYRJ: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.146150968 UTC

[section ""data" . $cInL1_rfXP8_closure" {
     $cInL1_rfXP8_closure:
         const Data.Data.AlgConstr_con_info;
         const $cInL2_rfXPe_closure;
         const 0;
 },
 section ""data" . $cInR1_rfXP9_closure" {
     $cInR1_rfXP9_closure:
         const Data.Data.AlgConstr_con_info;
         const $cInR2_rfXPd_closure;
         const 0;
 },
 section ""data" . Data.Functor.Sum.$cInL_closure" {
     Data.Functor.Sum.$cInL_closure:
         const Data.Data.Constr_con_info;
         const $cInL1_rfXP8_closure+1;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Sum.$tSum_closure+1;
         const 0;
 },
 section ""data" . $tSum2_rfXPa_closure" {
     $tSum2_rfXPa_closure:
         const :_con_info;
         const Data.Functor.Sum.$cInR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . $tSum3_rfXPb_closure" {
     $tSum3_rfXPb_closure:
         const :_con_info;
         const Data.Functor.Sum.$cInL_closure+1;
         const $tSum2_rfXPa_closure+2;
         const 0;
 },
 section ""data" . $tSum4_rfXPc_closure" {
     $tSum4_rfXPc_closure:
         const Data.Data.AlgRep_con_info;
         const $tSum3_rfXPb_closure+2;
         const 0;
 },
 section ""data" . Data.Functor.Sum.$tSum_closure" {
     Data.Functor.Sum.$tSum_closure:
         const Data.Data.DataType_con_info;
         const $tSum1_rfXP5_closure;
         const $tSum4_rfXPc_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Sum.$cInR_closure" {
     Data.Functor.Sum.$cInR_closure:
         const Data.Data.Constr_con_info;
         const $cInR1_rfXP9_closure+1;
         const Data.Functor.Sum.$fRead1Sum3_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Sum.$tSum_closure+1;
         const 0;
 },
 section ""data" . $cInR2_rfXPd_closure" {
     $cInR2_rfXPd_closure:
         const $cInR2_rfXPd_info;
         const 0;
         const 0;
         const 0;
 },
 $cInR2_rfXPd_entry() //  [R1]
         { info_tbl: [(cfYS8,
                       label: $cInR2_rfXPd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYS8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYS9; else goto cfYSa;
       cfYS9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYSa: // global
           (_cfYS5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfYS5::I64 == 0) goto cfYS7; else goto cfYS6;
       cfYS7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfYS6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfYS5::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = $tSum3_rfXPb_closure+2;
           Sp = Sp - 16;
           call go1_rfXP7_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""data" . $cInL2_rfXPe_closure" {
     $cInL2_rfXPe_closure:
         const $cInL2_rfXPe_info;
         const 0;
         const 0;
         const 0;
 },
 $cInL2_rfXPe_entry() //  [R1]
         { info_tbl: [(cfYSh,
                       label: $cInL2_rfXPe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYSh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYSi; else goto cfYSj;
       cfYSi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYSj: // global
           (_cfYSe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfYSe::I64 == 0) goto cfYSg; else goto cfYSf;
       cfYSg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfYSf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfYSe::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = $tSum3_rfXPb_closure+2;
           Sp = Sp - 16;
           call go61_rfXP6_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.147821604 UTC

[section ""cstring" . Data.Functor.Sum.$trModule4_bytes" {
     Data.Functor.Sum.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.148359059 UTC

[section ""data" . Data.Functor.Sum.$trModule3_closure" {
     Data.Functor.Sum.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.148920713 UTC

[section ""cstring" . Data.Functor.Sum.$trModule2_bytes" {
     Data.Functor.Sum.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.149526752 UTC

[section ""data" . Data.Functor.Sum.$trModule1_closure" {
     Data.Functor.Sum.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.150061404 UTC

[section ""data" . Data.Functor.Sum.$trModule_closure" {
     Data.Functor.Sum.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Sum.$trModule3_closure+1;
         const Data.Functor.Sum.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.150631566 UTC

[section ""data" . $krep_rfXPf_closure" {
     $krep_rfXPf_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.151200941 UTC

[section ""data" . $krep1_rfXPg_closure" {
     $krep1_rfXPg_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rfXPf_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.151808542 UTC

[section ""data" . $krep2_rfXPh_closure" {
     $krep2_rfXPh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rfXPg_closure+4;
         const $krep1_rfXPg_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.15241045 UTC

[section ""data" . Data.Functor.Sum.$fDataSum6_closure" {
     Data.Functor.Sum.$fDataSum6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rfXPg_closure+4;
         const $krep2_rfXPh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.152995633 UTC

[section ""data" . $krep3_rfXPi_closure" {
     $krep3_rfXPi_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.153625638 UTC

[section ""data" . $krep4_rfXPj_closure" {
     $krep4_rfXPj_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.154209633 UTC

[section ""data" . $krep5_rfXPk_closure" {
     $krep5_rfXPk_closure:
         const GHC.Types.KindRepVar_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.154817663 UTC

[section ""data" . $krep6_rfXPl_closure" {
     $krep6_rfXPl_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rfXPj_closure+2;
         const $krep5_rfXPk_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.155412886 UTC

[section ""data" . $krep7_rfXPm_closure" {
     $krep7_rfXPm_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep3_rfXPi_closure+2;
         const $krep5_rfXPk_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.156007197 UTC

[section ""data" . Data.Functor.Sum.$fDataSum7_closure" {
     Data.Functor.Sum.$fDataSum7_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$fDataSum8_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.156617211 UTC

[section ""data" . Data.Functor.Sum.$tcSum_closure" {
     Data.Functor.Sum.$tcSum_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Sum.$trModule_closure+1;
         const Data.Functor.Sum.$fDataSum7_closure+1;
         const Data.Functor.Sum.$fDataSum6_closure+4;
         const 6345190594862254730;
         const 1236278515871186010;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.157274686 UTC

[section ""data" . $krep8_rfXPn_closure" {
     $krep8_rfXPn_closure:
         const :_con_info;
         const $krep5_rfXPk_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.157874219 UTC

[section ""data" . $krep9_rfXPo_closure" {
     $krep9_rfXPo_closure:
         const :_con_info;
         const $krep3_rfXPi_closure+2;
         const $krep8_rfXPn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.158450128 UTC

[section ""data" . $krep10_rfXPp_closure" {
     $krep10_rfXPp_closure:
         const :_con_info;
         const $krep4_rfXPj_closure+2;
         const $krep9_rfXPo_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.159004292 UTC

[section ""data" . $krep11_rfXPq_closure" {
     $krep11_rfXPq_closure:
         const :_con_info;
         const $krep_rfXPf_closure+2;
         const $krep10_rfXPp_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.159595612 UTC

[section ""data" . $krep12_rfXPr_closure" {
     $krep12_rfXPr_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Sum.$tcSum_closure+1;
         const $krep11_rfXPq_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.160191029 UTC

[section ""data" . Data.Functor.Sum.$tc'InL1_closure" {
     Data.Functor.Sum.$tc'InL1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rfXPl_closure+3;
         const $krep12_rfXPr_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.16076593 UTC

[section ""cstring" . Data.Functor.Sum.$tc'InL3_bytes" {
     Data.Functor.Sum.$tc'InL3_bytes:
         I8[] [39,73,110,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.161381608 UTC

[section ""data" . Data.Functor.Sum.$tc'InL2_closure" {
     Data.Functor.Sum.$tc'InL2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$tc'InL3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.161935917 UTC

[section ""data" . Data.Functor.Sum.$tc'InL_closure" {
     Data.Functor.Sum.$tc'InL_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Sum.$trModule_closure+1;
         const Data.Functor.Sum.$tc'InL2_closure+1;
         const Data.Functor.Sum.$tc'InL1_closure+4;
         const 7951421854502432011;
         const 12303552236073891860;
         const 4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.162542661 UTC

[section ""data" . Data.Functor.Sum.$tc'InR1_closure" {
     Data.Functor.Sum.$tc'InR1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rfXPm_closure+3;
         const $krep12_rfXPr_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.163111361 UTC

[section ""cstring" . Data.Functor.Sum.$tc'InR3_bytes" {
     Data.Functor.Sum.$tc'InR3_bytes:
         I8[] [39,73,110,82]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.163711051 UTC

[section ""data" . Data.Functor.Sum.$tc'InR2_closure" {
     Data.Functor.Sum.$tc'InR2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$tc'InR3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.164252691 UTC

[section ""data" . Data.Functor.Sum.$tc'InR_closure" {
     Data.Functor.Sum.$tc'InR_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Sum.$trModule_closure+1;
         const Data.Functor.Sum.$tc'InR2_closure+1;
         const Data.Functor.Sum.$tc'InR1_closure+4;
         const 12078304815884238110;
         const 12377490770432979855;
         const 4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.165584081 UTC

[section ""data" . Data.Functor.Sum.$w$cp1Data_closure" {
     Data.Functor.Sum.$w$cp1Data_closure:
         const Data.Functor.Sum.$w$cp1Data_info;
         const 0;
 },
 Data.Functor.Sum.$w$cp1Data_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfYSx,
                       label: Data.Functor.Sum.$w$cp1Data_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYSx: // global
           _sfY0I::P64 = R5;
           _sfY0H::P64 = R4;
           _sfY0G::P64 = R3;
           _sfY0F::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cfYSB; else goto cfYSC;
       cfYSC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfYSE; else goto cfYSD;
       cfYSE: // global
           HpAlloc = 40;
           goto cfYSB;
       cfYSB: // global
           R5 = _sfY0I::P64;
           R4 = _sfY0H::P64;
           R3 = _sfY0G::P64;
           R2 = _sfY0F::P64;
           R1 = Data.Functor.Sum.$w$cp1Data_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYSD: // global
           I64[Hp - 32] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 24] = _sfY0I::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 32] = block_cfYSq_info;
           R6 = 1;
           R5 = Data.Functor.Sum.$fDataSum7_closure+1;
           R4 = Data.Functor.Sum.$trModule_closure+1;
           R3 = 1236278515871186010;
           R2 = 6345190594862254730;
           P64[Sp - 48] = Data.Functor.Sum.$fDataSum6_closure+4;
           P64[Sp - 40] = Hp - 14;
           P64[Sp - 24] = _sfY0F::P64;
           P64[Sp - 16] = _sfY0G::P64;
           P64[Sp - 8] = _sfY0H::P64;
           Sp = Sp - 48;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 8;
     }
 },
 _cfYSq() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfYSq,
                       label: block_cfYSq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYSq: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cfYSr() args: 0, res: 0, upd: 0;
     }
 },
 _cfYSr() //  []
         { info_tbl: [(cfYSr,
                       label: block_cfYSr_info
                       rep:StackRep [True, False, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYSr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfYSH; else goto cfYSG;
       cfYSH: // global
           HpAlloc = 48;
           I64[Sp] = block_cfYSr_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfYSG: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 40] = block_cfYSv_info;
           R3 = P64[Sp + 56];
           R2 = Hp - 38;
           Sp = Sp + 40;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfYSv() //  [R1]
         { info_tbl: [(cfYSv,
                       label: block_cfYSv_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYSv: // global
           I64[Sp] = block_cfYSA_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfYSA() //  [R1]
         { info_tbl: [(cfYSA,
                       label: block_cfYSA_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYSA: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.167668301 UTC

[section ""data" . Data.Functor.Sum.$fDataSum5_closure" {
     Data.Functor.Sum.$fDataSum5_closure:
         const Data.Functor.Sum.$fDataSum5_info;
         const 0;
 },
 Data.Functor.Sum.$fDataSum5_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfYST,
                       label: Data.Functor.Sum.$fDataSum5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYST: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Sum.$w$cp1Data_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.16845127 UTC

[section ""data" . Data.Functor.Sum.$fDataSum2_closure" {
     Data.Functor.Sum.$fDataSum2_closure:
         const (,)_con_info;
         const Data.Functor.Sum.InL_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.170899878 UTC

[section ""data" . Data.Functor.Sum.$fDataSum1_closure" {
     Data.Functor.Sum.$fDataSum1_closure:
         const (,)_con_info;
         const Data.Functor.Sum.InR_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.17419293 UTC

[section ""data" . Data.Functor.Sum.$w$cgmapMp_closure" {
     Data.Functor.Sum.$w$cgmapMp_closure:
         const Data.Functor.Sum.$w$cgmapMp_info;
 },
 lvl8_sfY15_entry() //  [R1]
         { info_tbl: [(cfYT4,
                       label: lvl8_sfY15_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYT4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYT5; else goto cfYT6;
       cfYT5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYT6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfY1A_entry() //  [R1, R2]
         { info_tbl: [(cfYTj,
                       label: sat_sfY1A_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYTj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYTk; else goto cfYTl;
       cfYTk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYTl: // global
           I64[Sp - 24] = block_cfYTg_info;
           _sfY15::P64 = P64[R1 + 7];
           _sfY16::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfY15::P64;
           P64[Sp - 8] = _sfY16::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufYTD; else goto cfYTh;
       ufYTD: // global
           call _cfYTg(R1) args: 0, res: 0, upd: 0;
       cfYTh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYTg() //  [R1]
         { info_tbl: [(cfYTg,
                       label: block_cfYTg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYTg: // global
           I64[Sp - 8] = block_cfYTo_info;
           _sfY1x::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfY1x::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYTC; else goto cfYTq;
       ufYTC: // global
           call _cfYTo(R1) args: 0, res: 0, upd: 0;
       cfYTq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYTo() //  [R1]
         { info_tbl: [(cfYTo,
                       label: block_cfYTo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYTo: // global
           if (R1 & 7 == 1) goto cfYTw; else goto cfYTA;
       cfYTw: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfYTA: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY1n_entry() //  [R1]
         { info_tbl: [(cfYU4,
                       label: sat_sfY1n_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYU4: // global
           _sfY1n::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cfYU5; else goto cfYU6;
       cfYU6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfYU8; else goto cfYU7;
       cfYU8: // global
           HpAlloc = 56;
           goto cfYU5;
       cfYU5: // global
           R1 = _sfY1n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYU7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY1n::P64;
           _sfY16::P64 = P64[_sfY1n::P64 + 16];
           _sfY1a::P64 = P64[_sfY1n::P64 + 24];
           _sfY1e::P64 = P64[_sfY1n::P64 + 32];
           _sfY1f::P64 = P64[_sfY1n::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY1e::P64;
           P64[Hp - 24] = _sfY1a::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sfY1f::P64;
           R2 = _sfY16::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY1j_entry() //  [R1, R2]
         { info_tbl: [(cfYUk,
                       label: sat_sfY1j_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYUk: // global
           _sfY1g::P64 = R2;
           _sfY1j::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfYUl; else goto cfYUm;
       cfYUm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfYUo; else goto cfYUn;
       cfYUo: // global
           HpAlloc = 56;
           goto cfYUl;
       cfYUl: // global
           R2 = _sfY1g::P64;
           R1 = _sfY1j::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYUn: // global
           _sfY16::P64 = P64[_sfY1j::P64 + 7];
           _sfY1e::P64 = P64[_sfY1j::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY1e::P64;
           P64[Hp - 24] = _sfY1g::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sfY16::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY1k_entry() //  [R1]
         { info_tbl: [(cfYUp,
                       label: sat_sfY1k_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYUp: // global
           _sfY1k::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cfYUq; else goto cfYUr;
       cfYUr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYUt; else goto cfYUs;
       cfYUt: // global
           HpAlloc = 24;
           goto cfYUq;
       cfYUq: // global
           R1 = _sfY1k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYUs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY1k::P64;
           _sfY16::P64 = P64[_sfY1k::P64 + 16];
           _sfY1b::P64 = P64[_sfY1k::P64 + 24];
           _sfY1e::P64 = P64[_sfY1k::P64 + 32];
           I64[Hp - 16] = sat_sfY1j_info;
           P64[Hp - 8] = _sfY16::P64;
           P64[Hp] = _sfY1e::P64;
           R2 = _sfY16::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sfY1b::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sfY1o_entry() //  [R1, R2]
         { info_tbl: [(cfYUu,
                       label: sat_sfY1o_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYUu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfYUv; else goto cfYUw;
       cfYUv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYUw: // global
           I64[Sp - 40] = block_cfYTT_info;
           _sfY12::P64 = P64[R1 + 7];
           _sfY16::P64 = P64[R1 + 15];
           _sfY1a::P64 = P64[R1 + 23];
           _sfY1b::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sfY12::P64;
           P64[Sp - 24] = _sfY16::P64;
           P64[Sp - 16] = _sfY1a::P64;
           P64[Sp - 8] = _sfY1b::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYUA; else goto cfYTU;
       ufYUA: // global
           call _cfYTT(R1) args: 0, res: 0, upd: 0;
       cfYTU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYTT() //  [R1]
         { info_tbl: [(cfYTT,
                       label: block_cfYTT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYTT: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfYUz; else goto cfYUy;
       cfYUz: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYUy: // global
           _sfY1e::P64 = P64[R1 + 7];
           _sfY1f::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sfY1n_info;
           _sfY16::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sfY16::P64;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _sfY1e::P64;
           P64[Hp - 40] = _sfY1f::P64;
           I64[Hp - 32] = sat_sfY1k_info;
           P64[Hp - 16] = _sfY16::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sfY1e::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sfY17_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfYUB,
                       label: k1_sfY17_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYUB: // global
           _sfY1a::P64 = R4;
           _sfY19::P64 = R3;
           _sfY18::P64 = R2;
           _sfY17::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cfYUC; else goto cfYUD;
       cfYUD: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cfYUF; else goto cfYUE;
       cfYUF: // global
           HpAlloc = 80;
           goto cfYUC;
       cfYUC: // global
           R4 = _sfY1a::P64;
           R3 = _sfY19::P64;
           R2 = _sfY18::P64;
           R1 = _sfY17::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYUE: // global
           _sfY12::P64 = P64[_sfY17::P64 + 5];
           _sfY13::P64 = P64[_sfY17::P64 + 13];
           _sfY16::P64 = P64[_sfY17::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sfY13::P64;
           P64[Hp - 48] = _sfY18::P64;
           P64[Hp - 40] = _sfY1a::P64;
           I64[Hp - 32] = sat_sfY1o_info;
           P64[Hp - 24] = _sfY12::P64;
           P64[Hp - 16] = _sfY16::P64;
           P64[Hp - 8] = _sfY1a::P64;
           P64[Hp] = Hp - 72;
           R2 = _sfY16::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sfY19::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY1r_entry() //  [R1]
         { info_tbl: [(cfYUP,
                       label: sat_sfY1r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYUP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYUQ; else goto cfYUR;
       cfYUQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYUR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY1t_entry() //  [R1]
         { info_tbl: [(cfYUY,
                       label: sat_sfY1t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYUY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYUZ; else goto cfYV0;
       cfYUZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYV0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY1u_entry() //  [R1]
         { info_tbl: [(cfYV5,
                       label: sat_sfY1u_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYV5: // global
           _sfY1u::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cfYV6; else goto cfYV7;
       cfYV7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfYV9; else goto cfYV8;
       cfYV9: // global
           HpAlloc = 32;
           goto cfYV6;
       cfYV6: // global
           R1 = _sfY1u::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYV8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY1u::P64;
           _sfY10::P64 = P64[_sfY1u::P64 + 16];
           _sfY11::P64 = P64[_sfY1u::P64 + 24];
           _sfY12::P64 = P64[_sfY1u::P64 + 32];
           _sfY13::P64 = P64[_sfY1u::P64 + 40];
           _sfY14::P64 = P64[_sfY1u::P64 + 48];
           _sfY16::P64 = P64[_sfY1u::P64 + 56];
           I64[Hp - 24] = k1_sfY17_info;
           P64[Hp - 16] = _sfY12::P64;
           P64[Hp - 8] = _sfY13::P64;
           P64[Hp] = _sfY16::P64;
           I64[Sp - 56] = block_cfYUG_info;
           R1 = _sfY14::P64;
           P64[Sp - 48] = Hp - 21;
           P64[Sp - 40] = _sfY10::P64;
           P64[Sp - 32] = _sfY11::P64;
           P64[Sp - 24] = _sfY16::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ufYVg; else goto cfYUH;
       ufYVg: // global
           call _cfYUG(R1) args: 0, res: 0, upd: 0;
       cfYUH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfYUG() //  [R1]
         { info_tbl: [(cfYUG,
                       label: block_cfYUG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYUG: // global
           _cfYTI::P64 = P64[Sp + 8];
           _sfY16::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfYV2; else goto cfYV3;
       cfYV2: // global
           Hp = Hp + 24;
           _sfY1p::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYVf; else goto cfYVb;
       cfYVb: // global
           _sfY1q::P64 = P64[_sfY1p::P64 + 7];
           I64[Hp - 16] = sat_sfY1r_info;
           P64[Hp] = _sfY16::P64;
           R4 = _sfY1q::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _cfYTI::P64;
           Sp = Sp + 40;
           call k1_sfY17_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
       cfYV3: // global
           Hp = Hp + 24;
           _sfY1p::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYVf; else goto cfYVe;
       cfYVf: // global
           HpAlloc = 24;
           R1 = _sfY1p::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfYVe: // global
           _sfY1s::P64 = P64[_sfY1p::P64 + 6];
           I64[Hp - 16] = sat_sfY1t_info;
           P64[Hp] = _sfY16::P64;
           R4 = _sfY1s::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 24];
           R1 = _cfYTI::P64;
           Sp = Sp + 40;
           call k1_sfY17_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgmapMp_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYVh,
                       label: Data.Functor.Sum.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYVh: // global
           _sfY14::P64 = R6;
           _sfY13::P64 = R5;
           _sfY12::P64 = R4;
           _sfY11::P64 = R3;
           _sfY10::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cfYVi; else goto cfYVj;
       cfYVj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYVl; else goto cfYVk;
       cfYVl: // global
           HpAlloc = 24;
           goto cfYVi;
       cfYVi: // global
           R6 = _sfY14::P64;
           R5 = _sfY13::P64;
           R4 = _sfY12::P64;
           R3 = _sfY11::P64;
           R2 = _sfY10::P64;
           R1 = Data.Functor.Sum.$w$cgmapMp_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYVk: // global
           I64[Hp - 16] = lvl8_sfY15_info;
           P64[Hp] = _sfY12::P64;
           I64[Sp - 56] = block_cfYT7_info;
           R2 = _sfY12::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sfY10::P64;
           P64[Sp - 32] = _sfY11::P64;
           P64[Sp - 24] = _sfY12::P64;
           P64[Sp - 16] = _sfY13::P64;
           P64[Sp - 8] = _sfY14::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfYT7() //  [R1]
         { info_tbl: [(cfYT7,
                       label: block_cfYT7_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYT7: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfYVo; else goto cfYVn;
       cfYVo: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYVn: // global
           I64[Hp - 80] = sat_sfY1A_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sfY1u_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.181196179 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapMp_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapMp_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapMp_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapMp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYVq: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapMp_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapMp_entry() //  [R6]
         { info_tbl: [(cfYVu,
                       label: Data.Functor.Sum.$fDataSum_$cgmapMp_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYVu: // global
           _sfY1F::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sfY1F::P64;
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgmapMp_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.183499919 UTC

[section ""data" . Data.Functor.Sum.$w$cgmapM_closure" {
     Data.Functor.Sum.$w$cgmapM_closure:
         const Data.Functor.Sum.$w$cgmapM_info;
 },
 sat_sfY1X_entry() //  [R1, R2]
         { info_tbl: [(cfYVS,
                       label: sat_sfY1X_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYVS: // global
           _sfY1V::P64 = R2;
           _sfY1X::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfYVT; else goto cfYVU;
       cfYVU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfYVW; else goto cfYVV;
       cfYVW: // global
           HpAlloc = 32;
           goto cfYVT;
       cfYVT: // global
           R2 = _sfY1V::P64;
           R1 = _sfY1X::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYVV: // global
           _sfY1M::P64 = P64[_sfY1X::P64 + 7];
           _sfY1U::P64 = P64[_sfY1X::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sfY1U::P64;
           P64[Hp] = _sfY1V::P64;
           R2 = _sfY1M::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY1Y_entry() //  [R1, R2]
         { info_tbl: [(cfYVX,
                       label: sat_sfY1Y_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYVX: // global
           _sfY1U::P64 = R2;
           _sfY1Y::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cfYVY; else goto cfYVZ;
       cfYVZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYW1; else goto cfYW0;
       cfYW1: // global
           HpAlloc = 24;
           goto cfYVY;
       cfYVY: // global
           R2 = _sfY1U::P64;
           R1 = _sfY1Y::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYW0: // global
           _sfY1M::P64 = P64[_sfY1Y::P64 + 7];
           _sfY1T::P64 = P64[_sfY1Y::P64 + 15];
           I64[Hp - 16] = sat_sfY1X_info;
           P64[Hp - 8] = _sfY1M::P64;
           P64[Hp] = _sfY1U::P64;
           R2 = _sfY1M::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sfY1T::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sfY1P_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfYW2,
                       label: k1_sfY1P_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYW2: // global
           _sfY1S::P64 = R4;
           _sfY1R::P64 = R3;
           _sfY1Q::P64 = R2;
           _sfY1P::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cfYW3; else goto cfYW4;
       cfYW4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfYW6; else goto cfYW5;
       cfYW6: // global
           HpAlloc = 64;
           goto cfYW3;
       cfYW3: // global
           R4 = _sfY1S::P64;
           R3 = _sfY1R::P64;
           R2 = _sfY1Q::P64;
           R1 = _sfY1P::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYW5: // global
           _sfY1M::P64 = P64[_sfY1P::P64 + 5];
           _sfY1N::P64 = P64[_sfY1P::P64 + 13];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sfY1N::P64;
           P64[Hp - 32] = _sfY1Q::P64;
           P64[Hp - 24] = _sfY1S::P64;
           I64[Hp - 16] = sat_sfY1Y_info;
           P64[Hp - 8] = _sfY1M::P64;
           P64[Hp] = Hp - 56;
           R2 = _sfY1M::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sfY1R::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY21_entry() //  [R1]
         { info_tbl: [(cfYWg,
                       label: sat_sfY21_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYWg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYWh; else goto cfYWi;
       cfYWh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYWi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.InL_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY23_entry() //  [R1]
         { info_tbl: [(cfYWp,
                       label: sat_sfY23_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYWp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYWq; else goto cfYWr;
       cfYWq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYWr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.InR_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgmapM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYWw,
                       label: Data.Functor.Sum.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYWw: // global
           _sfY1O::P64 = R6;
           _sfY1N::P64 = R5;
           _sfY1M::P64 = R4;
           _sfY1L::P64 = R3;
           _sfY1K::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cfYWx; else goto cfYWy;
       cfYWy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfYWA; else goto cfYWz;
       cfYWA: // global
           HpAlloc = 24;
           goto cfYWx;
       cfYWx: // global
           R6 = _sfY1O::P64;
           R5 = _sfY1N::P64;
           R4 = _sfY1M::P64;
           R3 = _sfY1L::P64;
           R2 = _sfY1K::P64;
           R1 = Data.Functor.Sum.$w$cgmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYWz: // global
           I64[Hp - 16] = k1_sfY1P_info;
           P64[Hp - 8] = _sfY1M::P64;
           P64[Hp] = _sfY1N::P64;
           I64[Sp - 40] = block_cfYW7_info;
           R1 = _sfY1O::P64;
           P64[Sp - 32] = Hp - 13;
           P64[Sp - 24] = _sfY1K::P64;
           P64[Sp - 16] = _sfY1L::P64;
           P64[Sp - 8] = _sfY1M::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYWH; else goto cfYW8;
       ufYWH: // global
           call _cfYW7(R1) args: 0, res: 0, upd: 0;
       cfYW8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYW7() //  [R1]
         { info_tbl: [(cfYW7,
                       label: block_cfYW7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYW7: // global
           _cfYVB::P64 = P64[Sp + 8];
           _sfY1M::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfYWt; else goto cfYWu;
       cfYWt: // global
           Hp = Hp + 24;
           _sfY1Z::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYWG; else goto cfYWC;
       cfYWC: // global
           _sfY20::P64 = P64[_sfY1Z::P64 + 7];
           I64[Hp - 16] = sat_sfY21_info;
           P64[Hp] = _sfY1M::P64;
           R4 = _sfY20::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _cfYVB::P64;
           Sp = Sp + 40;
           call k1_sfY1P_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYWu: // global
           Hp = Hp + 24;
           _sfY1Z::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYWG; else goto cfYWF;
       cfYWG: // global
           HpAlloc = 24;
           R1 = _sfY1Z::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYWF: // global
           _sfY22::P64 = P64[_sfY1Z::P64 + 6];
           I64[Hp - 16] = sat_sfY23_info;
           P64[Hp] = _sfY1M::P64;
           R4 = _sfY22::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 24];
           R1 = _cfYVB::P64;
           Sp = Sp + 40;
           call k1_sfY1P_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.186926332 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapM_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapM_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapM_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapM_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYWJ: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapM_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapM_entry() //  [R6]
         { info_tbl: [(cfYWN,
                       label: Data.Functor.Sum.$fDataSum_$cgmapM_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYWN: // global
           _sfY28::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sfY28::P64;
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgmapM_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.188618972 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapQi_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapQi_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapQi_info;
         const 0;
 },
 Data.Functor.Sum.$fDataSum_$cgmapQi_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYWR: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQi_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapQi_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cfYX2,
                       label: Data.Functor.Sum.$fDataSum_$cgmapQi_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYX2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYX3; else goto cfYX4;
       cfYX3: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgmapQi_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cfYX4: // global
           I64[Sp - 8] = block_cfYWV_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYXz; else goto cfYWW;
       ufYXz: // global
           call _cfYWV(R1) args: 0, res: 0, upd: 0;
       cfYWW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYWV() //  [R1]
         { info_tbl: [(cfYWV,
                       label: block_cfYWV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYWV: // global
           _sfY2j::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfYWZ; else goto cfYX0;
       cfYWZ: // global
           I64[Sp + 8] = block_cfYX7_info;
           _sfY2n::P64 = P64[R1 + 7];
           R1 = _sfY2j::P64;
           P64[Sp + 16] = _sfY2n::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufYXx; else goto cfYX9;
       ufYXx: // global
           call _cfYX7(R1) args: 0, res: 0, upd: 0;
       cfYX9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfYX0: // global
           I64[Sp] = block_cfYXk_info;
           _sfY2r::P64 = P64[R1 + 6];
           R1 = _sfY2j::P64;
           P64[Sp + 32] = _sfY2r::P64;
           if (R1 & 7 != 0) goto ufYXy; else goto cfYXm;
       ufYXy: // global
           call _cfYXk(R1) args: 0, res: 0, upd: 0;
       cfYXm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYX7() //  [R1]
         { info_tbl: [(cfYX7,
                       label: block_cfYX7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYX7: // global
           if (I64[R1 + 7] == 0) goto cfYXh; else goto ufYXw;
       cfYXh: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       ufYXw: // global
           Sp = Sp + 32;
           call _cfYXt() args: 0, res: 0, upd: 0;
     }
 },
 _cfYXk() //  [R1]
         { info_tbl: [(cfYXk,
                       label: block_cfYXk_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYXk: // global
           if (I64[R1 + 7] == 0) goto cfYXu; else goto ufYXv;
       cfYXu: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       ufYXv: // global
           Sp = Sp + 40;
           call _cfYXt() args: 0, res: 0, upd: 0;
     }
 },
 _cfYXt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYXt: // global
           R1 = Data.Maybe.fromJust1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.191170548 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapQr_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapQr_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapQr_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapQr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYXD: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQr_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 48, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapQr_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cfYXO,
                       label: Data.Functor.Sum.$fDataSum_$cgmapQr_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYXO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYXP; else goto cfYXQ;
       cfYXP: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgmapQr_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cfYXQ: // global
           I64[Sp - 8] = block_cfYXH_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYY3; else goto cfYXI;
       ufYY3: // global
           call _cfYXH(R1) args: 0, res: 0, upd: 0;
       cfYXI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYXH() //  [R1]
         { info_tbl: [(cfYXH,
                       label: block_cfYXH_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYXH: // global
           _sfY2B::P64 = P64[Sp + 16];
           _sfY2C::P64 = P64[Sp + 24];
           _sfY2D::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfYXL; else goto cfYXM;
       cfYXL: // global
           Hp = Hp + 40;
           _sfY2F::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYY2; else goto cfYXV;
       cfYXV: // global
           _sfY2G::P64 = P64[_sfY2F::P64 + 7];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sfY2D::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sfY2G::P64;
           R3 = _sfY2C::P64;
           R2 = Hp - 32;
           R1 = _sfY2B::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYXM: // global
           Hp = Hp + 40;
           _sfY2F::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYY2; else goto cfYY1;
       cfYY2: // global
           HpAlloc = 40;
           R1 = _sfY2F::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYY1: // global
           _sfY2I::P64 = P64[_sfY2F::P64 + 6];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sfY2D::P64;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sfY2I::P64;
           R3 = _sfY2C::P64;
           R2 = Hp - 32;
           R1 = _sfY2B::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.193478763 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapQ_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapQ_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapQ_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapQ_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYY5: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQ_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapQ_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYYg,
                       label: Data.Functor.Sum.$fDataSum_$cgmapQ_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYYg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYYh; else goto cfYYi;
       cfYYh: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgmapQ_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cfYYi: // global
           I64[Sp - 8] = block_cfYY9_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYYx; else goto cfYYa;
       ufYYx: // global
           call _cfYY9(R1) args: 0, res: 0, upd: 0;
       cfYYa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYY9() //  [R1]
         { info_tbl: [(cfYY9,
                       label: block_cfYY9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYY9: // global
           _sfY2Q::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfYYd; else goto cfYYe;
       cfYYd: // global
           Hp = Hp + 64;
           _sfY2S::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYYw; else goto cfYYo;
       cfYYo: // global
           _sfY2T::P64 = P64[_sfY2S::P64 + 7];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sfY2Q::P64;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sfY2T::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfYYe: // global
           Hp = Hp + 64;
           _sfY2S::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYYw; else goto cfYYv;
       cfYYw: // global
           HpAlloc = 64;
           R1 = _sfY2S::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYYv: // global
           _sfY2V::P64 = P64[_sfY2S::P64 + 6];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sfY2Q::P64;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sfY2V::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.195724274 UTC

[section ""data" . Data.Functor.Sum.$fDataSum3_closure" {
     Data.Functor.Sum.$fDataSum3_closure:
         const Data.Functor.Sum.$fDataSum3_info;
 },
 Data.Functor.Sum.$fDataSum3_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYYz: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum3_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 48, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYYK,
                       label: Data.Functor.Sum.$fDataSum3_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYYK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYYL; else goto cfYYM;
       cfYYL: // global
           R1 = Data.Functor.Sum.$fDataSum3_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cfYYM: // global
           I64[Sp - 8] = block_cfYYD_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYYZ; else goto cfYYE;
       ufYYZ: // global
           call _cfYYD(R1) args: 0, res: 0, upd: 0;
       cfYYE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYYD() //  [R1]
         { info_tbl: [(cfYYD,
                       label: block_cfYYD_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYYD: // global
           _sfY33::P64 = P64[Sp + 16];
           _sfY34::P64 = P64[Sp + 24];
           _sfY35::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfYYH; else goto cfYYI;
       cfYYH: // global
           Hp = Hp + 40;
           _sfY37::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYYY; else goto cfYYR;
       cfYYR: // global
           _sfY38::P64 = P64[_sfY37::P64 + 7];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sfY35::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sfY38::P64;
           R3 = Hp - 32;
           R2 = _sfY34::P64;
           R1 = _sfY33::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYYI: // global
           Hp = Hp + 40;
           _sfY37::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYYY; else goto cfYYX;
       cfYYY: // global
           HpAlloc = 40;
           R1 = _sfY37::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYYX: // global
           _sfY3a::P64 = P64[_sfY37::P64 + 6];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sfY35::P64;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sfY3a::P64;
           R3 = Hp - 32;
           R2 = _sfY34::P64;
           R1 = _sfY33::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.198144098 UTC

[section ""data" . Data.Functor.Sum.$fDataSum4_closure" {
     Data.Functor.Sum.$fDataSum4_closure:
         const Data.Functor.Sum.$fDataSum4_info;
 },
 Data.Functor.Sum.$fDataSum4_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYZ1: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfYZc,
                       label: Data.Functor.Sum.$fDataSum4_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYZc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYZd; else goto cfYZe;
       cfYZd: // global
           R1 = Data.Functor.Sum.$fDataSum4_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cfYZe: // global
           I64[Sp - 8] = block_cfYZ5_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYZt; else goto cfYZ6;
       ufYZt: // global
           call _cfYZ5(R1) args: 0, res: 0, upd: 0;
       cfYZ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYZ5() //  [R1]
         { info_tbl: [(cfYZ5,
                       label: block_cfYZ5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYZ5: // global
           _sfY3i::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfYZ9; else goto cfYZa;
       cfYZ9: // global
           Hp = Hp + 56;
           _sfY3k::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYZs; else goto cfYZk;
       cfYZk: // global
           _sfY3l::P64 = P64[_sfY3k::P64 + 7];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = _sfY3i::P64;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sfY3l::P64;
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfYZa: // global
           Hp = Hp + 56;
           _sfY3k::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfYZs; else goto cfYZr;
       cfYZs: // global
           HpAlloc = 56;
           R1 = _sfY3k::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfYZr: // global
           _sfY3n::P64 = P64[_sfY3k::P64 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = _sfY3i::P64;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sfY3n::P64;
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.202638888 UTC

[section ""data" . Data.Functor.Sum.$w$cgmapMo_closure" {
     Data.Functor.Sum.$w$cgmapMo_closure:
         const Data.Functor.Sum.$w$cgmapMo_info;
 },
 lvl8_sfY3u_entry() //  [R1]
         { info_tbl: [(cfYZC,
                       label: lvl8_sfY3u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYZC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYZD; else goto cfYZE;
       cfYZD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYZE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfY42_entry() //  [R1, R2]
         { info_tbl: [(cfYZR,
                       label: sat_sfY42_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYZR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfYZS; else goto cfYZT;
       cfYZS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYZT: // global
           I64[Sp - 24] = block_cfYZO_info;
           _sfY3u::P64 = P64[R1 + 7];
           _sfY3v::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfY3u::P64;
           P64[Sp - 8] = _sfY3v::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufZ0b; else goto cfYZP;
       ufZ0b: // global
           call _cfYZO(R1) args: 0, res: 0, upd: 0;
       cfYZP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYZO() //  [R1]
         { info_tbl: [(cfYZO,
                       label: block_cfYZO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYZO: // global
           I64[Sp - 8] = block_cfYZW_info;
           _sfY3Z::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfY3Z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZ0a; else goto cfYZY;
       ufZ0a: // global
           call _cfYZW(R1) args: 0, res: 0, upd: 0;
       cfYZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfYZW() //  [R1]
         { info_tbl: [(cfYZW,
                       label: block_cfYZW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYZW: // global
           if (R1 & 7 == 1) goto cfZ04; else goto cfZ08;
       cfZ04: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfZ08: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY3N_entry() //  [R1]
         { info_tbl: [(cfZ0H,
                       label: sat_sfY3N_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ0H: // global
           _sfY3N::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cfZ0I; else goto cfZ0J;
       cfZ0J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZ0L; else goto cfZ0K;
       cfZ0L: // global
           HpAlloc = 56;
           goto cfZ0I;
       cfZ0I: // global
           R1 = _sfY3N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZ0K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY3N::P64;
           _sfY3v::P64 = P64[_sfY3N::P64 + 16];
           _sfY3z::P64 = P64[_sfY3N::P64 + 24];
           _sfY3D::P64 = P64[_sfY3N::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY3D::P64;
           P64[Hp - 24] = _sfY3z::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sfY3v::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY3J_entry() //  [R1, R2]
         { info_tbl: [(cfZ0X,
                       label: sat_sfY3J_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ0X: // global
           _sfY3G::P64 = R2;
           _sfY3J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfZ0Y; else goto cfZ0Z;
       cfZ0Z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZ11; else goto cfZ10;
       cfZ11: // global
           HpAlloc = 56;
           goto cfZ0Y;
       cfZ0Y: // global
           R2 = _sfY3G::P64;
           R1 = _sfY3J::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZ10: // global
           _sfY3v::P64 = P64[_sfY3J::P64 + 7];
           _sfY3D::P64 = P64[_sfY3J::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY3D::P64;
           P64[Hp - 24] = _sfY3G::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sfY3v::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY3K_entry() //  [R1]
         { info_tbl: [(cfZ12,
                       label: sat_sfY3K_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ12: // global
           _sfY3K::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cfZ13; else goto cfZ14;
       cfZ14: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZ16; else goto cfZ15;
       cfZ16: // global
           HpAlloc = 24;
           goto cfZ13;
       cfZ13: // global
           R1 = _sfY3K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZ15: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY3K::P64;
           _sfY3v::P64 = P64[_sfY3K::P64 + 16];
           _sfY3A::P64 = P64[_sfY3K::P64 + 24];
           _sfY3D::P64 = P64[_sfY3K::P64 + 32];
           I64[Hp - 16] = sat_sfY3J_info;
           P64[Hp - 8] = _sfY3v::P64;
           P64[Hp] = _sfY3D::P64;
           R2 = _sfY3v::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sfY3A::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sfY3Q_entry() //  [R1, R2]
         { info_tbl: [(cfZ17,
                       label: sat_sfY3Q_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ17: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfZ18; else goto cfZ19;
       cfZ18: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZ19: // global
           I64[Sp - 40] = block_cfZ0r_info;
           _sfY3r::P64 = P64[R1 + 7];
           _sfY3v::P64 = P64[R1 + 15];
           _sfY3z::P64 = P64[R1 + 23];
           _sfY3A::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sfY3r::P64;
           P64[Sp - 24] = _sfY3v::P64;
           P64[Sp - 16] = _sfY3z::P64;
           P64[Sp - 8] = _sfY3A::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZ1q; else goto cfZ0s;
       ufZ1q: // global
           call _cfZ0r(R1) args: 0, res: 0, upd: 0;
       cfZ0s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZ0r() //  [R1]
         { info_tbl: [(cfZ0r,
                       label: block_cfZ0r_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ0r: // global
           I64[Sp - 8] = block_cfZ0w_info;
           _sfY3D::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfY3D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZ1p; else goto cfZ0x;
       ufZ1p: // global
           call _cfZ0w(R1) args: 0, res: 0, upd: 0;
       cfZ0x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZ0w() //  [R1]
         { info_tbl: [(cfZ0w,
                       label: block_cfZ0w_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ0w: // global
           _sfY3v::P64 = P64[Sp + 24];
           _sfY3z::P64 = P64[Sp + 32];
           _sfY3D::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cfZ1c; else goto cfZ1g;
       cfZ1c: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cfZ1f; else goto cfZ1e;
       cfZ1f: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZ1e: // global
           I64[Hp - 72] = sat_sfY3N_info;
           P64[Hp - 56] = _sfY3v::P64;
           P64[Hp - 48] = _sfY3z::P64;
           P64[Hp - 40] = _sfY3D::P64;
           I64[Hp - 32] = sat_sfY3K_info;
           P64[Hp - 16] = _sfY3v::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sfY3D::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cfZ1g: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZ1l; else goto cfZ1k;
       cfZ1l: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZ1k: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY3D::P64;
           P64[Hp - 24] = _sfY3z::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sfY3v::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 k1_sfY3w_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZ1r,
                       label: k1_sfY3w_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ1r: // global
           _sfY3z::P64 = R4;
           _sfY3y::P64 = R3;
           _sfY3x::P64 = R2;
           _sfY3w::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cfZ1s; else goto cfZ1t;
       cfZ1t: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cfZ1v; else goto cfZ1u;
       cfZ1v: // global
           HpAlloc = 80;
           goto cfZ1s;
       cfZ1s: // global
           R4 = _sfY3z::P64;
           R3 = _sfY3y::P64;
           R2 = _sfY3x::P64;
           R1 = _sfY3w::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ1u: // global
           _sfY3r::P64 = P64[_sfY3w::P64 + 5];
           _sfY3s::P64 = P64[_sfY3w::P64 + 13];
           _sfY3v::P64 = P64[_sfY3w::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sfY3s::P64;
           P64[Hp - 48] = _sfY3x::P64;
           P64[Hp - 40] = _sfY3z::P64;
           I64[Hp - 32] = sat_sfY3Q_info;
           P64[Hp - 24] = _sfY3r::P64;
           P64[Hp - 16] = _sfY3v::P64;
           P64[Hp - 8] = _sfY3z::P64;
           P64[Hp] = Hp - 72;
           R2 = _sfY3v::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sfY3y::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY3T_entry() //  [R1]
         { info_tbl: [(cfZ1F,
                       label: sat_sfY3T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ1F: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZ1G; else goto cfZ1H;
       cfZ1G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZ1H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY3V_entry() //  [R1]
         { info_tbl: [(cfZ1O,
                       label: sat_sfY3V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ1O: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZ1P; else goto cfZ1Q;
       cfZ1P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZ1Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY3W_entry() //  [R1]
         { info_tbl: [(cfZ1V,
                       label: sat_sfY3W_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ1V: // global
           _sfY3W::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cfZ1W; else goto cfZ1X;
       cfZ1X: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfZ1Z; else goto cfZ1Y;
       cfZ1Z: // global
           HpAlloc = 32;
           goto cfZ1W;
       cfZ1W: // global
           R1 = _sfY3W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZ1Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY3W::P64;
           _sfY3p::P64 = P64[_sfY3W::P64 + 16];
           _sfY3q::P64 = P64[_sfY3W::P64 + 24];
           _sfY3r::P64 = P64[_sfY3W::P64 + 32];
           _sfY3s::P64 = P64[_sfY3W::P64 + 40];
           _sfY3t::P64 = P64[_sfY3W::P64 + 48];
           _sfY3v::P64 = P64[_sfY3W::P64 + 56];
           I64[Hp - 24] = k1_sfY3w_info;
           P64[Hp - 16] = _sfY3r::P64;
           P64[Hp - 8] = _sfY3s::P64;
           P64[Hp] = _sfY3v::P64;
           I64[Sp - 56] = block_cfZ1w_info;
           R1 = _sfY3t::P64;
           P64[Sp - 48] = Hp - 21;
           P64[Sp - 40] = _sfY3p::P64;
           P64[Sp - 32] = _sfY3q::P64;
           P64[Sp - 24] = _sfY3v::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ufZ26; else goto cfZ1x;
       ufZ26: // global
           call _cfZ1w(R1) args: 0, res: 0, upd: 0;
       cfZ1x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfZ1w() //  [R1]
         { info_tbl: [(cfZ1w,
                       label: block_cfZ1w_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ1w: // global
           _cfZ0g::P64 = P64[Sp + 8];
           _sfY3v::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZ1S; else goto cfZ1T;
       cfZ1S: // global
           Hp = Hp + 24;
           _sfY3R::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZ25; else goto cfZ21;
       cfZ21: // global
           _sfY3S::P64 = P64[_sfY3R::P64 + 7];
           I64[Hp - 16] = sat_sfY3T_info;
           P64[Hp] = _sfY3v::P64;
           R4 = _sfY3S::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _cfZ0g::P64;
           Sp = Sp + 40;
           call k1_sfY3w_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
       cfZ1T: // global
           Hp = Hp + 24;
           _sfY3R::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZ25; else goto cfZ24;
       cfZ25: // global
           HpAlloc = 24;
           R1 = _sfY3R::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfZ24: // global
           _sfY3U::P64 = P64[_sfY3R::P64 + 6];
           I64[Hp - 16] = sat_sfY3V_info;
           P64[Hp] = _sfY3v::P64;
           R4 = _sfY3U::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 24];
           R1 = _cfZ0g::P64;
           Sp = Sp + 40;
           call k1_sfY3w_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgmapMo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZ27,
                       label: Data.Functor.Sum.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ27: // global
           _sfY3t::P64 = R6;
           _sfY3s::P64 = R5;
           _sfY3r::P64 = R4;
           _sfY3q::P64 = R3;
           _sfY3p::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cfZ28; else goto cfZ29;
       cfZ29: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZ2b; else goto cfZ2a;
       cfZ2b: // global
           HpAlloc = 24;
           goto cfZ28;
       cfZ28: // global
           R6 = _sfY3t::P64;
           R5 = _sfY3s::P64;
           R4 = _sfY3r::P64;
           R3 = _sfY3q::P64;
           R2 = _sfY3p::P64;
           R1 = Data.Functor.Sum.$w$cgmapMo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ2a: // global
           I64[Hp - 16] = lvl8_sfY3u_info;
           P64[Hp] = _sfY3r::P64;
           I64[Sp - 56] = block_cfYZF_info;
           R2 = _sfY3r::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sfY3p::P64;
           P64[Sp - 32] = _sfY3q::P64;
           P64[Sp - 24] = _sfY3r::P64;
           P64[Sp - 16] = _sfY3s::P64;
           P64[Sp - 8] = _sfY3t::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfYZF() //  [R1]
         { info_tbl: [(cfYZF,
                       label: block_cfYZF_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYZF: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfZ2e; else goto cfZ2d;
       cfZ2e: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZ2d: // global
           I64[Hp - 80] = sat_sfY42_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sfY3W_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.209611682 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapMo_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapMo_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapMo_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapMo_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ2g: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapMo_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapMo_entry() //  [R6]
         { info_tbl: [(cfZ2k,
                       label: Data.Functor.Sum.$fDataSum_$cgmapMo_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ2k: // global
           _sfY47::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sfY47::P64;
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgmapMo_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.210925659 UTC

[section ""data" . lvl4_rfXPs_closure" {
     lvl4_rfXPs_closure:
         const lvl4_rfXPs_info;
         const 0;
 },
 lvl4_rfXPs_entry() //  [R2]
         { info_tbl: [(cfZ2y,
                       label: lvl4_rfXPs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ2y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZ2z; else goto cfZ2A;
       cfZ2z: // global
           R2 = R2;
           R1 = lvl4_rfXPs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZ2A: // global
           I64[Sp - 8] = block_cfZ2r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZ2H; else goto cfZ2s;
       ufZ2H: // global
           call _cfZ2r(R1) args: 0, res: 0, upd: 0;
       cfZ2s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZ2r() //  [R1]
         { info_tbl: [(cfZ2r,
                       label: block_cfZ2r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ2r: // global
           if (R1 & 7 == 1) goto cfZ2v; else goto cfZ2w;
       cfZ2v: // global
           R1 = Data.Functor.Sum.$cInL_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfZ2w: // global
           R1 = Data.Functor.Sum.$cInR_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.212114627 UTC

[section ""data" . lvl5_rfXPt_closure" {
     lvl5_rfXPt_closure:
         const lvl5_rfXPt_info;
         const 0;
 },
 lvl5_rfXPt_entry() //  []
         { info_tbl: [(cfZ2M,
                       label: lvl5_rfXPt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ2M: // global
           R1 = Data.Functor.Sum.$tSum_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.212974376 UTC

[section ""data" . lvl6_rfXPu_closure" {
     lvl6_rfXPu_closure:
         const lvl6_rfXPu_info;
 },
 lvl6_rfXPu_entry() //  []
         { info_tbl: [(cfZ2T,
                       label: lvl6_rfXPu_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ2T: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.213993857 UTC

[section ""data" . lvl7_rfXPv_closure" {
     lvl7_rfXPv_closure:
         const lvl7_rfXPv_info;
 },
 lvl7_rfXPv_entry() //  []
         { info_tbl: [(cfZ30,
                       label: lvl7_rfXPv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ30: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.217000595 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_closure" {
     Data.Functor.Sum.$fDataSum_closure:
         const Data.Functor.Sum.$fDataSum_info;
         const 0;
 },
 sat_sfY4K_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZ3c,
                       label: sat_sfY4K_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ3c: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$w$cgmapMo_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfY4G_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZ3k,
                       label: sat_sfY4G_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ3k: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$w$cgmapMp_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfY4C_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZ3s,
                       label: sat_sfY4C_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ3s: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$w$cgmapM_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfY4y_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZ3A,
                       label: sat_sfY4y_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ3A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZ3B; else goto cfZ3C;
       cfZ3B: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ3C: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Sum.$fDataSum_$cgmapQi_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sfY4x_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZ3I,
                       label: sat_sfY4x_info
                       rep:HeapRep 6 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ3I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfZ3J; else goto cfZ3K;
       cfZ3J: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ3K: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 46];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fDataSum_$cgmapQ_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY4w_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfZ3Q,
                       label: sat_sfY4w_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ3Q: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZ3R; else goto cfZ3S;
       cfZ3R: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ3S: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQr_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sfY4v_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfZ3Y,
                       label: sat_sfY4v_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ3Y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZ3Z; else goto cfZ40;
       cfZ3Z: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ40: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Sum.$fDataSum3_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sfY4u_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZ46,
                       label: sat_sfY4u_info
                       rep:HeapRep 6 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ46: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfZ47; else goto cfZ48;
       cfZ47: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ48: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 46];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fDataSum4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY4t_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZ4e,
                       label: sat_sfY4t_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ4e: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZ4f; else goto cfZ4g;
       cfZ4f: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ4g: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Sum.$fDataSum_$cgunfold_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sfY4s_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZ4m,
                       label: sat_sfY4s_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ4m: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZ4n; else goto cfZ4o;
       cfZ4n: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ4o: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Sum.$fDataSum_$cgfoldl_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sfY4r_entry() //  [R1]
         { info_tbl: [(cfZ4t,
                       label: sat_sfY4r_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ4t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZ4u; else goto cfZ4v;
       cfZ4u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZ4v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$w$cp1Data_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fDataSum_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZ4x,
                       label: Data.Functor.Sum.$fDataSum_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ4x: // global
           Hp = Hp + 640;
           if (Hp > HpLim) (likely: False) goto cfZ4B; else goto cfZ4A;
       cfZ4B: // global
           HpAlloc = 640;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fDataSum_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfZ4A: // global
           I64[Hp - 632] = sat_sfY4K_info;
           P64[Hp - 624] = R6;
           _sfY4q::P64 = P64[Sp];
           P64[Hp - 616] = _sfY4q::P64;
           I64[Hp - 608] = sat_sfY4G_info;
           P64[Hp - 600] = R6;
           P64[Hp - 592] = _sfY4q::P64;
           I64[Hp - 584] = sat_sfY4C_info;
           P64[Hp - 576] = R6;
           P64[Hp - 568] = _sfY4q::P64;
           I64[Hp - 560] = sat_sfY4y_info;
           P64[Hp - 552] = R2;
           P64[Hp - 544] = R3;
           P64[Hp - 536] = R4;
           P64[Hp - 528] = R5;
           P64[Hp - 520] = R6;
           P64[Hp - 512] = _sfY4q::P64;
           I64[Hp - 504] = sat_sfY4x_info;
           P64[Hp - 496] = R2;
           P64[Hp - 488] = R3;
           P64[Hp - 480] = R4;
           P64[Hp - 472] = R5;
           P64[Hp - 464] = R6;
           P64[Hp - 456] = _sfY4q::P64;
           I64[Hp - 448] = sat_sfY4w_info;
           P64[Hp - 440] = R2;
           P64[Hp - 432] = R3;
           P64[Hp - 424] = R4;
           P64[Hp - 416] = R5;
           P64[Hp - 408] = R6;
           P64[Hp - 400] = _sfY4q::P64;
           I64[Hp - 392] = sat_sfY4v_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           P64[Hp - 368] = R4;
           P64[Hp - 360] = R5;
           P64[Hp - 352] = R6;
           P64[Hp - 344] = _sfY4q::P64;
           I64[Hp - 336] = sat_sfY4u_info;
           P64[Hp - 328] = R2;
           P64[Hp - 320] = R3;
           P64[Hp - 312] = R4;
           P64[Hp - 304] = R5;
           P64[Hp - 296] = R6;
           P64[Hp - 288] = _sfY4q::P64;
           I64[Hp - 280] = sat_sfY4t_info;
           P64[Hp - 272] = R2;
           P64[Hp - 264] = R3;
           P64[Hp - 256] = R4;
           P64[Hp - 248] = R5;
           P64[Hp - 240] = R6;
           P64[Hp - 232] = _sfY4q::P64;
           I64[Hp - 224] = sat_sfY4s_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           P64[Hp - 200] = R4;
           P64[Hp - 192] = R5;
           P64[Hp - 184] = R6;
           P64[Hp - 176] = _sfY4q::P64;
           I64[Hp - 168] = sat_sfY4r_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           P64[Hp - 136] = R4;
           P64[Hp - 128] = R5;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 168;
           P64[Hp - 104] = Hp - 221;
           P64[Hp - 96] = Hp - 277;
           P64[Hp - 88] = lvl4_rfXPs_closure+1;
           P64[Hp - 80] = lvl5_rfXPt_closure+1;
           P64[Hp - 72] = lvl6_rfXPu_closure+2;
           P64[Hp - 64] = lvl7_rfXPv_closure+2;
           P64[Hp - 56] = Hp - 334;
           P64[Hp - 48] = Hp - 388;
           P64[Hp - 40] = Hp - 444;
           P64[Hp - 32] = Hp - 502;
           P64[Hp - 24] = Hp - 557;
           P64[Hp - 16] = Hp - 581;
           P64[Hp - 8] = Hp - 605;
           P64[Hp] = Hp - 629;
           R1 = Hp - 119;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.222311492 UTC

[section ""data" . Data.Functor.Sum.InL_closure" {
     Data.Functor.Sum.InL_closure:
         const Data.Functor.Sum.InL_info;
 },
 Data.Functor.Sum.InL_entry() //  [R2]
         { info_tbl: [(cfZ4H,
                       label: Data.Functor.Sum.InL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ4H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZ4L; else goto cfZ4K;
       cfZ4L: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Functor.Sum.InL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZ4K: // global
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.223239791 UTC

[section ""data" . Data.Functor.Sum.InR_closure" {
     Data.Functor.Sum.InR_closure:
         const Data.Functor.Sum.InR_info;
 },
 Data.Functor.Sum.InR_entry() //  [R2]
         { info_tbl: [(cfZ4R,
                       label: Data.Functor.Sum.InR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ4R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZ4V; else goto cfZ4U;
       cfZ4V: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Functor.Sum.InR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZ4U: // global
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.224146335 UTC

[Data.Functor.Sum.InL_con_entry() //  [R1]
         { info_tbl: [(cfZ4W,
                       label: Data.Functor.Sum.InL_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,83,117,109,46,73,110,76]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ4W: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.22488839 UTC

[Data.Functor.Sum.InR_con_entry() //  [R1]
         { info_tbl: [(cfZ4X,
                       label: Data.Functor.Sum.InR_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,83,117,109,46,73,110,82]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ4X: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.225611814 UTC

[section ""relreadonly" . SfYa7_srt" {
     SfYa7_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Sum.$fRead1Sum2_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Data.Functor.Sum.$fRead1Sum6_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Sum.$fRead1Sum1_closure;
         const Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure;
         const Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure;
         const Data.Functor.Sum.$fRead1Sum_closure;
         const Data.Functor.Sum.$fRead1Sum3_closure;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const Data.Functor.Sum.$w$cliftShowsPrec_closure;
         const Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure;
         const Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure;
         const Data.Functor.Sum.$fShow1Sum_closure;
         const Data.Functor.Sum.$fReadSum1_closure;
         const Data.Functor.Sum.$fReadSum_$creadsPrec_closure;
         const Data.Functor.Sum.$fReadSum_$creadListPrec_closure;
         const Data.Functor.Sum.$fReadSum_$creadList_closure;
         const Data.Functor.Sum.$fReadSum_closure;
         const Data.Functor.Sum.$fShowSum_$cshowsPrec_closure;
         const Data.Functor.Sum.$fShowSum_$cshow_closure;
         const Data.Functor.Sum.$fShowSum_$cshowList_closure;
         const Data.Functor.Sum.$fShowSum_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Functor.Sum.$fFoldableSum3_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Functor.Sum.$fFoldableSum4_closure;
         const Data.Functor.Sum.$fFoldableSum_$cminimum_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Sum.$fFoldableSum5_closure;
         const Data.Functor.Sum.$fFoldableSum_$cmaximum_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Functor.Sum.$fFoldableSum_$celem_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Functor.Sum.$fFoldableSum10_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldl_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure;
         const Data.Functor.Sum.$fFoldableSum9_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldr_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure;
         const Data.Functor.Sum.$fFoldableSum_$clength_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure;
         const Data.Functor.Sum.$fFoldableSum11_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Functor.Sum.$fFoldableSum1_closure;
         const Data.Functor.Sum.$fFoldableSum_$cnull_closure;
         const Data.Functor.Sum.$fFoldableSum_$ctoList_closure;
         const Data.Functor.Sum.$fFoldableSum_closure;
         const Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure;
         const Data.Functor.Sum.$fTraversableSum_closure;
         const Data.Data.$wlvl_closure;
         const Data.Functor.Sum.$w$cgunfold_closure;
         const Data.Functor.Sum.$fDataSum_$cgunfold_closure;
         const GHC.List.badHead_closure;
         const go61_rfXP6_closure;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const go1_rfXP7_closure;
         const Data.Data.mkConstr1_closure;
         const $tSum3_rfXPb_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Functor.Sum.$w$cp1Data_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Functor.Sum.$fDataSum_$cgmapQi_closure;
         const Data.Functor.Sum.$cInL_closure;
         const Data.Functor.Sum.$cInR_closure;
         const lvl4_rfXPs_closure;
         const Data.Functor.Sum.$tSum_closure;
         const Data.Functor.Sum.$fDataSum_closure;
         const lvl5_rfXPt_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.22662906 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:47.227891701 UTC

[section ""data" . Data.Functor.Sum.$fEq1Sum_$cliftEq_closure" {
     Data.Functor.Sum.$fEq1Sum_$cliftEq_closure:
         const Data.Functor.Sum.$fEq1Sum_$cliftEq_info;
 },
 Data.Functor.Sum.$fEq1Sum_$cliftEq_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZ59,
                       label: Data.Functor.Sum.$fEq1Sum_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ59: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZ5a; else goto cfZ5b;
       cfZ5a: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEq1Sum_$cliftEq_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ5b: // global
           I64[Sp - 40] = block_cfZ52_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZ5M; else goto cfZ53;
       ufZ5M: // global
           call _cfZ52(R1) args: 0, res: 0, upd: 0;
       cfZ53: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZ52() //  [R1]
         { info_tbl: [(cfZ52,
                       label: block_cfZ52_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ52: // global
           _sfXPB::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZ56; else goto cfZ57;
       cfZ56: // global
           I64[Sp] = block_cfZ5e_info;
           _sfXPD::P64 = P64[R1 + 7];
           R1 = _sfXPB::P64;
           P64[Sp + 32] = _sfXPD::P64;
           if (R1 & 7 != 0) goto ufZ5K; else goto cfZ5g;
       ufZ5K: // global
           call _cfZ5e(R1) args: 0, res: 0, upd: 0;
       cfZ5g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfZ57: // global
           I64[Sp + 8] = block_cfZ5t_info;
           _sfXPH::P64 = P64[R1 + 6];
           R1 = _sfXPB::P64;
           P64[Sp + 32] = _sfXPH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufZ5L; else goto cfZ5v;
       ufZ5L: // global
           call _cfZ5t(R1) args: 0, res: 0, upd: 0;
       cfZ5v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZ5e() //  [R1]
         { info_tbl: [(cfZ5e,
                       label: block_cfZ5e_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ5e: // global
           if (R1 & 7 == 1) goto cfZ5m; else goto ufZ5J;
       cfZ5m: // global
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ufZ5J: // global
           Sp = Sp + 40;
           call _cfZ5B() args: 0, res: 0, upd: 0;
     }
 },
 _cfZ5t() //  [R1]
         { info_tbl: [(cfZ5t,
                       label: block_cfZ5t_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ5t: // global
           if (R1 & 7 == 1) goto ufZ5I; else goto cfZ5F;
       ufZ5I: // global
           Sp = Sp + 32;
           call _cfZ5B() args: 0, res: 0, upd: 0;
       cfZ5F: // global
           R4 = P64[R1 + 6];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZ5B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ5B: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.230040952 UTC

[section ""data" . Data.Functor.Sum.$fEq1Sum_closure" {
     Data.Functor.Sum.$fEq1Sum_closure:
         const Data.Functor.Sum.$fEq1Sum_info;
 },
 Data.Functor.Sum.$fEq1Sum_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZ5T,
                       label: Data.Functor.Sum.$fEq1Sum_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ5T: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fEq1Sum_$cliftEq_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.231387116 UTC

[section ""data" . Data.Functor.Sum.$fOrd1Sum_$cliftCompare_closure" {
     Data.Functor.Sum.$fOrd1Sum_$cliftCompare_closure:
         const Data.Functor.Sum.$fOrd1Sum_$cliftCompare_info;
 },
 Data.Functor.Sum.$fOrd1Sum_$cliftCompare_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cfZ67,
                       label: Data.Functor.Sum.$fOrd1Sum_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ67: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZ68; else goto cfZ69;
       cfZ68: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrd1Sum_$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ69: // global
           I64[Sp - 40] = block_cfZ60_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZ6I; else goto cfZ61;
       ufZ6I: // global
           call _cfZ60(R1) args: 0, res: 0, upd: 0;
       cfZ61: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZ60() //  [R1]
         { info_tbl: [(cfZ60,
                       label: block_cfZ60_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ60: // global
           _sfXPP::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZ64; else goto cfZ65;
       cfZ64: // global
           I64[Sp] = block_cfZ6c_info;
           _sfXPR::P64 = P64[R1 + 7];
           R1 = _sfXPP::P64;
           P64[Sp + 32] = _sfXPR::P64;
           if (R1 & 7 != 0) goto ufZ6G; else goto cfZ6e;
       ufZ6G: // global
           call _cfZ6c(R1) args: 0, res: 0, upd: 0;
       cfZ6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfZ65: // global
           I64[Sp + 8] = block_cfZ6r_info;
           _sfXPV::P64 = P64[R1 + 6];
           R1 = _sfXPP::P64;
           P64[Sp + 32] = _sfXPV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufZ6H; else goto cfZ6t;
       ufZ6H: // global
           call _cfZ6r(R1) args: 0, res: 0, upd: 0;
       cfZ6t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZ6c() //  [R1]
         { info_tbl: [(cfZ6c,
                       label: block_cfZ6c_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ6c: // global
           if (R1 & 7 == 1) goto cfZ6k; else goto cfZ6o;
       cfZ6k: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
       cfZ6o: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZ6r() //  [R1]
         { info_tbl: [(cfZ6r,
                       label: block_cfZ6r_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ6r: // global
           if (R1 & 7 == 1) goto cfZ6z; else goto cfZ6D;
       cfZ6z: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfZ6D: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.233873051 UTC

[section ""data" . Data.Functor.Sum.$fOrd1Sum1_closure" {
     Data.Functor.Sum.$fOrd1Sum1_closure:
         const Data.Functor.Sum.$fOrd1Sum1_info;
 },
 Data.Functor.Sum.$fOrd1Sum1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZ6U,
                       label: Data.Functor.Sum.$fOrd1Sum1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ6U: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZ6V; else goto cfZ6W;
       cfZ6V: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrd1Sum1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ6W: // global
           I64[Sp - 40] = block_cfZ6N_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZ7x; else goto cfZ6O;
       ufZ7x: // global
           call _cfZ6N(R1) args: 0, res: 0, upd: 0;
       cfZ6O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZ6N() //  [R1]
         { info_tbl: [(cfZ6N,
                       label: block_cfZ6N_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ6N: // global
           _sfXQ3::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZ6R; else goto cfZ6S;
       cfZ6R: // global
           I64[Sp] = block_cfZ6Z_info;
           _sfXQ5::P64 = P64[R1 + 7];
           R1 = _sfXQ3::P64;
           P64[Sp + 32] = _sfXQ5::P64;
           if (R1 & 7 != 0) goto ufZ7v; else goto cfZ71;
       ufZ7v: // global
           call _cfZ6Z(R1) args: 0, res: 0, upd: 0;
       cfZ71: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfZ6S: // global
           I64[Sp + 8] = block_cfZ7e_info;
           _sfXQ9::P64 = P64[R1 + 6];
           R1 = _sfXQ3::P64;
           P64[Sp + 32] = _sfXQ9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufZ7w; else goto cfZ7g;
       ufZ7w: // global
           call _cfZ7e(R1) args: 0, res: 0, upd: 0;
       cfZ7g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZ6Z() //  [R1]
         { info_tbl: [(cfZ6Z,
                       label: block_cfZ6Z_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ6Z: // global
           if (R1 & 7 == 1) goto cfZ77; else goto ufZ7u;
       cfZ77: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
       ufZ7u: // global
           Sp = Sp + 40;
           call _cfZ7m() args: 0, res: 0, upd: 0;
     }
 },
 _cfZ7e() //  [R1]
         { info_tbl: [(cfZ7e,
                       label: block_cfZ7e_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ7e: // global
           if (R1 & 7 == 1) goto ufZ7t; else goto cfZ7q;
       ufZ7t: // global
           Sp = Sp + 32;
           call _cfZ7m() args: 0, res: 0, upd: 0;
       cfZ7q: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cfZ7m() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ7m: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.236165884 UTC

[section ""data" . Data.Functor.Sum.$fOrd1Sum_closure" {
     Data.Functor.Sum.$fOrd1Sum_closure:
         const Data.Functor.Sum.$fOrd1Sum_info;
 },
 sat_sfXQg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZ7J,
                       label: sat_sfXQg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ7J: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fOrd1Sum_$cliftCompare_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZ7R,
                       label: sat_sfXQf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ7R: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fOrd1Sum1_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fOrd1Sum_entry() //  [R2, R3]
         { info_tbl: [(cfZ7V,
                       label: Data.Functor.Sum.$fOrd1Sum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ7V: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfZ7Z; else goto cfZ7Y;
       cfZ7Z: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrd1Sum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ7Y: // global
           I64[Hp - 64] = sat_sfXQg_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sfXQf_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 37;
           P64[Hp] = Hp - 61;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.237501774 UTC

[section ""cstring" . Data.Functor.Sum.$fRead1Sum8_bytes" {
     Data.Functor.Sum.$fRead1Sum8_bytes:
         I8[] [73,110,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.238249103 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum7_closure" {
     Data.Functor.Sum.$fRead1Sum7_closure:
         const Data.Functor.Sum.$fRead1Sum7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fRead1Sum7_entry() //  [R1]
         { info_tbl: [(cfZ86,
                       label: Data.Functor.Sum.$fRead1Sum7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ86: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZ87; else goto cfZ88;
       cfZ87: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZ88: // global
           (_cfZ83::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfZ83::I64 == 0) goto cfZ85; else goto cfZ84;
       cfZ85: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfZ84: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfZ83::I64;
           R2 = Data.Functor.Sum.$fRead1Sum8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.239161836 UTC

[section ""cstring" . Data.Functor.Sum.$fRead1Sum4_bytes" {
     Data.Functor.Sum.$fRead1Sum4_bytes:
         I8[] [73,110,82]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.23990955 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum3_closure" {
     Data.Functor.Sum.$fRead1Sum3_closure:
         const Data.Functor.Sum.$fRead1Sum3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fRead1Sum3_entry() //  [R1]
         { info_tbl: [(cfZ8f,
                       label: Data.Functor.Sum.$fRead1Sum3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ8f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZ8g; else goto cfZ8h;
       cfZ8g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZ8h: // global
           (_cfZ8c::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfZ8c::I64 == 0) goto cfZ8e; else goto cfZ8d;
       cfZ8e: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfZ8d: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfZ8c::I64;
           R2 = Data.Functor.Sum.$fRead1Sum4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.240829904 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum2_closure" {
     Data.Functor.Sum.$fRead1Sum2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Sum.$fRead1Sum3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.241438942 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum5_closure" {
     Data.Functor.Sum.$fRead1Sum5_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.241995526 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum6_closure" {
     Data.Functor.Sum.$fRead1Sum6_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.244719628 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum1_closure" {
     Data.Functor.Sum.$fRead1Sum1_closure:
         const Data.Functor.Sum.$fRead1Sum1_info;
         const 0;
 },
 ds_sfXQl_entry() //  [R1]
         { info_tbl: [(cfZ8q,
                       label: ds_sfXQl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ8q: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZ8r; else goto cfZ8s;
       cfZ8r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZ8s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds1_sfXQm_entry() //  [R1]
         { info_tbl: [(cfZ8x,
                       label: ds1_sfXQm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ8x: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZ8y; else goto cfZ8z;
       cfZ8y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZ8z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sfXQu_entry() //  [R1, R2]
         { info_tbl: [(cfZ8U,
                       label: sat_sfXQu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ8U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZ8Y; else goto cfZ8X;
       cfZ8Y: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZ8X: // global
           _sfXQp::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           R1 = _sfXQp::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQv_entry() //  [R1, R2]
         { info_tbl: [(cfZ8Z,
                       label: sat_sfXQv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ8Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZ93; else goto cfZ92;
       cfZ93: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZ92: // global
           _sfXQl::P64 = P64[R1 + 7];
           _sfXQp::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sfXQu_info;
           P64[Hp] = _sfXQp::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Sum.$fRead1Sum5_closure+1;
           R1 = _sfXQl::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQC_entry() //  [R1, R2]
         { info_tbl: [(cfZ9l,
                       label: sat_sfXQC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ9l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZ9p; else goto cfZ9o;
       cfZ9p: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZ9o: // global
           _sfXQp::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _sfXQp::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQD_entry() //  [R1, R2]
         { info_tbl: [(cfZ9q,
                       label: sat_sfXQD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ9q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZ9u; else goto cfZ9t;
       cfZ9u: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZ9t: // global
           _sfXQm::P64 = P64[R1 + 7];
           _sfXQp::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sfXQC_info;
           P64[Hp] = _sfXQp::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Sum.$fRead1Sum5_closure+1;
           R1 = _sfXQm::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQG_entry() //  [R1]
         { info_tbl: [(cfZ9y,
                       label: sat_sfXQG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ9y: // global
           _sfXQG::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cfZ9z; else goto cfZ9A;
       cfZ9A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZ9C; else goto cfZ9B;
       cfZ9C: // global
           HpAlloc = 24;
           goto cfZ9z;
       cfZ9z: // global
           R1 = _sfXQG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZ9B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXQG::P64;
           _sfXQm::P64 = P64[_sfXQG::P64 + 16];
           _sfXQp::P64 = P64[_sfXQG::P64 + 24];
           I64[Hp - 16] = sat_sfXQD_info;
           P64[Hp - 8] = _sfXQm::P64;
           P64[Hp] = _sfXQp::P64;
           I64[Sp - 24] = block_cfZ9v_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Sum.$fRead1Sum2_closure+4;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfZ9v() //  [R1]
         { info_tbl: [(cfZ9v,
                       label: block_cfZ9v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ9v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZ9F; else goto cfZ9E;
       cfZ9F: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfZ9E: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_sfXQn_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZ9J,
                       label: $wlvl_sfXQn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ9J: // global
           _sfXQp::P64 = R3;
           _sfXQo::I64 = R2;
           _sfXQn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cfZ9K; else goto cfZ9L;
       cfZ9L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZ9N; else goto cfZ9M;
       cfZ9N: // global
           HpAlloc = 24;
           goto cfZ9K;
       cfZ9K: // global
           R3 = _sfXQp::P64;
           R2 = _sfXQo::I64;
           R1 = _sfXQn::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZ9M: // global
           if (%MO_S_Gt_W64(_sfXQo::I64, 10)) goto cfZ9H; else goto cfZ9I;
       cfZ9H: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfZ9I: // global
           _sfXQl::P64 = P64[_sfXQn::P64 + 6];
           _sfXQm::P64 = P64[_sfXQn::P64 + 14];
           I64[Hp - 16] = sat_sfXQv_info;
           P64[Hp - 8] = _sfXQl::P64;
           P64[Hp] = _sfXQp::P64;
           I64[Sp - 24] = block_cfZ94_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Sum.$fRead1Sum6_closure+4;
           P64[Sp - 16] = _sfXQm::P64;
           P64[Sp - 8] = _sfXQp::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZ94() //  [R1]
         { info_tbl: [(cfZ94,
                       label: block_cfZ94_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ94: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfZ9R; else goto cfZ9Q;
       cfZ9R: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZ9Q: // global
           I64[Hp - 40] = sat_sfXQG_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R3 = Hp - 40;
           R2 = Hp - 6;
           Sp = Sp + 24;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 lvl8_sfXQH_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZa0,
                       label: lvl8_sfXQH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZa0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfZa1; else goto cfZa2;
       cfZa1: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZa2: // global
           I64[Sp - 24] = block_cfZ9X_info;
           _sfXQn::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sfXQn::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufZa6; else goto cfZ9Y;
       ufZa6: // global
           call _cfZ9X(R1) args: 0, res: 0, upd: 0;
       cfZ9Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZ9X() //  [R1]
         { info_tbl: [(cfZ9X,
                       label: block_cfZ9X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZ9X: // global
           R3 = P64[Sp + 16];
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call $wlvl_sfXQn_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQO_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZac,
                       label: sat_sfXQO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZac: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfZaf,
                       label: Data.Functor.Sum.$fRead1Sum1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZaf: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cfZaj; else goto cfZai;
       cfZaj: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZai: // global
           I64[Hp - 128] = ds_sfXQl_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R4;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = ds1_sfXQm_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = $wlvl_sfXQn_info;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 88;
           I64[Hp - 24] = lvl8_sfXQH_info;
           P64[Hp - 16] = Hp - 46;
           I64[Hp - 8] = sat_sfXQO_info;
           P64[Hp] = Hp - 22;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.250294482 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure" {
     Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure:
         const Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_info;
         const 0;
 },
 sat_sfXQZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZaA,
                       label: sat_sfXQZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZaA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZaB; else goto cfZaC;
       cfZaB: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZaC: // global
           I64[Sp - 8] = block_cfZax_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZax() //  [R1]
         { info_tbl: [(cfZax,
                       label: block_cfZax_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZax: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZaF; else goto cfZaE;
       cfZaF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZaE: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQU_entry() //  [R1, R2]
         { info_tbl: [(cfZaL,
                       label: sat_sfXQU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZaL: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sfXQT_entry() //  [R1]
         { info_tbl: [(cfZaO,
                       label: ds_sfXQT_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZaO: // global
           _sfXQT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfZaP; else goto cfZaQ;
       cfZaQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfZaS; else goto cfZaR;
       cfZaS: // global
           HpAlloc = 32;
           goto cfZaP;
       cfZaP: // global
           R1 = _sfXQT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZaR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXQT::P64;
           _sfXQP::P64 = P64[_sfXQT::P64 + 16];
           _sfXQQ::P64 = P64[_sfXQT::P64 + 24];
           _sfXQR::P64 = P64[_sfXQT::P64 + 32];
           _sfXQS::P64 = P64[_sfXQT::P64 + 40];
           I64[Hp - 24] = sat_sfXQZ_info;
           P64[Hp - 16] = _sfXQS::P64;
           I64[Hp - 8] = sat_sfXQU_info;
           P64[Hp] = _sfXQR::P64;
           R5 = Hp - 22;
           R4 = Hp - 7;
           R3 = _sfXQQ::P64;
           R2 = _sfXQP::P64;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXR1_entry() //  [R1]
         { info_tbl: [(cfZb2,
                       label: sat_sfXR1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZb2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZb3; else goto cfZb4;
       cfZb3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZb4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXR2_entry() //  [R1, R2]
         { info_tbl: [(cfZb5,
                       label: sat_sfXR2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZb5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfZb9; else goto cfZb8;
       cfZb9: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZb8: // global
           _sfXQT::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sfXR1_info;
           P64[Hp - 8] = _sfXQT::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cfZba,
                       label: Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZba: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfZbe; else goto cfZbd;
       cfZbe: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZbd: // global
           I64[Hp - 56] = ds_sfXQT_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = sat_sfXR2_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.253068923 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure" {
     Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure:
         const Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_info;
         const 0;
 },
 sat_sfXR7_entry() //  [R1]
         { info_tbl: [(cfZbn,
                       label: sat_sfXR7_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZbn: // global
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cfZbq,
                       label: Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZbq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfZbu; else goto cfZbt;
       cfZbu: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZbt: // global
           I64[Hp - 40] = sat_sfXR7_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.255375435 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum_closure" {
     Data.Functor.Sum.$fRead1Sum_closure:
         const Data.Functor.Sum.$fRead1Sum_info;
         const 0;
 },
 sat_sfXRd_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZbE,
                       label: sat_sfXRd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZbE: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXRc_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZbM,
                       label: sat_sfXRc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZbM: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXRb_entry() //  [R1]
         { info_tbl: [(cfZbT,
                       label: sat_sfXRb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZbT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZbU; else goto cfZbV;
       cfZbU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZbV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum_$cliftReadList_entry(R3,
                                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXRa_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZc1,
                       label: sat_sfXRa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZc1: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_entry(R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum_entry() //  [R2, R3]
         { info_tbl: [(cfZc5,
                       label: Data.Functor.Sum.$fRead1Sum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZc5: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cfZc9; else goto cfZc8;
       cfZc9: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZc8: // global
           I64[Hp - 136] = sat_sfXRd_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sfXRc_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sfXRb_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sfXRa_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 54;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 134;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure" {
     Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure:
         const Data.Functor.Sum.$fRead1Sum_$cliftReadList_info;
         const 0;
 },
 sat_sfXRg_entry() //  [R1]
         { info_tbl: [(cfZci,
                       label: sat_sfXRg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZci: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZcj; else goto cfZck;
       cfZcj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZck: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum_entry(R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fRead1Sum_$cliftReadList_entry() //  [R2, R3]
         { info_tbl: [(cfZcl,
                       label: Data.Functor.Sum.$fRead1Sum_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZcl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfZcp; else goto cfZco;
       cfZcp: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZco: // global
           I64[Hp - 24] = sat_sfXRg_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.258607409 UTC

[section ""data" . Data.Functor.Sum.$w$cliftShowsPrec_closure" {
     Data.Functor.Sum.$w$cliftShowsPrec_closure:
         const Data.Functor.Sum.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Sum.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZcr: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sfXRp_entry() //  [R1]
         { info_tbl: [(cfZcE,
                       label: sat_sfXRp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZcE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfZcF; else goto cfZcG;
       cfZcF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZcG: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfXRr_entry() //  [R1]
         { info_tbl: [(cfZcN,
                       label: sat_sfXRr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZcN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfZcO; else goto cfZcP;
       cfZcO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZcP: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZcU,
                       label: Data.Functor.Sum.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZcU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZcV; else goto cfZcW;
       cfZcV: // global
           R1 = Data.Functor.Sum.$w$cliftShowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cfZcW: // global
           I64[Sp - 40] = block_cfZcv_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZd3; else goto cfZcw;
       ufZd3: // global
           call _cfZcv(R1) args: 0, res: 0, upd: 0;
       cfZcw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZcv() //  [R1]
         { info_tbl: [(cfZcv,
                       label: block_cfZcv_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZcv: // global
           _sfXRj::P64 = P64[Sp + 16];
           _sfXRk::P64 = P64[Sp + 24];
           _sfXRl::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cfZcR; else goto cfZcS;
       cfZcR: // global
           Hp = Hp + 40;
           _sfXRn::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZd2; else goto cfZcY;
       cfZcY: // global
           _sfXRo::P64 = P64[_sfXRn::P64 + 7];
           I64[Hp - 32] = sat_sfXRp_info;
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = _sfXRj::P64;
           P64[Hp] = _sfXRk::P64;
           R5 = _sfXRo::P64;
           R4 = _sfXRl::I64;
           R3 = Data.Functor.Sum.$fRead1Sum7_closure;
           R2 = Hp - 32;
           Sp = Sp + 48;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cfZcS: // global
           Hp = Hp + 40;
           _sfXRn::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZd2; else goto cfZd1;
       cfZd2: // global
           HpAlloc = 40;
           R1 = _sfXRn::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZd1: // global
           _sfXRq::P64 = P64[_sfXRn::P64 + 6];
           I64[Hp - 32] = sat_sfXRr_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sfXRj::P64;
           P64[Hp] = _sfXRk::P64;
           R5 = _sfXRq::P64;
           R4 = _sfXRl::I64;
           R3 = Data.Functor.Sum.$fRead1Sum3_closure;
           R2 = Hp - 32;
           Sp = Sp + 48;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.26113321 UTC

[section ""data" . Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure" {
     Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure:
         const Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cfZdb,
                       label: Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZdb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZdc; else goto cfZdd;
       cfZdc: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfZdd: // global
           I64[Sp - 40] = block_cfZd8_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZdh; else goto cfZd9;
       ufZdh: // global
           call _cfZd8(R1) args: 0, res: 0, upd: 0;
       cfZd9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZd8() //  [R1]
         { info_tbl: [(cfZd8,
                       label: block_cfZd8_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZd8: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.262384141 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum6_closure" {
     Data.Functor.Sum.$fFoldableSum6_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.266396012 UTC

[section ""data" . Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure" {
     Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure:
         const Data.Functor.Sum.$fShow1Sum_$cliftShowList_info;
         const 0;
 },
 sat_sfXRH_entry() //  [R1, R2]
         { info_tbl: [(cfZdr,
                       label: sat_sfXRH_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZdr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZds; else goto cfZdt;
       cfZds: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZdt: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sfXRG::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sfXRG::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShow1Sum_$cliftShowList_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cfZdu,
                       label: Data.Functor.Sum.$fShow1Sum_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZdu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfZdy; else goto cfZdx;
       cfZdy: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfZdx: // global
           I64[Hp - 32] = sat_sfXRH_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 31;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.268153782 UTC

[section ""data" . Data.Functor.Sum.$fShow1Sum_closure" {
     Data.Functor.Sum.$fShow1Sum_closure:
         const Data.Functor.Sum.$fShow1Sum_info;
         const 0;
 },
 sat_sfXRL_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfZdI,
                       label: sat_sfXRL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZdI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZdJ; else goto cfZdK;
       cfZdJ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZdK: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$fShow1Sum_$cliftShowList_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_sfXRK_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfZdQ,
                       label: sat_sfXRK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZdQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZdR; else goto cfZdS;
       cfZdR: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZdS: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShow1Sum_entry() //  [R2, R3]
         { info_tbl: [(cfZdU,
                       label: Data.Functor.Sum.$fShow1Sum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZdU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfZdY; else goto cfZdX;
       cfZdY: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShow1Sum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZdX: // global
           I64[Hp - 64] = sat_sfXRL_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sfXRK_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 36;
           P64[Hp] = Hp - 60;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.270057295 UTC

[section ""data" . Data.Functor.Sum.$fEqSum_$c==_closure" {
     Data.Functor.Sum.$fEqSum_$c==_closure:
         const Data.Functor.Sum.$fEqSum_$c==_info;
 },
 sat_sfXRR_entry() //  [R1]
         { info_tbl: [(cfZe7,
                       label: sat_sfXRR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZe7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZe8; else goto cfZe9;
       cfZe8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZe9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fEqSum_$c==_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZea,
                       label: Data.Functor.Sum.$fEqSum_$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZea: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZee; else goto cfZed;
       cfZee: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEqSum_$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZed: // global
           I64[Hp - 16] = sat_sfXRR_info;
           P64[Hp] = R4;
           R6 = R6;
           R5 = R5;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fEq1Sum_$cliftEq_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.272435661 UTC

[section ""data" . Data.Functor.Sum.$fEqSum_$c/=_closure" {
     Data.Functor.Sum.$fEqSum_$c/=_closure:
         const Data.Functor.Sum.$fEqSum_$c/=_info;
 },
 sat_sfXS1_entry() //  [R1]
         { info_tbl: [(cfZex,
                       label: sat_sfXS1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZex: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZey; else goto cfZez;
       cfZey: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZez: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXS8_entry() //  [R1]
         { info_tbl: [(cfZeM,
                       label: sat_sfXS8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZeM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZeN; else goto cfZeO;
       cfZeN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZeO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fEqSum_$c/=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZeT,
                       label: Data.Functor.Sum.$fEqSum_$c/=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZeT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZeU; else goto cfZeV;
       cfZeU: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEqSum_$c/=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZeV: // global
           I64[Sp - 40] = block_cfZej_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZfP; else goto cfZek;
       ufZfP: // global
           call _cfZej(R1) args: 0, res: 0, upd: 0;
       cfZek: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZej() //  [R1]
         { info_tbl: [(cfZej,
                       label: block_cfZej_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZej: // global
           _sfXRW::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZeQ; else goto cfZeR;
       cfZeQ: // global
           I64[Sp] = block_cfZeo_info;
           _sfXRY::P64 = P64[R1 + 7];
           R1 = _sfXRW::P64;
           P64[Sp + 32] = _sfXRY::P64;
           if (R1 & 7 != 0) goto ufZfL; else goto cfZep;
       ufZfL: // global
           call _cfZeo(R1) args: 0, res: 0, upd: 0;
       cfZep: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfZeR: // global
           I64[Sp + 8] = block_cfZeC_info;
           _sfXS4::P64 = P64[R1 + 6];
           R1 = _sfXRW::P64;
           P64[Sp + 32] = _sfXS4::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufZfM; else goto cfZeD;
       ufZfM: // global
           call _cfZeC(R1) args: 0, res: 0, upd: 0;
       cfZeD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZeo() //  [R1]
         { info_tbl: [(cfZeo,
                       label: block_cfZeo_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZeo: // global
           if (R1 & 7 == 1) goto cfZeZ; else goto ufZfI;
       cfZeZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZf2; else goto cfZf1;
       cfZf2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZf1: // global
           _sfXS0::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXS1_info;
           P64[Hp] = P64[Sp + 24];
           _sfXRY::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cfZeX_info;
           R4 = _sfXS0::P64;
           R3 = _sfXRY::P64;
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ufZfI: // global
           Sp = Sp + 40;
           call _cfZfw() args: 0, res: 0, upd: 0;
     }
 },
 _cfZeX() //  [R1]
         { info_tbl: [(cfZeX,
                       label: block_cfZeX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZeX: // global
           if (R1 & 7 == 1) goto ufZfJ; else goto ufZfK;
       ufZfJ: // global
           Sp = Sp + 8;
           call _cfZfw() args: 0, res: 0, upd: 0;
       ufZfK: // global
           Sp = Sp + 8;
           call _cfZfA() args: 0, res: 0, upd: 0;
     }
 },
 _cfZeC() //  [R1]
         { info_tbl: [(cfZeC,
                       label: block_cfZeC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZeC: // global
           if (R1 & 7 == 1) goto ufZfF; else goto cfZfn;
       ufZfF: // global
           Sp = Sp + 32;
           call _cfZfw() args: 0, res: 0, upd: 0;
       cfZfn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZfq; else goto cfZfp;
       cfZfq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZfp: // global
           _sfXS7::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXS8_info;
           P64[Hp] = P64[Sp + 16];
           _sfXS4::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cfZfm_info;
           R4 = _sfXS7::P64;
           R3 = _sfXS4::P64;
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZfm() //  [R1]
         { info_tbl: [(cfZfm,
                       label: block_cfZfm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZfm: // global
           if (R1 & 7 == 1) goto ufZfG; else goto ufZfH;
       ufZfG: // global
           Sp = Sp + 8;
           call _cfZfw() args: 0, res: 0, upd: 0;
       ufZfH: // global
           Sp = Sp + 8;
           call _cfZfA() args: 0, res: 0, upd: 0;
     }
 },
 _cfZfw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZfw: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZfA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZfA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.275919462 UTC

[section ""data" . Data.Functor.Sum.$fEqSum_closure" {
     Data.Functor.Sum.$fEqSum_closure:
         const Data.Functor.Sum.$fEqSum_info;
 },
 sat_sfXSe_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZg3,
                       label: sat_sfXSe_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZg3: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fEqSum_$c/=_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXSd_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZgb,
                       label: sat_sfXSd_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZgb: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fEqSum_$c==_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fEqSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZgf,
                       label: Data.Functor.Sum.$fEqSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZgf: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfZgj; else goto cfZgi;
       cfZgj: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEqSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZgi: // global
           I64[Hp - 80] = sat_sfXSe_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sfXSd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 78;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.277603276 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$ccompare_closure" {
     Data.Functor.Sum.$fOrdSum_$ccompare_closure:
         const Data.Functor.Sum.$fOrdSum_$ccompare_info;
 },
 sat_sfXSk_entry() //  [R1]
         { info_tbl: [(cfZgs,
                       label: sat_sfXSk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZgs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZgt; else goto cfZgu;
       cfZgt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZgu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$ccompare_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cfZgv,
                       label: Data.Functor.Sum.$fOrdSum_$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZgv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZgz; else goto cfZgy;
       cfZgz: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZgy: // global
           I64[Hp - 16] = sat_sfXSk_info;
           P64[Hp] = R4;
           R6 = R6;
           R5 = R5;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fOrd1Sum_$cliftCompare_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.279269589 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$cp1Ord_closure" {
     Data.Functor.Sum.$fOrdSum_$cp1Ord_closure:
         const Data.Functor.Sum.$fOrdSum_$cp1Ord_info;
 },
 sat_sfXSq_entry() //  [R1]
         { info_tbl: [(cfZgI,
                       label: sat_sfXSq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZgI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZgJ; else goto cfZgK;
       cfZgJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZgK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXSp_entry() //  [R1]
         { info_tbl: [(cfZgP,
                       label: sat_sfXSp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZgP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZgQ; else goto cfZgR;
       cfZgQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZgR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXSo_entry() //  [R1]
         { info_tbl: [(cfZgW,
                       label: sat_sfXSo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZgW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZgX; else goto cfZgY;
       cfZgX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZgY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$cp1Ord_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZgZ,
                       label: Data.Functor.Sum.$fOrdSum_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZgZ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfZh3; else goto cfZh2;
       cfZh3: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$cp1Ord_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZh2: // global
           I64[Hp - 64] = sat_sfXSq_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sfXSp_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sfXSo_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Sum.$fEqSum_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.28218354 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c<_closure" {
     Data.Functor.Sum.$fOrdSum_$c<_closure:
         const Data.Functor.Sum.$fOrdSum_$c<_info;
 },
 sat_sfXSA_entry() //  [R1]
         { info_tbl: [(cfZhm,
                       label: sat_sfXSA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZhm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZhn; else goto cfZho;
       cfZhn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZho: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXSH_entry() //  [R1]
         { info_tbl: [(cfZhB,
                       label: sat_sfXSH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZhB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZhC; else goto cfZhD;
       cfZhC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZhD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZhI,
                       label: Data.Functor.Sum.$fOrdSum_$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZhI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZhJ; else goto cfZhK;
       cfZhJ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZhK: // global
           I64[Sp - 40] = block_cfZh8_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZiE; else goto cfZh9;
       ufZiE: // global
           call _cfZh8(R1) args: 0, res: 0, upd: 0;
       cfZh9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZh8() //  [R1]
         { info_tbl: [(cfZh8,
                       label: block_cfZh8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZh8: // global
           _sfXSv::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZhF; else goto cfZhG;
       cfZhF: // global
           I64[Sp] = block_cfZhd_info;
           _sfXSx::P64 = P64[R1 + 7];
           R1 = _sfXSv::P64;
           P64[Sp + 32] = _sfXSx::P64;
           if (R1 & 7 != 0) goto ufZiA; else goto cfZhe;
       ufZiA: // global
           call _cfZhd(R1) args: 0, res: 0, upd: 0;
       cfZhe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfZhG: // global
           I64[Sp + 8] = block_cfZhr_info;
           _sfXSD::P64 = P64[R1 + 6];
           R1 = _sfXSv::P64;
           P64[Sp + 32] = _sfXSD::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufZiB; else goto cfZhs;
       ufZiB: // global
           call _cfZhr(R1) args: 0, res: 0, upd: 0;
       cfZhs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZhd() //  [R1]
         { info_tbl: [(cfZhd,
                       label: block_cfZhd_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZhd: // global
           if (R1 & 7 == 1) goto cfZhO; else goto ufZix;
       cfZhO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZhR; else goto cfZhQ;
       cfZhR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZhQ: // global
           _sfXSz::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXSA_info;
           P64[Hp] = P64[Sp + 24];
           _sfXSx::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cfZhM_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sfXSx::P64;
           P64[Sp + 24] = _sfXSz::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ufZix: // global
           Sp = Sp + 40;
           call _cfZip() args: 0, res: 0, upd: 0;
     }
 },
 _cfZhM() //  [R1]
         { info_tbl: [(cfZhM,
                       label: block_cfZhM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZhM: // global
           if (R1 & 7 == 1) goto ufZiy; else goto ufZiz;
       ufZiy: // global
           Sp = Sp + 8;
           call _cfZip() args: 0, res: 0, upd: 0;
       ufZiz: // global
           Sp = Sp + 8;
           call _cfZil() args: 0, res: 0, upd: 0;
     }
 },
 _cfZhr() //  [R1]
         { info_tbl: [(cfZhr,
                       label: block_cfZhr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZhr: // global
           if (R1 & 7 == 1) goto ufZiu; else goto cfZic;
       ufZiu: // global
           Sp = Sp + 32;
           call _cfZil() args: 0, res: 0, upd: 0;
       cfZic: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZif; else goto cfZie;
       cfZif: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZie: // global
           _sfXSG::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXSH_info;
           P64[Hp] = P64[Sp + 16];
           _sfXSD::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cfZib_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sfXSD::P64;
           P64[Sp + 16] = _sfXSG::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfZib() //  [R1]
         { info_tbl: [(cfZib,
                       label: block_cfZib_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZib: // global
           if (R1 & 7 == 1) goto ufZiv; else goto ufZiw;
       ufZiv: // global
           Sp = Sp + 8;
           call _cfZip() args: 0, res: 0, upd: 0;
       ufZiw: // global
           Sp = Sp + 8;
           call _cfZil() args: 0, res: 0, upd: 0;
     }
 },
 _cfZip() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZip: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZil() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZil: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.286204656 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c>=_closure" {
     Data.Functor.Sum.$fOrdSum_$c>=_closure:
         const Data.Functor.Sum.$fOrdSum_$c>=_info;
 },
 sat_sfXSS_entry() //  [R1]
         { info_tbl: [(cfZj1,
                       label: sat_sfXSS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZj1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZj2; else goto cfZj3;
       cfZj2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZj3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXSZ_entry() //  [R1]
         { info_tbl: [(cfZjg,
                       label: sat_sfXSZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZjg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZjh; else goto cfZji;
       cfZjh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZji: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c>=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZjn,
                       label: Data.Functor.Sum.$fOrdSum_$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZjn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZjo; else goto cfZjp;
       cfZjo: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZjp: // global
           I64[Sp - 40] = block_cfZiN_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZkj; else goto cfZiO;
       ufZkj: // global
           call _cfZiN(R1) args: 0, res: 0, upd: 0;
       cfZiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZiN() //  [R1]
         { info_tbl: [(cfZiN,
                       label: block_cfZiN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZiN: // global
           _sfXSN::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZjk; else goto cfZjl;
       cfZjk: // global
           I64[Sp] = block_cfZiS_info;
           _sfXSP::P64 = P64[R1 + 7];
           R1 = _sfXSN::P64;
           P64[Sp + 32] = _sfXSP::P64;
           if (R1 & 7 != 0) goto ufZkf; else goto cfZiT;
       ufZkf: // global
           call _cfZiS(R1) args: 0, res: 0, upd: 0;
       cfZiT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfZjl: // global
           I64[Sp + 8] = block_cfZj6_info;
           _sfXSV::P64 = P64[R1 + 6];
           R1 = _sfXSN::P64;
           P64[Sp + 32] = _sfXSV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufZkg; else goto cfZj7;
       ufZkg: // global
           call _cfZj6(R1) args: 0, res: 0, upd: 0;
       cfZj7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZiS() //  [R1]
         { info_tbl: [(cfZiS,
                       label: block_cfZiS_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZiS: // global
           if (R1 & 7 == 1) goto cfZjt; else goto ufZkc;
       cfZjt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZjw; else goto cfZjv;
       cfZjw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZjv: // global
           _sfXSR::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXSS_info;
           P64[Hp] = P64[Sp + 24];
           _sfXSP::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cfZjr_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sfXSP::P64;
           P64[Sp + 24] = _sfXSR::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ufZkc: // global
           Sp = Sp + 40;
           call _cfZk4() args: 0, res: 0, upd: 0;
     }
 },
 _cfZjr() //  [R1]
         { info_tbl: [(cfZjr,
                       label: block_cfZjr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZjr: // global
           if (R1 & 7 == 1) goto ufZkd; else goto ufZke;
       ufZkd: // global
           Sp = Sp + 8;
           call _cfZk4() args: 0, res: 0, upd: 0;
       ufZke: // global
           Sp = Sp + 8;
           call _cfZk0() args: 0, res: 0, upd: 0;
     }
 },
 _cfZj6() //  [R1]
         { info_tbl: [(cfZj6,
                       label: block_cfZj6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZj6: // global
           if (R1 & 7 == 1) goto ufZk9; else goto cfZjR;
       ufZk9: // global
           Sp = Sp + 32;
           call _cfZk0() args: 0, res: 0, upd: 0;
       cfZjR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZjU; else goto cfZjT;
       cfZjU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZjT: // global
           _sfXSY::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXSZ_info;
           P64[Hp] = P64[Sp + 16];
           _sfXSV::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cfZjQ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sfXSV::P64;
           P64[Sp + 16] = _sfXSY::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfZjQ() //  [R1]
         { info_tbl: [(cfZjQ,
                       label: block_cfZjQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZjQ: // global
           if (R1 & 7 == 1) goto ufZka; else goto ufZkb;
       ufZka: // global
           Sp = Sp + 8;
           call _cfZk4() args: 0, res: 0, upd: 0;
       ufZkb: // global
           Sp = Sp + 8;
           call _cfZk0() args: 0, res: 0, upd: 0;
     }
 },
 _cfZk4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZk4: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZk0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZk0: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.290257864 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c>_closure" {
     Data.Functor.Sum.$fOrdSum_$c>_closure:
         const Data.Functor.Sum.$fOrdSum_$c>_info;
 },
 sat_sfXTa_entry() //  [R1]
         { info_tbl: [(cfZkG,
                       label: sat_sfXTa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZkG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZkH; else goto cfZkI;
       cfZkH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZkI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXTh_entry() //  [R1]
         { info_tbl: [(cfZkV,
                       label: sat_sfXTh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZkV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZkW; else goto cfZkX;
       cfZkW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZkX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZl2,
                       label: Data.Functor.Sum.$fOrdSum_$c>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZl2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZl3; else goto cfZl4;
       cfZl3: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZl4: // global
           I64[Sp - 40] = block_cfZks_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZlY; else goto cfZkt;
       ufZlY: // global
           call _cfZks(R1) args: 0, res: 0, upd: 0;
       cfZkt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZks() //  [R1]
         { info_tbl: [(cfZks,
                       label: block_cfZks_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZks: // global
           _sfXT5::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZkZ; else goto cfZl0;
       cfZkZ: // global
           I64[Sp] = block_cfZkx_info;
           _sfXT7::P64 = P64[R1 + 7];
           R1 = _sfXT5::P64;
           P64[Sp + 32] = _sfXT7::P64;
           if (R1 & 7 != 0) goto ufZlU; else goto cfZky;
       ufZlU: // global
           call _cfZkx(R1) args: 0, res: 0, upd: 0;
       cfZky: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfZl0: // global
           I64[Sp + 8] = block_cfZkL_info;
           _sfXTd::P64 = P64[R1 + 6];
           R1 = _sfXT5::P64;
           P64[Sp + 32] = _sfXTd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufZlV; else goto cfZkM;
       ufZlV: // global
           call _cfZkL(R1) args: 0, res: 0, upd: 0;
       cfZkM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZkx() //  [R1]
         { info_tbl: [(cfZkx,
                       label: block_cfZkx_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZkx: // global
           if (R1 & 7 == 1) goto cfZl8; else goto ufZlR;
       cfZl8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZlb; else goto cfZla;
       cfZlb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZla: // global
           _sfXT9::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXTa_info;
           P64[Hp] = P64[Sp + 24];
           _sfXT7::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cfZl6_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sfXT7::P64;
           P64[Sp + 24] = _sfXT9::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ufZlR: // global
           Sp = Sp + 40;
           call _cfZlF() args: 0, res: 0, upd: 0;
     }
 },
 _cfZl6() //  [R1]
         { info_tbl: [(cfZl6,
                       label: block_cfZl6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZl6: // global
           if (R1 & 7 == 3) goto ufZlS; else goto ufZlT;
       ufZlS: // global
           Sp = Sp + 8;
           call _cfZlJ() args: 0, res: 0, upd: 0;
       ufZlT: // global
           Sp = Sp + 8;
           call _cfZlF() args: 0, res: 0, upd: 0;
     }
 },
 _cfZkL() //  [R1]
         { info_tbl: [(cfZkL,
                       label: block_cfZkL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZkL: // global
           if (R1 & 7 == 1) goto ufZlO; else goto cfZlw;
       ufZlO: // global
           Sp = Sp + 32;
           call _cfZlJ() args: 0, res: 0, upd: 0;
       cfZlw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZlz; else goto cfZly;
       cfZlz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZly: // global
           _sfXTg::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXTh_info;
           P64[Hp] = P64[Sp + 16];
           _sfXTd::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cfZlv_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sfXTd::P64;
           P64[Sp + 16] = _sfXTg::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfZlv() //  [R1]
         { info_tbl: [(cfZlv,
                       label: block_cfZlv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZlv: // global
           if (R1 & 7 == 3) goto ufZlP; else goto ufZlQ;
       ufZlP: // global
           Sp = Sp + 8;
           call _cfZlJ() args: 0, res: 0, upd: 0;
       ufZlQ: // global
           Sp = Sp + 8;
           call _cfZlF() args: 0, res: 0, upd: 0;
     }
 },
 _cfZlJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZlJ: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZlF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZlF: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.294430474 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c<=_closure" {
     Data.Functor.Sum.$fOrdSum_$c<=_closure:
         const Data.Functor.Sum.$fOrdSum_$c<=_info;
 },
 sat_sfXTs_entry() //  [R1]
         { info_tbl: [(cfZml,
                       label: sat_sfXTs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZml: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZmm; else goto cfZmn;
       cfZmm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZmn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXTz_entry() //  [R1]
         { info_tbl: [(cfZmA,
                       label: sat_sfXTz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZmA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZmB; else goto cfZmC;
       cfZmB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZmC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZmH,
                       label: Data.Functor.Sum.$fOrdSum_$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZmH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZmI; else goto cfZmJ;
       cfZmI: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZmJ: // global
           I64[Sp - 40] = block_cfZm7_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZnD; else goto cfZm8;
       ufZnD: // global
           call _cfZm7(R1) args: 0, res: 0, upd: 0;
       cfZm8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZm7() //  [R1]
         { info_tbl: [(cfZm7,
                       label: block_cfZm7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZm7: // global
           _sfXTn::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZmE; else goto cfZmF;
       cfZmE: // global
           I64[Sp] = block_cfZmc_info;
           _sfXTp::P64 = P64[R1 + 7];
           R1 = _sfXTn::P64;
           P64[Sp + 32] = _sfXTp::P64;
           if (R1 & 7 != 0) goto ufZnz; else goto cfZmd;
       ufZnz: // global
           call _cfZmc(R1) args: 0, res: 0, upd: 0;
       cfZmd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfZmF: // global
           I64[Sp + 8] = block_cfZmq_info;
           _sfXTv::P64 = P64[R1 + 6];
           R1 = _sfXTn::P64;
           P64[Sp + 32] = _sfXTv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufZnA; else goto cfZmr;
       ufZnA: // global
           call _cfZmq(R1) args: 0, res: 0, upd: 0;
       cfZmr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZmc() //  [R1]
         { info_tbl: [(cfZmc,
                       label: block_cfZmc_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZmc: // global
           if (R1 & 7 == 1) goto cfZmN; else goto ufZnw;
       cfZmN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZmQ; else goto cfZmP;
       cfZmQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZmP: // global
           _sfXTr::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXTs_info;
           P64[Hp] = P64[Sp + 24];
           _sfXTp::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cfZmL_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sfXTp::P64;
           P64[Sp + 24] = _sfXTr::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ufZnw: // global
           Sp = Sp + 40;
           call _cfZnk() args: 0, res: 0, upd: 0;
     }
 },
 _cfZmL() //  [R1]
         { info_tbl: [(cfZmL,
                       label: block_cfZmL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZmL: // global
           if (R1 & 7 == 3) goto ufZnx; else goto ufZny;
       ufZnx: // global
           Sp = Sp + 8;
           call _cfZno() args: 0, res: 0, upd: 0;
       ufZny: // global
           Sp = Sp + 8;
           call _cfZnk() args: 0, res: 0, upd: 0;
     }
 },
 _cfZmq() //  [R1]
         { info_tbl: [(cfZmq,
                       label: block_cfZmq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZmq: // global
           if (R1 & 7 == 1) goto ufZnt; else goto cfZnb;
       ufZnt: // global
           Sp = Sp + 32;
           call _cfZno() args: 0, res: 0, upd: 0;
       cfZnb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZne; else goto cfZnd;
       cfZne: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZnd: // global
           _sfXTy::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXTz_info;
           P64[Hp] = P64[Sp + 16];
           _sfXTv::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cfZna_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sfXTv::P64;
           P64[Sp + 16] = _sfXTy::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfZna() //  [R1]
         { info_tbl: [(cfZna,
                       label: block_cfZna_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZna: // global
           if (R1 & 7 == 3) goto ufZnu; else goto ufZnv;
       ufZnu: // global
           Sp = Sp + 8;
           call _cfZno() args: 0, res: 0, upd: 0;
       ufZnv: // global
           Sp = Sp + 8;
           call _cfZnk() args: 0, res: 0, upd: 0;
     }
 },
 _cfZno() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZno: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZnk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZnk: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.297659158 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$cmax_closure" {
     Data.Functor.Sum.$fOrdSum_$cmax_closure:
         const Data.Functor.Sum.$fOrdSum_$cmax_info;
 },
 Data.Functor.Sum.$fOrdSum_$cmax_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZnS,
                       label: Data.Functor.Sum.$fOrdSum_$cmax_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZnS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfZnT; else goto cfZnU;
       cfZnT: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$cmax_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZnU: // global
           I64[Sp - 24] = block_cfZnM_info;
           _sfXTF::P64 = R6;
           R6 = R6;
           _sfXTE::P64 = R5;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           P64[Sp - 16] = _sfXTE::P64;
           P64[Sp - 8] = _sfXTF::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fOrdSum_$c<=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZnM() //  [R1]
         { info_tbl: [(cfZnM,
                       label: block_cfZnM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZnM: // global
           if (R1 & 7 == 1) goto cfZnP; else goto cfZnQ;
       cfZnP: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfZnQ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.299068898 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$cmin_closure" {
     Data.Functor.Sum.$fOrdSum_$cmin_closure:
         const Data.Functor.Sum.$fOrdSum_$cmin_info;
 },
 Data.Functor.Sum.$fOrdSum_$cmin_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZob,
                       label: Data.Functor.Sum.$fOrdSum_$cmin_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZob: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfZoc; else goto cfZod;
       cfZoc: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$cmin_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZod: // global
           I64[Sp - 24] = block_cfZo5_info;
           _sfXTL::P64 = R6;
           R6 = R6;
           _sfXTK::P64 = R5;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           P64[Sp - 16] = _sfXTK::P64;
           P64[Sp - 8] = _sfXTL::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fOrdSum_$c<=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZo5() //  [R1]
         { info_tbl: [(cfZo5,
                       label: block_cfZo5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZo5: // global
           if (R1 & 7 == 1) goto cfZo8; else goto cfZo9;
       cfZo8: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfZo9: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.301608215 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_closure" {
     Data.Functor.Sum.$fOrdSum_closure:
         const Data.Functor.Sum.$fOrdSum_info;
 },
 sat_sfXTX_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZot,
                       label: sat_sfXTX_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZot: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$cmin_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTW_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZoB,
                       label: sat_sfXTW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZoB: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$cmax_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTV_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZoJ,
                       label: sat_sfXTV_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZoJ: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c>=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTU_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZoR,
                       label: sat_sfXTU_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZoR: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c>_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTT_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZoZ,
                       label: sat_sfXTT_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZoZ: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c<=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTS_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZp7,
                       label: sat_sfXTS_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZp7: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c<_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTR_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZpf,
                       label: sat_sfXTR_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZpf: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$ccompare_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTQ_entry() //  [R1]
         { info_tbl: [(cfZpm,
                       label: sat_sfXTQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZpm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZpn; else goto cfZpo;
       cfZpn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZpo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fOrdSum_$cp1Ord_entry(R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZpq,
                       label: Data.Functor.Sum.$fOrdSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZpq: // global
           Hp = Hp + 336;
           if (Hp > HpLim) (likely: False) goto cfZpu; else goto cfZpt;
       cfZpu: // global
           HpAlloc = 336;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZpt: // global
           I64[Hp - 328] = sat_sfXTX_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           I64[Hp - 296] = sat_sfXTW_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           P64[Hp - 272] = R4;
           I64[Hp - 264] = sat_sfXTV_info;
           P64[Hp - 256] = R2;
           P64[Hp - 248] = R3;
           P64[Hp - 240] = R4;
           I64[Hp - 232] = sat_sfXTU_info;
           P64[Hp - 224] = R2;
           P64[Hp - 216] = R3;
           P64[Hp - 208] = R4;
           I64[Hp - 200] = sat_sfXTT_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           P64[Hp - 176] = R4;
           I64[Hp - 168] = sat_sfXTS_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = sat_sfXTR_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sat_sfXTQ_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 104;
           P64[Hp - 48] = Hp - 134;
           P64[Hp - 40] = Hp - 166;
           P64[Hp - 32] = Hp - 198;
           P64[Hp - 24] = Hp - 230;
           P64[Hp - 16] = Hp - 262;
           P64[Hp - 8] = Hp - 294;
           P64[Hp] = Hp - 326;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.304806014 UTC

[section ""data" . Data.Functor.Sum.$fReadSum1_closure" {
     Data.Functor.Sum.$fReadSum1_closure:
         const Data.Functor.Sum.$fReadSum1_info;
         const 0;
 },
 sat_sfXU2_entry() //  [R1]
         { info_tbl: [(cfZpD,
                       label: sat_sfXU2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZpD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZpE; else goto cfZpF;
       cfZpE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZpF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXU1_entry() //  [R1]
         { info_tbl: [(cfZpK,
                       label: sat_sfXU1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZpK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZpL; else goto cfZpM;
       cfZpL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZpM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fReadSum1_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZpN,
                       label: Data.Functor.Sum.$fReadSum1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZpN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfZpR; else goto cfZpQ;
       cfZpR: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZpQ: // global
           I64[Hp - 40] = sat_sfXU2_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sfXU1_info;
           P64[Hp] = R4;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.307085872 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_$creadsPrec_closure" {
     Data.Functor.Sum.$fReadSum_$creadsPrec_closure:
         const Data.Functor.Sum.$fReadSum_$creadsPrec_info;
         const 0;
 },
 sat_sfXU8_entry() //  [R1]
         { info_tbl: [(cfZq4,
                       label: sat_sfXU8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZq4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZq5; else goto cfZq6;
       cfZq5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZq6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXU7_entry() //  [R1]
         { info_tbl: [(cfZqb,
                       label: sat_sfXU7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZqb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZqc; else goto cfZqd;
       cfZqc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZqd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sfXU6_entry() //  [R1]
         { info_tbl: [(cfZqe,
                       label: ds_sfXU6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZqe: // global
           _sfXU6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfZqf; else goto cfZqg;
       cfZqg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfZqi; else goto cfZqh;
       cfZqi: // global
           HpAlloc = 48;
           goto cfZqf;
       cfZqf: // global
           R1 = _sfXU6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZqh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXU6::P64;
           _sfXU3::P64 = P64[_sfXU6::P64 + 16];
           _sfXU4::P64 = P64[_sfXU6::P64 + 24];
           _sfXU5::P64 = P64[_sfXU6::P64 + 32];
           I64[Hp - 40] = sat_sfXU8_info;
           P64[Hp - 24] = _sfXU5::P64;
           I64[Hp - 16] = sat_sfXU7_info;
           P64[Hp] = _sfXU5::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sfXU4::P64;
           R2 = _sfXU3::P64;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUa_entry() //  [R1]
         { info_tbl: [(cfZqs,
                       label: sat_sfXUa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZqs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZqt; else goto cfZqu;
       cfZqt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZqu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUb_entry() //  [R1, R2]
         { info_tbl: [(cfZqv,
                       label: sat_sfXUb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZqv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfZqz; else goto cfZqy;
       cfZqz: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZqy: // global
           _sfXU6::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sfXUa_info;
           P64[Hp - 8] = _sfXU6::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fReadSum_$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZqA,
                       label: Data.Functor.Sum.$fReadSum_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZqA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZqE; else goto cfZqD;
       cfZqE: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZqD: // global
           I64[Hp - 48] = ds_sfXU6_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sfXUb_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.309868247 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_$creadListPrec_closure" {
     Data.Functor.Sum.$fReadSum_$creadListPrec_closure:
         const Data.Functor.Sum.$fReadSum_$creadListPrec_info;
         const 0;
 },
 sat_sfXUg_entry() //  [R1]
         { info_tbl: [(cfZqR,
                       label: sat_sfXUg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZqR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZqS; else goto cfZqT;
       cfZqS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZqT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUf_entry() //  [R1]
         { info_tbl: [(cfZqY,
                       label: sat_sfXUf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZqY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZqZ; else goto cfZr0;
       cfZqZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZr0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUh_entry() //  [R1]
         { info_tbl: [(cfZr1,
                       label: sat_sfXUh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZr1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfZr5; else goto cfZr4;
       cfZr5: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZr4: // global
           _sfXUc::P64 = P64[R1 + 16];
           _sfXUd::P64 = P64[R1 + 24];
           _sfXUe::P64 = P64[R1 + 32];
           I64[Hp - 40] = sat_sfXUg_info;
           P64[Hp - 24] = _sfXUe::P64;
           I64[Hp - 16] = sat_sfXUf_info;
           P64[Hp] = _sfXUe::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sfXUd::P64;
           R2 = _sfXUc::P64;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fReadSum_$creadListPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZr6,
                       label: Data.Functor.Sum.$fReadSum_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZr6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfZra; else goto cfZr9;
       cfZra: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_$creadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZr9: // global
           I64[Hp - 32] = sat_sfXUh_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.311842978 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_$creadList_closure" {
     Data.Functor.Sum.$fReadSum_$creadList_closure:
         const Data.Functor.Sum.$fReadSum_$creadList_info;
         const 0;
 },
 sat_sfXUl_entry() //  [R1]
         { info_tbl: [(cfZrj,
                       label: sat_sfXUl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZrj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZrk; else goto cfZrl;
       cfZrk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZrl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call Data.Functor.Sum.$fReadSum_$creadListPrec_entry(R4,
                                                                R3,
                                                                R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fReadSum_$creadList_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZrm,
                       label: Data.Functor.Sum.$fReadSum_$creadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZrm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfZrq; else goto cfZrp;
       cfZrq: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_$creadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZrp: // global
           I64[Hp - 32] = sat_sfXUl_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.313806708 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_closure" {
     Data.Functor.Sum.$fReadSum_closure:
         const Data.Functor.Sum.$fReadSum_info;
         const 0;
 },
 sat_sfXUs_entry() //  [R1]
         { info_tbl: [(cfZrz,
                       label: sat_sfXUs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZrz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZrA; else goto cfZrB;
       cfZrA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZrB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum_$creadListPrec_entry(R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUr_entry() //  [R1]
         { info_tbl: [(cfZrG,
                       label: sat_sfXUr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZrG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZrH; else goto cfZrI;
       cfZrH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZrI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum1_entry(R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUq_entry() //  [R1]
         { info_tbl: [(cfZrN,
                       label: sat_sfXUq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZrN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZrO; else goto cfZrP;
       cfZrO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZrP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum_$creadList_entry(R4,
                                                            R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUp_entry() //  [R1]
         { info_tbl: [(cfZrU,
                       label: sat_sfXUp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZrU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZrV; else goto cfZrW;
       cfZrV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZrW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum_$creadsPrec_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fReadSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZrY,
                       label: Data.Functor.Sum.$fReadSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZrY: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cfZs2; else goto cfZs1;
       cfZs2: // global
           HpAlloc = 200;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZs1: // global
           I64[Hp - 192] = sat_sfXUs_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           I64[Hp - 152] = sat_sfXUr_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_sfXUq_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sfXUp_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.316420041 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_$cshowsPrec_closure" {
     Data.Functor.Sum.$fShowSum_$cshowsPrec_closure:
         const Data.Functor.Sum.$fShowSum_$cshowsPrec_info;
         const 0;
 },
 sat_sfXUB_entry() //  [R1]
         { info_tbl: [(cfZsg,
                       label: sat_sfXUB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZsg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZsh; else goto cfZsi;
       cfZsh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZsi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUA_entry() //  [R1]
         { info_tbl: [(cfZsn,
                       label: sat_sfXUA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZsn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZso; else goto cfZsp;
       cfZso: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZsp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fShowSum_$cshowsPrec_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cfZsq,
                       label: Data.Functor.Sum.$fShowSum_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZsq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZsr; else goto cfZss;
       cfZsr: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_$cshowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZss: // global
           I64[Sp - 40] = block_cfZs7_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZsw; else goto cfZs8;
       ufZsw: // global
           call _cfZs7(R1) args: 0, res: 0, upd: 0;
       cfZs8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZs7() //  [R1]
         { info_tbl: [(cfZs7,
                       label: block_cfZs7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZs7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfZsv; else goto cfZsu;
       cfZsv: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZsu: // global
           _sfXUz::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sfXUB_info;
           _sfXUv::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sfXUv::P64;
           I64[Hp - 16] = sat_sfXUA_info;
           P64[Hp] = _sfXUv::P64;
           R6 = _sfXUz::I64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.319592161 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_$cshow_closure" {
     Data.Functor.Sum.$fShowSum_$cshow_closure:
         const Data.Functor.Sum.$fShowSum_$cshow_info;
         const 0;
 },
 sat_sfXUJ_entry() //  [R1]
         { info_tbl: [(cfZsO,
                       label: sat_sfXUJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZsO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZsP; else goto cfZsQ;
       cfZsP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZsQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUI_entry() //  [R1]
         { info_tbl: [(cfZsV,
                       label: sat_sfXUI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZsV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZsW; else goto cfZsX;
       cfZsW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZsX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUK_entry() //  [R1]
         { info_tbl: [(cfZsY,
                       label: sat_sfXUK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZsY: // global
           _sfXUK::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cfZsZ; else goto cfZt0;
       cfZt0: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfZt2; else goto cfZt1;
       cfZt2: // global
           HpAlloc = 48;
           goto cfZsZ;
       cfZsZ: // global
           R1 = _sfXUK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZt1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXUK::P64;
           _sfXUC::P64 = P64[_sfXUK::P64 + 16];
           _sfXUE::P64 = P64[_sfXUK::P64 + 24];
           _sfXUH::P64 = P64[_sfXUK::P64 + 32];
           I64[Hp - 40] = sat_sfXUJ_info;
           P64[Hp - 24] = _sfXUE::P64;
           I64[Hp - 16] = sat_sfXUI_info;
           P64[Hp] = _sfXUE::P64;
           R2 = _sfXUC::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = Hp - 16;
           P64[Sp - 48] = Hp - 40;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sfXUH::P64;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 sat_sfXUO_entry() //  [R1]
         { info_tbl: [(cfZtd,
                       label: sat_sfXUO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZtd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZte; else goto cfZtf;
       cfZte: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZtf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUN_entry() //  [R1]
         { info_tbl: [(cfZtk,
                       label: sat_sfXUN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZtk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZtl; else goto cfZtm;
       cfZtl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZtm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUP_entry() //  [R1]
         { info_tbl: [(cfZtn,
                       label: sat_sfXUP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZtn: // global
           _sfXUP::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cfZto; else goto cfZtp;
       cfZtp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfZtr; else goto cfZtq;
       cfZtr: // global
           HpAlloc = 48;
           goto cfZto;
       cfZto: // global
           R1 = _sfXUP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZtq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXUP::P64;
           _sfXUD::P64 = P64[_sfXUP::P64 + 16];
           _sfXUE::P64 = P64[_sfXUP::P64 + 24];
           _sfXUM::P64 = P64[_sfXUP::P64 + 32];
           I64[Hp - 40] = sat_sfXUO_info;
           P64[Hp - 24] = _sfXUE::P64;
           I64[Hp - 16] = sat_sfXUN_info;
           P64[Hp] = _sfXUE::P64;
           R2 = _sfXUD::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = Hp - 16;
           P64[Sp - 48] = Hp - 40;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sfXUM::P64;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fShowSum_$cshow_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfZtw,
                       label: Data.Functor.Sum.$fShowSum_$cshow_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZtw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZtx; else goto cfZty;
       cfZtx: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_$cshow_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZty: // global
           I64[Sp - 32] = block_cfZsB_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufZtH; else goto cfZsC;
       ufZtH: // global
           call _cfZsB(R1) args: 0, res: 0, upd: 0;
       cfZsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZsB() //  [R1]
         { info_tbl: [(cfZsB,
                       label: block_cfZsB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZsB: // global
           _sfXUE::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfZtt; else goto cfZtu;
       cfZtt: // global
           Hp = Hp + 64;
           _sfXUG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZtG; else goto cfZtB;
       cfZtB: // global
           _sfXUH::P64 = P64[_sfXUG::P64 + 7];
           I64[Hp - 56] = sat_sfXUK_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sfXUE::P64;
           P64[Hp - 24] = _sfXUH::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = Data.Functor.Sum.$fRead1Sum7_closure;
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cfZtu: // global
           Hp = Hp + 64;
           _sfXUG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZtG; else goto cfZtF;
       cfZtG: // global
           HpAlloc = 64;
           R1 = _sfXUG::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZtF: // global
           _sfXUM::P64 = P64[_sfXUG::P64 + 6];
           I64[Hp - 56] = sat_sfXUP_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = _sfXUE::P64;
           P64[Hp - 24] = _sfXUM::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = Data.Functor.Sum.$fRead1Sum3_closure;
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.323367907 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_$cshowList_closure" {
     Data.Functor.Sum.$fShowSum_$cshowList_closure:
         const Data.Functor.Sum.$fShowSum_$cshowList_info;
         const 0;
 },
 lvl8_sfXUW_entry() //  [R1]
         { info_tbl: [(cfZtQ,
                       label: lvl8_sfXUW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZtQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZtR; else goto cfZtS;
       cfZtR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZtS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sfXUX_entry() //  [R1]
         { info_tbl: [(cfZtX,
                       label: lvl9_sfXUX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZtX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZtY; else goto cfZtZ;
       cfZtY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZtZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUZ_entry() //  [R1, R2]
         { info_tbl: [(cfZu5,
                       label: sat_sfXUZ_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZu5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZu6; else goto cfZu7;
       cfZu6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZu7: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sfXUY::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sfXUY::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShowSum_$cshowList_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cfZu8,
                       label: Data.Functor.Sum.$fShowSum_$cshowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZu8: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfZuc; else goto cfZub;
       cfZuc: // global
           HpAlloc = 88;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_$cshowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZub: // global
           I64[Hp - 80] = lvl8_sfXUW_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl9_sfXUX_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sfXUZ_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 31;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.325655286 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_closure" {
     Data.Functor.Sum.$fShowSum_closure:
         const Data.Functor.Sum.$fShowSum_info;
         const 0;
 },
 sat_sfXV5_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZum,
                       label: sat_sfXV5_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZum: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fShowSum_$cshowList_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXV4_entry() //  [R1, R2]
         { info_tbl: [(cfZuu,
                       label: sat_sfXV4_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZuu: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fShowSum_$cshow_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXV3_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZuC,
                       label: sat_sfXV3_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZuC: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fShowSum_$cshowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShowSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZuG,
                       label: Data.Functor.Sum.$fShowSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZuG: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cfZuK; else goto cfZuJ;
       cfZuK: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZuJ: // global
           I64[Hp - 120] = sat_sfXV5_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sfXV4_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sfXV3_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 118;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.327994273 UTC

[section ""data" . Data.Functor.Sum.$fFunctorSum_$cfmap_closure" {
     Data.Functor.Sum.$fFunctorSum_$cfmap_closure:
         const Data.Functor.Sum.$fFunctorSum_$cfmap_info;
 },
 sat_sfXVc_entry() //  [R1]
         { info_tbl: [(cfZuY,
                       label: sat_sfXVc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZuY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZuZ; else goto cfZv0;
       cfZuZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZv0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sfXVe_entry() //  [R1]
         { info_tbl: [(cfZv7,
                       label: sat_sfXVe_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZv7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZv8; else goto cfZv9;
       cfZv8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZv9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fFunctorSum_$cfmap_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfZve,
                       label: Data.Functor.Sum.$fFunctorSum_$cfmap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZve: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZvf; else goto cfZvg;
       cfZvf: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFunctorSum_$cfmap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZvg: // global
           I64[Sp - 32] = block_cfZuP_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufZvp; else goto cfZuQ;
       ufZvp: // global
           call _cfZuP(R1) args: 0, res: 0, upd: 0;
       cfZuQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZuP() //  [R1]
         { info_tbl: [(cfZuP,
                       label: block_cfZuP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZuP: // global
           _sfXV8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfZvb; else goto cfZvc;
       cfZvb: // global
           Hp = Hp + 56;
           _sfXVa::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZvo; else goto cfZvj;
       cfZvj: // global
           _sfXVb::P64 = P64[_sfXVa::P64 + 7];
           I64[Hp - 48] = sat_sfXVc_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sfXV8::P64;
           P64[Hp - 16] = _sfXVb::P64;
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfZvc: // global
           Hp = Hp + 56;
           _sfXVa::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZvo; else goto cfZvn;
       cfZvo: // global
           HpAlloc = 56;
           R1 = _sfXVa::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZvn: // global
           _sfXVd::P64 = P64[_sfXVa::P64 + 6];
           I64[Hp - 48] = sat_sfXVe_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sfXV8::P64;
           P64[Hp - 16] = _sfXVd::P64;
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.330252831 UTC

[section ""data" . Data.Functor.Sum.$fFunctorSum_$c<$_closure" {
     Data.Functor.Sum.$fFunctorSum_$c<$_closure:
         const Data.Functor.Sum.$fFunctorSum_$c<$_info;
 },
 sat_sfXVk_entry() //  [R1]
         { info_tbl: [(cfZvz,
                       label: sat_sfXVk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZvz: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFunctorSum_$c<$_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfZvC,
                       label: Data.Functor.Sum.$fFunctorSum_$c<$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZvC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZvG; else goto cfZvF;
       cfZvG: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFunctorSum_$c<$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZvF: // global
           I64[Hp - 8] = sat_sfXVk_info;
           P64[Hp] = R4;
           R5 = R5;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fFunctorSum_$cfmap_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.331758448 UTC

[section ""data" . Data.Functor.Sum.$fFunctorSum_closure" {
     Data.Functor.Sum.$fFunctorSum_closure:
         const Data.Functor.Sum.$fFunctorSum_info;
 },
 sat_sfXVo_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZvQ,
                       label: sat_sfXVo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZvQ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFunctorSum_$c<$_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXVn_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZvY,
                       label: sat_sfXVn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZvY: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFunctorSum_$cfmap_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFunctorSum_entry() //  [R2, R3]
         { info_tbl: [(cfZw2,
                       label: Data.Functor.Sum.$fFunctorSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZw2: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfZw6; else goto cfZw5;
       cfZw6: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFunctorSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZw5: // global
           I64[Hp - 64] = sat_sfXVo_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sfXVn_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.333470555 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldMap_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldMap_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldMap_info;
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldMap_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cfZwi,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZwi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZwj; else goto cfZwk;
       cfZwj: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZwk: // global
           I64[Sp - 40] = block_cfZwb_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZwr; else goto cfZwc;
       ufZwr: // global
           call _cfZwb(R1) args: 0, res: 0, upd: 0;
       cfZwc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZwb() //  [R1]
         { info_tbl: [(cfZwb,
                       label: block_cfZwb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZwb: // global
           _sfXVr::P64 = P64[Sp + 24];
           _sfXVs::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZwf; else goto cfZwg;
       cfZwf: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = _sfXVr::P64;
           P64[Sp + 24] = _sfXVs::P64;
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cfZwg: // global
           R2 = P64[Sp + 16];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = _sfXVr::P64;
           P64[Sp + 24] = _sfXVs::P64;
           P64[Sp + 32] = P64[R1 + 6];
           Sp = Sp + 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.335063802 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfold_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfold_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfold_info;
 },
 Data.Functor.Sum.$fFoldableSum_$cfold_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfZwD,
                       label: Data.Functor.Sum.$fFoldableSum_$cfold_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZwD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZwE; else goto cfZwF;
       cfZwE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfold_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZwF: // global
           I64[Sp - 32] = block_cfZww_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufZwM; else goto cfZwx;
       ufZwM: // global
           call _cfZww(R1) args: 0, res: 0, upd: 0;
       cfZwx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZww() //  [R1]
         { info_tbl: [(cfZww,
                       label: block_cfZww_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZww: // global
           _sfXVz::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfZwA; else goto cfZwB;
       cfZwA: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXVz::P64;
           P64[Sp + 16] = GHC.Base.id_closure+1;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cfZwB: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXVz::P64;
           P64[Sp + 16] = GHC.Base.id_closure+1;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.336432953 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum2_closure" {
     Data.Functor.Sum.$fFoldableSum2_closure:
         const Data.Functor.Sum.$fFoldableSum2_info;
 },
 Data.Functor.Sum.$fFoldableSum2_entry() //  [R2]
         { info_tbl: [(cfZwR,
                       label: Data.Functor.Sum.$fFoldableSum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZwR: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.337844666 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum3_closure" {
     Data.Functor.Sum.$fFoldableSum3_closure:
         const Data.Functor.Sum.$fFoldableSum3_info;
         const 0;
 },
 $dMonoid_sfXVI_entry() //  [R1]
         { info_tbl: [(cfZx2,
                       label: $dMonoid_sfXVI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZx2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZx3; else goto cfZx4;
       cfZx3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZx4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXVN_entry() //  [R1, R2]
         { info_tbl: [(cfZxh,
                       label: sat_sfXVN_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZxh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZxi; else goto cfZxj;
       cfZxi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZxj: // global
           I64[Sp - 32] = block_cfZxa_info;
           _sfXVF::P64 = P64[R1 + 7];
           _sfXVG::P64 = P64[R1 + 15];
           _sfXVI::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXVF::P64;
           P64[Sp - 16] = _sfXVG::P64;
           P64[Sp - 8] = _sfXVI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufZxq; else goto cfZxb;
       ufZxq: // global
           call _cfZxa(R1) args: 0, res: 0, upd: 0;
       cfZxb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZxa() //  [R1]
         { info_tbl: [(cfZxa,
                       label: block_cfZxa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZxa: // global
           _sfXVI::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfZxe; else goto cfZxf;
       cfZxe: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXVI::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cfZxf: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXVI::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum3_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZxr,
                       label: Data.Functor.Sum.$fFoldableSum3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZxr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZxv; else goto cfZxu;
       cfZxv: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZxu: // global
           I64[Hp - 48] = $dMonoid_sfXVI_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sfXVN_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.339614568 UTC

[section ""cstring" . lvl_rfXP1_bytes" {
     lvl_rfXP1_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.340366095 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum4_closure" {
     Data.Functor.Sum.$fFoldableSum4_closure:
         const Data.Functor.Sum.$fFoldableSum4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum4_entry() //  [R1]
         { info_tbl: [(cfZxE,
                       label: Data.Functor.Sum.$fFoldableSum4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZxE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfZxF; else goto cfZxG;
       cfZxF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZxG: // global
           (_cfZxz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfZxz::I64 == 0) goto cfZxB; else goto cfZxA;
       cfZxB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfZxA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfZxz::I64;
           I64[Sp - 24] = block_cfZxC_info;
           R2 = lvl_rfXP1_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfZxC() //  [R1]
         { info_tbl: [(cfZxC,
                       label: block_cfZxC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZxC: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.342463156 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cminimum_closure" {
     Data.Functor.Sum.$fFoldableSum_$cminimum_closure:
         const Data.Functor.Sum.$fFoldableSum_$cminimum_info;
         const 0;
 },
 g1_sfXVS_entry() //  [R1]
         { info_tbl: [(cfZxS,
                       label: g1_sfXVS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZxS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZxT; else goto cfZxU;
       cfZxT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZxU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXW1_entry() //  [R1, R2]
         { info_tbl: [(cfZy7,
                       label: sat_sfXW1_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZy7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZy8; else goto cfZy9;
       cfZy8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZy9: // global
           I64[Sp - 32] = block_cfZy0_info;
           _sfXVP::P64 = P64[R1 + 7];
           _sfXVQ::P64 = P64[R1 + 15];
           _sfXVS::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXVP::P64;
           P64[Sp - 16] = _sfXVQ::P64;
           P64[Sp - 8] = _sfXVS::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufZyG; else goto cfZy1;
       ufZyG: // global
           call _cfZy0(R1) args: 0, res: 0, upd: 0;
       cfZy1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZy0() //  [R1]
         { info_tbl: [(cfZy0,
                       label: block_cfZy0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZy0: // global
           _sfXVS::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfZy4; else goto cfZy5;
       cfZy4: // global
           I64[Sp + 24] = block_cfZyc_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sfXVS::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cfZy5: // global
           I64[Sp + 24] = block_cfZyq_info;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sfXVS::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 6];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfZyc() //  [R1]
         { info_tbl: [(cfZyc,
                       label: block_cfZyc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZyc: // global
           if (R1 & 7 == 1) goto ufZyF; else goto cfZyn;
       ufZyF: // global
           Sp = Sp + 8;
           call _cfZyx() args: 0, res: 0, upd: 0;
       cfZyn: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZyq() //  [R1]
         { info_tbl: [(cfZyq,
                       label: block_cfZyq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZyq: // global
           if (R1 & 7 == 1) goto ufZyE; else goto cfZyB;
       ufZyE: // global
           Sp = Sp + 8;
           call _cfZyx() args: 0, res: 0, upd: 0;
       cfZyB: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZyx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZyx: // global
           R1 = Data.Functor.Sum.$fFoldableSum4_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cminimum_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZyJ,
                       label: Data.Functor.Sum.$fFoldableSum_$cminimum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZyJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZyN; else goto cfZyM;
       cfZyN: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cminimum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZyM: // global
           I64[Hp - 48] = g1_sfXVS_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sfXW1_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.344668834 UTC

[section ""cstring" . lvl1_rfXP2_bytes" {
     lvl1_rfXP2_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.345535673 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum5_closure" {
     Data.Functor.Sum.$fFoldableSum5_closure:
         const Data.Functor.Sum.$fFoldableSum5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum5_entry() //  [R1]
         { info_tbl: [(cfZyW,
                       label: Data.Functor.Sum.$fFoldableSum5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZyW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfZyX; else goto cfZyY;
       cfZyX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZyY: // global
           (_cfZyR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfZyR::I64 == 0) goto cfZyT; else goto cfZyS;
       cfZyT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfZyS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfZyR::I64;
           I64[Sp - 24] = block_cfZyU_info;
           R2 = lvl1_rfXP2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfZyU() //  [R1]
         { info_tbl: [(cfZyU,
                       label: block_cfZyU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZyU: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.347456385 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cmaximum_closure" {
     Data.Functor.Sum.$fFoldableSum_$cmaximum_closure:
         const Data.Functor.Sum.$fFoldableSum_$cmaximum_info;
         const 0;
 },
 g1_sfXW6_entry() //  [R1]
         { info_tbl: [(cfZza,
                       label: g1_sfXW6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZza: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZzb; else goto cfZzc;
       cfZzb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZzc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXWf_entry() //  [R1, R2]
         { info_tbl: [(cfZzp,
                       label: sat_sfXWf_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZzp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZzq; else goto cfZzr;
       cfZzq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZzr: // global
           I64[Sp - 32] = block_cfZzi_info;
           _sfXW3::P64 = P64[R1 + 7];
           _sfXW4::P64 = P64[R1 + 15];
           _sfXW6::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXW3::P64;
           P64[Sp - 16] = _sfXW4::P64;
           P64[Sp - 8] = _sfXW6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufZzY; else goto cfZzj;
       ufZzY: // global
           call _cfZzi(R1) args: 0, res: 0, upd: 0;
       cfZzj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZzi() //  [R1]
         { info_tbl: [(cfZzi,
                       label: block_cfZzi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZzi: // global
           _sfXW6::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfZzm; else goto cfZzn;
       cfZzm: // global
           I64[Sp + 24] = block_cfZzu_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sfXW6::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cfZzn: // global
           I64[Sp + 24] = block_cfZzI_info;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sfXW6::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 6];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfZzu() //  [R1]
         { info_tbl: [(cfZzu,
                       label: block_cfZzu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZzu: // global
           if (R1 & 7 == 1) goto ufZzX; else goto cfZzF;
       ufZzX: // global
           Sp = Sp + 8;
           call _cfZzP() args: 0, res: 0, upd: 0;
       cfZzF: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZzI() //  [R1]
         { info_tbl: [(cfZzI,
                       label: block_cfZzI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZzI: // global
           if (R1 & 7 == 1) goto ufZzW; else goto cfZzT;
       ufZzW: // global
           Sp = Sp + 8;
           call _cfZzP() args: 0, res: 0, upd: 0;
       cfZzT: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZzP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZzP: // global
           R1 = Data.Functor.Sum.$fFoldableSum5_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cmaximum_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZA1,
                       label: Data.Functor.Sum.$fFoldableSum_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZA1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZA5; else goto cfZA4;
       cfZA5: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cmaximum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZA4: // global
           I64[Hp - 48] = g1_sfXW6_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sfXWf_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.350314759 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$celem_closure" {
     Data.Functor.Sum.$fFoldableSum_$celem_closure:
         const Data.Functor.Sum.$fFoldableSum_$celem_info;
         const 0;
 },
 f1_sfXWk_entry() //  [R1]
         { info_tbl: [(cfZAe,
                       label: f1_sfXWk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZAe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZAf; else goto cfZAg;
       cfZAf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZAg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfXWp_entry() //  [R1, R2]
         { info_tbl: [(cfZAt,
                       label: sat_sfXWp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZAt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZAu; else goto cfZAv;
       cfZAu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZAv: // global
           I64[Sp - 32] = block_cfZAm_info;
           _sfXWg::P64 = P64[R1 + 7];
           _sfXWh::P64 = P64[R1 + 15];
           _sfXWk::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXWg::P64;
           P64[Sp - 16] = _sfXWh::P64;
           P64[Sp - 8] = _sfXWk::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufZAC; else goto cfZAn;
       ufZAC: // global
           call _cfZAm(R1) args: 0, res: 0, upd: 0;
       cfZAn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZAm() //  [R1]
         { info_tbl: [(cfZAm,
                       label: block_cfZAm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZAm: // global
           _sfXWk::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfZAq; else goto cfZAr;
       cfZAq: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp + 16] = _sfXWk::P64;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cfZAr: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp + 16] = _sfXWk::P64;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$celem_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfZAD,
                       label: Data.Functor.Sum.$fFoldableSum_$celem_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZAD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfZAH; else goto cfZAG;
       cfZAH: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$celem_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZAG: // global
           I64[Hp - 56] = f1_sfXWk_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = sat_sfXWp_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.352273185 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum10_closure" {
     Data.Functor.Sum.$fFoldableSum10_closure:
         const Data.Functor.Sum.$fFoldableSum10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum10_entry() //  [R1]
         { info_tbl: [(cfZAO,
                       label: Data.Functor.Sum.$fFoldableSum10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZAO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZAP; else goto cfZAQ;
       cfZAP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZAQ: // global
           (_cfZAL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfZAL::I64 == 0) goto cfZAN; else goto cfZAM;
       cfZAN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfZAM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfZAL::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.353711763 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldl_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldl_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldl_info;
         const 0;
 },
 f2_sfXWv_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZB0,
                       label: f2_sfXWv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZB0: // global
           _sfXWx::P64 = R3;
           R3 = R2;
           R2 = _sfXWx::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldl_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cfZBa,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZBa: // global
           _sfXWu::P64 = R6;
           _sfXWt::P64 = R5;
           _sfXWs::P64 = R4;
           _sfXWr::P64 = R3;
           _sfXWq::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cfZBb; else goto cfZBc;
       cfZBc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZBe; else goto cfZBd;
       cfZBe: // global
           HpAlloc = 16;
           goto cfZBb;
       cfZBb: // global
           R6 = _sfXWu::P64;
           R5 = _sfXWt::P64;
           R4 = _sfXWs::P64;
           R3 = _sfXWr::P64;
           R2 = _sfXWq::P64;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZBd: // global
           I64[Hp - 8] = f2_sfXWv_info;
           P64[Hp] = _sfXWs::P64;
           I64[Sp - 40] = block_cfZB3_info;
           R1 = _sfXWu::P64;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = _sfXWq::P64;
           P64[Sp - 16] = _sfXWr::P64;
           P64[Sp - 8] = _sfXWt::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZBl; else goto cfZB4;
       ufZBl: // global
           call _cfZB3(R1) args: 0, res: 0, upd: 0;
       cfZB4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZB3() //  [R1]
         { info_tbl: [(cfZB3,
                       label: block_cfZB3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZB3: // global
           _cfZAV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cfZB7; else goto cfZB8;
       cfZB7: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 16] = _cfZAV::P64;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
       cfZB8: // global
           R2 = P64[Sp + 24];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 16] = _cfZAV::P64;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.35524164 UTC

[section ""cstring" . lvl2_rfXP3_bytes" {
     lvl2_rfXP3_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.356025907 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum9_closure" {
     Data.Functor.Sum.$fFoldableSum9_closure:
         const Data.Functor.Sum.$fFoldableSum9_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum9_entry() //  [R1]
         { info_tbl: [(cfZBu,
                       label: Data.Functor.Sum.$fFoldableSum9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZBu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfZBv; else goto cfZBw;
       cfZBv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZBw: // global
           (_cfZBp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfZBp::I64 == 0) goto cfZBr; else goto cfZBq;
       cfZBr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfZBq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfZBp::I64;
           I64[Sp - 24] = block_cfZBs_info;
           R2 = lvl2_rfXP3_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfZBs() //  [R1]
         { info_tbl: [(cfZBs,
                       label: block_cfZBs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZBs: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.359088577 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldl1_info;
         const 0;
 },
 sat_sfXWM_entry() //  [R1]
         { info_tbl: [(cfZBZ,
                       label: sat_sfXWM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZBZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZC0; else goto cfZC1;
       cfZC0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZC1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfZBS_info;
           _sfXWE::P64 = P64[R1 + 16];
           _sfXWI::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sfXWE::P64;
           P64[Sp - 24] = _sfXWI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZC8; else goto cfZBT;
       ufZC8: // global
           call _cfZBS(R1) args: 0, res: 0, upd: 0;
       cfZBT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfZBS() //  [R1]
         { info_tbl: [(cfZBS,
                       label: block_cfZBS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZBS: // global
           _sfXWI::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfZBW; else goto cfZBX;
       cfZBW: // global
           R1 = _sfXWI::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cfZBX: // global
           R3 = _sfXWI::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXWN_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZCa,
                       label: sat_sfXWN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZCa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZCe; else goto cfZCd;
       cfZCe: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZCd: // global
           _sfXWE::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sfXWM_info;
           P64[Hp - 32] = _sfXWE::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXWV_entry() //  [R1]
         { info_tbl: [(cfZCx,
                       label: sat_sfXWV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZCx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZCy; else goto cfZCz;
       cfZCy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZCz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfZCq_info;
           _sfXWE::P64 = P64[R1 + 16];
           _sfXWR::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sfXWE::P64;
           P64[Sp - 24] = _sfXWR::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZCG; else goto cfZCr;
       ufZCG: // global
           call _cfZCq(R1) args: 0, res: 0, upd: 0;
       cfZCr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfZCq() //  [R1]
         { info_tbl: [(cfZCq,
                       label: block_cfZCq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZCq: // global
           _sfXWR::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfZCu; else goto cfZCv;
       cfZCu: // global
           R1 = _sfXWR::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cfZCv: // global
           R3 = _sfXWR::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXWW_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZCI,
                       label: sat_sfXWW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZCI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZCM; else goto cfZCL;
       cfZCM: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZCL: // global
           _sfXWE::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sfXWV_info;
           P64[Hp - 32] = _sfXWE::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldl1_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cfZCR,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZCR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfZCS; else goto cfZCT;
       cfZCS: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZCT: // global
           I64[Sp - 32] = block_cfZBE_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufZDq; else goto cfZBF;
       ufZDq: // global
           call _cfZBE(R1) args: 0, res: 0, upd: 0;
       cfZBF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZBE() //  [R1]
         { info_tbl: [(cfZBE,
                       label: block_cfZBE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZBE: // global
           _sfXWE::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfZCO; else goto cfZCP;
       cfZCO: // global
           Hp = Hp + 16;
           _sfXWG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZDb; else goto cfZCW;
       cfZCW: // global
           _sfXWH::P64 = P64[_sfXWG::P64 + 7];
           I64[Hp - 8] = sat_sfXWN_info;
           P64[Hp] = _sfXWE::P64;
           I64[Sp + 24] = block_cfZCU_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp] = Hp - 6;
           P64[Sp + 8] = _sfXWH::P64;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
       cfZCP: // global
           Hp = Hp + 16;
           _sfXWG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZDb; else goto cfZDa;
       cfZDb: // global
           HpAlloc = 16;
           R1 = _sfXWG::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZDa: // global
           _sfXWQ::P64 = P64[_sfXWG::P64 + 6];
           I64[Hp - 8] = sat_sfXWW_info;
           P64[Hp] = _sfXWE::P64;
           I64[Sp + 24] = block_cfZD8_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp] = Hp - 6;
           P64[Sp + 8] = _sfXWQ::P64;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cfZCU() //  [R1]
         { info_tbl: [(cfZCU,
                       label: block_cfZCU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZCU: // global
           if (R1 & 7 == 1) goto ufZDp; else goto cfZD7;
       ufZDp: // global
           Sp = Sp + 8;
           call _cfZDh() args: 0, res: 0, upd: 0;
       cfZD7: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZD8() //  [R1]
         { info_tbl: [(cfZD8,
                       label: block_cfZD8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZD8: // global
           if (R1 & 7 == 1) goto ufZDo; else goto cfZDl;
       ufZDo: // global
           Sp = Sp + 8;
           call _cfZDh() args: 0, res: 0, upd: 0;
       cfZDl: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZDh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZDh: // global
           R1 = Data.Functor.Sum.$fFoldableSum9_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.363757185 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldr'_info;
         const 0;
 },
 sat_sfXXa_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZDJ,
                       label: sat_sfXXa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZDJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZDK; else goto cfZDL;
       cfZDK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZDL: // global
           I64[Sp - 16] = block_cfZDH_info;
           _sfXX7::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sfXX7::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZDH() //  [R1]
         { info_tbl: [(cfZDH,
                       label: block_cfZDH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZDH: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXXg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZDW,
                       label: sat_sfXXg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZDW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZDX; else goto cfZDY;
       cfZDX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZDY: // global
           I64[Sp - 16] = block_cfZDU_info;
           _sfXXd::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sfXXd::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZDU() //  [R1]
         { info_tbl: [(cfZDU,
                       label: block_cfZDU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZDU: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldr'_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cfZE4,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZE4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfZE5; else goto cfZE6;
       cfZE5: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZE6: // global
           I64[Sp - 40] = block_cfZDx_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZEd; else goto cfZDy;
       ufZEd: // global
           call _cfZDx(R1) args: 0, res: 0, upd: 0;
       cfZDy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZDx() //  [R1]
         { info_tbl: [(cfZDx,
                       label: block_cfZDx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZDx: // global
           _sfXX1::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfZE1; else goto cfZE2;
       cfZE1: // global
           Hp = Hp + 16;
           _sfXX4::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZEc; else goto cfZE8;
       cfZE8: // global
           _sfXX5::P64 = P64[_sfXX4::P64 + 7];
           I64[Hp - 8] = sat_sfXXa_info;
           P64[Hp] = _sfXX1::P64;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppppp_info;
           P64[Sp] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 8] = Hp - 5;
           P64[Sp + 16] = _sfXX5::P64;
           P64[Sp + 24] = GHC.Base.id_closure+1;
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
       cfZE2: // global
           Hp = Hp + 16;
           _sfXX4::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZEc; else goto cfZEb;
       cfZEc: // global
           HpAlloc = 16;
           R1 = _sfXX4::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZEb: // global
           _sfXXb::P64 = P64[_sfXX4::P64 + 6];
           I64[Hp - 8] = sat_sfXXg_info;
           P64[Hp] = _sfXX1::P64;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_ppppp_info;
           P64[Sp] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 8] = Hp - 5;
           P64[Sp + 16] = _sfXXb::P64;
           P64[Sp + 24] = GHC.Base.id_closure+1;
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.369972093 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldr_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldr_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldr_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldr_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cfZEp,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZEp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZEq; else goto cfZEr;
       cfZEq: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZEr: // global
           I64[Sp - 40] = block_cfZEi_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZEy; else goto cfZEj;
       ufZEy: // global
           call _cfZEi(R1) args: 0, res: 0, upd: 0;
       cfZEj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZEi() //  [R1]
         { info_tbl: [(cfZEi,
                       label: block_cfZEi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZEi: // global
           _sfXXj::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfZEm; else goto cfZEn;
       cfZEm: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp + 16] = _sfXXj::P64;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
       cfZEn: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp + 16] = _sfXXj::P64;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.371609959 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldl'_info;
         const 0;
 },
 sat_sfXXy_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZEK,
                       label: sat_sfXXy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZEK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZEL; else goto cfZEM;
       cfZEL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZEM: // global
           I64[Sp - 16] = block_cfZEI_info;
           _sfXXv::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sfXXv::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZEI() //  [R1]
         { info_tbl: [(cfZEI,
                       label: block_cfZEI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZEI: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldl'_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cfZEO,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZEO: // global
           _sfXXt::P64 = R6;
           _sfXXs::P64 = R5;
           _sfXXr::P64 = R4;
           _sfXXq::P64 = R3;
           _sfXXp::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cfZEP; else goto cfZEQ;
       cfZEQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZES; else goto cfZER;
       cfZES: // global
           HpAlloc = 16;
           goto cfZEP;
       cfZEP: // global
           R6 = _sfXXt::P64;
           R5 = _sfXXs::P64;
           R4 = _sfXXr::P64;
           R3 = _sfXXq::P64;
           R2 = _sfXXp::P64;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZER: // global
           I64[Hp - 8] = sat_sfXXy_info;
           P64[Hp] = _sfXXr::P64;
           R6 = _sfXXt::P64;
           R5 = GHC.Base.id_closure+1;
           R4 = Hp - 5;
           R3 = _sfXXq::P64;
           R2 = _sfXXp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sfXXs::P64;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.373450669 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum7_closure" {
     Data.Functor.Sum.$fFoldableSum7_closure:
         const Data.Functor.Sum.$fFoldableSum7_info;
 },
 Data.Functor.Sum.$fFoldableSum7_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZF0,
                       label: Data.Functor.Sum.$fFoldableSum7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZF0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZF7; else goto cfZF8;
       cfZF7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZF8: // global
           I64[Sp - 16] = block_cfZEX_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufZFc; else goto cfZEY;
       ufZFc: // global
           call _cfZEX(R1) args: 0, res: 0, upd: 0;
       cfZEY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZEX() //  [R1]
         { info_tbl: [(cfZEX,
                       label: block_cfZEX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZEX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZFb; else goto cfZFa;
       cfZFb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZFa: // global
           _sfXXE::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sfXXE::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.37473733 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$clength_closure" {
     Data.Functor.Sum.$fFoldableSum_$clength_closure:
         const Data.Functor.Sum.$fFoldableSum_$clength_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$clength_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZFh,
                       label: Data.Functor.Sum.$fFoldableSum_$clength_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZFh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZFi; else goto cfZFj;
       cfZFi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$clength_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZFj: // global
           R6 = R4;
           R5 = GHC.Base.id_closure+1;
           R4 = Data.Functor.Sum.$fFoldableSum7_closure+3;
           R3 = R3;
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Functor.Sum.$fFoldableSum6_closure+1;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.375593705 UTC

[section ""cstring" . lvl3_rfXP4_bytes" {
     lvl3_rfXP4_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.376406681 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum11_closure" {
     Data.Functor.Sum.$fFoldableSum11_closure:
         const Data.Functor.Sum.$fFoldableSum11_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum11_entry() //  [R1]
         { info_tbl: [(cfZFs,
                       label: Data.Functor.Sum.$fFoldableSum11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZFs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfZFt; else goto cfZFu;
       cfZFt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZFu: // global
           (_cfZFn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfZFn::I64 == 0) goto cfZFp; else goto cfZFo;
       cfZFp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfZFo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfZFn::I64;
           I64[Sp - 24] = block_cfZFq_info;
           R2 = lvl3_rfXP4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfZFq() //  [R1]
         { info_tbl: [(cfZFq,
                       label: block_cfZFq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZFq: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.37835849 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldr1_info;
         const 0;
 },
 sat_sfXXS_entry() //  [R1]
         { info_tbl: [(cfZFS,
                       label: sat_sfXXS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZFS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZFT; else goto cfZFU;
       cfZFT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZFU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfZFL_info;
           _sfXXM::P64 = P64[R1 + 16];
           _sfXXO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sfXXM::P64;
           P64[Sp - 24] = _sfXXO::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZG1; else goto cfZFM;
       ufZG1: // global
           call _cfZFL(R1) args: 0, res: 0, upd: 0;
       cfZFM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfZFL() //  [R1]
         { info_tbl: [(cfZFL,
                       label: block_cfZFL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZFL: // global
           _sfXXO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfZFP; else goto cfZFQ;
       cfZFP: // global
           R1 = _sfXXO::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cfZFQ: // global
           R3 = P64[R1 + 6];
           R2 = _sfXXO::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXXT_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZG3,
                       label: sat_sfXXT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZG3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZG7; else goto cfZG6;
       cfZG7: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZG6: // global
           _sfXXM::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sfXXS_info;
           P64[Hp - 32] = _sfXXM::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldr1_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cfZGe,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZGe: // global
           _sfXXN::P64 = R5;
           _sfXXM::P64 = R4;
           _sfXXL::P64 = R3;
           _sfXXK::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cfZGf; else goto cfZGg;
       cfZGg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfZGi; else goto cfZGh;
       cfZGi: // global
           HpAlloc = 16;
           goto cfZGf;
       cfZGf: // global
           R5 = _sfXXN::P64;
           R4 = _sfXXM::P64;
           R3 = _sfXXL::P64;
           R2 = _sfXXK::P64;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZGh: // global
           I64[Hp - 8] = sat_sfXXT_info;
           P64[Hp] = _sfXXM::P64;
           I64[Sp - 8] = block_cfZG8_info;
           R6 = _sfXXN::P64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = Hp - 6;
           R3 = _sfXXL::P64;
           R2 = _sfXXK::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZG8() //  [R1]
         { info_tbl: [(cfZG8,
                       label: block_cfZG8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZG8: // global
           if (R1 & 7 == 1) goto cfZGb; else goto cfZGc;
       cfZGb: // global
           R1 = Data.Functor.Sum.$fFoldableSum11_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfZGc: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.380544657 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum8_closure" {
     Data.Functor.Sum.$fFoldableSum8_closure:
         const Data.Functor.Sum.$fFoldableSum8_info;
 },
 Data.Functor.Sum.$fFoldableSum8_entry() //  []
         { info_tbl: [(cfZGt,
                       label: Data.Functor.Sum.$fFoldableSum8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZGt: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.381632275 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cnull_closure" {
     Data.Functor.Sum.$fFoldableSum_$cnull_closure:
         const Data.Functor.Sum.$fFoldableSum_$cnull_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$cnull_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZGA,
                       label: Data.Functor.Sum.$fFoldableSum_$cnull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZGA: // global
           R6 = R4;
           R5 = GHC.Types.True_closure+2;
           R4 = Data.Functor.Sum.$fFoldableSum8_closure+2;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.383057729 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum1_closure" {
     Data.Functor.Sum.$fFoldableSum1_closure:
         const Data.Functor.Sum.$fFoldableSum1_info;
         const 0;
 },
 $dMonoid_sfXY4_entry() //  [R1]
         { info_tbl: [(cfZGL,
                       label: $dMonoid_sfXY4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZGL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZGM; else goto cfZGN;
       cfZGM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZGN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXY9_entry() //  [R1, R2]
         { info_tbl: [(cfZH0,
                       label: sat_sfXY9_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZH0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZH1; else goto cfZH2;
       cfZH1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZH2: // global
           I64[Sp - 32] = block_cfZGT_info;
           _sfXY1::P64 = P64[R1 + 7];
           _sfXY2::P64 = P64[R1 + 15];
           _sfXY4::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXY1::P64;
           P64[Sp - 16] = _sfXY2::P64;
           P64[Sp - 8] = _sfXY4::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufZH9; else goto cfZGU;
       ufZH9: // global
           call _cfZGT(R1) args: 0, res: 0, upd: 0;
       cfZGU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZGT() //  [R1]
         { info_tbl: [(cfZGT,
                       label: block_cfZGT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZGT: // global
           _sfXY4::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfZGX; else goto cfZGY;
       cfZGX: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXY4::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cfZGY: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXY4::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum1_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZHa,
                       label: Data.Functor.Sum.$fFoldableSum1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZHa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZHe; else goto cfZHd;
       cfZHe: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZHd: // global
           I64[Hp - 48] = $dMonoid_sfXY4_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sfXY9_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.384932598 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$ctoList_closure" {
     Data.Functor.Sum.$fFoldableSum_$ctoList_closure:
         const Data.Functor.Sum.$fFoldableSum_$ctoList_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$ctoList_entry() //  [R2, R3, R4]
         { info_tbl: [(cfZHj,
                       label: Data.Functor.Sum.$fFoldableSum_$ctoList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZHj: // global
           R6 = R4;
           R5 = GHC.Types.[]_closure+1;
           R4 = GHC.Types.:_closure+2;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.387971377 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_closure" {
     Data.Functor.Sum.$fFoldableSum_closure:
         const Data.Functor.Sum.$fFoldableSum_info;
         const 0;
 },
 sat_sfXYu_entry() //  [R1, R2]
         { info_tbl: [(cfZHv,
                       label: sat_sfXYu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZHv: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYt_entry() //  [R1, R2]
         { info_tbl: [(cfZHD,
                       label: sat_sfXYt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZHD: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum3_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYs_entry() //  [R1, R2]
         { info_tbl: [(cfZHL,
                       label: sat_sfXYs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZHL: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$cminimum_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYr_entry() //  [R1, R2]
         { info_tbl: [(cfZHT,
                       label: sat_sfXYr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZHT: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$cmaximum_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYq_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZI1,
                       label: sat_sfXYq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZI1: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$celem_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYp_entry() //  [R1, R2]
         { info_tbl: [(cfZI9,
                       label: sat_sfXYp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZI9: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$clength_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYo_entry() //  [R1, R2]
         { info_tbl: [(cfZIh,
                       label: sat_sfXYo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZIh: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$cnull_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYn_entry() //  [R1, R2]
         { info_tbl: [(cfZIp,
                       label: sat_sfXYn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZIp: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$ctoList_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYm_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZIx,
                       label: sat_sfXYm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZIx: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$cfoldl1_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYl_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZIF,
                       label: sat_sfXYl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZIF: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$cfoldr1_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZIN,
                       label: sat_sfXYk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZIN: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldl'_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYj_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZIV,
                       label: sat_sfXYj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZIV: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldl_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYi_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZJ3,
                       label: sat_sfXYi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZJ3: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldr'_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYh_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZJb,
                       label: sat_sfXYh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZJb: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZJj,
                       label: sat_sfXYg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZJj: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldMap_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYf_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZJr,
                       label: sat_sfXYf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZJr: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$cfold_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_entry() //  [R2, R3]
         { info_tbl: [(cfZJv,
                       label: Data.Functor.Sum.$fFoldableSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZJv: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cfZJz; else goto cfZJy;
       cfZJz: // global
           HpAlloc = 520;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZJy: // global
           I64[Hp - 512] = sat_sfXYu_info;
           P64[Hp - 504] = R2;
           P64[Hp - 496] = R3;
           I64[Hp - 488] = sat_sfXYt_info;
           P64[Hp - 480] = R2;
           P64[Hp - 472] = R3;
           I64[Hp - 464] = sat_sfXYs_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           I64[Hp - 440] = sat_sfXYr_info;
           P64[Hp - 432] = R2;
           P64[Hp - 424] = R3;
           I64[Hp - 416] = sat_sfXYq_info;
           P64[Hp - 408] = R2;
           P64[Hp - 400] = R3;
           I64[Hp - 392] = sat_sfXYp_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           I64[Hp - 368] = sat_sfXYo_info;
           P64[Hp - 360] = R2;
           P64[Hp - 352] = R3;
           I64[Hp - 344] = sat_sfXYn_info;
           P64[Hp - 336] = R2;
           P64[Hp - 328] = R3;
           I64[Hp - 320] = sat_sfXYm_info;
           P64[Hp - 312] = R2;
           P64[Hp - 304] = R3;
           I64[Hp - 296] = sat_sfXYl_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           I64[Hp - 272] = sat_sfXYk_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_sfXYj_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_sfXYi_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_sfXYh_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sfXYg_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sfXYf_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = Data.Foldable.C:Foldable_con_info;
           P64[Hp - 120] = Hp - 150;
           P64[Hp - 112] = Hp - 173;
           P64[Hp - 104] = Hp - 197;
           P64[Hp - 96] = Hp - 221;
           P64[Hp - 88] = Hp - 245;
           P64[Hp - 80] = Hp - 269;
           P64[Hp - 72] = Hp - 294;
           P64[Hp - 64] = Hp - 318;
           P64[Hp - 56] = Hp - 343;
           P64[Hp - 48] = Hp - 367;
           P64[Hp - 40] = Hp - 391;
           P64[Hp - 32] = Hp - 414;
           P64[Hp - 24] = Hp - 439;
           P64[Hp - 16] = Hp - 463;
           P64[Hp - 8] = Hp - 487;
           P64[Hp] = Hp - 511;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.393138181 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$ctraverse_closure" {
     Data.Functor.Sum.$fTraversableSum_$ctraverse_closure:
         const Data.Functor.Sum.$fTraversableSum_$ctraverse_info;
 },
 sat_sfXYD_entry() //  [R1]
         { info_tbl: [(cfZJN,
                       label: sat_sfXYD_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZJN: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfZJO; else goto cfZJP;
       cfZJO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZJP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sfXYG_entry() //  [R1]
         { info_tbl: [(cfZJW,
                       label: sat_sfXYG_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZJW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfZJX; else goto cfZJY;
       cfZJX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZJY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cfZK3,
                       label: Data.Functor.Sum.$fTraversableSum_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZK3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZK4; else goto cfZK5;
       cfZK4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZK5: // global
           I64[Sp - 40] = block_cfZJE_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZKm; else goto cfZJF;
       ufZKm: // global
           call _cfZJE(R1) args: 0, res: 0, upd: 0;
       cfZJF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZJE() //  [R1]
         { info_tbl: [(cfZJE,
                       label: block_cfZJE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZJE: // global
           _sfXYx::P64 = P64[Sp + 24];
           _sfXYy::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZK0; else goto cfZK1;
       cfZK0: // global
           Hp = Hp + 48;
           _sfXYA::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZKh; else goto cfZK8;
       cfZK8: // global
           _sfXYB::P64 = P64[_sfXYA::P64 + 7];
           I64[Hp - 40] = sat_sfXYD_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sfXYx::P64;
           P64[Hp - 8] = _sfXYy::P64;
           P64[Hp] = _sfXYB::P64;
           I64[Sp + 24] = block_cfZK6_info;
           R2 = _sfXYx::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
       cfZK1: // global
           Hp = Hp + 48;
           _sfXYA::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZKh; else goto cfZKg;
       cfZKh: // global
           HpAlloc = 48;
           R1 = _sfXYA::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZKg: // global
           _sfXYE::P64 = P64[_sfXYA::P64 + 6];
           I64[Hp - 40] = sat_sfXYG_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sfXYx::P64;
           P64[Hp - 8] = _sfXYy::P64;
           P64[Hp] = _sfXYE::P64;
           I64[Sp + 24] = block_cfZKe_info;
           R2 = _sfXYx::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZK6() //  [R1]
         { info_tbl: [(cfZK6,
                       label: block_cfZK6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZK6: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Sum.InL_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cfZKe() //  [R1]
         { info_tbl: [(cfZKe,
                       label: block_cfZKe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZKe: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Sum.InR_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.395938686 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure" {
     Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure:
         const Data.Functor.Sum.$fTraversableSum_$cp2Traversable_info;
         const 0;
 },
 sat_sfXYK_entry() //  [R1]
         { info_tbl: [(cfZKv,
                       label: sat_sfXYK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZKv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZKw; else goto cfZKx;
       cfZKw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZKx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXYJ_entry() //  [R1]
         { info_tbl: [(cfZKC,
                       label: sat_sfXYJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZKC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZKD; else goto cfZKE;
       cfZKD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZKE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cfZKF,
                       label: Data.Functor.Sum.$fTraversableSum_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZKF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfZKJ; else goto cfZKI;
       cfZKJ: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZKI: // global
           I64[Hp - 40] = sat_sfXYK_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sfXYJ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Sum.$fFoldableSum_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.397700205 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$cp1Traversable_closure" {
     Data.Functor.Sum.$fTraversableSum_$cp1Traversable_closure:
         const Data.Functor.Sum.$fTraversableSum_$cp1Traversable_info;
 },
 sat_sfXYO_entry() //  [R1]
         { info_tbl: [(cfZKS,
                       label: sat_sfXYO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZKS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZKT; else goto cfZKU;
       cfZKT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZKU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXYN_entry() //  [R1]
         { info_tbl: [(cfZKZ,
                       label: sat_sfXYN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZKZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZL0; else goto cfZL1;
       cfZL0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZL1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cfZL2,
                       label: Data.Functor.Sum.$fTraversableSum_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZL2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfZL6; else goto cfZL5;
       cfZL6: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZL5: // global
           I64[Hp - 40] = sat_sfXYO_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sfXYN_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Sum.$fFunctorSum_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.399133155 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$csequenceA_closure" {
     Data.Functor.Sum.$fTraversableSum_$csequenceA_closure:
         const Data.Functor.Sum.$fTraversableSum_$csequenceA_info;
 },
 Data.Functor.Sum.$fTraversableSum_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cfZLb,
                       label: Data.Functor.Sum.$fTraversableSum_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZLb: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.400118111 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$cmapM_closure" {
     Data.Functor.Sum.$fTraversableSum_$cmapM_closure:
         const Data.Functor.Sum.$fTraversableSum_$cmapM_info;
 },
 Data.Functor.Sum.$fTraversableSum_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cfZLk,
                       label: Data.Functor.Sum.$fTraversableSum_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZLk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZLl; else goto cfZLm;
       cfZLl: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZLm: // global
           I64[Sp - 40] = block_cfZLi_info;
           _sfXYS::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sfXYS::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZLi() //  [R1]
         { info_tbl: [(cfZLi,
                       label: block_cfZLi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZLi: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.401496013 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$csequence_closure" {
     Data.Functor.Sum.$fTraversableSum_$csequence_closure:
         const Data.Functor.Sum.$fTraversableSum_$csequence_info;
 },
 Data.Functor.Sum.$fTraversableSum_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cfZLw,
                       label: Data.Functor.Sum.$fTraversableSum_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZLw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZLx; else goto cfZLy;
       cfZLx: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZLy: // global
           I64[Sp - 32] = block_cfZLu_info;
           _sfXYY::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sfXYY::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZLu() //  [R1]
         { info_tbl: [(cfZLu,
                       label: block_cfZLu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZLu: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.403505916 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_closure" {
     Data.Functor.Sum.$fTraversableSum_closure:
         const Data.Functor.Sum.$fTraversableSum_info;
         const 0;
 },
 sat_sfXZa_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZLL,
                       label: sat_sfXZa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZLL: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fTraversableSum_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXZ9_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZLT,
                       label: sat_sfXZ9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZLT: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fTraversableSum_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXZ8_entry() //  [R1, R2, R3]
         { info_tbl: [(cfZM1,
                       label: sat_sfXZ8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZM1: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fTraversableSum_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXZ7_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZM9,
                       label: sat_sfXZ7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZM9: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXZ6_entry() //  [R1]
         { info_tbl: [(cfZMg,
                       label: sat_sfXZ6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZMg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZMh; else goto cfZMi;
       cfZMh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZMi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fTraversableSum_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXZ5_entry() //  [R1]
         { info_tbl: [(cfZMn,
                       label: sat_sfXZ5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZMn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZMo; else goto cfZMp;
       cfZMo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZMp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fTraversableSum_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_entry() //  [R2, R3]
         { info_tbl: [(cfZMr,
                       label: Data.Functor.Sum.$fTraversableSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZMr: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cfZMv; else goto cfZMu;
       cfZMv: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZMu: // global
           I64[Hp - 208] = sat_sfXZa_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sfXZ9_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sfXZ8_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sfXZ7_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sfXZ6_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sfXZ5_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.406211684 UTC

[section ""data" . Data.Functor.Sum.$fGeneric1Sum_$cto1_closure" {
     Data.Functor.Sum.$fGeneric1Sum_$cto1_closure:
         const Data.Functor.Sum.$fGeneric1Sum_$cto1_info;
 },
 Data.Functor.Sum.$fGeneric1Sum_$cto1_entry() //  [R2]
         { info_tbl: [(cfZMG,
                       label: Data.Functor.Sum.$fGeneric1Sum_$cto1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZMG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZMH; else goto cfZMI;
       cfZMH: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGeneric1Sum_$cto1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZMI: // global
           I64[Sp - 8] = block_cfZMA_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZMA() //  [R1]
         { info_tbl: [(cfZMA,
                       label: block_cfZMA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZMA: // global
           if (R1 & 7 == 1) goto cfZMD; else goto cfZME;
       cfZMD: // global
           Hp = Hp + 16;
           _sfXZc::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZMU; else goto cfZMN;
       cfZMN: // global
           _sfXZd::P64 = P64[_sfXZc::P64 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = _sfXZd::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfZME: // global
           Hp = Hp + 16;
           _sfXZc::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZMU; else goto cfZMT;
       cfZMU: // global
           HpAlloc = 16;
           R1 = _sfXZc::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZMT: // global
           _sfXZe::P64 = P64[_sfXZc::P64 + 6];
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = _sfXZe::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.4077823 UTC

[section ""data" . Data.Functor.Sum.$fGeneric1Sum1_closure" {
     Data.Functor.Sum.$fGeneric1Sum1_closure:
         const Data.Functor.Sum.$fGeneric1Sum1_info;
 },
 Data.Functor.Sum.$fGeneric1Sum1_entry() //  [R2]
         { info_tbl: [(cfZN6,
                       label: Data.Functor.Sum.$fGeneric1Sum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZN6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZN7; else goto cfZN8;
       cfZN7: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGeneric1Sum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZN8: // global
           I64[Sp - 8] = block_cfZMZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZNl; else goto cfZN0;
       ufZNl: // global
           call _cfZMZ(R1) args: 0, res: 0, upd: 0;
       cfZN0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZMZ() //  [R1]
         { info_tbl: [(cfZMZ,
                       label: block_cfZMZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZMZ: // global
           if (R1 & 7 == 1) goto cfZN3; else goto cfZN4;
       cfZN3: // global
           Hp = Hp + 16;
           _sfXZg::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZNk; else goto cfZNd;
       cfZNd: // global
           _sfXZh::P64 = P64[_sfXZg::P64 + 7];
           I64[Hp - 8] = GHC.Generics.L1_con_info;
           P64[Hp] = _sfXZh::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfZN4: // global
           Hp = Hp + 16;
           _sfXZg::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZNk; else goto cfZNj;
       cfZNk: // global
           HpAlloc = 16;
           R1 = _sfXZg::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZNj: // global
           _sfXZi::P64 = P64[_sfXZg::P64 + 6];
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = _sfXZi::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.409034001 UTC

[section ""data" . Data.Functor.Sum.$fGeneric1Sum_closure" {
     Data.Functor.Sum.$fGeneric1Sum_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Sum.$fGeneric1Sum1_closure+1;
         const Data.Functor.Sum.$fGeneric1Sum_$cto1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.410313366 UTC

[section ""data" . Data.Functor.Sum.$fGenericSum_$cto_closure" {
     Data.Functor.Sum.$fGenericSum_$cto_closure:
         const Data.Functor.Sum.$fGenericSum_$cto_info;
 },
 Data.Functor.Sum.$fGenericSum_$cto_entry() //  [R2]
         { info_tbl: [(cfZNw,
                       label: Data.Functor.Sum.$fGenericSum_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZNw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZNx; else goto cfZNy;
       cfZNx: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGenericSum_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZNy: // global
           I64[Sp - 8] = block_cfZNq_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZNq() //  [R1]
         { info_tbl: [(cfZNq,
                       label: block_cfZNq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZNq: // global
           if (R1 & 7 == 1) goto cfZNt; else goto cfZNu;
       cfZNt: // global
           Hp = Hp + 16;
           _sfXZk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZNK; else goto cfZND;
       cfZND: // global
           _sfXZl::P64 = P64[_sfXZk::P64 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = _sfXZl::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfZNu: // global
           Hp = Hp + 16;
           _sfXZk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZNK; else goto cfZNJ;
       cfZNK: // global
           HpAlloc = 16;
           R1 = _sfXZk::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZNJ: // global
           _sfXZm::P64 = P64[_sfXZk::P64 + 6];
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = _sfXZm::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.411922804 UTC

[section ""data" . Data.Functor.Sum.$fGenericSum1_closure" {
     Data.Functor.Sum.$fGenericSum1_closure:
         const Data.Functor.Sum.$fGenericSum1_info;
 },
 Data.Functor.Sum.$fGenericSum1_entry() //  [R2]
         { info_tbl: [(cfZNW,
                       label: Data.Functor.Sum.$fGenericSum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZNW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZNX; else goto cfZNY;
       cfZNX: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGenericSum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZNY: // global
           I64[Sp - 8] = block_cfZNP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZOb; else goto cfZNQ;
       ufZOb: // global
           call _cfZNP(R1) args: 0, res: 0, upd: 0;
       cfZNQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZNP() //  [R1]
         { info_tbl: [(cfZNP,
                       label: block_cfZNP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZNP: // global
           if (R1 & 7 == 1) goto cfZNT; else goto cfZNU;
       cfZNT: // global
           Hp = Hp + 16;
           _sfXZo::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZOa; else goto cfZO3;
       cfZO3: // global
           _sfXZp::P64 = P64[_sfXZo::P64 + 7];
           I64[Hp - 8] = GHC.Generics.L1_con_info;
           P64[Hp] = _sfXZp::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfZNU: // global
           Hp = Hp + 16;
           _sfXZo::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZOa; else goto cfZO9;
       cfZOa: // global
           HpAlloc = 16;
           R1 = _sfXZo::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZO9: // global
           _sfXZq::P64 = P64[_sfXZo::P64 + 6];
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = _sfXZq::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.413159605 UTC

[section ""data" . Data.Functor.Sum.$fGenericSum_closure" {
     Data.Functor.Sum.$fGenericSum_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Sum.$fGenericSum1_closure+1;
         const Data.Functor.Sum.$fGenericSum_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.414656239 UTC

[section ""data" . Data.Functor.Sum.$w$cgunfold_closure" {
     Data.Functor.Sum.$w$cgunfold_closure:
         const Data.Functor.Sum.$w$cgunfold_info;
         const 0;
 },
 sat_sfXZG_entry() //  [R1]
         { info_tbl: [(cfZOx,
                       label: sat_sfXZG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZOx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZOy; else goto cfZOz;
       cfZOy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZOz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InR_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXZH_entry() //  [R1]
         { info_tbl: [(cfZOF,
                       label: sat_sfXZH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZOF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZOG; else goto cfZOH;
       cfZOG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZOH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InL_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgunfold_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZOM,
                       label: Data.Functor.Sum.$w$cgunfold_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZOM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZON; else goto cfZOO;
       cfZON: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$w$cgunfold_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfZOO: // global
           I64[Sp - 40] = block_cfZOg_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZP6; else goto cfZOh;
       ufZP6: // global
           call _cfZOg(R1) args: 0, res: 0, upd: 0;
       cfZOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZOg() //  [R1]
         { info_tbl: [(cfZOg,
                       label: block_cfZOg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZOg: // global
           if (R1 & 7 == 1) goto cfZOK; else goto cfZOJ;
       cfZOK: // global
           I64[Sp] = block_cfZOm_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto ufZP5; else goto cfZOn;
       ufZP5: // global
           call _cfZOm(R1) args: 0, res: 0, upd: 0;
       cfZOn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfZOJ: // global
           _sfXZw::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cfZOQ_info;
           R1 = _sfXZw::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ufZP4; else goto cfZOS;
       ufZP4: // global
           call _cfZOQ(R1) args: 0, res: 0, upd: 0;
       cfZOS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZOm() //  [R1]
         { info_tbl: [(cfZOm,
                       label: block_cfZOm_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZOm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZP0; else goto cfZOZ;
       cfZP0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZOZ: // global
           _sfXZt::P64 = P64[Sp + 24];
           _sfXZu::P64 = P64[Sp + 32];
           if (I64[R1 + 7] == 1) goto cfZP3; else goto cfZP2;
       cfZP3: // global
           I64[Hp - 16] = sat_sfXZH_info;
           P64[Hp] = _sfXZu::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 8];
           R1 = _sfXZt::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZP2: // global
           I64[Hp - 16] = sat_sfXZG_info;
           P64[Hp] = _sfXZu::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _sfXZt::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZOQ() //  [R1]
         { info_tbl: [(cfZOQ,
                       label: block_cfZOQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZOQ: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Data.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.41725908 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgunfold_closure" {
     Data.Functor.Sum.$fDataSum_$cgunfold_closure:
         const Data.Functor.Sum.$fDataSum_$cgunfold_info;
         const 0;
 },
 Data.Functor.Sum.$fDataSum_$cgunfold_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZP8: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgunfold_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgunfold_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cfZPf,
                       label: Data.Functor.Sum.$fDataSum_$cgunfold_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZPf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZPg; else goto cfZPh;
       cfZPg: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgunfold_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cfZPh: // global
           I64[Sp - 8] = block_cfZPc_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZPl; else goto cfZPd;
       ufZPl: // global
           call _cfZPc(R1) args: 0, res: 0, upd: 0;
       cfZPd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZPc() //  [R1]
         { info_tbl: [(cfZPc,
                       label: block_cfZPc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZPc: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 39];
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgunfold_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.419430846 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgfoldl_closure" {
     Data.Functor.Sum.$fDataSum_$cgfoldl_closure:
         const Data.Functor.Sum.$fDataSum_$cgfoldl_info;
 },
 Data.Functor.Sum.$fDataSum_$cgfoldl_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZPn: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgfoldl_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_sfY08_entry() //  [R1]
         { info_tbl: [(cfZPA,
                       label: sat_sfY08_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZPA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZPB; else goto cfZPC;
       cfZPB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZPC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InL_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfY0a_entry() //  [R1]
         { info_tbl: [(cfZPJ,
                       label: sat_sfY0a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZPJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZPK; else goto cfZPL;
       cfZPK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZPL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InR_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgfoldl_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cfZPQ,
                       label: Data.Functor.Sum.$fDataSum_$cgfoldl_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZPQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZPR; else goto cfZPS;
       cfZPR: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgfoldl_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cfZPS: // global
           I64[Sp - 8] = block_cfZPr_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZPZ; else goto cfZPs;
       ufZPZ: // global
           call _cfZPr(R1) args: 0, res: 0, upd: 0;
       cfZPs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZPr() //  [R1]
         { info_tbl: [(cfZPr,
                       label: block_cfZPr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZPr: // global
           _sfY03::P64 = P64[Sp + 16];
           _sfY04::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cfZPN; else goto cfZPO;
       cfZPN: // global
           Hp = Hp + 24;
           _sfY06::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZPY; else goto cfZPU;
       cfZPU: // global
           _sfY07::P64 = P64[_sfY06::P64 + 7];
           I64[Hp - 16] = sat_sfY08_info;
           P64[Hp] = _sfY04::P64;
           R4 = _sfY07::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 32];
           R1 = _sfY03::P64;
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZPO: // global
           Hp = Hp + 24;
           _sfY06::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZPY; else goto cfZPX;
       cfZPY: // global
           HpAlloc = 24;
           R1 = _sfY06::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZPX: // global
           _sfY09::P64 = P64[_sfY06::P64 + 6];
           I64[Hp - 16] = sat_sfY0a_info;
           P64[Hp] = _sfY04::P64;
           R4 = _sfY09::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 8];
           R1 = _sfY03::P64;
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.421684318 UTC

[section ""cstring" . Data.Functor.Sum.$fDataSum8_bytes" {
     Data.Functor.Sum.$fDataSum8_bytes:
         I8[] [83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.422429559 UTC

[section ""data" . $tSum1_rfXP5_closure" {
     $tSum1_rfXP5_closure:
         const $tSum1_rfXP5_info;
         const 0;
         const 0;
         const 0;
 },
 $tSum1_rfXP5_entry() //  [R1]
         { info_tbl: [(cfZQ6,
                       label: $tSum1_rfXP5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZQ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZQ7; else goto cfZQ8;
       cfZQ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZQ8: // global
           (_cfZQ3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfZQ3::I64 == 0) goto cfZQ5; else goto cfZQ4;
       cfZQ5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfZQ4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfZQ3::I64;
           R2 = Data.Functor.Sum.$fDataSum8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.424110459 UTC

[section ""data" . go61_rfXP6_closure" {
     go61_rfXP6_closure:
         const go61_rfXP6_info;
         const 0;
 },
 go61_rfXP6_entry() //  [R2, R3]
         { info_tbl: [(cfZQk,
                       label: go61_rfXP6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZQk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZQl; else goto ufZQY;
       cfZQl: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rfXP6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ufZQY: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cfZQa() args: 0, res: 0, upd: 0;
     }
 },
 _cfZQa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZQa: // global
           _sfY0b::P64 = P64[Sp];
           I64[Sp] = block_cfZQd_info;
           R1 = _sfY0b::P64;
           if (R1 & 7 != 0) goto ufZR2; else goto cfZQe;
       ufZR2: // global
           call _cfZQd(R1) args: 0, res: 0, upd: 0;
       cfZQe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZQd() //  [R1]
         { info_tbl: [(cfZQd,
                       label: block_cfZQd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZQd: // global
           if (R1 & 7 == 1) goto ufZQZ; else goto cfZQi;
       ufZQZ: // global
           Sp = Sp + 16;
           call _cfZQA() args: 0, res: 0, upd: 0;
       cfZQi: // global
           I64[Sp - 8] = block_cfZQs_info;
           _sfY0e::P64 = P64[R1 + 6];
           _sfY0f::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sfY0f::P64;
           P64[Sp + 8] = _sfY0e::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZR3; else goto cfZQu;
       ufZR3: // global
           call _cfZQs(R1) args: 0, res: 0, upd: 0;
       cfZQu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZQs() //  [R1]
         { info_tbl: [(cfZQs,
                       label: block_cfZQs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZQs: // global
           if (R1 & 7 == 1) goto ufZR0; else goto cfZQF;
       ufZR0: // global
           Sp = Sp + 24;
           call _cfZQA() args: 0, res: 0, upd: 0;
       cfZQF: // global
           I64[Sp - 8] = block_cfZQD_info;
           _sfY0h::P64 = P64[R1 + 6];
           _sfY0i::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sfY0i::P64;
           P64[Sp + 16] = _sfY0h::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZR6; else goto cfZQG;
       ufZR6: // global
           call _cfZQD(R1) args: 0, res: 0, upd: 0;
       cfZQG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZQA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZQA: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfZQD() //  [R1]
         { info_tbl: [(cfZQD,
                       label: block_cfZQD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZQD: // global
           I64[Sp] = block_cfZQK_info;
           R3 = Data.Functor.Sum.$fRead1Sum7_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZQK() //  [R1]
         { info_tbl: [(cfZQK,
                       label: block_cfZQK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZQK: // global
           if (R1 & 7 == 1) goto cfZQR; else goto cfZQV;
       cfZQR: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cfZQa() args: 0, res: 0, upd: 0;
       cfZQV: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.426884677 UTC

[section ""data" . go1_rfXP7_closure" {
     go1_rfXP7_closure:
         const go1_rfXP7_info;
         const 0;
 },
 section ""relreadonly" . ufZS9_srtd" {
     ufZS9_srtd:
         const SfYa7_srt+88;
         const 51;
         const 1266637395197953;
 },
 go1_rfXP7_entry() //  [R2, R3]
         { info_tbl: [(cfZRk,
                       label: go1_rfXP7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZRk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZRl; else goto ufZRY;
       cfZRl: // global
           R3 = R3;
           R2 = R2;
           R1 = go1_rfXP7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ufZRY: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cfZRa() args: 0, res: 0, upd: 0;
     }
 },
 _cfZRa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZRa: // global
           _sfY0q::P64 = P64[Sp];
           I64[Sp] = block_cfZRd_info;
           R1 = _sfY0q::P64;
           if (R1 & 7 != 0) goto ufZS2; else goto cfZRe;
       ufZS2: // global
           call _cfZRd(R1) args: 0, res: 0, upd: 0;
       cfZRe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ufZSa_srtd" {
     ufZSa_srtd:
         const SfYa7_srt+88;
         const 48;
         const 140737488355329;
 },
 _cfZRd() //  [R1]
         { info_tbl: [(cfZRd,
                       label: block_cfZRd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZRd: // global
           if (R1 & 7 == 1) goto ufZRZ; else goto cfZRi;
       ufZRZ: // global
           Sp = Sp + 16;
           call _cfZRA() args: 0, res: 0, upd: 0;
       cfZRi: // global
           I64[Sp - 8] = block_cfZRs_info;
           _sfY0t::P64 = P64[R1 + 6];
           _sfY0u::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sfY0u::P64;
           P64[Sp + 8] = _sfY0t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZS3; else goto cfZRu;
       ufZS3: // global
           call _cfZRs(R1) args: 0, res: 0, upd: 0;
       cfZRu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ufZSb_srtd" {
     ufZSb_srtd:
         const SfYa7_srt+88;
         const 48;
         const 140737488355329;
 },
 _cfZRs() //  [R1]
         { info_tbl: [(cfZRs,
                       label: block_cfZRs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZRs: // global
           if (R1 & 7 == 1) goto ufZS0; else goto cfZRF;
       ufZS0: // global
           Sp = Sp + 24;
           call _cfZRA() args: 0, res: 0, upd: 0;
       cfZRF: // global
           I64[Sp - 8] = block_cfZRD_info;
           _sfY0w::P64 = P64[R1 + 6];
           _sfY0x::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sfY0x::P64;
           P64[Sp + 16] = _sfY0w::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZS6; else goto cfZRG;
       ufZS6: // global
           call _cfZRD(R1) args: 0, res: 0, upd: 0;
       cfZRG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZRA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZRA: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ufZSc_srtd" {
     ufZSc_srtd:
         const SfYa7_srt+88;
         const 48;
         const 140737488355329;
 },
 _cfZRD() //  [R1]
         { info_tbl: [(cfZRD,
                       label: block_cfZRD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZRD: // global
           I64[Sp] = block_cfZRK_info;
           R3 = Data.Functor.Sum.$fRead1Sum3_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ufZSd_srtd" {
     ufZSd_srtd:
         const SfYa7_srt+88;
         const 48;
         const 140737488355329;
 },
 _cfZRK() //  [R1]
         { info_tbl: [(cfZRK,
                       label: block_cfZRK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZRK: // global
           if (R1 & 7 == 1) goto cfZRR; else goto cfZRV;
       cfZRR: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cfZRa() args: 0, res: 0, upd: 0;
       cfZRV: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.429493968 UTC

[section ""data" . $cInL1_rfXP8_closure" {
     $cInL1_rfXP8_closure:
         const Data.Data.AlgConstr_con_info;
         const $cInL2_rfXPe_closure;
         const 0;
 },
 section ""data" . $cInR1_rfXP9_closure" {
     $cInR1_rfXP9_closure:
         const Data.Data.AlgConstr_con_info;
         const $cInR2_rfXPd_closure;
         const 0;
 },
 section ""data" . Data.Functor.Sum.$cInL_closure" {
     Data.Functor.Sum.$cInL_closure:
         const Data.Data.Constr_con_info;
         const $cInL1_rfXP8_closure+1;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Sum.$tSum_closure+1;
         const 0;
 },
 section ""data" . $tSum2_rfXPa_closure" {
     $tSum2_rfXPa_closure:
         const :_con_info;
         const Data.Functor.Sum.$cInR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . $tSum3_rfXPb_closure" {
     $tSum3_rfXPb_closure:
         const :_con_info;
         const Data.Functor.Sum.$cInL_closure+1;
         const $tSum2_rfXPa_closure+2;
         const 0;
 },
 section ""data" . $tSum4_rfXPc_closure" {
     $tSum4_rfXPc_closure:
         const Data.Data.AlgRep_con_info;
         const $tSum3_rfXPb_closure+2;
         const 0;
 },
 section ""data" . Data.Functor.Sum.$tSum_closure" {
     Data.Functor.Sum.$tSum_closure:
         const Data.Data.DataType_con_info;
         const $tSum1_rfXP5_closure;
         const $tSum4_rfXPc_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Sum.$cInR_closure" {
     Data.Functor.Sum.$cInR_closure:
         const Data.Data.Constr_con_info;
         const $cInR1_rfXP9_closure+1;
         const Data.Functor.Sum.$fRead1Sum3_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Sum.$tSum_closure+1;
         const 0;
 },
 section ""data" . $cInR2_rfXPd_closure" {
     $cInR2_rfXPd_closure:
         const $cInR2_rfXPd_info;
         const 0;
         const 0;
         const 0;
 },
 $cInR2_rfXPd_entry() //  [R1]
         { info_tbl: [(cfZSk,
                       label: $cInR2_rfXPd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZSk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZSl; else goto cfZSm;
       cfZSl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZSm: // global
           (_cfZSh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfZSh::I64 == 0) goto cfZSj; else goto cfZSi;
       cfZSj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfZSi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfZSh::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = $tSum3_rfXPb_closure+2;
           Sp = Sp - 16;
           call go1_rfXP7_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""data" . $cInL2_rfXPe_closure" {
     $cInL2_rfXPe_closure:
         const $cInL2_rfXPe_info;
         const 0;
         const 0;
         const 0;
 },
 $cInL2_rfXPe_entry() //  [R1]
         { info_tbl: [(cfZSt,
                       label: $cInL2_rfXPe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZSt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZSu; else goto cfZSv;
       cfZSu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZSv: // global
           (_cfZSq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfZSq::I64 == 0) goto cfZSs; else goto cfZSr;
       cfZSs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfZSr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfZSq::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = $tSum3_rfXPb_closure+2;
           Sp = Sp - 16;
           call go61_rfXP6_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.431210928 UTC

[section ""cstring" . Data.Functor.Sum.$trModule4_bytes" {
     Data.Functor.Sum.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.431770787 UTC

[section ""data" . Data.Functor.Sum.$trModule3_closure" {
     Data.Functor.Sum.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.432334293 UTC

[section ""cstring" . Data.Functor.Sum.$trModule2_bytes" {
     Data.Functor.Sum.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.432910531 UTC

[section ""data" . Data.Functor.Sum.$trModule1_closure" {
     Data.Functor.Sum.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.433704909 UTC

[section ""data" . Data.Functor.Sum.$trModule_closure" {
     Data.Functor.Sum.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Sum.$trModule3_closure+1;
         const Data.Functor.Sum.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.43429856 UTC

[section ""data" . $krep_rfXPf_closure" {
     $krep_rfXPf_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.434852927 UTC

[section ""data" . $krep1_rfXPg_closure" {
     $krep1_rfXPg_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rfXPf_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.435459043 UTC

[section ""data" . $krep2_rfXPh_closure" {
     $krep2_rfXPh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rfXPg_closure+4;
         const $krep1_rfXPg_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.436046099 UTC

[section ""data" . Data.Functor.Sum.$fDataSum6_closure" {
     Data.Functor.Sum.$fDataSum6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rfXPg_closure+4;
         const $krep2_rfXPh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.436631311 UTC

[section ""data" . $krep3_rfXPi_closure" {
     $krep3_rfXPi_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.439913068 UTC

[section ""data" . $krep4_rfXPj_closure" {
     $krep4_rfXPj_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.440518092 UTC

[section ""data" . $krep5_rfXPk_closure" {
     $krep5_rfXPk_closure:
         const GHC.Types.KindRepVar_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.44108443 UTC

[section ""data" . $krep6_rfXPl_closure" {
     $krep6_rfXPl_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rfXPj_closure+2;
         const $krep5_rfXPk_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.441696082 UTC

[section ""data" . $krep7_rfXPm_closure" {
     $krep7_rfXPm_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep3_rfXPi_closure+2;
         const $krep5_rfXPk_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.442275047 UTC

[section ""data" . Data.Functor.Sum.$fDataSum7_closure" {
     Data.Functor.Sum.$fDataSum7_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$fDataSum8_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.442860844 UTC

[section ""data" . Data.Functor.Sum.$tcSum_closure" {
     Data.Functor.Sum.$tcSum_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Sum.$trModule_closure+1;
         const Data.Functor.Sum.$fDataSum7_closure+1;
         const Data.Functor.Sum.$fDataSum6_closure+4;
         const 6345190594862254730;
         const 1236278515871186010;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.443447369 UTC

[section ""data" . $krep8_rfXPn_closure" {
     $krep8_rfXPn_closure:
         const :_con_info;
         const $krep5_rfXPk_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.444015557 UTC

[section ""data" . $krep9_rfXPo_closure" {
     $krep9_rfXPo_closure:
         const :_con_info;
         const $krep3_rfXPi_closure+2;
         const $krep8_rfXPn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.444596561 UTC

[section ""data" . $krep10_rfXPp_closure" {
     $krep10_rfXPp_closure:
         const :_con_info;
         const $krep4_rfXPj_closure+2;
         const $krep9_rfXPo_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.445169169 UTC

[section ""data" . $krep11_rfXPq_closure" {
     $krep11_rfXPq_closure:
         const :_con_info;
         const $krep_rfXPf_closure+2;
         const $krep10_rfXPp_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.445815806 UTC

[section ""data" . $krep12_rfXPr_closure" {
     $krep12_rfXPr_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Sum.$tcSum_closure+1;
         const $krep11_rfXPq_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.446523603 UTC

[section ""data" . Data.Functor.Sum.$tc'InL1_closure" {
     Data.Functor.Sum.$tc'InL1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rfXPl_closure+3;
         const $krep12_rfXPr_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.447192434 UTC

[section ""cstring" . Data.Functor.Sum.$tc'InL3_bytes" {
     Data.Functor.Sum.$tc'InL3_bytes:
         I8[] [39,73,110,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.447787423 UTC

[section ""data" . Data.Functor.Sum.$tc'InL2_closure" {
     Data.Functor.Sum.$tc'InL2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$tc'InL3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.448378386 UTC

[section ""data" . Data.Functor.Sum.$tc'InL_closure" {
     Data.Functor.Sum.$tc'InL_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Sum.$trModule_closure+1;
         const Data.Functor.Sum.$tc'InL2_closure+1;
         const Data.Functor.Sum.$tc'InL1_closure+4;
         const 7951421854502432011;
         const 12303552236073891860;
         const 4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.448996818 UTC

[section ""data" . Data.Functor.Sum.$tc'InR1_closure" {
     Data.Functor.Sum.$tc'InR1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rfXPm_closure+3;
         const $krep12_rfXPr_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.449818447 UTC

[section ""cstring" . Data.Functor.Sum.$tc'InR3_bytes" {
     Data.Functor.Sum.$tc'InR3_bytes:
         I8[] [39,73,110,82]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.450341535 UTC

[section ""data" . Data.Functor.Sum.$tc'InR2_closure" {
     Data.Functor.Sum.$tc'InR2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$tc'InR3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.450937318 UTC

[section ""data" . Data.Functor.Sum.$tc'InR_closure" {
     Data.Functor.Sum.$tc'InR_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Sum.$trModule_closure+1;
         const Data.Functor.Sum.$tc'InR2_closure+1;
         const Data.Functor.Sum.$tc'InR1_closure+4;
         const 12078304815884238110;
         const 12377490770432979855;
         const 4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.452290432 UTC

[section ""data" . Data.Functor.Sum.$w$cp1Data_closure" {
     Data.Functor.Sum.$w$cp1Data_closure:
         const Data.Functor.Sum.$w$cp1Data_info;
         const 0;
 },
 Data.Functor.Sum.$w$cp1Data_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfZSJ,
                       label: Data.Functor.Sum.$w$cp1Data_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZSJ: // global
           _sfY0I::P64 = R5;
           _sfY0H::P64 = R4;
           _sfY0G::P64 = R3;
           _sfY0F::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cfZSN; else goto cfZSO;
       cfZSO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfZSQ; else goto cfZSP;
       cfZSQ: // global
           HpAlloc = 40;
           goto cfZSN;
       cfZSN: // global
           R5 = _sfY0I::P64;
           R4 = _sfY0H::P64;
           R3 = _sfY0G::P64;
           R2 = _sfY0F::P64;
           R1 = Data.Functor.Sum.$w$cp1Data_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZSP: // global
           I64[Hp - 32] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 24] = _sfY0I::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 32] = block_cfZSC_info;
           R6 = 1;
           R5 = Data.Functor.Sum.$fDataSum7_closure+1;
           R4 = Data.Functor.Sum.$trModule_closure+1;
           R3 = 1236278515871186010;
           R2 = 6345190594862254730;
           P64[Sp - 48] = Data.Functor.Sum.$fDataSum6_closure+4;
           P64[Sp - 40] = Hp - 14;
           P64[Sp - 24] = _sfY0F::P64;
           P64[Sp - 16] = _sfY0G::P64;
           P64[Sp - 8] = _sfY0H::P64;
           Sp = Sp - 48;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 8;
     }
 },
 _cfZSC() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfZSC,
                       label: block_cfZSC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZSC: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cfZSD() args: 0, res: 0, upd: 0;
     }
 },
 _cfZSD() //  []
         { info_tbl: [(cfZSD,
                       label: block_cfZSD_info
                       rep:StackRep [True, False, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZSD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfZST; else goto cfZSS;
       cfZST: // global
           HpAlloc = 48;
           I64[Sp] = block_cfZSD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfZSS: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 40] = block_cfZSH_info;
           R3 = P64[Sp + 56];
           R2 = Hp - 38;
           Sp = Sp + 40;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZSH() //  [R1]
         { info_tbl: [(cfZSH,
                       label: block_cfZSH_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZSH: // global
           I64[Sp] = block_cfZSM_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZSM() //  [R1]
         { info_tbl: [(cfZSM,
                       label: block_cfZSM_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZSM: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.45442843 UTC

[section ""data" . Data.Functor.Sum.$fDataSum5_closure" {
     Data.Functor.Sum.$fDataSum5_closure:
         const Data.Functor.Sum.$fDataSum5_info;
         const 0;
 },
 Data.Functor.Sum.$fDataSum5_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfZT5,
                       label: Data.Functor.Sum.$fDataSum5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZT5: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Sum.$w$cp1Data_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.45520508 UTC

[section ""data" . Data.Functor.Sum.$fDataSum2_closure" {
     Data.Functor.Sum.$fDataSum2_closure:
         const (,)_con_info;
         const Data.Functor.Sum.InL_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.455815119 UTC

[section ""data" . Data.Functor.Sum.$fDataSum1_closure" {
     Data.Functor.Sum.$fDataSum1_closure:
         const (,)_con_info;
         const Data.Functor.Sum.InR_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.459175184 UTC

[section ""data" . Data.Functor.Sum.$w$cgmapMp_closure" {
     Data.Functor.Sum.$w$cgmapMp_closure:
         const Data.Functor.Sum.$w$cgmapMp_info;
 },
 lvl8_sfY15_entry() //  [R1]
         { info_tbl: [(cfZTg,
                       label: lvl8_sfY15_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZTg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZTh; else goto cfZTi;
       cfZTh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZTi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfY1A_entry() //  [R1, R2]
         { info_tbl: [(cfZTv,
                       label: sat_sfY1A_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZTv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZTw; else goto cfZTx;
       cfZTw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZTx: // global
           I64[Sp - 24] = block_cfZTs_info;
           _sfY15::P64 = P64[R1 + 7];
           _sfY16::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfY15::P64;
           P64[Sp - 8] = _sfY16::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufZTP; else goto cfZTt;
       ufZTP: // global
           call _cfZTs(R1) args: 0, res: 0, upd: 0;
       cfZTt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZTs() //  [R1]
         { info_tbl: [(cfZTs,
                       label: block_cfZTs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZTs: // global
           I64[Sp - 8] = block_cfZTA_info;
           _sfY1x::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfY1x::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZTO; else goto cfZTC;
       ufZTO: // global
           call _cfZTA(R1) args: 0, res: 0, upd: 0;
       cfZTC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZTA() //  [R1]
         { info_tbl: [(cfZTA,
                       label: block_cfZTA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZTA: // global
           if (R1 & 7 == 1) goto cfZTI; else goto cfZTM;
       cfZTI: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfZTM: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY1n_entry() //  [R1]
         { info_tbl: [(cfZUg,
                       label: sat_sfY1n_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZUg: // global
           _sfY1n::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cfZUh; else goto cfZUi;
       cfZUi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZUk; else goto cfZUj;
       cfZUk: // global
           HpAlloc = 56;
           goto cfZUh;
       cfZUh: // global
           R1 = _sfY1n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZUj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY1n::P64;
           _sfY16::P64 = P64[_sfY1n::P64 + 16];
           _sfY1a::P64 = P64[_sfY1n::P64 + 24];
           _sfY1e::P64 = P64[_sfY1n::P64 + 32];
           _sfY1f::P64 = P64[_sfY1n::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY1e::P64;
           P64[Hp - 24] = _sfY1a::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sfY1f::P64;
           R2 = _sfY16::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY1j_entry() //  [R1, R2]
         { info_tbl: [(cfZUw,
                       label: sat_sfY1j_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZUw: // global
           _sfY1g::P64 = R2;
           _sfY1j::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfZUx; else goto cfZUy;
       cfZUy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfZUA; else goto cfZUz;
       cfZUA: // global
           HpAlloc = 56;
           goto cfZUx;
       cfZUx: // global
           R2 = _sfY1g::P64;
           R1 = _sfY1j::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZUz: // global
           _sfY16::P64 = P64[_sfY1j::P64 + 7];
           _sfY1e::P64 = P64[_sfY1j::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY1e::P64;
           P64[Hp - 24] = _sfY1g::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sfY16::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY1k_entry() //  [R1]
         { info_tbl: [(cfZUB,
                       label: sat_sfY1k_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZUB: // global
           _sfY1k::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cfZUC; else goto cfZUD;
       cfZUD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZUF; else goto cfZUE;
       cfZUF: // global
           HpAlloc = 24;
           goto cfZUC;
       cfZUC: // global
           R1 = _sfY1k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZUE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY1k::P64;
           _sfY16::P64 = P64[_sfY1k::P64 + 16];
           _sfY1b::P64 = P64[_sfY1k::P64 + 24];
           _sfY1e::P64 = P64[_sfY1k::P64 + 32];
           I64[Hp - 16] = sat_sfY1j_info;
           P64[Hp - 8] = _sfY16::P64;
           P64[Hp] = _sfY1e::P64;
           R2 = _sfY16::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sfY1b::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sfY1o_entry() //  [R1, R2]
         { info_tbl: [(cfZUG,
                       label: sat_sfY1o_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZUG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfZUH; else goto cfZUI;
       cfZUH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZUI: // global
           I64[Sp - 40] = block_cfZU5_info;
           _sfY12::P64 = P64[R1 + 7];
           _sfY16::P64 = P64[R1 + 15];
           _sfY1a::P64 = P64[R1 + 23];
           _sfY1b::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sfY12::P64;
           P64[Sp - 24] = _sfY16::P64;
           P64[Sp - 16] = _sfY1a::P64;
           P64[Sp - 8] = _sfY1b::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZUM; else goto cfZU6;
       ufZUM: // global
           call _cfZU5(R1) args: 0, res: 0, upd: 0;
       cfZU6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZU5() //  [R1]
         { info_tbl: [(cfZU5,
                       label: block_cfZU5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZU5: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfZUL; else goto cfZUK;
       cfZUL: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZUK: // global
           _sfY1e::P64 = P64[R1 + 7];
           _sfY1f::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sfY1n_info;
           _sfY16::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sfY16::P64;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _sfY1e::P64;
           P64[Hp - 40] = _sfY1f::P64;
           I64[Hp - 32] = sat_sfY1k_info;
           P64[Hp - 16] = _sfY16::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sfY1e::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sfY17_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZUN,
                       label: k1_sfY17_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZUN: // global
           _sfY1a::P64 = R4;
           _sfY19::P64 = R3;
           _sfY18::P64 = R2;
           _sfY17::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cfZUO; else goto cfZUP;
       cfZUP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cfZUR; else goto cfZUQ;
       cfZUR: // global
           HpAlloc = 80;
           goto cfZUO;
       cfZUO: // global
           R4 = _sfY1a::P64;
           R3 = _sfY19::P64;
           R2 = _sfY18::P64;
           R1 = _sfY17::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZUQ: // global
           _sfY12::P64 = P64[_sfY17::P64 + 5];
           _sfY13::P64 = P64[_sfY17::P64 + 13];
           _sfY16::P64 = P64[_sfY17::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sfY13::P64;
           P64[Hp - 48] = _sfY18::P64;
           P64[Hp - 40] = _sfY1a::P64;
           I64[Hp - 32] = sat_sfY1o_info;
           P64[Hp - 24] = _sfY12::P64;
           P64[Hp - 16] = _sfY16::P64;
           P64[Hp - 8] = _sfY1a::P64;
           P64[Hp] = Hp - 72;
           R2 = _sfY16::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sfY19::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY1r_entry() //  [R1]
         { info_tbl: [(cfZV1,
                       label: sat_sfY1r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZV1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZV2; else goto cfZV3;
       cfZV2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZV3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY1t_entry() //  [R1]
         { info_tbl: [(cfZVa,
                       label: sat_sfY1t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZVa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZVb; else goto cfZVc;
       cfZVb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZVc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY1u_entry() //  [R1]
         { info_tbl: [(cfZVh,
                       label: sat_sfY1u_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZVh: // global
           _sfY1u::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cfZVi; else goto cfZVj;
       cfZVj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfZVl; else goto cfZVk;
       cfZVl: // global
           HpAlloc = 32;
           goto cfZVi;
       cfZVi: // global
           R1 = _sfY1u::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZVk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY1u::P64;
           _sfY10::P64 = P64[_sfY1u::P64 + 16];
           _sfY11::P64 = P64[_sfY1u::P64 + 24];
           _sfY12::P64 = P64[_sfY1u::P64 + 32];
           _sfY13::P64 = P64[_sfY1u::P64 + 40];
           _sfY14::P64 = P64[_sfY1u::P64 + 48];
           _sfY16::P64 = P64[_sfY1u::P64 + 56];
           I64[Hp - 24] = k1_sfY17_info;
           P64[Hp - 16] = _sfY12::P64;
           P64[Hp - 8] = _sfY13::P64;
           P64[Hp] = _sfY16::P64;
           I64[Sp - 56] = block_cfZUS_info;
           R1 = _sfY14::P64;
           P64[Sp - 48] = Hp - 21;
           P64[Sp - 40] = _sfY10::P64;
           P64[Sp - 32] = _sfY11::P64;
           P64[Sp - 24] = _sfY16::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ufZVs; else goto cfZUT;
       ufZVs: // global
           call _cfZUS(R1) args: 0, res: 0, upd: 0;
       cfZUT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cfZUS() //  [R1]
         { info_tbl: [(cfZUS,
                       label: block_cfZUS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZUS: // global
           _cfZTU::P64 = P64[Sp + 8];
           _sfY16::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZVe; else goto cfZVf;
       cfZVe: // global
           Hp = Hp + 24;
           _sfY1p::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZVr; else goto cfZVn;
       cfZVn: // global
           _sfY1q::P64 = P64[_sfY1p::P64 + 7];
           I64[Hp - 16] = sat_sfY1r_info;
           P64[Hp] = _sfY16::P64;
           R4 = _sfY1q::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _cfZTU::P64;
           Sp = Sp + 40;
           call k1_sfY17_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
       cfZVf: // global
           Hp = Hp + 24;
           _sfY1p::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZVr; else goto cfZVq;
       cfZVr: // global
           HpAlloc = 24;
           R1 = _sfY1p::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cfZVq: // global
           _sfY1s::P64 = P64[_sfY1p::P64 + 6];
           I64[Hp - 16] = sat_sfY1t_info;
           P64[Hp] = _sfY16::P64;
           R4 = _sfY1s::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 24];
           R1 = _cfZTU::P64;
           Sp = Sp + 40;
           call k1_sfY17_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgmapMp_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZVt,
                       label: Data.Functor.Sum.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZVt: // global
           _sfY14::P64 = R6;
           _sfY13::P64 = R5;
           _sfY12::P64 = R4;
           _sfY11::P64 = R3;
           _sfY10::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cfZVu; else goto cfZVv;
       cfZVv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZVx; else goto cfZVw;
       cfZVx: // global
           HpAlloc = 24;
           goto cfZVu;
       cfZVu: // global
           R6 = _sfY14::P64;
           R5 = _sfY13::P64;
           R4 = _sfY12::P64;
           R3 = _sfY11::P64;
           R2 = _sfY10::P64;
           R1 = Data.Functor.Sum.$w$cgmapMp_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZVw: // global
           I64[Hp - 16] = lvl8_sfY15_info;
           P64[Hp] = _sfY12::P64;
           I64[Sp - 56] = block_cfZTj_info;
           R2 = _sfY12::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sfY10::P64;
           P64[Sp - 32] = _sfY11::P64;
           P64[Sp - 24] = _sfY12::P64;
           P64[Sp - 16] = _sfY13::P64;
           P64[Sp - 8] = _sfY14::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZTj() //  [R1]
         { info_tbl: [(cfZTj,
                       label: block_cfZTj_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZTj: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cfZVA; else goto cfZVz;
       cfZVA: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZVz: // global
           I64[Hp - 80] = sat_sfY1A_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sfY1u_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.465834257 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapMp_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapMp_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapMp_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapMp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZVC: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapMp_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapMp_entry() //  [R6]
         { info_tbl: [(cfZVG,
                       label: Data.Functor.Sum.$fDataSum_$cgmapMp_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZVG: // global
           _sfY1F::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sfY1F::P64;
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgmapMp_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.468239271 UTC

[section ""data" . Data.Functor.Sum.$w$cgmapM_closure" {
     Data.Functor.Sum.$w$cgmapM_closure:
         const Data.Functor.Sum.$w$cgmapM_info;
 },
 sat_sfY1X_entry() //  [R1, R2]
         { info_tbl: [(cfZW4,
                       label: sat_sfY1X_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZW4: // global
           _sfY1V::P64 = R2;
           _sfY1X::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cfZW5; else goto cfZW6;
       cfZW6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfZW8; else goto cfZW7;
       cfZW8: // global
           HpAlloc = 32;
           goto cfZW5;
       cfZW5: // global
           R2 = _sfY1V::P64;
           R1 = _sfY1X::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZW7: // global
           _sfY1M::P64 = P64[_sfY1X::P64 + 7];
           _sfY1U::P64 = P64[_sfY1X::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sfY1U::P64;
           P64[Hp] = _sfY1V::P64;
           R2 = _sfY1M::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY1Y_entry() //  [R1, R2]
         { info_tbl: [(cfZW9,
                       label: sat_sfY1Y_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZW9: // global
           _sfY1U::P64 = R2;
           _sfY1Y::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cfZWa; else goto cfZWb;
       cfZWb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZWd; else goto cfZWc;
       cfZWd: // global
           HpAlloc = 24;
           goto cfZWa;
       cfZWa: // global
           R2 = _sfY1U::P64;
           R1 = _sfY1Y::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfZWc: // global
           _sfY1M::P64 = P64[_sfY1Y::P64 + 7];
           _sfY1T::P64 = P64[_sfY1Y::P64 + 15];
           I64[Hp - 16] = sat_sfY1X_info;
           P64[Hp - 8] = _sfY1M::P64;
           P64[Hp] = _sfY1U::P64;
           R2 = _sfY1M::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sfY1T::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sfY1P_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfZWe,
                       label: k1_sfY1P_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZWe: // global
           _sfY1S::P64 = R4;
           _sfY1R::P64 = R3;
           _sfY1Q::P64 = R2;
           _sfY1P::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cfZWf; else goto cfZWg;
       cfZWg: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfZWi; else goto cfZWh;
       cfZWi: // global
           HpAlloc = 64;
           goto cfZWf;
       cfZWf: // global
           R4 = _sfY1S::P64;
           R3 = _sfY1R::P64;
           R2 = _sfY1Q::P64;
           R1 = _sfY1P::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZWh: // global
           _sfY1M::P64 = P64[_sfY1P::P64 + 5];
           _sfY1N::P64 = P64[_sfY1P::P64 + 13];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sfY1N::P64;
           P64[Hp - 32] = _sfY1Q::P64;
           P64[Hp - 24] = _sfY1S::P64;
           I64[Hp - 16] = sat_sfY1Y_info;
           P64[Hp - 8] = _sfY1M::P64;
           P64[Hp] = Hp - 56;
           R2 = _sfY1M::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sfY1R::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY21_entry() //  [R1]
         { info_tbl: [(cfZWs,
                       label: sat_sfY21_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZWs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZWt; else goto cfZWu;
       cfZWt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZWu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.InL_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY23_entry() //  [R1]
         { info_tbl: [(cfZWB,
                       label: sat_sfY23_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZWB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfZWC; else goto cfZWD;
       cfZWC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZWD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.InR_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgmapM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZWI,
                       label: Data.Functor.Sum.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZWI: // global
           _sfY1O::P64 = R6;
           _sfY1N::P64 = R5;
           _sfY1M::P64 = R4;
           _sfY1L::P64 = R3;
           _sfY1K::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cfZWJ; else goto cfZWK;
       cfZWK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfZWM; else goto cfZWL;
       cfZWM: // global
           HpAlloc = 24;
           goto cfZWJ;
       cfZWJ: // global
           R6 = _sfY1O::P64;
           R5 = _sfY1N::P64;
           R4 = _sfY1M::P64;
           R3 = _sfY1L::P64;
           R2 = _sfY1K::P64;
           R1 = Data.Functor.Sum.$w$cgmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZWL: // global
           I64[Hp - 16] = k1_sfY1P_info;
           P64[Hp - 8] = _sfY1M::P64;
           P64[Hp] = _sfY1N::P64;
           I64[Sp - 40] = block_cfZWj_info;
           R1 = _sfY1O::P64;
           P64[Sp - 32] = Hp - 13;
           P64[Sp - 24] = _sfY1K::P64;
           P64[Sp - 16] = _sfY1L::P64;
           P64[Sp - 8] = _sfY1M::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufZWT; else goto cfZWk;
       ufZWT: // global
           call _cfZWj(R1) args: 0, res: 0, upd: 0;
       cfZWk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZWj() //  [R1]
         { info_tbl: [(cfZWj,
                       label: block_cfZWj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZWj: // global
           _cfZVN::P64 = P64[Sp + 8];
           _sfY1M::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZWF; else goto cfZWG;
       cfZWF: // global
           Hp = Hp + 24;
           _sfY1Z::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZWS; else goto cfZWO;
       cfZWO: // global
           _sfY20::P64 = P64[_sfY1Z::P64 + 7];
           I64[Hp - 16] = sat_sfY21_info;
           P64[Hp] = _sfY1M::P64;
           R4 = _sfY20::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _cfZVN::P64;
           Sp = Sp + 40;
           call k1_sfY1P_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZWG: // global
           Hp = Hp + 24;
           _sfY1Z::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZWS; else goto cfZWR;
       cfZWS: // global
           HpAlloc = 24;
           R1 = _sfY1Z::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZWR: // global
           _sfY22::P64 = P64[_sfY1Z::P64 + 6];
           I64[Hp - 16] = sat_sfY23_info;
           P64[Hp] = _sfY1M::P64;
           R4 = _sfY22::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 24];
           R1 = _cfZVN::P64;
           Sp = Sp + 40;
           call k1_sfY1P_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.471734541 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapM_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapM_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapM_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapM_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZWV: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapM_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapM_entry() //  [R6]
         { info_tbl: [(cfZWZ,
                       label: Data.Functor.Sum.$fDataSum_$cgmapM_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZWZ: // global
           _sfY28::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sfY28::P64;
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgmapM_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.474189109 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapQi_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapQi_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapQi_info;
         const 0;
 },
 Data.Functor.Sum.$fDataSum_$cgmapQi_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZX3: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQi_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapQi_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cfZXe,
                       label: Data.Functor.Sum.$fDataSum_$cgmapQi_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZXe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZXf; else goto cfZXg;
       cfZXf: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgmapQi_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cfZXg: // global
           I64[Sp - 8] = block_cfZX7_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZXL; else goto cfZX8;
       ufZXL: // global
           call _cfZX7(R1) args: 0, res: 0, upd: 0;
       cfZX8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZX7() //  [R1]
         { info_tbl: [(cfZX7,
                       label: block_cfZX7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZX7: // global
           _sfY2j::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfZXb; else goto cfZXc;
       cfZXb: // global
           I64[Sp + 8] = block_cfZXj_info;
           _sfY2n::P64 = P64[R1 + 7];
           R1 = _sfY2j::P64;
           P64[Sp + 16] = _sfY2n::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufZXJ; else goto cfZXl;
       ufZXJ: // global
           call _cfZXj(R1) args: 0, res: 0, upd: 0;
       cfZXl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfZXc: // global
           I64[Sp] = block_cfZXw_info;
           _sfY2r::P64 = P64[R1 + 6];
           R1 = _sfY2j::P64;
           P64[Sp + 32] = _sfY2r::P64;
           if (R1 & 7 != 0) goto ufZXK; else goto cfZXy;
       ufZXK: // global
           call _cfZXw(R1) args: 0, res: 0, upd: 0;
       cfZXy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZXj() //  [R1]
         { info_tbl: [(cfZXj,
                       label: block_cfZXj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZXj: // global
           if (I64[R1 + 7] == 0) goto cfZXt; else goto ufZXI;
       cfZXt: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       ufZXI: // global
           Sp = Sp + 32;
           call _cfZXF() args: 0, res: 0, upd: 0;
     }
 },
 _cfZXw() //  [R1]
         { info_tbl: [(cfZXw,
                       label: block_cfZXw_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZXw: // global
           if (I64[R1 + 7] == 0) goto cfZXG; else goto ufZXH;
       cfZXG: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       ufZXH: // global
           Sp = Sp + 40;
           call _cfZXF() args: 0, res: 0, upd: 0;
     }
 },
 _cfZXF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZXF: // global
           R1 = Data.Maybe.fromJust1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.476844233 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapQr_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapQr_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapQr_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapQr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZXP: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQr_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 48, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapQr_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cfZY0,
                       label: Data.Functor.Sum.$fDataSum_$cgmapQr_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZY0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZY1; else goto cfZY2;
       cfZY1: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgmapQr_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cfZY2: // global
           I64[Sp - 8] = block_cfZXT_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZYf; else goto cfZXU;
       ufZYf: // global
           call _cfZXT(R1) args: 0, res: 0, upd: 0;
       cfZXU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZXT() //  [R1]
         { info_tbl: [(cfZXT,
                       label: block_cfZXT_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZXT: // global
           _sfY2B::P64 = P64[Sp + 16];
           _sfY2C::P64 = P64[Sp + 24];
           _sfY2D::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZXX; else goto cfZXY;
       cfZXX: // global
           Hp = Hp + 40;
           _sfY2F::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZYe; else goto cfZY7;
       cfZY7: // global
           _sfY2G::P64 = P64[_sfY2F::P64 + 7];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sfY2D::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sfY2G::P64;
           R3 = _sfY2C::P64;
           R2 = Hp - 32;
           R1 = _sfY2B::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZXY: // global
           Hp = Hp + 40;
           _sfY2F::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZYe; else goto cfZYd;
       cfZYe: // global
           HpAlloc = 40;
           R1 = _sfY2F::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZYd: // global
           _sfY2I::P64 = P64[_sfY2F::P64 + 6];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sfY2D::P64;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sfY2I::P64;
           R3 = _sfY2C::P64;
           R2 = Hp - 32;
           R1 = _sfY2B::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.479165106 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapQ_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapQ_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapQ_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapQ_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZYh: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQ_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapQ_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZYs,
                       label: Data.Functor.Sum.$fDataSum_$cgmapQ_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZYs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZYt; else goto cfZYu;
       cfZYt: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgmapQ_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cfZYu: // global
           I64[Sp - 8] = block_cfZYl_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZYJ; else goto cfZYm;
       ufZYJ: // global
           call _cfZYl(R1) args: 0, res: 0, upd: 0;
       cfZYm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZYl() //  [R1]
         { info_tbl: [(cfZYl,
                       label: block_cfZYl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZYl: // global
           _sfY2Q::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfZYp; else goto cfZYq;
       cfZYp: // global
           Hp = Hp + 64;
           _sfY2S::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZYI; else goto cfZYA;
       cfZYA: // global
           _sfY2T::P64 = P64[_sfY2S::P64 + 7];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sfY2Q::P64;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sfY2T::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfZYq: // global
           Hp = Hp + 64;
           _sfY2S::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZYI; else goto cfZYH;
       cfZYI: // global
           HpAlloc = 64;
           R1 = _sfY2S::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZYH: // global
           _sfY2V::P64 = P64[_sfY2S::P64 + 6];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sfY2Q::P64;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sfY2V::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.481427795 UTC

[section ""data" . Data.Functor.Sum.$fDataSum3_closure" {
     Data.Functor.Sum.$fDataSum3_closure:
         const Data.Functor.Sum.$fDataSum3_info;
 },
 Data.Functor.Sum.$fDataSum3_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZYL: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum3_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 48, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZYW,
                       label: Data.Functor.Sum.$fDataSum3_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZYW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZYX; else goto cfZYY;
       cfZYX: // global
           R1 = Data.Functor.Sum.$fDataSum3_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cfZYY: // global
           I64[Sp - 8] = block_cfZYP_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZZb; else goto cfZYQ;
       ufZZb: // global
           call _cfZYP(R1) args: 0, res: 0, upd: 0;
       cfZYQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZYP() //  [R1]
         { info_tbl: [(cfZYP,
                       label: block_cfZYP_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZYP: // global
           _sfY33::P64 = P64[Sp + 16];
           _sfY34::P64 = P64[Sp + 24];
           _sfY35::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cfZYT; else goto cfZYU;
       cfZYT: // global
           Hp = Hp + 40;
           _sfY37::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZZa; else goto cfZZ3;
       cfZZ3: // global
           _sfY38::P64 = P64[_sfY37::P64 + 7];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sfY35::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sfY38::P64;
           R3 = Hp - 32;
           R2 = _sfY34::P64;
           R1 = _sfY33::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfZYU: // global
           Hp = Hp + 40;
           _sfY37::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZZa; else goto cfZZ9;
       cfZZa: // global
           HpAlloc = 40;
           R1 = _sfY37::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZZ9: // global
           _sfY3a::P64 = P64[_sfY37::P64 + 6];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sfY35::P64;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sfY3a::P64;
           R3 = Hp - 32;
           R2 = _sfY34::P64;
           R1 = _sfY33::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.483624207 UTC

[section ""data" . Data.Functor.Sum.$fDataSum4_closure" {
     Data.Functor.Sum.$fDataSum4_closure:
         const Data.Functor.Sum.$fDataSum4_info;
 },
 Data.Functor.Sum.$fDataSum4_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZZd: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfZZo,
                       label: Data.Functor.Sum.$fDataSum4_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZZo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfZZp; else goto cfZZq;
       cfZZp: // global
           R1 = Data.Functor.Sum.$fDataSum4_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cfZZq: // global
           I64[Sp - 8] = block_cfZZh_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufZZF; else goto cfZZi;
       ufZZF: // global
           call _cfZZh(R1) args: 0, res: 0, upd: 0;
       cfZZi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfZZh() //  [R1]
         { info_tbl: [(cfZZh,
                       label: block_cfZZh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZZh: // global
           _sfY3i::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfZZl; else goto cfZZm;
       cfZZl: // global
           Hp = Hp + 56;
           _sfY3k::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZZE; else goto cfZZw;
       cfZZw: // global
           _sfY3l::P64 = P64[_sfY3k::P64 + 7];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = _sfY3i::P64;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sfY3l::P64;
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfZZm: // global
           Hp = Hp + 56;
           _sfY3k::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cfZZE; else goto cfZZD;
       cfZZE: // global
           HpAlloc = 56;
           R1 = _sfY3k::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfZZD: // global
           _sfY3n::P64 = P64[_sfY3k::P64 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = _sfY3i::P64;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sfY3n::P64;
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.488167551 UTC

[section ""data" . Data.Functor.Sum.$w$cgmapMo_closure" {
     Data.Functor.Sum.$w$cgmapMo_closure:
         const Data.Functor.Sum.$w$cgmapMo_info;
 },
 lvl8_sfY3u_entry() //  [R1]
         { info_tbl: [(cfZZO,
                       label: lvl8_sfY3u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZZO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfZZP; else goto cfZZQ;
       cfZZP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfZZQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfY42_entry() //  [R1, R2]
         { info_tbl: [(cg003,
                       label: sat_sfY42_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg003: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg004; else goto cg005;
       cg004: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg005: // global
           I64[Sp - 24] = block_cg000_info;
           _sfY3u::P64 = P64[R1 + 7];
           _sfY3v::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfY3u::P64;
           P64[Sp - 8] = _sfY3v::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug00n; else goto cg001;
       ug00n: // global
           call _cg000(R1) args: 0, res: 0, upd: 0;
       cg001: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg000() //  [R1]
         { info_tbl: [(cg000,
                       label: block_cg000_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg000: // global
           I64[Sp - 8] = block_cg008_info;
           _sfY3Z::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfY3Z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug00m; else goto cg00a;
       ug00m: // global
           call _cg008(R1) args: 0, res: 0, upd: 0;
       cg00a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg008() //  [R1]
         { info_tbl: [(cg008,
                       label: block_cg008_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg008: // global
           if (R1 & 7 == 1) goto cg00g; else goto cg00k;
       cg00g: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg00k: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY3N_entry() //  [R1]
         { info_tbl: [(cg00T,
                       label: sat_sfY3N_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg00T: // global
           _sfY3N::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg00U; else goto cg00V;
       cg00V: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg00X; else goto cg00W;
       cg00X: // global
           HpAlloc = 56;
           goto cg00U;
       cg00U: // global
           R1 = _sfY3N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg00W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY3N::P64;
           _sfY3v::P64 = P64[_sfY3N::P64 + 16];
           _sfY3z::P64 = P64[_sfY3N::P64 + 24];
           _sfY3D::P64 = P64[_sfY3N::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY3D::P64;
           P64[Hp - 24] = _sfY3z::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sfY3v::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY3J_entry() //  [R1, R2]
         { info_tbl: [(cg019,
                       label: sat_sfY3J_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg019: // global
           _sfY3G::P64 = R2;
           _sfY3J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg01a; else goto cg01b;
       cg01b: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg01d; else goto cg01c;
       cg01d: // global
           HpAlloc = 56;
           goto cg01a;
       cg01a: // global
           R2 = _sfY3G::P64;
           R1 = _sfY3J::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg01c: // global
           _sfY3v::P64 = P64[_sfY3J::P64 + 7];
           _sfY3D::P64 = P64[_sfY3J::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY3D::P64;
           P64[Hp - 24] = _sfY3G::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sfY3v::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY3K_entry() //  [R1]
         { info_tbl: [(cg01e,
                       label: sat_sfY3K_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg01e: // global
           _sfY3K::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg01f; else goto cg01g;
       cg01g: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg01i; else goto cg01h;
       cg01i: // global
           HpAlloc = 24;
           goto cg01f;
       cg01f: // global
           R1 = _sfY3K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg01h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY3K::P64;
           _sfY3v::P64 = P64[_sfY3K::P64 + 16];
           _sfY3A::P64 = P64[_sfY3K::P64 + 24];
           _sfY3D::P64 = P64[_sfY3K::P64 + 32];
           I64[Hp - 16] = sat_sfY3J_info;
           P64[Hp - 8] = _sfY3v::P64;
           P64[Hp] = _sfY3D::P64;
           R2 = _sfY3v::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sfY3A::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sfY3Q_entry() //  [R1, R2]
         { info_tbl: [(cg01j,
                       label: sat_sfY3Q_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg01j: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg01k; else goto cg01l;
       cg01k: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg01l: // global
           I64[Sp - 40] = block_cg00D_info;
           _sfY3r::P64 = P64[R1 + 7];
           _sfY3v::P64 = P64[R1 + 15];
           _sfY3z::P64 = P64[R1 + 23];
           _sfY3A::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sfY3r::P64;
           P64[Sp - 24] = _sfY3v::P64;
           P64[Sp - 16] = _sfY3z::P64;
           P64[Sp - 8] = _sfY3A::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug01C; else goto cg00E;
       ug01C: // global
           call _cg00D(R1) args: 0, res: 0, upd: 0;
       cg00E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg00D() //  [R1]
         { info_tbl: [(cg00D,
                       label: block_cg00D_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg00D: // global
           I64[Sp - 8] = block_cg00I_info;
           _sfY3D::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfY3D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug01B; else goto cg00J;
       ug01B: // global
           call _cg00I(R1) args: 0, res: 0, upd: 0;
       cg00J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg00I() //  [R1]
         { info_tbl: [(cg00I,
                       label: block_cg00I_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg00I: // global
           _sfY3v::P64 = P64[Sp + 24];
           _sfY3z::P64 = P64[Sp + 32];
           _sfY3D::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cg01o; else goto cg01s;
       cg01o: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg01r; else goto cg01q;
       cg01r: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg01q: // global
           I64[Hp - 72] = sat_sfY3N_info;
           P64[Hp - 56] = _sfY3v::P64;
           P64[Hp - 48] = _sfY3z::P64;
           P64[Hp - 40] = _sfY3D::P64;
           I64[Hp - 32] = sat_sfY3K_info;
           P64[Hp - 16] = _sfY3v::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sfY3D::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cg01s: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg01x; else goto cg01w;
       cg01x: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg01w: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY3D::P64;
           P64[Hp - 24] = _sfY3z::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sfY3v::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 k1_sfY3w_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg01D,
                       label: k1_sfY3w_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg01D: // global
           _sfY3z::P64 = R4;
           _sfY3y::P64 = R3;
           _sfY3x::P64 = R2;
           _sfY3w::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg01E; else goto cg01F;
       cg01F: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg01H; else goto cg01G;
       cg01H: // global
           HpAlloc = 80;
           goto cg01E;
       cg01E: // global
           R4 = _sfY3z::P64;
           R3 = _sfY3y::P64;
           R2 = _sfY3x::P64;
           R1 = _sfY3w::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg01G: // global
           _sfY3r::P64 = P64[_sfY3w::P64 + 5];
           _sfY3s::P64 = P64[_sfY3w::P64 + 13];
           _sfY3v::P64 = P64[_sfY3w::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sfY3s::P64;
           P64[Hp - 48] = _sfY3x::P64;
           P64[Hp - 40] = _sfY3z::P64;
           I64[Hp - 32] = sat_sfY3Q_info;
           P64[Hp - 24] = _sfY3r::P64;
           P64[Hp - 16] = _sfY3v::P64;
           P64[Hp - 8] = _sfY3z::P64;
           P64[Hp] = Hp - 72;
           R2 = _sfY3v::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sfY3y::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY3T_entry() //  [R1]
         { info_tbl: [(cg01R,
                       label: sat_sfY3T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg01R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg01S; else goto cg01T;
       cg01S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg01T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY3V_entry() //  [R1]
         { info_tbl: [(cg020,
                       label: sat_sfY3V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg020: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg021; else goto cg022;
       cg021: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg022: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY3W_entry() //  [R1]
         { info_tbl: [(cg027,
                       label: sat_sfY3W_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg027: // global
           _sfY3W::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cg028; else goto cg029;
       cg029: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg02b; else goto cg02a;
       cg02b: // global
           HpAlloc = 32;
           goto cg028;
       cg028: // global
           R1 = _sfY3W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg02a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY3W::P64;
           _sfY3p::P64 = P64[_sfY3W::P64 + 16];
           _sfY3q::P64 = P64[_sfY3W::P64 + 24];
           _sfY3r::P64 = P64[_sfY3W::P64 + 32];
           _sfY3s::P64 = P64[_sfY3W::P64 + 40];
           _sfY3t::P64 = P64[_sfY3W::P64 + 48];
           _sfY3v::P64 = P64[_sfY3W::P64 + 56];
           I64[Hp - 24] = k1_sfY3w_info;
           P64[Hp - 16] = _sfY3r::P64;
           P64[Hp - 8] = _sfY3s::P64;
           P64[Hp] = _sfY3v::P64;
           I64[Sp - 56] = block_cg01I_info;
           R1 = _sfY3t::P64;
           P64[Sp - 48] = Hp - 21;
           P64[Sp - 40] = _sfY3p::P64;
           P64[Sp - 32] = _sfY3q::P64;
           P64[Sp - 24] = _sfY3v::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ug02i; else goto cg01J;
       ug02i: // global
           call _cg01I(R1) args: 0, res: 0, upd: 0;
       cg01J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg01I() //  [R1]
         { info_tbl: [(cg01I,
                       label: block_cg01I_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg01I: // global
           _cg00s::P64 = P64[Sp + 8];
           _sfY3v::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg024; else goto cg025;
       cg024: // global
           Hp = Hp + 24;
           _sfY3R::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg02h; else goto cg02d;
       cg02d: // global
           _sfY3S::P64 = P64[_sfY3R::P64 + 7];
           I64[Hp - 16] = sat_sfY3T_info;
           P64[Hp] = _sfY3v::P64;
           R4 = _sfY3S::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _cg00s::P64;
           Sp = Sp + 40;
           call k1_sfY3w_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
       cg025: // global
           Hp = Hp + 24;
           _sfY3R::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg02h; else goto cg02g;
       cg02h: // global
           HpAlloc = 24;
           R1 = _sfY3R::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg02g: // global
           _sfY3U::P64 = P64[_sfY3R::P64 + 6];
           I64[Hp - 16] = sat_sfY3V_info;
           P64[Hp] = _sfY3v::P64;
           R4 = _sfY3U::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 24];
           R1 = _cg00s::P64;
           Sp = Sp + 40;
           call k1_sfY3w_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgmapMo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg02j,
                       label: Data.Functor.Sum.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg02j: // global
           _sfY3t::P64 = R6;
           _sfY3s::P64 = R5;
           _sfY3r::P64 = R4;
           _sfY3q::P64 = R3;
           _sfY3p::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg02k; else goto cg02l;
       cg02l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg02n; else goto cg02m;
       cg02n: // global
           HpAlloc = 24;
           goto cg02k;
       cg02k: // global
           R6 = _sfY3t::P64;
           R5 = _sfY3s::P64;
           R4 = _sfY3r::P64;
           R3 = _sfY3q::P64;
           R2 = _sfY3p::P64;
           R1 = Data.Functor.Sum.$w$cgmapMo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg02m: // global
           I64[Hp - 16] = lvl8_sfY3u_info;
           P64[Hp] = _sfY3r::P64;
           I64[Sp - 56] = block_cfZZR_info;
           R2 = _sfY3r::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sfY3p::P64;
           P64[Sp - 32] = _sfY3q::P64;
           P64[Sp - 24] = _sfY3r::P64;
           P64[Sp - 16] = _sfY3s::P64;
           P64[Sp - 8] = _sfY3t::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfZZR() //  [R1]
         { info_tbl: [(cfZZR,
                       label: block_cfZZR_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfZZR: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg02q; else goto cg02p;
       cg02q: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg02p: // global
           I64[Hp - 80] = sat_sfY42_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sfY3W_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.495285187 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapMo_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapMo_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapMo_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapMo_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg02s: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapMo_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapMo_entry() //  [R6]
         { info_tbl: [(cg02w,
                       label: Data.Functor.Sum.$fDataSum_$cgmapMo_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg02w: // global
           _sfY47::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sfY47::P64;
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgmapMo_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.496613299 UTC

[section ""data" . lvl4_rfXPs_closure" {
     lvl4_rfXPs_closure:
         const lvl4_rfXPs_info;
         const 0;
 },
 lvl4_rfXPs_entry() //  [R2]
         { info_tbl: [(cg02K,
                       label: lvl4_rfXPs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg02K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg02L; else goto cg02M;
       cg02L: // global
           R2 = R2;
           R1 = lvl4_rfXPs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg02M: // global
           I64[Sp - 8] = block_cg02D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug02T; else goto cg02E;
       ug02T: // global
           call _cg02D(R1) args: 0, res: 0, upd: 0;
       cg02E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg02D() //  [R1]
         { info_tbl: [(cg02D,
                       label: block_cg02D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg02D: // global
           if (R1 & 7 == 1) goto cg02H; else goto cg02I;
       cg02H: // global
           R1 = Data.Functor.Sum.$cInL_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg02I: // global
           R1 = Data.Functor.Sum.$cInR_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.497794401 UTC

[section ""data" . lvl5_rfXPt_closure" {
     lvl5_rfXPt_closure:
         const lvl5_rfXPt_info;
         const 0;
 },
 lvl5_rfXPt_entry() //  []
         { info_tbl: [(cg02Y,
                       label: lvl5_rfXPt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg02Y: // global
           R1 = Data.Functor.Sum.$tSum_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.498629084 UTC

[section ""data" . lvl6_rfXPu_closure" {
     lvl6_rfXPu_closure:
         const lvl6_rfXPu_info;
 },
 lvl6_rfXPu_entry() //  []
         { info_tbl: [(cg035,
                       label: lvl6_rfXPu_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg035: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.49943471 UTC

[section ""data" . lvl7_rfXPv_closure" {
     lvl7_rfXPv_closure:
         const lvl7_rfXPv_info;
 },
 lvl7_rfXPv_entry() //  []
         { info_tbl: [(cg03c,
                       label: lvl7_rfXPv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg03c: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.502530272 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_closure" {
     Data.Functor.Sum.$fDataSum_closure:
         const Data.Functor.Sum.$fDataSum_info;
         const 0;
 },
 sat_sfY4K_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg03o,
                       label: sat_sfY4K_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg03o: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$w$cgmapMo_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfY4G_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg03w,
                       label: sat_sfY4G_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg03w: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$w$cgmapMp_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfY4C_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg03E,
                       label: sat_sfY4C_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg03E: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$w$cgmapM_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfY4y_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg03M,
                       label: sat_sfY4y_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg03M: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg03N; else goto cg03O;
       cg03N: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg03O: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Sum.$fDataSum_$cgmapQi_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sfY4x_entry() //  [R1, R2, R3]
         { info_tbl: [(cg03U,
                       label: sat_sfY4x_info
                       rep:HeapRep 6 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg03U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg03V; else goto cg03W;
       cg03V: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg03W: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 46];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fDataSum_$cgmapQ_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY4w_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg042,
                       label: sat_sfY4w_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg042: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg043; else goto cg044;
       cg043: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg044: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQr_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sfY4v_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg04a,
                       label: sat_sfY4v_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg04a: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg04b; else goto cg04c;
       cg04b: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg04c: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Sum.$fDataSum3_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sfY4u_entry() //  [R1, R2, R3]
         { info_tbl: [(cg04i,
                       label: sat_sfY4u_info
                       rep:HeapRep 6 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg04i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg04j; else goto cg04k;
       cg04j: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg04k: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 46];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fDataSum4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY4t_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg04q,
                       label: sat_sfY4t_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg04q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg04r; else goto cg04s;
       cg04r: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg04s: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Sum.$fDataSum_$cgunfold_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sfY4s_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg04y,
                       label: sat_sfY4s_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg04y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg04z; else goto cg04A;
       cg04z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg04A: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Sum.$fDataSum_$cgfoldl_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sfY4r_entry() //  [R1]
         { info_tbl: [(cg04F,
                       label: sat_sfY4r_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg04F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg04G; else goto cg04H;
       cg04G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg04H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$w$cp1Data_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fDataSum_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg04J,
                       label: Data.Functor.Sum.$fDataSum_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg04J: // global
           Hp = Hp + 640;
           if (Hp > HpLim) (likely: False) goto cg04N; else goto cg04M;
       cg04N: // global
           HpAlloc = 640;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fDataSum_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg04M: // global
           I64[Hp - 632] = sat_sfY4K_info;
           P64[Hp - 624] = R6;
           _sfY4q::P64 = P64[Sp];
           P64[Hp - 616] = _sfY4q::P64;
           I64[Hp - 608] = sat_sfY4G_info;
           P64[Hp - 600] = R6;
           P64[Hp - 592] = _sfY4q::P64;
           I64[Hp - 584] = sat_sfY4C_info;
           P64[Hp - 576] = R6;
           P64[Hp - 568] = _sfY4q::P64;
           I64[Hp - 560] = sat_sfY4y_info;
           P64[Hp - 552] = R2;
           P64[Hp - 544] = R3;
           P64[Hp - 536] = R4;
           P64[Hp - 528] = R5;
           P64[Hp - 520] = R6;
           P64[Hp - 512] = _sfY4q::P64;
           I64[Hp - 504] = sat_sfY4x_info;
           P64[Hp - 496] = R2;
           P64[Hp - 488] = R3;
           P64[Hp - 480] = R4;
           P64[Hp - 472] = R5;
           P64[Hp - 464] = R6;
           P64[Hp - 456] = _sfY4q::P64;
           I64[Hp - 448] = sat_sfY4w_info;
           P64[Hp - 440] = R2;
           P64[Hp - 432] = R3;
           P64[Hp - 424] = R4;
           P64[Hp - 416] = R5;
           P64[Hp - 408] = R6;
           P64[Hp - 400] = _sfY4q::P64;
           I64[Hp - 392] = sat_sfY4v_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           P64[Hp - 368] = R4;
           P64[Hp - 360] = R5;
           P64[Hp - 352] = R6;
           P64[Hp - 344] = _sfY4q::P64;
           I64[Hp - 336] = sat_sfY4u_info;
           P64[Hp - 328] = R2;
           P64[Hp - 320] = R3;
           P64[Hp - 312] = R4;
           P64[Hp - 304] = R5;
           P64[Hp - 296] = R6;
           P64[Hp - 288] = _sfY4q::P64;
           I64[Hp - 280] = sat_sfY4t_info;
           P64[Hp - 272] = R2;
           P64[Hp - 264] = R3;
           P64[Hp - 256] = R4;
           P64[Hp - 248] = R5;
           P64[Hp - 240] = R6;
           P64[Hp - 232] = _sfY4q::P64;
           I64[Hp - 224] = sat_sfY4s_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           P64[Hp - 200] = R4;
           P64[Hp - 192] = R5;
           P64[Hp - 184] = R6;
           P64[Hp - 176] = _sfY4q::P64;
           I64[Hp - 168] = sat_sfY4r_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           P64[Hp - 136] = R4;
           P64[Hp - 128] = R5;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 168;
           P64[Hp - 104] = Hp - 221;
           P64[Hp - 96] = Hp - 277;
           P64[Hp - 88] = lvl4_rfXPs_closure+1;
           P64[Hp - 80] = lvl5_rfXPt_closure+1;
           P64[Hp - 72] = lvl6_rfXPu_closure+2;
           P64[Hp - 64] = lvl7_rfXPv_closure+2;
           P64[Hp - 56] = Hp - 334;
           P64[Hp - 48] = Hp - 388;
           P64[Hp - 40] = Hp - 444;
           P64[Hp - 32] = Hp - 502;
           P64[Hp - 24] = Hp - 557;
           P64[Hp - 16] = Hp - 581;
           P64[Hp - 8] = Hp - 605;
           P64[Hp] = Hp - 629;
           R1 = Hp - 119;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.508107989 UTC

[section ""data" . Data.Functor.Sum.InL_closure" {
     Data.Functor.Sum.InL_closure:
         const Data.Functor.Sum.InL_info;
 },
 Data.Functor.Sum.InL_entry() //  [R2]
         { info_tbl: [(cg04T,
                       label: Data.Functor.Sum.InL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg04T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg04X; else goto cg04W;
       cg04X: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Functor.Sum.InL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg04W: // global
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.509143302 UTC

[section ""data" . Data.Functor.Sum.InR_closure" {
     Data.Functor.Sum.InR_closure:
         const Data.Functor.Sum.InR_info;
 },
 Data.Functor.Sum.InR_entry() //  [R2]
         { info_tbl: [(cg053,
                       label: Data.Functor.Sum.InR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg053: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg057; else goto cg056;
       cg057: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Functor.Sum.InR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg056: // global
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.510053898 UTC

[Data.Functor.Sum.InL_con_entry() //  [R1]
         { info_tbl: [(cg058,
                       label: Data.Functor.Sum.InL_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,83,117,109,46,73,110,76]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg058: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.513214234 UTC

[Data.Functor.Sum.InR_con_entry() //  [R1]
         { info_tbl: [(cg05a,
                       label: Data.Functor.Sum.InR_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,83,117,109,46,73,110,82]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg05a: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.514008211 UTC

[section ""relreadonly" . SfYa7_srt" {
     SfYa7_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Sum.$fRead1Sum2_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Data.Functor.Sum.$fRead1Sum6_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Sum.$fRead1Sum1_closure;
         const Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure;
         const Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure;
         const Data.Functor.Sum.$fRead1Sum_closure;
         const Data.Functor.Sum.$fRead1Sum3_closure;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const Data.Functor.Sum.$w$cliftShowsPrec_closure;
         const Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure;
         const Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure;
         const Data.Functor.Sum.$fShow1Sum_closure;
         const Data.Functor.Sum.$fReadSum1_closure;
         const Data.Functor.Sum.$fReadSum_$creadsPrec_closure;
         const Data.Functor.Sum.$fReadSum_$creadListPrec_closure;
         const Data.Functor.Sum.$fReadSum_$creadList_closure;
         const Data.Functor.Sum.$fReadSum_closure;
         const Data.Functor.Sum.$fShowSum_$cshowsPrec_closure;
         const Data.Functor.Sum.$fShowSum_$cshow_closure;
         const Data.Functor.Sum.$fShowSum_$cshowList_closure;
         const Data.Functor.Sum.$fShowSum_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Functor.Sum.$fFoldableSum3_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Functor.Sum.$fFoldableSum4_closure;
         const Data.Functor.Sum.$fFoldableSum_$cminimum_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Sum.$fFoldableSum5_closure;
         const Data.Functor.Sum.$fFoldableSum_$cmaximum_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Functor.Sum.$fFoldableSum_$celem_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Functor.Sum.$fFoldableSum10_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldl_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure;
         const Data.Functor.Sum.$fFoldableSum9_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldr_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure;
         const Data.Functor.Sum.$fFoldableSum_$clength_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure;
         const Data.Functor.Sum.$fFoldableSum11_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Functor.Sum.$fFoldableSum1_closure;
         const Data.Functor.Sum.$fFoldableSum_$cnull_closure;
         const Data.Functor.Sum.$fFoldableSum_$ctoList_closure;
         const Data.Functor.Sum.$fFoldableSum_closure;
         const Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure;
         const Data.Functor.Sum.$fTraversableSum_closure;
         const Data.Data.$wlvl_closure;
         const Data.Functor.Sum.$w$cgunfold_closure;
         const Data.Functor.Sum.$fDataSum_$cgunfold_closure;
         const GHC.List.badHead_closure;
         const go61_rfXP6_closure;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const go1_rfXP7_closure;
         const Data.Data.mkConstr1_closure;
         const $tSum3_rfXPb_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Functor.Sum.$w$cp1Data_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Functor.Sum.$fDataSum_$cgmapQi_closure;
         const Data.Functor.Sum.$cInL_closure;
         const Data.Functor.Sum.$cInR_closure;
         const lvl4_rfXPs_closure;
         const Data.Functor.Sum.$tSum_closure;
         const Data.Functor.Sum.$fDataSum_closure;
         const lvl5_rfXPt_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.51526764 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:47.51722132 UTC

[section ""data" . Data.Functor.Sum.$fEq1Sum_$cliftEq_closure" {
     Data.Functor.Sum.$fEq1Sum_$cliftEq_closure:
         const Data.Functor.Sum.$fEq1Sum_$cliftEq_info;
 },
 Data.Functor.Sum.$fEq1Sum_$cliftEq_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg05n,
                       label: Data.Functor.Sum.$fEq1Sum_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg05n: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg05o; else goto cg05p;
       cg05o: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEq1Sum_$cliftEq_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg05p: // global
           I64[Sp - 40] = block_cg05g_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug060; else goto cg05h;
       ug060: // global
           call _cg05g(R1) args: 0, res: 0, upd: 0;
       cg05h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg05g() //  [R1]
         { info_tbl: [(cg05g,
                       label: block_cg05g_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg05g: // global
           _sfXPB::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg05k; else goto cg05l;
       cg05k: // global
           I64[Sp] = block_cg05s_info;
           _sfXPD::P64 = P64[R1 + 7];
           R1 = _sfXPB::P64;
           P64[Sp + 32] = _sfXPD::P64;
           if (R1 & 7 != 0) goto ug05Y; else goto cg05u;
       ug05Y: // global
           call _cg05s(R1) args: 0, res: 0, upd: 0;
       cg05u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg05l: // global
           I64[Sp + 8] = block_cg05H_info;
           _sfXPH::P64 = P64[R1 + 6];
           R1 = _sfXPB::P64;
           P64[Sp + 32] = _sfXPH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug05Z; else goto cg05J;
       ug05Z: // global
           call _cg05H(R1) args: 0, res: 0, upd: 0;
       cg05J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg05s() //  [R1]
         { info_tbl: [(cg05s,
                       label: block_cg05s_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg05s: // global
           if (R1 & 7 == 1) goto cg05A; else goto ug05X;
       cg05A: // global
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ug05X: // global
           Sp = Sp + 40;
           call _cg05P() args: 0, res: 0, upd: 0;
     }
 },
 _cg05H() //  [R1]
         { info_tbl: [(cg05H,
                       label: block_cg05H_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg05H: // global
           if (R1 & 7 == 1) goto ug05W; else goto cg05T;
       ug05W: // global
           Sp = Sp + 32;
           call _cg05P() args: 0, res: 0, upd: 0;
       cg05T: // global
           R4 = P64[R1 + 6];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg05P() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg05P: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.528808359 UTC

[section ""data" . Data.Functor.Sum.$fEq1Sum_closure" {
     Data.Functor.Sum.$fEq1Sum_closure:
         const Data.Functor.Sum.$fEq1Sum_info;
 },
 Data.Functor.Sum.$fEq1Sum_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg06x,
                       label: Data.Functor.Sum.$fEq1Sum_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg06x: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fEq1Sum_$cliftEq_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.533023903 UTC

[section ""data" . Data.Functor.Sum.$fOrd1Sum_$cliftCompare_closure" {
     Data.Functor.Sum.$fOrd1Sum_$cliftCompare_closure:
         const Data.Functor.Sum.$fOrd1Sum_$cliftCompare_info;
 },
 Data.Functor.Sum.$fOrd1Sum_$cliftCompare_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cg06P,
                       label: Data.Functor.Sum.$fOrd1Sum_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg06P: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg06Q; else goto cg06R;
       cg06Q: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrd1Sum_$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg06R: // global
           I64[Sp - 40] = block_cg06I_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug07q; else goto cg06J;
       ug07q: // global
           call _cg06I(R1) args: 0, res: 0, upd: 0;
       cg06J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg06I() //  [R1]
         { info_tbl: [(cg06I,
                       label: block_cg06I_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg06I: // global
           _sfXPP::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg06M; else goto cg06N;
       cg06M: // global
           I64[Sp] = block_cg06U_info;
           _sfXPR::P64 = P64[R1 + 7];
           R1 = _sfXPP::P64;
           P64[Sp + 32] = _sfXPR::P64;
           if (R1 & 7 != 0) goto ug07o; else goto cg06W;
       ug07o: // global
           call _cg06U(R1) args: 0, res: 0, upd: 0;
       cg06W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg06N: // global
           I64[Sp + 8] = block_cg079_info;
           _sfXPV::P64 = P64[R1 + 6];
           R1 = _sfXPP::P64;
           P64[Sp + 32] = _sfXPV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug07p; else goto cg07b;
       ug07p: // global
           call _cg079(R1) args: 0, res: 0, upd: 0;
       cg07b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg06U() //  [R1]
         { info_tbl: [(cg06U,
                       label: block_cg06U_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg06U: // global
           if (R1 & 7 == 1) goto cg072; else goto cg076;
       cg072: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
       cg076: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg079() //  [R1]
         { info_tbl: [(cg079,
                       label: block_cg079_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg079: // global
           if (R1 & 7 == 1) goto cg07h; else goto cg07l;
       cg07h: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg07l: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.544111104 UTC

[section ""data" . Data.Functor.Sum.$fOrd1Sum1_closure" {
     Data.Functor.Sum.$fOrd1Sum1_closure:
         const Data.Functor.Sum.$fOrd1Sum1_info;
 },
 Data.Functor.Sum.$fOrd1Sum1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg087,
                       label: Data.Functor.Sum.$fOrd1Sum1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg087: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg088; else goto cg089;
       cg088: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrd1Sum1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg089: // global
           I64[Sp - 40] = block_cg080_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug08K; else goto cg081;
       ug08K: // global
           call _cg080(R1) args: 0, res: 0, upd: 0;
       cg081: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg080() //  [R1]
         { info_tbl: [(cg080,
                       label: block_cg080_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg080: // global
           _sfXQ3::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg084; else goto cg085;
       cg084: // global
           I64[Sp] = block_cg08c_info;
           _sfXQ5::P64 = P64[R1 + 7];
           R1 = _sfXQ3::P64;
           P64[Sp + 32] = _sfXQ5::P64;
           if (R1 & 7 != 0) goto ug08I; else goto cg08e;
       ug08I: // global
           call _cg08c(R1) args: 0, res: 0, upd: 0;
       cg08e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg085: // global
           I64[Sp + 8] = block_cg08r_info;
           _sfXQ9::P64 = P64[R1 + 6];
           R1 = _sfXQ3::P64;
           P64[Sp + 32] = _sfXQ9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug08J; else goto cg08t;
       ug08J: // global
           call _cg08r(R1) args: 0, res: 0, upd: 0;
       cg08t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg08c() //  [R1]
         { info_tbl: [(cg08c,
                       label: block_cg08c_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg08c: // global
           if (R1 & 7 == 1) goto cg08k; else goto ug08H;
       cg08k: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
       ug08H: // global
           Sp = Sp + 40;
           call _cg08z() args: 0, res: 0, upd: 0;
     }
 },
 _cg08r() //  [R1]
         { info_tbl: [(cg08r,
                       label: block_cg08r_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg08r: // global
           if (R1 & 7 == 1) goto ug08G; else goto cg08D;
       ug08G: // global
           Sp = Sp + 32;
           call _cg08z() args: 0, res: 0, upd: 0;
       cg08D: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cg08z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg08z: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.557172009 UTC

[section ""data" . Data.Functor.Sum.$fOrd1Sum_closure" {
     Data.Functor.Sum.$fOrd1Sum_closure:
         const Data.Functor.Sum.$fOrd1Sum_info;
 },
 sat_sfXQg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg09s,
                       label: sat_sfXQg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg09s: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fOrd1Sum_$cliftCompare_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg09A,
                       label: sat_sfXQf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg09A: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fOrd1Sum1_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fOrd1Sum_entry() //  [R2, R3]
         { info_tbl: [(cg09E,
                       label: Data.Functor.Sum.$fOrd1Sum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg09E: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg09I; else goto cg09H;
       cg09I: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrd1Sum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg09H: // global
           I64[Hp - 64] = sat_sfXQg_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sfXQf_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 37;
           P64[Hp] = Hp - 61;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.564726413 UTC

[section ""cstring" . Data.Functor.Sum.$fRead1Sum8_bytes" {
     Data.Functor.Sum.$fRead1Sum8_bytes:
         I8[] [73,110,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.56673335 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum7_closure" {
     Data.Functor.Sum.$fRead1Sum7_closure:
         const Data.Functor.Sum.$fRead1Sum7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fRead1Sum7_entry() //  [R1]
         { info_tbl: [(cg0a3,
                       label: Data.Functor.Sum.$fRead1Sum7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0a3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0a4; else goto cg0a5;
       cg0a4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0a5: // global
           (_cg0a0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg0a0::I64 == 0) goto cg0a2; else goto cg0a1;
       cg0a2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg0a1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg0a0::I64;
           R2 = Data.Functor.Sum.$fRead1Sum8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.571359284 UTC

[section ""cstring" . Data.Functor.Sum.$fRead1Sum4_bytes" {
     Data.Functor.Sum.$fRead1Sum4_bytes:
         I8[] [73,110,82]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.573175101 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum3_closure" {
     Data.Functor.Sum.$fRead1Sum3_closure:
         const Data.Functor.Sum.$fRead1Sum3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fRead1Sum3_entry() //  [R1]
         { info_tbl: [(cg0ak,
                       label: Data.Functor.Sum.$fRead1Sum3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0ak: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0al; else goto cg0am;
       cg0al: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0am: // global
           (_cg0ah::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg0ah::I64 == 0) goto cg0aj; else goto cg0ai;
       cg0aj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg0ai: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg0ah::I64;
           R2 = Data.Functor.Sum.$fRead1Sum4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.577328854 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum2_closure" {
     Data.Functor.Sum.$fRead1Sum2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Sum.$fRead1Sum3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.579143519 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum5_closure" {
     Data.Functor.Sum.$fRead1Sum5_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.580884744 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum6_closure" {
     Data.Functor.Sum.$fRead1Sum6_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.584958551 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum1_closure" {
     Data.Functor.Sum.$fRead1Sum1_closure:
         const Data.Functor.Sum.$fRead1Sum1_info;
         const 0;
 },
 ds_sfXQl_entry() //  [R1]
         { info_tbl: [(cg0aF,
                       label: ds_sfXQl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0aF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0aG; else goto cg0aH;
       cg0aG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0aH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds1_sfXQm_entry() //  [R1]
         { info_tbl: [(cg0aM,
                       label: ds1_sfXQm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0aM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0aN; else goto cg0aO;
       cg0aN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0aO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sfXQu_entry() //  [R1, R2]
         { info_tbl: [(cg0b9,
                       label: sat_sfXQu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0b9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg0bd; else goto cg0bc;
       cg0bd: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg0bc: // global
           _sfXQp::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           R1 = _sfXQp::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQv_entry() //  [R1, R2]
         { info_tbl: [(cg0be,
                       label: sat_sfXQv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0be: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg0bi; else goto cg0bh;
       cg0bi: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg0bh: // global
           _sfXQl::P64 = P64[R1 + 7];
           _sfXQp::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sfXQu_info;
           P64[Hp] = _sfXQp::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Sum.$fRead1Sum5_closure+1;
           R1 = _sfXQl::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQC_entry() //  [R1, R2]
         { info_tbl: [(cg0bA,
                       label: sat_sfXQC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0bA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg0bE; else goto cg0bD;
       cg0bE: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg0bD: // global
           _sfXQp::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _sfXQp::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQD_entry() //  [R1, R2]
         { info_tbl: [(cg0bF,
                       label: sat_sfXQD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0bF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg0bJ; else goto cg0bI;
       cg0bJ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg0bI: // global
           _sfXQm::P64 = P64[R1 + 7];
           _sfXQp::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sfXQC_info;
           P64[Hp] = _sfXQp::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Sum.$fRead1Sum5_closure+1;
           R1 = _sfXQm::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQG_entry() //  [R1]
         { info_tbl: [(cg0bN,
                       label: sat_sfXQG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0bN: // global
           _sfXQG::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg0bO; else goto cg0bP;
       cg0bP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0bR; else goto cg0bQ;
       cg0bR: // global
           HpAlloc = 24;
           goto cg0bO;
       cg0bO: // global
           R1 = _sfXQG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0bQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXQG::P64;
           _sfXQm::P64 = P64[_sfXQG::P64 + 16];
           _sfXQp::P64 = P64[_sfXQG::P64 + 24];
           I64[Hp - 16] = sat_sfXQD_info;
           P64[Hp - 8] = _sfXQm::P64;
           P64[Hp] = _sfXQp::P64;
           I64[Sp - 24] = block_cg0bK_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Sum.$fRead1Sum2_closure+4;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg0bK() //  [R1]
         { info_tbl: [(cg0bK,
                       label: block_cg0bK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0bK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg0bU; else goto cg0bT;
       cg0bU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg0bT: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_sfXQn_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0bY,
                       label: $wlvl_sfXQn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0bY: // global
           _sfXQp::P64 = R3;
           _sfXQo::I64 = R2;
           _sfXQn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg0bZ; else goto cg0c0;
       cg0c0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0c2; else goto cg0c1;
       cg0c2: // global
           HpAlloc = 24;
           goto cg0bZ;
       cg0bZ: // global
           R3 = _sfXQp::P64;
           R2 = _sfXQo::I64;
           R1 = _sfXQn::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0c1: // global
           if (%MO_S_Gt_W64(_sfXQo::I64, 10)) goto cg0bW; else goto cg0bX;
       cg0bW: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg0bX: // global
           _sfXQl::P64 = P64[_sfXQn::P64 + 6];
           _sfXQm::P64 = P64[_sfXQn::P64 + 14];
           I64[Hp - 16] = sat_sfXQv_info;
           P64[Hp - 8] = _sfXQl::P64;
           P64[Hp] = _sfXQp::P64;
           I64[Sp - 24] = block_cg0bj_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Sum.$fRead1Sum6_closure+4;
           P64[Sp - 16] = _sfXQm::P64;
           P64[Sp - 8] = _sfXQp::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg0bj() //  [R1]
         { info_tbl: [(cg0bj,
                       label: block_cg0bj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0bj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg0c6; else goto cg0c5;
       cg0c6: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0c5: // global
           I64[Hp - 40] = sat_sfXQG_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R3 = Hp - 40;
           R2 = Hp - 6;
           Sp = Sp + 24;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 lvl8_sfXQH_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0cf,
                       label: lvl8_sfXQH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0cf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg0cg; else goto cg0ch;
       cg0cg: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0ch: // global
           I64[Sp - 24] = block_cg0cc_info;
           _sfXQn::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sfXQn::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug0cl; else goto cg0cd;
       ug0cl: // global
           call _cg0cc(R1) args: 0, res: 0, upd: 0;
       cg0cd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0cc() //  [R1]
         { info_tbl: [(cg0cc,
                       label: block_cg0cc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0cc: // global
           R3 = P64[Sp + 16];
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call $wlvl_sfXQn_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQO_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0cr,
                       label: sat_sfXQO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0cr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg0cu,
                       label: Data.Functor.Sum.$fRead1Sum1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0cu: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cg0cy; else goto cg0cx;
       cg0cy: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0cx: // global
           I64[Hp - 128] = ds_sfXQl_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R4;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = ds1_sfXQm_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = $wlvl_sfXQn_info;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 88;
           I64[Hp - 24] = lvl8_sfXQH_info;
           P64[Hp - 16] = Hp - 46;
           I64[Hp - 8] = sat_sfXQO_info;
           P64[Hp] = Hp - 22;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.617633375 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure" {
     Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure:
         const Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_info;
         const 0;
 },
 sat_sfXQZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0dP,
                       label: sat_sfXQZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0dP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg0dQ; else goto cg0dR;
       cg0dQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0dR: // global
           I64[Sp - 8] = block_cg0dM_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg0dM() //  [R1]
         { info_tbl: [(cg0dM,
                       label: block_cg0dM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0dM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg0dU; else goto cg0dT;
       cg0dU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0dT: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXQU_entry() //  [R1, R2]
         { info_tbl: [(cg0e0,
                       label: sat_sfXQU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0e0: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sfXQT_entry() //  [R1]
         { info_tbl: [(cg0e3,
                       label: ds_sfXQT_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0e3: // global
           _sfXQT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg0e4; else goto cg0e5;
       cg0e5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg0e7; else goto cg0e6;
       cg0e7: // global
           HpAlloc = 32;
           goto cg0e4;
       cg0e4: // global
           R1 = _sfXQT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0e6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXQT::P64;
           _sfXQP::P64 = P64[_sfXQT::P64 + 16];
           _sfXQQ::P64 = P64[_sfXQT::P64 + 24];
           _sfXQR::P64 = P64[_sfXQT::P64 + 32];
           _sfXQS::P64 = P64[_sfXQT::P64 + 40];
           I64[Hp - 24] = sat_sfXQZ_info;
           P64[Hp - 16] = _sfXQS::P64;
           I64[Hp - 8] = sat_sfXQU_info;
           P64[Hp] = _sfXQR::P64;
           R5 = Hp - 22;
           R4 = Hp - 7;
           R3 = _sfXQQ::P64;
           R2 = _sfXQP::P64;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXR1_entry() //  [R1]
         { info_tbl: [(cg0eh,
                       label: sat_sfXR1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0eh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0ei; else goto cg0ej;
       cg0ei: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0ej: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXR2_entry() //  [R1, R2]
         { info_tbl: [(cg0ek,
                       label: sat_sfXR2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0ek: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg0eo; else goto cg0en;
       cg0eo: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg0en: // global
           _sfXQT::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sfXR1_info;
           P64[Hp - 8] = _sfXQT::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cg0ep,
                       label: Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0ep: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg0et; else goto cg0es;
       cg0et: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0es: // global
           I64[Hp - 56] = ds_sfXQT_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = sat_sfXR2_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.633825132 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure" {
     Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure:
         const Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_info;
         const 0;
 },
 sat_sfXR7_entry() //  [R1]
         { info_tbl: [(cg0f4,
                       label: sat_sfXR7_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0f4: // global
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cg0f7,
                       label: Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0f7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg0fb; else goto cg0fa;
       cg0fb: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0fa: // global
           I64[Hp - 40] = sat_sfXR7_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.640911291 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum_closure" {
     Data.Functor.Sum.$fRead1Sum_closure:
         const Data.Functor.Sum.$fRead1Sum_info;
         const 0;
 },
 sat_sfXRd_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0fs,
                       label: sat_sfXRd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0fs: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXRc_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0fA,
                       label: sat_sfXRc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0fA: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXRb_entry() //  [R1]
         { info_tbl: [(cg0fH,
                       label: sat_sfXRb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0fH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0fI; else goto cg0fJ;
       cg0fI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0fJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum_$cliftReadList_entry(R3,
                                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXRa_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0fP,
                       label: sat_sfXRa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0fP: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_entry(R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum_entry() //  [R2, R3]
         { info_tbl: [(cg0fT,
                       label: Data.Functor.Sum.$fRead1Sum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0fT: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cg0fX; else goto cg0fW;
       cg0fX: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0fW: // global
           I64[Hp - 136] = sat_sfXRd_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sfXRc_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sfXRb_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sfXRa_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 54;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 134;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure" {
     Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure:
         const Data.Functor.Sum.$fRead1Sum_$cliftReadList_info;
         const 0;
 },
 sat_sfXRg_entry() //  [R1]
         { info_tbl: [(cg0g6,
                       label: sat_sfXRg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0g6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0g7; else goto cg0g8;
       cg0g7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0g8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum_entry(R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fRead1Sum_$cliftReadList_entry() //  [R2, R3]
         { info_tbl: [(cg0g9,
                       label: Data.Functor.Sum.$fRead1Sum_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0g9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg0gd; else goto cg0gc;
       cg0gd: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0gc: // global
           I64[Hp - 24] = sat_sfXRg_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.658315356 UTC

[section ""data" . Data.Functor.Sum.$w$cliftShowsPrec_closure" {
     Data.Functor.Sum.$w$cliftShowsPrec_closure:
         const Data.Functor.Sum.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Sum.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0gJ: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sfXRp_entry() //  [R1]
         { info_tbl: [(cg0gW,
                       label: sat_sfXRp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0gW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg0gX; else goto cg0gY;
       cg0gX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0gY: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfXRr_entry() //  [R1]
         { info_tbl: [(cg0h5,
                       label: sat_sfXRr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0h5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg0h6; else goto cg0h7;
       cg0h6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0h7: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg0hc,
                       label: Data.Functor.Sum.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0hc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0hd; else goto cg0he;
       cg0hd: // global
           R1 = Data.Functor.Sum.$w$cliftShowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cg0he: // global
           I64[Sp - 40] = block_cg0gN_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0hl; else goto cg0gO;
       ug0hl: // global
           call _cg0gN(R1) args: 0, res: 0, upd: 0;
       cg0gO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0gN() //  [R1]
         { info_tbl: [(cg0gN,
                       label: block_cg0gN_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0gN: // global
           _sfXRj::P64 = P64[Sp + 16];
           _sfXRk::P64 = P64[Sp + 24];
           _sfXRl::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cg0h9; else goto cg0ha;
       cg0h9: // global
           Hp = Hp + 40;
           _sfXRn::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg0hk; else goto cg0hg;
       cg0hg: // global
           _sfXRo::P64 = P64[_sfXRn::P64 + 7];
           I64[Hp - 32] = sat_sfXRp_info;
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = _sfXRj::P64;
           P64[Hp] = _sfXRk::P64;
           R5 = _sfXRo::P64;
           R4 = _sfXRl::I64;
           R3 = Data.Functor.Sum.$fRead1Sum7_closure;
           R2 = Hp - 32;
           Sp = Sp + 48;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cg0ha: // global
           Hp = Hp + 40;
           _sfXRn::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg0hk; else goto cg0hj;
       cg0hk: // global
           HpAlloc = 40;
           R1 = _sfXRn::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0hj: // global
           _sfXRq::P64 = P64[_sfXRn::P64 + 6];
           I64[Hp - 32] = sat_sfXRr_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sfXRj::P64;
           P64[Hp] = _sfXRk::P64;
           R5 = _sfXRq::P64;
           R4 = _sfXRl::I64;
           R3 = Data.Functor.Sum.$fRead1Sum3_closure;
           R2 = Hp - 32;
           Sp = Sp + 48;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.670432328 UTC

[section ""data" . Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure" {
     Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure:
         const Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cg0hU,
                       label: Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0hU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0hV; else goto cg0hW;
       cg0hV: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg0hW: // global
           I64[Sp - 40] = block_cg0hR_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0i0; else goto cg0hS;
       ug0i0: // global
           call _cg0hR(R1) args: 0, res: 0, upd: 0;
       cg0hS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0hR() //  [R1]
         { info_tbl: [(cg0hR,
                       label: block_cg0hR_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0hR: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.676866817 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum6_closure" {
     Data.Functor.Sum.$fFoldableSum6_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.679131736 UTC

[section ""data" . Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure" {
     Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure:
         const Data.Functor.Sum.$fShow1Sum_$cliftShowList_info;
         const 0;
 },
 sat_sfXRH_entry() //  [R1, R2]
         { info_tbl: [(cg0ik,
                       label: sat_sfXRH_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0ik: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg0il; else goto cg0im;
       cg0il: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg0im: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sfXRG::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sfXRG::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShow1Sum_$cliftShowList_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cg0in,
                       label: Data.Functor.Sum.$fShow1Sum_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0in: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg0ir; else goto cg0iq;
       cg0ir: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg0iq: // global
           I64[Hp - 32] = sat_sfXRH_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 31;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.685828402 UTC

[section ""data" . Data.Functor.Sum.$fShow1Sum_closure" {
     Data.Functor.Sum.$fShow1Sum_closure:
         const Data.Functor.Sum.$fShow1Sum_info;
         const 0;
 },
 sat_sfXRL_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg0iJ,
                       label: sat_sfXRL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0iJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg0iK; else goto cg0iL;
       cg0iK: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0iL: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$fShow1Sum_$cliftShowList_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_sfXRK_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg0iR,
                       label: sat_sfXRK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0iR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg0iS; else goto cg0iT;
       cg0iS: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0iT: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShow1Sum_entry() //  [R2, R3]
         { info_tbl: [(cg0iV,
                       label: Data.Functor.Sum.$fShow1Sum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0iV: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg0iZ; else goto cg0iY;
       cg0iZ: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShow1Sum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0iY: // global
           I64[Hp - 64] = sat_sfXRL_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sfXRK_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 36;
           P64[Hp] = Hp - 60;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.694480689 UTC

[section ""data" . Data.Functor.Sum.$fEqSum_$c==_closure" {
     Data.Functor.Sum.$fEqSum_$c==_closure:
         const Data.Functor.Sum.$fEqSum_$c==_info;
 },
 sat_sfXRR_entry() //  [R1]
         { info_tbl: [(cg0jn,
                       label: sat_sfXRR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0jn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0jo; else goto cg0jp;
       cg0jo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0jp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fEqSum_$c==_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg0jq,
                       label: Data.Functor.Sum.$fEqSum_$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0jq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0ju; else goto cg0jt;
       cg0ju: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEqSum_$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0jt: // global
           I64[Hp - 16] = sat_sfXRR_info;
           P64[Hp] = R4;
           R6 = R6;
           R5 = R5;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fEq1Sum_$cliftEq_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.701340866 UTC

[section ""data" . Data.Functor.Sum.$fEqSum_$c/=_closure" {
     Data.Functor.Sum.$fEqSum_$c/=_closure:
         const Data.Functor.Sum.$fEqSum_$c/=_info;
 },
 sat_sfXS1_entry() //  [R1]
         { info_tbl: [(cg0jV,
                       label: sat_sfXS1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0jV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0jW; else goto cg0jX;
       cg0jW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0jX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXS8_entry() //  [R1]
         { info_tbl: [(cg0ka,
                       label: sat_sfXS8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0ka: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0kb; else goto cg0kc;
       cg0kb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0kc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fEqSum_$c/=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg0kh,
                       label: Data.Functor.Sum.$fEqSum_$c/=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0kh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0ki; else goto cg0kj;
       cg0ki: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEqSum_$c/=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0kj: // global
           I64[Sp - 40] = block_cg0jH_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0ld; else goto cg0jI;
       ug0ld: // global
           call _cg0jH(R1) args: 0, res: 0, upd: 0;
       cg0jI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0jH() //  [R1]
         { info_tbl: [(cg0jH,
                       label: block_cg0jH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0jH: // global
           _sfXRW::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg0ke; else goto cg0kf;
       cg0ke: // global
           I64[Sp] = block_cg0jM_info;
           _sfXRY::P64 = P64[R1 + 7];
           R1 = _sfXRW::P64;
           P64[Sp + 32] = _sfXRY::P64;
           if (R1 & 7 != 0) goto ug0l9; else goto cg0jN;
       ug0l9: // global
           call _cg0jM(R1) args: 0, res: 0, upd: 0;
       cg0jN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg0kf: // global
           I64[Sp + 8] = block_cg0k0_info;
           _sfXS4::P64 = P64[R1 + 6];
           R1 = _sfXRW::P64;
           P64[Sp + 32] = _sfXS4::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug0la; else goto cg0k1;
       ug0la: // global
           call _cg0k0(R1) args: 0, res: 0, upd: 0;
       cg0k1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0jM() //  [R1]
         { info_tbl: [(cg0jM,
                       label: block_cg0jM_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0jM: // global
           if (R1 & 7 == 1) goto cg0kn; else goto ug0l6;
       cg0kn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0kq; else goto cg0kp;
       cg0kq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0kp: // global
           _sfXS0::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXS1_info;
           P64[Hp] = P64[Sp + 24];
           _sfXRY::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg0kl_info;
           R4 = _sfXS0::P64;
           R3 = _sfXRY::P64;
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ug0l6: // global
           Sp = Sp + 40;
           call _cg0kU() args: 0, res: 0, upd: 0;
     }
 },
 _cg0kl() //  [R1]
         { info_tbl: [(cg0kl,
                       label: block_cg0kl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0kl: // global
           if (R1 & 7 == 1) goto ug0l7; else goto ug0l8;
       ug0l7: // global
           Sp = Sp + 8;
           call _cg0kU() args: 0, res: 0, upd: 0;
       ug0l8: // global
           Sp = Sp + 8;
           call _cg0kY() args: 0, res: 0, upd: 0;
     }
 },
 _cg0k0() //  [R1]
         { info_tbl: [(cg0k0,
                       label: block_cg0k0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0k0: // global
           if (R1 & 7 == 1) goto ug0l3; else goto cg0kL;
       ug0l3: // global
           Sp = Sp + 32;
           call _cg0kU() args: 0, res: 0, upd: 0;
       cg0kL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0kO; else goto cg0kN;
       cg0kO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0kN: // global
           _sfXS7::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXS8_info;
           P64[Hp] = P64[Sp + 16];
           _sfXS4::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cg0kK_info;
           R4 = _sfXS7::P64;
           R3 = _sfXS4::P64;
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0kK() //  [R1]
         { info_tbl: [(cg0kK,
                       label: block_cg0kK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0kK: // global
           if (R1 & 7 == 1) goto ug0l4; else goto ug0l5;
       ug0l4: // global
           Sp = Sp + 8;
           call _cg0kU() args: 0, res: 0, upd: 0;
       ug0l5: // global
           Sp = Sp + 8;
           call _cg0kY() args: 0, res: 0, upd: 0;
     }
 },
 _cg0kU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0kU: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg0kY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0kY: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.721700273 UTC

[section ""data" . Data.Functor.Sum.$fEqSum_closure" {
     Data.Functor.Sum.$fEqSum_closure:
         const Data.Functor.Sum.$fEqSum_info;
 },
 sat_sfXSe_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0me,
                       label: sat_sfXSe_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0me: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fEqSum_$c/=_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXSd_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0mm,
                       label: sat_sfXSd_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0mm: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fEqSum_$c==_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fEqSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0mq,
                       label: Data.Functor.Sum.$fEqSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0mq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg0mu; else goto cg0mt;
       cg0mu: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEqSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0mt: // global
           I64[Hp - 80] = sat_sfXSe_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sfXSd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 78;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.729915905 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$ccompare_closure" {
     Data.Functor.Sum.$fOrdSum_$ccompare_closure:
         const Data.Functor.Sum.$fOrdSum_$ccompare_info;
 },
 sat_sfXSk_entry() //  [R1]
         { info_tbl: [(cg0mQ,
                       label: sat_sfXSk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0mQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0mR; else goto cg0mS;
       cg0mR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0mS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$ccompare_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg0mT,
                       label: Data.Functor.Sum.$fOrdSum_$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0mT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0mX; else goto cg0mW;
       cg0mX: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0mW: // global
           I64[Hp - 16] = sat_sfXSk_info;
           P64[Hp] = R4;
           R6 = R6;
           R5 = R5;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fOrd1Sum_$cliftCompare_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.736039126 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$cp1Ord_closure" {
     Data.Functor.Sum.$fOrdSum_$cp1Ord_closure:
         const Data.Functor.Sum.$fOrdSum_$cp1Ord_info;
 },
 sat_sfXSq_entry() //  [R1]
         { info_tbl: [(cg0ne,
                       label: sat_sfXSq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0ne: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0nf; else goto cg0ng;
       cg0nf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0ng: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXSp_entry() //  [R1]
         { info_tbl: [(cg0nl,
                       label: sat_sfXSp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0nl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0nm; else goto cg0nn;
       cg0nm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0nn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXSo_entry() //  [R1]
         { info_tbl: [(cg0ns,
                       label: sat_sfXSo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0ns: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0nt; else goto cg0nu;
       cg0nt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0nu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$cp1Ord_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0nv,
                       label: Data.Functor.Sum.$fOrdSum_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0nv: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg0nz; else goto cg0ny;
       cg0nz: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$cp1Ord_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0ny: // global
           I64[Hp - 64] = sat_sfXSq_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sfXSp_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sfXSo_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Sum.$fEqSum_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.747293014 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c<_closure" {
     Data.Functor.Sum.$fOrdSum_$c<_closure:
         const Data.Functor.Sum.$fOrdSum_$c<_info;
 },
 sat_sfXSA_entry() //  [R1]
         { info_tbl: [(cg0o8,
                       label: sat_sfXSA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0o8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0o9; else goto cg0oa;
       cg0o9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0oa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXSH_entry() //  [R1]
         { info_tbl: [(cg0on,
                       label: sat_sfXSH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0on: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0oo; else goto cg0op;
       cg0oo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0op: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg0ou,
                       label: Data.Functor.Sum.$fOrdSum_$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0ou: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0ov; else goto cg0ow;
       cg0ov: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0ow: // global
           I64[Sp - 40] = block_cg0nU_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0pq; else goto cg0nV;
       ug0pq: // global
           call _cg0nU(R1) args: 0, res: 0, upd: 0;
       cg0nV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0nU() //  [R1]
         { info_tbl: [(cg0nU,
                       label: block_cg0nU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0nU: // global
           _sfXSv::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg0or; else goto cg0os;
       cg0or: // global
           I64[Sp] = block_cg0nZ_info;
           _sfXSx::P64 = P64[R1 + 7];
           R1 = _sfXSv::P64;
           P64[Sp + 32] = _sfXSx::P64;
           if (R1 & 7 != 0) goto ug0pm; else goto cg0o0;
       ug0pm: // global
           call _cg0nZ(R1) args: 0, res: 0, upd: 0;
       cg0o0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg0os: // global
           I64[Sp + 8] = block_cg0od_info;
           _sfXSD::P64 = P64[R1 + 6];
           R1 = _sfXSv::P64;
           P64[Sp + 32] = _sfXSD::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug0pn; else goto cg0oe;
       ug0pn: // global
           call _cg0od(R1) args: 0, res: 0, upd: 0;
       cg0oe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0nZ() //  [R1]
         { info_tbl: [(cg0nZ,
                       label: block_cg0nZ_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0nZ: // global
           if (R1 & 7 == 1) goto cg0oA; else goto ug0pj;
       cg0oA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0oD; else goto cg0oC;
       cg0oD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0oC: // global
           _sfXSz::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXSA_info;
           P64[Hp] = P64[Sp + 24];
           _sfXSx::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg0oy_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sfXSx::P64;
           P64[Sp + 24] = _sfXSz::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug0pj: // global
           Sp = Sp + 40;
           call _cg0pb() args: 0, res: 0, upd: 0;
     }
 },
 _cg0oy() //  [R1]
         { info_tbl: [(cg0oy,
                       label: block_cg0oy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0oy: // global
           if (R1 & 7 == 1) goto ug0pk; else goto ug0pl;
       ug0pk: // global
           Sp = Sp + 8;
           call _cg0pb() args: 0, res: 0, upd: 0;
       ug0pl: // global
           Sp = Sp + 8;
           call _cg0p7() args: 0, res: 0, upd: 0;
     }
 },
 _cg0od() //  [R1]
         { info_tbl: [(cg0od,
                       label: block_cg0od_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0od: // global
           if (R1 & 7 == 1) goto ug0pg; else goto cg0oY;
       ug0pg: // global
           Sp = Sp + 32;
           call _cg0p7() args: 0, res: 0, upd: 0;
       cg0oY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0p1; else goto cg0p0;
       cg0p1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0p0: // global
           _sfXSG::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXSH_info;
           P64[Hp] = P64[Sp + 16];
           _sfXSD::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cg0oX_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sfXSD::P64;
           P64[Sp + 16] = _sfXSG::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg0oX() //  [R1]
         { info_tbl: [(cg0oX,
                       label: block_cg0oX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0oX: // global
           if (R1 & 7 == 1) goto ug0ph; else goto ug0pi;
       ug0ph: // global
           Sp = Sp + 8;
           call _cg0pb() args: 0, res: 0, upd: 0;
       ug0pi: // global
           Sp = Sp + 8;
           call _cg0p7() args: 0, res: 0, upd: 0;
     }
 },
 _cg0pb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0pb: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg0p7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0p7: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.769125876 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c>=_closure" {
     Data.Functor.Sum.$fOrdSum_$c>=_closure:
         const Data.Functor.Sum.$fOrdSum_$c>=_info;
 },
 sat_sfXSS_entry() //  [R1]
         { info_tbl: [(cg0qC,
                       label: sat_sfXSS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0qC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0qD; else goto cg0qE;
       cg0qD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0qE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXSZ_entry() //  [R1]
         { info_tbl: [(cg0qR,
                       label: sat_sfXSZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0qR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0qS; else goto cg0qT;
       cg0qS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0qT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c>=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg0qY,
                       label: Data.Functor.Sum.$fOrdSum_$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0qY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0qZ; else goto cg0r0;
       cg0qZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0r0: // global
           I64[Sp - 40] = block_cg0qo_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0rU; else goto cg0qp;
       ug0rU: // global
           call _cg0qo(R1) args: 0, res: 0, upd: 0;
       cg0qp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0qo() //  [R1]
         { info_tbl: [(cg0qo,
                       label: block_cg0qo_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0qo: // global
           _sfXSN::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg0qV; else goto cg0qW;
       cg0qV: // global
           I64[Sp] = block_cg0qt_info;
           _sfXSP::P64 = P64[R1 + 7];
           R1 = _sfXSN::P64;
           P64[Sp + 32] = _sfXSP::P64;
           if (R1 & 7 != 0) goto ug0rQ; else goto cg0qu;
       ug0rQ: // global
           call _cg0qt(R1) args: 0, res: 0, upd: 0;
       cg0qu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg0qW: // global
           I64[Sp + 8] = block_cg0qH_info;
           _sfXSV::P64 = P64[R1 + 6];
           R1 = _sfXSN::P64;
           P64[Sp + 32] = _sfXSV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug0rR; else goto cg0qI;
       ug0rR: // global
           call _cg0qH(R1) args: 0, res: 0, upd: 0;
       cg0qI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0qt() //  [R1]
         { info_tbl: [(cg0qt,
                       label: block_cg0qt_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0qt: // global
           if (R1 & 7 == 1) goto cg0r4; else goto ug0rN;
       cg0r4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0r7; else goto cg0r6;
       cg0r7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0r6: // global
           _sfXSR::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXSS_info;
           P64[Hp] = P64[Sp + 24];
           _sfXSP::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg0r2_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sfXSP::P64;
           P64[Sp + 24] = _sfXSR::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug0rN: // global
           Sp = Sp + 40;
           call _cg0rF() args: 0, res: 0, upd: 0;
     }
 },
 _cg0r2() //  [R1]
         { info_tbl: [(cg0r2,
                       label: block_cg0r2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0r2: // global
           if (R1 & 7 == 1) goto ug0rO; else goto ug0rP;
       ug0rO: // global
           Sp = Sp + 8;
           call _cg0rF() args: 0, res: 0, upd: 0;
       ug0rP: // global
           Sp = Sp + 8;
           call _cg0rB() args: 0, res: 0, upd: 0;
     }
 },
 _cg0qH() //  [R1]
         { info_tbl: [(cg0qH,
                       label: block_cg0qH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0qH: // global
           if (R1 & 7 == 1) goto ug0rK; else goto cg0rs;
       ug0rK: // global
           Sp = Sp + 32;
           call _cg0rB() args: 0, res: 0, upd: 0;
       cg0rs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0rv; else goto cg0ru;
       cg0rv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0ru: // global
           _sfXSY::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXSZ_info;
           P64[Hp] = P64[Sp + 16];
           _sfXSV::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cg0rr_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sfXSV::P64;
           P64[Sp + 16] = _sfXSY::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg0rr() //  [R1]
         { info_tbl: [(cg0rr,
                       label: block_cg0rr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0rr: // global
           if (R1 & 7 == 1) goto ug0rL; else goto ug0rM;
       ug0rL: // global
           Sp = Sp + 8;
           call _cg0rF() args: 0, res: 0, upd: 0;
       ug0rM: // global
           Sp = Sp + 8;
           call _cg0rB() args: 0, res: 0, upd: 0;
     }
 },
 _cg0rF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0rF: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg0rB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0rB: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.79011131 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c>_closure" {
     Data.Functor.Sum.$fOrdSum_$c>_closure:
         const Data.Functor.Sum.$fOrdSum_$c>_info;
 },
 sat_sfXTa_entry() //  [R1]
         { info_tbl: [(cg0t6,
                       label: sat_sfXTa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0t6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0t7; else goto cg0t8;
       cg0t7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0t8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXTh_entry() //  [R1]
         { info_tbl: [(cg0tl,
                       label: sat_sfXTh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0tl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0tm; else goto cg0tn;
       cg0tm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0tn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg0ts,
                       label: Data.Functor.Sum.$fOrdSum_$c>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0ts: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0tt; else goto cg0tu;
       cg0tt: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0tu: // global
           I64[Sp - 40] = block_cg0sS_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0uo; else goto cg0sT;
       ug0uo: // global
           call _cg0sS(R1) args: 0, res: 0, upd: 0;
       cg0sT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0sS() //  [R1]
         { info_tbl: [(cg0sS,
                       label: block_cg0sS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0sS: // global
           _sfXT5::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg0tp; else goto cg0tq;
       cg0tp: // global
           I64[Sp] = block_cg0sX_info;
           _sfXT7::P64 = P64[R1 + 7];
           R1 = _sfXT5::P64;
           P64[Sp + 32] = _sfXT7::P64;
           if (R1 & 7 != 0) goto ug0uk; else goto cg0sY;
       ug0uk: // global
           call _cg0sX(R1) args: 0, res: 0, upd: 0;
       cg0sY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg0tq: // global
           I64[Sp + 8] = block_cg0tb_info;
           _sfXTd::P64 = P64[R1 + 6];
           R1 = _sfXT5::P64;
           P64[Sp + 32] = _sfXTd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug0ul; else goto cg0tc;
       ug0ul: // global
           call _cg0tb(R1) args: 0, res: 0, upd: 0;
       cg0tc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0sX() //  [R1]
         { info_tbl: [(cg0sX,
                       label: block_cg0sX_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0sX: // global
           if (R1 & 7 == 1) goto cg0ty; else goto ug0uh;
       cg0ty: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0tB; else goto cg0tA;
       cg0tB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0tA: // global
           _sfXT9::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXTa_info;
           P64[Hp] = P64[Sp + 24];
           _sfXT7::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg0tw_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sfXT7::P64;
           P64[Sp + 24] = _sfXT9::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug0uh: // global
           Sp = Sp + 40;
           call _cg0u5() args: 0, res: 0, upd: 0;
     }
 },
 _cg0tw() //  [R1]
         { info_tbl: [(cg0tw,
                       label: block_cg0tw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0tw: // global
           if (R1 & 7 == 3) goto ug0ui; else goto ug0uj;
       ug0ui: // global
           Sp = Sp + 8;
           call _cg0u9() args: 0, res: 0, upd: 0;
       ug0uj: // global
           Sp = Sp + 8;
           call _cg0u5() args: 0, res: 0, upd: 0;
     }
 },
 _cg0tb() //  [R1]
         { info_tbl: [(cg0tb,
                       label: block_cg0tb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0tb: // global
           if (R1 & 7 == 1) goto ug0ue; else goto cg0tW;
       ug0ue: // global
           Sp = Sp + 32;
           call _cg0u9() args: 0, res: 0, upd: 0;
       cg0tW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0tZ; else goto cg0tY;
       cg0tZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0tY: // global
           _sfXTg::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXTh_info;
           P64[Hp] = P64[Sp + 16];
           _sfXTd::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cg0tV_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sfXTd::P64;
           P64[Sp + 16] = _sfXTg::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg0tV() //  [R1]
         { info_tbl: [(cg0tV,
                       label: block_cg0tV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0tV: // global
           if (R1 & 7 == 3) goto ug0uf; else goto ug0ug;
       ug0uf: // global
           Sp = Sp + 8;
           call _cg0u9() args: 0, res: 0, upd: 0;
       ug0ug: // global
           Sp = Sp + 8;
           call _cg0u5() args: 0, res: 0, upd: 0;
     }
 },
 _cg0u9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0u9: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg0u5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0u5: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.81152126 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c<=_closure" {
     Data.Functor.Sum.$fOrdSum_$c<=_closure:
         const Data.Functor.Sum.$fOrdSum_$c<=_info;
 },
 sat_sfXTs_entry() //  [R1]
         { info_tbl: [(cg0vA,
                       label: sat_sfXTs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0vA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0vB; else goto cg0vC;
       cg0vB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0vC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXTz_entry() //  [R1]
         { info_tbl: [(cg0vP,
                       label: sat_sfXTz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0vP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0vQ; else goto cg0vR;
       cg0vQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0vR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg0vW,
                       label: Data.Functor.Sum.$fOrdSum_$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0vW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0vX; else goto cg0vY;
       cg0vX: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0vY: // global
           I64[Sp - 40] = block_cg0vm_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0wS; else goto cg0vn;
       ug0wS: // global
           call _cg0vm(R1) args: 0, res: 0, upd: 0;
       cg0vn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0vm() //  [R1]
         { info_tbl: [(cg0vm,
                       label: block_cg0vm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0vm: // global
           _sfXTn::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg0vT; else goto cg0vU;
       cg0vT: // global
           I64[Sp] = block_cg0vr_info;
           _sfXTp::P64 = P64[R1 + 7];
           R1 = _sfXTn::P64;
           P64[Sp + 32] = _sfXTp::P64;
           if (R1 & 7 != 0) goto ug0wO; else goto cg0vs;
       ug0wO: // global
           call _cg0vr(R1) args: 0, res: 0, upd: 0;
       cg0vs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg0vU: // global
           I64[Sp + 8] = block_cg0vF_info;
           _sfXTv::P64 = P64[R1 + 6];
           R1 = _sfXTn::P64;
           P64[Sp + 32] = _sfXTv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug0wP; else goto cg0vG;
       ug0wP: // global
           call _cg0vF(R1) args: 0, res: 0, upd: 0;
       cg0vG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0vr() //  [R1]
         { info_tbl: [(cg0vr,
                       label: block_cg0vr_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0vr: // global
           if (R1 & 7 == 1) goto cg0w2; else goto ug0wL;
       cg0w2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0w5; else goto cg0w4;
       cg0w5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0w4: // global
           _sfXTr::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sfXTs_info;
           P64[Hp] = P64[Sp + 24];
           _sfXTp::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg0w0_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sfXTp::P64;
           P64[Sp + 24] = _sfXTr::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug0wL: // global
           Sp = Sp + 40;
           call _cg0wz() args: 0, res: 0, upd: 0;
     }
 },
 _cg0w0() //  [R1]
         { info_tbl: [(cg0w0,
                       label: block_cg0w0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0w0: // global
           if (R1 & 7 == 3) goto ug0wM; else goto ug0wN;
       ug0wM: // global
           Sp = Sp + 8;
           call _cg0wD() args: 0, res: 0, upd: 0;
       ug0wN: // global
           Sp = Sp + 8;
           call _cg0wz() args: 0, res: 0, upd: 0;
     }
 },
 _cg0vF() //  [R1]
         { info_tbl: [(cg0vF,
                       label: block_cg0vF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0vF: // global
           if (R1 & 7 == 1) goto ug0wI; else goto cg0wq;
       ug0wI: // global
           Sp = Sp + 32;
           call _cg0wD() args: 0, res: 0, upd: 0;
       cg0wq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg0wt; else goto cg0ws;
       cg0wt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0ws: // global
           _sfXTy::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sfXTz_info;
           P64[Hp] = P64[Sp + 16];
           _sfXTv::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cg0wp_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sfXTv::P64;
           P64[Sp + 16] = _sfXTy::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg0wp() //  [R1]
         { info_tbl: [(cg0wp,
                       label: block_cg0wp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0wp: // global
           if (R1 & 7 == 3) goto ug0wJ; else goto ug0wK;
       ug0wJ: // global
           Sp = Sp + 8;
           call _cg0wD() args: 0, res: 0, upd: 0;
       ug0wK: // global
           Sp = Sp + 8;
           call _cg0wz() args: 0, res: 0, upd: 0;
     }
 },
 _cg0wD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0wD: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg0wz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0wz: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.831497703 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$cmax_closure" {
     Data.Functor.Sum.$fOrdSum_$cmax_closure:
         const Data.Functor.Sum.$fOrdSum_$cmax_info;
 },
 Data.Functor.Sum.$fOrdSum_$cmax_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg0xW,
                       label: Data.Functor.Sum.$fOrdSum_$cmax_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0xW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg0xX; else goto cg0xY;
       cg0xX: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$cmax_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0xY: // global
           I64[Sp - 24] = block_cg0xQ_info;
           _sfXTF::P64 = R6;
           R6 = R6;
           _sfXTE::P64 = R5;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           P64[Sp - 16] = _sfXTE::P64;
           P64[Sp - 8] = _sfXTF::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fOrdSum_$c<=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg0xQ() //  [R1]
         { info_tbl: [(cg0xQ,
                       label: block_cg0xQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0xQ: // global
           if (R1 & 7 == 1) goto cg0xT; else goto cg0xU;
       cg0xT: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cg0xU: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.838268533 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$cmin_closure" {
     Data.Functor.Sum.$fOrdSum_$cmin_closure:
         const Data.Functor.Sum.$fOrdSum_$cmin_info;
 },
 Data.Functor.Sum.$fOrdSum_$cmin_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg0yt,
                       label: Data.Functor.Sum.$fOrdSum_$cmin_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0yt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg0yu; else goto cg0yv;
       cg0yu: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$cmin_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0yv: // global
           I64[Sp - 24] = block_cg0yn_info;
           _sfXTL::P64 = R6;
           R6 = R6;
           _sfXTK::P64 = R5;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           P64[Sp - 16] = _sfXTK::P64;
           P64[Sp - 8] = _sfXTL::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fOrdSum_$c<=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg0yn() //  [R1]
         { info_tbl: [(cg0yn,
                       label: block_cg0yn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0yn: // global
           if (R1 & 7 == 1) goto cg0yq; else goto cg0yr;
       cg0yq: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cg0yr: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.846409952 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_closure" {
     Data.Functor.Sum.$fOrdSum_closure:
         const Data.Functor.Sum.$fOrdSum_info;
 },
 sat_sfXTX_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0yZ,
                       label: sat_sfXTX_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0yZ: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$cmin_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTW_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0z7,
                       label: sat_sfXTW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0z7: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$cmax_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTV_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0zf,
                       label: sat_sfXTV_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0zf: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c>=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTU_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0zn,
                       label: sat_sfXTU_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0zn: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c>_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTT_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0zv,
                       label: sat_sfXTT_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0zv: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c<=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTS_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0zD,
                       label: sat_sfXTS_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0zD: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c<_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTR_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0zL,
                       label: sat_sfXTR_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0zL: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$ccompare_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXTQ_entry() //  [R1]
         { info_tbl: [(cg0zS,
                       label: sat_sfXTQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0zS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0zT; else goto cg0zU;
       cg0zT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0zU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fOrdSum_$cp1Ord_entry(R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0zW,
                       label: Data.Functor.Sum.$fOrdSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0zW: // global
           Hp = Hp + 336;
           if (Hp > HpLim) (likely: False) goto cg0A0; else goto cg0zZ;
       cg0A0: // global
           HpAlloc = 336;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0zZ: // global
           I64[Hp - 328] = sat_sfXTX_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           I64[Hp - 296] = sat_sfXTW_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           P64[Hp - 272] = R4;
           I64[Hp - 264] = sat_sfXTV_info;
           P64[Hp - 256] = R2;
           P64[Hp - 248] = R3;
           P64[Hp - 240] = R4;
           I64[Hp - 232] = sat_sfXTU_info;
           P64[Hp - 224] = R2;
           P64[Hp - 216] = R3;
           P64[Hp - 208] = R4;
           I64[Hp - 200] = sat_sfXTT_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           P64[Hp - 176] = R4;
           I64[Hp - 168] = sat_sfXTS_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = sat_sfXTR_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sat_sfXTQ_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 104;
           P64[Hp - 48] = Hp - 134;
           P64[Hp - 40] = Hp - 166;
           P64[Hp - 32] = Hp - 198;
           P64[Hp - 24] = Hp - 230;
           P64[Hp - 16] = Hp - 262;
           P64[Hp - 8] = Hp - 294;
           P64[Hp] = Hp - 326;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.865498484 UTC

[section ""data" . Data.Functor.Sum.$fReadSum1_closure" {
     Data.Functor.Sum.$fReadSum1_closure:
         const Data.Functor.Sum.$fReadSum1_info;
         const 0;
 },
 sat_sfXU2_entry() //  [R1]
         { info_tbl: [(cg0AL,
                       label: sat_sfXU2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0AL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0AM; else goto cg0AN;
       cg0AM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0AN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXU1_entry() //  [R1]
         { info_tbl: [(cg0AS,
                       label: sat_sfXU1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0AS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0AT; else goto cg0AU;
       cg0AT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0AU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fReadSum1_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0AV,
                       label: Data.Functor.Sum.$fReadSum1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0AV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg0AZ; else goto cg0AY;
       cg0AZ: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0AY: // global
           I64[Hp - 40] = sat_sfXU2_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sfXU1_info;
           P64[Hp] = R4;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.874317521 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_$creadsPrec_closure" {
     Data.Functor.Sum.$fReadSum_$creadsPrec_closure:
         const Data.Functor.Sum.$fReadSum_$creadsPrec_info;
         const 0;
 },
 sat_sfXU8_entry() //  [R1]
         { info_tbl: [(cg0Bo,
                       label: sat_sfXU8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Bo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0Bp; else goto cg0Bq;
       cg0Bp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Bq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXU7_entry() //  [R1]
         { info_tbl: [(cg0Bv,
                       label: sat_sfXU7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Bv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0Bw; else goto cg0Bx;
       cg0Bw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Bx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sfXU6_entry() //  [R1]
         { info_tbl: [(cg0By,
                       label: ds_sfXU6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0By: // global
           _sfXU6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg0Bz; else goto cg0BA;
       cg0BA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg0BC; else goto cg0BB;
       cg0BC: // global
           HpAlloc = 48;
           goto cg0Bz;
       cg0Bz: // global
           R1 = _sfXU6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0BB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXU6::P64;
           _sfXU3::P64 = P64[_sfXU6::P64 + 16];
           _sfXU4::P64 = P64[_sfXU6::P64 + 24];
           _sfXU5::P64 = P64[_sfXU6::P64 + 32];
           I64[Hp - 40] = sat_sfXU8_info;
           P64[Hp - 24] = _sfXU5::P64;
           I64[Hp - 16] = sat_sfXU7_info;
           P64[Hp] = _sfXU5::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sfXU4::P64;
           R2 = _sfXU3::P64;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUa_entry() //  [R1]
         { info_tbl: [(cg0BM,
                       label: sat_sfXUa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0BM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0BN; else goto cg0BO;
       cg0BN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0BO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUb_entry() //  [R1, R2]
         { info_tbl: [(cg0BP,
                       label: sat_sfXUb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0BP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg0BT; else goto cg0BS;
       cg0BT: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg0BS: // global
           _sfXU6::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sfXUa_info;
           P64[Hp - 8] = _sfXU6::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fReadSum_$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0BU,
                       label: Data.Functor.Sum.$fReadSum_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0BU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg0BY; else goto cg0BX;
       cg0BY: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0BX: // global
           I64[Hp - 48] = ds_sfXU6_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sfXUb_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.88946544 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_$creadListPrec_closure" {
     Data.Functor.Sum.$fReadSum_$creadListPrec_closure:
         const Data.Functor.Sum.$fReadSum_$creadListPrec_info;
         const 0;
 },
 sat_sfXUg_entry() //  [R1]
         { info_tbl: [(cg0CA,
                       label: sat_sfXUg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0CA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0CB; else goto cg0CC;
       cg0CB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0CC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUf_entry() //  [R1]
         { info_tbl: [(cg0CH,
                       label: sat_sfXUf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0CH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0CI; else goto cg0CJ;
       cg0CI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0CJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUh_entry() //  [R1]
         { info_tbl: [(cg0CK,
                       label: sat_sfXUh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0CK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg0CO; else goto cg0CN;
       cg0CO: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0CN: // global
           _sfXUc::P64 = P64[R1 + 16];
           _sfXUd::P64 = P64[R1 + 24];
           _sfXUe::P64 = P64[R1 + 32];
           I64[Hp - 40] = sat_sfXUg_info;
           P64[Hp - 24] = _sfXUe::P64;
           I64[Hp - 16] = sat_sfXUf_info;
           P64[Hp] = _sfXUe::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sfXUd::P64;
           R2 = _sfXUc::P64;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fReadSum_$creadListPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0CP,
                       label: Data.Functor.Sum.$fReadSum_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0CP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg0CT; else goto cg0CS;
       cg0CT: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_$creadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0CS: // global
           I64[Hp - 32] = sat_sfXUh_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.899428526 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_$creadList_closure" {
     Data.Functor.Sum.$fReadSum_$creadList_closure:
         const Data.Functor.Sum.$fReadSum_$creadList_info;
         const 0;
 },
 sat_sfXUl_entry() //  [R1]
         { info_tbl: [(cg0Dh,
                       label: sat_sfXUl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Dh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0Di; else goto cg0Dj;
       cg0Di: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Dj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call Data.Functor.Sum.$fReadSum_$creadListPrec_entry(R4,
                                                                R3,
                                                                R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fReadSum_$creadList_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0Dk,
                       label: Data.Functor.Sum.$fReadSum_$creadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Dk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg0Do; else goto cg0Dn;
       cg0Do: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_$creadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0Dn: // global
           I64[Hp - 32] = sat_sfXUl_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.906703474 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_closure" {
     Data.Functor.Sum.$fReadSum_closure:
         const Data.Functor.Sum.$fReadSum_info;
         const 0;
 },
 sat_sfXUs_entry() //  [R1]
         { info_tbl: [(cg0DF,
                       label: sat_sfXUs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0DF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0DG; else goto cg0DH;
       cg0DG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0DH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum_$creadListPrec_entry(R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUr_entry() //  [R1]
         { info_tbl: [(cg0DM,
                       label: sat_sfXUr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0DM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0DN; else goto cg0DO;
       cg0DN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0DO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum1_entry(R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUq_entry() //  [R1]
         { info_tbl: [(cg0DT,
                       label: sat_sfXUq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0DT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0DU; else goto cg0DV;
       cg0DU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0DV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum_$creadList_entry(R4,
                                                            R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUp_entry() //  [R1]
         { info_tbl: [(cg0E0,
                       label: sat_sfXUp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0E0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0E1; else goto cg0E2;
       cg0E1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0E2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum_$creadsPrec_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fReadSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0E4,
                       label: Data.Functor.Sum.$fReadSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0E4: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cg0E8; else goto cg0E7;
       cg0E8: // global
           HpAlloc = 200;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0E7: // global
           I64[Hp - 192] = sat_sfXUs_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           I64[Hp - 152] = sat_sfXUr_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_sfXUq_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sfXUp_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.919396433 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_$cshowsPrec_closure" {
     Data.Functor.Sum.$fShowSum_$cshowsPrec_closure:
         const Data.Functor.Sum.$fShowSum_$cshowsPrec_info;
         const 0;
 },
 sat_sfXUB_entry() //  [R1]
         { info_tbl: [(cg0EL,
                       label: sat_sfXUB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0EL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0EM; else goto cg0EN;
       cg0EM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0EN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUA_entry() //  [R1]
         { info_tbl: [(cg0ES,
                       label: sat_sfXUA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0ES: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0ET; else goto cg0EU;
       cg0ET: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0EU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fShowSum_$cshowsPrec_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg0EV,
                       label: Data.Functor.Sum.$fShowSum_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0EV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0EW; else goto cg0EX;
       cg0EW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_$cshowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0EX: // global
           I64[Sp - 40] = block_cg0EC_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0F1; else goto cg0ED;
       ug0F1: // global
           call _cg0EC(R1) args: 0, res: 0, upd: 0;
       cg0ED: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0EC() //  [R1]
         { info_tbl: [(cg0EC,
                       label: block_cg0EC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0EC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg0F0; else goto cg0EZ;
       cg0F0: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0EZ: // global
           _sfXUz::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sfXUB_info;
           _sfXUv::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sfXUv::P64;
           I64[Hp - 16] = sat_sfXUA_info;
           P64[Hp] = _sfXUv::P64;
           R6 = _sfXUz::I64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.931728269 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_$cshow_closure" {
     Data.Functor.Sum.$fShowSum_$cshow_closure:
         const Data.Functor.Sum.$fShowSum_$cshow_info;
         const 0;
 },
 sat_sfXUJ_entry() //  [R1]
         { info_tbl: [(cg0FA,
                       label: sat_sfXUJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0FA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0FB; else goto cg0FC;
       cg0FB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0FC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUI_entry() //  [R1]
         { info_tbl: [(cg0FH,
                       label: sat_sfXUI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0FH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0FI; else goto cg0FJ;
       cg0FI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0FJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUK_entry() //  [R1]
         { info_tbl: [(cg0FK,
                       label: sat_sfXUK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0FK: // global
           _sfXUK::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cg0FL; else goto cg0FM;
       cg0FM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg0FO; else goto cg0FN;
       cg0FO: // global
           HpAlloc = 48;
           goto cg0FL;
       cg0FL: // global
           R1 = _sfXUK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0FN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXUK::P64;
           _sfXUC::P64 = P64[_sfXUK::P64 + 16];
           _sfXUE::P64 = P64[_sfXUK::P64 + 24];
           _sfXUH::P64 = P64[_sfXUK::P64 + 32];
           I64[Hp - 40] = sat_sfXUJ_info;
           P64[Hp - 24] = _sfXUE::P64;
           I64[Hp - 16] = sat_sfXUI_info;
           P64[Hp] = _sfXUE::P64;
           R2 = _sfXUC::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = Hp - 16;
           P64[Sp - 48] = Hp - 40;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sfXUH::P64;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 sat_sfXUO_entry() //  [R1]
         { info_tbl: [(cg0FZ,
                       label: sat_sfXUO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0FZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0G0; else goto cg0G1;
       cg0G0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0G1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUN_entry() //  [R1]
         { info_tbl: [(cg0G6,
                       label: sat_sfXUN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0G6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0G7; else goto cg0G8;
       cg0G7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0G8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUP_entry() //  [R1]
         { info_tbl: [(cg0G9,
                       label: sat_sfXUP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0G9: // global
           _sfXUP::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cg0Ga; else goto cg0Gb;
       cg0Gb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg0Gd; else goto cg0Gc;
       cg0Gd: // global
           HpAlloc = 48;
           goto cg0Ga;
       cg0Ga: // global
           R1 = _sfXUP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Gc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfXUP::P64;
           _sfXUD::P64 = P64[_sfXUP::P64 + 16];
           _sfXUE::P64 = P64[_sfXUP::P64 + 24];
           _sfXUM::P64 = P64[_sfXUP::P64 + 32];
           I64[Hp - 40] = sat_sfXUO_info;
           P64[Hp - 24] = _sfXUE::P64;
           I64[Hp - 16] = sat_sfXUN_info;
           P64[Hp] = _sfXUE::P64;
           R2 = _sfXUD::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = Hp - 16;
           P64[Sp - 48] = Hp - 40;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sfXUM::P64;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fShowSum_$cshow_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg0Gi,
                       label: Data.Functor.Sum.$fShowSum_$cshow_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Gi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg0Gj; else goto cg0Gk;
       cg0Gj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_$cshow_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0Gk: // global
           I64[Sp - 32] = block_cg0Fn_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug0Gt; else goto cg0Fo;
       ug0Gt: // global
           call _cg0Fn(R1) args: 0, res: 0, upd: 0;
       cg0Fo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0Fn() //  [R1]
         { info_tbl: [(cg0Fn,
                       label: block_cg0Fn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Fn: // global
           _sfXUE::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg0Gf; else goto cg0Gg;
       cg0Gf: // global
           Hp = Hp + 64;
           _sfXUG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg0Gs; else goto cg0Gn;
       cg0Gn: // global
           _sfXUH::P64 = P64[_sfXUG::P64 + 7];
           I64[Hp - 56] = sat_sfXUK_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sfXUE::P64;
           P64[Hp - 24] = _sfXUH::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = Data.Functor.Sum.$fRead1Sum7_closure;
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cg0Gg: // global
           Hp = Hp + 64;
           _sfXUG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg0Gs; else goto cg0Gr;
       cg0Gs: // global
           HpAlloc = 64;
           R1 = _sfXUG::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0Gr: // global
           _sfXUM::P64 = P64[_sfXUG::P64 + 6];
           I64[Hp - 56] = sat_sfXUP_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = _sfXUE::P64;
           P64[Hp - 24] = _sfXUM::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = Data.Functor.Sum.$fRead1Sum3_closure;
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.952120713 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_$cshowList_closure" {
     Data.Functor.Sum.$fShowSum_$cshowList_closure:
         const Data.Functor.Sum.$fShowSum_$cshowList_info;
         const 0;
 },
 lvl8_sfXUW_entry() //  [R1]
         { info_tbl: [(cg0Hj,
                       label: lvl8_sfXUW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Hj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0Hk; else goto cg0Hl;
       cg0Hk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Hl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sfXUX_entry() //  [R1]
         { info_tbl: [(cg0Hq,
                       label: lvl9_sfXUX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Hq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0Hr; else goto cg0Hs;
       cg0Hr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Hs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXUZ_entry() //  [R1, R2]
         { info_tbl: [(cg0Hy,
                       label: sat_sfXUZ_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Hy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg0Hz; else goto cg0HA;
       cg0Hz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg0HA: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sfXUY::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sfXUY::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShowSum_$cshowList_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg0HB,
                       label: Data.Functor.Sum.$fShowSum_$cshowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0HB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg0HF; else goto cg0HE;
       cg0HF: // global
           HpAlloc = 88;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_$cshowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0HE: // global
           I64[Hp - 80] = lvl8_sfXUW_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl9_sfXUX_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sfXUZ_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 31;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.962904876 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_closure" {
     Data.Functor.Sum.$fShowSum_closure:
         const Data.Functor.Sum.$fShowSum_info;
         const 0;
 },
 sat_sfXV5_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0I7,
                       label: sat_sfXV5_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0I7: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fShowSum_$cshowList_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXV4_entry() //  [R1, R2]
         { info_tbl: [(cg0If,
                       label: sat_sfXV4_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0If: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fShowSum_$cshow_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXV3_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0In,
                       label: sat_sfXV3_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0In: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fShowSum_$cshowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShowSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0Ir,
                       label: Data.Functor.Sum.$fShowSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Ir: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg0Iv; else goto cg0Iu;
       cg0Iv: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0Iu: // global
           I64[Hp - 120] = sat_sfXV5_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sfXV4_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sfXV3_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 118;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.973830272 UTC

[section ""data" . Data.Functor.Sum.$fFunctorSum_$cfmap_closure" {
     Data.Functor.Sum.$fFunctorSum_$cfmap_closure:
         const Data.Functor.Sum.$fFunctorSum_$cfmap_info;
 },
 sat_sfXVc_entry() //  [R1]
         { info_tbl: [(cg0J0,
                       label: sat_sfXVc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0J0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0J1; else goto cg0J2;
       cg0J1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0J2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sfXVe_entry() //  [R1]
         { info_tbl: [(cg0J9,
                       label: sat_sfXVe_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0J9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0Ja; else goto cg0Jb;
       cg0Ja: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Jb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fFunctorSum_$cfmap_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg0Jg,
                       label: Data.Functor.Sum.$fFunctorSum_$cfmap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Jg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg0Jh; else goto cg0Ji;
       cg0Jh: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFunctorSum_$cfmap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0Ji: // global
           I64[Sp - 32] = block_cg0IR_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug0Jr; else goto cg0IS;
       ug0Jr: // global
           call _cg0IR(R1) args: 0, res: 0, upd: 0;
       cg0IS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0IR() //  [R1]
         { info_tbl: [(cg0IR,
                       label: block_cg0IR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0IR: // global
           _sfXV8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg0Jd; else goto cg0Je;
       cg0Jd: // global
           Hp = Hp + 56;
           _sfXVa::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg0Jq; else goto cg0Jl;
       cg0Jl: // global
           _sfXVb::P64 = P64[_sfXVa::P64 + 7];
           I64[Hp - 48] = sat_sfXVc_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sfXV8::P64;
           P64[Hp - 16] = _sfXVb::P64;
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg0Je: // global
           Hp = Hp + 56;
           _sfXVa::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg0Jq; else goto cg0Jp;
       cg0Jq: // global
           HpAlloc = 56;
           R1 = _sfXVa::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0Jp: // global
           _sfXVd::P64 = P64[_sfXVa::P64 + 6];
           I64[Hp - 48] = sat_sfXVe_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sfXV8::P64;
           P64[Hp - 16] = _sfXVd::P64;
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.985589626 UTC

[section ""data" . Data.Functor.Sum.$fFunctorSum_$c<$_closure" {
     Data.Functor.Sum.$fFunctorSum_$c<$_closure:
         const Data.Functor.Sum.$fFunctorSum_$c<$_info;
 },
 sat_sfXVk_entry() //  [R1]
         { info_tbl: [(cg0K4,
                       label: sat_sfXVk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0K4: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFunctorSum_$c<$_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg0K7,
                       label: Data.Functor.Sum.$fFunctorSum_$c<$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0K7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg0Kb; else goto cg0Ka;
       cg0Kb: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFunctorSum_$c<$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0Ka: // global
           I64[Hp - 8] = sat_sfXVk_info;
           P64[Hp] = R4;
           R5 = R5;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fFunctorSum_$cfmap_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:47.992833263 UTC

[section ""data" . Data.Functor.Sum.$fFunctorSum_closure" {
     Data.Functor.Sum.$fFunctorSum_closure:
         const Data.Functor.Sum.$fFunctorSum_info;
 },
 sat_sfXVo_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0Ks,
                       label: sat_sfXVo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Ks: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFunctorSum_$c<$_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXVn_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0KA,
                       label: sat_sfXVn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0KA: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFunctorSum_$cfmap_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFunctorSum_entry() //  [R2, R3]
         { info_tbl: [(cg0KE,
                       label: Data.Functor.Sum.$fFunctorSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0KE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg0KI; else goto cg0KH;
       cg0KI: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFunctorSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0KH: // global
           I64[Hp - 64] = sat_sfXVo_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sfXVn_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.001683807 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldMap_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldMap_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldMap_info;
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldMap_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cg0L7,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0L7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0L8; else goto cg0L9;
       cg0L8: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0L9: // global
           I64[Sp - 40] = block_cg0L0_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0Lg; else goto cg0L1;
       ug0Lg: // global
           call _cg0L0(R1) args: 0, res: 0, upd: 0;
       cg0L1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0L0() //  [R1]
         { info_tbl: [(cg0L0,
                       label: block_cg0L0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0L0: // global
           _sfXVr::P64 = P64[Sp + 24];
           _sfXVs::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg0L4; else goto cg0L5;
       cg0L4: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = _sfXVr::P64;
           P64[Sp + 24] = _sfXVs::P64;
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg0L5: // global
           R2 = P64[Sp + 16];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = _sfXVr::P64;
           P64[Sp + 24] = _sfXVs::P64;
           P64[Sp + 32] = P64[R1 + 6];
           Sp = Sp + 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.00889255 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfold_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfold_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfold_info;
 },
 Data.Functor.Sum.$fFoldableSum_$cfold_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg0LF,
                       label: Data.Functor.Sum.$fFoldableSum_$cfold_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0LF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg0LG; else goto cg0LH;
       cg0LG: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfold_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0LH: // global
           I64[Sp - 32] = block_cg0Ly_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug0LO; else goto cg0Lz;
       ug0LO: // global
           call _cg0Ly(R1) args: 0, res: 0, upd: 0;
       cg0Lz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0Ly() //  [R1]
         { info_tbl: [(cg0Ly,
                       label: block_cg0Ly_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Ly: // global
           _sfXVz::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg0LC; else goto cg0LD;
       cg0LC: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXVz::P64;
           P64[Sp + 16] = GHC.Base.id_closure+1;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg0LD: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXVz::P64;
           P64[Sp + 16] = GHC.Base.id_closure+1;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.015179008 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum2_closure" {
     Data.Functor.Sum.$fFoldableSum2_closure:
         const Data.Functor.Sum.$fFoldableSum2_info;
 },
 Data.Functor.Sum.$fFoldableSum2_entry() //  [R2]
         { info_tbl: [(cg0M6,
                       label: Data.Functor.Sum.$fFoldableSum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0M6: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.020479 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum3_closure" {
     Data.Functor.Sum.$fFoldableSum3_closure:
         const Data.Functor.Sum.$fFoldableSum3_info;
         const 0;
 },
 $dMonoid_sfXVI_entry() //  [R1]
         { info_tbl: [(cg0Ml,
                       label: $dMonoid_sfXVI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Ml: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0Mm; else goto cg0Mn;
       cg0Mm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Mn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXVN_entry() //  [R1, R2]
         { info_tbl: [(cg0MA,
                       label: sat_sfXVN_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0MA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg0MB; else goto cg0MC;
       cg0MB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg0MC: // global
           I64[Sp - 32] = block_cg0Mt_info;
           _sfXVF::P64 = P64[R1 + 7];
           _sfXVG::P64 = P64[R1 + 15];
           _sfXVI::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXVF::P64;
           P64[Sp - 16] = _sfXVG::P64;
           P64[Sp - 8] = _sfXVI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug0MJ; else goto cg0Mu;
       ug0MJ: // global
           call _cg0Mt(R1) args: 0, res: 0, upd: 0;
       cg0Mu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0Mt() //  [R1]
         { info_tbl: [(cg0Mt,
                       label: block_cg0Mt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Mt: // global
           _sfXVI::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg0Mx; else goto cg0My;
       cg0Mx: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXVI::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg0My: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXVI::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum3_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0MK,
                       label: Data.Functor.Sum.$fFoldableSum3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0MK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg0MO; else goto cg0MN;
       cg0MO: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0MN: // global
           I64[Hp - 48] = $dMonoid_sfXVI_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sfXVN_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.032358108 UTC

[section ""cstring" . lvl_rfXP1_bytes" {
     lvl_rfXP1_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.034691113 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum4_closure" {
     Data.Functor.Sum.$fFoldableSum4_closure:
         const Data.Functor.Sum.$fFoldableSum4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum4_entry() //  [R1]
         { info_tbl: [(cg0Nk,
                       label: Data.Functor.Sum.$fFoldableSum4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Nk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg0Nl; else goto cg0Nm;
       cg0Nl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Nm: // global
           (_cg0Nf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg0Nf::I64 == 0) goto cg0Nh; else goto cg0Ng;
       cg0Nh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg0Ng: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg0Nf::I64;
           I64[Sp - 24] = block_cg0Ni_info;
           R2 = lvl_rfXP1_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg0Ni() //  [R1]
         { info_tbl: [(cg0Ni,
                       label: block_cg0Ni_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Ni: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.043160299 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cminimum_closure" {
     Data.Functor.Sum.$fFoldableSum_$cminimum_closure:
         const Data.Functor.Sum.$fFoldableSum_$cminimum_info;
         const 0;
 },
 g1_sfXVS_entry() //  [R1]
         { info_tbl: [(cg0NI,
                       label: g1_sfXVS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0NI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0NJ; else goto cg0NK;
       cg0NJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0NK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXW1_entry() //  [R1, R2]
         { info_tbl: [(cg0NX,
                       label: sat_sfXW1_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0NX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0NY; else goto cg0NZ;
       cg0NY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg0NZ: // global
           I64[Sp - 32] = block_cg0NQ_info;
           _sfXVP::P64 = P64[R1 + 7];
           _sfXVQ::P64 = P64[R1 + 15];
           _sfXVS::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXVP::P64;
           P64[Sp - 16] = _sfXVQ::P64;
           P64[Sp - 8] = _sfXVS::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug0Ow; else goto cg0NR;
       ug0Ow: // global
           call _cg0NQ(R1) args: 0, res: 0, upd: 0;
       cg0NR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0NQ() //  [R1]
         { info_tbl: [(cg0NQ,
                       label: block_cg0NQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0NQ: // global
           _sfXVS::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg0NU; else goto cg0NV;
       cg0NU: // global
           I64[Sp + 24] = block_cg0O2_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sfXVS::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cg0NV: // global
           I64[Sp + 24] = block_cg0Og_info;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sfXVS::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 6];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg0O2() //  [R1]
         { info_tbl: [(cg0O2,
                       label: block_cg0O2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0O2: // global
           if (R1 & 7 == 1) goto ug0Ov; else goto cg0Od;
       ug0Ov: // global
           Sp = Sp + 8;
           call _cg0On() args: 0, res: 0, upd: 0;
       cg0Od: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg0Og() //  [R1]
         { info_tbl: [(cg0Og,
                       label: block_cg0Og_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Og: // global
           if (R1 & 7 == 1) goto ug0Ou; else goto cg0Or;
       ug0Ou: // global
           Sp = Sp + 8;
           call _cg0On() args: 0, res: 0, upd: 0;
       cg0Or: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg0On() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0On: // global
           R1 = Data.Functor.Sum.$fFoldableSum4_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cminimum_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0Oz,
                       label: Data.Functor.Sum.$fFoldableSum_$cminimum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Oz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg0OD; else goto cg0OC;
       cg0OD: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cminimum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0OC: // global
           I64[Hp - 48] = g1_sfXVS_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sfXW1_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.0593388 UTC

[section ""cstring" . lvl1_rfXP2_bytes" {
     lvl1_rfXP2_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.06239698 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum5_closure" {
     Data.Functor.Sum.$fFoldableSum5_closure:
         const Data.Functor.Sum.$fFoldableSum5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum5_entry() //  [R1]
         { info_tbl: [(cg0Pl,
                       label: Data.Functor.Sum.$fFoldableSum5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Pl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg0Pm; else goto cg0Pn;
       cg0Pm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Pn: // global
           (_cg0Pg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg0Pg::I64 == 0) goto cg0Pi; else goto cg0Ph;
       cg0Pi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg0Ph: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg0Pg::I64;
           I64[Sp - 24] = block_cg0Pj_info;
           R2 = lvl1_rfXP2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg0Pj() //  [R1]
         { info_tbl: [(cg0Pj,
                       label: block_cg0Pj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Pj: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.068934778 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cmaximum_closure" {
     Data.Functor.Sum.$fFoldableSum_$cmaximum_closure:
         const Data.Functor.Sum.$fFoldableSum_$cmaximum_info;
         const 0;
 },
 g1_sfXW6_entry() //  [R1]
         { info_tbl: [(cg0PJ,
                       label: g1_sfXW6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0PJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0PK; else goto cg0PL;
       cg0PK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0PL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXWf_entry() //  [R1, R2]
         { info_tbl: [(cg0PY,
                       label: sat_sfXWf_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0PY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0PZ; else goto cg0Q0;
       cg0PZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg0Q0: // global
           I64[Sp - 32] = block_cg0PR_info;
           _sfXW3::P64 = P64[R1 + 7];
           _sfXW4::P64 = P64[R1 + 15];
           _sfXW6::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXW3::P64;
           P64[Sp - 16] = _sfXW4::P64;
           P64[Sp - 8] = _sfXW6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug0Qx; else goto cg0PS;
       ug0Qx: // global
           call _cg0PR(R1) args: 0, res: 0, upd: 0;
       cg0PS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0PR() //  [R1]
         { info_tbl: [(cg0PR,
                       label: block_cg0PR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0PR: // global
           _sfXW6::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg0PV; else goto cg0PW;
       cg0PV: // global
           I64[Sp + 24] = block_cg0Q3_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sfXW6::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cg0PW: // global
           I64[Sp + 24] = block_cg0Qh_info;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sfXW6::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 6];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg0Q3() //  [R1]
         { info_tbl: [(cg0Q3,
                       label: block_cg0Q3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Q3: // global
           if (R1 & 7 == 1) goto ug0Qw; else goto cg0Qe;
       ug0Qw: // global
           Sp = Sp + 8;
           call _cg0Qo() args: 0, res: 0, upd: 0;
       cg0Qe: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg0Qh() //  [R1]
         { info_tbl: [(cg0Qh,
                       label: block_cg0Qh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Qh: // global
           if (R1 & 7 == 1) goto ug0Qv; else goto cg0Qs;
       ug0Qv: // global
           Sp = Sp + 8;
           call _cg0Qo() args: 0, res: 0, upd: 0;
       cg0Qs: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg0Qo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Qo: // global
           R1 = Data.Functor.Sum.$fFoldableSum5_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cmaximum_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0QA,
                       label: Data.Functor.Sum.$fFoldableSum_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0QA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg0QE; else goto cg0QD;
       cg0QE: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cmaximum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0QD: // global
           I64[Hp - 48] = g1_sfXW6_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sfXWf_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.08458907 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$celem_closure" {
     Data.Functor.Sum.$fFoldableSum_$celem_closure:
         const Data.Functor.Sum.$fFoldableSum_$celem_info;
         const 0;
 },
 f1_sfXWk_entry() //  [R1]
         { info_tbl: [(cg0Rl,
                       label: f1_sfXWk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Rl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg0Rm; else goto cg0Rn;
       cg0Rm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Rn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfXWp_entry() //  [R1, R2]
         { info_tbl: [(cg0RA,
                       label: sat_sfXWp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0RA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg0RB; else goto cg0RC;
       cg0RB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg0RC: // global
           I64[Sp - 32] = block_cg0Rt_info;
           _sfXWg::P64 = P64[R1 + 7];
           _sfXWh::P64 = P64[R1 + 15];
           _sfXWk::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXWg::P64;
           P64[Sp - 16] = _sfXWh::P64;
           P64[Sp - 8] = _sfXWk::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug0RJ; else goto cg0Ru;
       ug0RJ: // global
           call _cg0Rt(R1) args: 0, res: 0, upd: 0;
       cg0Ru: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0Rt() //  [R1]
         { info_tbl: [(cg0Rt,
                       label: block_cg0Rt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Rt: // global
           _sfXWk::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg0Rx; else goto cg0Ry;
       cg0Rx: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp + 16] = _sfXWk::P64;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg0Ry: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp + 16] = _sfXWk::P64;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$celem_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg0RK,
                       label: Data.Functor.Sum.$fFoldableSum_$celem_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0RK: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg0RO; else goto cg0RN;
       cg0RO: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$celem_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0RN: // global
           I64[Hp - 56] = f1_sfXWk_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = sat_sfXWp_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.095130261 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum10_closure" {
     Data.Functor.Sum.$fFoldableSum10_closure:
         const Data.Functor.Sum.$fFoldableSum10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum10_entry() //  [R1]
         { info_tbl: [(cg0Si,
                       label: Data.Functor.Sum.$fFoldableSum10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Si: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0Sj; else goto cg0Sk;
       cg0Sj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Sk: // global
           (_cg0Sf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg0Sf::I64 == 0) goto cg0Sh; else goto cg0Sg;
       cg0Sh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg0Sg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg0Sf::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.099691615 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldl_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldl_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldl_info;
         const 0;
 },
 f2_sfXWv_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0SB,
                       label: f2_sfXWv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0SB: // global
           _sfXWx::P64 = R3;
           R3 = R2;
           R2 = _sfXWx::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldl_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg0SL,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0SL: // global
           _sfXWu::P64 = R6;
           _sfXWt::P64 = R5;
           _sfXWs::P64 = R4;
           _sfXWr::P64 = R3;
           _sfXWq::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cg0SM; else goto cg0SN;
       cg0SN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg0SP; else goto cg0SO;
       cg0SP: // global
           HpAlloc = 16;
           goto cg0SM;
       cg0SM: // global
           R6 = _sfXWu::P64;
           R5 = _sfXWt::P64;
           R4 = _sfXWs::P64;
           R3 = _sfXWr::P64;
           R2 = _sfXWq::P64;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0SO: // global
           I64[Hp - 8] = f2_sfXWv_info;
           P64[Hp] = _sfXWs::P64;
           I64[Sp - 40] = block_cg0SE_info;
           R1 = _sfXWu::P64;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = _sfXWq::P64;
           P64[Sp - 16] = _sfXWr::P64;
           P64[Sp - 8] = _sfXWt::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0SW; else goto cg0SF;
       ug0SW: // global
           call _cg0SE(R1) args: 0, res: 0, upd: 0;
       cg0SF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0SE() //  [R1]
         { info_tbl: [(cg0SE,
                       label: block_cg0SE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0SE: // global
           _cg0Sw::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cg0SI; else goto cg0SJ;
       cg0SI: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 16] = _cg0Sw::P64;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
       cg0SJ: // global
           R2 = P64[Sp + 24];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 16] = _cg0Sw::P64;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.110598064 UTC

[section ""cstring" . lvl2_rfXP3_bytes" {
     lvl2_rfXP3_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.112578701 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum9_closure" {
     Data.Functor.Sum.$fFoldableSum9_closure:
         const Data.Functor.Sum.$fFoldableSum9_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum9_entry() //  [R1]
         { info_tbl: [(cg0Tn,
                       label: Data.Functor.Sum.$fFoldableSum9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Tn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg0To; else goto cg0Tp;
       cg0To: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Tp: // global
           (_cg0Ti::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg0Ti::I64 == 0) goto cg0Tk; else goto cg0Tj;
       cg0Tk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg0Tj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg0Ti::I64;
           I64[Sp - 24] = block_cg0Tl_info;
           R2 = lvl2_rfXP3_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg0Tl() //  [R1]
         { info_tbl: [(cg0Tl,
                       label: block_cg0Tl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Tl: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.120294497 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldl1_info;
         const 0;
 },
 sat_sfXWM_entry() //  [R1]
         { info_tbl: [(cg0U2,
                       label: sat_sfXWM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0U2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0U3; else goto cg0U4;
       cg0U3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0U4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg0TV_info;
           _sfXWE::P64 = P64[R1 + 16];
           _sfXWI::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sfXWE::P64;
           P64[Sp - 24] = _sfXWI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0Ub; else goto cg0TW;
       ug0Ub: // global
           call _cg0TV(R1) args: 0, res: 0, upd: 0;
       cg0TW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg0TV() //  [R1]
         { info_tbl: [(cg0TV,
                       label: block_cg0TV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0TV: // global
           _sfXWI::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg0TZ; else goto cg0U0;
       cg0TZ: // global
           R1 = _sfXWI::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cg0U0: // global
           R3 = _sfXWI::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXWN_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0Ud,
                       label: sat_sfXWN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Ud: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg0Uh; else goto cg0Ug;
       cg0Uh: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0Ug: // global
           _sfXWE::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sfXWM_info;
           P64[Hp - 32] = _sfXWE::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXWV_entry() //  [R1]
         { info_tbl: [(cg0UA,
                       label: sat_sfXWV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0UA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0UB; else goto cg0UC;
       cg0UB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0UC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg0Ut_info;
           _sfXWE::P64 = P64[R1 + 16];
           _sfXWR::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sfXWE::P64;
           P64[Sp - 24] = _sfXWR::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0UJ; else goto cg0Uu;
       ug0UJ: // global
           call _cg0Ut(R1) args: 0, res: 0, upd: 0;
       cg0Uu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg0Ut() //  [R1]
         { info_tbl: [(cg0Ut,
                       label: block_cg0Ut_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Ut: // global
           _sfXWR::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg0Ux; else goto cg0Uy;
       cg0Ux: // global
           R1 = _sfXWR::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cg0Uy: // global
           R3 = _sfXWR::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXWW_entry() //  [R1, R2, R3]
         { info_tbl: [(cg0UL,
                       label: sat_sfXWW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0UL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg0UP; else goto cg0UO;
       cg0UP: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0UO: // global
           _sfXWE::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sfXWV_info;
           P64[Hp - 32] = _sfXWE::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldl1_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cg0UU,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0UU: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg0UV; else goto cg0UW;
       cg0UV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0UW: // global
           I64[Sp - 32] = block_cg0TH_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug0Vt; else goto cg0TI;
       ug0Vt: // global
           call _cg0TH(R1) args: 0, res: 0, upd: 0;
       cg0TI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0TH() //  [R1]
         { info_tbl: [(cg0TH,
                       label: block_cg0TH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0TH: // global
           _sfXWE::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg0UR; else goto cg0US;
       cg0UR: // global
           Hp = Hp + 16;
           _sfXWG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg0Ve; else goto cg0UZ;
       cg0UZ: // global
           _sfXWH::P64 = P64[_sfXWG::P64 + 7];
           I64[Hp - 8] = sat_sfXWN_info;
           P64[Hp] = _sfXWE::P64;
           I64[Sp + 24] = block_cg0UX_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp] = Hp - 6;
           P64[Sp + 8] = _sfXWH::P64;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
       cg0US: // global
           Hp = Hp + 16;
           _sfXWG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg0Ve; else goto cg0Vd;
       cg0Ve: // global
           HpAlloc = 16;
           R1 = _sfXWG::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0Vd: // global
           _sfXWQ::P64 = P64[_sfXWG::P64 + 6];
           I64[Hp - 8] = sat_sfXWW_info;
           P64[Hp] = _sfXWE::P64;
           I64[Sp + 24] = block_cg0Vb_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp] = Hp - 6;
           P64[Sp + 8] = _sfXWQ::P64;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cg0UX() //  [R1]
         { info_tbl: [(cg0UX,
                       label: block_cg0UX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0UX: // global
           if (R1 & 7 == 1) goto ug0Vs; else goto cg0Va;
       ug0Vs: // global
           Sp = Sp + 8;
           call _cg0Vk() args: 0, res: 0, upd: 0;
       cg0Va: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg0Vb() //  [R1]
         { info_tbl: [(cg0Vb,
                       label: block_cg0Vb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Vb: // global
           if (R1 & 7 == 1) goto ug0Vr; else goto cg0Vo;
       ug0Vr: // global
           Sp = Sp + 8;
           call _cg0Vk() args: 0, res: 0, upd: 0;
       cg0Vo: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg0Vk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Vk: // global
           R1 = Data.Functor.Sum.$fFoldableSum9_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.146418878 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldr'_info;
         const 0;
 },
 sat_sfXXa_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg0WF,
                       label: sat_sfXXa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0WF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0WG; else goto cg0WH;
       cg0WG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0WH: // global
           I64[Sp - 16] = block_cg0WD_info;
           _sfXX7::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sfXX7::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0WD() //  [R1]
         { info_tbl: [(cg0WD,
                       label: block_cg0WD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0WD: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXXg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg0WS,
                       label: sat_sfXXg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0WS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0WT; else goto cg0WU;
       cg0WT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0WU: // global
           I64[Sp - 16] = block_cg0WQ_info;
           _sfXXd::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sfXXd::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0WQ() //  [R1]
         { info_tbl: [(cg0WQ,
                       label: block_cg0WQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0WQ: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldr'_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cg0X0,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0X0: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg0X1; else goto cg0X2;
       cg0X1: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0X2: // global
           I64[Sp - 40] = block_cg0Wt_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0X9; else goto cg0Wu;
       ug0X9: // global
           call _cg0Wt(R1) args: 0, res: 0, upd: 0;
       cg0Wu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0Wt() //  [R1]
         { info_tbl: [(cg0Wt,
                       label: block_cg0Wt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Wt: // global
           _sfXX1::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg0WX; else goto cg0WY;
       cg0WX: // global
           Hp = Hp + 16;
           _sfXX4::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg0X8; else goto cg0X4;
       cg0X4: // global
           _sfXX5::P64 = P64[_sfXX4::P64 + 7];
           I64[Hp - 8] = sat_sfXXa_info;
           P64[Hp] = _sfXX1::P64;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppppp_info;
           P64[Sp] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 8] = Hp - 5;
           P64[Sp + 16] = _sfXX5::P64;
           P64[Sp + 24] = GHC.Base.id_closure+1;
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
       cg0WY: // global
           Hp = Hp + 16;
           _sfXX4::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg0X8; else goto cg0X7;
       cg0X8: // global
           HpAlloc = 16;
           R1 = _sfXX4::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0X7: // global
           _sfXXb::P64 = P64[_sfXX4::P64 + 6];
           I64[Hp - 8] = sat_sfXXg_info;
           P64[Hp] = _sfXX1::P64;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_ppppp_info;
           P64[Sp] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 8] = Hp - 5;
           P64[Sp + 16] = _sfXXb::P64;
           P64[Sp + 24] = GHC.Base.id_closure+1;
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.162230456 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldr_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldr_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldr_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldr_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg0XM,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0XM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg0XN; else goto cg0XO;
       cg0XN: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0XO: // global
           I64[Sp - 40] = block_cg0XF_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug0XV; else goto cg0XG;
       ug0XV: // global
           call _cg0XF(R1) args: 0, res: 0, upd: 0;
       cg0XG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0XF() //  [R1]
         { info_tbl: [(cg0XF,
                       label: block_cg0XF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0XF: // global
           _sfXXj::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg0XJ; else goto cg0XK;
       cg0XJ: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp + 16] = _sfXXj::P64;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
       cg0XK: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp + 16] = _sfXXj::P64;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.168742944 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldl'_info;
         const 0;
 },
 sat_sfXXy_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg0Yk,
                       label: sat_sfXXy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Yk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0Yl; else goto cg0Ym;
       cg0Yl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0Ym: // global
           I64[Sp - 16] = block_cg0Yi_info;
           _sfXXv::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sfXXv::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0Yi() //  [R1]
         { info_tbl: [(cg0Yi,
                       label: block_cg0Yi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Yi: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldl'_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cg0Yo,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Yo: // global
           _sfXXt::P64 = R6;
           _sfXXs::P64 = R5;
           _sfXXr::P64 = R4;
           _sfXXq::P64 = R3;
           _sfXXp::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cg0Yp; else goto cg0Yq;
       cg0Yq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg0Ys; else goto cg0Yr;
       cg0Ys: // global
           HpAlloc = 16;
           goto cg0Yp;
       cg0Yp: // global
           R6 = _sfXXt::P64;
           R5 = _sfXXs::P64;
           R4 = _sfXXr::P64;
           R3 = _sfXXq::P64;
           R2 = _sfXXp::P64;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0Yr: // global
           I64[Hp - 8] = sat_sfXXy_info;
           P64[Hp] = _sfXXr::P64;
           R6 = _sfXXt::P64;
           R5 = GHC.Base.id_closure+1;
           R4 = Hp - 5;
           R3 = _sfXXq::P64;
           R2 = _sfXXp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sfXXs::P64;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.176760472 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum7_closure" {
     Data.Functor.Sum.$fFoldableSum7_closure:
         const Data.Functor.Sum.$fFoldableSum7_info;
 },
 Data.Functor.Sum.$fFoldableSum7_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0YM,
                       label: Data.Functor.Sum.$fFoldableSum7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0YM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0YT; else goto cg0YU;
       cg0YT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0YU: // global
           I64[Sp - 16] = block_cg0YJ_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ug0YY; else goto cg0YK;
       ug0YY: // global
           call _cg0YJ(R1) args: 0, res: 0, upd: 0;
       cg0YK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg0YJ() //  [R1]
         { info_tbl: [(cg0YJ,
                       label: block_cg0YJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0YJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg0YX; else goto cg0YW;
       cg0YX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg0YW: // global
           _sfXXE::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sfXXE::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.183050333 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$clength_closure" {
     Data.Functor.Sum.$fFoldableSum_$clength_closure:
         const Data.Functor.Sum.$fFoldableSum_$clength_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$clength_entry() //  [R2, R3, R4]
         { info_tbl: [(cg0Zd,
                       label: Data.Functor.Sum.$fFoldableSum_$clength_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Zd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg0Ze; else goto cg0Zf;
       cg0Ze: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$clength_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg0Zf: // global
           R6 = R4;
           R5 = GHC.Base.id_closure+1;
           R4 = Data.Functor.Sum.$fFoldableSum7_closure+3;
           R3 = R3;
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Functor.Sum.$fFoldableSum6_closure+1;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.186965337 UTC

[section ""cstring" . lvl3_rfXP4_bytes" {
     lvl3_rfXP4_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.18960393 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum11_closure" {
     Data.Functor.Sum.$fFoldableSum11_closure:
         const Data.Functor.Sum.$fFoldableSum11_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum11_entry() //  [R1]
         { info_tbl: [(cg0Zu,
                       label: Data.Functor.Sum.$fFoldableSum11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Zu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg0Zv; else goto cg0Zw;
       cg0Zv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg0Zw: // global
           (_cg0Zp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg0Zp::I64 == 0) goto cg0Zr; else goto cg0Zq;
       cg0Zr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg0Zq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg0Zp::I64;
           I64[Sp - 24] = block_cg0Zs_info;
           R2 = lvl3_rfXP4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg0Zs() //  [R1]
         { info_tbl: [(cg0Zs,
                       label: block_cg0Zs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0Zs: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.196278707 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldr1_info;
         const 0;
 },
 sat_sfXXS_entry() //  [R1]
         { info_tbl: [(cg104,
                       label: sat_sfXXS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg104: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg105; else goto cg106;
       cg105: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg106: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg0ZX_info;
           _sfXXM::P64 = P64[R1 + 16];
           _sfXXO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sfXXM::P64;
           P64[Sp - 24] = _sfXXO::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug10d; else goto cg0ZY;
       ug10d: // global
           call _cg0ZX(R1) args: 0, res: 0, upd: 0;
       cg0ZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg0ZX() //  [R1]
         { info_tbl: [(cg0ZX,
                       label: block_cg0ZX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg0ZX: // global
           _sfXXO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg101; else goto cg102;
       cg101: // global
           R1 = _sfXXO::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cg102: // global
           R3 = P64[R1 + 6];
           R2 = _sfXXO::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXXT_entry() //  [R1, R2, R3]
         { info_tbl: [(cg10f,
                       label: sat_sfXXT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg10f: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg10j; else goto cg10i;
       cg10j: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg10i: // global
           _sfXXM::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sfXXS_info;
           P64[Hp - 32] = _sfXXM::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldr1_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cg10q,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg10q: // global
           _sfXXN::P64 = R5;
           _sfXXM::P64 = R4;
           _sfXXL::P64 = R3;
           _sfXXK::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cg10r; else goto cg10s;
       cg10s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg10u; else goto cg10t;
       cg10u: // global
           HpAlloc = 16;
           goto cg10r;
       cg10r: // global
           R5 = _sfXXN::P64;
           R4 = _sfXXM::P64;
           R3 = _sfXXL::P64;
           R2 = _sfXXK::P64;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg10t: // global
           I64[Hp - 8] = sat_sfXXT_info;
           P64[Hp] = _sfXXM::P64;
           I64[Sp - 8] = block_cg10k_info;
           R6 = _sfXXN::P64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = Hp - 6;
           R3 = _sfXXL::P64;
           R2 = _sfXXK::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg10k() //  [R1]
         { info_tbl: [(cg10k,
                       label: block_cg10k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg10k: // global
           if (R1 & 7 == 1) goto cg10n; else goto cg10o;
       cg10n: // global
           R1 = Data.Functor.Sum.$fFoldableSum11_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg10o: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.208592363 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum8_closure" {
     Data.Functor.Sum.$fFoldableSum8_closure:
         const Data.Functor.Sum.$fFoldableSum8_info;
 },
 Data.Functor.Sum.$fFoldableSum8_entry() //  []
         { info_tbl: [(cg114,
                       label: Data.Functor.Sum.$fFoldableSum8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg114: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.212126392 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cnull_closure" {
     Data.Functor.Sum.$fFoldableSum_$cnull_closure:
         const Data.Functor.Sum.$fFoldableSum_$cnull_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$cnull_entry() //  [R2, R3, R4]
         { info_tbl: [(cg11g,
                       label: Data.Functor.Sum.$fFoldableSum_$cnull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg11g: // global
           R6 = R4;
           R5 = GHC.Types.True_closure+2;
           R4 = Data.Functor.Sum.$fFoldableSum8_closure+2;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.216348047 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum1_closure" {
     Data.Functor.Sum.$fFoldableSum1_closure:
         const Data.Functor.Sum.$fFoldableSum1_info;
         const 0;
 },
 $dMonoid_sfXY4_entry() //  [R1]
         { info_tbl: [(cg11v,
                       label: $dMonoid_sfXY4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg11v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg11w; else goto cg11x;
       cg11w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg11x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXY9_entry() //  [R1, R2]
         { info_tbl: [(cg11K,
                       label: sat_sfXY9_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg11K: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg11L; else goto cg11M;
       cg11L: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg11M: // global
           I64[Sp - 32] = block_cg11D_info;
           _sfXY1::P64 = P64[R1 + 7];
           _sfXY2::P64 = P64[R1 + 15];
           _sfXY4::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sfXY1::P64;
           P64[Sp - 16] = _sfXY2::P64;
           P64[Sp - 8] = _sfXY4::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug11T; else goto cg11E;
       ug11T: // global
           call _cg11D(R1) args: 0, res: 0, upd: 0;
       cg11E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg11D() //  [R1]
         { info_tbl: [(cg11D,
                       label: block_cg11D_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg11D: // global
           _sfXY4::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg11H; else goto cg11I;
       cg11H: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXY4::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg11I: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sfXY4::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum1_entry() //  [R2, R3, R4]
         { info_tbl: [(cg11U,
                       label: Data.Functor.Sum.$fFoldableSum1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg11U: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg11Y; else goto cg11X;
       cg11Y: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg11X: // global
           I64[Hp - 48] = $dMonoid_sfXY4_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sfXY9_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.227259049 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$ctoList_closure" {
     Data.Functor.Sum.$fFoldableSum_$ctoList_closure:
         const Data.Functor.Sum.$fFoldableSum_$ctoList_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$ctoList_entry() //  [R2, R3, R4]
         { info_tbl: [(cg12p,
                       label: Data.Functor.Sum.$fFoldableSum_$ctoList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg12p: // global
           R6 = R4;
           R5 = GHC.Types.[]_closure+1;
           R4 = GHC.Types.:_closure+2;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.233083344 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_closure" {
     Data.Functor.Sum.$fFoldableSum_closure:
         const Data.Functor.Sum.$fFoldableSum_info;
         const 0;
 },
 sat_sfXYu_entry() //  [R1, R2]
         { info_tbl: [(cg12F,
                       label: sat_sfXYu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg12F: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYt_entry() //  [R1, R2]
         { info_tbl: [(cg12N,
                       label: sat_sfXYt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg12N: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum3_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYs_entry() //  [R1, R2]
         { info_tbl: [(cg12V,
                       label: sat_sfXYs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg12V: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$cminimum_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYr_entry() //  [R1, R2]
         { info_tbl: [(cg133,
                       label: sat_sfXYr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg133: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$cmaximum_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYq_entry() //  [R1, R2, R3]
         { info_tbl: [(cg13b,
                       label: sat_sfXYq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg13b: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$celem_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYp_entry() //  [R1, R2]
         { info_tbl: [(cg13j,
                       label: sat_sfXYp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg13j: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$clength_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYo_entry() //  [R1, R2]
         { info_tbl: [(cg13r,
                       label: sat_sfXYo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg13r: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$cnull_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYn_entry() //  [R1, R2]
         { info_tbl: [(cg13z,
                       label: sat_sfXYn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg13z: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$ctoList_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYm_entry() //  [R1, R2, R3]
         { info_tbl: [(cg13H,
                       label: sat_sfXYm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg13H: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$cfoldl1_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYl_entry() //  [R1, R2, R3]
         { info_tbl: [(cg13P,
                       label: sat_sfXYl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg13P: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$cfoldr1_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg13X,
                       label: sat_sfXYk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg13X: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldl'_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYj_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg145,
                       label: sat_sfXYj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg145: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldl_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYi_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg14d,
                       label: sat_sfXYi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg14d: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldr'_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYh_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg14l,
                       label: sat_sfXYh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg14l: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg14t,
                       label: sat_sfXYg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg14t: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldMap_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXYf_entry() //  [R1, R2, R3]
         { info_tbl: [(cg14B,
                       label: sat_sfXYf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg14B: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$cfold_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_entry() //  [R2, R3]
         { info_tbl: [(cg14F,
                       label: Data.Functor.Sum.$fFoldableSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg14F: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cg14J; else goto cg14I;
       cg14J: // global
           HpAlloc = 520;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg14I: // global
           I64[Hp - 512] = sat_sfXYu_info;
           P64[Hp - 504] = R2;
           P64[Hp - 496] = R3;
           I64[Hp - 488] = sat_sfXYt_info;
           P64[Hp - 480] = R2;
           P64[Hp - 472] = R3;
           I64[Hp - 464] = sat_sfXYs_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           I64[Hp - 440] = sat_sfXYr_info;
           P64[Hp - 432] = R2;
           P64[Hp - 424] = R3;
           I64[Hp - 416] = sat_sfXYq_info;
           P64[Hp - 408] = R2;
           P64[Hp - 400] = R3;
           I64[Hp - 392] = sat_sfXYp_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           I64[Hp - 368] = sat_sfXYo_info;
           P64[Hp - 360] = R2;
           P64[Hp - 352] = R3;
           I64[Hp - 344] = sat_sfXYn_info;
           P64[Hp - 336] = R2;
           P64[Hp - 328] = R3;
           I64[Hp - 320] = sat_sfXYm_info;
           P64[Hp - 312] = R2;
           P64[Hp - 304] = R3;
           I64[Hp - 296] = sat_sfXYl_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           I64[Hp - 272] = sat_sfXYk_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_sfXYj_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_sfXYi_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_sfXYh_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sfXYg_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sfXYf_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = Data.Foldable.C:Foldable_con_info;
           P64[Hp - 120] = Hp - 150;
           P64[Hp - 112] = Hp - 173;
           P64[Hp - 104] = Hp - 197;
           P64[Hp - 96] = Hp - 221;
           P64[Hp - 88] = Hp - 245;
           P64[Hp - 80] = Hp - 269;
           P64[Hp - 72] = Hp - 294;
           P64[Hp - 64] = Hp - 318;
           P64[Hp - 56] = Hp - 343;
           P64[Hp - 48] = Hp - 367;
           P64[Hp - 40] = Hp - 391;
           P64[Hp - 32] = Hp - 414;
           P64[Hp - 24] = Hp - 439;
           P64[Hp - 16] = Hp - 463;
           P64[Hp - 8] = Hp - 487;
           P64[Hp] = Hp - 511;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.266904648 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$ctraverse_closure" {
     Data.Functor.Sum.$fTraversableSum_$ctraverse_closure:
         const Data.Functor.Sum.$fTraversableSum_$ctraverse_info;
 },
 sat_sfXYD_entry() //  [R1]
         { info_tbl: [(cg164,
                       label: sat_sfXYD_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg164: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg165; else goto cg166;
       cg165: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg166: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sfXYG_entry() //  [R1]
         { info_tbl: [(cg16d,
                       label: sat_sfXYG_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg16d: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg16e; else goto cg16f;
       cg16e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg16f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cg16k,
                       label: Data.Functor.Sum.$fTraversableSum_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg16k: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg16l; else goto cg16m;
       cg16l: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg16m: // global
           I64[Sp - 40] = block_cg15V_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug16D; else goto cg15W;
       ug16D: // global
           call _cg15V(R1) args: 0, res: 0, upd: 0;
       cg15W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg15V() //  [R1]
         { info_tbl: [(cg15V,
                       label: block_cg15V_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg15V: // global
           _sfXYx::P64 = P64[Sp + 24];
           _sfXYy::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg16h; else goto cg16i;
       cg16h: // global
           Hp = Hp + 48;
           _sfXYA::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg16y; else goto cg16p;
       cg16p: // global
           _sfXYB::P64 = P64[_sfXYA::P64 + 7];
           I64[Hp - 40] = sat_sfXYD_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sfXYx::P64;
           P64[Hp - 8] = _sfXYy::P64;
           P64[Hp] = _sfXYB::P64;
           I64[Sp + 24] = block_cg16n_info;
           R2 = _sfXYx::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
       cg16i: // global
           Hp = Hp + 48;
           _sfXYA::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg16y; else goto cg16x;
       cg16y: // global
           HpAlloc = 48;
           R1 = _sfXYA::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg16x: // global
           _sfXYE::P64 = P64[_sfXYA::P64 + 6];
           I64[Hp - 40] = sat_sfXYG_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sfXYx::P64;
           P64[Hp - 8] = _sfXYy::P64;
           P64[Hp] = _sfXYE::P64;
           I64[Sp + 24] = block_cg16v_info;
           R2 = _sfXYx::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg16n() //  [R1]
         { info_tbl: [(cg16n,
                       label: block_cg16n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg16n: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Sum.InL_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cg16v() //  [R1]
         { info_tbl: [(cg16v,
                       label: block_cg16v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg16v: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Sum.InR_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.282576113 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure" {
     Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure:
         const Data.Functor.Sum.$fTraversableSum_$cp2Traversable_info;
         const 0;
 },
 sat_sfXYK_entry() //  [R1]
         { info_tbl: [(cg17l,
                       label: sat_sfXYK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg17l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg17m; else goto cg17n;
       cg17m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg17n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXYJ_entry() //  [R1]
         { info_tbl: [(cg17s,
                       label: sat_sfXYJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg17s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg17t; else goto cg17u;
       cg17t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg17u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cg17v,
                       label: Data.Functor.Sum.$fTraversableSum_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg17v: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg17z; else goto cg17y;
       cg17z: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg17y: // global
           I64[Hp - 40] = sat_sfXYK_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sfXYJ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Sum.$fFoldableSum_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.290452033 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$cp1Traversable_closure" {
     Data.Functor.Sum.$fTraversableSum_$cp1Traversable_closure:
         const Data.Functor.Sum.$fTraversableSum_$cp1Traversable_info;
 },
 sat_sfXYO_entry() //  [R1]
         { info_tbl: [(cg17U,
                       label: sat_sfXYO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg17U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg17V; else goto cg17W;
       cg17V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg17W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXYN_entry() //  [R1]
         { info_tbl: [(cg181,
                       label: sat_sfXYN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg181: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg182; else goto cg183;
       cg182: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg183: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cg184,
                       label: Data.Functor.Sum.$fTraversableSum_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg184: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg188; else goto cg187;
       cg188: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg187: // global
           I64[Hp - 40] = sat_sfXYO_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sfXYN_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Sum.$fFunctorSum_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.297824909 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$csequenceA_closure" {
     Data.Functor.Sum.$fTraversableSum_$csequenceA_closure:
         const Data.Functor.Sum.$fTraversableSum_$csequenceA_info;
 },
 Data.Functor.Sum.$fTraversableSum_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cg18p,
                       label: Data.Functor.Sum.$fTraversableSum_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg18p: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.301780374 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$cmapM_closure" {
     Data.Functor.Sum.$fTraversableSum_$cmapM_closure:
         const Data.Functor.Sum.$fTraversableSum_$cmapM_info;
 },
 Data.Functor.Sum.$fTraversableSum_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cg18C,
                       label: Data.Functor.Sum.$fTraversableSum_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg18C: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg18D; else goto cg18E;
       cg18D: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg18E: // global
           I64[Sp - 40] = block_cg18A_info;
           _sfXYS::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sfXYS::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg18A() //  [R1]
         { info_tbl: [(cg18A,
                       label: block_cg18A_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg18A: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.308019804 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$csequence_closure" {
     Data.Functor.Sum.$fTraversableSum_$csequence_closure:
         const Data.Functor.Sum.$fTraversableSum_$csequence_info;
 },
 Data.Functor.Sum.$fTraversableSum_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cg18W,
                       label: Data.Functor.Sum.$fTraversableSum_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg18W: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg18X; else goto cg18Y;
       cg18X: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg18Y: // global
           I64[Sp - 32] = block_cg18U_info;
           _sfXYY::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sfXYY::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg18U() //  [R1]
         { info_tbl: [(cg18U,
                       label: block_cg18U_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg18U: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.314330863 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_closure" {
     Data.Functor.Sum.$fTraversableSum_closure:
         const Data.Functor.Sum.$fTraversableSum_info;
         const 0;
 },
 sat_sfXZa_entry() //  [R1, R2, R3]
         { info_tbl: [(cg19j,
                       label: sat_sfXZa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg19j: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fTraversableSum_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXZ9_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg19r,
                       label: sat_sfXZ9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg19r: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fTraversableSum_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXZ8_entry() //  [R1, R2, R3]
         { info_tbl: [(cg19z,
                       label: sat_sfXZ8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg19z: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fTraversableSum_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXZ7_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg19H,
                       label: sat_sfXZ7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg19H: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfXZ6_entry() //  [R1]
         { info_tbl: [(cg19O,
                       label: sat_sfXZ6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg19O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg19P; else goto cg19Q;
       cg19P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg19Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fTraversableSum_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXZ5_entry() //  [R1]
         { info_tbl: [(cg19V,
                       label: sat_sfXZ5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg19V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg19W; else goto cg19X;
       cg19W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg19X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fTraversableSum_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_entry() //  [R2, R3]
         { info_tbl: [(cg19Z,
                       label: Data.Functor.Sum.$fTraversableSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg19Z: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cg1a3; else goto cg1a2;
       cg1a3: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1a2: // global
           I64[Hp - 208] = sat_sfXZa_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sfXZ9_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sfXZ8_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sfXZ7_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sfXZ6_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sfXZ5_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.329466185 UTC

[section ""data" . Data.Functor.Sum.$fGeneric1Sum_$cto1_closure" {
     Data.Functor.Sum.$fGeneric1Sum_$cto1_closure:
         const Data.Functor.Sum.$fGeneric1Sum_$cto1_info;
 },
 Data.Functor.Sum.$fGeneric1Sum_$cto1_entry() //  [R2]
         { info_tbl: [(cg1aJ,
                       label: Data.Functor.Sum.$fGeneric1Sum_$cto1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1aJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1aK; else goto cg1aL;
       cg1aK: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGeneric1Sum_$cto1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1aL: // global
           I64[Sp - 8] = block_cg1aD_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1aD() //  [R1]
         { info_tbl: [(cg1aD,
                       label: block_cg1aD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1aD: // global
           if (R1 & 7 == 1) goto cg1aG; else goto cg1aH;
       cg1aG: // global
           Hp = Hp + 16;
           _sfXZc::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1aX; else goto cg1aQ;
       cg1aQ: // global
           _sfXZd::P64 = P64[_sfXZc::P64 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = _sfXZd::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg1aH: // global
           Hp = Hp + 16;
           _sfXZc::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1aX; else goto cg1aW;
       cg1aX: // global
           HpAlloc = 16;
           R1 = _sfXZc::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1aW: // global
           _sfXZe::P64 = P64[_sfXZc::P64 + 6];
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = _sfXZe::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.335589079 UTC

[section ""data" . Data.Functor.Sum.$fGeneric1Sum1_closure" {
     Data.Functor.Sum.$fGeneric1Sum1_closure:
         const Data.Functor.Sum.$fGeneric1Sum1_info;
 },
 Data.Functor.Sum.$fGeneric1Sum1_entry() //  [R2]
         { info_tbl: [(cg1bl,
                       label: Data.Functor.Sum.$fGeneric1Sum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1bl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1bm; else goto cg1bn;
       cg1bm: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGeneric1Sum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1bn: // global
           I64[Sp - 8] = block_cg1be_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1bA; else goto cg1bf;
       ug1bA: // global
           call _cg1be(R1) args: 0, res: 0, upd: 0;
       cg1bf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1be() //  [R1]
         { info_tbl: [(cg1be,
                       label: block_cg1be_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1be: // global
           if (R1 & 7 == 1) goto cg1bi; else goto cg1bj;
       cg1bi: // global
           Hp = Hp + 16;
           _sfXZg::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1bz; else goto cg1bs;
       cg1bs: // global
           _sfXZh::P64 = P64[_sfXZg::P64 + 7];
           I64[Hp - 8] = GHC.Generics.L1_con_info;
           P64[Hp] = _sfXZh::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg1bj: // global
           Hp = Hp + 16;
           _sfXZg::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1bz; else goto cg1by;
       cg1bz: // global
           HpAlloc = 16;
           R1 = _sfXZg::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1by: // global
           _sfXZi::P64 = P64[_sfXZg::P64 + 6];
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = _sfXZi::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.341949886 UTC

[section ""data" . Data.Functor.Sum.$fGeneric1Sum_closure" {
     Data.Functor.Sum.$fGeneric1Sum_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Sum.$fGeneric1Sum1_closure+1;
         const Data.Functor.Sum.$fGeneric1Sum_$cto1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.344703732 UTC

[section ""data" . Data.Functor.Sum.$fGenericSum_$cto_closure" {
     Data.Functor.Sum.$fGenericSum_$cto_closure:
         const Data.Functor.Sum.$fGenericSum_$cto_info;
 },
 Data.Functor.Sum.$fGenericSum_$cto_entry() //  [R2]
         { info_tbl: [(cg1bZ,
                       label: Data.Functor.Sum.$fGenericSum_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1bZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1c0; else goto cg1c1;
       cg1c0: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGenericSum_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1c1: // global
           I64[Sp - 8] = block_cg1bT_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1bT() //  [R1]
         { info_tbl: [(cg1bT,
                       label: block_cg1bT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1bT: // global
           if (R1 & 7 == 1) goto cg1bW; else goto cg1bX;
       cg1bW: // global
           Hp = Hp + 16;
           _sfXZk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1cd; else goto cg1c6;
       cg1c6: // global
           _sfXZl::P64 = P64[_sfXZk::P64 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = _sfXZl::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg1bX: // global
           Hp = Hp + 16;
           _sfXZk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1cd; else goto cg1cc;
       cg1cd: // global
           HpAlloc = 16;
           R1 = _sfXZk::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1cc: // global
           _sfXZm::P64 = P64[_sfXZk::P64 + 6];
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = _sfXZm::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.351277031 UTC

[section ""data" . Data.Functor.Sum.$fGenericSum1_closure" {
     Data.Functor.Sum.$fGenericSum1_closure:
         const Data.Functor.Sum.$fGenericSum1_info;
 },
 Data.Functor.Sum.$fGenericSum1_entry() //  [R2]
         { info_tbl: [(cg1cB,
                       label: Data.Functor.Sum.$fGenericSum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1cB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1cC; else goto cg1cD;
       cg1cC: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGenericSum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1cD: // global
           I64[Sp - 8] = block_cg1cu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1cQ; else goto cg1cv;
       ug1cQ: // global
           call _cg1cu(R1) args: 0, res: 0, upd: 0;
       cg1cv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1cu() //  [R1]
         { info_tbl: [(cg1cu,
                       label: block_cg1cu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1cu: // global
           if (R1 & 7 == 1) goto cg1cy; else goto cg1cz;
       cg1cy: // global
           Hp = Hp + 16;
           _sfXZo::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1cP; else goto cg1cI;
       cg1cI: // global
           _sfXZp::P64 = P64[_sfXZo::P64 + 7];
           I64[Hp - 8] = GHC.Generics.L1_con_info;
           P64[Hp] = _sfXZp::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg1cz: // global
           Hp = Hp + 16;
           _sfXZo::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1cP; else goto cg1cO;
       cg1cP: // global
           HpAlloc = 16;
           R1 = _sfXZo::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1cO: // global
           _sfXZq::P64 = P64[_sfXZo::P64 + 6];
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = _sfXZq::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.357707213 UTC

[section ""data" . Data.Functor.Sum.$fGenericSum_closure" {
     Data.Functor.Sum.$fGenericSum_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Sum.$fGenericSum1_closure+1;
         const Data.Functor.Sum.$fGenericSum_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.360445747 UTC

[section ""data" . Data.Functor.Sum.$w$cgunfold_closure" {
     Data.Functor.Sum.$w$cgunfold_closure:
         const Data.Functor.Sum.$w$cgunfold_info;
         const 0;
 },
 sat_sfXZG_entry() //  [R1]
         { info_tbl: [(cg1dq,
                       label: sat_sfXZG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1dq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg1dr; else goto cg1ds;
       cg1dr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1ds: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InR_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfXZH_entry() //  [R1]
         { info_tbl: [(cg1dy,
                       label: sat_sfXZH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1dy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg1dz; else goto cg1dA;
       cg1dz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1dA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InL_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgunfold_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg1dF,
                       label: Data.Functor.Sum.$w$cgunfold_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1dF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg1dG; else goto cg1dH;
       cg1dG: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$w$cgunfold_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg1dH: // global
           I64[Sp - 40] = block_cg1d9_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug1dZ; else goto cg1da;
       ug1dZ: // global
           call _cg1d9(R1) args: 0, res: 0, upd: 0;
       cg1da: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1d9() //  [R1]
         { info_tbl: [(cg1d9,
                       label: block_cg1d9_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1d9: // global
           if (R1 & 7 == 1) goto cg1dD; else goto cg1dC;
       cg1dD: // global
           I64[Sp] = block_cg1df_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto ug1dY; else goto cg1dg;
       ug1dY: // global
           call _cg1df(R1) args: 0, res: 0, upd: 0;
       cg1dg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg1dC: // global
           _sfXZw::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cg1dJ_info;
           R1 = _sfXZw::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ug1dX; else goto cg1dL;
       ug1dX: // global
           call _cg1dJ(R1) args: 0, res: 0, upd: 0;
       cg1dL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1df() //  [R1]
         { info_tbl: [(cg1df,
                       label: block_cg1df_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1df: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg1dT; else goto cg1dS;
       cg1dT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1dS: // global
           _sfXZt::P64 = P64[Sp + 24];
           _sfXZu::P64 = P64[Sp + 32];
           if (I64[R1 + 7] == 1) goto cg1dW; else goto cg1dV;
       cg1dW: // global
           I64[Hp - 16] = sat_sfXZH_info;
           P64[Hp] = _sfXZu::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 8];
           R1 = _sfXZt::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1dV: // global
           I64[Hp - 16] = sat_sfXZG_info;
           P64[Hp] = _sfXZu::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _sfXZt::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg1dJ() //  [R1]
         { info_tbl: [(cg1dJ,
                       label: block_cg1dJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1dJ: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Data.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.374560473 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgunfold_closure" {
     Data.Functor.Sum.$fDataSum_$cgunfold_closure:
         const Data.Functor.Sum.$fDataSum_$cgunfold_info;
         const 0;
 },
 Data.Functor.Sum.$fDataSum_$cgunfold_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1es: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgunfold_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgunfold_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cg1ez,
                       label: Data.Functor.Sum.$fDataSum_$cgunfold_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1ez: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1eA; else goto cg1eB;
       cg1eA: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgunfold_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cg1eB: // global
           I64[Sp - 8] = block_cg1ew_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1eF; else goto cg1ex;
       ug1eF: // global
           call _cg1ew(R1) args: 0, res: 0, upd: 0;
       cg1ex: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1ew() //  [R1]
         { info_tbl: [(cg1ew,
                       label: block_cg1ew_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1ew: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 39];
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgunfold_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.382846217 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgfoldl_closure" {
     Data.Functor.Sum.$fDataSum_$cgfoldl_closure:
         const Data.Functor.Sum.$fDataSum_$cgfoldl_info;
 },
 Data.Functor.Sum.$fDataSum_$cgfoldl_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1eT: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgfoldl_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_sfY08_entry() //  [R1]
         { info_tbl: [(cg1f6,
                       label: sat_sfY08_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1f6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg1f7; else goto cg1f8;
       cg1f7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1f8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InL_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfY0a_entry() //  [R1]
         { info_tbl: [(cg1ff,
                       label: sat_sfY0a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1ff: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg1fg; else goto cg1fh;
       cg1fg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1fh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InR_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgfoldl_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg1fm,
                       label: Data.Functor.Sum.$fDataSum_$cgfoldl_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1fm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1fn; else goto cg1fo;
       cg1fn: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgfoldl_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cg1fo: // global
           I64[Sp - 8] = block_cg1eX_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1fv; else goto cg1eY;
       ug1fv: // global
           call _cg1eX(R1) args: 0, res: 0, upd: 0;
       cg1eY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1eX() //  [R1]
         { info_tbl: [(cg1eX,
                       label: block_cg1eX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1eX: // global
           _sfY03::P64 = P64[Sp + 16];
           _sfY04::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg1fj; else goto cg1fk;
       cg1fj: // global
           Hp = Hp + 24;
           _sfY06::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1fu; else goto cg1fq;
       cg1fq: // global
           _sfY07::P64 = P64[_sfY06::P64 + 7];
           I64[Hp - 16] = sat_sfY08_info;
           P64[Hp] = _sfY04::P64;
           R4 = _sfY07::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 32];
           R1 = _sfY03::P64;
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1fk: // global
           Hp = Hp + 24;
           _sfY06::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1fu; else goto cg1ft;
       cg1fu: // global
           HpAlloc = 24;
           R1 = _sfY06::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1ft: // global
           _sfY09::P64 = P64[_sfY06::P64 + 6];
           I64[Hp - 16] = sat_sfY0a_info;
           P64[Hp] = _sfY04::P64;
           R4 = _sfY09::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 8];
           R1 = _sfY03::P64;
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.395193286 UTC

[section ""cstring" . Data.Functor.Sum.$fDataSum8_bytes" {
     Data.Functor.Sum.$fDataSum8_bytes:
         I8[] [83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.397455136 UTC

[section ""data" . $tSum1_rfXP5_closure" {
     $tSum1_rfXP5_closure:
         const $tSum1_rfXP5_info;
         const 0;
         const 0;
         const 0;
 },
 $tSum1_rfXP5_entry() //  [R1]
         { info_tbl: [(cg1fY,
                       label: $tSum1_rfXP5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1fY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg1fZ; else goto cg1g0;
       cg1fZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1g0: // global
           (_cg1fV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg1fV::I64 == 0) goto cg1fX; else goto cg1fW;
       cg1fX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg1fW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg1fV::I64;
           R2 = Data.Functor.Sum.$fDataSum8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.402116095 UTC

[section ""data" . go61_rfXP6_closure" {
     go61_rfXP6_closure:
         const go61_rfXP6_info;
         const 0;
 },
 go61_rfXP6_entry() //  [R2, R3]
         { info_tbl: [(cg1gj,
                       label: go61_rfXP6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1gj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1gk; else goto ug1gX;
       cg1gk: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rfXP6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ug1gX: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cg1g9() args: 0, res: 0, upd: 0;
     }
 },
 _cg1g9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1g9: // global
           _sfY0b::P64 = P64[Sp];
           I64[Sp] = block_cg1gc_info;
           R1 = _sfY0b::P64;
           if (R1 & 7 != 0) goto ug1h1; else goto cg1gd;
       ug1h1: // global
           call _cg1gc(R1) args: 0, res: 0, upd: 0;
       cg1gd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1gc() //  [R1]
         { info_tbl: [(cg1gc,
                       label: block_cg1gc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1gc: // global
           if (R1 & 7 == 1) goto ug1gY; else goto cg1gh;
       ug1gY: // global
           Sp = Sp + 16;
           call _cg1gz() args: 0, res: 0, upd: 0;
       cg1gh: // global
           I64[Sp - 8] = block_cg1gr_info;
           _sfY0e::P64 = P64[R1 + 6];
           _sfY0f::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sfY0f::P64;
           P64[Sp + 8] = _sfY0e::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1h2; else goto cg1gt;
       ug1h2: // global
           call _cg1gr(R1) args: 0, res: 0, upd: 0;
       cg1gt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1gr() //  [R1]
         { info_tbl: [(cg1gr,
                       label: block_cg1gr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1gr: // global
           if (R1 & 7 == 1) goto ug1gZ; else goto cg1gE;
       ug1gZ: // global
           Sp = Sp + 24;
           call _cg1gz() args: 0, res: 0, upd: 0;
       cg1gE: // global
           I64[Sp - 8] = block_cg1gC_info;
           _sfY0h::P64 = P64[R1 + 6];
           _sfY0i::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sfY0i::P64;
           P64[Sp + 16] = _sfY0h::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1h5; else goto cg1gF;
       ug1h5: // global
           call _cg1gC(R1) args: 0, res: 0, upd: 0;
       cg1gF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1gz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1gz: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg1gC() //  [R1]
         { info_tbl: [(cg1gC,
                       label: block_cg1gC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1gC: // global
           I64[Sp] = block_cg1gJ_info;
           R3 = Data.Functor.Sum.$fRead1Sum7_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg1gJ() //  [R1]
         { info_tbl: [(cg1gJ,
                       label: block_cg1gJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1gJ: // global
           if (R1 & 7 == 1) goto cg1gQ; else goto cg1gU;
       cg1gQ: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cg1g9() args: 0, res: 0, upd: 0;
       cg1gU: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.415729628 UTC

[section ""data" . go1_rfXP7_closure" {
     go1_rfXP7_closure:
         const go1_rfXP7_info;
         const 0;
 },
 section ""relreadonly" . ug1iG_srtd" {
     ug1iG_srtd:
         const SfYa7_srt+88;
         const 51;
         const 1266637395197953;
 },
 go1_rfXP7_entry() //  [R2, R3]
         { info_tbl: [(cg1hR,
                       label: go1_rfXP7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1hR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1hS; else goto ug1iv;
       cg1hS: // global
           R3 = R3;
           R2 = R2;
           R1 = go1_rfXP7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ug1iv: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cg1hH() args: 0, res: 0, upd: 0;
     }
 },
 _cg1hH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1hH: // global
           _sfY0q::P64 = P64[Sp];
           I64[Sp] = block_cg1hK_info;
           R1 = _sfY0q::P64;
           if (R1 & 7 != 0) goto ug1iz; else goto cg1hL;
       ug1iz: // global
           call _cg1hK(R1) args: 0, res: 0, upd: 0;
       cg1hL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ug1iH_srtd" {
     ug1iH_srtd:
         const SfYa7_srt+88;
         const 48;
         const 140737488355329;
 },
 _cg1hK() //  [R1]
         { info_tbl: [(cg1hK,
                       label: block_cg1hK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1hK: // global
           if (R1 & 7 == 1) goto ug1iw; else goto cg1hP;
       ug1iw: // global
           Sp = Sp + 16;
           call _cg1i7() args: 0, res: 0, upd: 0;
       cg1hP: // global
           I64[Sp - 8] = block_cg1hZ_info;
           _sfY0t::P64 = P64[R1 + 6];
           _sfY0u::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sfY0u::P64;
           P64[Sp + 8] = _sfY0t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1iA; else goto cg1i1;
       ug1iA: // global
           call _cg1hZ(R1) args: 0, res: 0, upd: 0;
       cg1i1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ug1iI_srtd" {
     ug1iI_srtd:
         const SfYa7_srt+88;
         const 48;
         const 140737488355329;
 },
 _cg1hZ() //  [R1]
         { info_tbl: [(cg1hZ,
                       label: block_cg1hZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1hZ: // global
           if (R1 & 7 == 1) goto ug1ix; else goto cg1ic;
       ug1ix: // global
           Sp = Sp + 24;
           call _cg1i7() args: 0, res: 0, upd: 0;
       cg1ic: // global
           I64[Sp - 8] = block_cg1ia_info;
           _sfY0w::P64 = P64[R1 + 6];
           _sfY0x::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sfY0x::P64;
           P64[Sp + 16] = _sfY0w::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1iD; else goto cg1id;
       ug1iD: // global
           call _cg1ia(R1) args: 0, res: 0, upd: 0;
       cg1id: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1i7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1i7: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ug1iJ_srtd" {
     ug1iJ_srtd:
         const SfYa7_srt+88;
         const 48;
         const 140737488355329;
 },
 _cg1ia() //  [R1]
         { info_tbl: [(cg1ia,
                       label: block_cg1ia_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1ia: // global
           I64[Sp] = block_cg1ih_info;
           R3 = Data.Functor.Sum.$fRead1Sum3_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ug1iK_srtd" {
     ug1iK_srtd:
         const SfYa7_srt+88;
         const 48;
         const 140737488355329;
 },
 _cg1ih() //  [R1]
         { info_tbl: [(cg1ih,
                       label: block_cg1ih_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1ih: // global
           if (R1 & 7 == 1) goto cg1io; else goto cg1is;
       cg1io: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cg1hH() args: 0, res: 0, upd: 0;
       cg1is: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.433035637 UTC

[section ""data" . $cInL1_rfXP8_closure" {
     $cInL1_rfXP8_closure:
         const Data.Data.AlgConstr_con_info;
         const $cInL2_rfXPe_closure;
         const 0;
 },
 section ""data" . $cInR1_rfXP9_closure" {
     $cInR1_rfXP9_closure:
         const Data.Data.AlgConstr_con_info;
         const $cInR2_rfXPd_closure;
         const 0;
 },
 section ""data" . Data.Functor.Sum.$cInL_closure" {
     Data.Functor.Sum.$cInL_closure:
         const Data.Data.Constr_con_info;
         const $cInL1_rfXP8_closure+1;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Sum.$tSum_closure+1;
         const 0;
 },
 section ""data" . $tSum2_rfXPa_closure" {
     $tSum2_rfXPa_closure:
         const :_con_info;
         const Data.Functor.Sum.$cInR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . $tSum3_rfXPb_closure" {
     $tSum3_rfXPb_closure:
         const :_con_info;
         const Data.Functor.Sum.$cInL_closure+1;
         const $tSum2_rfXPa_closure+2;
         const 0;
 },
 section ""data" . $tSum4_rfXPc_closure" {
     $tSum4_rfXPc_closure:
         const Data.Data.AlgRep_con_info;
         const $tSum3_rfXPb_closure+2;
         const 0;
 },
 section ""data" . Data.Functor.Sum.$tSum_closure" {
     Data.Functor.Sum.$tSum_closure:
         const Data.Data.DataType_con_info;
         const $tSum1_rfXP5_closure;
         const $tSum4_rfXPc_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Sum.$cInR_closure" {
     Data.Functor.Sum.$cInR_closure:
         const Data.Data.Constr_con_info;
         const $cInR1_rfXP9_closure+1;
         const Data.Functor.Sum.$fRead1Sum3_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Sum.$tSum_closure+1;
         const 0;
 },
 section ""data" . $cInR2_rfXPd_closure" {
     $cInR2_rfXPd_closure:
         const $cInR2_rfXPd_info;
         const 0;
         const 0;
         const 0;
 },
 $cInR2_rfXPd_entry() //  [R1]
         { info_tbl: [(cg1ju,
                       label: $cInR2_rfXPd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1ju: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg1jv; else goto cg1jw;
       cg1jv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1jw: // global
           (_cg1jr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg1jr::I64 == 0) goto cg1jt; else goto cg1js;
       cg1jt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg1js: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg1jr::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = $tSum3_rfXPb_closure+2;
           Sp = Sp - 16;
           call go1_rfXP7_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""data" . $cInL2_rfXPe_closure" {
     $cInL2_rfXPe_closure:
         const $cInL2_rfXPe_info;
         const 0;
         const 0;
         const 0;
 },
 $cInL2_rfXPe_entry() //  [R1]
         { info_tbl: [(cg1jD,
                       label: $cInL2_rfXPe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1jD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg1jE; else goto cg1jF;
       cg1jE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1jF: // global
           (_cg1jA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg1jA::I64 == 0) goto cg1jC; else goto cg1jB;
       cg1jC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg1jB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg1jA::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = $tSum3_rfXPb_closure+2;
           Sp = Sp - 16;
           call go61_rfXP6_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.446078851 UTC

[section ""cstring" . Data.Functor.Sum.$trModule4_bytes" {
     Data.Functor.Sum.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.447709952 UTC

[section ""data" . Data.Functor.Sum.$trModule3_closure" {
     Data.Functor.Sum.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.449893396 UTC

[section ""cstring" . Data.Functor.Sum.$trModule2_bytes" {
     Data.Functor.Sum.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.451577647 UTC

[section ""data" . Data.Functor.Sum.$trModule1_closure" {
     Data.Functor.Sum.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.453436481 UTC

[section ""data" . Data.Functor.Sum.$trModule_closure" {
     Data.Functor.Sum.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Sum.$trModule3_closure+1;
         const Data.Functor.Sum.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.455265501 UTC

[section ""data" . $krep_rfXPf_closure" {
     $krep_rfXPf_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.457850543 UTC

[section ""data" . $krep1_rfXPg_closure" {
     $krep1_rfXPg_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rfXPf_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.459591488 UTC

[section ""data" . $krep2_rfXPh_closure" {
     $krep2_rfXPh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rfXPg_closure+4;
         const $krep1_rfXPg_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.461277315 UTC

[section ""data" . Data.Functor.Sum.$fDataSum6_closure" {
     Data.Functor.Sum.$fDataSum6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rfXPg_closure+4;
         const $krep2_rfXPh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.462975911 UTC

[section ""data" . $krep3_rfXPi_closure" {
     $krep3_rfXPi_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.464742091 UTC

[section ""data" . $krep4_rfXPj_closure" {
     $krep4_rfXPj_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.466847049 UTC

[section ""data" . $krep5_rfXPk_closure" {
     $krep5_rfXPk_closure:
         const GHC.Types.KindRepVar_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.468523135 UTC

[section ""data" . $krep6_rfXPl_closure" {
     $krep6_rfXPl_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rfXPj_closure+2;
         const $krep5_rfXPk_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.470265371 UTC

[section ""data" . $krep7_rfXPm_closure" {
     $krep7_rfXPm_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep3_rfXPi_closure+2;
         const $krep5_rfXPk_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.471988518 UTC

[section ""data" . Data.Functor.Sum.$fDataSum7_closure" {
     Data.Functor.Sum.$fDataSum7_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$fDataSum8_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.474017273 UTC

[section ""data" . Data.Functor.Sum.$tcSum_closure" {
     Data.Functor.Sum.$tcSum_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Sum.$trModule_closure+1;
         const Data.Functor.Sum.$fDataSum7_closure+1;
         const Data.Functor.Sum.$fDataSum6_closure+4;
         const 6345190594862254730;
         const 1236278515871186010;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.475908422 UTC

[section ""data" . $krep8_rfXPn_closure" {
     $krep8_rfXPn_closure:
         const :_con_info;
         const $krep5_rfXPk_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.477689868 UTC

[section ""data" . $krep9_rfXPo_closure" {
     $krep9_rfXPo_closure:
         const :_con_info;
         const $krep3_rfXPi_closure+2;
         const $krep8_rfXPn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.479432513 UTC

[section ""data" . $krep10_rfXPp_closure" {
     $krep10_rfXPp_closure:
         const :_con_info;
         const $krep4_rfXPj_closure+2;
         const $krep9_rfXPo_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.481138738 UTC

[section ""data" . $krep11_rfXPq_closure" {
     $krep11_rfXPq_closure:
         const :_con_info;
         const $krep_rfXPf_closure+2;
         const $krep10_rfXPp_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.483496852 UTC

[section ""data" . $krep12_rfXPr_closure" {
     $krep12_rfXPr_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Sum.$tcSum_closure+1;
         const $krep11_rfXPq_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.485548557 UTC

[section ""data" . Data.Functor.Sum.$tc'InL1_closure" {
     Data.Functor.Sum.$tc'InL1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rfXPl_closure+3;
         const $krep12_rfXPr_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.487264692 UTC

[section ""cstring" . Data.Functor.Sum.$tc'InL3_bytes" {
     Data.Functor.Sum.$tc'InL3_bytes:
         I8[] [39,73,110,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.48888381 UTC

[section ""data" . Data.Functor.Sum.$tc'InL2_closure" {
     Data.Functor.Sum.$tc'InL2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$tc'InL3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.490728771 UTC

[section ""data" . Data.Functor.Sum.$tc'InL_closure" {
     Data.Functor.Sum.$tc'InL_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Sum.$trModule_closure+1;
         const Data.Functor.Sum.$tc'InL2_closure+1;
         const Data.Functor.Sum.$tc'InL1_closure+4;
         const 7951421854502432011;
         const 12303552236073891860;
         const 4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.492651582 UTC

[section ""data" . Data.Functor.Sum.$tc'InR1_closure" {
     Data.Functor.Sum.$tc'InR1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rfXPm_closure+3;
         const $krep12_rfXPr_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.494378716 UTC

[section ""cstring" . Data.Functor.Sum.$tc'InR3_bytes" {
     Data.Functor.Sum.$tc'InR3_bytes:
         I8[] [39,73,110,82]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.496076368 UTC

[section ""data" . Data.Functor.Sum.$tc'InR2_closure" {
     Data.Functor.Sum.$tc'InR2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$tc'InR3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.497811834 UTC

[section ""data" . Data.Functor.Sum.$tc'InR_closure" {
     Data.Functor.Sum.$tc'InR_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Sum.$trModule_closure+1;
         const Data.Functor.Sum.$tc'InR2_closure+1;
         const Data.Functor.Sum.$tc'InR1_closure+4;
         const 12078304815884238110;
         const 12377490770432979855;
         const 4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.500393078 UTC

[section ""data" . Data.Functor.Sum.$w$cp1Data_closure" {
     Data.Functor.Sum.$w$cp1Data_closure:
         const Data.Functor.Sum.$w$cp1Data_info;
         const 0;
 },
 Data.Functor.Sum.$w$cp1Data_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg1kI,
                       label: Data.Functor.Sum.$w$cp1Data_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1kI: // global
           _sfY0I::P64 = R5;
           _sfY0H::P64 = R4;
           _sfY0G::P64 = R3;
           _sfY0F::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cg1kM; else goto cg1kN;
       cg1kN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg1kP; else goto cg1kO;
       cg1kP: // global
           HpAlloc = 40;
           goto cg1kM;
       cg1kM: // global
           R5 = _sfY0I::P64;
           R4 = _sfY0H::P64;
           R3 = _sfY0G::P64;
           R2 = _sfY0F::P64;
           R1 = Data.Functor.Sum.$w$cp1Data_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1kO: // global
           I64[Hp - 32] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 24] = _sfY0I::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 32] = block_cg1kB_info;
           R6 = 1;
           R5 = Data.Functor.Sum.$fDataSum7_closure+1;
           R4 = Data.Functor.Sum.$trModule_closure+1;
           R3 = 1236278515871186010;
           R2 = 6345190594862254730;
           P64[Sp - 48] = Data.Functor.Sum.$fDataSum6_closure+4;
           P64[Sp - 40] = Hp - 14;
           P64[Sp - 24] = _sfY0F::P64;
           P64[Sp - 16] = _sfY0G::P64;
           P64[Sp - 8] = _sfY0H::P64;
           Sp = Sp - 48;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 8;
     }
 },
 _cg1kB() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg1kB,
                       label: block_cg1kB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1kB: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cg1kC() args: 0, res: 0, upd: 0;
     }
 },
 _cg1kC() //  []
         { info_tbl: [(cg1kC,
                       label: block_cg1kC_info
                       rep:StackRep [True, False, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1kC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg1kS; else goto cg1kR;
       cg1kS: // global
           HpAlloc = 48;
           I64[Sp] = block_cg1kC_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cg1kR: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 40] = block_cg1kG_info;
           R3 = P64[Sp + 56];
           R2 = Hp - 38;
           Sp = Sp + 40;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg1kG() //  [R1]
         { info_tbl: [(cg1kG,
                       label: block_cg1kG_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1kG: // global
           I64[Sp] = block_cg1kL_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg1kL() //  [R1]
         { info_tbl: [(cg1kL,
                       label: block_cg1kL_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1kL: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.51241289 UTC

[section ""data" . Data.Functor.Sum.$fDataSum5_closure" {
     Data.Functor.Sum.$fDataSum5_closure:
         const Data.Functor.Sum.$fDataSum5_info;
         const 0;
 },
 Data.Functor.Sum.$fDataSum5_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg1ls,
                       label: Data.Functor.Sum.$fDataSum5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1ls: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Sum.$w$cp1Data_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.516416798 UTC

[section ""data" . Data.Functor.Sum.$fDataSum2_closure" {
     Data.Functor.Sum.$fDataSum2_closure:
         const (,)_con_info;
         const Data.Functor.Sum.InL_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.518644664 UTC

[section ""data" . Data.Functor.Sum.$fDataSum1_closure" {
     Data.Functor.Sum.$fDataSum1_closure:
         const (,)_con_info;
         const Data.Functor.Sum.InR_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.523135694 UTC

[section ""data" . Data.Functor.Sum.$w$cgmapMp_closure" {
     Data.Functor.Sum.$w$cgmapMp_closure:
         const Data.Functor.Sum.$w$cgmapMp_info;
 },
 lvl8_sfY15_entry() //  [R1]
         { info_tbl: [(cg1lJ,
                       label: lvl8_sfY15_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1lJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg1lK; else goto cg1lL;
       cg1lK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1lL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfY1A_entry() //  [R1, R2]
         { info_tbl: [(cg1lY,
                       label: sat_sfY1A_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1lY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1lZ; else goto cg1m0;
       cg1lZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1m0: // global
           I64[Sp - 24] = block_cg1lV_info;
           _sfY15::P64 = P64[R1 + 7];
           _sfY16::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfY15::P64;
           P64[Sp - 8] = _sfY16::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug1mi; else goto cg1lW;
       ug1mi: // global
           call _cg1lV(R1) args: 0, res: 0, upd: 0;
       cg1lW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1lV() //  [R1]
         { info_tbl: [(cg1lV,
                       label: block_cg1lV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1lV: // global
           I64[Sp - 8] = block_cg1m3_info;
           _sfY1x::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfY1x::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1mh; else goto cg1m5;
       ug1mh: // global
           call _cg1m3(R1) args: 0, res: 0, upd: 0;
       cg1m5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1m3() //  [R1]
         { info_tbl: [(cg1m3,
                       label: block_cg1m3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1m3: // global
           if (R1 & 7 == 1) goto cg1mb; else goto cg1mf;
       cg1mb: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg1mf: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY1n_entry() //  [R1]
         { info_tbl: [(cg1mJ,
                       label: sat_sfY1n_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1mJ: // global
           _sfY1n::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg1mK; else goto cg1mL;
       cg1mL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg1mN; else goto cg1mM;
       cg1mN: // global
           HpAlloc = 56;
           goto cg1mK;
       cg1mK: // global
           R1 = _sfY1n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1mM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY1n::P64;
           _sfY16::P64 = P64[_sfY1n::P64 + 16];
           _sfY1a::P64 = P64[_sfY1n::P64 + 24];
           _sfY1e::P64 = P64[_sfY1n::P64 + 32];
           _sfY1f::P64 = P64[_sfY1n::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY1e::P64;
           P64[Hp - 24] = _sfY1a::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sfY1f::P64;
           R2 = _sfY16::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY1j_entry() //  [R1, R2]
         { info_tbl: [(cg1mZ,
                       label: sat_sfY1j_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1mZ: // global
           _sfY1g::P64 = R2;
           _sfY1j::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg1n0; else goto cg1n1;
       cg1n1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg1n3; else goto cg1n2;
       cg1n3: // global
           HpAlloc = 56;
           goto cg1n0;
       cg1n0: // global
           R2 = _sfY1g::P64;
           R1 = _sfY1j::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1n2: // global
           _sfY16::P64 = P64[_sfY1j::P64 + 7];
           _sfY1e::P64 = P64[_sfY1j::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY1e::P64;
           P64[Hp - 24] = _sfY1g::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sfY16::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY1k_entry() //  [R1]
         { info_tbl: [(cg1n4,
                       label: sat_sfY1k_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1n4: // global
           _sfY1k::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg1n5; else goto cg1n6;
       cg1n6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg1n8; else goto cg1n7;
       cg1n8: // global
           HpAlloc = 24;
           goto cg1n5;
       cg1n5: // global
           R1 = _sfY1k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1n7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY1k::P64;
           _sfY16::P64 = P64[_sfY1k::P64 + 16];
           _sfY1b::P64 = P64[_sfY1k::P64 + 24];
           _sfY1e::P64 = P64[_sfY1k::P64 + 32];
           I64[Hp - 16] = sat_sfY1j_info;
           P64[Hp - 8] = _sfY16::P64;
           P64[Hp] = _sfY1e::P64;
           R2 = _sfY16::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sfY1b::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sfY1o_entry() //  [R1, R2]
         { info_tbl: [(cg1n9,
                       label: sat_sfY1o_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1n9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg1na; else goto cg1nb;
       cg1na: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1nb: // global
           I64[Sp - 40] = block_cg1my_info;
           _sfY12::P64 = P64[R1 + 7];
           _sfY16::P64 = P64[R1 + 15];
           _sfY1a::P64 = P64[R1 + 23];
           _sfY1b::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sfY12::P64;
           P64[Sp - 24] = _sfY16::P64;
           P64[Sp - 16] = _sfY1a::P64;
           P64[Sp - 8] = _sfY1b::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug1nf; else goto cg1mz;
       ug1nf: // global
           call _cg1my(R1) args: 0, res: 0, upd: 0;
       cg1mz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1my() //  [R1]
         { info_tbl: [(cg1my,
                       label: block_cg1my_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1my: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg1ne; else goto cg1nd;
       cg1ne: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1nd: // global
           _sfY1e::P64 = P64[R1 + 7];
           _sfY1f::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sfY1n_info;
           _sfY16::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sfY16::P64;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _sfY1e::P64;
           P64[Hp - 40] = _sfY1f::P64;
           I64[Hp - 32] = sat_sfY1k_info;
           P64[Hp - 16] = _sfY16::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sfY1e::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sfY17_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg1ng,
                       label: k1_sfY17_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1ng: // global
           _sfY1a::P64 = R4;
           _sfY19::P64 = R3;
           _sfY18::P64 = R2;
           _sfY17::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg1nh; else goto cg1ni;
       cg1ni: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg1nk; else goto cg1nj;
       cg1nk: // global
           HpAlloc = 80;
           goto cg1nh;
       cg1nh: // global
           R4 = _sfY1a::P64;
           R3 = _sfY19::P64;
           R2 = _sfY18::P64;
           R1 = _sfY17::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1nj: // global
           _sfY12::P64 = P64[_sfY17::P64 + 5];
           _sfY13::P64 = P64[_sfY17::P64 + 13];
           _sfY16::P64 = P64[_sfY17::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sfY13::P64;
           P64[Hp - 48] = _sfY18::P64;
           P64[Hp - 40] = _sfY1a::P64;
           I64[Hp - 32] = sat_sfY1o_info;
           P64[Hp - 24] = _sfY12::P64;
           P64[Hp - 16] = _sfY16::P64;
           P64[Hp - 8] = _sfY1a::P64;
           P64[Hp] = Hp - 72;
           R2 = _sfY16::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sfY19::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY1r_entry() //  [R1]
         { info_tbl: [(cg1nu,
                       label: sat_sfY1r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1nu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1nv; else goto cg1nw;
       cg1nv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1nw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY1t_entry() //  [R1]
         { info_tbl: [(cg1nD,
                       label: sat_sfY1t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1nD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1nE; else goto cg1nF;
       cg1nE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1nF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY1u_entry() //  [R1]
         { info_tbl: [(cg1nK,
                       label: sat_sfY1u_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1nK: // global
           _sfY1u::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cg1nL; else goto cg1nM;
       cg1nM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg1nO; else goto cg1nN;
       cg1nO: // global
           HpAlloc = 32;
           goto cg1nL;
       cg1nL: // global
           R1 = _sfY1u::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1nN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY1u::P64;
           _sfY10::P64 = P64[_sfY1u::P64 + 16];
           _sfY11::P64 = P64[_sfY1u::P64 + 24];
           _sfY12::P64 = P64[_sfY1u::P64 + 32];
           _sfY13::P64 = P64[_sfY1u::P64 + 40];
           _sfY14::P64 = P64[_sfY1u::P64 + 48];
           _sfY16::P64 = P64[_sfY1u::P64 + 56];
           I64[Hp - 24] = k1_sfY17_info;
           P64[Hp - 16] = _sfY12::P64;
           P64[Hp - 8] = _sfY13::P64;
           P64[Hp] = _sfY16::P64;
           I64[Sp - 56] = block_cg1nl_info;
           R1 = _sfY14::P64;
           P64[Sp - 48] = Hp - 21;
           P64[Sp - 40] = _sfY10::P64;
           P64[Sp - 32] = _sfY11::P64;
           P64[Sp - 24] = _sfY16::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ug1nV; else goto cg1nm;
       ug1nV: // global
           call _cg1nl(R1) args: 0, res: 0, upd: 0;
       cg1nm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg1nl() //  [R1]
         { info_tbl: [(cg1nl,
                       label: block_cg1nl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1nl: // global
           _cg1mn::P64 = P64[Sp + 8];
           _sfY16::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg1nH; else goto cg1nI;
       cg1nH: // global
           Hp = Hp + 24;
           _sfY1p::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1nU; else goto cg1nQ;
       cg1nQ: // global
           _sfY1q::P64 = P64[_sfY1p::P64 + 7];
           I64[Hp - 16] = sat_sfY1r_info;
           P64[Hp] = _sfY16::P64;
           R4 = _sfY1q::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _cg1mn::P64;
           Sp = Sp + 40;
           call k1_sfY17_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
       cg1nI: // global
           Hp = Hp + 24;
           _sfY1p::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1nU; else goto cg1nT;
       cg1nU: // global
           HpAlloc = 24;
           R1 = _sfY1p::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg1nT: // global
           _sfY1s::P64 = P64[_sfY1p::P64 + 6];
           I64[Hp - 16] = sat_sfY1t_info;
           P64[Hp] = _sfY16::P64;
           R4 = _sfY1s::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 24];
           R1 = _cg1mn::P64;
           Sp = Sp + 40;
           call k1_sfY17_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgmapMp_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg1nW,
                       label: Data.Functor.Sum.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1nW: // global
           _sfY14::P64 = R6;
           _sfY13::P64 = R5;
           _sfY12::P64 = R4;
           _sfY11::P64 = R3;
           _sfY10::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg1nX; else goto cg1nY;
       cg1nY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg1o0; else goto cg1nZ;
       cg1o0: // global
           HpAlloc = 24;
           goto cg1nX;
       cg1nX: // global
           R6 = _sfY14::P64;
           R5 = _sfY13::P64;
           R4 = _sfY12::P64;
           R3 = _sfY11::P64;
           R2 = _sfY10::P64;
           R1 = Data.Functor.Sum.$w$cgmapMp_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1nZ: // global
           I64[Hp - 16] = lvl8_sfY15_info;
           P64[Hp] = _sfY12::P64;
           I64[Sp - 56] = block_cg1lM_info;
           R2 = _sfY12::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sfY10::P64;
           P64[Sp - 32] = _sfY11::P64;
           P64[Sp - 24] = _sfY12::P64;
           P64[Sp - 16] = _sfY13::P64;
           P64[Sp - 8] = _sfY14::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg1lM() //  [R1]
         { info_tbl: [(cg1lM,
                       label: block_cg1lM_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1lM: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg1o3; else goto cg1o2;
       cg1o3: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1o2: // global
           I64[Hp - 80] = sat_sfY1A_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sfY1u_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.562394544 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapMp_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapMp_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapMp_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapMp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1px: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapMp_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapMp_entry() //  [R6]
         { info_tbl: [(cg1pB,
                       label: Data.Functor.Sum.$fDataSum_$cgmapMp_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1pB: // global
           _sfY1F::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sfY1F::P64;
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgmapMp_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.568797372 UTC

[section ""data" . Data.Functor.Sum.$w$cgmapM_closure" {
     Data.Functor.Sum.$w$cgmapM_closure:
         const Data.Functor.Sum.$w$cgmapM_info;
 },
 sat_sfY1X_entry() //  [R1, R2]
         { info_tbl: [(cg1q5,
                       label: sat_sfY1X_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1q5: // global
           _sfY1V::P64 = R2;
           _sfY1X::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg1q6; else goto cg1q7;
       cg1q7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg1q9; else goto cg1q8;
       cg1q9: // global
           HpAlloc = 32;
           goto cg1q6;
       cg1q6: // global
           R2 = _sfY1V::P64;
           R1 = _sfY1X::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1q8: // global
           _sfY1M::P64 = P64[_sfY1X::P64 + 7];
           _sfY1U::P64 = P64[_sfY1X::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sfY1U::P64;
           P64[Hp] = _sfY1V::P64;
           R2 = _sfY1M::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY1Y_entry() //  [R1, R2]
         { info_tbl: [(cg1qa,
                       label: sat_sfY1Y_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1qa: // global
           _sfY1U::P64 = R2;
           _sfY1Y::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg1qb; else goto cg1qc;
       cg1qc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg1qe; else goto cg1qd;
       cg1qe: // global
           HpAlloc = 24;
           goto cg1qb;
       cg1qb: // global
           R2 = _sfY1U::P64;
           R1 = _sfY1Y::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1qd: // global
           _sfY1M::P64 = P64[_sfY1Y::P64 + 7];
           _sfY1T::P64 = P64[_sfY1Y::P64 + 15];
           I64[Hp - 16] = sat_sfY1X_info;
           P64[Hp - 8] = _sfY1M::P64;
           P64[Hp] = _sfY1U::P64;
           R2 = _sfY1M::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sfY1T::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sfY1P_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg1qf,
                       label: k1_sfY1P_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1qf: // global
           _sfY1S::P64 = R4;
           _sfY1R::P64 = R3;
           _sfY1Q::P64 = R2;
           _sfY1P::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg1qg; else goto cg1qh;
       cg1qh: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg1qj; else goto cg1qi;
       cg1qj: // global
           HpAlloc = 64;
           goto cg1qg;
       cg1qg: // global
           R4 = _sfY1S::P64;
           R3 = _sfY1R::P64;
           R2 = _sfY1Q::P64;
           R1 = _sfY1P::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1qi: // global
           _sfY1M::P64 = P64[_sfY1P::P64 + 5];
           _sfY1N::P64 = P64[_sfY1P::P64 + 13];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sfY1N::P64;
           P64[Hp - 32] = _sfY1Q::P64;
           P64[Hp - 24] = _sfY1S::P64;
           I64[Hp - 16] = sat_sfY1Y_info;
           P64[Hp - 8] = _sfY1M::P64;
           P64[Hp] = Hp - 56;
           R2 = _sfY1M::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sfY1R::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY21_entry() //  [R1]
         { info_tbl: [(cg1qt,
                       label: sat_sfY21_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1qt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1qu; else goto cg1qv;
       cg1qu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1qv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.InL_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY23_entry() //  [R1]
         { info_tbl: [(cg1qC,
                       label: sat_sfY23_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1qC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1qD; else goto cg1qE;
       cg1qD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1qE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.InR_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgmapM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg1qJ,
                       label: Data.Functor.Sum.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1qJ: // global
           _sfY1O::P64 = R6;
           _sfY1N::P64 = R5;
           _sfY1M::P64 = R4;
           _sfY1L::P64 = R3;
           _sfY1K::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cg1qK; else goto cg1qL;
       cg1qL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg1qN; else goto cg1qM;
       cg1qN: // global
           HpAlloc = 24;
           goto cg1qK;
       cg1qK: // global
           R6 = _sfY1O::P64;
           R5 = _sfY1N::P64;
           R4 = _sfY1M::P64;
           R3 = _sfY1L::P64;
           R2 = _sfY1K::P64;
           R1 = Data.Functor.Sum.$w$cgmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1qM: // global
           I64[Hp - 16] = k1_sfY1P_info;
           P64[Hp - 8] = _sfY1M::P64;
           P64[Hp] = _sfY1N::P64;
           I64[Sp - 40] = block_cg1qk_info;
           R1 = _sfY1O::P64;
           P64[Sp - 32] = Hp - 13;
           P64[Sp - 24] = _sfY1K::P64;
           P64[Sp - 16] = _sfY1L::P64;
           P64[Sp - 8] = _sfY1M::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug1qU; else goto cg1ql;
       ug1qU: // global
           call _cg1qk(R1) args: 0, res: 0, upd: 0;
       cg1ql: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1qk() //  [R1]
         { info_tbl: [(cg1qk,
                       label: block_cg1qk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1qk: // global
           _cg1pO::P64 = P64[Sp + 8];
           _sfY1M::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg1qG; else goto cg1qH;
       cg1qG: // global
           Hp = Hp + 24;
           _sfY1Z::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1qT; else goto cg1qP;
       cg1qP: // global
           _sfY20::P64 = P64[_sfY1Z::P64 + 7];
           I64[Hp - 16] = sat_sfY21_info;
           P64[Hp] = _sfY1M::P64;
           R4 = _sfY20::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _cg1pO::P64;
           Sp = Sp + 40;
           call k1_sfY1P_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1qH: // global
           Hp = Hp + 24;
           _sfY1Z::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1qT; else goto cg1qS;
       cg1qT: // global
           HpAlloc = 24;
           R1 = _sfY1Z::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1qS: // global
           _sfY22::P64 = P64[_sfY1Z::P64 + 6];
           I64[Hp - 16] = sat_sfY23_info;
           P64[Hp] = _sfY1M::P64;
           R4 = _sfY22::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 24];
           R1 = _cg1pO::P64;
           Sp = Sp + 40;
           call k1_sfY1P_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.587155895 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapM_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapM_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapM_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapM_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1rw: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapM_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapM_entry() //  [R6]
         { info_tbl: [(cg1rA,
                       label: Data.Functor.Sum.$fDataSum_$cgmapM_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1rA: // global
           _sfY28::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sfY28::P64;
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgmapM_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.59273578 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapQi_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapQi_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapQi_info;
         const 0;
 },
 Data.Functor.Sum.$fDataSum_$cgmapQi_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1rK: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQi_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapQi_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg1rV,
                       label: Data.Functor.Sum.$fDataSum_$cgmapQi_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1rV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1rW; else goto cg1rX;
       cg1rW: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgmapQi_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cg1rX: // global
           I64[Sp - 8] = block_cg1rO_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1ss; else goto cg1rP;
       ug1ss: // global
           call _cg1rO(R1) args: 0, res: 0, upd: 0;
       cg1rP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1rO() //  [R1]
         { info_tbl: [(cg1rO,
                       label: block_cg1rO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1rO: // global
           _sfY2j::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg1rS; else goto cg1rT;
       cg1rS: // global
           I64[Sp + 8] = block_cg1s0_info;
           _sfY2n::P64 = P64[R1 + 7];
           R1 = _sfY2j::P64;
           P64[Sp + 16] = _sfY2n::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug1sq; else goto cg1s2;
       ug1sq: // global
           call _cg1s0(R1) args: 0, res: 0, upd: 0;
       cg1s2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg1rT: // global
           I64[Sp] = block_cg1sd_info;
           _sfY2r::P64 = P64[R1 + 6];
           R1 = _sfY2j::P64;
           P64[Sp + 32] = _sfY2r::P64;
           if (R1 & 7 != 0) goto ug1sr; else goto cg1sf;
       ug1sr: // global
           call _cg1sd(R1) args: 0, res: 0, upd: 0;
       cg1sf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1s0() //  [R1]
         { info_tbl: [(cg1s0,
                       label: block_cg1s0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1s0: // global
           if (I64[R1 + 7] == 0) goto cg1sa; else goto ug1sp;
       cg1sa: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       ug1sp: // global
           Sp = Sp + 32;
           call _cg1sm() args: 0, res: 0, upd: 0;
     }
 },
 _cg1sd() //  [R1]
         { info_tbl: [(cg1sd,
                       label: block_cg1sd_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1sd: // global
           if (I64[R1 + 7] == 0) goto cg1sn; else goto ug1so;
       cg1sn: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       ug1so: // global
           Sp = Sp + 40;
           call _cg1sm() args: 0, res: 0, upd: 0;
     }
 },
 _cg1sm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1sm: // global
           R1 = Data.Maybe.fromJust1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.606276447 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapQr_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapQr_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapQr_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapQr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1sT: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQr_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 48, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapQr_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg1t4,
                       label: Data.Functor.Sum.$fDataSum_$cgmapQr_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1t4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1t5; else goto cg1t6;
       cg1t5: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgmapQr_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cg1t6: // global
           I64[Sp - 8] = block_cg1sX_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1tj; else goto cg1sY;
       ug1tj: // global
           call _cg1sX(R1) args: 0, res: 0, upd: 0;
       cg1sY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1sX() //  [R1]
         { info_tbl: [(cg1sX,
                       label: block_cg1sX_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1sX: // global
           _sfY2B::P64 = P64[Sp + 16];
           _sfY2C::P64 = P64[Sp + 24];
           _sfY2D::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg1t1; else goto cg1t2;
       cg1t1: // global
           Hp = Hp + 40;
           _sfY2F::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1ti; else goto cg1tb;
       cg1tb: // global
           _sfY2G::P64 = P64[_sfY2F::P64 + 7];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sfY2D::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sfY2G::P64;
           R3 = _sfY2C::P64;
           R2 = Hp - 32;
           R1 = _sfY2B::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1t2: // global
           Hp = Hp + 40;
           _sfY2F::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1ti; else goto cg1th;
       cg1ti: // global
           HpAlloc = 40;
           R1 = _sfY2F::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1th: // global
           _sfY2I::P64 = P64[_sfY2F::P64 + 6];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sfY2D::P64;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sfY2I::P64;
           R3 = _sfY2C::P64;
           R2 = Hp - 32;
           R1 = _sfY2B::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.615265623 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapQ_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapQ_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapQ_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapQ_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1tA: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQ_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapQ_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg1tL,
                       label: Data.Functor.Sum.$fDataSum_$cgmapQ_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1tL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1tM; else goto cg1tN;
       cg1tM: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgmapQ_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cg1tN: // global
           I64[Sp - 8] = block_cg1tE_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1u2; else goto cg1tF;
       ug1u2: // global
           call _cg1tE(R1) args: 0, res: 0, upd: 0;
       cg1tF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1tE() //  [R1]
         { info_tbl: [(cg1tE,
                       label: block_cg1tE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1tE: // global
           _sfY2Q::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg1tI; else goto cg1tJ;
       cg1tI: // global
           Hp = Hp + 64;
           _sfY2S::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1u1; else goto cg1tT;
       cg1tT: // global
           _sfY2T::P64 = P64[_sfY2S::P64 + 7];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sfY2Q::P64;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sfY2T::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg1tJ: // global
           Hp = Hp + 64;
           _sfY2S::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1u1; else goto cg1u0;
       cg1u1: // global
           HpAlloc = 64;
           R1 = _sfY2S::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1u0: // global
           _sfY2V::P64 = P64[_sfY2S::P64 + 6];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sfY2Q::P64;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sfY2V::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.623955907 UTC

[section ""data" . Data.Functor.Sum.$fDataSum3_closure" {
     Data.Functor.Sum.$fDataSum3_closure:
         const Data.Functor.Sum.$fDataSum3_info;
 },
 Data.Functor.Sum.$fDataSum3_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1un: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum3_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 48, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg1uy,
                       label: Data.Functor.Sum.$fDataSum3_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1uy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1uz; else goto cg1uA;
       cg1uz: // global
           R1 = Data.Functor.Sum.$fDataSum3_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cg1uA: // global
           I64[Sp - 8] = block_cg1ur_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1uN; else goto cg1us;
       ug1uN: // global
           call _cg1ur(R1) args: 0, res: 0, upd: 0;
       cg1us: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1ur() //  [R1]
         { info_tbl: [(cg1ur,
                       label: block_cg1ur_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1ur: // global
           _sfY33::P64 = P64[Sp + 16];
           _sfY34::P64 = P64[Sp + 24];
           _sfY35::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg1uv; else goto cg1uw;
       cg1uv: // global
           Hp = Hp + 40;
           _sfY37::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1uM; else goto cg1uF;
       cg1uF: // global
           _sfY38::P64 = P64[_sfY37::P64 + 7];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sfY35::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sfY38::P64;
           R3 = Hp - 32;
           R2 = _sfY34::P64;
           R1 = _sfY33::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1uw: // global
           Hp = Hp + 40;
           _sfY37::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1uM; else goto cg1uL;
       cg1uM: // global
           HpAlloc = 40;
           R1 = _sfY37::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1uL: // global
           _sfY3a::P64 = P64[_sfY37::P64 + 6];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sfY35::P64;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sfY3a::P64;
           R3 = Hp - 32;
           R2 = _sfY34::P64;
           R1 = _sfY33::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.632831701 UTC

[section ""data" . Data.Functor.Sum.$fDataSum4_closure" {
     Data.Functor.Sum.$fDataSum4_closure:
         const Data.Functor.Sum.$fDataSum4_info;
 },
 Data.Functor.Sum.$fDataSum4_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1v4: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg1vf,
                       label: Data.Functor.Sum.$fDataSum4_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1vf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1vg; else goto cg1vh;
       cg1vg: // global
           R1 = Data.Functor.Sum.$fDataSum4_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cg1vh: // global
           I64[Sp - 8] = block_cg1v8_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1vw; else goto cg1v9;
       ug1vw: // global
           call _cg1v8(R1) args: 0, res: 0, upd: 0;
       cg1v9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1v8() //  [R1]
         { info_tbl: [(cg1v8,
                       label: block_cg1v8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1v8: // global
           _sfY3i::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg1vc; else goto cg1vd;
       cg1vc: // global
           Hp = Hp + 56;
           _sfY3k::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1vv; else goto cg1vn;
       cg1vn: // global
           _sfY3l::P64 = P64[_sfY3k::P64 + 7];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = _sfY3i::P64;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sfY3l::P64;
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg1vd: // global
           Hp = Hp + 56;
           _sfY3k::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1vv; else goto cg1vu;
       cg1vv: // global
           HpAlloc = 56;
           R1 = _sfY3k::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1vu: // global
           _sfY3n::P64 = P64[_sfY3k::P64 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = _sfY3i::P64;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sfY3n::P64;
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.644095768 UTC

[section ""data" . Data.Functor.Sum.$w$cgmapMo_closure" {
     Data.Functor.Sum.$w$cgmapMo_closure:
         const Data.Functor.Sum.$w$cgmapMo_info;
 },
 lvl8_sfY3u_entry() //  [R1]
         { info_tbl: [(cg1vY,
                       label: lvl8_sfY3u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1vY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg1vZ; else goto cg1w0;
       cg1vZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1w0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfY42_entry() //  [R1, R2]
         { info_tbl: [(cg1wd,
                       label: sat_sfY42_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1wd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1we; else goto cg1wf;
       cg1we: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1wf: // global
           I64[Sp - 24] = block_cg1wa_info;
           _sfY3u::P64 = P64[R1 + 7];
           _sfY3v::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfY3u::P64;
           P64[Sp - 8] = _sfY3v::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug1wx; else goto cg1wb;
       ug1wx: // global
           call _cg1wa(R1) args: 0, res: 0, upd: 0;
       cg1wb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1wa() //  [R1]
         { info_tbl: [(cg1wa,
                       label: block_cg1wa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1wa: // global
           I64[Sp - 8] = block_cg1wi_info;
           _sfY3Z::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfY3Z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1ww; else goto cg1wk;
       ug1ww: // global
           call _cg1wi(R1) args: 0, res: 0, upd: 0;
       cg1wk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1wi() //  [R1]
         { info_tbl: [(cg1wi,
                       label: block_cg1wi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1wi: // global
           if (R1 & 7 == 1) goto cg1wq; else goto cg1wu;
       cg1wq: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg1wu: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY3N_entry() //  [R1]
         { info_tbl: [(cg1x3,
                       label: sat_sfY3N_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1x3: // global
           _sfY3N::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg1x4; else goto cg1x5;
       cg1x5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg1x7; else goto cg1x6;
       cg1x7: // global
           HpAlloc = 56;
           goto cg1x4;
       cg1x4: // global
           R1 = _sfY3N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1x6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY3N::P64;
           _sfY3v::P64 = P64[_sfY3N::P64 + 16];
           _sfY3z::P64 = P64[_sfY3N::P64 + 24];
           _sfY3D::P64 = P64[_sfY3N::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY3D::P64;
           P64[Hp - 24] = _sfY3z::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sfY3v::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY3J_entry() //  [R1, R2]
         { info_tbl: [(cg1xj,
                       label: sat_sfY3J_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1xj: // global
           _sfY3G::P64 = R2;
           _sfY3J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg1xk; else goto cg1xl;
       cg1xl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg1xn; else goto cg1xm;
       cg1xn: // global
           HpAlloc = 56;
           goto cg1xk;
       cg1xk: // global
           R2 = _sfY3G::P64;
           R1 = _sfY3J::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1xm: // global
           _sfY3v::P64 = P64[_sfY3J::P64 + 7];
           _sfY3D::P64 = P64[_sfY3J::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY3D::P64;
           P64[Hp - 24] = _sfY3G::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sfY3v::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sfY3K_entry() //  [R1]
         { info_tbl: [(cg1xo,
                       label: sat_sfY3K_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1xo: // global
           _sfY3K::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg1xp; else goto cg1xq;
       cg1xq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg1xs; else goto cg1xr;
       cg1xs: // global
           HpAlloc = 24;
           goto cg1xp;
       cg1xp: // global
           R1 = _sfY3K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1xr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY3K::P64;
           _sfY3v::P64 = P64[_sfY3K::P64 + 16];
           _sfY3A::P64 = P64[_sfY3K::P64 + 24];
           _sfY3D::P64 = P64[_sfY3K::P64 + 32];
           I64[Hp - 16] = sat_sfY3J_info;
           P64[Hp - 8] = _sfY3v::P64;
           P64[Hp] = _sfY3D::P64;
           R2 = _sfY3v::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sfY3A::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sfY3Q_entry() //  [R1, R2]
         { info_tbl: [(cg1xt,
                       label: sat_sfY3Q_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1xt: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg1xu; else goto cg1xv;
       cg1xu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1xv: // global
           I64[Sp - 40] = block_cg1wN_info;
           _sfY3r::P64 = P64[R1 + 7];
           _sfY3v::P64 = P64[R1 + 15];
           _sfY3z::P64 = P64[R1 + 23];
           _sfY3A::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sfY3r::P64;
           P64[Sp - 24] = _sfY3v::P64;
           P64[Sp - 16] = _sfY3z::P64;
           P64[Sp - 8] = _sfY3A::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug1xM; else goto cg1wO;
       ug1xM: // global
           call _cg1wN(R1) args: 0, res: 0, upd: 0;
       cg1wO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1wN() //  [R1]
         { info_tbl: [(cg1wN,
                       label: block_cg1wN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1wN: // global
           I64[Sp - 8] = block_cg1wS_info;
           _sfY3D::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfY3D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1xL; else goto cg1wT;
       ug1xL: // global
           call _cg1wS(R1) args: 0, res: 0, upd: 0;
       cg1wT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1wS() //  [R1]
         { info_tbl: [(cg1wS,
                       label: block_cg1wS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1wS: // global
           _sfY3v::P64 = P64[Sp + 24];
           _sfY3z::P64 = P64[Sp + 32];
           _sfY3D::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cg1xy; else goto cg1xC;
       cg1xy: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg1xB; else goto cg1xA;
       cg1xB: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1xA: // global
           I64[Hp - 72] = sat_sfY3N_info;
           P64[Hp - 56] = _sfY3v::P64;
           P64[Hp - 48] = _sfY3z::P64;
           P64[Hp - 40] = _sfY3D::P64;
           I64[Hp - 32] = sat_sfY3K_info;
           P64[Hp - 16] = _sfY3v::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sfY3D::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cg1xC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg1xH; else goto cg1xG;
       cg1xH: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1xG: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sfY3D::P64;
           P64[Hp - 24] = _sfY3z::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sfY3v::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 k1_sfY3w_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg1xN,
                       label: k1_sfY3w_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1xN: // global
           _sfY3z::P64 = R4;
           _sfY3y::P64 = R3;
           _sfY3x::P64 = R2;
           _sfY3w::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg1xO; else goto cg1xP;
       cg1xP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg1xR; else goto cg1xQ;
       cg1xR: // global
           HpAlloc = 80;
           goto cg1xO;
       cg1xO: // global
           R4 = _sfY3z::P64;
           R3 = _sfY3y::P64;
           R2 = _sfY3x::P64;
           R1 = _sfY3w::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1xQ: // global
           _sfY3r::P64 = P64[_sfY3w::P64 + 5];
           _sfY3s::P64 = P64[_sfY3w::P64 + 13];
           _sfY3v::P64 = P64[_sfY3w::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sfY3s::P64;
           P64[Hp - 48] = _sfY3x::P64;
           P64[Hp - 40] = _sfY3z::P64;
           I64[Hp - 32] = sat_sfY3Q_info;
           P64[Hp - 24] = _sfY3r::P64;
           P64[Hp - 16] = _sfY3v::P64;
           P64[Hp - 8] = _sfY3z::P64;
           P64[Hp] = Hp - 72;
           R2 = _sfY3v::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sfY3y::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY3T_entry() //  [R1]
         { info_tbl: [(cg1y1,
                       label: sat_sfY3T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1y1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1y2; else goto cg1y3;
       cg1y2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1y3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY3V_entry() //  [R1]
         { info_tbl: [(cg1ya,
                       label: sat_sfY3V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1ya: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1yb; else goto cg1yc;
       cg1yb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1yc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sfY3W_entry() //  [R1]
         { info_tbl: [(cg1yh,
                       label: sat_sfY3W_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1yh: // global
           _sfY3W::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cg1yi; else goto cg1yj;
       cg1yj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg1yl; else goto cg1yk;
       cg1yl: // global
           HpAlloc = 32;
           goto cg1yi;
       cg1yi: // global
           R1 = _sfY3W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1yk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sfY3W::P64;
           _sfY3p::P64 = P64[_sfY3W::P64 + 16];
           _sfY3q::P64 = P64[_sfY3W::P64 + 24];
           _sfY3r::P64 = P64[_sfY3W::P64 + 32];
           _sfY3s::P64 = P64[_sfY3W::P64 + 40];
           _sfY3t::P64 = P64[_sfY3W::P64 + 48];
           _sfY3v::P64 = P64[_sfY3W::P64 + 56];
           I64[Hp - 24] = k1_sfY3w_info;
           P64[Hp - 16] = _sfY3r::P64;
           P64[Hp - 8] = _sfY3s::P64;
           P64[Hp] = _sfY3v::P64;
           I64[Sp - 56] = block_cg1xS_info;
           R1 = _sfY3t::P64;
           P64[Sp - 48] = Hp - 21;
           P64[Sp - 40] = _sfY3p::P64;
           P64[Sp - 32] = _sfY3q::P64;
           P64[Sp - 24] = _sfY3v::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ug1ys; else goto cg1xT;
       ug1ys: // global
           call _cg1xS(R1) args: 0, res: 0, upd: 0;
       cg1xT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg1xS() //  [R1]
         { info_tbl: [(cg1xS,
                       label: block_cg1xS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1xS: // global
           _cg1wC::P64 = P64[Sp + 8];
           _sfY3v::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg1ye; else goto cg1yf;
       cg1ye: // global
           Hp = Hp + 24;
           _sfY3R::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1yr; else goto cg1yn;
       cg1yn: // global
           _sfY3S::P64 = P64[_sfY3R::P64 + 7];
           I64[Hp - 16] = sat_sfY3T_info;
           P64[Hp] = _sfY3v::P64;
           R4 = _sfY3S::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _cg1wC::P64;
           Sp = Sp + 40;
           call k1_sfY3w_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
       cg1yf: // global
           Hp = Hp + 24;
           _sfY3R::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg1yr; else goto cg1yq;
       cg1yr: // global
           HpAlloc = 24;
           R1 = _sfY3R::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg1yq: // global
           _sfY3U::P64 = P64[_sfY3R::P64 + 6];
           I64[Hp - 16] = sat_sfY3V_info;
           P64[Hp] = _sfY3v::P64;
           R4 = _sfY3U::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 24];
           R1 = _cg1wC::P64;
           Sp = Sp + 40;
           call k1_sfY3w_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgmapMo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg1yt,
                       label: Data.Functor.Sum.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1yt: // global
           _sfY3t::P64 = R6;
           _sfY3s::P64 = R5;
           _sfY3r::P64 = R4;
           _sfY3q::P64 = R3;
           _sfY3p::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg1yu; else goto cg1yv;
       cg1yv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg1yx; else goto cg1yw;
       cg1yx: // global
           HpAlloc = 24;
           goto cg1yu;
       cg1yu: // global
           R6 = _sfY3t::P64;
           R5 = _sfY3s::P64;
           R4 = _sfY3r::P64;
           R3 = _sfY3q::P64;
           R2 = _sfY3p::P64;
           R1 = Data.Functor.Sum.$w$cgmapMo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1yw: // global
           I64[Hp - 16] = lvl8_sfY3u_info;
           P64[Hp] = _sfY3r::P64;
           I64[Sp - 56] = block_cg1w1_info;
           R2 = _sfY3r::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sfY3p::P64;
           P64[Sp - 32] = _sfY3q::P64;
           P64[Sp - 24] = _sfY3r::P64;
           P64[Sp - 16] = _sfY3s::P64;
           P64[Sp - 8] = _sfY3t::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg1w1() //  [R1]
         { info_tbl: [(cg1w1,
                       label: block_cg1w1_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1w1: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg1yA; else goto cg1yz;
       cg1yA: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg1yz: // global
           I64[Hp - 80] = sat_sfY42_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sfY3W_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.687680738 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapMo_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapMo_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapMo_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapMo_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Ab: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapMo_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapMo_entry() //  [R6]
         { info_tbl: [(cg1Af,
                       label: Data.Functor.Sum.$fDataSum_$cgmapMo_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Af: // global
           _sfY47::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sfY47::P64;
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgmapMo_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.692667879 UTC

[section ""data" . lvl4_rfXPs_closure" {
     lvl4_rfXPs_closure:
         const lvl4_rfXPs_info;
         const 0;
 },
 lvl4_rfXPs_entry() //  [R2]
         { info_tbl: [(cg1Az,
                       label: lvl4_rfXPs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Az: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1AA; else goto cg1AB;
       cg1AA: // global
           R2 = R2;
           R1 = lvl4_rfXPs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1AB: // global
           I64[Sp - 8] = block_cg1As_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug1AI; else goto cg1At;
       ug1AI: // global
           call _cg1As(R1) args: 0, res: 0, upd: 0;
       cg1At: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1As() //  [R1]
         { info_tbl: [(cg1As,
                       label: block_cg1As_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1As: // global
           if (R1 & 7 == 1) goto cg1Aw; else goto cg1Ax;
       cg1Aw: // global
           R1 = Data.Functor.Sum.$cInL_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg1Ax: // global
           R1 = Data.Functor.Sum.$cInR_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.698282541 UTC

[section ""data" . lvl5_rfXPt_closure" {
     lvl5_rfXPt_closure:
         const lvl5_rfXPt_info;
         const 0;
 },
 lvl5_rfXPt_entry() //  []
         { info_tbl: [(cg1B0,
                       label: lvl5_rfXPt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1B0: // global
           R1 = Data.Functor.Sum.$tSum_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.702253922 UTC

[section ""data" . lvl6_rfXPu_closure" {
     lvl6_rfXPu_closure:
         const lvl6_rfXPu_info;
 },
 lvl6_rfXPu_entry() //  []
         { info_tbl: [(cg1Bc,
                       label: lvl6_rfXPu_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Bc: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.706027501 UTC

[section ""data" . lvl7_rfXPv_closure" {
     lvl7_rfXPv_closure:
         const lvl7_rfXPv_info;
 },
 lvl7_rfXPv_entry() //  []
         { info_tbl: [(cg1Bo,
                       label: lvl7_rfXPv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Bo: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.711756858 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_closure" {
     Data.Functor.Sum.$fDataSum_closure:
         const Data.Functor.Sum.$fDataSum_info;
         const 0;
 },
 sat_sfY4K_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg1BF,
                       label: sat_sfY4K_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1BF: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$w$cgmapMo_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfY4G_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg1BN,
                       label: sat_sfY4G_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1BN: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$w$cgmapMp_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfY4C_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg1BV,
                       label: sat_sfY4C_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1BV: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$w$cgmapM_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfY4y_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg1C3,
                       label: sat_sfY4y_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1C3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1C4; else goto cg1C5;
       cg1C4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1C5: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Sum.$fDataSum_$cgmapQi_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sfY4x_entry() //  [R1, R2, R3]
         { info_tbl: [(cg1Cb,
                       label: sat_sfY4x_info
                       rep:HeapRep 6 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Cb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg1Cc; else goto cg1Cd;
       cg1Cc: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1Cd: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 46];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fDataSum_$cgmapQ_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY4w_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg1Cj,
                       label: sat_sfY4w_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Cj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg1Ck; else goto cg1Cl;
       cg1Ck: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1Cl: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQr_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sfY4v_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg1Cr,
                       label: sat_sfY4v_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Cr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg1Cs; else goto cg1Ct;
       cg1Cs: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1Ct: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Sum.$fDataSum3_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sfY4u_entry() //  [R1, R2, R3]
         { info_tbl: [(cg1Cz,
                       label: sat_sfY4u_info
                       rep:HeapRep 6 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Cz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg1CA; else goto cg1CB;
       cg1CA: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1CB: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 46];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fDataSum4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sfY4t_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg1CH,
                       label: sat_sfY4t_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1CH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1CI; else goto cg1CJ;
       cg1CI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1CJ: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Sum.$fDataSum_$cgunfold_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sfY4s_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg1CP,
                       label: sat_sfY4s_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1CP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg1CQ; else goto cg1CR;
       cg1CQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1CR: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Sum.$fDataSum_$cgfoldl_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sfY4r_entry() //  [R1]
         { info_tbl: [(cg1CW,
                       label: sat_sfY4r_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1CW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg1CX; else goto cg1CY;
       cg1CX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1CY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$w$cp1Data_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fDataSum_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg1D0,
                       label: Data.Functor.Sum.$fDataSum_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1D0: // global
           Hp = Hp + 640;
           if (Hp > HpLim) (likely: False) goto cg1D4; else goto cg1D3;
       cg1D4: // global
           HpAlloc = 640;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fDataSum_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg1D3: // global
           I64[Hp - 632] = sat_sfY4K_info;
           P64[Hp - 624] = R6;
           _sfY4q::P64 = P64[Sp];
           P64[Hp - 616] = _sfY4q::P64;
           I64[Hp - 608] = sat_sfY4G_info;
           P64[Hp - 600] = R6;
           P64[Hp - 592] = _sfY4q::P64;
           I64[Hp - 584] = sat_sfY4C_info;
           P64[Hp - 576] = R6;
           P64[Hp - 568] = _sfY4q::P64;
           I64[Hp - 560] = sat_sfY4y_info;
           P64[Hp - 552] = R2;
           P64[Hp - 544] = R3;
           P64[Hp - 536] = R4;
           P64[Hp - 528] = R5;
           P64[Hp - 520] = R6;
           P64[Hp - 512] = _sfY4q::P64;
           I64[Hp - 504] = sat_sfY4x_info;
           P64[Hp - 496] = R2;
           P64[Hp - 488] = R3;
           P64[Hp - 480] = R4;
           P64[Hp - 472] = R5;
           P64[Hp - 464] = R6;
           P64[Hp - 456] = _sfY4q::P64;
           I64[Hp - 448] = sat_sfY4w_info;
           P64[Hp - 440] = R2;
           P64[Hp - 432] = R3;
           P64[Hp - 424] = R4;
           P64[Hp - 416] = R5;
           P64[Hp - 408] = R6;
           P64[Hp - 400] = _sfY4q::P64;
           I64[Hp - 392] = sat_sfY4v_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           P64[Hp - 368] = R4;
           P64[Hp - 360] = R5;
           P64[Hp - 352] = R6;
           P64[Hp - 344] = _sfY4q::P64;
           I64[Hp - 336] = sat_sfY4u_info;
           P64[Hp - 328] = R2;
           P64[Hp - 320] = R3;
           P64[Hp - 312] = R4;
           P64[Hp - 304] = R5;
           P64[Hp - 296] = R6;
           P64[Hp - 288] = _sfY4q::P64;
           I64[Hp - 280] = sat_sfY4t_info;
           P64[Hp - 272] = R2;
           P64[Hp - 264] = R3;
           P64[Hp - 256] = R4;
           P64[Hp - 248] = R5;
           P64[Hp - 240] = R6;
           P64[Hp - 232] = _sfY4q::P64;
           I64[Hp - 224] = sat_sfY4s_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           P64[Hp - 200] = R4;
           P64[Hp - 192] = R5;
           P64[Hp - 184] = R6;
           P64[Hp - 176] = _sfY4q::P64;
           I64[Hp - 168] = sat_sfY4r_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           P64[Hp - 136] = R4;
           P64[Hp - 128] = R5;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 168;
           P64[Hp - 104] = Hp - 221;
           P64[Hp - 96] = Hp - 277;
           P64[Hp - 88] = lvl4_rfXPs_closure+1;
           P64[Hp - 80] = lvl5_rfXPt_closure+1;
           P64[Hp - 72] = lvl6_rfXPu_closure+2;
           P64[Hp - 64] = lvl7_rfXPv_closure+2;
           P64[Hp - 56] = Hp - 334;
           P64[Hp - 48] = Hp - 388;
           P64[Hp - 40] = Hp - 444;
           P64[Hp - 32] = Hp - 502;
           P64[Hp - 24] = Hp - 557;
           P64[Hp - 16] = Hp - 581;
           P64[Hp - 8] = Hp - 605;
           P64[Hp] = Hp - 629;
           R1 = Hp - 119;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.741058236 UTC

[section ""data" . Data.Functor.Sum.InL_closure" {
     Data.Functor.Sum.InL_closure:
         const Data.Functor.Sum.InL_info;
 },
 Data.Functor.Sum.InL_entry() //  [R2]
         { info_tbl: [(cg1Ec,
                       label: Data.Functor.Sum.InL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Ec: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg1Eg; else goto cg1Ef;
       cg1Eg: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Functor.Sum.InL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1Ef: // global
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.745473917 UTC

[section ""data" . Data.Functor.Sum.InR_closure" {
     Data.Functor.Sum.InR_closure:
         const Data.Functor.Sum.InR_info;
 },
 Data.Functor.Sum.InR_entry() //  [R2]
         { info_tbl: [(cg1Er,
                       label: Data.Functor.Sum.InR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Er: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg1Ev; else goto cg1Eu;
       cg1Ev: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Functor.Sum.InR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg1Eu: // global
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.748957846 UTC

[Data.Functor.Sum.InL_con_entry() //  [R1]
         { info_tbl: [(cg1EB,
                       label: Data.Functor.Sum.InL_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,83,117,109,46,73,110,76]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1EB: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.752397386 UTC

[Data.Functor.Sum.InR_con_entry() //  [R1]
         { info_tbl: [(cg1EH,
                       label: Data.Functor.Sum.InR_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,83,117,109,46,73,110,82]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1EH: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:48.755669388 UTC

[section ""relreadonly" . SfYa7_srt" {
     SfYa7_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Sum.$fRead1Sum2_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Data.Functor.Sum.$fRead1Sum6_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Sum.$fRead1Sum1_closure;
         const Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure;
         const Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure;
         const Data.Functor.Sum.$fRead1Sum_closure;
         const Data.Functor.Sum.$fRead1Sum3_closure;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const Data.Functor.Sum.$w$cliftShowsPrec_closure;
         const Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure;
         const Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure;
         const Data.Functor.Sum.$fShow1Sum_closure;
         const Data.Functor.Sum.$fReadSum1_closure;
         const Data.Functor.Sum.$fReadSum_$creadsPrec_closure;
         const Data.Functor.Sum.$fReadSum_$creadListPrec_closure;
         const Data.Functor.Sum.$fReadSum_$creadList_closure;
         const Data.Functor.Sum.$fReadSum_closure;
         const Data.Functor.Sum.$fShowSum_$cshowsPrec_closure;
         const Data.Functor.Sum.$fShowSum_$cshow_closure;
         const Data.Functor.Sum.$fShowSum_$cshowList_closure;
         const Data.Functor.Sum.$fShowSum_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Functor.Sum.$fFoldableSum3_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Functor.Sum.$fFoldableSum4_closure;
         const Data.Functor.Sum.$fFoldableSum_$cminimum_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Sum.$fFoldableSum5_closure;
         const Data.Functor.Sum.$fFoldableSum_$cmaximum_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Functor.Sum.$fFoldableSum_$celem_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Functor.Sum.$fFoldableSum10_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldl_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure;
         const Data.Functor.Sum.$fFoldableSum9_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldr_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure;
         const Data.Functor.Sum.$fFoldableSum_$clength_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure;
         const Data.Functor.Sum.$fFoldableSum11_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Functor.Sum.$fFoldableSum1_closure;
         const Data.Functor.Sum.$fFoldableSum_$cnull_closure;
         const Data.Functor.Sum.$fFoldableSum_$ctoList_closure;
         const Data.Functor.Sum.$fFoldableSum_closure;
         const Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure;
         const Data.Functor.Sum.$fTraversableSum_closure;
         const Data.Data.$wlvl_closure;
         const Data.Functor.Sum.$w$cgunfold_closure;
         const Data.Functor.Sum.$fDataSum_$cgunfold_closure;
         const GHC.List.badHead_closure;
         const go61_rfXP6_closure;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const go1_rfXP7_closure;
         const Data.Data.mkConstr1_closure;
         const $tSum3_rfXPb_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Functor.Sum.$w$cp1Data_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Functor.Sum.$fDataSum_$cgmapQi_closure;
         const Data.Functor.Sum.$cInL_closure;
         const Data.Functor.Sum.$cInR_closure;
         const lvl4_rfXPs_closure;
         const Data.Functor.Sum.$tSum_closure;
         const Data.Functor.Sum.$fDataSum_closure;
         const lvl5_rfXPt_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.543562679 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:52.546407487 UTC

[section ""data" . Data.Functor.Sum.$fEq1Sum_$cliftEq_closure" {
     Data.Functor.Sum.$fEq1Sum_$cliftEq_closure:
         const Data.Functor.Sum.$fEq1Sum_$cliftEq_info;
 },
 Data.Functor.Sum.$fEq1Sum_$cliftEq_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg1Ud,
                       label: Data.Functor.Sum.$fEq1Sum_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Ud: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg1Ue; else goto cg1Uf;
       cg1Ue: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEq1Sum_$cliftEq_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1Uf: // global
           I64[Sp - 40] = block_cg1U6_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug1UQ; else goto cg1U7;
       ug1UQ: // global
           call _cg1U6(R1) args: 0, res: 0, upd: 0;
       cg1U7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1U6() //  [R1]
         { info_tbl: [(cg1U6,
                       label: block_cg1U6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1U6: // global
           _sg1ES::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg1Ua; else goto cg1Ub;
       cg1Ua: // global
           I64[Sp] = block_cg1Ui_info;
           _sg1EU::P64 = P64[R1 + 7];
           R1 = _sg1ES::P64;
           P64[Sp + 32] = _sg1EU::P64;
           if (R1 & 7 != 0) goto ug1UO; else goto cg1Uk;
       ug1UO: // global
           call _cg1Ui(R1) args: 0, res: 0, upd: 0;
       cg1Uk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg1Ub: // global
           I64[Sp + 8] = block_cg1Ux_info;
           _sg1EY::P64 = P64[R1 + 6];
           R1 = _sg1ES::P64;
           P64[Sp + 32] = _sg1EY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug1UP; else goto cg1Uz;
       ug1UP: // global
           call _cg1Ux(R1) args: 0, res: 0, upd: 0;
       cg1Uz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1Ui() //  [R1]
         { info_tbl: [(cg1Ui,
                       label: block_cg1Ui_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Ui: // global
           if (R1 & 7 == 1) goto cg1Uq; else goto ug1UN;
       cg1Uq: // global
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ug1UN: // global
           Sp = Sp + 40;
           call _cg1UF() args: 0, res: 0, upd: 0;
     }
 },
 _cg1Ux() //  [R1]
         { info_tbl: [(cg1Ux,
                       label: block_cg1Ux_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Ux: // global
           if (R1 & 7 == 1) goto ug1UM; else goto cg1UJ;
       ug1UM: // global
           Sp = Sp + 32;
           call _cg1UF() args: 0, res: 0, upd: 0;
       cg1UJ: // global
           R4 = P64[R1 + 6];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg1UF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1UF: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.557430564 UTC

[section ""data" . Data.Functor.Sum.$fEq1Sum_closure" {
     Data.Functor.Sum.$fEq1Sum_closure:
         const Data.Functor.Sum.$fEq1Sum_info;
 },
 Data.Functor.Sum.$fEq1Sum_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg1Vr,
                       label: Data.Functor.Sum.$fEq1Sum_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Vr: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fEq1Sum_$cliftEq_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.561444946 UTC

[section ""data" . Data.Functor.Sum.$fOrd1Sum_$cliftCompare_closure" {
     Data.Functor.Sum.$fOrd1Sum_$cliftCompare_closure:
         const Data.Functor.Sum.$fOrd1Sum_$cliftCompare_info;
 },
 Data.Functor.Sum.$fOrd1Sum_$cliftCompare_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cg1VJ,
                       label: Data.Functor.Sum.$fOrd1Sum_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1VJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg1VK; else goto cg1VL;
       cg1VK: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrd1Sum_$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1VL: // global
           I64[Sp - 40] = block_cg1VC_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug1Wk; else goto cg1VD;
       ug1Wk: // global
           call _cg1VC(R1) args: 0, res: 0, upd: 0;
       cg1VD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1VC() //  [R1]
         { info_tbl: [(cg1VC,
                       label: block_cg1VC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1VC: // global
           _sg1F6::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg1VG; else goto cg1VH;
       cg1VG: // global
           I64[Sp] = block_cg1VO_info;
           _sg1F8::P64 = P64[R1 + 7];
           R1 = _sg1F6::P64;
           P64[Sp + 32] = _sg1F8::P64;
           if (R1 & 7 != 0) goto ug1Wi; else goto cg1VQ;
       ug1Wi: // global
           call _cg1VO(R1) args: 0, res: 0, upd: 0;
       cg1VQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg1VH: // global
           I64[Sp + 8] = block_cg1W3_info;
           _sg1Fc::P64 = P64[R1 + 6];
           R1 = _sg1F6::P64;
           P64[Sp + 32] = _sg1Fc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug1Wj; else goto cg1W5;
       ug1Wj: // global
           call _cg1W3(R1) args: 0, res: 0, upd: 0;
       cg1W5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1VO() //  [R1]
         { info_tbl: [(cg1VO,
                       label: block_cg1VO_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1VO: // global
           if (R1 & 7 == 1) goto cg1VW; else goto cg1W0;
       cg1VW: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
       cg1W0: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg1W3() //  [R1]
         { info_tbl: [(cg1W3,
                       label: block_cg1W3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1W3: // global
           if (R1 & 7 == 1) goto cg1Wb; else goto cg1Wf;
       cg1Wb: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg1Wf: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.572605983 UTC

[section ""data" . Data.Functor.Sum.$fOrd1Sum1_closure" {
     Data.Functor.Sum.$fOrd1Sum1_closure:
         const Data.Functor.Sum.$fOrd1Sum1_info;
 },
 Data.Functor.Sum.$fOrd1Sum1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg1X8,
                       label: Data.Functor.Sum.$fOrd1Sum1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1X8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg1X9; else goto cg1Xa;
       cg1X9: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrd1Sum1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1Xa: // global
           I64[Sp - 40] = block_cg1X1_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug1XL; else goto cg1X2;
       ug1XL: // global
           call _cg1X1(R1) args: 0, res: 0, upd: 0;
       cg1X2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1X1() //  [R1]
         { info_tbl: [(cg1X1,
                       label: block_cg1X1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1X1: // global
           _sg1Fk::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg1X5; else goto cg1X6;
       cg1X5: // global
           I64[Sp] = block_cg1Xd_info;
           _sg1Fm::P64 = P64[R1 + 7];
           R1 = _sg1Fk::P64;
           P64[Sp + 32] = _sg1Fm::P64;
           if (R1 & 7 != 0) goto ug1XJ; else goto cg1Xf;
       ug1XJ: // global
           call _cg1Xd(R1) args: 0, res: 0, upd: 0;
       cg1Xf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg1X6: // global
           I64[Sp + 8] = block_cg1Xs_info;
           _sg1Fq::P64 = P64[R1 + 6];
           R1 = _sg1Fk::P64;
           P64[Sp + 32] = _sg1Fq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug1XK; else goto cg1Xu;
       ug1XK: // global
           call _cg1Xs(R1) args: 0, res: 0, upd: 0;
       cg1Xu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg1Xd() //  [R1]
         { info_tbl: [(cg1Xd,
                       label: block_cg1Xd_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Xd: // global
           if (R1 & 7 == 1) goto cg1Xl; else goto ug1XI;
       cg1Xl: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
       ug1XI: // global
           Sp = Sp + 40;
           call _cg1XA() args: 0, res: 0, upd: 0;
     }
 },
 _cg1Xs() //  [R1]
         { info_tbl: [(cg1Xs,
                       label: block_cg1Xs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Xs: // global
           if (R1 & 7 == 1) goto ug1XH; else goto cg1XE;
       ug1XH: // global
           Sp = Sp + 32;
           call _cg1XA() args: 0, res: 0, upd: 0;
       cg1XE: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cg1XA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1XA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.584345661 UTC

[section ""data" . Data.Functor.Sum.$fOrd1Sum_closure" {
     Data.Functor.Sum.$fOrd1Sum_closure:
         const Data.Functor.Sum.$fOrd1Sum_info;
 },
 sat_sg1Fx_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg1Yz,
                       label: sat_sg1Fx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Yz: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fOrd1Sum_$cliftCompare_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Fw_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg1YH,
                       label: sat_sg1Fw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1YH: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fOrd1Sum1_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fOrd1Sum_entry() //  [R2, R3]
         { info_tbl: [(cg1YL,
                       label: Data.Functor.Sum.$fOrd1Sum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1YL: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg1YP; else goto cg1YO;
       cg1YP: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrd1Sum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1YO: // global
           I64[Hp - 64] = sat_sg1Fx_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg1Fw_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 37;
           P64[Hp] = Hp - 61;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.592650885 UTC

[section ""cstring" . Data.Functor.Sum.$fRead1Sum8_bytes" {
     Data.Functor.Sum.$fRead1Sum8_bytes:
         I8[] [73,110,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.594551779 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum7_closure" {
     Data.Functor.Sum.$fRead1Sum7_closure:
         const Data.Functor.Sum.$fRead1Sum7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fRead1Sum7_entry() //  [R1]
         { info_tbl: [(cg1Zd,
                       label: Data.Functor.Sum.$fRead1Sum7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Zd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg1Ze; else goto cg1Zf;
       cg1Ze: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1Zf: // global
           (_cg1Za::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg1Za::I64 == 0) goto cg1Zc; else goto cg1Zb;
       cg1Zc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg1Zb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg1Za::I64;
           R2 = Data.Functor.Sum.$fRead1Sum8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.598487751 UTC

[section ""cstring" . Data.Functor.Sum.$fRead1Sum4_bytes" {
     Data.Functor.Sum.$fRead1Sum4_bytes:
         I8[] [73,110,82]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.600344033 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum3_closure" {
     Data.Functor.Sum.$fRead1Sum3_closure:
         const Data.Functor.Sum.$fRead1Sum3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fRead1Sum3_entry() //  [R1]
         { info_tbl: [(cg1Zv,
                       label: Data.Functor.Sum.$fRead1Sum3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1Zv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg1Zw; else goto cg1Zx;
       cg1Zw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1Zx: // global
           (_cg1Zs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg1Zs::I64 == 0) goto cg1Zu; else goto cg1Zt;
       cg1Zu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg1Zt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg1Zs::I64;
           R2 = Data.Functor.Sum.$fRead1Sum4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.604274958 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum2_closure" {
     Data.Functor.Sum.$fRead1Sum2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Sum.$fRead1Sum3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.606425139 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum5_closure" {
     Data.Functor.Sum.$fRead1Sum5_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.608148922 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum6_closure" {
     Data.Functor.Sum.$fRead1Sum6_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.612234803 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum1_closure" {
     Data.Functor.Sum.$fRead1Sum1_closure:
         const Data.Functor.Sum.$fRead1Sum1_info;
         const 0;
 },
 ds_sg1FC_entry() //  [R1]
         { info_tbl: [(cg1ZR,
                       label: ds_sg1FC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1ZR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg1ZS; else goto cg1ZT;
       cg1ZS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1ZT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 ds1_sg1FD_entry() //  [R1]
         { info_tbl: [(cg1ZY,
                       label: ds1_sg1FD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1ZY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg1ZZ; else goto cg200;
       cg1ZZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg200: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg1FL_entry() //  [R1, R2]
         { info_tbl: [(cg20l,
                       label: sat_sg1FL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg20l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg20p; else goto cg20o;
       cg20p: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg20o: // global
           _sg1FG::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           R1 = _sg1FG::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1FM_entry() //  [R1, R2]
         { info_tbl: [(cg20q,
                       label: sat_sg1FM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg20q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg20u; else goto cg20t;
       cg20u: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg20t: // global
           _sg1FC::P64 = P64[R1 + 7];
           _sg1FG::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sg1FL_info;
           P64[Hp] = _sg1FG::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Sum.$fRead1Sum5_closure+1;
           R1 = _sg1FC::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1FT_entry() //  [R1, R2]
         { info_tbl: [(cg20M,
                       label: sat_sg1FT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg20M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg20Q; else goto cg20P;
       cg20Q: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg20P: // global
           _sg1FG::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _sg1FG::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1FU_entry() //  [R1, R2]
         { info_tbl: [(cg20R,
                       label: sat_sg1FU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg20R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg20V; else goto cg20U;
       cg20V: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg20U: // global
           _sg1FD::P64 = P64[R1 + 7];
           _sg1FG::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sg1FT_info;
           P64[Hp] = _sg1FG::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Sum.$fRead1Sum5_closure+1;
           R1 = _sg1FD::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1FX_entry() //  [R1]
         { info_tbl: [(cg20Z,
                       label: sat_sg1FX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg20Z: // global
           _sg1FX::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg210; else goto cg211;
       cg211: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg213; else goto cg212;
       cg213: // global
           HpAlloc = 24;
           goto cg210;
       cg210: // global
           R1 = _sg1FX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg212: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg1FX::P64;
           _sg1FD::P64 = P64[_sg1FX::P64 + 16];
           _sg1FG::P64 = P64[_sg1FX::P64 + 24];
           I64[Hp - 16] = sat_sg1FU_info;
           P64[Hp - 8] = _sg1FD::P64;
           P64[Hp] = _sg1FG::P64;
           I64[Sp - 24] = block_cg20W_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Sum.$fRead1Sum2_closure+4;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg20W() //  [R1]
         { info_tbl: [(cg20W,
                       label: block_cg20W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg20W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg216; else goto cg215;
       cg216: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg215: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_sg1FE_entry() //  [R1, R2, R3]
         { info_tbl: [(cg21a,
                       label: $wlvl_sg1FE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg21a: // global
           _sg1FG::P64 = R3;
           _sg1FF::I64 = R2;
           _sg1FE::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg21b; else goto cg21c;
       cg21c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg21e; else goto cg21d;
       cg21e: // global
           HpAlloc = 24;
           goto cg21b;
       cg21b: // global
           R3 = _sg1FG::P64;
           R2 = _sg1FF::I64;
           R1 = _sg1FE::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg21d: // global
           if (%MO_S_Gt_W64(_sg1FF::I64, 10)) goto cg218; else goto cg219;
       cg218: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg219: // global
           _sg1FC::P64 = P64[_sg1FE::P64 + 6];
           _sg1FD::P64 = P64[_sg1FE::P64 + 14];
           I64[Hp - 16] = sat_sg1FM_info;
           P64[Hp - 8] = _sg1FC::P64;
           P64[Hp] = _sg1FG::P64;
           I64[Sp - 24] = block_cg20v_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Sum.$fRead1Sum6_closure+4;
           P64[Sp - 16] = _sg1FD::P64;
           P64[Sp - 8] = _sg1FG::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg20v() //  [R1]
         { info_tbl: [(cg20v,
                       label: block_cg20v_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg20v: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg21i; else goto cg21h;
       cg21i: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg21h: // global
           I64[Hp - 40] = sat_sg1FX_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R3 = Hp - 40;
           R2 = Hp - 6;
           Sp = Sp + 24;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 lvl8_sg1FY_entry() //  [R1, R2, R3]
         { info_tbl: [(cg21r,
                       label: lvl8_sg1FY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg21r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg21s; else goto cg21t;
       cg21s: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg21t: // global
           I64[Sp - 24] = block_cg21o_info;
           _sg1FE::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sg1FE::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug21x; else goto cg21p;
       ug21x: // global
           call _cg21o(R1) args: 0, res: 0, upd: 0;
       cg21p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg21o() //  [R1]
         { info_tbl: [(cg21o,
                       label: block_cg21o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg21o: // global
           R3 = P64[Sp + 16];
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call $wlvl_sg1FE_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1G5_entry() //  [R1, R2, R3]
         { info_tbl: [(cg21D,
                       label: sat_sg1G5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg21D: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg21G,
                       label: Data.Functor.Sum.$fRead1Sum1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg21G: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cg21K; else goto cg21J;
       cg21K: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg21J: // global
           I64[Hp - 128] = ds_sg1FC_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R4;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = ds1_sg1FD_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = $wlvl_sg1FE_info;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 88;
           I64[Hp - 24] = lvl8_sg1FY_info;
           P64[Hp - 16] = Hp - 46;
           I64[Hp - 8] = sat_sg1G5_info;
           P64[Hp] = Hp - 22;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.644955458 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure" {
     Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure:
         const Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_info;
         const 0;
 },
 sat_sg1Gg_entry() //  [R1, R2, R3]
         { info_tbl: [(cg23p,
                       label: sat_sg1Gg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg23p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg23q; else goto cg23r;
       cg23q: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg23r: // global
           I64[Sp - 8] = block_cg23m_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg23m() //  [R1]
         { info_tbl: [(cg23m,
                       label: block_cg23m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg23m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg23u; else goto cg23t;
       cg23u: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg23t: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Gb_entry() //  [R1, R2]
         { info_tbl: [(cg23A,
                       label: sat_sg1Gb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg23A: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sg1Ga_entry() //  [R1]
         { info_tbl: [(cg23D,
                       label: ds_sg1Ga_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg23D: // global
           _sg1Ga::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg23E; else goto cg23F;
       cg23F: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg23H; else goto cg23G;
       cg23H: // global
           HpAlloc = 32;
           goto cg23E;
       cg23E: // global
           R1 = _sg1Ga::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg23G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg1Ga::P64;
           _sg1G6::P64 = P64[_sg1Ga::P64 + 16];
           _sg1G7::P64 = P64[_sg1Ga::P64 + 24];
           _sg1G8::P64 = P64[_sg1Ga::P64 + 32];
           _sg1G9::P64 = P64[_sg1Ga::P64 + 40];
           I64[Hp - 24] = sat_sg1Gg_info;
           P64[Hp - 16] = _sg1G9::P64;
           I64[Hp - 8] = sat_sg1Gb_info;
           P64[Hp] = _sg1G8::P64;
           R5 = Hp - 22;
           R4 = Hp - 7;
           R3 = _sg1G7::P64;
           R2 = _sg1G6::P64;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Gi_entry() //  [R1]
         { info_tbl: [(cg23R,
                       label: sat_sg1Gi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg23R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg23S; else goto cg23T;
       cg23S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg23T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Gj_entry() //  [R1, R2]
         { info_tbl: [(cg23U,
                       label: sat_sg1Gj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg23U: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg23Y; else goto cg23X;
       cg23Y: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg23X: // global
           _sg1Ga::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sg1Gi_info;
           P64[Hp - 8] = _sg1Ga::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cg23Z,
                       label: Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg23Z: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg243; else goto cg242;
       cg243: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg242: // global
           I64[Hp - 56] = ds_sg1Ga_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = sat_sg1Gj_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.661779973 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure" {
     Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure:
         const Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_info;
         const 0;
 },
 sat_sg1Go_entry() //  [R1]
         { info_tbl: [(cg24P,
                       label: sat_sg1Go_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg24P: // global
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cg24S,
                       label: Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg24S: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg24W; else goto cg24V;
       cg24W: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg24V: // global
           I64[Hp - 40] = sat_sg1Go_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.668834372 UTC

[section ""data" . Data.Functor.Sum.$fRead1Sum_closure" {
     Data.Functor.Sum.$fRead1Sum_closure:
         const Data.Functor.Sum.$fRead1Sum_info;
         const 0;
 },
 sat_sg1Gu_entry() //  [R1, R2, R3]
         { info_tbl: [(cg25e,
                       label: sat_sg1Gu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg25e: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Gt_entry() //  [R1, R2, R3]
         { info_tbl: [(cg25m,
                       label: sat_sg1Gt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg25m: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Gs_entry() //  [R1]
         { info_tbl: [(cg25t,
                       label: sat_sg1Gs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg25t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg25u; else goto cg25v;
       cg25u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg25v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum_$cliftReadList_entry(R3,
                                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Gr_entry() //  [R1, R2, R3]
         { info_tbl: [(cg25B,
                       label: sat_sg1Gr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg25B: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_entry(R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fRead1Sum_entry() //  [R2, R3]
         { info_tbl: [(cg25F,
                       label: Data.Functor.Sum.$fRead1Sum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg25F: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cg25J; else goto cg25I;
       cg25J: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg25I: // global
           I64[Hp - 136] = sat_sg1Gu_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sg1Gt_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sg1Gs_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sg1Gr_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 54;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 134;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure" {
     Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure:
         const Data.Functor.Sum.$fRead1Sum_$cliftReadList_info;
         const 0;
 },
 sat_sg1Gx_entry() //  [R1]
         { info_tbl: [(cg25S,
                       label: sat_sg1Gx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg25S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg25T; else goto cg25U;
       cg25T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg25U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum_entry(R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fRead1Sum_$cliftReadList_entry() //  [R2, R3]
         { info_tbl: [(cg25V,
                       label: Data.Functor.Sum.$fRead1Sum_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg25V: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg25Z; else goto cg25Y;
       cg25Z: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg25Y: // global
           I64[Hp - 24] = sat_sg1Gx_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.685635386 UTC

[section ""data" . Data.Functor.Sum.$w$cliftShowsPrec_closure" {
     Data.Functor.Sum.$w$cliftShowsPrec_closure:
         const Data.Functor.Sum.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Sum.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg26E: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sg1GG_entry() //  [R1]
         { info_tbl: [(cg26R,
                       label: sat_sg1GG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg26R: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg26S; else goto cg26T;
       cg26S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg26T: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg1GI_entry() //  [R1]
         { info_tbl: [(cg270,
                       label: sat_sg1GI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg270: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg271; else goto cg272;
       cg271: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg272: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg277,
                       label: Data.Functor.Sum.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg277: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg278; else goto cg279;
       cg278: // global
           R1 = Data.Functor.Sum.$w$cliftShowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cg279: // global
           I64[Sp - 40] = block_cg26I_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug27g; else goto cg26J;
       ug27g: // global
           call _cg26I(R1) args: 0, res: 0, upd: 0;
       cg26J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg26I() //  [R1]
         { info_tbl: [(cg26I,
                       label: block_cg26I_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg26I: // global
           _sg1GA::P64 = P64[Sp + 16];
           _sg1GB::P64 = P64[Sp + 24];
           _sg1GC::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cg274; else goto cg275;
       cg274: // global
           Hp = Hp + 40;
           _sg1GE::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg27f; else goto cg27b;
       cg27b: // global
           _sg1GF::P64 = P64[_sg1GE::P64 + 7];
           I64[Hp - 32] = sat_sg1GG_info;
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = _sg1GA::P64;
           P64[Hp] = _sg1GB::P64;
           R5 = _sg1GF::P64;
           R4 = _sg1GC::I64;
           R3 = Data.Functor.Sum.$fRead1Sum7_closure;
           R2 = Hp - 32;
           Sp = Sp + 48;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cg275: // global
           Hp = Hp + 40;
           _sg1GE::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg27f; else goto cg27e;
       cg27f: // global
           HpAlloc = 40;
           R1 = _sg1GE::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg27e: // global
           _sg1GH::P64 = P64[_sg1GE::P64 + 6];
           I64[Hp - 32] = sat_sg1GI_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sg1GA::P64;
           P64[Hp] = _sg1GB::P64;
           R5 = _sg1GH::P64;
           R4 = _sg1GC::I64;
           R3 = Data.Functor.Sum.$fRead1Sum3_closure;
           R2 = Hp - 32;
           Sp = Sp + 48;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.698444174 UTC

[section ""data" . Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure" {
     Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure:
         const Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cg27U,
                       label: Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg27U: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg27V; else goto cg27W;
       cg27V: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg27W: // global
           I64[Sp - 40] = block_cg27R_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug280; else goto cg27S;
       ug280: // global
           call _cg27R(R1) args: 0, res: 0, upd: 0;
       cg27S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg27R() //  [R1]
         { info_tbl: [(cg27R,
                       label: block_cg27R_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg27R: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.704433562 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum6_closure" {
     Data.Functor.Sum.$fFoldableSum6_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.707597438 UTC

[section ""data" . Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure" {
     Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure:
         const Data.Functor.Sum.$fShow1Sum_$cliftShowList_info;
         const 0;
 },
 sat_sg1GY_entry() //  [R1, R2]
         { info_tbl: [(cg28l,
                       label: sat_sg1GY_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg28l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg28m; else goto cg28n;
       cg28m: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg28n: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sg1GX::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sg1GX::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShow1Sum_$cliftShowList_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cg28o,
                       label: Data.Functor.Sum.$fShow1Sum_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg28o: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg28s; else goto cg28r;
       cg28s: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg28r: // global
           I64[Hp - 32] = sat_sg1GY_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 31;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.714075411 UTC

[section ""data" . Data.Functor.Sum.$fShow1Sum_closure" {
     Data.Functor.Sum.$fShow1Sum_closure:
         const Data.Functor.Sum.$fShow1Sum_info;
         const 0;
 },
 sat_sg1H2_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg28L,
                       label: sat_sg1H2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg28L: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg28M; else goto cg28N;
       cg28M: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg28N: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$fShow1Sum_$cliftShowList_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_sg1H1_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg28T,
                       label: sat_sg1H1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg28T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg28U; else goto cg28V;
       cg28U: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg28V: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShow1Sum_entry() //  [R2, R3]
         { info_tbl: [(cg28X,
                       label: Data.Functor.Sum.$fShow1Sum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg28X: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg291; else goto cg290;
       cg291: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShow1Sum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg290: // global
           I64[Hp - 64] = sat_sg1H2_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg1H1_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 36;
           P64[Hp] = Hp - 60;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.722810798 UTC

[section ""data" . Data.Functor.Sum.$fEqSum_$c==_closure" {
     Data.Functor.Sum.$fEqSum_$c==_closure:
         const Data.Functor.Sum.$fEqSum_$c==_info;
 },
 sat_sg1H8_entry() //  [R1]
         { info_tbl: [(cg29s,
                       label: sat_sg1H8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg29s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg29t; else goto cg29u;
       cg29t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg29u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fEqSum_$c==_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg29v,
                       label: Data.Functor.Sum.$fEqSum_$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg29v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg29z; else goto cg29y;
       cg29z: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEqSum_$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg29y: // global
           I64[Hp - 16] = sat_sg1H8_info;
           P64[Hp] = R4;
           R6 = R6;
           R5 = R5;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fEq1Sum_$cliftEq_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.72976362 UTC

[section ""data" . Data.Functor.Sum.$fEqSum_$c/=_closure" {
     Data.Functor.Sum.$fEqSum_$c/=_closure:
         const Data.Functor.Sum.$fEqSum_$c/=_info;
 },
 sat_sg1Hi_entry() //  [R1]
         { info_tbl: [(cg2a2,
                       label: sat_sg1Hi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2a2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2a3; else goto cg2a4;
       cg2a3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2a4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Hp_entry() //  [R1]
         { info_tbl: [(cg2ah,
                       label: sat_sg1Hp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2ah: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2ai; else goto cg2aj;
       cg2ai: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2aj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fEqSum_$c/=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg2ao,
                       label: Data.Functor.Sum.$fEqSum_$c/=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2ao: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2ap; else goto cg2aq;
       cg2ap: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEqSum_$c/=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2aq: // global
           I64[Sp - 40] = block_cg29O_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2bk; else goto cg29P;
       ug2bk: // global
           call _cg29O(R1) args: 0, res: 0, upd: 0;
       cg29P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg29O() //  [R1]
         { info_tbl: [(cg29O,
                       label: block_cg29O_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg29O: // global
           _sg1Hd::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg2al; else goto cg2am;
       cg2al: // global
           I64[Sp] = block_cg29T_info;
           _sg1Hf::P64 = P64[R1 + 7];
           R1 = _sg1Hd::P64;
           P64[Sp + 32] = _sg1Hf::P64;
           if (R1 & 7 != 0) goto ug2bg; else goto cg29U;
       ug2bg: // global
           call _cg29T(R1) args: 0, res: 0, upd: 0;
       cg29U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg2am: // global
           I64[Sp + 8] = block_cg2a7_info;
           _sg1Hl::P64 = P64[R1 + 6];
           R1 = _sg1Hd::P64;
           P64[Sp + 32] = _sg1Hl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug2bh; else goto cg2a8;
       ug2bh: // global
           call _cg2a7(R1) args: 0, res: 0, upd: 0;
       cg2a8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg29T() //  [R1]
         { info_tbl: [(cg29T,
                       label: block_cg29T_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg29T: // global
           if (R1 & 7 == 1) goto cg2au; else goto ug2bd;
       cg2au: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg2ax; else goto cg2aw;
       cg2ax: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2aw: // global
           _sg1Hh::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sg1Hi_info;
           P64[Hp] = P64[Sp + 24];
           _sg1Hf::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg2as_info;
           R4 = _sg1Hh::P64;
           R3 = _sg1Hf::P64;
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ug2bd: // global
           Sp = Sp + 40;
           call _cg2b1() args: 0, res: 0, upd: 0;
     }
 },
 _cg2as() //  [R1]
         { info_tbl: [(cg2as,
                       label: block_cg2as_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2as: // global
           if (R1 & 7 == 1) goto ug2be; else goto ug2bf;
       ug2be: // global
           Sp = Sp + 8;
           call _cg2b1() args: 0, res: 0, upd: 0;
       ug2bf: // global
           Sp = Sp + 8;
           call _cg2b5() args: 0, res: 0, upd: 0;
     }
 },
 _cg2a7() //  [R1]
         { info_tbl: [(cg2a7,
                       label: block_cg2a7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2a7: // global
           if (R1 & 7 == 1) goto ug2ba; else goto cg2aS;
       ug2ba: // global
           Sp = Sp + 32;
           call _cg2b1() args: 0, res: 0, upd: 0;
       cg2aS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg2aV; else goto cg2aU;
       cg2aV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2aU: // global
           _sg1Ho::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sg1Hp_info;
           P64[Hp] = P64[Sp + 16];
           _sg1Hl::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cg2aR_info;
           R4 = _sg1Ho::P64;
           R3 = _sg1Hl::P64;
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2aR() //  [R1]
         { info_tbl: [(cg2aR,
                       label: block_cg2aR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2aR: // global
           if (R1 & 7 == 1) goto ug2bb; else goto ug2bc;
       ug2bb: // global
           Sp = Sp + 8;
           call _cg2b1() args: 0, res: 0, upd: 0;
       ug2bc: // global
           Sp = Sp + 8;
           call _cg2b5() args: 0, res: 0, upd: 0;
     }
 },
 _cg2b1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2b1: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg2b5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2b5: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.751080998 UTC

[section ""data" . Data.Functor.Sum.$fEqSum_closure" {
     Data.Functor.Sum.$fEqSum_closure:
         const Data.Functor.Sum.$fEqSum_info;
 },
 sat_sg1Hv_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2cw,
                       label: sat_sg1Hv_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2cw: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fEqSum_$c/=_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Hu_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2cE,
                       label: sat_sg1Hu_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2cE: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fEqSum_$c==_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fEqSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2cI,
                       label: Data.Functor.Sum.$fEqSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2cI: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg2cM; else goto cg2cL;
       cg2cM: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fEqSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2cL: // global
           I64[Hp - 80] = sat_sg1Hv_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg1Hu_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 78;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.758825371 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$ccompare_closure" {
     Data.Functor.Sum.$fOrdSum_$ccompare_closure:
         const Data.Functor.Sum.$fOrdSum_$ccompare_info;
 },
 sat_sg1HB_entry() //  [R1]
         { info_tbl: [(cg2db,
                       label: sat_sg1HB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2db: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2dc; else goto cg2dd;
       cg2dc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2dd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$ccompare_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg2de,
                       label: Data.Functor.Sum.$fOrdSum_$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2de: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg2di; else goto cg2dh;
       cg2di: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2dh: // global
           I64[Hp - 16] = sat_sg1HB_info;
           P64[Hp] = R4;
           R6 = R6;
           R5 = R5;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fOrd1Sum_$cliftCompare_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.765357709 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$cp1Ord_closure" {
     Data.Functor.Sum.$fOrdSum_$cp1Ord_closure:
         const Data.Functor.Sum.$fOrdSum_$cp1Ord_info;
 },
 sat_sg1HH_entry() //  [R1]
         { info_tbl: [(cg2dB,
                       label: sat_sg1HH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2dB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2dC; else goto cg2dD;
       cg2dC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2dD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1HG_entry() //  [R1]
         { info_tbl: [(cg2dI,
                       label: sat_sg1HG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2dI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2dJ; else goto cg2dK;
       cg2dJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2dK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1HF_entry() //  [R1]
         { info_tbl: [(cg2dP,
                       label: sat_sg1HF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2dP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2dQ; else goto cg2dR;
       cg2dQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2dR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$cp1Ord_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2dS,
                       label: Data.Functor.Sum.$fOrdSum_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2dS: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg2dW; else goto cg2dV;
       cg2dW: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$cp1Ord_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2dV: // global
           I64[Hp - 64] = sat_sg1HH_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sg1HG_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg1HF_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Sum.$fEqSum_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.776336971 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c<_closure" {
     Data.Functor.Sum.$fOrdSum_$c<_closure:
         const Data.Functor.Sum.$fOrdSum_$c<_info;
 },
 sat_sg1HR_entry() //  [R1]
         { info_tbl: [(cg2eB,
                       label: sat_sg1HR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2eB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2eC; else goto cg2eD;
       cg2eC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2eD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1HY_entry() //  [R1]
         { info_tbl: [(cg2eQ,
                       label: sat_sg1HY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2eQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2eR; else goto cg2eS;
       cg2eR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2eS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg2eX,
                       label: Data.Functor.Sum.$fOrdSum_$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2eX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2eY; else goto cg2eZ;
       cg2eY: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2eZ: // global
           I64[Sp - 40] = block_cg2en_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2fT; else goto cg2eo;
       ug2fT: // global
           call _cg2en(R1) args: 0, res: 0, upd: 0;
       cg2eo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2en() //  [R1]
         { info_tbl: [(cg2en,
                       label: block_cg2en_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2en: // global
           _sg1HM::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg2eU; else goto cg2eV;
       cg2eU: // global
           I64[Sp] = block_cg2es_info;
           _sg1HO::P64 = P64[R1 + 7];
           R1 = _sg1HM::P64;
           P64[Sp + 32] = _sg1HO::P64;
           if (R1 & 7 != 0) goto ug2fP; else goto cg2et;
       ug2fP: // global
           call _cg2es(R1) args: 0, res: 0, upd: 0;
       cg2et: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg2eV: // global
           I64[Sp + 8] = block_cg2eG_info;
           _sg1HU::P64 = P64[R1 + 6];
           R1 = _sg1HM::P64;
           P64[Sp + 32] = _sg1HU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug2fQ; else goto cg2eH;
       ug2fQ: // global
           call _cg2eG(R1) args: 0, res: 0, upd: 0;
       cg2eH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2es() //  [R1]
         { info_tbl: [(cg2es,
                       label: block_cg2es_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2es: // global
           if (R1 & 7 == 1) goto cg2f3; else goto ug2fM;
       cg2f3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg2f6; else goto cg2f5;
       cg2f6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2f5: // global
           _sg1HQ::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sg1HR_info;
           P64[Hp] = P64[Sp + 24];
           _sg1HO::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg2f1_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sg1HO::P64;
           P64[Sp + 24] = _sg1HQ::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug2fM: // global
           Sp = Sp + 40;
           call _cg2fE() args: 0, res: 0, upd: 0;
     }
 },
 _cg2f1() //  [R1]
         { info_tbl: [(cg2f1,
                       label: block_cg2f1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2f1: // global
           if (R1 & 7 == 1) goto ug2fN; else goto ug2fO;
       ug2fN: // global
           Sp = Sp + 8;
           call _cg2fE() args: 0, res: 0, upd: 0;
       ug2fO: // global
           Sp = Sp + 8;
           call _cg2fA() args: 0, res: 0, upd: 0;
     }
 },
 _cg2eG() //  [R1]
         { info_tbl: [(cg2eG,
                       label: block_cg2eG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2eG: // global
           if (R1 & 7 == 1) goto ug2fJ; else goto cg2fr;
       ug2fJ: // global
           Sp = Sp + 32;
           call _cg2fA() args: 0, res: 0, upd: 0;
       cg2fr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg2fu; else goto cg2ft;
       cg2fu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2ft: // global
           _sg1HX::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sg1HY_info;
           P64[Hp] = P64[Sp + 16];
           _sg1HU::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cg2fq_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sg1HU::P64;
           P64[Sp + 16] = _sg1HX::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg2fq() //  [R1]
         { info_tbl: [(cg2fq,
                       label: block_cg2fq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2fq: // global
           if (R1 & 7 == 1) goto ug2fK; else goto ug2fL;
       ug2fK: // global
           Sp = Sp + 8;
           call _cg2fE() args: 0, res: 0, upd: 0;
       ug2fL: // global
           Sp = Sp + 8;
           call _cg2fA() args: 0, res: 0, upd: 0;
     }
 },
 _cg2fE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2fE: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg2fA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2fA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.798100558 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c>=_closure" {
     Data.Functor.Sum.$fOrdSum_$c>=_closure:
         const Data.Functor.Sum.$fOrdSum_$c>=_info;
 },
 sat_sg1I9_entry() //  [R1]
         { info_tbl: [(cg2hi,
                       label: sat_sg1I9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2hi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2hj; else goto cg2hk;
       cg2hj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2hk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Ig_entry() //  [R1]
         { info_tbl: [(cg2hx,
                       label: sat_sg1Ig_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2hx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2hy; else goto cg2hz;
       cg2hy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2hz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c>=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg2hE,
                       label: Data.Functor.Sum.$fOrdSum_$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2hE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2hF; else goto cg2hG;
       cg2hF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2hG: // global
           I64[Sp - 40] = block_cg2h4_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2iA; else goto cg2h5;
       ug2iA: // global
           call _cg2h4(R1) args: 0, res: 0, upd: 0;
       cg2h5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2h4() //  [R1]
         { info_tbl: [(cg2h4,
                       label: block_cg2h4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2h4: // global
           _sg1I4::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg2hB; else goto cg2hC;
       cg2hB: // global
           I64[Sp] = block_cg2h9_info;
           _sg1I6::P64 = P64[R1 + 7];
           R1 = _sg1I4::P64;
           P64[Sp + 32] = _sg1I6::P64;
           if (R1 & 7 != 0) goto ug2iw; else goto cg2ha;
       ug2iw: // global
           call _cg2h9(R1) args: 0, res: 0, upd: 0;
       cg2ha: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg2hC: // global
           I64[Sp + 8] = block_cg2hn_info;
           _sg1Ic::P64 = P64[R1 + 6];
           R1 = _sg1I4::P64;
           P64[Sp + 32] = _sg1Ic::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug2ix; else goto cg2ho;
       ug2ix: // global
           call _cg2hn(R1) args: 0, res: 0, upd: 0;
       cg2ho: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2h9() //  [R1]
         { info_tbl: [(cg2h9,
                       label: block_cg2h9_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2h9: // global
           if (R1 & 7 == 1) goto cg2hK; else goto ug2it;
       cg2hK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg2hN; else goto cg2hM;
       cg2hN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2hM: // global
           _sg1I8::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sg1I9_info;
           P64[Hp] = P64[Sp + 24];
           _sg1I6::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg2hI_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sg1I6::P64;
           P64[Sp + 24] = _sg1I8::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug2it: // global
           Sp = Sp + 40;
           call _cg2il() args: 0, res: 0, upd: 0;
     }
 },
 _cg2hI() //  [R1]
         { info_tbl: [(cg2hI,
                       label: block_cg2hI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2hI: // global
           if (R1 & 7 == 1) goto ug2iu; else goto ug2iv;
       ug2iu: // global
           Sp = Sp + 8;
           call _cg2il() args: 0, res: 0, upd: 0;
       ug2iv: // global
           Sp = Sp + 8;
           call _cg2ih() args: 0, res: 0, upd: 0;
     }
 },
 _cg2hn() //  [R1]
         { info_tbl: [(cg2hn,
                       label: block_cg2hn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2hn: // global
           if (R1 & 7 == 1) goto ug2iq; else goto cg2i8;
       ug2iq: // global
           Sp = Sp + 32;
           call _cg2ih() args: 0, res: 0, upd: 0;
       cg2i8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg2ib; else goto cg2ia;
       cg2ib: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2ia: // global
           _sg1If::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sg1Ig_info;
           P64[Hp] = P64[Sp + 16];
           _sg1Ic::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cg2i7_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sg1Ic::P64;
           P64[Sp + 16] = _sg1If::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg2i7() //  [R1]
         { info_tbl: [(cg2i7,
                       label: block_cg2i7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2i7: // global
           if (R1 & 7 == 1) goto ug2ir; else goto ug2is;
       ug2ir: // global
           Sp = Sp + 8;
           call _cg2il() args: 0, res: 0, upd: 0;
       ug2is: // global
           Sp = Sp + 8;
           call _cg2ih() args: 0, res: 0, upd: 0;
     }
 },
 _cg2il() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2il: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg2ih() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2ih: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.819014072 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c>_closure" {
     Data.Functor.Sum.$fOrdSum_$c>_closure:
         const Data.Functor.Sum.$fOrdSum_$c>_info;
 },
 sat_sg1Ir_entry() //  [R1]
         { info_tbl: [(cg2jZ,
                       label: sat_sg1Ir_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2jZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2k0; else goto cg2k1;
       cg2k0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2k1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Iy_entry() //  [R1]
         { info_tbl: [(cg2ke,
                       label: sat_sg1Iy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2ke: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2kf; else goto cg2kg;
       cg2kf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2kg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg2kl,
                       label: Data.Functor.Sum.$fOrdSum_$c>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2kl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2km; else goto cg2kn;
       cg2km: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2kn: // global
           I64[Sp - 40] = block_cg2jL_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2lh; else goto cg2jM;
       ug2lh: // global
           call _cg2jL(R1) args: 0, res: 0, upd: 0;
       cg2jM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2jL() //  [R1]
         { info_tbl: [(cg2jL,
                       label: block_cg2jL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2jL: // global
           _sg1Im::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg2ki; else goto cg2kj;
       cg2ki: // global
           I64[Sp] = block_cg2jQ_info;
           _sg1Io::P64 = P64[R1 + 7];
           R1 = _sg1Im::P64;
           P64[Sp + 32] = _sg1Io::P64;
           if (R1 & 7 != 0) goto ug2ld; else goto cg2jR;
       ug2ld: // global
           call _cg2jQ(R1) args: 0, res: 0, upd: 0;
       cg2jR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg2kj: // global
           I64[Sp + 8] = block_cg2k4_info;
           _sg1Iu::P64 = P64[R1 + 6];
           R1 = _sg1Im::P64;
           P64[Sp + 32] = _sg1Iu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug2le; else goto cg2k5;
       ug2le: // global
           call _cg2k4(R1) args: 0, res: 0, upd: 0;
       cg2k5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2jQ() //  [R1]
         { info_tbl: [(cg2jQ,
                       label: block_cg2jQ_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2jQ: // global
           if (R1 & 7 == 1) goto cg2kr; else goto ug2la;
       cg2kr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg2ku; else goto cg2kt;
       cg2ku: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2kt: // global
           _sg1Iq::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sg1Ir_info;
           P64[Hp] = P64[Sp + 24];
           _sg1Io::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg2kp_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sg1Io::P64;
           P64[Sp + 24] = _sg1Iq::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug2la: // global
           Sp = Sp + 40;
           call _cg2kY() args: 0, res: 0, upd: 0;
     }
 },
 _cg2kp() //  [R1]
         { info_tbl: [(cg2kp,
                       label: block_cg2kp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2kp: // global
           if (R1 & 7 == 3) goto ug2lb; else goto ug2lc;
       ug2lb: // global
           Sp = Sp + 8;
           call _cg2l2() args: 0, res: 0, upd: 0;
       ug2lc: // global
           Sp = Sp + 8;
           call _cg2kY() args: 0, res: 0, upd: 0;
     }
 },
 _cg2k4() //  [R1]
         { info_tbl: [(cg2k4,
                       label: block_cg2k4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2k4: // global
           if (R1 & 7 == 1) goto ug2l7; else goto cg2kP;
       ug2l7: // global
           Sp = Sp + 32;
           call _cg2l2() args: 0, res: 0, upd: 0;
       cg2kP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg2kS; else goto cg2kR;
       cg2kS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2kR: // global
           _sg1Ix::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sg1Iy_info;
           P64[Hp] = P64[Sp + 16];
           _sg1Iu::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cg2kO_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sg1Iu::P64;
           P64[Sp + 16] = _sg1Ix::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg2kO() //  [R1]
         { info_tbl: [(cg2kO,
                       label: block_cg2kO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2kO: // global
           if (R1 & 7 == 3) goto ug2l8; else goto ug2l9;
       ug2l8: // global
           Sp = Sp + 8;
           call _cg2l2() args: 0, res: 0, upd: 0;
       ug2l9: // global
           Sp = Sp + 8;
           call _cg2kY() args: 0, res: 0, upd: 0;
     }
 },
 _cg2l2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2l2: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg2kY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2kY: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.841510144 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$c<=_closure" {
     Data.Functor.Sum.$fOrdSum_$c<=_closure:
         const Data.Functor.Sum.$fOrdSum_$c<=_info;
 },
 sat_sg1IJ_entry() //  [R1]
         { info_tbl: [(cg2mG,
                       label: sat_sg1IJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2mG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2mH; else goto cg2mI;
       cg2mH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2mI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1IQ_entry() //  [R1]
         { info_tbl: [(cg2mV,
                       label: sat_sg1IQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2mV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2mW; else goto cg2mX;
       cg2mW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2mX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg2n2,
                       label: Data.Functor.Sum.$fOrdSum_$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2n2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2n3; else goto cg2n4;
       cg2n3: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2n4: // global
           I64[Sp - 40] = block_cg2ms_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2nY; else goto cg2mt;
       ug2nY: // global
           call _cg2ms(R1) args: 0, res: 0, upd: 0;
       cg2mt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2ms() //  [R1]
         { info_tbl: [(cg2ms,
                       label: block_cg2ms_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2ms: // global
           _sg1IE::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg2mZ; else goto cg2n0;
       cg2mZ: // global
           I64[Sp] = block_cg2mx_info;
           _sg1IG::P64 = P64[R1 + 7];
           R1 = _sg1IE::P64;
           P64[Sp + 32] = _sg1IG::P64;
           if (R1 & 7 != 0) goto ug2nU; else goto cg2my;
       ug2nU: // global
           call _cg2mx(R1) args: 0, res: 0, upd: 0;
       cg2my: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg2n0: // global
           I64[Sp + 8] = block_cg2mL_info;
           _sg1IM::P64 = P64[R1 + 6];
           R1 = _sg1IE::P64;
           P64[Sp + 32] = _sg1IM::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug2nV; else goto cg2mM;
       ug2nV: // global
           call _cg2mL(R1) args: 0, res: 0, upd: 0;
       cg2mM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2mx() //  [R1]
         { info_tbl: [(cg2mx,
                       label: block_cg2mx_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2mx: // global
           if (R1 & 7 == 1) goto cg2n8; else goto ug2nR;
       cg2n8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg2nb; else goto cg2na;
       cg2nb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2na: // global
           _sg1II::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sg1IJ_info;
           P64[Hp] = P64[Sp + 24];
           _sg1IG::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg2n6_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = _sg1IG::P64;
           P64[Sp + 24] = _sg1II::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug2nR: // global
           Sp = Sp + 40;
           call _cg2nF() args: 0, res: 0, upd: 0;
     }
 },
 _cg2n6() //  [R1]
         { info_tbl: [(cg2n6,
                       label: block_cg2n6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2n6: // global
           if (R1 & 7 == 3) goto ug2nS; else goto ug2nT;
       ug2nS: // global
           Sp = Sp + 8;
           call _cg2nJ() args: 0, res: 0, upd: 0;
       ug2nT: // global
           Sp = Sp + 8;
           call _cg2nF() args: 0, res: 0, upd: 0;
     }
 },
 _cg2mL() //  [R1]
         { info_tbl: [(cg2mL,
                       label: block_cg2mL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2mL: // global
           if (R1 & 7 == 1) goto ug2nO; else goto cg2nw;
       ug2nO: // global
           Sp = Sp + 32;
           call _cg2nJ() args: 0, res: 0, upd: 0;
       cg2nw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg2nz; else goto cg2ny;
       cg2nz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2ny: // global
           _sg1IP::P64 = P64[R1 + 6];
           I64[Hp - 16] = sat_sg1IQ_info;
           P64[Hp] = P64[Sp + 16];
           _sg1IM::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cg2nv_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = _sg1IM::P64;
           P64[Sp + 16] = _sg1IP::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg2nv() //  [R1]
         { info_tbl: [(cg2nv,
                       label: block_cg2nv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2nv: // global
           if (R1 & 7 == 3) goto ug2nP; else goto ug2nQ;
       ug2nP: // global
           Sp = Sp + 8;
           call _cg2nJ() args: 0, res: 0, upd: 0;
       ug2nQ: // global
           Sp = Sp + 8;
           call _cg2nF() args: 0, res: 0, upd: 0;
     }
 },
 _cg2nJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2nJ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg2nF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2nF: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.862069055 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$cmax_closure" {
     Data.Functor.Sum.$fOrdSum_$cmax_closure:
         const Data.Functor.Sum.$fOrdSum_$cmax_info;
 },
 Data.Functor.Sum.$fOrdSum_$cmax_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg2pf,
                       label: Data.Functor.Sum.$fOrdSum_$cmax_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2pf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg2pg; else goto cg2ph;
       cg2pg: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$cmax_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2ph: // global
           I64[Sp - 24] = block_cg2p9_info;
           _sg1IW::P64 = R6;
           R6 = R6;
           _sg1IV::P64 = R5;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           P64[Sp - 16] = _sg1IV::P64;
           P64[Sp - 8] = _sg1IW::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fOrdSum_$c<=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg2p9() //  [R1]
         { info_tbl: [(cg2p9,
                       label: block_cg2p9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2p9: // global
           if (R1 & 7 == 1) goto cg2pc; else goto cg2pd;
       cg2pc: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cg2pd: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.868299027 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_$cmin_closure" {
     Data.Functor.Sum.$fOrdSum_$cmin_closure:
         const Data.Functor.Sum.$fOrdSum_$cmin_info;
 },
 Data.Functor.Sum.$fOrdSum_$cmin_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg2pN,
                       label: Data.Functor.Sum.$fOrdSum_$cmin_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2pN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg2pO; else goto cg2pP;
       cg2pO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_$cmin_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2pP: // global
           I64[Sp - 24] = block_cg2pH_info;
           _sg1J2::P64 = R6;
           R6 = R6;
           _sg1J1::P64 = R5;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           P64[Sp - 16] = _sg1J1::P64;
           P64[Sp - 8] = _sg1J2::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fOrdSum_$c<=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg2pH() //  [R1]
         { info_tbl: [(cg2pH,
                       label: block_cg2pH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2pH: // global
           if (R1 & 7 == 1) goto cg2pK; else goto cg2pL;
       cg2pK: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cg2pL: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.876052098 UTC

[section ""data" . Data.Functor.Sum.$fOrdSum_closure" {
     Data.Functor.Sum.$fOrdSum_closure:
         const Data.Functor.Sum.$fOrdSum_info;
 },
 sat_sg1Je_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2qk,
                       label: sat_sg1Je_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2qk: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$cmin_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Jd_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2qs,
                       label: sat_sg1Jd_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2qs: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$cmax_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Jc_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2qA,
                       label: sat_sg1Jc_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2qA: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c>=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Jb_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2qI,
                       label: sat_sg1Jb_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2qI: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c>_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Ja_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2qQ,
                       label: sat_sg1Ja_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2qQ: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c<=_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1J9_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2qY,
                       label: sat_sg1J9_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2qY: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$c<_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1J8_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2r6,
                       label: sat_sg1J8_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2r6: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fOrdSum_$ccompare_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1J7_entry() //  [R1]
         { info_tbl: [(cg2rd,
                       label: sat_sg1J7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2rd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2re; else goto cg2rf;
       cg2re: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2rf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fOrdSum_$cp1Ord_entry(R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fOrdSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2rh,
                       label: Data.Functor.Sum.$fOrdSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2rh: // global
           Hp = Hp + 336;
           if (Hp > HpLim) (likely: False) goto cg2rl; else goto cg2rk;
       cg2rl: // global
           HpAlloc = 336;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fOrdSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2rk: // global
           I64[Hp - 328] = sat_sg1Je_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           I64[Hp - 296] = sat_sg1Jd_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           P64[Hp - 272] = R4;
           I64[Hp - 264] = sat_sg1Jc_info;
           P64[Hp - 256] = R2;
           P64[Hp - 248] = R3;
           P64[Hp - 240] = R4;
           I64[Hp - 232] = sat_sg1Jb_info;
           P64[Hp - 224] = R2;
           P64[Hp - 216] = R3;
           P64[Hp - 208] = R4;
           I64[Hp - 200] = sat_sg1Ja_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           P64[Hp - 176] = R4;
           I64[Hp - 168] = sat_sg1J9_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = sat_sg1J8_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sat_sg1J7_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 104;
           P64[Hp - 48] = Hp - 134;
           P64[Hp - 40] = Hp - 166;
           P64[Hp - 32] = Hp - 198;
           P64[Hp - 24] = Hp - 230;
           P64[Hp - 16] = Hp - 262;
           P64[Hp - 8] = Hp - 294;
           P64[Hp] = Hp - 326;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.896740624 UTC

[section ""data" . Data.Functor.Sum.$fReadSum1_closure" {
     Data.Functor.Sum.$fReadSum1_closure:
         const Data.Functor.Sum.$fReadSum1_info;
         const 0;
 },
 sat_sg1Jj_entry() //  [R1]
         { info_tbl: [(cg2sg,
                       label: sat_sg1Jj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2sg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2sh; else goto cg2si;
       cg2sh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2si: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Ji_entry() //  [R1]
         { info_tbl: [(cg2sn,
                       label: sat_sg1Ji_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2sn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2so; else goto cg2sp;
       cg2so: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2sp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fReadSum1_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2sq,
                       label: Data.Functor.Sum.$fReadSum1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2sq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg2su; else goto cg2st;
       cg2su: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2st: // global
           I64[Hp - 40] = sat_sg1Jj_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sg1Ji_info;
           P64[Hp] = R4;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.905401488 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_$creadsPrec_closure" {
     Data.Functor.Sum.$fReadSum_$creadsPrec_closure:
         const Data.Functor.Sum.$fReadSum_$creadsPrec_info;
         const 0;
 },
 sat_sg1Jp_entry() //  [R1]
         { info_tbl: [(cg2sX,
                       label: sat_sg1Jp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2sX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2sY; else goto cg2sZ;
       cg2sY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2sZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Jo_entry() //  [R1]
         { info_tbl: [(cg2t4,
                       label: sat_sg1Jo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2t4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2t5; else goto cg2t6;
       cg2t5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2t6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sg1Jn_entry() //  [R1]
         { info_tbl: [(cg2t7,
                       label: ds_sg1Jn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2t7: // global
           _sg1Jn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg2t8; else goto cg2t9;
       cg2t9: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg2tb; else goto cg2ta;
       cg2tb: // global
           HpAlloc = 48;
           goto cg2t8;
       cg2t8: // global
           R1 = _sg1Jn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2ta: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg1Jn::P64;
           _sg1Jk::P64 = P64[_sg1Jn::P64 + 16];
           _sg1Jl::P64 = P64[_sg1Jn::P64 + 24];
           _sg1Jm::P64 = P64[_sg1Jn::P64 + 32];
           I64[Hp - 40] = sat_sg1Jp_info;
           P64[Hp - 24] = _sg1Jm::P64;
           I64[Hp - 16] = sat_sg1Jo_info;
           P64[Hp] = _sg1Jm::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sg1Jl::P64;
           R2 = _sg1Jk::P64;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Jr_entry() //  [R1]
         { info_tbl: [(cg2tl,
                       label: sat_sg1Jr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2tl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2tm; else goto cg2tn;
       cg2tm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2tn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Js_entry() //  [R1, R2]
         { info_tbl: [(cg2to,
                       label: sat_sg1Js_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2to: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg2ts; else goto cg2tr;
       cg2ts: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg2tr: // global
           _sg1Jn::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sg1Jr_info;
           P64[Hp - 8] = _sg1Jn::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fReadSum_$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2tt,
                       label: Data.Functor.Sum.$fReadSum_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2tt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg2tx; else goto cg2tw;
       cg2tx: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2tw: // global
           I64[Hp - 48] = ds_sg1Jn_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sg1Js_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.921075457 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_$creadListPrec_closure" {
     Data.Functor.Sum.$fReadSum_$creadListPrec_closure:
         const Data.Functor.Sum.$fReadSum_$creadListPrec_info;
         const 0;
 },
 sat_sg1Jx_entry() //  [R1]
         { info_tbl: [(cg2uk,
                       label: sat_sg1Jx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2uk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2ul; else goto cg2um;
       cg2ul: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2um: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Jw_entry() //  [R1]
         { info_tbl: [(cg2ur,
                       label: sat_sg1Jw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2ur: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2us; else goto cg2ut;
       cg2us: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2ut: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Jy_entry() //  [R1]
         { info_tbl: [(cg2uu,
                       label: sat_sg1Jy_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2uu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg2uy; else goto cg2ux;
       cg2uy: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2ux: // global
           _sg1Jt::P64 = P64[R1 + 16];
           _sg1Ju::P64 = P64[R1 + 24];
           _sg1Jv::P64 = P64[R1 + 32];
           I64[Hp - 40] = sat_sg1Jx_info;
           P64[Hp - 24] = _sg1Jv::P64;
           I64[Hp - 16] = sat_sg1Jw_info;
           P64[Hp] = _sg1Jv::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sg1Ju::P64;
           R2 = _sg1Jt::P64;
           call Data.Functor.Sum.$fRead1Sum1_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fReadSum_$creadListPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2uz,
                       label: Data.Functor.Sum.$fReadSum_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2uz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg2uD; else goto cg2uC;
       cg2uD: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_$creadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2uC: // global
           I64[Hp - 32] = sat_sg1Jy_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.930951161 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_$creadList_closure" {
     Data.Functor.Sum.$fReadSum_$creadList_closure:
         const Data.Functor.Sum.$fReadSum_$creadList_info;
         const 0;
 },
 sat_sg1JC_entry() //  [R1]
         { info_tbl: [(cg2v6,
                       label: sat_sg1JC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2v6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2v7; else goto cg2v8;
       cg2v7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2v8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call Data.Functor.Sum.$fReadSum_$creadListPrec_entry(R4,
                                                                R3,
                                                                R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fReadSum_$creadList_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2v9,
                       label: Data.Functor.Sum.$fReadSum_$creadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2v9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg2vd; else goto cg2vc;
       cg2vd: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_$creadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2vc: // global
           I64[Hp - 32] = sat_sg1JC_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.937754585 UTC

[section ""data" . Data.Functor.Sum.$fReadSum_closure" {
     Data.Functor.Sum.$fReadSum_closure:
         const Data.Functor.Sum.$fReadSum_info;
         const 0;
 },
 sat_sg1JJ_entry() //  [R1]
         { info_tbl: [(cg2vB,
                       label: sat_sg1JJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2vB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2vC; else goto cg2vD;
       cg2vC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2vD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum_$creadListPrec_entry(R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1JI_entry() //  [R1]
         { info_tbl: [(cg2vI,
                       label: sat_sg1JI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2vI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2vJ; else goto cg2vK;
       cg2vJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2vK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum1_entry(R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1JH_entry() //  [R1]
         { info_tbl: [(cg2vP,
                       label: sat_sg1JH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2vP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2vQ; else goto cg2vR;
       cg2vQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2vR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum_$creadList_entry(R4,
                                                            R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1JG_entry() //  [R1]
         { info_tbl: [(cg2vW,
                       label: sat_sg1JG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2vW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2vX; else goto cg2vY;
       cg2vX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2vY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fReadSum_$creadsPrec_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fReadSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2w0,
                       label: Data.Functor.Sum.$fReadSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2w0: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cg2w4; else goto cg2w3;
       cg2w4: // global
           HpAlloc = 200;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fReadSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2w3: // global
           I64[Hp - 192] = sat_sg1JJ_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           I64[Hp - 152] = sat_sg1JI_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_sg1JH_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sg1JG_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.951412772 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_$cshowsPrec_closure" {
     Data.Functor.Sum.$fShowSum_$cshowsPrec_closure:
         const Data.Functor.Sum.$fShowSum_$cshowsPrec_info;
         const 0;
 },
 sat_sg1JS_entry() //  [R1]
         { info_tbl: [(cg2wQ,
                       label: sat_sg1JS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2wQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2wR; else goto cg2wS;
       cg2wR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2wS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1JR_entry() //  [R1]
         { info_tbl: [(cg2wX,
                       label: sat_sg1JR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2wX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2wY; else goto cg2wZ;
       cg2wY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2wZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fShowSum_$cshowsPrec_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg2x0,
                       label: Data.Functor.Sum.$fShowSum_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2x0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2x1; else goto cg2x2;
       cg2x1: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_$cshowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2x2: // global
           I64[Sp - 40] = block_cg2wH_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2x6; else goto cg2wI;
       ug2x6: // global
           call _cg2wH(R1) args: 0, res: 0, upd: 0;
       cg2wI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2wH() //  [R1]
         { info_tbl: [(cg2wH,
                       label: block_cg2wH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2wH: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg2x5; else goto cg2x4;
       cg2x5: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2x4: // global
           _sg1JQ::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sg1JS_info;
           _sg1JM::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sg1JM::P64;
           I64[Hp - 16] = sat_sg1JR_info;
           P64[Hp] = _sg1JM::P64;
           R6 = _sg1JQ::I64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.963907366 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_$cshow_closure" {
     Data.Functor.Sum.$fShowSum_$cshow_closure:
         const Data.Functor.Sum.$fShowSum_$cshow_info;
         const 0;
 },
 sat_sg1K0_entry() //  [R1]
         { info_tbl: [(cg2xK,
                       label: sat_sg1K0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2xK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2xL; else goto cg2xM;
       cg2xL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2xM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1JZ_entry() //  [R1]
         { info_tbl: [(cg2xR,
                       label: sat_sg1JZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2xR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2xS; else goto cg2xT;
       cg2xS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2xT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1K1_entry() //  [R1]
         { info_tbl: [(cg2xU,
                       label: sat_sg1K1_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2xU: // global
           _sg1K1::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cg2xV; else goto cg2xW;
       cg2xW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg2xY; else goto cg2xX;
       cg2xY: // global
           HpAlloc = 48;
           goto cg2xV;
       cg2xV: // global
           R1 = _sg1K1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2xX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg1K1::P64;
           _sg1JT::P64 = P64[_sg1K1::P64 + 16];
           _sg1JV::P64 = P64[_sg1K1::P64 + 24];
           _sg1JY::P64 = P64[_sg1K1::P64 + 32];
           I64[Hp - 40] = sat_sg1K0_info;
           P64[Hp - 24] = _sg1JV::P64;
           I64[Hp - 16] = sat_sg1JZ_info;
           P64[Hp] = _sg1JV::P64;
           R2 = _sg1JT::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = Hp - 16;
           P64[Sp - 48] = Hp - 40;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sg1JY::P64;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 sat_sg1K5_entry() //  [R1]
         { info_tbl: [(cg2y9,
                       label: sat_sg1K5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2y9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2ya; else goto cg2yb;
       cg2ya: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2yb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1K4_entry() //  [R1]
         { info_tbl: [(cg2yg,
                       label: sat_sg1K4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2yg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2yh; else goto cg2yi;
       cg2yh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2yi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1K6_entry() //  [R1]
         { info_tbl: [(cg2yj,
                       label: sat_sg1K6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2yj: // global
           _sg1K6::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cg2yk; else goto cg2yl;
       cg2yl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg2yn; else goto cg2ym;
       cg2yn: // global
           HpAlloc = 48;
           goto cg2yk;
       cg2yk: // global
           R1 = _sg1K6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2ym: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg1K6::P64;
           _sg1JU::P64 = P64[_sg1K6::P64 + 16];
           _sg1JV::P64 = P64[_sg1K6::P64 + 24];
           _sg1K3::P64 = P64[_sg1K6::P64 + 32];
           I64[Hp - 40] = sat_sg1K5_info;
           P64[Hp - 24] = _sg1JV::P64;
           I64[Hp - 16] = sat_sg1K4_info;
           P64[Hp] = _sg1JV::P64;
           R2 = _sg1JU::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = Hp - 16;
           P64[Sp - 48] = Hp - 40;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sg1K3::P64;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fShowSum_$cshow_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg2ys,
                       label: Data.Functor.Sum.$fShowSum_$cshow_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2ys: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg2yt; else goto cg2yu;
       cg2yt: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_$cshow_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2yu: // global
           I64[Sp - 32] = block_cg2xx_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug2yD; else goto cg2xy;
       ug2yD: // global
           call _cg2xx(R1) args: 0, res: 0, upd: 0;
       cg2xy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2xx() //  [R1]
         { info_tbl: [(cg2xx,
                       label: block_cg2xx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2xx: // global
           _sg1JV::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg2yp; else goto cg2yq;
       cg2yp: // global
           Hp = Hp + 64;
           _sg1JX::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg2yC; else goto cg2yx;
       cg2yx: // global
           _sg1JY::P64 = P64[_sg1JX::P64 + 7];
           I64[Hp - 56] = sat_sg1K1_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg1JV::P64;
           P64[Hp - 24] = _sg1JY::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = Data.Functor.Sum.$fRead1Sum7_closure;
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cg2yq: // global
           Hp = Hp + 64;
           _sg1JX::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg2yC; else goto cg2yB;
       cg2yC: // global
           HpAlloc = 64;
           R1 = _sg1JX::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2yB: // global
           _sg1K3::P64 = P64[_sg1JX::P64 + 6];
           I64[Hp - 56] = sat_sg1K6_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = _sg1JV::P64;
           P64[Hp - 24] = _sg1K3::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = Data.Functor.Sum.$fRead1Sum3_closure;
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.984375291 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_$cshowList_closure" {
     Data.Functor.Sum.$fShowSum_$cshowList_closure:
         const Data.Functor.Sum.$fShowSum_$cshowList_info;
         const 0;
 },
 lvl8_sg1Kd_entry() //  [R1]
         { info_tbl: [(cg2zS,
                       label: lvl8_sg1Kd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2zS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2zT; else goto cg2zU;
       cg2zT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2zU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sg1Ke_entry() //  [R1]
         { info_tbl: [(cg2zZ,
                       label: lvl9_sg1Ke_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2zZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2A0; else goto cg2A1;
       cg2A0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2A1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Kg_entry() //  [R1, R2]
         { info_tbl: [(cg2A7,
                       label: sat_sg1Kg_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2A7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg2A8; else goto cg2A9;
       cg2A8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg2A9: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sg1Kf::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sg1Kf::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$w$cliftShowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShowSum_$cshowList_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg2Aa,
                       label: Data.Functor.Sum.$fShowSum_$cshowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Aa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg2Ae; else goto cg2Ad;
       cg2Ae: // global
           HpAlloc = 88;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_$cshowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2Ad: // global
           I64[Hp - 80] = lvl8_sg1Kd_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl9_sg1Ke_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg1Kg_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 31;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:52.995218767 UTC

[section ""data" . Data.Functor.Sum.$fShowSum_closure" {
     Data.Functor.Sum.$fShowSum_closure:
         const Data.Functor.Sum.$fShowSum_info;
         const 0;
 },
 sat_sg1Km_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2AL,
                       label: sat_sg1Km_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2AL: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fShowSum_$cshowList_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Kl_entry() //  [R1, R2]
         { info_tbl: [(cg2AT,
                       label: sat_sg1Kl_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2AT: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fShowSum_$cshow_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Kk_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2B1,
                       label: sat_sg1Kk_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2B1: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fShowSum_$cshowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fShowSum_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2B5,
                       label: Data.Functor.Sum.$fShowSum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2B5: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg2B9; else goto cg2B8;
       cg2B9: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fShowSum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2B8: // global
           I64[Hp - 120] = sat_sg1Km_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sg1Kl_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sg1Kk_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 118;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.005513348 UTC

[section ""data" . Data.Functor.Sum.$fFunctorSum_$cfmap_closure" {
     Data.Functor.Sum.$fFunctorSum_$cfmap_closure:
         const Data.Functor.Sum.$fFunctorSum_$cfmap_info;
 },
 sat_sg1Kt_entry() //  [R1]
         { info_tbl: [(cg2BI,
                       label: sat_sg1Kt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2BI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2BJ; else goto cg2BK;
       cg2BJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2BK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg1Kv_entry() //  [R1]
         { info_tbl: [(cg2BR,
                       label: sat_sg1Kv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2BR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2BS; else goto cg2BT;
       cg2BS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2BT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fFunctorSum_$cfmap_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg2BY,
                       label: Data.Functor.Sum.$fFunctorSum_$cfmap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2BY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg2BZ; else goto cg2C0;
       cg2BZ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFunctorSum_$cfmap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2C0: // global
           I64[Sp - 32] = block_cg2Bz_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug2C9; else goto cg2BA;
       ug2C9: // global
           call _cg2Bz(R1) args: 0, res: 0, upd: 0;
       cg2BA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2Bz() //  [R1]
         { info_tbl: [(cg2Bz,
                       label: block_cg2Bz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Bz: // global
           _sg1Kp::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg2BV; else goto cg2BW;
       cg2BV: // global
           Hp = Hp + 56;
           _sg1Kr::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg2C8; else goto cg2C3;
       cg2C3: // global
           _sg1Ks::P64 = P64[_sg1Kr::P64 + 7];
           I64[Hp - 48] = sat_sg1Kt_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg1Kp::P64;
           P64[Hp - 16] = _sg1Ks::P64;
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg2BW: // global
           Hp = Hp + 56;
           _sg1Kr::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg2C8; else goto cg2C7;
       cg2C8: // global
           HpAlloc = 56;
           R1 = _sg1Kr::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2C7: // global
           _sg1Ku::P64 = P64[_sg1Kr::P64 + 6];
           I64[Hp - 48] = sat_sg1Kv_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sg1Kp::P64;
           P64[Hp - 16] = _sg1Ku::P64;
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.017350238 UTC

[section ""data" . Data.Functor.Sum.$fFunctorSum_$c<$_closure" {
     Data.Functor.Sum.$fFunctorSum_$c<$_closure:
         const Data.Functor.Sum.$fFunctorSum_$c<$_info;
 },
 sat_sg1KB_entry() //  [R1]
         { info_tbl: [(cg2CV,
                       label: sat_sg1KB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2CV: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFunctorSum_$c<$_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg2CY,
                       label: Data.Functor.Sum.$fFunctorSum_$c<$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2CY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg2D2; else goto cg2D1;
       cg2D2: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFunctorSum_$c<$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2D1: // global
           I64[Hp - 8] = sat_sg1KB_info;
           P64[Hp] = R4;
           R5 = R5;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fFunctorSum_$cfmap_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.023053981 UTC

[section ""data" . Data.Functor.Sum.$fFunctorSum_closure" {
     Data.Functor.Sum.$fFunctorSum_closure:
         const Data.Functor.Sum.$fFunctorSum_info;
 },
 sat_sg1KF_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2Dk,
                       label: sat_sg1KF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Dk: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFunctorSum_$c<$_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1KE_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2Ds,
                       label: sat_sg1KE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Ds: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFunctorSum_$cfmap_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFunctorSum_entry() //  [R2, R3]
         { info_tbl: [(cg2Dw,
                       label: Data.Functor.Sum.$fFunctorSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Dw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg2DA; else goto cg2Dz;
       cg2DA: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFunctorSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2Dz: // global
           I64[Hp - 64] = sat_sg1KF_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg1KE_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.031088376 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldMap_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldMap_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldMap_info;
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldMap_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cg2E2,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2E2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2E3; else goto cg2E4;
       cg2E3: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2E4: // global
           I64[Sp - 40] = block_cg2DV_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2Eb; else goto cg2DW;
       ug2Eb: // global
           call _cg2DV(R1) args: 0, res: 0, upd: 0;
       cg2DW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2DV() //  [R1]
         { info_tbl: [(cg2DV,
                       label: block_cg2DV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2DV: // global
           _sg1KI::P64 = P64[Sp + 24];
           _sg1KJ::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg2DZ; else goto cg2E0;
       cg2DZ: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = _sg1KI::P64;
           P64[Sp + 24] = _sg1KJ::P64;
           P64[Sp + 32] = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg2E0: // global
           R2 = P64[Sp + 16];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = _sg1KI::P64;
           P64[Sp + 24] = _sg1KJ::P64;
           P64[Sp + 32] = P64[R1 + 6];
           Sp = Sp + 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.037965083 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfold_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfold_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfold_info;
 },
 Data.Functor.Sum.$fFoldableSum_$cfold_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg2ED,
                       label: Data.Functor.Sum.$fFoldableSum_$cfold_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2ED: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg2EE; else goto cg2EF;
       cg2EE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfold_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2EF: // global
           I64[Sp - 32] = block_cg2Ew_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug2EM; else goto cg2Ex;
       ug2EM: // global
           call _cg2Ew(R1) args: 0, res: 0, upd: 0;
       cg2Ex: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2Ew() //  [R1]
         { info_tbl: [(cg2Ew,
                       label: block_cg2Ew_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Ew: // global
           _sg1KQ::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg2EA; else goto cg2EB;
       cg2EA: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sg1KQ::P64;
           P64[Sp + 16] = GHC.Base.id_closure+1;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg2EB: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sg1KQ::P64;
           P64[Sp + 16] = GHC.Base.id_closure+1;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.044114817 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum2_closure" {
     Data.Functor.Sum.$fFoldableSum2_closure:
         const Data.Functor.Sum.$fFoldableSum2_info;
 },
 Data.Functor.Sum.$fFoldableSum2_entry() //  [R2]
         { info_tbl: [(cg2Fb,
                       label: Data.Functor.Sum.$fFoldableSum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Fb: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.048669029 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum3_closure" {
     Data.Functor.Sum.$fFoldableSum3_closure:
         const Data.Functor.Sum.$fFoldableSum3_info;
         const 0;
 },
 $dMonoid_sg1KZ_entry() //  [R1]
         { info_tbl: [(cg2Fq,
                       label: $dMonoid_sg1KZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Fq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2Fr; else goto cg2Fs;
       cg2Fr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2Fs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1L4_entry() //  [R1, R2]
         { info_tbl: [(cg2FF,
                       label: sat_sg1L4_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2FF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg2FG; else goto cg2FH;
       cg2FG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg2FH: // global
           I64[Sp - 32] = block_cg2Fy_info;
           _sg1KW::P64 = P64[R1 + 7];
           _sg1KX::P64 = P64[R1 + 15];
           _sg1KZ::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sg1KW::P64;
           P64[Sp - 16] = _sg1KX::P64;
           P64[Sp - 8] = _sg1KZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug2FO; else goto cg2Fz;
       ug2FO: // global
           call _cg2Fy(R1) args: 0, res: 0, upd: 0;
       cg2Fz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2Fy() //  [R1]
         { info_tbl: [(cg2Fy,
                       label: block_cg2Fy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Fy: // global
           _sg1KZ::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg2FC; else goto cg2FD;
       cg2FC: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sg1KZ::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg2FD: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sg1KZ::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum3_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2FP,
                       label: Data.Functor.Sum.$fFoldableSum3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2FP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg2FT; else goto cg2FS;
       cg2FT: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2FS: // global
           I64[Hp - 48] = $dMonoid_sg1KZ_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sg1L4_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.058940088 UTC

[section ""cstring" . lvl_rfXP1_bytes" {
     lvl_rfXP1_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.060983056 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum4_closure" {
     Data.Functor.Sum.$fFoldableSum4_closure:
         const Data.Functor.Sum.$fFoldableSum4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum4_entry() //  [R1]
         { info_tbl: [(cg2Gx,
                       label: Data.Functor.Sum.$fFoldableSum4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Gx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg2Gy; else goto cg2Gz;
       cg2Gy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2Gz: // global
           (_cg2Gs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg2Gs::I64 == 0) goto cg2Gu; else goto cg2Gt;
       cg2Gu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg2Gt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg2Gs::I64;
           I64[Sp - 24] = block_cg2Gv_info;
           R2 = lvl_rfXP1_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg2Gv() //  [R1]
         { info_tbl: [(cg2Gv,
                       label: block_cg2Gv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Gv: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.067462323 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cminimum_closure" {
     Data.Functor.Sum.$fFoldableSum_$cminimum_closure:
         const Data.Functor.Sum.$fFoldableSum_$cminimum_info;
         const 0;
 },
 g1_sg1L9_entry() //  [R1]
         { info_tbl: [(cg2GX,
                       label: g1_sg1L9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2GX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2GY; else goto cg2GZ;
       cg2GY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2GZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Li_entry() //  [R1, R2]
         { info_tbl: [(cg2Hc,
                       label: sat_sg1Li_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Hc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2Hd; else goto cg2He;
       cg2Hd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg2He: // global
           I64[Sp - 32] = block_cg2H5_info;
           _sg1L6::P64 = P64[R1 + 7];
           _sg1L7::P64 = P64[R1 + 15];
           _sg1L9::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sg1L6::P64;
           P64[Sp - 16] = _sg1L7::P64;
           P64[Sp - 8] = _sg1L9::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug2HL; else goto cg2H6;
       ug2HL: // global
           call _cg2H5(R1) args: 0, res: 0, upd: 0;
       cg2H6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2H5() //  [R1]
         { info_tbl: [(cg2H5,
                       label: block_cg2H5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2H5: // global
           _sg1L9::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg2H9; else goto cg2Ha;
       cg2H9: // global
           I64[Sp + 24] = block_cg2Hh_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sg1L9::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cg2Ha: // global
           I64[Sp + 24] = block_cg2Hv_info;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sg1L9::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 6];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg2Hh() //  [R1]
         { info_tbl: [(cg2Hh,
                       label: block_cg2Hh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Hh: // global
           if (R1 & 7 == 1) goto ug2HK; else goto cg2Hs;
       ug2HK: // global
           Sp = Sp + 8;
           call _cg2HC() args: 0, res: 0, upd: 0;
       cg2Hs: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg2Hv() //  [R1]
         { info_tbl: [(cg2Hv,
                       label: block_cg2Hv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Hv: // global
           if (R1 & 7 == 1) goto ug2HJ; else goto cg2HG;
       ug2HJ: // global
           Sp = Sp + 8;
           call _cg2HC() args: 0, res: 0, upd: 0;
       cg2HG: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg2HC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2HC: // global
           R1 = Data.Functor.Sum.$fFoldableSum4_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cminimum_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2HO,
                       label: Data.Functor.Sum.$fFoldableSum_$cminimum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2HO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg2HS; else goto cg2HR;
       cg2HS: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cminimum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2HR: // global
           I64[Hp - 48] = g1_sg1L9_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sg1Li_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.082374386 UTC

[section ""cstring" . lvl1_rfXP2_bytes" {
     lvl1_rfXP2_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.08445558 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum5_closure" {
     Data.Functor.Sum.$fFoldableSum5_closure:
         const Data.Functor.Sum.$fFoldableSum5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum5_entry() //  [R1]
         { info_tbl: [(cg2IM,
                       label: Data.Functor.Sum.$fFoldableSum5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2IM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg2IN; else goto cg2IO;
       cg2IN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2IO: // global
           (_cg2IH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg2IH::I64 == 0) goto cg2IJ; else goto cg2II;
       cg2IJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg2II: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg2IH::I64;
           I64[Sp - 24] = block_cg2IK_info;
           R2 = lvl1_rfXP2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg2IK() //  [R1]
         { info_tbl: [(cg2IK,
                       label: block_cg2IK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2IK: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.091972575 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cmaximum_closure" {
     Data.Functor.Sum.$fFoldableSum_$cmaximum_closure:
         const Data.Functor.Sum.$fFoldableSum_$cmaximum_info;
         const 0;
 },
 g1_sg1Ln_entry() //  [R1]
         { info_tbl: [(cg2Jc,
                       label: g1_sg1Ln_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Jc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2Jd; else goto cg2Je;
       cg2Jd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2Je: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Lw_entry() //  [R1, R2]
         { info_tbl: [(cg2Jr,
                       label: sat_sg1Lw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Jr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2Js; else goto cg2Jt;
       cg2Js: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg2Jt: // global
           I64[Sp - 32] = block_cg2Jk_info;
           _sg1Lk::P64 = P64[R1 + 7];
           _sg1Ll::P64 = P64[R1 + 15];
           _sg1Ln::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sg1Lk::P64;
           P64[Sp - 16] = _sg1Ll::P64;
           P64[Sp - 8] = _sg1Ln::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug2K0; else goto cg2Jl;
       ug2K0: // global
           call _cg2Jk(R1) args: 0, res: 0, upd: 0;
       cg2Jl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2Jk() //  [R1]
         { info_tbl: [(cg2Jk,
                       label: block_cg2Jk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Jk: // global
           _sg1Ln::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg2Jo; else goto cg2Jp;
       cg2Jo: // global
           I64[Sp + 24] = block_cg2Jw_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sg1Ln::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cg2Jp: // global
           I64[Sp + 24] = block_cg2JK_info;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = _sg1Ln::P64;
           P64[Sp + 8] = GHC.Base.Just_closure+1;
           P64[Sp + 16] = P64[R1 + 6];
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg2Jw() //  [R1]
         { info_tbl: [(cg2Jw,
                       label: block_cg2Jw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Jw: // global
           if (R1 & 7 == 1) goto ug2JZ; else goto cg2JH;
       ug2JZ: // global
           Sp = Sp + 8;
           call _cg2JR() args: 0, res: 0, upd: 0;
       cg2JH: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg2JK() //  [R1]
         { info_tbl: [(cg2JK,
                       label: block_cg2JK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2JK: // global
           if (R1 & 7 == 1) goto ug2JY; else goto cg2JV;
       ug2JY: // global
           Sp = Sp + 8;
           call _cg2JR() args: 0, res: 0, upd: 0;
       cg2JV: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg2JR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2JR: // global
           R1 = Data.Functor.Sum.$fFoldableSum5_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cmaximum_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2K3,
                       label: Data.Functor.Sum.$fFoldableSum_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2K3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg2K7; else goto cg2K6;
       cg2K7: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cmaximum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2K6: // global
           I64[Hp - 48] = g1_sg1Ln_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sg1Lw_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.107292744 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$celem_closure" {
     Data.Functor.Sum.$fFoldableSum_$celem_closure:
         const Data.Functor.Sum.$fFoldableSum_$celem_info;
         const 0;
 },
 f1_sg1LB_entry() //  [R1]
         { info_tbl: [(cg2L0,
                       label: f1_sg1LB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2L0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg2L1; else goto cg2L2;
       cg2L1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2L2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg1LG_entry() //  [R1, R2]
         { info_tbl: [(cg2Lf,
                       label: sat_sg1LG_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Lf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg2Lg; else goto cg2Lh;
       cg2Lg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg2Lh: // global
           I64[Sp - 32] = block_cg2L8_info;
           _sg1Lx::P64 = P64[R1 + 7];
           _sg1Ly::P64 = P64[R1 + 15];
           _sg1LB::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sg1Lx::P64;
           P64[Sp - 16] = _sg1Ly::P64;
           P64[Sp - 8] = _sg1LB::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug2Lo; else goto cg2L9;
       ug2Lo: // global
           call _cg2L8(R1) args: 0, res: 0, upd: 0;
       cg2L9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2L8() //  [R1]
         { info_tbl: [(cg2L8,
                       label: block_cg2L8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2L8: // global
           _sg1LB::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg2Lc; else goto cg2Ld;
       cg2Lc: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp + 16] = _sg1LB::P64;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg2Ld: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp + 16] = _sg1LB::P64;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$celem_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg2Lp,
                       label: Data.Functor.Sum.$fFoldableSum_$celem_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Lp: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg2Lt; else goto cg2Ls;
       cg2Lt: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$celem_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2Ls: // global
           I64[Hp - 56] = f1_sg1LB_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = sat_sg1LG_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.117720488 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum10_closure" {
     Data.Functor.Sum.$fFoldableSum10_closure:
         const Data.Functor.Sum.$fFoldableSum10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum10_entry() //  [R1]
         { info_tbl: [(cg2M6,
                       label: Data.Functor.Sum.$fFoldableSum10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2M6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2M7; else goto cg2M8;
       cg2M7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2M8: // global
           (_cg2M3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg2M3::I64 == 0) goto cg2M5; else goto cg2M4;
       cg2M5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg2M4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg2M3::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.122522206 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldl_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldl_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldl_info;
         const 0;
 },
 f2_sg1LM_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2Mq,
                       label: f2_sg1LM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Mq: // global
           _sg1LO::P64 = R3;
           R3 = R2;
           R2 = _sg1LO::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldl_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg2MA,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2MA: // global
           _sg1LL::P64 = R6;
           _sg1LK::P64 = R5;
           _sg1LJ::P64 = R4;
           _sg1LI::P64 = R3;
           _sg1LH::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cg2MB; else goto cg2MC;
       cg2MC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg2ME; else goto cg2MD;
       cg2ME: // global
           HpAlloc = 16;
           goto cg2MB;
       cg2MB: // global
           R6 = _sg1LL::P64;
           R5 = _sg1LK::P64;
           R4 = _sg1LJ::P64;
           R3 = _sg1LI::P64;
           R2 = _sg1LH::P64;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2MD: // global
           I64[Hp - 8] = f2_sg1LM_info;
           P64[Hp] = _sg1LJ::P64;
           I64[Sp - 40] = block_cg2Mt_info;
           R1 = _sg1LL::P64;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = _sg1LH::P64;
           P64[Sp - 16] = _sg1LI::P64;
           P64[Sp - 8] = _sg1LK::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2ML; else goto cg2Mu;
       ug2ML: // global
           call _cg2Mt(R1) args: 0, res: 0, upd: 0;
       cg2Mu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2Mt() //  [R1]
         { info_tbl: [(cg2Mt,
                       label: block_cg2Mt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Mt: // global
           _cg2Ml::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cg2Mx; else goto cg2My;
       cg2Mx: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 16] = _cg2Ml::P64;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
       cg2My: // global
           R2 = P64[Sp + 24];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 16] = _cg2Ml::P64;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.131343435 UTC

[section ""cstring" . lvl2_rfXP3_bytes" {
     lvl2_rfXP3_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.1333846 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum9_closure" {
     Data.Functor.Sum.$fFoldableSum9_closure:
         const Data.Functor.Sum.$fFoldableSum9_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum9_entry() //  [R1]
         { info_tbl: [(cg2Ni,
                       label: Data.Functor.Sum.$fFoldableSum9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Ni: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg2Nj; else goto cg2Nk;
       cg2Nj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2Nk: // global
           (_cg2Nd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg2Nd::I64 == 0) goto cg2Nf; else goto cg2Ne;
       cg2Nf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg2Ne: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg2Nd::I64;
           I64[Sp - 24] = block_cg2Ng_info;
           R2 = lvl2_rfXP3_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg2Ng() //  [R1]
         { info_tbl: [(cg2Ng,
                       label: block_cg2Ng_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Ng: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.141141239 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldl1_info;
         const 0;
 },
 sat_sg1M3_entry() //  [R1]
         { info_tbl: [(cg2NZ,
                       label: sat_sg1M3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2NZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2O0; else goto cg2O1;
       cg2O0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2O1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg2NS_info;
           _sg1LV::P64 = P64[R1 + 16];
           _sg1LZ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sg1LV::P64;
           P64[Sp - 24] = _sg1LZ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2O8; else goto cg2NT;
       ug2O8: // global
           call _cg2NS(R1) args: 0, res: 0, upd: 0;
       cg2NT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg2NS() //  [R1]
         { info_tbl: [(cg2NS,
                       label: block_cg2NS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2NS: // global
           _sg1LZ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg2NW; else goto cg2NX;
       cg2NW: // global
           R1 = _sg1LZ::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cg2NX: // global
           R3 = _sg1LZ::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1M4_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2Oa,
                       label: sat_sg1M4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Oa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg2Oe; else goto cg2Od;
       cg2Oe: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2Od: // global
           _sg1LV::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sg1M3_info;
           P64[Hp - 32] = _sg1LV::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Mc_entry() //  [R1]
         { info_tbl: [(cg2Ox,
                       label: sat_sg1Mc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Ox: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2Oy; else goto cg2Oz;
       cg2Oy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2Oz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg2Oq_info;
           _sg1LV::P64 = P64[R1 + 16];
           _sg1M8::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sg1LV::P64;
           P64[Sp - 24] = _sg1M8::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2OG; else goto cg2Or;
       ug2OG: // global
           call _cg2Oq(R1) args: 0, res: 0, upd: 0;
       cg2Or: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg2Oq() //  [R1]
         { info_tbl: [(cg2Oq,
                       label: block_cg2Oq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Oq: // global
           _sg1M8::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg2Ou; else goto cg2Ov;
       cg2Ou: // global
           R1 = _sg1M8::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cg2Ov: // global
           R3 = _sg1M8::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Md_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2OI,
                       label: sat_sg1Md_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2OI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg2OM; else goto cg2OL;
       cg2OM: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2OL: // global
           _sg1LV::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sg1Mc_info;
           P64[Hp - 32] = _sg1LV::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldl1_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cg2OR,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2OR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg2OS; else goto cg2OT;
       cg2OS: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2OT: // global
           I64[Sp - 32] = block_cg2NE_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug2Pq; else goto cg2NF;
       ug2Pq: // global
           call _cg2NE(R1) args: 0, res: 0, upd: 0;
       cg2NF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2NE() //  [R1]
         { info_tbl: [(cg2NE,
                       label: block_cg2NE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2NE: // global
           _sg1LV::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg2OO; else goto cg2OP;
       cg2OO: // global
           Hp = Hp + 16;
           _sg1LX::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg2Pb; else goto cg2OW;
       cg2OW: // global
           _sg1LY::P64 = P64[_sg1LX::P64 + 7];
           I64[Hp - 8] = sat_sg1M4_info;
           P64[Hp] = _sg1LV::P64;
           I64[Sp + 24] = block_cg2OU_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp] = Hp - 6;
           P64[Sp + 8] = _sg1LY::P64;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
       cg2OP: // global
           Hp = Hp + 16;
           _sg1LX::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg2Pb; else goto cg2Pa;
       cg2Pb: // global
           HpAlloc = 16;
           R1 = _sg1LX::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2Pa: // global
           _sg1M7::P64 = P64[_sg1LX::P64 + 6];
           I64[Hp - 8] = sat_sg1Md_info;
           P64[Hp] = _sg1LV::P64;
           I64[Sp + 24] = block_cg2P8_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp] = Hp - 6;
           P64[Sp + 8] = _sg1M7::P64;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cg2OU() //  [R1]
         { info_tbl: [(cg2OU,
                       label: block_cg2OU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2OU: // global
           if (R1 & 7 == 1) goto ug2Pp; else goto cg2P7;
       ug2Pp: // global
           Sp = Sp + 8;
           call _cg2Ph() args: 0, res: 0, upd: 0;
       cg2P7: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg2P8() //  [R1]
         { info_tbl: [(cg2P8,
                       label: block_cg2P8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2P8: // global
           if (R1 & 7 == 1) goto ug2Po; else goto cg2Pl;
       ug2Po: // global
           Sp = Sp + 8;
           call _cg2Ph() args: 0, res: 0, upd: 0;
       cg2Pl: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg2Ph() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Ph: // global
           R1 = Data.Functor.Sum.$fFoldableSum9_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.165659587 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldr'_info;
         const 0;
 },
 sat_sg1Mr_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg2QX,
                       label: sat_sg1Mr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2QX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2QY; else goto cg2QZ;
       cg2QY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2QZ: // global
           I64[Sp - 16] = block_cg2QV_info;
           _sg1Mo::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sg1Mo::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2QV() //  [R1]
         { info_tbl: [(cg2QV,
                       label: block_cg2QV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2QV: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Mx_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg2Ra,
                       label: sat_sg1Mx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Ra: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2Rb; else goto cg2Rc;
       cg2Rb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2Rc: // global
           I64[Sp - 16] = block_cg2R8_info;
           _sg1Mu::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sg1Mu::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2R8() //  [R1]
         { info_tbl: [(cg2R8,
                       label: block_cg2R8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2R8: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldr'_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cg2Ri,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Ri: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg2Rj; else goto cg2Rk;
       cg2Rj: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2Rk: // global
           I64[Sp - 40] = block_cg2QL_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2Rr; else goto cg2QM;
       ug2Rr: // global
           call _cg2QL(R1) args: 0, res: 0, upd: 0;
       cg2QM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2QL() //  [R1]
         { info_tbl: [(cg2QL,
                       label: block_cg2QL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2QL: // global
           _sg1Mi::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg2Rf; else goto cg2Rg;
       cg2Rf: // global
           Hp = Hp + 16;
           _sg1Ml::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg2Rq; else goto cg2Rm;
       cg2Rm: // global
           _sg1Mm::P64 = P64[_sg1Ml::P64 + 7];
           I64[Hp - 8] = sat_sg1Mr_info;
           P64[Hp] = _sg1Mi::P64;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppppp_info;
           P64[Sp] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 8] = Hp - 5;
           P64[Sp + 16] = _sg1Mm::P64;
           P64[Sp + 24] = GHC.Base.id_closure+1;
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
       cg2Rg: // global
           Hp = Hp + 16;
           _sg1Ml::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg2Rq; else goto cg2Rp;
       cg2Rq: // global
           HpAlloc = 16;
           R1 = _sg1Ml::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2Rp: // global
           _sg1Ms::P64 = P64[_sg1Ml::P64 + 6];
           I64[Hp - 8] = sat_sg1Mx_info;
           P64[Hp] = _sg1Mi::P64;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = stg_ap_ppppp_info;
           P64[Sp] = Data.Functor.Sum.$fFoldableSum10_closure;
           P64[Sp + 8] = Hp - 5;
           P64[Sp + 16] = _sg1Ms::P64;
           P64[Sp + 24] = GHC.Base.id_closure+1;
           Sp = Sp - 8;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.181398874 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldr_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldr_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldr_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldr_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg2Sh,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Sh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2Si; else goto cg2Sj;
       cg2Si: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2Sj: // global
           I64[Sp - 40] = block_cg2Sa_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2Sq; else goto cg2Sb;
       ug2Sq: // global
           call _cg2Sa(R1) args: 0, res: 0, upd: 0;
       cg2Sb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2Sa() //  [R1]
         { info_tbl: [(cg2Sa,
                       label: block_cg2Sa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Sa: // global
           _sg1MA::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg2Se; else goto cg2Sf;
       cg2Se: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp + 16] = _sg1MA::P64;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
       cg2Sf: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp + 16] = _sg1MA::P64;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.188119311 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldl'_info;
         const 0;
 },
 sat_sg1MP_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg2SU,
                       label: sat_sg1MP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2SU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2SV; else goto cg2SW;
       cg2SV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2SW: // global
           I64[Sp - 16] = block_cg2SS_info;
           _sg1MM::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sg1MM::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2SS() //  [R1]
         { info_tbl: [(cg2SS,
                       label: block_cg2SS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2SS: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldl'_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cg2SY,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2SY: // global
           _sg1MK::P64 = R6;
           _sg1MJ::P64 = R5;
           _sg1MI::P64 = R4;
           _sg1MH::P64 = R3;
           _sg1MG::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cg2SZ; else goto cg2T0;
       cg2T0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg2T2; else goto cg2T1;
       cg2T2: // global
           HpAlloc = 16;
           goto cg2SZ;
       cg2SZ: // global
           R6 = _sg1MK::P64;
           R5 = _sg1MJ::P64;
           R4 = _sg1MI::P64;
           R3 = _sg1MH::P64;
           R2 = _sg1MG::P64;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2T1: // global
           I64[Hp - 8] = sat_sg1MP_info;
           P64[Hp] = _sg1MI::P64;
           R6 = _sg1MK::P64;
           R5 = GHC.Base.id_closure+1;
           R4 = Hp - 5;
           R3 = _sg1MH::P64;
           R2 = _sg1MG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sg1MJ::P64;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.19626008 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum7_closure" {
     Data.Functor.Sum.$fFoldableSum7_closure:
         const Data.Functor.Sum.$fFoldableSum7_info;
 },
 Data.Functor.Sum.$fFoldableSum7_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2Tq,
                       label: Data.Functor.Sum.$fFoldableSum7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Tq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2Tx; else goto cg2Ty;
       cg2Tx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2Ty: // global
           I64[Sp - 16] = block_cg2Tn_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ug2TC; else goto cg2To;
       ug2TC: // global
           call _cg2Tn(R1) args: 0, res: 0, upd: 0;
       cg2To: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2Tn() //  [R1]
         { info_tbl: [(cg2Tn,
                       label: block_cg2Tn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Tn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg2TB; else goto cg2TA;
       cg2TB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2TA: // global
           _sg1MV::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sg1MV::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.202711458 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$clength_closure" {
     Data.Functor.Sum.$fFoldableSum_$clength_closure:
         const Data.Functor.Sum.$fFoldableSum_$clength_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$clength_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2TT,
                       label: Data.Functor.Sum.$fFoldableSum_$clength_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2TT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2TU; else goto cg2TV;
       cg2TU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_$clength_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2TV: // global
           R6 = R4;
           R5 = GHC.Base.id_closure+1;
           R4 = Data.Functor.Sum.$fFoldableSum7_closure+3;
           R3 = R3;
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Functor.Sum.$fFoldableSum6_closure+1;
           Sp = Sp - 16;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.206747355 UTC

[section ""cstring" . lvl3_rfXP4_bytes" {
     lvl3_rfXP4_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.208727032 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum11_closure" {
     Data.Functor.Sum.$fFoldableSum11_closure:
         const Data.Functor.Sum.$fFoldableSum11_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum11_entry() //  [R1]
         { info_tbl: [(cg2Ud,
                       label: Data.Functor.Sum.$fFoldableSum11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Ud: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg2Ue; else goto cg2Uf;
       cg2Ue: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2Uf: // global
           (_cg2U8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg2U8::I64 == 0) goto cg2Ua; else goto cg2U9;
       cg2Ua: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg2U9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg2U8::I64;
           I64[Sp - 24] = block_cg2Ub_info;
           R2 = lvl3_rfXP4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg2Ub() //  [R1]
         { info_tbl: [(cg2Ub,
                       label: block_cg2Ub_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Ub: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.216024758 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure" {
     Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure:
         const Data.Functor.Sum.$fFoldableSum_$cfoldr1_info;
         const 0;
 },
 sat_sg1N9_entry() //  [R1]
         { info_tbl: [(cg2UP,
                       label: sat_sg1N9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2UP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg2UQ; else goto cg2UR;
       cg2UQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2UR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg2UI_info;
           _sg1N3::P64 = P64[R1 + 16];
           _sg1N5::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sg1N3::P64;
           P64[Sp - 24] = _sg1N5::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug2UY; else goto cg2UJ;
       ug2UY: // global
           call _cg2UI(R1) args: 0, res: 0, upd: 0;
       cg2UJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg2UI() //  [R1]
         { info_tbl: [(cg2UI,
                       label: block_cg2UI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2UI: // global
           _sg1N5::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg2UM; else goto cg2UN;
       cg2UM: // global
           R1 = _sg1N5::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cg2UN: // global
           R3 = P64[R1 + 6];
           R2 = _sg1N5::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Na_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2V0,
                       label: sat_sg1Na_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2V0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg2V4; else goto cg2V3;
       cg2V4: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2V3: // global
           _sg1N3::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sg1N9_info;
           P64[Hp - 32] = _sg1N3::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_$cfoldr1_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cg2Vb,
                       label: Data.Functor.Sum.$fFoldableSum_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Vb: // global
           _sg1N4::P64 = R5;
           _sg1N3::P64 = R4;
           _sg1N2::P64 = R3;
           _sg1N1::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cg2Vc; else goto cg2Vd;
       cg2Vd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg2Vf; else goto cg2Ve;
       cg2Vf: // global
           HpAlloc = 16;
           goto cg2Vc;
       cg2Vc: // global
           R5 = _sg1N4::P64;
           R4 = _sg1N3::P64;
           R3 = _sg1N2::P64;
           R2 = _sg1N1::P64;
           R1 = Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2Ve: // global
           I64[Hp - 8] = sat_sg1Na_info;
           P64[Hp] = _sg1N3::P64;
           I64[Sp - 8] = block_cg2V5_info;
           R6 = _sg1N4::P64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = Hp - 6;
           R3 = _sg1N2::P64;
           R2 = _sg1N1::P64;
           Sp = Sp - 8;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg2V5() //  [R1]
         { info_tbl: [(cg2V5,
                       label: block_cg2V5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2V5: // global
           if (R1 & 7 == 1) goto cg2V8; else goto cg2V9;
       cg2V8: // global
           R1 = Data.Functor.Sum.$fFoldableSum11_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg2V9: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.228604563 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum8_closure" {
     Data.Functor.Sum.$fFoldableSum8_closure:
         const Data.Functor.Sum.$fFoldableSum8_info;
 },
 Data.Functor.Sum.$fFoldableSum8_entry() //  []
         { info_tbl: [(cg2VW,
                       label: Data.Functor.Sum.$fFoldableSum8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2VW: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.232027473 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$cnull_closure" {
     Data.Functor.Sum.$fFoldableSum_$cnull_closure:
         const Data.Functor.Sum.$fFoldableSum_$cnull_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$cnull_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2W9,
                       label: Data.Functor.Sum.$fFoldableSum_$cnull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2W9: // global
           R6 = R4;
           R5 = GHC.Types.True_closure+2;
           R4 = Data.Functor.Sum.$fFoldableSum8_closure+2;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.236305459 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum1_closure" {
     Data.Functor.Sum.$fFoldableSum1_closure:
         const Data.Functor.Sum.$fFoldableSum1_info;
         const 0;
 },
 $dMonoid_sg1Nl_entry() //  [R1]
         { info_tbl: [(cg2Wp,
                       label: $dMonoid_sg1Nl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Wp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2Wq; else goto cg2Wr;
       cg2Wq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2Wr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Nq_entry() //  [R1, R2]
         { info_tbl: [(cg2WE,
                       label: sat_sg1Nq_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2WE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg2WF; else goto cg2WG;
       cg2WF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg2WG: // global
           I64[Sp - 32] = block_cg2Wx_info;
           _sg1Ni::P64 = P64[R1 + 7];
           _sg1Nj::P64 = P64[R1 + 15];
           _sg1Nl::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sg1Ni::P64;
           P64[Sp - 16] = _sg1Nj::P64;
           P64[Sp - 8] = _sg1Nl::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug2WN; else goto cg2Wy;
       ug2WN: // global
           call _cg2Wx(R1) args: 0, res: 0, upd: 0;
       cg2Wy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2Wx() //  [R1]
         { info_tbl: [(cg2Wx,
                       label: block_cg2Wx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Wx: // global
           _sg1Nl::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg2WB; else goto cg2WC;
       cg2WB: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sg1Nl::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 7];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg2WC: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sg1Nl::P64;
           P64[Sp + 16] = Data.Functor.Sum.$fFoldableSum2_closure+1;
           P64[Sp + 24] = P64[R1 + 6];
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum1_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2WO,
                       label: Data.Functor.Sum.$fFoldableSum1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2WO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg2WS; else goto cg2WR;
       cg2WS: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2WR: // global
           I64[Hp - 48] = $dMonoid_sg1Nl_info;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sg1Nq_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.247135187 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_$ctoList_closure" {
     Data.Functor.Sum.$fFoldableSum_$ctoList_closure:
         const Data.Functor.Sum.$fFoldableSum_$ctoList_info;
         const 0;
 },
 Data.Functor.Sum.$fFoldableSum_$ctoList_entry() //  [R2, R3, R4]
         { info_tbl: [(cg2Xr,
                       label: Data.Functor.Sum.$fFoldableSum_$ctoList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Xr: // global
           R6 = R4;
           R5 = GHC.Types.[]_closure+1;
           R4 = GHC.Types.:_closure+2;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.253346688 UTC

[section ""data" . Data.Functor.Sum.$fFoldableSum_closure" {
     Data.Functor.Sum.$fFoldableSum_closure:
         const Data.Functor.Sum.$fFoldableSum_info;
         const 0;
 },
 sat_sg1NL_entry() //  [R1, R2]
         { info_tbl: [(cg2XJ,
                       label: sat_sg1NL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2XJ: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1NK_entry() //  [R1, R2]
         { info_tbl: [(cg2XR,
                       label: sat_sg1NK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2XR: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum3_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1NJ_entry() //  [R1, R2]
         { info_tbl: [(cg2XZ,
                       label: sat_sg1NJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2XZ: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$cminimum_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1NI_entry() //  [R1, R2]
         { info_tbl: [(cg2Y7,
                       label: sat_sg1NI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Y7: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$cmaximum_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1NH_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2Yf,
                       label: sat_sg1NH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Yf: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$celem_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1NG_entry() //  [R1, R2]
         { info_tbl: [(cg2Yn,
                       label: sat_sg1NG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Yn: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$clength_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1NF_entry() //  [R1, R2]
         { info_tbl: [(cg2Yv,
                       label: sat_sg1NF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Yv: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$cnull_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1NE_entry() //  [R1, R2]
         { info_tbl: [(cg2YD,
                       label: sat_sg1NE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2YD: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Sum.$fFoldableSum_$ctoList_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1ND_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2YL,
                       label: sat_sg1ND_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2YL: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$cfoldl1_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1NC_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2YT,
                       label: sat_sg1NC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2YT: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$cfoldr1_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1NB_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg2Z1,
                       label: sat_sg1NB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Z1: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldl'_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1NA_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg2Z9,
                       label: sat_sg1NA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Z9: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldl_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Nz_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg2Zh,
                       label: sat_sg1Nz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Zh: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldr'_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Ny_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg2Zp,
                       label: sat_sg1Ny_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Zp: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldr_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Nx_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg2Zx,
                       label: sat_sg1Nx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2Zx: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fFoldableSum_$cfoldMap_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Nw_entry() //  [R1, R2, R3]
         { info_tbl: [(cg2ZF,
                       label: sat_sg1Nw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2ZF: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fFoldableSum_$cfold_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fFoldableSum_entry() //  [R2, R3]
         { info_tbl: [(cg2ZJ,
                       label: Data.Functor.Sum.$fFoldableSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2ZJ: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cg2ZN; else goto cg2ZM;
       cg2ZN: // global
           HpAlloc = 520;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fFoldableSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg2ZM: // global
           I64[Hp - 512] = sat_sg1NL_info;
           P64[Hp - 504] = R2;
           P64[Hp - 496] = R3;
           I64[Hp - 488] = sat_sg1NK_info;
           P64[Hp - 480] = R2;
           P64[Hp - 472] = R3;
           I64[Hp - 464] = sat_sg1NJ_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           I64[Hp - 440] = sat_sg1NI_info;
           P64[Hp - 432] = R2;
           P64[Hp - 424] = R3;
           I64[Hp - 416] = sat_sg1NH_info;
           P64[Hp - 408] = R2;
           P64[Hp - 400] = R3;
           I64[Hp - 392] = sat_sg1NG_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           I64[Hp - 368] = sat_sg1NF_info;
           P64[Hp - 360] = R2;
           P64[Hp - 352] = R3;
           I64[Hp - 344] = sat_sg1NE_info;
           P64[Hp - 336] = R2;
           P64[Hp - 328] = R3;
           I64[Hp - 320] = sat_sg1ND_info;
           P64[Hp - 312] = R2;
           P64[Hp - 304] = R3;
           I64[Hp - 296] = sat_sg1NC_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           I64[Hp - 272] = sat_sg1NB_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_sg1NA_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_sg1Nz_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_sg1Ny_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sg1Nx_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sg1Nw_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = Data.Foldable.C:Foldable_con_info;
           P64[Hp - 120] = Hp - 150;
           P64[Hp - 112] = Hp - 173;
           P64[Hp - 104] = Hp - 197;
           P64[Hp - 96] = Hp - 221;
           P64[Hp - 88] = Hp - 245;
           P64[Hp - 80] = Hp - 269;
           P64[Hp - 72] = Hp - 294;
           P64[Hp - 64] = Hp - 318;
           P64[Hp - 56] = Hp - 343;
           P64[Hp - 48] = Hp - 367;
           P64[Hp - 40] = Hp - 391;
           P64[Hp - 32] = Hp - 414;
           P64[Hp - 24] = Hp - 439;
           P64[Hp - 16] = Hp - 463;
           P64[Hp - 8] = Hp - 487;
           P64[Hp] = Hp - 511;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.286456696 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$ctraverse_closure" {
     Data.Functor.Sum.$fTraversableSum_$ctraverse_closure:
         const Data.Functor.Sum.$fTraversableSum_$ctraverse_info;
 },
 sat_sg1NU_entry() //  [R1]
         { info_tbl: [(cg31p,
                       label: sat_sg1NU_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg31p: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg31q; else goto cg31r;
       cg31q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg31r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg1NX_entry() //  [R1]
         { info_tbl: [(cg31y,
                       label: sat_sg1NX_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg31y: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg31z; else goto cg31A;
       cg31z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg31A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cg31F,
                       label: Data.Functor.Sum.$fTraversableSum_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg31F: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg31G; else goto cg31H;
       cg31G: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg31H: // global
           I64[Sp - 40] = block_cg31g_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug31Y; else goto cg31h;
       ug31Y: // global
           call _cg31g(R1) args: 0, res: 0, upd: 0;
       cg31h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg31g() //  [R1]
         { info_tbl: [(cg31g,
                       label: block_cg31g_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg31g: // global
           _sg1NO::P64 = P64[Sp + 24];
           _sg1NP::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg31C; else goto cg31D;
       cg31C: // global
           Hp = Hp + 48;
           _sg1NR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg31T; else goto cg31K;
       cg31K: // global
           _sg1NS::P64 = P64[_sg1NR::P64 + 7];
           I64[Hp - 40] = sat_sg1NU_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sg1NO::P64;
           P64[Hp - 8] = _sg1NP::P64;
           P64[Hp] = _sg1NS::P64;
           I64[Sp + 24] = block_cg31I_info;
           R2 = _sg1NO::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
       cg31D: // global
           Hp = Hp + 48;
           _sg1NR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg31T; else goto cg31S;
       cg31T: // global
           HpAlloc = 48;
           R1 = _sg1NR::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg31S: // global
           _sg1NV::P64 = P64[_sg1NR::P64 + 6];
           I64[Hp - 40] = sat_sg1NX_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sg1NO::P64;
           P64[Hp - 8] = _sg1NP::P64;
           P64[Hp] = _sg1NV::P64;
           I64[Sp + 24] = block_cg31Q_info;
           R2 = _sg1NO::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg31I() //  [R1]
         { info_tbl: [(cg31I,
                       label: block_cg31I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg31I: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Sum.InL_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cg31Q() //  [R1]
         { info_tbl: [(cg31Q,
                       label: block_cg31Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg31Q: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Sum.InR_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.302301043 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure" {
     Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure:
         const Data.Functor.Sum.$fTraversableSum_$cp2Traversable_info;
         const 0;
 },
 sat_sg1O1_entry() //  [R1]
         { info_tbl: [(cg32T,
                       label: sat_sg1O1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg32T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg32U; else goto cg32V;
       cg32U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg32V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1O0_entry() //  [R1]
         { info_tbl: [(cg330,
                       label: sat_sg1O0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg330: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg331; else goto cg332;
       cg331: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg332: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cg333,
                       label: Data.Functor.Sum.$fTraversableSum_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg333: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg337; else goto cg336;
       cg337: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg336: // global
           I64[Hp - 40] = sat_sg1O1_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg1O0_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Sum.$fFoldableSum_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.310290352 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$cp1Traversable_closure" {
     Data.Functor.Sum.$fTraversableSum_$cp1Traversable_closure:
         const Data.Functor.Sum.$fTraversableSum_$cp1Traversable_info;
 },
 sat_sg1O5_entry() //  [R1]
         { info_tbl: [(cg33w,
                       label: sat_sg1O5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg33w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg33x; else goto cg33y;
       cg33x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg33y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1O4_entry() //  [R1]
         { info_tbl: [(cg33D,
                       label: sat_sg1O4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg33D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg33E; else goto cg33F;
       cg33E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg33F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cg33G,
                       label: Data.Functor.Sum.$fTraversableSum_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg33G: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg33K; else goto cg33J;
       cg33K: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg33J: // global
           I64[Hp - 40] = sat_sg1O5_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg1O4_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Sum.$fFunctorSum_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.317578002 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$csequenceA_closure" {
     Data.Functor.Sum.$fTraversableSum_$csequenceA_closure:
         const Data.Functor.Sum.$fTraversableSum_$csequenceA_info;
 },
 Data.Functor.Sum.$fTraversableSum_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cg345,
                       label: Data.Functor.Sum.$fTraversableSum_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg345: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.321797793 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$cmapM_closure" {
     Data.Functor.Sum.$fTraversableSum_$cmapM_closure:
         const Data.Functor.Sum.$fTraversableSum_$cmapM_info;
 },
 Data.Functor.Sum.$fTraversableSum_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cg34j,
                       label: Data.Functor.Sum.$fTraversableSum_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg34j: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg34k; else goto cg34l;
       cg34k: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg34l: // global
           I64[Sp - 40] = block_cg34h_info;
           _sg1O9::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sg1O9::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg34h() //  [R1]
         { info_tbl: [(cg34h,
                       label: block_cg34h_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg34h: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.327539123 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_$csequence_closure" {
     Data.Functor.Sum.$fTraversableSum_$csequence_closure:
         const Data.Functor.Sum.$fTraversableSum_$csequence_info;
 },
 Data.Functor.Sum.$fTraversableSum_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cg34E,
                       label: Data.Functor.Sum.$fTraversableSum_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg34E: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg34F; else goto cg34G;
       cg34F: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg34G: // global
           I64[Sp - 32] = block_cg34C_info;
           _sg1Of::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sg1Of::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg34C() //  [R1]
         { info_tbl: [(cg34C,
                       label: block_cg34C_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg34C: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.33439484 UTC

[section ""data" . Data.Functor.Sum.$fTraversableSum_closure" {
     Data.Functor.Sum.$fTraversableSum_closure:
         const Data.Functor.Sum.$fTraversableSum_info;
         const 0;
 },
 sat_sg1Or_entry() //  [R1, R2, R3]
         { info_tbl: [(cg353,
                       label: sat_sg1Or_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg353: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fTraversableSum_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Oq_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg35b,
                       label: sat_sg1Oq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg35b: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fTraversableSum_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Op_entry() //  [R1, R2, R3]
         { info_tbl: [(cg35j,
                       label: sat_sg1Op_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg35j: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Sum.$fTraversableSum_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1Oo_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg35r,
                       label: sat_sg1Oo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg35r: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$fTraversableSum_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1On_entry() //  [R1]
         { info_tbl: [(cg35y,
                       label: sat_sg1On_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg35y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg35z; else goto cg35A;
       cg35z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg35A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fTraversableSum_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Om_entry() //  [R1]
         { info_tbl: [(cg35F,
                       label: sat_sg1Om_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg35F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg35G; else goto cg35H;
       cg35G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg35H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$fTraversableSum_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fTraversableSum_entry() //  [R2, R3]
         { info_tbl: [(cg35J,
                       label: Data.Functor.Sum.$fTraversableSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg35J: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cg35N; else goto cg35M;
       cg35N: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fTraversableSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg35M: // global
           I64[Hp - 208] = sat_sg1Or_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sg1Oq_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sg1Op_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sg1Oo_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sg1On_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sg1Om_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.349485568 UTC

[section ""data" . Data.Functor.Sum.$fGeneric1Sum_$cto1_closure" {
     Data.Functor.Sum.$fGeneric1Sum_$cto1_closure:
         const Data.Functor.Sum.$fGeneric1Sum_$cto1_info;
 },
 Data.Functor.Sum.$fGeneric1Sum_$cto1_entry() //  [R2]
         { info_tbl: [(cg36C,
                       label: Data.Functor.Sum.$fGeneric1Sum_$cto1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg36C: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg36D; else goto cg36E;
       cg36D: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGeneric1Sum_$cto1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg36E: // global
           I64[Sp - 8] = block_cg36w_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg36w() //  [R1]
         { info_tbl: [(cg36w,
                       label: block_cg36w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg36w: // global
           if (R1 & 7 == 1) goto cg36z; else goto cg36A;
       cg36z: // global
           Hp = Hp + 16;
           _sg1Ot::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg36Q; else goto cg36J;
       cg36J: // global
           _sg1Ou::P64 = P64[_sg1Ot::P64 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = _sg1Ou::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg36A: // global
           Hp = Hp + 16;
           _sg1Ot::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg36Q; else goto cg36P;
       cg36Q: // global
           HpAlloc = 16;
           R1 = _sg1Ot::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg36P: // global
           _sg1Ov::P64 = P64[_sg1Ot::P64 + 6];
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = _sg1Ov::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.356229918 UTC

[section ""data" . Data.Functor.Sum.$fGeneric1Sum1_closure" {
     Data.Functor.Sum.$fGeneric1Sum1_closure:
         const Data.Functor.Sum.$fGeneric1Sum1_info;
 },
 Data.Functor.Sum.$fGeneric1Sum1_entry() //  [R2]
         { info_tbl: [(cg37h,
                       label: Data.Functor.Sum.$fGeneric1Sum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg37h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg37i; else goto cg37j;
       cg37i: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGeneric1Sum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg37j: // global
           I64[Sp - 8] = block_cg37a_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug37w; else goto cg37b;
       ug37w: // global
           call _cg37a(R1) args: 0, res: 0, upd: 0;
       cg37b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg37a() //  [R1]
         { info_tbl: [(cg37a,
                       label: block_cg37a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg37a: // global
           if (R1 & 7 == 1) goto cg37e; else goto cg37f;
       cg37e: // global
           Hp = Hp + 16;
           _sg1Ox::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg37v; else goto cg37o;
       cg37o: // global
           _sg1Oy::P64 = P64[_sg1Ox::P64 + 7];
           I64[Hp - 8] = GHC.Generics.L1_con_info;
           P64[Hp] = _sg1Oy::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg37f: // global
           Hp = Hp + 16;
           _sg1Ox::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg37v; else goto cg37u;
       cg37v: // global
           HpAlloc = 16;
           R1 = _sg1Ox::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg37u: // global
           _sg1Oz::P64 = P64[_sg1Ox::P64 + 6];
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = _sg1Oz::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.362374556 UTC

[section ""data" . Data.Functor.Sum.$fGeneric1Sum_closure" {
     Data.Functor.Sum.$fGeneric1Sum_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Sum.$fGeneric1Sum1_closure+1;
         const Data.Functor.Sum.$fGeneric1Sum_$cto1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.364607826 UTC

[section ""data" . Data.Functor.Sum.$fGenericSum_$cto_closure" {
     Data.Functor.Sum.$fGenericSum_$cto_closure:
         const Data.Functor.Sum.$fGenericSum_$cto_info;
 },
 Data.Functor.Sum.$fGenericSum_$cto_entry() //  [R2]
         { info_tbl: [(cg37Y,
                       label: Data.Functor.Sum.$fGenericSum_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg37Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg37Z; else goto cg380;
       cg37Z: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGenericSum_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg380: // global
           I64[Sp - 8] = block_cg37S_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg37S() //  [R1]
         { info_tbl: [(cg37S,
                       label: block_cg37S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg37S: // global
           if (R1 & 7 == 1) goto cg37V; else goto cg37W;
       cg37V: // global
           Hp = Hp + 16;
           _sg1OB::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg38c; else goto cg385;
       cg385: // global
           _sg1OC::P64 = P64[_sg1OB::P64 + 7];
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = _sg1OC::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg37W: // global
           Hp = Hp + 16;
           _sg1OB::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg38c; else goto cg38b;
       cg38c: // global
           HpAlloc = 16;
           R1 = _sg1OB::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg38b: // global
           _sg1OD::P64 = P64[_sg1OB::P64 + 6];
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = _sg1OD::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.37198709 UTC

[section ""data" . Data.Functor.Sum.$fGenericSum1_closure" {
     Data.Functor.Sum.$fGenericSum1_closure:
         const Data.Functor.Sum.$fGenericSum1_info;
 },
 Data.Functor.Sum.$fGenericSum1_entry() //  [R2]
         { info_tbl: [(cg38D,
                       label: Data.Functor.Sum.$fGenericSum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg38D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg38E; else goto cg38F;
       cg38E: // global
           R2 = R2;
           R1 = Data.Functor.Sum.$fGenericSum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg38F: // global
           I64[Sp - 8] = block_cg38w_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug38S; else goto cg38x;
       ug38S: // global
           call _cg38w(R1) args: 0, res: 0, upd: 0;
       cg38x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg38w() //  [R1]
         { info_tbl: [(cg38w,
                       label: block_cg38w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg38w: // global
           if (R1 & 7 == 1) goto cg38A; else goto cg38B;
       cg38A: // global
           Hp = Hp + 16;
           _sg1OF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg38R; else goto cg38K;
       cg38K: // global
           _sg1OG::P64 = P64[_sg1OF::P64 + 7];
           I64[Hp - 8] = GHC.Generics.L1_con_info;
           P64[Hp] = _sg1OG::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg38B: // global
           Hp = Hp + 16;
           _sg1OF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg38R; else goto cg38Q;
       cg38R: // global
           HpAlloc = 16;
           R1 = _sg1OF::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg38Q: // global
           _sg1OH::P64 = P64[_sg1OF::P64 + 6];
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = _sg1OH::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.378077085 UTC

[section ""data" . Data.Functor.Sum.$fGenericSum_closure" {
     Data.Functor.Sum.$fGenericSum_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Sum.$fGenericSum1_closure+1;
         const Data.Functor.Sum.$fGenericSum_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.380689668 UTC

[section ""data" . Data.Functor.Sum.$w$cgunfold_closure" {
     Data.Functor.Sum.$w$cgunfold_closure:
         const Data.Functor.Sum.$w$cgunfold_info;
         const 0;
 },
 sat_sg1OX_entry() //  [R1]
         { info_tbl: [(cg39v,
                       label: sat_sg1OX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg39v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg39w; else goto cg39x;
       cg39w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg39x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InR_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1OY_entry() //  [R1]
         { info_tbl: [(cg39D,
                       label: sat_sg1OY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg39D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg39E; else goto cg39F;
       cg39E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg39F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InL_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgunfold_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg39K,
                       label: Data.Functor.Sum.$w$cgunfold_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg39K: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg39L; else goto cg39M;
       cg39L: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$w$cgunfold_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg39M: // global
           I64[Sp - 40] = block_cg39e_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug3a4; else goto cg39f;
       ug3a4: // global
           call _cg39e(R1) args: 0, res: 0, upd: 0;
       cg39f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg39e() //  [R1]
         { info_tbl: [(cg39e,
                       label: block_cg39e_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg39e: // global
           if (R1 & 7 == 1) goto cg39I; else goto cg39H;
       cg39I: // global
           I64[Sp] = block_cg39k_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto ug3a3; else goto cg39l;
       ug3a3: // global
           call _cg39k(R1) args: 0, res: 0, upd: 0;
       cg39l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg39H: // global
           _sg1ON::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cg39O_info;
           R1 = _sg1ON::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ug3a2; else goto cg39Q;
       ug3a2: // global
           call _cg39O(R1) args: 0, res: 0, upd: 0;
       cg39Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg39k() //  [R1]
         { info_tbl: [(cg39k,
                       label: block_cg39k_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg39k: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg39Y; else goto cg39X;
       cg39Y: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg39X: // global
           _sg1OK::P64 = P64[Sp + 24];
           _sg1OL::P64 = P64[Sp + 32];
           if (I64[R1 + 7] == 1) goto cg3a1; else goto cg3a0;
       cg3a1: // global
           I64[Hp - 16] = sat_sg1OY_info;
           P64[Hp] = _sg1OL::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 8];
           R1 = _sg1OK::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3a0: // global
           I64[Hp - 16] = sat_sg1OX_info;
           P64[Hp] = _sg1OL::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _sg1OK::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg39O() //  [R1]
         { info_tbl: [(cg39O,
                       label: block_cg39O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg39O: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Data.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.394980942 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgunfold_closure" {
     Data.Functor.Sum.$fDataSum_$cgunfold_closure:
         const Data.Functor.Sum.$fDataSum_$cgunfold_info;
         const 0;
 },
 Data.Functor.Sum.$fDataSum_$cgunfold_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3aE: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgunfold_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgunfold_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cg3aL,
                       label: Data.Functor.Sum.$fDataSum_$cgunfold_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3aL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg3aM; else goto cg3aN;
       cg3aM: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgunfold_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cg3aN: // global
           I64[Sp - 8] = block_cg3aI_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3aR; else goto cg3aJ;
       ug3aR: // global
           call _cg3aI(R1) args: 0, res: 0, upd: 0;
       cg3aJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3aI() //  [R1]
         { info_tbl: [(cg3aI,
                       label: block_cg3aI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3aI: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 39];
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgunfold_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.403181884 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgfoldl_closure" {
     Data.Functor.Sum.$fDataSum_$cgfoldl_closure:
         const Data.Functor.Sum.$fDataSum_$cgfoldl_info;
 },
 Data.Functor.Sum.$fDataSum_$cgfoldl_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3b6: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgfoldl_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg1Pp_entry() //  [R1]
         { info_tbl: [(cg3bj,
                       label: sat_sg1Pp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3bj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg3bk; else goto cg3bl;
       cg3bk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3bl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InL_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Pr_entry() //  [R1]
         { info_tbl: [(cg3bs,
                       label: sat_sg1Pr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3bs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg3bt; else goto cg3bu;
       cg3bt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3bu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Sum.InR_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgfoldl_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg3bz,
                       label: Data.Functor.Sum.$fDataSum_$cgfoldl_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3bz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg3bA; else goto cg3bB;
       cg3bA: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgfoldl_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cg3bB: // global
           I64[Sp - 8] = block_cg3ba_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3bI; else goto cg3bb;
       ug3bI: // global
           call _cg3ba(R1) args: 0, res: 0, upd: 0;
       cg3bb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3ba() //  [R1]
         { info_tbl: [(cg3ba,
                       label: block_cg3ba_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3ba: // global
           _sg1Pk::P64 = P64[Sp + 16];
           _sg1Pl::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cg3bw; else goto cg3bx;
       cg3bw: // global
           Hp = Hp + 24;
           _sg1Pn::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3bH; else goto cg3bD;
       cg3bD: // global
           _sg1Po::P64 = P64[_sg1Pn::P64 + 7];
           I64[Hp - 16] = sat_sg1Pp_info;
           P64[Hp] = _sg1Pl::P64;
           R4 = _sg1Po::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 32];
           R1 = _sg1Pk::P64;
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3bx: // global
           Hp = Hp + 24;
           _sg1Pn::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3bH; else goto cg3bG;
       cg3bH: // global
           HpAlloc = 24;
           R1 = _sg1Pn::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg3bG: // global
           _sg1Pq::P64 = P64[_sg1Pn::P64 + 6];
           I64[Hp - 16] = sat_sg1Pr_info;
           P64[Hp] = _sg1Pl::P64;
           R4 = _sg1Pq::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 8];
           R1 = _sg1Pk::P64;
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.415111201 UTC

[section ""cstring" . Data.Functor.Sum.$fDataSum8_bytes" {
     Data.Functor.Sum.$fDataSum8_bytes:
         I8[] [83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.417119453 UTC

[section ""data" . $tSum1_rfXP5_closure" {
     $tSum1_rfXP5_closure:
         const $tSum1_rfXP5_info;
         const 0;
         const 0;
         const 0;
 },
 $tSum1_rfXP5_entry() //  [R1]
         { info_tbl: [(cg3cg,
                       label: $tSum1_rfXP5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3cg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg3ch; else goto cg3ci;
       cg3ch: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3ci: // global
           (_cg3cd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg3cd::I64 == 0) goto cg3cf; else goto cg3ce;
       cg3cf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg3ce: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg3cd::I64;
           R2 = Data.Functor.Sum.$fDataSum8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.422260126 UTC

[section ""data" . go61_rfXP6_closure" {
     go61_rfXP6_closure:
         const go61_rfXP6_info;
         const 0;
 },
 go61_rfXP6_entry() //  [R2, R3]
         { info_tbl: [(cg3cC,
                       label: go61_rfXP6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3cC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3cD; else goto ug3dg;
       cg3cD: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rfXP6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ug3dg: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cg3cs() args: 0, res: 0, upd: 0;
     }
 },
 _cg3cs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3cs: // global
           _sg1Ps::P64 = P64[Sp];
           I64[Sp] = block_cg3cv_info;
           R1 = _sg1Ps::P64;
           if (R1 & 7 != 0) goto ug3dk; else goto cg3cw;
       ug3dk: // global
           call _cg3cv(R1) args: 0, res: 0, upd: 0;
       cg3cw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3cv() //  [R1]
         { info_tbl: [(cg3cv,
                       label: block_cg3cv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3cv: // global
           if (R1 & 7 == 1) goto ug3dh; else goto cg3cA;
       ug3dh: // global
           Sp = Sp + 16;
           call _cg3cS() args: 0, res: 0, upd: 0;
       cg3cA: // global
           I64[Sp - 8] = block_cg3cK_info;
           _sg1Pv::P64 = P64[R1 + 6];
           _sg1Pw::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sg1Pw::P64;
           P64[Sp + 8] = _sg1Pv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3dl; else goto cg3cM;
       ug3dl: // global
           call _cg3cK(R1) args: 0, res: 0, upd: 0;
       cg3cM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3cK() //  [R1]
         { info_tbl: [(cg3cK,
                       label: block_cg3cK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3cK: // global
           if (R1 & 7 == 1) goto ug3di; else goto cg3cX;
       ug3di: // global
           Sp = Sp + 24;
           call _cg3cS() args: 0, res: 0, upd: 0;
       cg3cX: // global
           I64[Sp - 8] = block_cg3cV_info;
           _sg1Py::P64 = P64[R1 + 6];
           _sg1Pz::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sg1Pz::P64;
           P64[Sp + 16] = _sg1Py::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3do; else goto cg3cY;
       ug3do: // global
           call _cg3cV(R1) args: 0, res: 0, upd: 0;
       cg3cY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3cS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3cS: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg3cV() //  [R1]
         { info_tbl: [(cg3cV,
                       label: block_cg3cV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3cV: // global
           I64[Sp] = block_cg3d2_info;
           R3 = Data.Functor.Sum.$fRead1Sum7_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg3d2() //  [R1]
         { info_tbl: [(cg3d2,
                       label: block_cg3d2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3d2: // global
           if (R1 & 7 == 1) goto cg3d9; else goto cg3dd;
       cg3d9: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cg3cs() args: 0, res: 0, upd: 0;
       cg3dd: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.436437275 UTC

[section ""data" . go1_rfXP7_closure" {
     go1_rfXP7_closure:
         const go1_rfXP7_info;
         const 0;
 },
 section ""relreadonly" . ug3f3_srtd" {
     ug3f3_srtd:
         const Sg21L_srt+88;
         const 51;
         const 1266637395197953;
 },
 go1_rfXP7_entry() //  [R2, R3]
         { info_tbl: [(cg3ee,
                       label: go1_rfXP7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3ee: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3ef; else goto ug3eS;
       cg3ef: // global
           R3 = R3;
           R2 = R2;
           R1 = go1_rfXP7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ug3eS: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cg3e4() args: 0, res: 0, upd: 0;
     }
 },
 _cg3e4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3e4: // global
           _sg1PH::P64 = P64[Sp];
           I64[Sp] = block_cg3e7_info;
           R1 = _sg1PH::P64;
           if (R1 & 7 != 0) goto ug3eW; else goto cg3e8;
       ug3eW: // global
           call _cg3e7(R1) args: 0, res: 0, upd: 0;
       cg3e8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ug3f4_srtd" {
     ug3f4_srtd:
         const Sg21L_srt+88;
         const 48;
         const 140737488355329;
 },
 _cg3e7() //  [R1]
         { info_tbl: [(cg3e7,
                       label: block_cg3e7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3e7: // global
           if (R1 & 7 == 1) goto ug3eT; else goto cg3ec;
       ug3eT: // global
           Sp = Sp + 16;
           call _cg3eu() args: 0, res: 0, upd: 0;
       cg3ec: // global
           I64[Sp - 8] = block_cg3em_info;
           _sg1PK::P64 = P64[R1 + 6];
           _sg1PL::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sg1PL::P64;
           P64[Sp + 8] = _sg1PK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3eX; else goto cg3eo;
       ug3eX: // global
           call _cg3em(R1) args: 0, res: 0, upd: 0;
       cg3eo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ug3f5_srtd" {
     ug3f5_srtd:
         const Sg21L_srt+88;
         const 48;
         const 140737488355329;
 },
 _cg3em() //  [R1]
         { info_tbl: [(cg3em,
                       label: block_cg3em_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3em: // global
           if (R1 & 7 == 1) goto ug3eU; else goto cg3ez;
       ug3eU: // global
           Sp = Sp + 24;
           call _cg3eu() args: 0, res: 0, upd: 0;
       cg3ez: // global
           I64[Sp - 8] = block_cg3ex_info;
           _sg1PN::P64 = P64[R1 + 6];
           _sg1PO::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sg1PO::P64;
           P64[Sp + 16] = _sg1PN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3f0; else goto cg3eA;
       ug3f0: // global
           call _cg3ex(R1) args: 0, res: 0, upd: 0;
       cg3eA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3eu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3eu: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ug3f6_srtd" {
     ug3f6_srtd:
         const Sg21L_srt+88;
         const 48;
         const 140737488355329;
 },
 _cg3ex() //  [R1]
         { info_tbl: [(cg3ex,
                       label: block_cg3ex_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3ex: // global
           I64[Sp] = block_cg3eE_info;
           R3 = Data.Functor.Sum.$fRead1Sum3_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ug3f7_srtd" {
     ug3f7_srtd:
         const Sg21L_srt+88;
         const 48;
         const 140737488355329;
 },
 _cg3eE() //  [R1]
         { info_tbl: [(cg3eE,
                       label: block_cg3eE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3eE: // global
           if (R1 & 7 == 1) goto cg3eL; else goto cg3eP;
       cg3eL: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cg3e4() args: 0, res: 0, upd: 0;
       cg3eP: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.454133763 UTC

[section ""data" . $cInL1_rfXP8_closure" {
     $cInL1_rfXP8_closure:
         const Data.Data.AlgConstr_con_info;
         const $cInL2_rfXPe_closure;
         const 0;
 },
 section ""data" . $cInR1_rfXP9_closure" {
     $cInR1_rfXP9_closure:
         const Data.Data.AlgConstr_con_info;
         const $cInR2_rfXPd_closure;
         const 0;
 },
 section ""data" . Data.Functor.Sum.$cInL_closure" {
     Data.Functor.Sum.$cInL_closure:
         const Data.Data.Constr_con_info;
         const $cInL1_rfXP8_closure+1;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Sum.$tSum_closure+1;
         const 0;
 },
 section ""data" . $tSum2_rfXPa_closure" {
     $tSum2_rfXPa_closure:
         const :_con_info;
         const Data.Functor.Sum.$cInR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . $tSum3_rfXPb_closure" {
     $tSum3_rfXPb_closure:
         const :_con_info;
         const Data.Functor.Sum.$cInL_closure+1;
         const $tSum2_rfXPa_closure+2;
         const 0;
 },
 section ""data" . $tSum4_rfXPc_closure" {
     $tSum4_rfXPc_closure:
         const Data.Data.AlgRep_con_info;
         const $tSum3_rfXPb_closure+2;
         const 0;
 },
 section ""data" . Data.Functor.Sum.$tSum_closure" {
     Data.Functor.Sum.$tSum_closure:
         const Data.Data.DataType_con_info;
         const $tSum1_rfXP5_closure;
         const $tSum4_rfXPc_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Sum.$cInR_closure" {
     Data.Functor.Sum.$cInR_closure:
         const Data.Data.Constr_con_info;
         const $cInR1_rfXP9_closure+1;
         const Data.Functor.Sum.$fRead1Sum3_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Sum.$tSum_closure+1;
         const 0;
 },
 section ""data" . $cInR2_rfXPd_closure" {
     $cInR2_rfXPd_closure:
         const $cInR2_rfXPd_info;
         const 0;
         const 0;
         const 0;
 },
 $cInR2_rfXPd_entry() //  [R1]
         { info_tbl: [(cg3fV,
                       label: $cInR2_rfXPd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3fV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg3fW; else goto cg3fX;
       cg3fW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3fX: // global
           (_cg3fS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg3fS::I64 == 0) goto cg3fU; else goto cg3fT;
       cg3fU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg3fT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg3fS::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = $tSum3_rfXPb_closure+2;
           Sp = Sp - 16;
           call go1_rfXP7_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""data" . $cInL2_rfXPe_closure" {
     $cInL2_rfXPe_closure:
         const $cInL2_rfXPe_info;
         const 0;
         const 0;
         const 0;
 },
 $cInL2_rfXPe_entry() //  [R1]
         { info_tbl: [(cg3g4,
                       label: $cInL2_rfXPe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3g4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg3g5; else goto cg3g6;
       cg3g5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3g6: // global
           (_cg3g1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg3g1::I64 == 0) goto cg3g3; else goto cg3g2;
       cg3g3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg3g2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg3g1::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = $tSum3_rfXPb_closure+2;
           Sp = Sp - 16;
           call go61_rfXP6_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.466734797 UTC

[section ""cstring" . Data.Functor.Sum.$trModule4_bytes" {
     Data.Functor.Sum.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.468465661 UTC

[section ""data" . Data.Functor.Sum.$trModule3_closure" {
     Data.Functor.Sum.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.470426075 UTC

[section ""cstring" . Data.Functor.Sum.$trModule2_bytes" {
     Data.Functor.Sum.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.472030541 UTC

[section ""data" . Data.Functor.Sum.$trModule1_closure" {
     Data.Functor.Sum.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.473886042 UTC

[section ""data" . Data.Functor.Sum.$trModule_closure" {
     Data.Functor.Sum.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Sum.$trModule3_closure+1;
         const Data.Functor.Sum.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.475656675 UTC

[section ""data" . $krep_rfXPf_closure" {
     $krep_rfXPf_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.477342158 UTC

[section ""data" . $krep1_rfXPg_closure" {
     $krep1_rfXPg_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rfXPf_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.479640667 UTC

[section ""data" . $krep2_rfXPh_closure" {
     $krep2_rfXPh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rfXPg_closure+4;
         const $krep1_rfXPg_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.481425251 UTC

[section ""data" . Data.Functor.Sum.$fDataSum6_closure" {
     Data.Functor.Sum.$fDataSum6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rfXPg_closure+4;
         const $krep2_rfXPh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.483228927 UTC

[section ""data" . $krep3_rfXPi_closure" {
     $krep3_rfXPi_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.484883678 UTC

[section ""data" . $krep4_rfXPj_closure" {
     $krep4_rfXPj_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.487786103 UTC

[section ""data" . $krep5_rfXPk_closure" {
     $krep5_rfXPk_closure:
         const GHC.Types.KindRepVar_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.490182714 UTC

[section ""data" . $krep6_rfXPl_closure" {
     $krep6_rfXPl_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rfXPj_closure+2;
         const $krep5_rfXPk_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.492046202 UTC

[section ""data" . $krep7_rfXPm_closure" {
     $krep7_rfXPm_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep3_rfXPi_closure+2;
         const $krep5_rfXPk_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.493958281 UTC

[section ""data" . Data.Functor.Sum.$fDataSum7_closure" {
     Data.Functor.Sum.$fDataSum7_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$fDataSum8_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.495817635 UTC

[section ""data" . Data.Functor.Sum.$tcSum_closure" {
     Data.Functor.Sum.$tcSum_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Sum.$trModule_closure+1;
         const Data.Functor.Sum.$fDataSum7_closure+1;
         const Data.Functor.Sum.$fDataSum6_closure+4;
         const 6345190594862254730;
         const 1236278515871186010;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.497925966 UTC

[section ""data" . $krep8_rfXPn_closure" {
     $krep8_rfXPn_closure:
         const :_con_info;
         const $krep5_rfXPk_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.499854072 UTC

[section ""data" . $krep9_rfXPo_closure" {
     $krep9_rfXPo_closure:
         const :_con_info;
         const $krep3_rfXPi_closure+2;
         const $krep8_rfXPn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.501779024 UTC

[section ""data" . $krep10_rfXPp_closure" {
     $krep10_rfXPp_closure:
         const :_con_info;
         const $krep4_rfXPj_closure+2;
         const $krep9_rfXPo_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.503693789 UTC

[section ""data" . $krep11_rfXPq_closure" {
     $krep11_rfXPq_closure:
         const :_con_info;
         const $krep_rfXPf_closure+2;
         const $krep10_rfXPp_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.506384549 UTC

[section ""data" . $krep12_rfXPr_closure" {
     $krep12_rfXPr_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Sum.$tcSum_closure+1;
         const $krep11_rfXPq_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.508894298 UTC

[section ""data" . Data.Functor.Sum.$tc'InL1_closure" {
     Data.Functor.Sum.$tc'InL1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rfXPl_closure+3;
         const $krep12_rfXPr_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.510819259 UTC

[section ""cstring" . Data.Functor.Sum.$tc'InL3_bytes" {
     Data.Functor.Sum.$tc'InL3_bytes:
         I8[] [39,73,110,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.512726737 UTC

[section ""data" . Data.Functor.Sum.$tc'InL2_closure" {
     Data.Functor.Sum.$tc'InL2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$tc'InL3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.514787575 UTC

[section ""data" . Data.Functor.Sum.$tc'InL_closure" {
     Data.Functor.Sum.$tc'InL_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Sum.$trModule_closure+1;
         const Data.Functor.Sum.$tc'InL2_closure+1;
         const Data.Functor.Sum.$tc'InL1_closure+4;
         const 7951421854502432011;
         const 12303552236073891860;
         const 4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.516840482 UTC

[section ""data" . Data.Functor.Sum.$tc'InR1_closure" {
     Data.Functor.Sum.$tc'InR1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rfXPm_closure+3;
         const $krep12_rfXPr_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.518566123 UTC

[section ""cstring" . Data.Functor.Sum.$tc'InR3_bytes" {
     Data.Functor.Sum.$tc'InR3_bytes:
         I8[] [39,73,110,82]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.520230707 UTC

[section ""data" . Data.Functor.Sum.$tc'InR2_closure" {
     Data.Functor.Sum.$tc'InR2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Sum.$tc'InR3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.522383708 UTC

[section ""data" . Data.Functor.Sum.$tc'InR_closure" {
     Data.Functor.Sum.$tc'InR_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Sum.$trModule_closure+1;
         const Data.Functor.Sum.$tc'InR2_closure+1;
         const Data.Functor.Sum.$tc'InR1_closure+4;
         const 12078304815884238110;
         const 12377490770432979855;
         const 4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.524973185 UTC

[section ""data" . Data.Functor.Sum.$w$cp1Data_closure" {
     Data.Functor.Sum.$w$cp1Data_closure:
         const Data.Functor.Sum.$w$cp1Data_info;
         const 0;
 },
 Data.Functor.Sum.$w$cp1Data_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg3hb,
                       label: Data.Functor.Sum.$w$cp1Data_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3hb: // global
           _sg1PZ::P64 = R5;
           _sg1PY::P64 = R4;
           _sg1PX::P64 = R3;
           _sg1PW::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cg3hf; else goto cg3hg;
       cg3hg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg3hi; else goto cg3hh;
       cg3hi: // global
           HpAlloc = 40;
           goto cg3hf;
       cg3hf: // global
           R5 = _sg1PZ::P64;
           R4 = _sg1PY::P64;
           R3 = _sg1PX::P64;
           R2 = _sg1PW::P64;
           R1 = Data.Functor.Sum.$w$cp1Data_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3hh: // global
           I64[Hp - 32] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 24] = _sg1PZ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 32] = block_cg3h4_info;
           R6 = 1;
           R5 = Data.Functor.Sum.$fDataSum7_closure+1;
           R4 = Data.Functor.Sum.$trModule_closure+1;
           R3 = 1236278515871186010;
           R2 = 6345190594862254730;
           P64[Sp - 48] = Data.Functor.Sum.$fDataSum6_closure+4;
           P64[Sp - 40] = Hp - 14;
           P64[Sp - 24] = _sg1PW::P64;
           P64[Sp - 16] = _sg1PX::P64;
           P64[Sp - 8] = _sg1PY::P64;
           Sp = Sp - 48;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 8;
     }
 },
 _cg3h4() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg3h4,
                       label: block_cg3h4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3h4: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cg3h5() args: 0, res: 0, upd: 0;
     }
 },
 _cg3h5() //  []
         { info_tbl: [(cg3h5,
                       label: block_cg3h5_info
                       rep:StackRep [True, False, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3h5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg3hl; else goto cg3hk;
       cg3hl: // global
           HpAlloc = 48;
           I64[Sp] = block_cg3h5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cg3hk: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 40] = block_cg3h9_info;
           R3 = P64[Sp + 56];
           R2 = Hp - 38;
           Sp = Sp + 40;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg3h9() //  [R1]
         { info_tbl: [(cg3h9,
                       label: block_cg3h9_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3h9: // global
           I64[Sp] = block_cg3he_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg3he() //  [R1]
         { info_tbl: [(cg3he,
                       label: block_cg3he_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3he: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.537139938 UTC

[section ""data" . Data.Functor.Sum.$fDataSum5_closure" {
     Data.Functor.Sum.$fDataSum5_closure:
         const Data.Functor.Sum.$fDataSum5_info;
         const 0;
 },
 Data.Functor.Sum.$fDataSum5_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg3i5,
                       label: Data.Functor.Sum.$fDataSum5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3i5: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Sum.$w$cp1Data_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.542131728 UTC

[section ""data" . Data.Functor.Sum.$fDataSum2_closure" {
     Data.Functor.Sum.$fDataSum2_closure:
         const (,)_con_info;
         const Data.Functor.Sum.InL_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.543998897 UTC

[section ""data" . Data.Functor.Sum.$fDataSum1_closure" {
     Data.Functor.Sum.$fDataSum1_closure:
         const (,)_con_info;
         const Data.Functor.Sum.InR_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.548534854 UTC

[section ""data" . Data.Functor.Sum.$w$cgmapMp_closure" {
     Data.Functor.Sum.$w$cgmapMp_closure:
         const Data.Functor.Sum.$w$cgmapMp_info;
 },
 lvl8_sg1Qm_entry() //  [R1]
         { info_tbl: [(cg3im,
                       label: lvl8_sg1Qm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3im: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg3in; else goto cg3io;
       cg3in: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3io: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1QR_entry() //  [R1, R2]
         { info_tbl: [(cg3iB,
                       label: sat_sg1QR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3iB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3iC; else goto cg3iD;
       cg3iC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg3iD: // global
           I64[Sp - 24] = block_cg3iy_info;
           _sg1Qm::P64 = P64[R1 + 7];
           _sg1Qn::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sg1Qm::P64;
           P64[Sp - 8] = _sg1Qn::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug3iV; else goto cg3iz;
       ug3iV: // global
           call _cg3iy(R1) args: 0, res: 0, upd: 0;
       cg3iz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3iy() //  [R1]
         { info_tbl: [(cg3iy,
                       label: block_cg3iy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3iy: // global
           I64[Sp - 8] = block_cg3iG_info;
           _sg1QO::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sg1QO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3iU; else goto cg3iI;
       ug3iU: // global
           call _cg3iG(R1) args: 0, res: 0, upd: 0;
       cg3iI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3iG() //  [R1]
         { info_tbl: [(cg3iG,
                       label: block_cg3iG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3iG: // global
           if (R1 & 7 == 1) goto cg3iO; else goto cg3iS;
       cg3iO: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg3iS: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg1QE_entry() //  [R1]
         { info_tbl: [(cg3jm,
                       label: sat_sg1QE_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3jm: // global
           _sg1QE::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg3jn; else goto cg3jo;
       cg3jo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg3jq; else goto cg3jp;
       cg3jq: // global
           HpAlloc = 56;
           goto cg3jn;
       cg3jn: // global
           R1 = _sg1QE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3jp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg1QE::P64;
           _sg1Qn::P64 = P64[_sg1QE::P64 + 16];
           _sg1Qr::P64 = P64[_sg1QE::P64 + 24];
           _sg1Qv::P64 = P64[_sg1QE::P64 + 32];
           _sg1Qw::P64 = P64[_sg1QE::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg1Qv::P64;
           P64[Hp - 24] = _sg1Qr::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sg1Qw::P64;
           R2 = _sg1Qn::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg1QA_entry() //  [R1, R2]
         { info_tbl: [(cg3jC,
                       label: sat_sg1QA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3jC: // global
           _sg1Qx::P64 = R2;
           _sg1QA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg3jD; else goto cg3jE;
       cg3jE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg3jG; else goto cg3jF;
       cg3jG: // global
           HpAlloc = 56;
           goto cg3jD;
       cg3jD: // global
           R2 = _sg1Qx::P64;
           R1 = _sg1QA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg3jF: // global
           _sg1Qn::P64 = P64[_sg1QA::P64 + 7];
           _sg1Qv::P64 = P64[_sg1QA::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg1Qv::P64;
           P64[Hp - 24] = _sg1Qx::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sg1Qn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg1QB_entry() //  [R1]
         { info_tbl: [(cg3jH,
                       label: sat_sg1QB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3jH: // global
           _sg1QB::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg3jI; else goto cg3jJ;
       cg3jJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg3jL; else goto cg3jK;
       cg3jL: // global
           HpAlloc = 24;
           goto cg3jI;
       cg3jI: // global
           R1 = _sg1QB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3jK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg1QB::P64;
           _sg1Qn::P64 = P64[_sg1QB::P64 + 16];
           _sg1Qs::P64 = P64[_sg1QB::P64 + 24];
           _sg1Qv::P64 = P64[_sg1QB::P64 + 32];
           I64[Hp - 16] = sat_sg1QA_info;
           P64[Hp - 8] = _sg1Qn::P64;
           P64[Hp] = _sg1Qv::P64;
           R2 = _sg1Qn::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg1Qs::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg1QF_entry() //  [R1, R2]
         { info_tbl: [(cg3jM,
                       label: sat_sg1QF_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3jM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg3jN; else goto cg3jO;
       cg3jN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg3jO: // global
           I64[Sp - 40] = block_cg3jb_info;
           _sg1Qj::P64 = P64[R1 + 7];
           _sg1Qn::P64 = P64[R1 + 15];
           _sg1Qr::P64 = P64[R1 + 23];
           _sg1Qs::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg1Qj::P64;
           P64[Sp - 24] = _sg1Qn::P64;
           P64[Sp - 16] = _sg1Qr::P64;
           P64[Sp - 8] = _sg1Qs::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug3jS; else goto cg3jc;
       ug3jS: // global
           call _cg3jb(R1) args: 0, res: 0, upd: 0;
       cg3jc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3jb() //  [R1]
         { info_tbl: [(cg3jb,
                       label: block_cg3jb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3jb: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg3jR; else goto cg3jQ;
       cg3jR: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg3jQ: // global
           _sg1Qv::P64 = P64[R1 + 7];
           _sg1Qw::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sg1QE_info;
           _sg1Qn::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sg1Qn::P64;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _sg1Qv::P64;
           P64[Hp - 40] = _sg1Qw::P64;
           I64[Hp - 32] = sat_sg1QB_info;
           P64[Hp - 16] = _sg1Qn::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sg1Qv::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sg1Qo_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg3jT,
                       label: k1_sg1Qo_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3jT: // global
           _sg1Qr::P64 = R4;
           _sg1Qq::P64 = R3;
           _sg1Qp::P64 = R2;
           _sg1Qo::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg3jU; else goto cg3jV;
       cg3jV: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg3jX; else goto cg3jW;
       cg3jX: // global
           HpAlloc = 80;
           goto cg3jU;
       cg3jU: // global
           R4 = _sg1Qr::P64;
           R3 = _sg1Qq::P64;
           R2 = _sg1Qp::P64;
           R1 = _sg1Qo::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3jW: // global
           _sg1Qj::P64 = P64[_sg1Qo::P64 + 5];
           _sg1Qk::P64 = P64[_sg1Qo::P64 + 13];
           _sg1Qn::P64 = P64[_sg1Qo::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sg1Qk::P64;
           P64[Hp - 48] = _sg1Qp::P64;
           P64[Hp - 40] = _sg1Qr::P64;
           I64[Hp - 32] = sat_sg1QF_info;
           P64[Hp - 24] = _sg1Qj::P64;
           P64[Hp - 16] = _sg1Qn::P64;
           P64[Hp - 8] = _sg1Qr::P64;
           P64[Hp] = Hp - 72;
           R2 = _sg1Qn::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg1Qq::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg1QI_entry() //  [R1]
         { info_tbl: [(cg3k7,
                       label: sat_sg1QI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3k7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3k8; else goto cg3k9;
       cg3k8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3k9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg1QK_entry() //  [R1]
         { info_tbl: [(cg3kg,
                       label: sat_sg1QK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3kg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3kh; else goto cg3ki;
       cg3kh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3ki: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg1QL_entry() //  [R1]
         { info_tbl: [(cg3kn,
                       label: sat_sg1QL_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3kn: // global
           _sg1QL::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cg3ko; else goto cg3kp;
       cg3kp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg3kr; else goto cg3kq;
       cg3kr: // global
           HpAlloc = 32;
           goto cg3ko;
       cg3ko: // global
           R1 = _sg1QL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3kq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg1QL::P64;
           _sg1Qh::P64 = P64[_sg1QL::P64 + 16];
           _sg1Qi::P64 = P64[_sg1QL::P64 + 24];
           _sg1Qj::P64 = P64[_sg1QL::P64 + 32];
           _sg1Qk::P64 = P64[_sg1QL::P64 + 40];
           _sg1Ql::P64 = P64[_sg1QL::P64 + 48];
           _sg1Qn::P64 = P64[_sg1QL::P64 + 56];
           I64[Hp - 24] = k1_sg1Qo_info;
           P64[Hp - 16] = _sg1Qj::P64;
           P64[Hp - 8] = _sg1Qk::P64;
           P64[Hp] = _sg1Qn::P64;
           I64[Sp - 56] = block_cg3jY_info;
           R1 = _sg1Ql::P64;
           P64[Sp - 48] = Hp - 21;
           P64[Sp - 40] = _sg1Qh::P64;
           P64[Sp - 32] = _sg1Qi::P64;
           P64[Sp - 24] = _sg1Qn::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ug3ky; else goto cg3jZ;
       ug3ky: // global
           call _cg3jY(R1) args: 0, res: 0, upd: 0;
       cg3jZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg3jY() //  [R1]
         { info_tbl: [(cg3jY,
                       label: block_cg3jY_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3jY: // global
           _cg3j0::P64 = P64[Sp + 8];
           _sg1Qn::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg3kk; else goto cg3kl;
       cg3kk: // global
           Hp = Hp + 24;
           _sg1QG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3kx; else goto cg3kt;
       cg3kt: // global
           _sg1QH::P64 = P64[_sg1QG::P64 + 7];
           I64[Hp - 16] = sat_sg1QI_info;
           P64[Hp] = _sg1Qn::P64;
           R4 = _sg1QH::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _cg3j0::P64;
           Sp = Sp + 40;
           call k1_sg1Qo_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
       cg3kl: // global
           Hp = Hp + 24;
           _sg1QG::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3kx; else goto cg3kw;
       cg3kx: // global
           HpAlloc = 24;
           R1 = _sg1QG::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg3kw: // global
           _sg1QJ::P64 = P64[_sg1QG::P64 + 6];
           I64[Hp - 16] = sat_sg1QK_info;
           P64[Hp] = _sg1Qn::P64;
           R4 = _sg1QJ::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 24];
           R1 = _cg3j0::P64;
           Sp = Sp + 40;
           call k1_sg1Qo_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgmapMp_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg3kz,
                       label: Data.Functor.Sum.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3kz: // global
           _sg1Ql::P64 = R6;
           _sg1Qk::P64 = R5;
           _sg1Qj::P64 = R4;
           _sg1Qi::P64 = R3;
           _sg1Qh::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg3kA; else goto cg3kB;
       cg3kB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg3kD; else goto cg3kC;
       cg3kD: // global
           HpAlloc = 24;
           goto cg3kA;
       cg3kA: // global
           R6 = _sg1Ql::P64;
           R5 = _sg1Qk::P64;
           R4 = _sg1Qj::P64;
           R3 = _sg1Qi::P64;
           R2 = _sg1Qh::P64;
           R1 = Data.Functor.Sum.$w$cgmapMp_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3kC: // global
           I64[Hp - 16] = lvl8_sg1Qm_info;
           P64[Hp] = _sg1Qj::P64;
           I64[Sp - 56] = block_cg3ip_info;
           R2 = _sg1Qj::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sg1Qh::P64;
           P64[Sp - 32] = _sg1Qi::P64;
           P64[Sp - 24] = _sg1Qj::P64;
           P64[Sp - 16] = _sg1Qk::P64;
           P64[Sp - 8] = _sg1Ql::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg3ip() //  [R1]
         { info_tbl: [(cg3ip,
                       label: block_cg3ip_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3ip: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg3kG; else goto cg3kF;
       cg3kG: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg3kF: // global
           I64[Hp - 80] = sat_sg1QR_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sg1QL_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.588648473 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapMp_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapMp_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapMp_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapMp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3mN: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapMp_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapMp_entry() //  [R6]
         { info_tbl: [(cg3mR,
                       label: Data.Functor.Sum.$fDataSum_$cgmapMp_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3mR: // global
           _sg1QW::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sg1QW::P64;
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgmapMp_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.595734123 UTC

[section ""data" . Data.Functor.Sum.$w$cgmapM_closure" {
     Data.Functor.Sum.$w$cgmapM_closure:
         const Data.Functor.Sum.$w$cgmapM_info;
 },
 sat_sg1Re_entry() //  [R1, R2]
         { info_tbl: [(cg3nl,
                       label: sat_sg1Re_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3nl: // global
           _sg1Rc::P64 = R2;
           _sg1Re::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg3nm; else goto cg3nn;
       cg3nn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg3np; else goto cg3no;
       cg3np: // global
           HpAlloc = 32;
           goto cg3nm;
       cg3nm: // global
           R2 = _sg1Rc::P64;
           R1 = _sg1Re::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg3no: // global
           _sg1R3::P64 = P64[_sg1Re::P64 + 7];
           _sg1Rb::P64 = P64[_sg1Re::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sg1Rb::P64;
           P64[Hp] = _sg1Rc::P64;
           R2 = _sg1R3::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg1Rf_entry() //  [R1, R2]
         { info_tbl: [(cg3nq,
                       label: sat_sg1Rf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3nq: // global
           _sg1Rb::P64 = R2;
           _sg1Rf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg3nr; else goto cg3ns;
       cg3ns: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg3nu; else goto cg3nt;
       cg3nu: // global
           HpAlloc = 24;
           goto cg3nr;
       cg3nr: // global
           R2 = _sg1Rb::P64;
           R1 = _sg1Rf::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg3nt: // global
           _sg1R3::P64 = P64[_sg1Rf::P64 + 7];
           _sg1Ra::P64 = P64[_sg1Rf::P64 + 15];
           I64[Hp - 16] = sat_sg1Re_info;
           P64[Hp - 8] = _sg1R3::P64;
           P64[Hp] = _sg1Rb::P64;
           R2 = _sg1R3::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg1Ra::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sg1R6_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg3nv,
                       label: k1_sg1R6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3nv: // global
           _sg1R9::P64 = R4;
           _sg1R8::P64 = R3;
           _sg1R7::P64 = R2;
           _sg1R6::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg3nw; else goto cg3nx;
       cg3nx: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg3nz; else goto cg3ny;
       cg3nz: // global
           HpAlloc = 64;
           goto cg3nw;
       cg3nw: // global
           R4 = _sg1R9::P64;
           R3 = _sg1R8::P64;
           R2 = _sg1R7::P64;
           R1 = _sg1R6::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3ny: // global
           _sg1R3::P64 = P64[_sg1R6::P64 + 5];
           _sg1R4::P64 = P64[_sg1R6::P64 + 13];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sg1R4::P64;
           P64[Hp - 32] = _sg1R7::P64;
           P64[Hp - 24] = _sg1R9::P64;
           I64[Hp - 16] = sat_sg1Rf_info;
           P64[Hp - 8] = _sg1R3::P64;
           P64[Hp] = Hp - 56;
           R2 = _sg1R3::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg1R8::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg1Ri_entry() //  [R1]
         { info_tbl: [(cg3nJ,
                       label: sat_sg1Ri_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3nJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3nK; else goto cg3nL;
       cg3nK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3nL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.InL_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg1Rk_entry() //  [R1]
         { info_tbl: [(cg3nS,
                       label: sat_sg1Rk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3nS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3nT; else goto cg3nU;
       cg3nT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3nU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.InR_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgmapM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg3nZ,
                       label: Data.Functor.Sum.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3nZ: // global
           _sg1R5::P64 = R6;
           _sg1R4::P64 = R5;
           _sg1R3::P64 = R4;
           _sg1R2::P64 = R3;
           _sg1R1::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cg3o0; else goto cg3o1;
       cg3o1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg3o3; else goto cg3o2;
       cg3o3: // global
           HpAlloc = 24;
           goto cg3o0;
       cg3o0: // global
           R6 = _sg1R5::P64;
           R5 = _sg1R4::P64;
           R4 = _sg1R3::P64;
           R3 = _sg1R2::P64;
           R2 = _sg1R1::P64;
           R1 = Data.Functor.Sum.$w$cgmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3o2: // global
           I64[Hp - 16] = k1_sg1R6_info;
           P64[Hp - 8] = _sg1R3::P64;
           P64[Hp] = _sg1R4::P64;
           I64[Sp - 40] = block_cg3nA_info;
           R1 = _sg1R5::P64;
           P64[Sp - 32] = Hp - 13;
           P64[Sp - 24] = _sg1R1::P64;
           P64[Sp - 16] = _sg1R2::P64;
           P64[Sp - 8] = _sg1R3::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug3oa; else goto cg3nB;
       ug3oa: // global
           call _cg3nA(R1) args: 0, res: 0, upd: 0;
       cg3nB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3nA() //  [R1]
         { info_tbl: [(cg3nA,
                       label: block_cg3nA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3nA: // global
           _cg3n4::P64 = P64[Sp + 8];
           _sg1R3::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg3nW; else goto cg3nX;
       cg3nW: // global
           Hp = Hp + 24;
           _sg1Rg::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3o9; else goto cg3o5;
       cg3o5: // global
           _sg1Rh::P64 = P64[_sg1Rg::P64 + 7];
           I64[Hp - 16] = sat_sg1Ri_info;
           P64[Hp] = _sg1R3::P64;
           R4 = _sg1Rh::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _cg3n4::P64;
           Sp = Sp + 40;
           call k1_sg1R6_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3nX: // global
           Hp = Hp + 24;
           _sg1Rg::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3o9; else goto cg3o8;
       cg3o9: // global
           HpAlloc = 24;
           R1 = _sg1Rg::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg3o8: // global
           _sg1Rj::P64 = P64[_sg1Rg::P64 + 6];
           I64[Hp - 16] = sat_sg1Rk_info;
           P64[Hp] = _sg1R3::P64;
           R4 = _sg1Rj::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 24];
           R1 = _cg3n4::P64;
           Sp = Sp + 40;
           call k1_sg1R6_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.614881291 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapM_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapM_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapM_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapM_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3p3: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapM_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapM_entry() //  [R6]
         { info_tbl: [(cg3p7,
                       label: Data.Functor.Sum.$fDataSum_$cgmapM_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3p7: // global
           _sg1Rp::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sg1Rp::P64;
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgmapM_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.620705319 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapQi_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapQi_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapQi_info;
         const 0;
 },
 Data.Functor.Sum.$fDataSum_$cgmapQi_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3ph: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQi_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapQi_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg3ps,
                       label: Data.Functor.Sum.$fDataSum_$cgmapQi_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3ps: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg3pt; else goto cg3pu;
       cg3pt: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgmapQi_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cg3pu: // global
           I64[Sp - 8] = block_cg3pl_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3pZ; else goto cg3pm;
       ug3pZ: // global
           call _cg3pl(R1) args: 0, res: 0, upd: 0;
       cg3pm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3pl() //  [R1]
         { info_tbl: [(cg3pl,
                       label: block_cg3pl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3pl: // global
           _sg1RA::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg3pp; else goto cg3pq;
       cg3pp: // global
           I64[Sp + 8] = block_cg3px_info;
           _sg1RE::P64 = P64[R1 + 7];
           R1 = _sg1RA::P64;
           P64[Sp + 16] = _sg1RE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ug3pX; else goto cg3pz;
       ug3pX: // global
           call _cg3px(R1) args: 0, res: 0, upd: 0;
       cg3pz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cg3pq: // global
           I64[Sp] = block_cg3pK_info;
           _sg1RI::P64 = P64[R1 + 6];
           R1 = _sg1RA::P64;
           P64[Sp + 32] = _sg1RI::P64;
           if (R1 & 7 != 0) goto ug3pY; else goto cg3pM;
       ug3pY: // global
           call _cg3pK(R1) args: 0, res: 0, upd: 0;
       cg3pM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3px() //  [R1]
         { info_tbl: [(cg3px,
                       label: block_cg3px_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3px: // global
           if (I64[R1 + 7] == 0) goto cg3pH; else goto ug3pW;
       cg3pH: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       ug3pW: // global
           Sp = Sp + 32;
           call _cg3pT() args: 0, res: 0, upd: 0;
     }
 },
 _cg3pK() //  [R1]
         { info_tbl: [(cg3pK,
                       label: block_cg3pK_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3pK: // global
           if (I64[R1 + 7] == 0) goto cg3pU; else goto ug3pV;
       cg3pU: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       ug3pV: // global
           Sp = Sp + 40;
           call _cg3pT() args: 0, res: 0, upd: 0;
     }
 },
 _cg3pT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3pT: // global
           R1 = Data.Maybe.fromJust1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.634125801 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapQr_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapQr_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapQr_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapQr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3qt: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQr_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 48, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapQr_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg3qE,
                       label: Data.Functor.Sum.$fDataSum_$cgmapQr_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3qE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg3qF; else goto cg3qG;
       cg3qF: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgmapQr_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cg3qG: // global
           I64[Sp - 8] = block_cg3qx_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3qT; else goto cg3qy;
       ug3qT: // global
           call _cg3qx(R1) args: 0, res: 0, upd: 0;
       cg3qy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3qx() //  [R1]
         { info_tbl: [(cg3qx,
                       label: block_cg3qx_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3qx: // global
           _sg1RS::P64 = P64[Sp + 16];
           _sg1RT::P64 = P64[Sp + 24];
           _sg1RU::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg3qB; else goto cg3qC;
       cg3qB: // global
           Hp = Hp + 40;
           _sg1RW::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3qS; else goto cg3qL;
       cg3qL: // global
           _sg1RX::P64 = P64[_sg1RW::P64 + 7];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg1RU::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sg1RX::P64;
           R3 = _sg1RT::P64;
           R2 = Hp - 32;
           R1 = _sg1RS::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3qC: // global
           Hp = Hp + 40;
           _sg1RW::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3qS; else goto cg3qR;
       cg3qS: // global
           HpAlloc = 40;
           R1 = _sg1RW::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg3qR: // global
           _sg1RZ::P64 = P64[_sg1RW::P64 + 6];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg1RU::P64;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sg1RZ::P64;
           R3 = _sg1RT::P64;
           R2 = Hp - 32;
           R1 = _sg1RS::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.643291815 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapQ_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapQ_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapQ_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapQ_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3rd: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQ_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapQ_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg3ro,
                       label: Data.Functor.Sum.$fDataSum_$cgmapQ_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3ro: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg3rp; else goto cg3rq;
       cg3rp: // global
           R1 = Data.Functor.Sum.$fDataSum_$cgmapQ_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cg3rq: // global
           I64[Sp - 8] = block_cg3rh_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3rF; else goto cg3ri;
       ug3rF: // global
           call _cg3rh(R1) args: 0, res: 0, upd: 0;
       cg3ri: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3rh() //  [R1]
         { info_tbl: [(cg3rh,
                       label: block_cg3rh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3rh: // global
           _sg1S7::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg3rl; else goto cg3rm;
       cg3rl: // global
           Hp = Hp + 64;
           _sg1S9::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3rE; else goto cg3rw;
       cg3rw: // global
           _sg1Sa::P64 = P64[_sg1S9::P64 + 7];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sg1S7::P64;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sg1Sa::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg3rm: // global
           Hp = Hp + 64;
           _sg1S9::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3rE; else goto cg3rD;
       cg3rE: // global
           HpAlloc = 64;
           R1 = _sg1S9::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg3rD: // global
           _sg1Sc::P64 = P64[_sg1S9::P64 + 6];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sg1S7::P64;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg1Sc::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.651845553 UTC

[section ""data" . Data.Functor.Sum.$fDataSum3_closure" {
     Data.Functor.Sum.$fDataSum3_closure:
         const Data.Functor.Sum.$fDataSum3_info;
 },
 Data.Functor.Sum.$fDataSum3_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3s9: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum3_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 48, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg3sk,
                       label: Data.Functor.Sum.$fDataSum3_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3sk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg3sl; else goto cg3sm;
       cg3sl: // global
           R1 = Data.Functor.Sum.$fDataSum3_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cg3sm: // global
           I64[Sp - 8] = block_cg3sd_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3sz; else goto cg3se;
       ug3sz: // global
           call _cg3sd(R1) args: 0, res: 0, upd: 0;
       cg3se: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3sd() //  [R1]
         { info_tbl: [(cg3sd,
                       label: block_cg3sd_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3sd: // global
           _sg1Sk::P64 = P64[Sp + 16];
           _sg1Sl::P64 = P64[Sp + 24];
           _sg1Sm::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg3sh; else goto cg3si;
       cg3sh: // global
           Hp = Hp + 40;
           _sg1So::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3sy; else goto cg3sr;
       cg3sr: // global
           _sg1Sp::P64 = P64[_sg1So::P64 + 7];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg1Sm::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sg1Sp::P64;
           R3 = Hp - 32;
           R2 = _sg1Sl::P64;
           R1 = _sg1Sk::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3si: // global
           Hp = Hp + 40;
           _sg1So::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3sy; else goto cg3sx;
       cg3sy: // global
           HpAlloc = 40;
           R1 = _sg1So::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg3sx: // global
           _sg1Sr::P64 = P64[_sg1So::P64 + 6];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg1Sm::P64;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sg1Sr::P64;
           R3 = Hp - 32;
           R2 = _sg1Sl::P64;
           R1 = _sg1Sk::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.660706495 UTC

[section ""data" . Data.Functor.Sum.$fDataSum4_closure" {
     Data.Functor.Sum.$fDataSum4_closure:
         const Data.Functor.Sum.$fDataSum4_info;
 },
 Data.Functor.Sum.$fDataSum4_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3sT: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg3t4,
                       label: Data.Functor.Sum.$fDataSum4_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3t4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg3t5; else goto cg3t6;
       cg3t5: // global
           R1 = Data.Functor.Sum.$fDataSum4_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cg3t6: // global
           I64[Sp - 8] = block_cg3sX_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3tl; else goto cg3sY;
       ug3tl: // global
           call _cg3sX(R1) args: 0, res: 0, upd: 0;
       cg3sY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3sX() //  [R1]
         { info_tbl: [(cg3sX,
                       label: block_cg3sX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3sX: // global
           _sg1Sz::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg3t1; else goto cg3t2;
       cg3t1: // global
           Hp = Hp + 56;
           _sg1SB::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3tk; else goto cg3tc;
       cg3tc: // global
           _sg1SC::P64 = P64[_sg1SB::P64 + 7];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = _sg1Sz::P64;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sg1SC::P64;
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg3t2: // global
           Hp = Hp + 56;
           _sg1SB::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3tk; else goto cg3tj;
       cg3tk: // global
           HpAlloc = 56;
           R1 = _sg1SB::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg3tj: // global
           _sg1SE::P64 = P64[_sg1SB::P64 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = _sg1Sz::P64;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sg1SE::P64;
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.671730361 UTC

[section ""data" . Data.Functor.Sum.$w$cgmapMo_closure" {
     Data.Functor.Sum.$w$cgmapMo_closure:
         const Data.Functor.Sum.$w$cgmapMo_info;
 },
 lvl8_sg1SL_entry() //  [R1]
         { info_tbl: [(cg3tS,
                       label: lvl8_sg1SL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3tS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg3tT; else goto cg3tU;
       cg3tT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3tU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg1Tj_entry() //  [R1, R2]
         { info_tbl: [(cg3u7,
                       label: sat_sg1Tj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3u7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3u8; else goto cg3u9;
       cg3u8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg3u9: // global
           I64[Sp - 24] = block_cg3u4_info;
           _sg1SL::P64 = P64[R1 + 7];
           _sg1SM::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sg1SL::P64;
           P64[Sp - 8] = _sg1SM::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug3ur; else goto cg3u5;
       ug3ur: // global
           call _cg3u4(R1) args: 0, res: 0, upd: 0;
       cg3u5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3u4() //  [R1]
         { info_tbl: [(cg3u4,
                       label: block_cg3u4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3u4: // global
           I64[Sp - 8] = block_cg3uc_info;
           _sg1Tg::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sg1Tg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3uq; else goto cg3ue;
       ug3uq: // global
           call _cg3uc(R1) args: 0, res: 0, upd: 0;
       cg3ue: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3uc() //  [R1]
         { info_tbl: [(cg3uc,
                       label: block_cg3uc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3uc: // global
           if (R1 & 7 == 1) goto cg3uk; else goto cg3uo;
       cg3uk: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg3uo: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg1T4_entry() //  [R1]
         { info_tbl: [(cg3uX,
                       label: sat_sg1T4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3uX: // global
           _sg1T4::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg3uY; else goto cg3uZ;
       cg3uZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg3v1; else goto cg3v0;
       cg3v1: // global
           HpAlloc = 56;
           goto cg3uY;
       cg3uY: // global
           R1 = _sg1T4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3v0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg1T4::P64;
           _sg1SM::P64 = P64[_sg1T4::P64 + 16];
           _sg1SQ::P64 = P64[_sg1T4::P64 + 24];
           _sg1SU::P64 = P64[_sg1T4::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg1SU::P64;
           P64[Hp - 24] = _sg1SQ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sg1SM::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg1T0_entry() //  [R1, R2]
         { info_tbl: [(cg3vd,
                       label: sat_sg1T0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3vd: // global
           _sg1SX::P64 = R2;
           _sg1T0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg3ve; else goto cg3vf;
       cg3vf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg3vh; else goto cg3vg;
       cg3vh: // global
           HpAlloc = 56;
           goto cg3ve;
       cg3ve: // global
           R2 = _sg1SX::P64;
           R1 = _sg1T0::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg3vg: // global
           _sg1SM::P64 = P64[_sg1T0::P64 + 7];
           _sg1SU::P64 = P64[_sg1T0::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg1SU::P64;
           P64[Hp - 24] = _sg1SX::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sg1SM::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg1T1_entry() //  [R1]
         { info_tbl: [(cg3vi,
                       label: sat_sg1T1_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3vi: // global
           _sg1T1::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg3vj; else goto cg3vk;
       cg3vk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg3vm; else goto cg3vl;
       cg3vm: // global
           HpAlloc = 24;
           goto cg3vj;
       cg3vj: // global
           R1 = _sg1T1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3vl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg1T1::P64;
           _sg1SM::P64 = P64[_sg1T1::P64 + 16];
           _sg1SR::P64 = P64[_sg1T1::P64 + 24];
           _sg1SU::P64 = P64[_sg1T1::P64 + 32];
           I64[Hp - 16] = sat_sg1T0_info;
           P64[Hp - 8] = _sg1SM::P64;
           P64[Hp] = _sg1SU::P64;
           R2 = _sg1SM::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg1SR::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg1T7_entry() //  [R1, R2]
         { info_tbl: [(cg3vn,
                       label: sat_sg1T7_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3vn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg3vo; else goto cg3vp;
       cg3vo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg3vp: // global
           I64[Sp - 40] = block_cg3uH_info;
           _sg1SI::P64 = P64[R1 + 7];
           _sg1SM::P64 = P64[R1 + 15];
           _sg1SQ::P64 = P64[R1 + 23];
           _sg1SR::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg1SI::P64;
           P64[Sp - 24] = _sg1SM::P64;
           P64[Sp - 16] = _sg1SQ::P64;
           P64[Sp - 8] = _sg1SR::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug3vG; else goto cg3uI;
       ug3vG: // global
           call _cg3uH(R1) args: 0, res: 0, upd: 0;
       cg3uI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3uH() //  [R1]
         { info_tbl: [(cg3uH,
                       label: block_cg3uH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3uH: // global
           I64[Sp - 8] = block_cg3uM_info;
           _sg1SU::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sg1SU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3vF; else goto cg3uN;
       ug3vF: // global
           call _cg3uM(R1) args: 0, res: 0, upd: 0;
       cg3uN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3uM() //  [R1]
         { info_tbl: [(cg3uM,
                       label: block_cg3uM_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3uM: // global
           _sg1SM::P64 = P64[Sp + 24];
           _sg1SQ::P64 = P64[Sp + 32];
           _sg1SU::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cg3vs; else goto cg3vw;
       cg3vs: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg3vv; else goto cg3vu;
       cg3vv: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg3vu: // global
           I64[Hp - 72] = sat_sg1T4_info;
           P64[Hp - 56] = _sg1SM::P64;
           P64[Hp - 48] = _sg1SQ::P64;
           P64[Hp - 40] = _sg1SU::P64;
           I64[Hp - 32] = sat_sg1T1_info;
           P64[Hp - 16] = _sg1SM::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sg1SU::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cg3vw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg3vB; else goto cg3vA;
       cg3vB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg3vA: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg1SU::P64;
           P64[Hp - 24] = _sg1SQ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sg1SM::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 k1_sg1SN_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg3vH,
                       label: k1_sg1SN_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3vH: // global
           _sg1SQ::P64 = R4;
           _sg1SP::P64 = R3;
           _sg1SO::P64 = R2;
           _sg1SN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg3vI; else goto cg3vJ;
       cg3vJ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg3vL; else goto cg3vK;
       cg3vL: // global
           HpAlloc = 80;
           goto cg3vI;
       cg3vI: // global
           R4 = _sg1SQ::P64;
           R3 = _sg1SP::P64;
           R2 = _sg1SO::P64;
           R1 = _sg1SN::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3vK: // global
           _sg1SI::P64 = P64[_sg1SN::P64 + 5];
           _sg1SJ::P64 = P64[_sg1SN::P64 + 13];
           _sg1SM::P64 = P64[_sg1SN::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sg1SJ::P64;
           P64[Hp - 48] = _sg1SO::P64;
           P64[Hp - 40] = _sg1SQ::P64;
           I64[Hp - 32] = sat_sg1T7_info;
           P64[Hp - 24] = _sg1SI::P64;
           P64[Hp - 16] = _sg1SM::P64;
           P64[Hp - 8] = _sg1SQ::P64;
           P64[Hp] = Hp - 72;
           R2 = _sg1SM::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg1SP::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg1Ta_entry() //  [R1]
         { info_tbl: [(cg3vV,
                       label: sat_sg1Ta_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3vV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3vW; else goto cg3vX;
       cg3vW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3vX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg1Tc_entry() //  [R1]
         { info_tbl: [(cg3w4,
                       label: sat_sg1Tc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3w4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3w5; else goto cg3w6;
       cg3w5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3w6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Sum.$fDataSum1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg1Td_entry() //  [R1]
         { info_tbl: [(cg3wb,
                       label: sat_sg1Td_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3wb: // global
           _sg1Td::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cg3wc; else goto cg3wd;
       cg3wd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg3wf; else goto cg3we;
       cg3wf: // global
           HpAlloc = 32;
           goto cg3wc;
       cg3wc: // global
           R1 = _sg1Td::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3we: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg1Td::P64;
           _sg1SG::P64 = P64[_sg1Td::P64 + 16];
           _sg1SH::P64 = P64[_sg1Td::P64 + 24];
           _sg1SI::P64 = P64[_sg1Td::P64 + 32];
           _sg1SJ::P64 = P64[_sg1Td::P64 + 40];
           _sg1SK::P64 = P64[_sg1Td::P64 + 48];
           _sg1SM::P64 = P64[_sg1Td::P64 + 56];
           I64[Hp - 24] = k1_sg1SN_info;
           P64[Hp - 16] = _sg1SI::P64;
           P64[Hp - 8] = _sg1SJ::P64;
           P64[Hp] = _sg1SM::P64;
           I64[Sp - 56] = block_cg3vM_info;
           R1 = _sg1SK::P64;
           P64[Sp - 48] = Hp - 21;
           P64[Sp - 40] = _sg1SG::P64;
           P64[Sp - 32] = _sg1SH::P64;
           P64[Sp - 24] = _sg1SM::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ug3wm; else goto cg3vN;
       ug3wm: // global
           call _cg3vM(R1) args: 0, res: 0, upd: 0;
       cg3vN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg3vM() //  [R1]
         { info_tbl: [(cg3vM,
                       label: block_cg3vM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3vM: // global
           _cg3uw::P64 = P64[Sp + 8];
           _sg1SM::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cg3w8; else goto cg3w9;
       cg3w8: // global
           Hp = Hp + 24;
           _sg1T8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3wl; else goto cg3wh;
       cg3wh: // global
           _sg1T9::P64 = P64[_sg1T8::P64 + 7];
           I64[Hp - 16] = sat_sg1Ta_info;
           P64[Hp] = _sg1SM::P64;
           R4 = _sg1T9::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 16];
           R1 = _cg3uw::P64;
           Sp = Sp + 40;
           call k1_sg1SN_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
       cg3w9: // global
           Hp = Hp + 24;
           _sg1T8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cg3wl; else goto cg3wk;
       cg3wl: // global
           HpAlloc = 24;
           R1 = _sg1T8::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg3wk: // global
           _sg1Tb::P64 = P64[_sg1T8::P64 + 6];
           I64[Hp - 16] = sat_sg1Tc_info;
           P64[Hp] = _sg1SM::P64;
           R4 = _sg1Tb::P64;
           R3 = Hp - 16;
           R2 = P64[Sp + 24];
           R1 = _cg3uw::P64;
           Sp = Sp + 40;
           call k1_sg1SN_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$w$cgmapMo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg3wn,
                       label: Data.Functor.Sum.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3wn: // global
           _sg1SK::P64 = R6;
           _sg1SJ::P64 = R5;
           _sg1SI::P64 = R4;
           _sg1SH::P64 = R3;
           _sg1SG::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg3wo; else goto cg3wp;
       cg3wp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg3wr; else goto cg3wq;
       cg3wr: // global
           HpAlloc = 24;
           goto cg3wo;
       cg3wo: // global
           R6 = _sg1SK::P64;
           R5 = _sg1SJ::P64;
           R4 = _sg1SI::P64;
           R3 = _sg1SH::P64;
           R2 = _sg1SG::P64;
           R1 = Data.Functor.Sum.$w$cgmapMo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3wq: // global
           I64[Hp - 16] = lvl8_sg1SL_info;
           P64[Hp] = _sg1SI::P64;
           I64[Sp - 56] = block_cg3tV_info;
           R2 = _sg1SI::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sg1SG::P64;
           P64[Sp - 32] = _sg1SH::P64;
           P64[Sp - 24] = _sg1SI::P64;
           P64[Sp - 16] = _sg1SJ::P64;
           P64[Sp - 8] = _sg1SK::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg3tV() //  [R1]
         { info_tbl: [(cg3tV,
                       label: block_cg3tV_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3tV: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg3wu; else goto cg3wt;
       cg3wu: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg3wt: // global
           I64[Hp - 80] = sat_sg1Tj_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sg1Td_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.713905528 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_$cgmapMo_closure" {
     Data.Functor.Sum.$fDataSum_$cgmapMo_closure:
         const Data.Functor.Sum.$fDataSum_$cgmapMo_info;
 },
 Data.Functor.Sum.$fDataSum_$cgmapMo_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3yQ: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Sum.$fDataSum_$cgmapMo_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Sum.$fDataSum_$cgmapMo_entry() //  [R6]
         { info_tbl: [(cg3yU,
                       label: Data.Functor.Sum.$fDataSum_$cgmapMo_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3yU: // global
           _sg1To::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sg1To::P64;
           Sp = Sp + 32;
           call Data.Functor.Sum.$w$cgmapMo_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.719351362 UTC

[section ""data" . lvl4_rfXPs_closure" {
     lvl4_rfXPs_closure:
         const lvl4_rfXPs_info;
         const 0;
 },
 lvl4_rfXPs_entry() //  [R2]
         { info_tbl: [(cg3ze,
                       label: lvl4_rfXPs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3ze: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg3zf; else goto cg3zg;
       cg3zf: // global
           R2 = R2;
           R1 = lvl4_rfXPs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg3zg: // global
           I64[Sp - 8] = block_cg3z7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug3zn; else goto cg3z8;
       ug3zn: // global
           call _cg3z7(R1) args: 0, res: 0, upd: 0;
       cg3z8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg3z7() //  [R1]
         { info_tbl: [(cg3z7,
                       label: block_cg3z7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3z7: // global
           if (R1 & 7 == 1) goto cg3zb; else goto cg3zc;
       cg3zb: // global
           R1 = Data.Functor.Sum.$cInL_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg3zc: // global
           R1 = Data.Functor.Sum.$cInR_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.72584438 UTC

[section ""data" . lvl5_rfXPt_closure" {
     lvl5_rfXPt_closure:
         const lvl5_rfXPt_info;
         const 0;
 },
 lvl5_rfXPt_entry() //  []
         { info_tbl: [(cg3zG,
                       label: lvl5_rfXPt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3zG: // global
           R1 = Data.Functor.Sum.$tSum_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.729279653 UTC

[section ""data" . lvl6_rfXPu_closure" {
     lvl6_rfXPu_closure:
         const lvl6_rfXPu_info;
 },
 lvl6_rfXPu_entry() //  []
         { info_tbl: [(cg3zS,
                       label: lvl6_rfXPu_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3zS: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.732652219 UTC

[section ""data" . lvl7_rfXPv_closure" {
     lvl7_rfXPv_closure:
         const lvl7_rfXPv_info;
 },
 lvl7_rfXPv_entry() //  []
         { info_tbl: [(cg3A5,
                       label: lvl7_rfXPv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3A5: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.738566606 UTC

[section ""data" . Data.Functor.Sum.$fDataSum_closure" {
     Data.Functor.Sum.$fDataSum_closure:
         const Data.Functor.Sum.$fDataSum_info;
         const 0;
 },
 sat_sg1U1_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg3An,
                       label: sat_sg1U1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3An: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$w$cgmapMo_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1TX_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg3Av,
                       label: sat_sg1TX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3Av: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$w$cgmapMp_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1TT_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg3AD,
                       label: sat_sg1TT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3AD: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Sum.$w$cgmapM_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg1TP_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg3AL,
                       label: sat_sg1TP_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3AL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3AM; else goto cg3AN;
       cg3AM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3AN: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Sum.$fDataSum_$cgmapQi_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg1TO_entry() //  [R1, R2, R3]
         { info_tbl: [(cg3AT,
                       label: sat_sg1TO_info
                       rep:HeapRep 6 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3AT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg3AU; else goto cg3AV;
       cg3AU: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3AV: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 46];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fDataSum_$cgmapQ_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg1TN_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg3B1,
                       label: sat_sg1TN_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3B1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg3B2; else goto cg3B3;
       cg3B2: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3B3: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Sum.$fDataSum_$cgmapQr_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg1TM_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg3B9,
                       label: sat_sg1TM_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3B9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg3Ba; else goto cg3Bb;
       cg3Ba: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3Bb: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Sum.$fDataSum3_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg1TL_entry() //  [R1, R2, R3]
         { info_tbl: [(cg3Bh,
                       label: sat_sg1TL_info
                       rep:HeapRep 6 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3Bh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg3Bi; else goto cg3Bj;
       cg3Bi: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3Bj: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 46];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call Data.Functor.Sum.$fDataSum4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg1TK_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg3Bp,
                       label: sat_sg1TK_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3Bp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3Bq; else goto cg3Br;
       cg3Bq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3Br: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Sum.$fDataSum_$cgunfold_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg1TJ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg3Bx,
                       label: sat_sg1TJ_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3Bx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg3By; else goto cg3Bz;
       cg3By: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg3Bz: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Sum.$fDataSum_$cgfoldl_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg1TI_entry() //  [R1]
         { info_tbl: [(cg3BE,
                       label: sat_sg1TI_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3BE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg3BF; else goto cg3BG;
       cg3BF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg3BG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Sum.$w$cp1Data_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Sum.$fDataSum_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg3BI,
                       label: Data.Functor.Sum.$fDataSum_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3BI: // global
           Hp = Hp + 640;
           if (Hp > HpLim) (likely: False) goto cg3BM; else goto cg3BL;
       cg3BM: // global
           HpAlloc = 640;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Sum.$fDataSum_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg3BL: // global
           I64[Hp - 632] = sat_sg1U1_info;
           P64[Hp - 624] = R6;
           _sg1TH::P64 = P64[Sp];
           P64[Hp - 616] = _sg1TH::P64;
           I64[Hp - 608] = sat_sg1TX_info;
           P64[Hp - 600] = R6;
           P64[Hp - 592] = _sg1TH::P64;
           I64[Hp - 584] = sat_sg1TT_info;
           P64[Hp - 576] = R6;
           P64[Hp - 568] = _sg1TH::P64;
           I64[Hp - 560] = sat_sg1TP_info;
           P64[Hp - 552] = R2;
           P64[Hp - 544] = R3;
           P64[Hp - 536] = R4;
           P64[Hp - 528] = R5;
           P64[Hp - 520] = R6;
           P64[Hp - 512] = _sg1TH::P64;
           I64[Hp - 504] = sat_sg1TO_info;
           P64[Hp - 496] = R2;
           P64[Hp - 488] = R3;
           P64[Hp - 480] = R4;
           P64[Hp - 472] = R5;
           P64[Hp - 464] = R6;
           P64[Hp - 456] = _sg1TH::P64;
           I64[Hp - 448] = sat_sg1TN_info;
           P64[Hp - 440] = R2;
           P64[Hp - 432] = R3;
           P64[Hp - 424] = R4;
           P64[Hp - 416] = R5;
           P64[Hp - 408] = R6;
           P64[Hp - 400] = _sg1TH::P64;
           I64[Hp - 392] = sat_sg1TM_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           P64[Hp - 368] = R4;
           P64[Hp - 360] = R5;
           P64[Hp - 352] = R6;
           P64[Hp - 344] = _sg1TH::P64;
           I64[Hp - 336] = sat_sg1TL_info;
           P64[Hp - 328] = R2;
           P64[Hp - 320] = R3;
           P64[Hp - 312] = R4;
           P64[Hp - 304] = R5;
           P64[Hp - 296] = R6;
           P64[Hp - 288] = _sg1TH::P64;
           I64[Hp - 280] = sat_sg1TK_info;
           P64[Hp - 272] = R2;
           P64[Hp - 264] = R3;
           P64[Hp - 256] = R4;
           P64[Hp - 248] = R5;
           P64[Hp - 240] = R6;
           P64[Hp - 232] = _sg1TH::P64;
           I64[Hp - 224] = sat_sg1TJ_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           P64[Hp - 200] = R4;
           P64[Hp - 192] = R5;
           P64[Hp - 184] = R6;
           P64[Hp - 176] = _sg1TH::P64;
           I64[Hp - 168] = sat_sg1TI_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           P64[Hp - 136] = R4;
           P64[Hp - 128] = R5;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 168;
           P64[Hp - 104] = Hp - 221;
           P64[Hp - 96] = Hp - 277;
           P64[Hp - 88] = lvl4_rfXPs_closure+1;
           P64[Hp - 80] = lvl5_rfXPt_closure+1;
           P64[Hp - 72] = lvl6_rfXPu_closure+2;
           P64[Hp - 64] = lvl7_rfXPv_closure+2;
           P64[Hp - 56] = Hp - 334;
           P64[Hp - 48] = Hp - 388;
           P64[Hp - 40] = Hp - 444;
           P64[Hp - 32] = Hp - 502;
           P64[Hp - 24] = Hp - 557;
           P64[Hp - 16] = Hp - 581;
           P64[Hp - 8] = Hp - 605;
           P64[Hp] = Hp - 629;
           R1 = Hp - 119;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.770078917 UTC

[section ""data" . Data.Functor.Sum.InL_closure" {
     Data.Functor.Sum.InL_closure:
         const Data.Functor.Sum.InL_info;
 },
 Data.Functor.Sum.InL_entry() //  [R2]
         { info_tbl: [(cg3Db,
                       label: Data.Functor.Sum.InL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3Db: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg3Df; else goto cg3De;
       cg3Df: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Functor.Sum.InL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg3De: // global
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.774152977 UTC

[section ""data" . Data.Functor.Sum.InR_closure" {
     Data.Functor.Sum.InR_closure:
         const Data.Functor.Sum.InR_info;
 },
 Data.Functor.Sum.InR_entry() //  [R2]
         { info_tbl: [(cg3Dr,
                       label: Data.Functor.Sum.InR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3Dr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg3Dv; else goto cg3Du;
       cg3Dv: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Functor.Sum.InR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg3Du: // global
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.777949418 UTC

[Data.Functor.Sum.InL_con_entry() //  [R1]
         { info_tbl: [(cg3DC,
                       label: Data.Functor.Sum.InL_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,83,117,109,46,73,110,76]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3DC: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.781323836 UTC

[Data.Functor.Sum.InR_con_entry() //  [R1]
         { info_tbl: [(cg3DJ,
                       label: Data.Functor.Sum.InR_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,83,117,109,46,73,110,82]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg3DJ: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:53.784616194 UTC

[section ""relreadonly" . Sg21L_srt" {
     Sg21L_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Sum.$fRead1Sum2_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Data.Functor.Sum.$fRead1Sum6_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Sum.$fRead1Sum1_closure;
         const Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec_closure;
         const Data.Functor.Sum.$fRead1Sum_$cliftReadList_closure;
         const Data.Functor.Sum.$fRead1Sum_closure;
         const Data.Functor.Sum.$fRead1Sum3_closure;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const Data.Functor.Sum.$w$cliftShowsPrec_closure;
         const Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec_closure;
         const Data.Functor.Sum.$fShow1Sum_$cliftShowList_closure;
         const Data.Functor.Sum.$fShow1Sum_closure;
         const Data.Functor.Sum.$fReadSum1_closure;
         const Data.Functor.Sum.$fReadSum_$creadsPrec_closure;
         const Data.Functor.Sum.$fReadSum_$creadListPrec_closure;
         const Data.Functor.Sum.$fReadSum_$creadList_closure;
         const Data.Functor.Sum.$fReadSum_closure;
         const Data.Functor.Sum.$fShowSum_$cshowsPrec_closure;
         const Data.Functor.Sum.$fShowSum_$cshow_closure;
         const Data.Functor.Sum.$fShowSum_$cshowList_closure;
         const Data.Functor.Sum.$fShowSum_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Functor.Sum.$fFoldableSum3_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Functor.Sum.$fFoldableSum4_closure;
         const Data.Functor.Sum.$fFoldableSum_$cminimum_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Sum.$fFoldableSum5_closure;
         const Data.Functor.Sum.$fFoldableSum_$cmaximum_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Functor.Sum.$fFoldableSum_$celem_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Functor.Sum.$fFoldableSum10_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldl_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldl1_closure;
         const Data.Functor.Sum.$fFoldableSum9_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldr'_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldr_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldl'_closure;
         const Data.Functor.Sum.$fFoldableSum_$clength_closure;
         const Data.Functor.Sum.$fFoldableSum_$cfoldr1_closure;
         const Data.Functor.Sum.$fFoldableSum11_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Functor.Sum.$fFoldableSum1_closure;
         const Data.Functor.Sum.$fFoldableSum_$cnull_closure;
         const Data.Functor.Sum.$fFoldableSum_$ctoList_closure;
         const Data.Functor.Sum.$fFoldableSum_closure;
         const Data.Functor.Sum.$fTraversableSum_$cp2Traversable_closure;
         const Data.Functor.Sum.$fTraversableSum_closure;
         const Data.Data.$wlvl_closure;
         const Data.Functor.Sum.$w$cgunfold_closure;
         const Data.Functor.Sum.$fDataSum_$cgunfold_closure;
         const GHC.List.badHead_closure;
         const go61_rfXP6_closure;
         const Data.Functor.Sum.$fRead1Sum7_closure;
         const go1_rfXP7_closure;
         const Data.Data.mkConstr1_closure;
         const $tSum3_rfXPb_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Functor.Sum.$w$cp1Data_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Functor.Sum.$fDataSum_$cgmapQi_closure;
         const Data.Functor.Sum.$cInL_closure;
         const Data.Functor.Sum.$cInR_closure;
         const lvl4_rfXPs_closure;
         const Data.Functor.Sum.$tSum_closure;
         const Data.Functor.Sum.$fDataSum_closure;
         const lvl5_rfXPt_closure;
 }]

