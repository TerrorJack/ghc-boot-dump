
==================== Tidy Core ====================
2018-03-16 16:06:35.552658404 UTC

Result size of Tidy Core
  = {terms: 893, types: 1,345, coercions: 1,742, joins: 0/8}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fReadIdentity4 :: GHC.Types.Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Identity.$fReadIdentity4 = GHC.Types.I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fReadIdentity6 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Identity.$fReadIdentity6 = "Identity"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fReadIdentity5 :: [GHC.Types.Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Identity.$fReadIdentity5
  = GHC.CString.unpackCString# Data.Functor.Identity.$fReadIdentity6

-- RHS size: {terms: 57, types: 88, coercions: 3, joins: 0/3}
Data.Functor.Identity.$w$creadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Read a =>
     GHC.Prim.Int# -> GHC.Base.String -> [(Identity a, GHC.Base.String)]
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 402 0}]
Data.Functor.Identity.$w$creadsPrec
  = \ (@ a_sbJqG)
      (w_sbJqH :: Read a_sbJqG)
      (ww_sbJqM :: GHC.Prim.Int#)
      (w1_sbJqJ :: GHC.Base.String) ->
      letrec {
        go_sbJrx [Occ=LoopBreaker]
          :: [(GHC.Base.String, GHC.Base.String)]
             -> [(Identity a_sbJqG, GHC.Base.String)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_sbJrx
          = \ (ds_i7Jck :: [(GHC.Base.String, GHC.Base.String)]) ->
              case ds_i7Jck of {
                [] -> GHC.Types.[] @ (Identity a_sbJqG, GHC.Base.String);
                : y_i7Jcp ys_i7Jcq ->
                  case y_i7Jcp of { (ds1_dbJhR, s_abHDy) ->
                  case GHC.Base.eqString
                         ds1_dbJhR Data.Functor.Identity.$fReadIdentity5
                  of {
                    False -> go_sbJrx ys_i7Jcq;
                    True ->
                      let {
                        z_X7Jex :: [(Identity a_sbJqG, GHC.Base.String)]
                        [LclId]
                        z_X7Jex = go_sbJrx ys_i7Jcq } in
                      letrec {
                        go1_X7JeA [Occ=LoopBreaker]
                          :: [(a_sbJqG, GHC.Base.String)]
                             -> [(Identity a_sbJqG, GHC.Base.String)]
                        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                        go1_X7JeA
                          = \ (ds2_X7JeC :: [(a_sbJqG, GHC.Base.String)]) ->
                              case ds2_X7JeC of {
                                [] -> z_X7Jex;
                                : y1_X7JeK ys1_X7JeM ->
                                  case y1_X7JeK of { (x_abHDz, t_abHDA) ->
                                  GHC.Types.:
                                    @ (Identity a_sbJqG, GHC.Base.String)
                                    (x_abHDz
                                     `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_sbJqG>_R)
                                             :: (a_sbJqG :: *) ~R# (Identity a_sbJqG :: *)),
                                     t_abHDA)
                                    (go1_X7JeA ys1_X7JeM)
                                  }
                              }; } in
                      go1_X7JeA
                        (readsPrec
                           @ a_sbJqG w_sbJqH Data.Functor.Identity.$fReadIdentity4 s_abHDy)
                  }
                  }
              }; } in
      readParen
        @ (Identity a_sbJqG)
        (GHC.Prim.tagToEnum# @ Bool (GHC.Prim.># ww_sbJqM 10#))
        (\ (r_abHDx :: GHC.Base.String) ->
           go_sbJrx
             (Text.ParserCombinators.ReadP.run
                @ GHC.Base.String GHC.Read.lex1 r_abHDx))
        w1_sbJqJ

-- RHS size: {terms: 11, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fReadIdentity_$creadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Read a =>
     GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (Identity a)
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sbJqG)
                 (w_sbJqH [Occ=Once] :: Read a_sbJqG)
                 (w1_sbJqI [Occ=Once!] :: GHC.Types.Int)
                 (w2_sbJqJ [Occ=Once] :: GHC.Base.String) ->
                 case w1_sbJqI of { GHC.Types.I# ww1_sbJqM [Occ=Once] ->
                 Data.Functor.Identity.$w$creadsPrec
                   @ a_sbJqG w_sbJqH ww1_sbJqM w2_sbJqJ
                 }}]
Data.Functor.Identity.$fReadIdentity_$creadsPrec
  = \ (@ a_sbJqG)
      (w_sbJqH :: Read a_sbJqG)
      (w1_sbJqI :: GHC.Types.Int)
      (w2_sbJqJ :: GHC.Base.String) ->
      case w1_sbJqI of { GHC.Types.I# ww1_sbJqM ->
      Data.Functor.Identity.$w$creadsPrec
        @ a_sbJqG w_sbJqH ww1_sbJqM w2_sbJqJ
      }

-- RHS size: {terms: 14, types: 24, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fReadIdentity3
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Identity a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><L,U(U)><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abJ16)
                 ($dRead_abJ17 [Occ=Once] :: Read a_abJ16)
                 (n_ibJi1 [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b_ibJi3)
                 (eta_B1 [Occ=Once]
                    :: Identity a_abJ16 -> Text.ParserCombinators.ReadP.P b_ibJi3) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ (Identity a_abJ16)
                        (Data.Functor.Identity.$fReadIdentity_$creadsPrec
                           @ a_abJ16 $dRead_abJ17 n_ibJi1)
                        @ b_ibJi3
                        eta_B1
                 of
                 { (# ww1_ibJi7 [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_ibJi3 ww1_ibJi7
                 }}]
Data.Functor.Identity.$fReadIdentity3
  = \ (@ a_abJ16)
      ($dRead_abJ17 :: Read a_abJ16)
      (n_ibJi1 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_ibJi3)
      (eta_B1
         :: Identity a_abJ16 -> Text.ParserCombinators.ReadP.P b_ibJi3) ->
      case Text.ParserCombinators.ReadP.$wreadS_to_P
             @ (Identity a_abJ16)
             (Data.Functor.Identity.$fReadIdentity_$creadsPrec
                @ a_abJ16 $dRead_abJ17 n_ibJi1)
             @ b_ibJi3
             eta_B1
      of
      { (# ww1_ibJi7 #) ->
      Text.ParserCombinators.ReadP.Look @ b_ibJi3 ww1_ibJi7
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fReadIdentity2 :: GHC.Types.Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Identity.$fReadIdentity2 = GHC.Types.I# 0#

-- RHS size: {terms: 8, types: 16, coercions: 19, joins: 0/0}
Data.Functor.Identity.$fReadIdentity_$creadList
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadP.ReadS [Identity a]
[GblId,
 Arity=1,
 Str=<L,U(C(C1(U)),A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XbJ2M) ($dRead_XbJ2O [Occ=Once] :: Read a_XbJ2M) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Identity a_XbJ2M]
                   (((((GHC.Read.list
                          @ (Identity a_XbJ2M)
                          ((Data.Functor.Identity.$fReadIdentity3 @ a_XbJ2M $dRead_XbJ2O)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <Identity
                                                     a_XbJ2M>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <Identity a_XbJ2M>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (Identity a_XbJ2M -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (Identity a_XbJ2M) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[Identity a_XbJ2M]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                     [Identity a_XbJ2M] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP
                                            [Identity a_XbJ2M] :: *)))
                        Data.Functor.Identity.$fReadIdentity2)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                 <[Identity a_XbJ2M]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [Identity a_XbJ2M] :: *)
                                ~R# (forall b.
                                     ([Identity a_XbJ2M] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [Identity a_XbJ2M]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Identity a_XbJ2M]))}]
Data.Functor.Identity.$fReadIdentity_$creadList
  = \ (@ a_XbJ2M) ($dRead_XbJ2O :: Read a_XbJ2M) ->
      Text.ParserCombinators.ReadP.run
        @ [Identity a_XbJ2M]
        (((((GHC.Read.list
               @ (Identity a_XbJ2M)
               ((Data.Functor.Identity.$fReadIdentity3 @ a_XbJ2M $dRead_XbJ2O)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Identity
                                          a_XbJ2M>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Identity a_XbJ2M>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (Identity a_XbJ2M -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (Identity a_XbJ2M) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Identity a_XbJ2M]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec
                          [Identity a_XbJ2M] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [Identity a_XbJ2M] :: *)))
             Data.Functor.Identity.$fReadIdentity2)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[Identity a_XbJ2M]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [Identity a_XbJ2M] :: *)
                     ~R# (forall b.
                          ([Identity a_XbJ2M] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Identity a_XbJ2M]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Identity a_XbJ2M]))

-- RHS size: {terms: 20, types: 44, coercions: 19, joins: 0/2}
Data.Functor.Identity.$w$creadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Read a =>
     forall b.
     ([Identity a] -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Str=<L,U(C(C1(U)),A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 60}]
Data.Functor.Identity.$w$creadListPrec
  = \ (@ a_sbJqP) (w_sbJqQ :: Read a_sbJqP) ->
      let {
        w1_sbJoI :: Text.ParserCombinators.ReadP.P [Identity a_sbJqP]
        [LclId]
        w1_sbJoI
          = ((((GHC.Read.list
                  @ (Identity a_sbJqP)
                  ((Data.Functor.Identity.$fReadIdentity3 @ a_sbJqP w_sbJqQ)
                   `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                          <Identity
                                             a_sbJqP>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <Identity a_sbJqP>_R)
                           :: (Text.ParserCombinators.ReadPrec.Prec
                               -> forall b.
                                  (Identity a_sbJqP -> Text.ParserCombinators.ReadP.P b)
                                  -> Text.ParserCombinators.ReadP.P b :: *)
                              ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                     (Identity a_sbJqP) :: *))))
               `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                           <[Identity a_sbJqP]>_R
                       :: (Text.ParserCombinators.ReadPrec.ReadPrec
                             [Identity a_sbJqP] :: *)
                          ~R# (Text.ParserCombinators.ReadPrec.Prec
                               -> Text.ParserCombinators.ReadP.ReadP [Identity a_sbJqP] :: *)))
                Data.Functor.Identity.$fReadIdentity2)
             `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <[Identity a_sbJqP]>_R
                     :: (Text.ParserCombinators.ReadP.ReadP [Identity a_sbJqP] :: *)
                        ~R# (forall b.
                             ([Identity a_sbJqP] -> Text.ParserCombinators.ReadP.P b)
                             -> Text.ParserCombinators.ReadP.P b :: *)))
              @ [Identity a_sbJqP]
              (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                 @ [Identity a_sbJqP]) } in
      let {
        w2_sbJoH [Dmd=<L,C(U)>]
          :: Text.ParserCombinators.ReadP.ReadS [Identity a_sbJqP]
        [LclId, Arity=1, Unf=OtherCon []]
        w2_sbJoH
          = Text.ParserCombinators.ReadP.run
              @ [Identity a_sbJqP] w1_sbJoI } in
      \ (@ b_ibJid)
        (w3_ibJie
           :: [Identity a_sbJqP] -> Text.ParserCombinators.ReadP.P b_ibJid) ->
        case Text.ParserCombinators.ReadP.$wreadS_to_P
               @ [Identity a_sbJqP] w2_sbJoH @ b_ibJid w3_ibJie
        of
        { (# ww1_ibJih #) ->
        Text.ParserCombinators.ReadP.Look @ b_ibJid ww1_ibJih
        }

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fReadIdentity1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([Identity a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sbJqP)
                 (w_sbJqQ [Occ=Once] :: Read a_sbJqP)
                 _ [Occ=Dead] ->
                 Data.Functor.Identity.$w$creadListPrec @ a_sbJqP w_sbJqQ}]
Data.Functor.Identity.$fReadIdentity1
  = \ (@ a_sbJqP) (w_sbJqQ :: Read a_sbJqP) _ [Occ=Dead] ->
      Data.Functor.Identity.$w$creadListPrec @ a_sbJqP w_sbJqQ

-- RHS size: {terms: 14, types: 20, coercions: 24, joins: 0/1}
Data.Functor.Identity.$fReadIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read (Identity a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(U)),A,A,A)>m,
 Unf=DFun: \ (@ a_abHDv) (v_B1 :: Read a_abHDv) ->
       GHC.Read.C:Read TYPE: Identity a_abHDv
                       Data.Functor.Identity.$fReadIdentity_$creadsPrec @ a_abHDv v_B1
                       Data.Functor.Identity.$fReadIdentity_$creadList @ a_abHDv v_B1
                       (Data.Functor.Identity.$fReadIdentity3 @ a_abHDv v_B1)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Identity
                                                 a_abHDv>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <Identity a_abHDv>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Identity a_abHDv -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                         (Identity a_abHDv) :: *))
                       (Data.Functor.Identity.$fReadIdentity1 @ a_abHDv v_B1)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Identity
                                                  a_abHDv]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                           <[Identity a_abHDv]>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Identity a_abHDv] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                         [Identity a_abHDv] :: *))]
Data.Functor.Identity.$fReadIdentity
  = \ (@ a_XbJ2R) ($dRead_XbJ2T :: Read a_XbJ2R) ->
      let {
        lvl1_sbJry
          :: forall b.
             ([Identity a_XbJ2R] -> Text.ParserCombinators.ReadP.P b)
             -> Text.ParserCombinators.ReadP.P b
        [LclId]
        lvl1_sbJry
          = Data.Functor.Identity.$w$creadListPrec
              @ a_XbJ2R $dRead_XbJ2T } in
      GHC.Read.C:Read
        @ (Identity a_XbJ2R)
        (Data.Functor.Identity.$fReadIdentity_$creadsPrec
           @ a_XbJ2R $dRead_XbJ2T)
        (Data.Functor.Identity.$fReadIdentity_$creadList
           @ a_XbJ2R $dRead_XbJ2T)
        ((Data.Functor.Identity.$fReadIdentity3 @ a_XbJ2R $dRead_XbJ2T)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Identity
                                   a_XbJ2R>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Identity a_XbJ2R>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Identity a_XbJ2R -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Identity a_XbJ2R) :: *)))
        ((\ _ [Occ=Dead] -> lvl1_sbJry)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <[Identity
                                    a_XbJ2R]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                             <[Identity a_XbJ2R]>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        ([Identity a_XbJ2R] -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           [Identity a_XbJ2R] :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fShowIdentity2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Functor.Identity.$fShowIdentity2 = "Identity "#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fShowIdentity1 :: [GHC.Types.Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Identity.$fShowIdentity1
  = GHC.CString.unpackCString# Data.Functor.Identity.$fShowIdentity2

-- RHS size: {terms: 29, types: 17, coercions: 2, joins: 0/1}
Data.Functor.Identity.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Show a =>
     GHC.Prim.Int# -> Identity a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 211 120}]
Data.Functor.Identity.$w$cshowsPrec
  = \ (@ a_sbJqT)
      (w_sbJqU :: Show a_sbJqT)
      (ww_sbJqZ :: GHC.Prim.Int#)
      (w1_sbJqW :: Identity a_sbJqT) ->
      let {
        g_sbJoD [Dmd=<L,C(U)>] :: GHC.Base.String -> GHC.Base.String
        [LclId]
        g_sbJoD
          = showsPrec
              @ a_sbJqT
              w_sbJqU
              Data.Functor.Identity.$fReadIdentity4
              (w1_sbJqW
               `cast` (Data.Functor.Identity.N:Identity[0] <a_sbJqT>_R
                       :: (Identity a_sbJqT :: *) ~R# (a_sbJqT :: *))) } in
      case GHC.Prim.># ww_sbJqZ 10# of {
        __DEFAULT ->
          \ (x_i7Rxi :: GHC.Base.String) ->
            GHC.Base.++
              @ GHC.Types.Char
              Data.Functor.Identity.$fShowIdentity1
              (g_sbJoD x_i7Rxi);
        1# ->
          \ (x_i88RR :: GHC.Base.String) ->
            GHC.Types.:
              @ GHC.Types.Char
              GHC.Show.$fShow(,)4
              (GHC.Base.++
                 @ GHC.Types.Char
                 Data.Functor.Identity.$fShowIdentity1
                 (g_sbJoD
                    (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x_i88RR)))
      }

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fShowIdentity_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Show a =>
     GHC.Types.Int -> Identity a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sbJqT)
                 (w_sbJqU [Occ=Once] :: Show a_sbJqT)
                 (w1_sbJqV [Occ=Once!] :: GHC.Types.Int)
                 (w2_sbJqW [Occ=Once] :: Identity a_sbJqT) ->
                 case w1_sbJqV of { GHC.Types.I# ww1_sbJqZ [Occ=Once] ->
                 Data.Functor.Identity.$w$cshowsPrec
                   @ a_sbJqT w_sbJqU ww1_sbJqZ w2_sbJqW
                 }}]
Data.Functor.Identity.$fShowIdentity_$cshowsPrec
  = \ (@ a_sbJqT)
      (w_sbJqU :: Show a_sbJqT)
      (w1_sbJqV :: GHC.Types.Int)
      (w2_sbJqW :: Identity a_sbJqT) ->
      case w1_sbJqV of { GHC.Types.I# ww1_sbJqZ ->
      Data.Functor.Identity.$w$cshowsPrec
        @ a_sbJqT w_sbJqU ww1_sbJqZ w2_sbJqW
      }

-- RHS size: {terms: 10, types: 9, coercions: 2, joins: 0/0}
Data.Functor.Identity.$fShowIdentity_$cshow
  :: forall a. Show a => Identity a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abJ0D)
                 ($dShow_abJ0E [Occ=Once] :: Show a_abJ0D)
                 (x_i7Jay [Occ=Once] :: Identity a_abJ0D) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot]
                         :: GHC.Types.Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      GHC.Base.foldr
                        @ GHC.Types.Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        Data.Functor.Identity.$fShowIdentity1)
                   (showsPrec
                      @ a_abJ0D
                      $dShow_abJ0E
                      Data.Functor.Identity.$fReadIdentity4
                      (x_i7Jay
                       `cast` (Data.Functor.Identity.N:Identity[0] <a_abJ0D>_R
                               :: (Identity a_abJ0D :: *) ~R# (a_abJ0D :: *)))
                      (GHC.Types.[] @ GHC.Types.Char))}]
Data.Functor.Identity.$fShowIdentity_$cshow
  = \ (@ a_abJ0D)
      ($dShow_abJ0E :: Show a_abJ0D)
      (x_i7Jay :: Identity a_abJ0D) ->
      GHC.Base.++
        @ GHC.Types.Char
        Data.Functor.Identity.$fShowIdentity1
        (showsPrec
           @ a_abJ0D
           $dShow_abJ0E
           Data.Functor.Identity.$fReadIdentity4
           (x_i7Jay
            `cast` (Data.Functor.Identity.N:Identity[0] <a_abJ0D>_R
                    :: (Identity a_abJ0D :: *) ~R# (a_abJ0D :: *)))
           (GHC.Types.[] @ GHC.Types.Char))

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fShowIdentity_$cshowList
  :: forall a. Show a => [Identity a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abJ0D)
                 ($dShow_abJ0E [Occ=Once] :: Show a_abJ0D)
                 (ls_i7JaB [Occ=Once] :: [Identity a_abJ0D])
                 (s_i7JaC [Occ=Once] :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Identity a_abJ0D)
                   (Data.Functor.Identity.$fShowIdentity_$cshowsPrec
                      @ a_abJ0D $dShow_abJ0E Data.Functor.Identity.$fReadIdentity2)
                   ls_i7JaB
                   s_i7JaC}]
Data.Functor.Identity.$fShowIdentity_$cshowList
  = \ (@ a_abJ0D)
      ($dShow_abJ0E :: Show a_abJ0D)
      (ls_i7JaB :: [Identity a_abJ0D])
      (s_i7JaC :: GHC.Base.String) ->
      GHC.Show.showList__
        @ (Identity a_abJ0D)
        (\ (w_sbJqW :: Identity a_abJ0D) ->
           Data.Functor.Identity.$w$cshowsPrec
             @ a_abJ0D $dShow_abJ0E 0# w_sbJqW)
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fShowIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show (Identity a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_abHDs) (v_B1 :: Show a_abHDs) ->
       GHC.Show.C:Show TYPE: Identity a_abHDs
                       Data.Functor.Identity.$fShowIdentity_$cshowsPrec @ a_abHDs v_B1
                       Data.Functor.Identity.$fShowIdentity_$cshow @ a_abHDs v_B1
                       Data.Functor.Identity.$fShowIdentity_$cshowList @ a_abHDs v_B1]
Data.Functor.Identity.$fShowIdentity
  = \ (@ a_abJ0D) ($dShow_abJ0E :: Show a_abJ0D) ->
      GHC.Show.C:Show
        @ (Identity a_abJ0D)
        (Data.Functor.Identity.$fShowIdentity_$cshowsPrec
           @ a_abJ0D $dShow_abJ0E)
        (Data.Functor.Identity.$fShowIdentity_$cshow
           @ a_abJ0D $dShow_abJ0E)
        (Data.Functor.Identity.$fShowIdentity_$cshowList
           @ a_abJ0D $dShow_abJ0E)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity4 :: GHC.Types.Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Identity.$fFoldableIdentity4 = GHC.Types.I# 1#

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity_$clength
  :: forall a. Identity a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIZD) _ [Occ=Dead] ->
                 Data.Functor.Identity.$fFoldableIdentity4}]
Data.Functor.Identity.$fFoldableIdentity_$clength
  = \ (@ a_abIZD) _ [Occ=Dead] ->
      Data.Functor.Identity.$fFoldableIdentity4

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity_$cnull
  :: forall a. Identity a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIZx) _ [Occ=Dead] -> GHC.Types.False}]
Data.Functor.Identity.$fFoldableIdentity_$cnull
  = \ (@ a_abIZx) _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 5, types: 6, coercions: 2, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity_$ctoList
  :: forall a. Identity a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIZr) (ds_dbJfi [Occ=Once] :: Identity a_abIZr) ->
                 GHC.Types.:
                   @ a_abIZr
                   (ds_dbJfi
                    `cast` (Data.Functor.Identity.N:Identity[0] <a_abIZr>_R
                            :: (Identity a_abIZr :: *) ~R# (a_abIZr :: *)))
                   (GHC.Types.[] @ a_abIZr)}]
Data.Functor.Identity.$fFoldableIdentity_$ctoList
  = \ (@ a_abIZr) (ds_dbJfi :: Identity a_abIZr) ->
      GHC.Types.:
        @ a_abIZr
        (ds_dbJfi
         `cast` (Data.Functor.Identity.N:Identity[0] <a_abIZr>_R
                 :: (Identity a_abIZr :: *) ~R# (a_abIZr :: *)))
        (GHC.Types.[] @ a_abIZr)

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity6
  :: forall b a. (b -> a -> b) -> b -> a -> b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_abIZ2)
                 (@ a_abIZ3)
                 (v_B2 [Occ=Once] :: b_abIZ2 -> a_abIZ3 -> b_abIZ2) ->
                 v_B2}]
Data.Functor.Identity.$fFoldableIdentity6
  = \ (@ b_abIZ2)
      (@ a_abIZ3)
      (v_B2 :: b_abIZ2 -> a_abIZ3 -> b_abIZ2) ->
      v_B2

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> Identity a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIYv)
                 (@ b_abIYw)
                 (f_abHDo [Occ=Once!] :: a_abIYv -> b_abIYw -> b_abIYw)
                 (z_abHDp [Occ=Once] :: b_abIYw)
                 (ds_dbJf5 [Occ=Once] :: Identity a_abIYv) ->
                 f_abHDo
                   (ds_dbJf5
                    `cast` (Data.Functor.Identity.N:Identity[0] <a_abIYv>_R
                            :: (Identity a_abIYv :: *) ~R# (a_abIYv :: *)))
                   z_abHDp}]
Data.Functor.Identity.$fFoldableIdentity_$cfoldr
  = \ (@ a_abIYv)
      (@ b_abIYw)
      (f_abHDo :: a_abIYv -> b_abIYw -> b_abIYw)
      (z_abHDp :: b_abIYw)
      (ds_dbJf5 :: Identity a_abIYv) ->
      f_abHDo
        (ds_dbJf5
         `cast` (Data.Functor.Identity.N:Identity[0] <a_abIYv>_R
                 :: (Identity a_abIYv :: *) ~R# (a_abIYv :: *)))
        z_abHDp

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity7
  :: forall m a. Monoid m => (a -> m) -> a -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_abIYk)
                 (@ a_abIYl)
                 _ [Occ=Dead]
                 (v_X3R [Occ=Once] :: a_abIYl -> m_abIYk) ->
                 v_X3R}]
Data.Functor.Identity.$fFoldableIdentity7
  = \ (@ m_abIYk)
      (@ a_abIYl)
      _ [Occ=Dead]
      (v_X3R :: a_abIYl -> m_abIYk) ->
      v_X3R

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFunctorIdentity2
  :: forall a b. (a -> b) -> a -> b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIXI)
                 (@ b_abIXJ)
                 (v_X3W [Occ=Once] :: a_abIXI -> b_abIXJ) ->
                 v_X3W}]
Data.Functor.Identity.$fFunctorIdentity2
  = \ (@ a_abIXI) (@ b_abIXJ) (v_X3W :: a_abIXI -> b_abIXJ) -> v_X3W

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFunctorIdentity1 :: forall b a. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_abIXT)
                 (@ a_abIXS)
                 (x_X9DoW [Occ=Once] :: a_abIXS)
                 _ [Occ=Dead] ->
                 x_X9DoW}]
Data.Functor.Identity.$fFunctorIdentity1
  = \ (@ b_abIXT) (@ a_abIXS) (x_X9DoW :: a_abIXS) _ [Occ=Dead] ->
      x_X9DoW

-- RHS size: {terms: 5, types: 7, coercions: 31, joins: 0/0}
Data.Functor.Identity.$fFunctorIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor Identity
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: Identity
                          Data.Functor.Identity.$fFunctorIdentity2
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R
                                  ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                                  ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R)
                                  :: (forall a b. (a -> b) -> a -> b :: *)
                                     ~R# (forall a b. (a -> b) -> Identity a -> Identity b :: *))
                          (\ (@ a_abIXS) (@ b_abIXT) ->
                             Data.Functor.Identity.$fFunctorIdentity1 @ b_abIXT @ a_abIXS)
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R
                                  ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R)
                                  ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                                  :: (forall a b. a -> b -> a :: *)
                                     ~R# (forall a b. a -> Identity b -> Identity a :: *))]
Data.Functor.Identity.$fFunctorIdentity
  = GHC.Base.C:Functor
      @ Identity
      (Data.Functor.Identity.$fFunctorIdentity2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R)
               :: (forall a b. (a -> b) -> a -> b :: *)
                  ~R# (forall a b. (a -> b) -> Identity a -> Identity b :: *)))
      ((\ (@ a_abIXS) (@ b_abIXT) ->
          Data.Functor.Identity.$fFunctorIdentity1 @ b_abIXT @ a_abIXS)
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a>_R
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R)
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
               :: (forall a b. a -> b -> a :: *)
                  ~R# (forall a b. a -> Identity b -> Identity a :: *)))

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fApplicativeIdentity1
  :: forall a b c. (a -> b -> c) -> a -> b -> c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIX7)
                 (@ b_abIX8)
                 (@ c_abIX9)
                 (v_X45 [Occ=Once] :: a_abIX7 -> b_abIX8 -> c_abIX9) ->
                 v_X45}]
Data.Functor.Identity.$fApplicativeIdentity1
  = \ (@ a_abIX7)
      (@ b_abIX8)
      (@ c_abIX9)
      (v_X45 :: a_abIX7 -> b_abIX8 -> c_abIX9) ->
      v_X45

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fApplicativeIdentity2
  :: forall a b. Identity (a -> b) -> Identity (a -> b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIWX)
                 (@ b_abIWY)
                 (v_X4a [Occ=Once] :: Identity (a_abIWX -> b_abIWY)) ->
                 v_X4a}]
Data.Functor.Identity.$fApplicativeIdentity2
  = \ (@ a_abIWX)
      (@ b_abIWY)
      (v_X4a :: Identity (a_abIWX -> b_abIWY)) ->
      v_X4a

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fApplicativeIdentity3 :: forall a. a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIWR) (v_B1 [Occ=Once] :: a_abIWR) -> v_B1}]
Data.Functor.Identity.$fApplicativeIdentity3
  = \ (@ a_abIWR) (v_B1 :: a_abIWR) -> v_B1

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fApplicativeIdentity_$c*>
  :: forall a b. Identity a -> Identity b -> Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIXm)
                 (@ b_abIXn)
                 _ [Occ=Dead]
                 (a2_ibJeX [Occ=Once] :: Identity b_abIXn) ->
                 a2_ibJeX}]
Data.Functor.Identity.$fApplicativeIdentity_$c*>
  = \ (@ a_abIXm)
      (@ b_abIXn)
      _ [Occ=Dead]
      (a2_ibJeX :: Identity b_abIXn) ->
      a2_ibJeX

-- RHS size: {terms: 7, types: 1, coercions: 67, joins: 0/0}
Data.Functor.Identity.$fApplicativeIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative Identity
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: Identity
                              Data.Functor.Identity.$fFunctorIdentity
                              Data.Functor.Identity.$fApplicativeIdentity3
                              `cast` (forall (a :: <*>_N).
                                      <a>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                                      :: (forall a. a -> a :: *)
                                         ~R# (forall a. a -> Identity a :: *))
                              Data.Functor.Identity.$fApplicativeIdentity2
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <Identity (a -> b)>_R
                                      ->_R Data.Functor.Identity.N:Identity[0]
                                               (Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                                                ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                              <b>_R))
                                      :: (forall a b. Identity (a -> b) -> Identity (a -> b) :: *)
                                         ~R# (forall a b.
                                              Identity (a -> b) -> Identity a -> Identity b :: *))
                              Data.Functor.Identity.$fApplicativeIdentity1
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                                      ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R)
                                      ->_R Sym (Data.Functor.Identity.N:Identity[0] <c>_R)
                                      :: (forall a b c. (a -> b -> c) -> a -> b -> c :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c)
                                              -> Identity a -> Identity b -> Identity c :: *))
                              Data.Functor.Identity.$fApplicativeIdentity_$c*>
                              GHC.Base.const
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                                      ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R)
                                      ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                                      :: (forall a b. a -> b -> a :: *)
                                         ~R# (forall a b.
                                              Identity a -> Identity b -> Identity a :: *))]
Data.Functor.Identity.$fApplicativeIdentity
  = GHC.Base.C:Applicative
      @ Identity
      Data.Functor.Identity.$fFunctorIdentity
      (Data.Functor.Identity.$fApplicativeIdentity3
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
               :: (forall a. a -> a :: *) ~R# (forall a. a -> Identity a :: *)))
      (Data.Functor.Identity.$fApplicativeIdentity2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <Identity (a -> b)>_R
               ->_R Data.Functor.Identity.N:Identity[0]
                        (Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                         ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
               :: (forall a b. Identity (a -> b) -> Identity (a -> b) :: *)
                  ~R# (forall a b.
                       Identity (a -> b) -> Identity a -> Identity b :: *)))
      (Data.Functor.Identity.$fApplicativeIdentity1
       `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
               <a -> b -> c>_R
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R)
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <c>_R)
               :: (forall a b c. (a -> b -> c) -> a -> b -> c :: *)
                  ~R# (forall a b c.
                       (a -> b -> c) -> Identity a -> Identity b -> Identity c :: *)))
      Data.Functor.Identity.$fApplicativeIdentity_$c*>
      (GHC.Base.const
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R)
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
               :: (forall a b. a -> b -> a :: *)
                  ~R# (forall a b. Identity a -> Identity b -> Identity a :: *)))

-- RHS size: {terms: 19, types: 14, coercions: 96, joins: 0/0}
Data.Functor.Identity.$fStorableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Storable a => Storable (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X4s :: Storable a_abHDk) ->
       Foreign.Storable.C:Storable TYPE: Identity a_abHDk
                                   (Foreign.Storable.sizeOf @ a_abHDk v_X4s)
                                   `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                           ->_R <GHC.Types.Int>_R
                                           :: (a_abHDk -> GHC.Types.Int :: *)
                                              ~R# (Identity a_abHDk -> GHC.Types.Int :: *))
                                   (Foreign.Storable.alignment @ a_abHDk v_X4s)
                                   `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                           ->_R <GHC.Types.Int>_R
                                           :: (a_abHDk -> GHC.Types.Int :: *)
                                              ~R# (Identity a_abHDk -> GHC.Types.Int :: *))
                                   (Foreign.Storable.peekElemOff @ a_abHDk v_X4s)
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N
                                                   :: a_abHDk, Identity a_abHDk))_R
                                           ->_R <GHC.Types.Int>_R
                                           ->_R (GHC.Types.IO
                                                   (Sym (Data.Functor.Identity.N:Identity[0]
                                                             <a_abHDk>_R)))_R
                                           :: (GHC.Ptr.Ptr a_abHDk
                                               -> GHC.Types.Int -> GHC.Types.IO a_abHDk :: *)
                                              ~R# (GHC.Ptr.Ptr (Identity a_abHDk)
                                                   -> GHC.Types.Int
                                                   -> GHC.Types.IO (Identity a_abHDk) :: *))
                                   (Foreign.Storable.pokeElemOff @ a_abHDk v_X4s)
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N
                                                   :: a_abHDk, Identity a_abHDk))_R
                                           ->_R <GHC.Types.Int>_R
                                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                         <a_abHDk>_R)
                                           ->_R <GHC.Types.IO ()>_R
                                           :: (GHC.Ptr.Ptr a_abHDk
                                               -> GHC.Types.Int -> a_abHDk -> GHC.Types.IO () :: *)
                                              ~R# (GHC.Ptr.Ptr (Identity a_abHDk)
                                                   -> GHC.Types.Int
                                                   -> Identity a_abHDk
                                                   -> GHC.Types.IO () :: *))
                                   (Foreign.Storable.peekByteOff @ a_abHDk v_X4s)
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <GHC.Types.Int>_R
                                           ->_R (GHC.Types.IO
                                                   (Sym (Data.Functor.Identity.N:Identity[0]
                                                             <a_abHDk>_R)))_R
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> GHC.Types.Int -> GHC.Types.IO a_abHDk :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b
                                                   -> GHC.Types.Int
                                                   -> GHC.Types.IO (Identity a_abHDk) :: *))
                                   (Foreign.Storable.pokeByteOff @ a_abHDk v_X4s)
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <GHC.Types.Int>_R
                                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                         <a_abHDk>_R)
                                           ->_R <GHC.Types.IO ()>_R
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> GHC.Types.Int -> a_abHDk -> GHC.Types.IO () :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b
                                                   -> GHC.Types.Int
                                                   -> Identity a_abHDk
                                                   -> GHC.Types.IO () :: *))
                                   (Foreign.Storable.peek @ a_abHDk v_X4s)
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N
                                                   :: a_abHDk, Identity a_abHDk))_R
                                           ->_R (GHC.Types.IO
                                                   (Sym (Data.Functor.Identity.N:Identity[0]
                                                             <a_abHDk>_R)))_R
                                           :: (GHC.Ptr.Ptr a_abHDk -> GHC.Types.IO a_abHDk :: *)
                                              ~R# (GHC.Ptr.Ptr (Identity a_abHDk)
                                                   -> GHC.Types.IO (Identity a_abHDk) :: *))
                                   (Foreign.Storable.poke @ a_abHDk v_X4s)
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N
                                                   :: a_abHDk, Identity a_abHDk))_R
                                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                         <a_abHDk>_R)
                                           ->_R <GHC.Types.IO ()>_R
                                           :: (GHC.Ptr.Ptr a_abHDk
                                               -> a_abHDk -> GHC.Types.IO () :: *)
                                              ~R# (GHC.Ptr.Ptr (Identity a_abHDk)
                                                   -> Identity a_abHDk -> GHC.Types.IO () :: *))]
Data.Functor.Identity.$fStorableIdentity
  = \ (@ a_abITC) ($dStorable_abITD :: Storable a_abITC) ->
      Foreign.Storable.C:Storable
        @ (Identity a_abITC)
        ((Foreign.Storable.sizeOf @ a_abITC $dStorable_abITD)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abITC>_R)
                 ->_R <GHC.Types.Int>_R
                 :: (a_abITC -> GHC.Types.Int :: *)
                    ~R# (Identity a_abITC -> GHC.Types.Int :: *)))
        ((Foreign.Storable.alignment @ a_abITC $dStorable_abITD)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abITC>_R)
                 ->_R <GHC.Types.Int>_R
                 :: (a_abITC -> GHC.Types.Int :: *)
                    ~R# (Identity a_abITC -> GHC.Types.Int :: *)))
        ((Foreign.Storable.peekElemOff @ a_abITC $dStorable_abITD)
         `cast` ((GHC.Ptr.Ptr
                    Univ(phantom phantom <*>_N :: a_abITC, Identity a_abITC))_R
                 ->_R <GHC.Types.Int>_R
                 ->_R (GHC.Types.IO
                         (Sym (Data.Functor.Identity.N:Identity[0] <a_abITC>_R)))_R
                 :: (GHC.Ptr.Ptr a_abITC
                     -> GHC.Types.Int -> GHC.Types.IO a_abITC :: *)
                    ~R# (GHC.Ptr.Ptr (Identity a_abITC)
                         -> GHC.Types.Int -> GHC.Types.IO (Identity a_abITC) :: *)))
        ((Foreign.Storable.pokeElemOff @ a_abITC $dStorable_abITD)
         `cast` ((GHC.Ptr.Ptr
                    Univ(phantom phantom <*>_N :: a_abITC, Identity a_abITC))_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abITC>_R)
                 ->_R <GHC.Types.IO ()>_R
                 :: (GHC.Ptr.Ptr a_abITC
                     -> GHC.Types.Int -> a_abITC -> GHC.Types.IO () :: *)
                    ~R# (GHC.Ptr.Ptr (Identity a_abITC)
                         -> GHC.Types.Int -> Identity a_abITC -> GHC.Types.IO () :: *)))
        ((Foreign.Storable.peekByteOff @ a_abITC $dStorable_abITD)
         `cast` (forall (b :: <*>_N).
                 <GHC.Ptr.Ptr b>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R (GHC.Types.IO
                         (Sym (Data.Functor.Identity.N:Identity[0] <a_abITC>_R)))_R
                 :: (forall b.
                     GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a_abITC :: *)
                    ~R# (forall b.
                         GHC.Ptr.Ptr b
                         -> GHC.Types.Int -> GHC.Types.IO (Identity a_abITC) :: *)))
        ((Foreign.Storable.pokeByteOff @ a_abITC $dStorable_abITD)
         `cast` (forall (b :: <*>_N).
                 <GHC.Ptr.Ptr b>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abITC>_R)
                 ->_R <GHC.Types.IO ()>_R
                 :: (forall b.
                     GHC.Ptr.Ptr b -> GHC.Types.Int -> a_abITC -> GHC.Types.IO () :: *)
                    ~R# (forall b.
                         GHC.Ptr.Ptr b
                         -> GHC.Types.Int -> Identity a_abITC -> GHC.Types.IO () :: *)))
        ((Foreign.Storable.peek @ a_abITC $dStorable_abITD)
         `cast` ((GHC.Ptr.Ptr
                    Univ(phantom phantom <*>_N :: a_abITC, Identity a_abITC))_R
                 ->_R (GHC.Types.IO
                         (Sym (Data.Functor.Identity.N:Identity[0] <a_abITC>_R)))_R
                 :: (GHC.Ptr.Ptr a_abITC -> GHC.Types.IO a_abITC :: *)
                    ~R# (GHC.Ptr.Ptr (Identity a_abITC)
                         -> GHC.Types.IO (Identity a_abITC) :: *)))
        ((Foreign.Storable.poke @ a_abITC $dStorable_abITD)
         `cast` ((GHC.Ptr.Ptr
                    Univ(phantom phantom <*>_N :: a_abITC, Identity a_abITC))_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abITC>_R)
                 ->_R <GHC.Types.IO ()>_R
                 :: (GHC.Ptr.Ptr a_abITC -> a_abITC -> GHC.Types.IO () :: *)
                    ~R# (GHC.Ptr.Ptr (Identity a_abITC)
                         -> Identity a_abITC -> GHC.Types.IO () :: *)))

-- RHS size: {terms: 17, types: 13, coercions: 59, joins: 0/0}
Data.Functor.Identity.$fNumIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Num a => Num (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X51 :: Num a_abHDk) ->
       GHC.Num.C:Num TYPE: Identity a_abHDk
                     (GHC.Num.+ @ a_abHDk v_X51)
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                ~R# (Identity a_abHDk
                                     -> Identity a_abHDk -> Identity a_abHDk :: *))
                     (GHC.Num.- @ a_abHDk v_X51)
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                ~R# (Identity a_abHDk
                                     -> Identity a_abHDk -> Identity a_abHDk :: *))
                     (GHC.Num.* @ a_abHDk v_X51)
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                ~R# (Identity a_abHDk
                                     -> Identity a_abHDk -> Identity a_abHDk :: *))
                     (GHC.Num.negate @ a_abHDk v_X51)
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             :: (a_abHDk -> a_abHDk :: *)
                                ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                     (GHC.Num.abs @ a_abHDk v_X51)
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             :: (a_abHDk -> a_abHDk :: *)
                                ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                     (GHC.Num.signum @ a_abHDk v_X51)
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             :: (a_abHDk -> a_abHDk :: *)
                                ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                     (GHC.Num.fromInteger @ a_abHDk v_X51)
                     `cast` (<integer-simple-0.1.1.1:GHC.Integer.Type.Integer>_R
                             ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                             :: (integer-simple-0.1.1.1:GHC.Integer.Type.Integer
                                 -> a_abHDk :: *)
                                ~R# (integer-simple-0.1.1.1:GHC.Integer.Type.Integer
                                     -> Identity a_abHDk :: *))]
Data.Functor.Identity.$fNumIdentity
  = \ (@ a_abIKV) ($dNum_abIKW :: Num a_abIKV) ->
      GHC.Num.C:Num
        @ (Identity a_abIKV)
        ((GHC.Num.+ @ a_abIKV $dNum_abIKW)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 :: (a_abIKV -> a_abIKV -> a_abIKV :: *)
                    ~R# (Identity a_abIKV
                         -> Identity a_abIKV -> Identity a_abIKV :: *)))
        ((GHC.Num.- @ a_abIKV $dNum_abIKW)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 :: (a_abIKV -> a_abIKV -> a_abIKV :: *)
                    ~R# (Identity a_abIKV
                         -> Identity a_abIKV -> Identity a_abIKV :: *)))
        ((GHC.Num.* @ a_abIKV $dNum_abIKW)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 :: (a_abIKV -> a_abIKV -> a_abIKV :: *)
                    ~R# (Identity a_abIKV
                         -> Identity a_abIKV -> Identity a_abIKV :: *)))
        ((GHC.Num.negate @ a_abIKV $dNum_abIKW)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 :: (a_abIKV -> a_abIKV :: *)
                    ~R# (Identity a_abIKV -> Identity a_abIKV :: *)))
        ((GHC.Num.abs @ a_abIKV $dNum_abIKW)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 :: (a_abIKV -> a_abIKV :: *)
                    ~R# (Identity a_abIKV -> Identity a_abIKV :: *)))
        ((GHC.Num.signum @ a_abIKV $dNum_abIKW)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 :: (a_abIKV -> a_abIKV :: *)
                    ~R# (Identity a_abIKV -> Identity a_abIKV :: *)))
        ((GHC.Num.fromInteger @ a_abIKV $dNum_abIKW)
         `cast` (<integer-simple-0.1.1.1:GHC.Integer.Type.Integer>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKV>_R)
                 :: (integer-simple-0.1.1.1:GHC.Integer.Type.Integer
                     -> a_abIKV :: *)
                    ~R# (integer-simple-0.1.1.1:GHC.Integer.Type.Integer
                         -> Identity a_abIKV :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fRealIdentity_$cp1Real
  :: forall a. Real a => Num (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIOf) ($dReal_abIOg [Occ=Once] :: Real a_abIOf) ->
                 Data.Functor.Identity.$fNumIdentity
                   @ a_abIOf (GHC.Real.$p1Real @ a_abIOf $dReal_abIOg)}]
Data.Functor.Identity.$fRealIdentity_$cp1Real
  = \ (@ a_abIOf) ($dReal_abIOg :: Real a_abIOf) ->
      Data.Functor.Identity.$fNumIdentity
        @ a_abIOf (GHC.Real.$p1Real @ a_abIOf $dReal_abIOg)

-- RHS size: {terms: 9, types: 9, coercions: 34, joins: 0/0}
Data.Functor.Identity.$fSemigroupIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup a => Semigroup (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X59 :: Semigroup a_abHDk) ->
       GHC.Base.C:Semigroup TYPE: Identity a_abHDk
                            (GHC.Base.<> @ a_abHDk v_X59)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk
                                            -> Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Base.sconcat @ a_abHDk v_X59)
                            `cast` ((GHC.Base.NonEmpty
                                       (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)))_R
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (GHC.Base.NonEmpty a_abHDk -> a_abHDk :: *)
                                       ~R# (GHC.Base.NonEmpty (Identity a_abHDk)
                                            -> Identity a_abHDk :: *))
                            (GHC.Base.stimes @ a_abHDk v_X59)
                            `cast` (forall (b :: <*>_N).
                                    <Integral b>_R
                                    ->_R <b>_R
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (forall b. Integral b => b -> a_abHDk -> a_abHDk :: *)
                                       ~R# (forall b.
                                            Integral b =>
                                            b -> Identity a_abHDk -> Identity a_abHDk :: *))]
Data.Functor.Identity.$fSemigroupIdentity
  = \ (@ a_abIJk) ($dSemigroup_abIJl :: Semigroup a_abIJk) ->
      GHC.Base.C:Semigroup
        @ (Identity a_abIJk)
        ((GHC.Base.<> @ a_abIJk $dSemigroup_abIJl)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIJk>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIJk>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIJk>_R)
                 :: (a_abIJk -> a_abIJk -> a_abIJk :: *)
                    ~R# (Identity a_abIJk
                         -> Identity a_abIJk -> Identity a_abIJk :: *)))
        ((GHC.Base.sconcat @ a_abIJk $dSemigroup_abIJl)
         `cast` ((GHC.Base.NonEmpty
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIJk>_R)))_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIJk>_R)
                 :: (GHC.Base.NonEmpty a_abIJk -> a_abIJk :: *)
                    ~R# (GHC.Base.NonEmpty (Identity a_abIJk)
                         -> Identity a_abIJk :: *)))
        ((GHC.Base.stimes @ a_abIJk $dSemigroup_abIJl)
         `cast` (forall (b :: <*>_N).
                 <Integral b>_R
                 ->_R <b>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIJk>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIJk>_R)
                 :: (forall b. Integral b => b -> a_abIJk -> a_abIJk :: *)
                    ~R# (forall b.
                         Integral b =>
                         b -> Identity a_abIJk -> Identity a_abIJk :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid
  :: forall a. Monoid a => Semigroup (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U),A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIKg)
                 ($dMonoid_abIKh [Occ=Once] :: Monoid a_abIKg) ->
                 Data.Functor.Identity.$fSemigroupIdentity
                   @ a_abIKg (GHC.Base.$p1Monoid @ a_abIKg $dMonoid_abIKh)}]
Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid
  = \ (@ a_abIKg) ($dMonoid_abIKh :: Monoid a_abIKg) ->
      Data.Functor.Identity.$fSemigroupIdentity
        @ a_abIKg (GHC.Base.$p1Monoid @ a_abIKg $dMonoid_abIKh)

-- RHS size: {terms: 11, types: 10, coercions: 22, joins: 0/0}
Data.Functor.Identity.$fMonoidIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Monoid a => Monoid (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U),1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X5b :: Monoid a_abHDk) ->
       GHC.Base.C:Monoid TYPE: Identity a_abHDk
                         Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid @ a_abHDk v_X5b
                         (GHC.Base.mempty @ a_abHDk v_X5b)
                         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 :: (a_abHDk :: *) ~R# (Identity a_abHDk :: *))
                         (GHC.Base.mappend @ a_abHDk v_X5b)
                         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                    ~R# (Identity a_abHDk
                                         -> Identity a_abHDk -> Identity a_abHDk :: *))
                         (GHC.Base.mconcat @ a_abHDk v_X5b)
                         `cast` (([Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)])_R
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 :: ([a_abHDk] -> a_abHDk :: *)
                                    ~R# ([Identity a_abHDk] -> Identity a_abHDk :: *))]
Data.Functor.Identity.$fMonoidIdentity
  = \ (@ a_abIKg) ($dMonoid_abIKh :: Monoid a_abIKg) ->
      GHC.Base.C:Monoid
        @ (Identity a_abIKg)
        (Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid
           @ a_abIKg $dMonoid_abIKh)
        ((GHC.Base.mempty @ a_abIKg $dMonoid_abIKh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIKg>_R)
                 :: (a_abIKg :: *) ~R# (Identity a_abIKg :: *)))
        ((GHC.Base.mappend @ a_abIKg $dMonoid_abIKh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIKg>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKg>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKg>_R)
                 :: (a_abIKg -> a_abIKg -> a_abIKg :: *)
                    ~R# (Identity a_abIKg
                         -> Identity a_abIKg -> Identity a_abIKg :: *)))
        ((GHC.Base.mconcat @ a_abIKg $dMonoid_abIKh)
         `cast` (([Sym (Data.Functor.Identity.N:Identity[0] <a_abIKg>_R)])_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIKg>_R)
                 :: ([a_abIKg] -> a_abIKg :: *)
                    ~R# ([Identity a_abIKg] -> Identity a_abIKg :: *)))

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fGeneric1Identity1
  :: forall a.
     GHC.Generics.Rep1 Identity a -> GHC.Generics.Rep1 Identity a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIFI)
                 (ds_dbJeB [Occ=Once] :: GHC.Generics.Rep1 Identity a_abIFI) ->
                 ds_dbJeB}]
Data.Functor.Identity.$fGeneric1Identity1
  = \ (@ a_abIFI) (ds_dbJeB :: GHC.Generics.Rep1 Identity a_abIFI) ->
      ds_dbJeB

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity2
  :: forall a. Identity a -> Identity a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIFi) (x_abIrc [Occ=Once] :: Identity a_abIFi) ->
                 x_abIrc}]
Data.Functor.Identity.$fFoldableIdentity2
  = \ (@ a_abIFi) (x_abIrc :: Identity a_abIFi) -> x_abIrc

-- RHS size: {terms: 3, types: 3, coercions: 163, joins: 0/0}
Data.Functor.Identity.$fGeneric1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic1 Identity
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: Identity
                               Data.Functor.Identity.$fFoldableIdentity2
                               `cast` (forall (a :: <*>_N).
                                       <Identity a>_R
                                       ->_R Data.Functor.Identity.N:Identity[0]
                                                (Sym (GHC.Generics.N:Par1[0]
                                                          <a>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                             <*>_N
                                                                             <GHC.Generics.S>_P
                                                                             <'GHC.Generics.MetaSel
                                                                                ('GHC.Base.Just
                                                                                   "runIdentity")
                                                                                'GHC.Generics.NoSourceUnpackedness
                                                                                'GHC.Generics.NoSourceStrictness
                                                                                'GHC.Generics.DecidedLazy>_P
                                                                             <GHC.Generics.Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                <*>_N
                                                                                                                <GHC.Generics.C>_P
                                                                                                                <'GHC.Generics.MetaCons
                                                                                                                   "Identity"
                                                                                                                   'GHC.Generics.PrefixI
                                                                                                                   'True>_P
                                                                                                                <GHC.Generics.M1
                                                                                                                   GHC.Generics.S
                                                                                                                   ('GHC.Generics.MetaSel
                                                                                                                      ('GHC.Base.Just
                                                                                                                         "runIdentity")
                                                                                                                      'GHC.Generics.NoSourceUnpackedness
                                                                                                                      'GHC.Generics.NoSourceStrictness
                                                                                                                      'GHC.Generics.DecidedLazy)
                                                                                                                   GHC.Generics.Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                     <*>_N
                                                                                                                                                     <GHC.Generics.D>_P
                                                                                                                                                     <'GHC.Generics.MetaData
                                                                                                                                                        "Identity"
                                                                                                                                                        "Data.Functor.Identity"
                                                                                                                                                        "base"
                                                                                                                                                        'True>_P
                                                                                                                                                     <GHC.Generics.M1
                                                                                                                                                        GHC.Generics.C
                                                                                                                                                        ('GHC.Generics.MetaCons
                                                                                                                                                           "Identity"
                                                                                                                                                           'GHC.Generics.PrefixI
                                                                                                                                                           'True)
                                                                                                                                                        (GHC.Generics.M1
                                                                                                                                                           GHC.Generics.S
                                                                                                                                                           ('GHC.Generics.MetaSel
                                                                                                                                                              ('GHC.Base.Just
                                                                                                                                                                 "runIdentity")
                                                                                                                                                              'GHC.Generics.NoSourceUnpackedness
                                                                                                                                                              'GHC.Generics.NoSourceStrictness
                                                                                                                                                              'GHC.Generics.DecidedLazy)
                                                                                                                                                           GHC.Generics.Par1)>_R) ; Sub (Sym (Data.Functor.Identity.Rep1_Identity[0]))))) <a>_N)
                                       :: (forall a. Identity a -> Identity a :: *)
                                          ~R# (forall a.
                                               Identity a -> GHC.Generics.Rep1 Identity a :: *))
                               Data.Functor.Identity.$fGeneric1Identity1
                               `cast` (forall (a :: <*>_N).
                                       <GHC.Generics.Rep1 Identity a>_R
                                       ->_R (Sub (Data.Functor.Identity.Rep1_Identity[0]) ; (GHC.Generics.N:M1[0]
                                                                                                 <*>_N
                                                                                                 <GHC.Generics.D>_P
                                                                                                 <'GHC.Generics.MetaData
                                                                                                    "Identity"
                                                                                                    "Data.Functor.Identity"
                                                                                                    "base"
                                                                                                    'True>_P
                                                                                                 <GHC.Generics.M1
                                                                                                    GHC.Generics.C
                                                                                                    ('GHC.Generics.MetaCons
                                                                                                       "Identity"
                                                                                                       'GHC.Generics.PrefixI
                                                                                                       'True)
                                                                                                    (GHC.Generics.M1
                                                                                                       GHC.Generics.S
                                                                                                       ('GHC.Generics.MetaSel
                                                                                                          ('GHC.Base.Just
                                                                                                             "runIdentity")
                                                                                                          'GHC.Generics.NoSourceUnpackedness
                                                                                                          'GHC.Generics.NoSourceStrictness
                                                                                                          'GHC.Generics.DecidedLazy)
                                                                                                       GHC.Generics.Par1)>_R ; (GHC.Generics.N:M1[0]
                                                                                                                                    <*>_N
                                                                                                                                    <GHC.Generics.C>_P
                                                                                                                                    <'GHC.Generics.MetaCons
                                                                                                                                       "Identity"
                                                                                                                                       'GHC.Generics.PrefixI
                                                                                                                                       'True>_P
                                                                                                                                    <GHC.Generics.M1
                                                                                                                                       GHC.Generics.S
                                                                                                                                       ('GHC.Generics.MetaSel
                                                                                                                                          ('GHC.Base.Just
                                                                                                                                             "runIdentity")
                                                                                                                                          'GHC.Generics.NoSourceUnpackedness
                                                                                                                                          'GHC.Generics.NoSourceStrictness
                                                                                                                                          'GHC.Generics.DecidedLazy)
                                                                                                                                       GHC.Generics.Par1>_R ; GHC.Generics.N:M1[0]
                                                                                                                                                                  <*>_N
                                                                                                                                                                  <GHC.Generics.S>_P
                                                                                                                                                                  <'GHC.Generics.MetaSel
                                                                                                                                                                     ('GHC.Base.Just
                                                                                                                                                                        "runIdentity")
                                                                                                                                                                     'GHC.Generics.NoSourceUnpackedness
                                                                                                                                                                     'GHC.Generics.NoSourceStrictness
                                                                                                                                                                     'GHC.Generics.DecidedLazy>_P
                                                                                                                                                                  <GHC.Generics.Par1>_R))) <a>_N ; GHC.Generics.N:Par1[0]
                                                                                                                                                                                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                                                                                                                                                                                 <a>_R))
                                       :: (forall a.
                                           GHC.Generics.Rep1 Identity a
                                           -> GHC.Generics.Rep1 Identity a :: *)
                                          ~R# (forall a.
                                               GHC.Generics.Rep1 Identity a -> Identity a :: *))]
Data.Functor.Identity.$fGeneric1Identity
  = GHC.Generics.C:Generic1
      @ *
      @ Identity
      (Data.Functor.Identity.$fFoldableIdentity2
       `cast` (forall (a :: <*>_N).
               <Identity a>_R
               ->_R Data.Functor.Identity.N:Identity[0]
                        (Sym (GHC.Generics.N:Par1[0] <a>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                        <*>_N
                                                                        <GHC.Generics.S>_P
                                                                        <'GHC.Generics.MetaSel
                                                                           ('GHC.Base.Just
                                                                              "runIdentity")
                                                                           'GHC.Generics.NoSourceUnpackedness
                                                                           'GHC.Generics.NoSourceStrictness
                                                                           'GHC.Generics.DecidedLazy>_P
                                                                        <GHC.Generics.Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                           <*>_N
                                                                                                           <GHC.Generics.C>_P
                                                                                                           <'GHC.Generics.MetaCons
                                                                                                              "Identity"
                                                                                                              'GHC.Generics.PrefixI
                                                                                                              'True>_P
                                                                                                           <GHC.Generics.M1
                                                                                                              GHC.Generics.S
                                                                                                              ('GHC.Generics.MetaSel
                                                                                                                 ('GHC.Base.Just
                                                                                                                    "runIdentity")
                                                                                                                 'GHC.Generics.NoSourceUnpackedness
                                                                                                                 'GHC.Generics.NoSourceStrictness
                                                                                                                 'GHC.Generics.DecidedLazy)
                                                                                                              GHC.Generics.Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                <*>_N
                                                                                                                                                <GHC.Generics.D>_P
                                                                                                                                                <'GHC.Generics.MetaData
                                                                                                                                                   "Identity"
                                                                                                                                                   "Data.Functor.Identity"
                                                                                                                                                   "base"
                                                                                                                                                   'True>_P
                                                                                                                                                <GHC.Generics.M1
                                                                                                                                                   GHC.Generics.C
                                                                                                                                                   ('GHC.Generics.MetaCons
                                                                                                                                                      "Identity"
                                                                                                                                                      'GHC.Generics.PrefixI
                                                                                                                                                      'True)
                                                                                                                                                   (GHC.Generics.M1
                                                                                                                                                      GHC.Generics.S
                                                                                                                                                      ('GHC.Generics.MetaSel
                                                                                                                                                         ('GHC.Base.Just
                                                                                                                                                            "runIdentity")
                                                                                                                                                         'GHC.Generics.NoSourceUnpackedness
                                                                                                                                                         'GHC.Generics.NoSourceStrictness
                                                                                                                                                         'GHC.Generics.DecidedLazy)
                                                                                                                                                      GHC.Generics.Par1)>_R) ; Sub (Sym (Data.Functor.Identity.Rep1_Identity[0]))))) <a>_N)
               :: (forall a. Identity a -> Identity a :: *)
                  ~R# (forall a. Identity a -> GHC.Generics.Rep1 Identity a :: *)))
      (Data.Functor.Identity.$fGeneric1Identity1
       `cast` (forall (a :: <*>_N).
               <GHC.Generics.Rep1 Identity a>_R
               ->_R (Sub (Data.Functor.Identity.Rep1_Identity[0]) ; (GHC.Generics.N:M1[0]
                                                                         <*>_N
                                                                         <GHC.Generics.D>_P
                                                                         <'GHC.Generics.MetaData
                                                                            "Identity"
                                                                            "Data.Functor.Identity"
                                                                            "base"
                                                                            'True>_P
                                                                         <GHC.Generics.M1
                                                                            GHC.Generics.C
                                                                            ('GHC.Generics.MetaCons
                                                                               "Identity"
                                                                               'GHC.Generics.PrefixI
                                                                               'True)
                                                                            (GHC.Generics.M1
                                                                               GHC.Generics.S
                                                                               ('GHC.Generics.MetaSel
                                                                                  ('GHC.Base.Just
                                                                                     "runIdentity")
                                                                                  'GHC.Generics.NoSourceUnpackedness
                                                                                  'GHC.Generics.NoSourceStrictness
                                                                                  'GHC.Generics.DecidedLazy)
                                                                               GHC.Generics.Par1)>_R ; (GHC.Generics.N:M1[0]
                                                                                                            <*>_N
                                                                                                            <GHC.Generics.C>_P
                                                                                                            <'GHC.Generics.MetaCons
                                                                                                               "Identity"
                                                                                                               'GHC.Generics.PrefixI
                                                                                                               'True>_P
                                                                                                            <GHC.Generics.M1
                                                                                                               GHC.Generics.S
                                                                                                               ('GHC.Generics.MetaSel
                                                                                                                  ('GHC.Base.Just
                                                                                                                     "runIdentity")
                                                                                                                  'GHC.Generics.NoSourceUnpackedness
                                                                                                                  'GHC.Generics.NoSourceStrictness
                                                                                                                  'GHC.Generics.DecidedLazy)
                                                                                                               GHC.Generics.Par1>_R ; GHC.Generics.N:M1[0]
                                                                                                                                          <*>_N
                                                                                                                                          <GHC.Generics.S>_P
                                                                                                                                          <'GHC.Generics.MetaSel
                                                                                                                                             ('GHC.Base.Just
                                                                                                                                                "runIdentity")
                                                                                                                                             'GHC.Generics.NoSourceUnpackedness
                                                                                                                                             'GHC.Generics.NoSourceStrictness
                                                                                                                                             'GHC.Generics.DecidedLazy>_P
                                                                                                                                          <GHC.Generics.Par1>_R))) <a>_N ; GHC.Generics.N:Par1[0]
                                                                                                                                                                               (Sym (Data.Functor.Identity.N:Identity[0]
                                                                                                                                                                                         <a>_R))
               :: (forall a.
                   GHC.Generics.Rep1 Identity a -> GHC.Generics.Rep1 Identity a :: *)
                  ~R# (forall a. GHC.Generics.Rep1 Identity a -> Identity a :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fGenericIdentity1
  :: forall a x.
     GHC.Generics.Rep (Identity a) x -> GHC.Generics.Rep (Identity a) x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIEg)
                 (@ x_abIEM)
                 (ds_dbJev [Occ=Once]
                    :: GHC.Generics.Rep (Identity a_abIEg) x_abIEM) ->
                 ds_dbJev}]
Data.Functor.Identity.$fGenericIdentity1
  = \ (@ a_abIEg)
      (@ x_abIEM)
      (ds_dbJev :: GHC.Generics.Rep (Identity a_abIEg) x_abIEM) ->
      ds_dbJev

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fGenericIdentity2
  :: forall a x. Identity a -> Identity a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_XbIJR)
                 (@ x_abIEk)
                 (x1_abIr8 [Occ=Once] :: Identity a_XbIJR) ->
                 x1_abIr8}]
Data.Functor.Identity.$fGenericIdentity2
  = \ (@ a_XbIJR) (@ x_abIEk) (x1_abIr8 :: Identity a_XbIJR) ->
      x1_abIr8

-- RHS size: {terms: 4, types: 6, coercions: 199, joins: 0/0}
Data.Functor.Identity.$fGenericIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Generic (Identity a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_abHDk) ->
       GHC.Generics.C:Generic TYPE: Identity a_abHDk
                              (Data.Functor.Identity.$fGenericIdentity2 @ a_abHDk)
                              `cast` (forall (x :: <*>_N).
                                      <Identity a_abHDk>_R
                                      ->_R Data.Functor.Identity.N:Identity[0]
                                               (Sym (GHC.Generics.N:K1[0]
                                                         <*>_N
                                                         <GHC.Generics.R>_P
                                                         <a_abHDk>_R
                                                         <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                            <*>_N
                                                                            <GHC.Generics.S>_P
                                                                            <'GHC.Generics.MetaSel
                                                                               ('GHC.Base.Just
                                                                                  "runIdentity")
                                                                               'GHC.Generics.NoSourceUnpackedness
                                                                               'GHC.Generics.NoSourceStrictness
                                                                               'GHC.Generics.DecidedLazy>_P
                                                                            <GHC.Generics.K1
                                                                               GHC.Generics.R
                                                                               a_abHDk>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                       <*>_N
                                                                                                       <GHC.Generics.C>_P
                                                                                                       <'GHC.Generics.MetaCons
                                                                                                          "Identity"
                                                                                                          'GHC.Generics.PrefixI
                                                                                                          'True>_P
                                                                                                       <GHC.Generics.M1
                                                                                                          GHC.Generics.S
                                                                                                          ('GHC.Generics.MetaSel
                                                                                                             ('GHC.Base.Just
                                                                                                                "runIdentity")
                                                                                                             'GHC.Generics.NoSourceUnpackedness
                                                                                                             'GHC.Generics.NoSourceStrictness
                                                                                                             'GHC.Generics.DecidedLazy)
                                                                                                          (GHC.Generics.K1
                                                                                                             GHC.Generics.R
                                                                                                             a_abHDk)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                      <*>_N
                                                                                                                                      <GHC.Generics.D>_P
                                                                                                                                      <'GHC.Generics.MetaData
                                                                                                                                         "Identity"
                                                                                                                                         "Data.Functor.Identity"
                                                                                                                                         "base"
                                                                                                                                         'True>_P
                                                                                                                                      <GHC.Generics.M1
                                                                                                                                         GHC.Generics.C
                                                                                                                                         ('GHC.Generics.MetaCons
                                                                                                                                            "Identity"
                                                                                                                                            'GHC.Generics.PrefixI
                                                                                                                                            'True)
                                                                                                                                         (GHC.Generics.M1
                                                                                                                                            GHC.Generics.S
                                                                                                                                            ('GHC.Generics.MetaSel
                                                                                                                                               ('GHC.Base.Just
                                                                                                                                                  "runIdentity")
                                                                                                                                               'GHC.Generics.NoSourceUnpackedness
                                                                                                                                               'GHC.Generics.NoSourceStrictness
                                                                                                                                               'GHC.Generics.DecidedLazy)
                                                                                                                                            (GHC.Generics.K1
                                                                                                                                               GHC.Generics.R
                                                                                                                                               a_abHDk))>_R) ; Sub (Sym (Data.Functor.Identity.Rep_Identity[0]
                                                                                                                                                                             <a_abHDk>_N))))) <x>_N)
                                      :: (forall x. Identity a_abHDk -> Identity a_abHDk :: *)
                                         ~R# (forall x.
                                              Identity a_abHDk
                                              -> GHC.Generics.Rep (Identity a_abHDk) x :: *))
                              (Data.Functor.Identity.$fGenericIdentity1 @ a_abHDk)
                              `cast` (forall (x :: <*>_N).
                                      <GHC.Generics.Rep (Identity a_abHDk) x>_R
                                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                    (Sym (GHC.Generics.N:K1[0]
                                                              <*>_N
                                                              <GHC.Generics.R>_P
                                                              <a_abHDk>_R
                                                              <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                 <*>_N
                                                                                 <GHC.Generics.S>_P
                                                                                 <'GHC.Generics.MetaSel
                                                                                    ('GHC.Base.Just
                                                                                       "runIdentity")
                                                                                    'GHC.Generics.NoSourceUnpackedness
                                                                                    'GHC.Generics.NoSourceStrictness
                                                                                    'GHC.Generics.DecidedLazy>_P
                                                                                 <GHC.Generics.K1
                                                                                    GHC.Generics.R
                                                                                    a_abHDk>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                            <*>_N
                                                                                                            <GHC.Generics.C>_P
                                                                                                            <'GHC.Generics.MetaCons
                                                                                                               "Identity"
                                                                                                               'GHC.Generics.PrefixI
                                                                                                               'True>_P
                                                                                                            <GHC.Generics.M1
                                                                                                               GHC.Generics.S
                                                                                                               ('GHC.Generics.MetaSel
                                                                                                                  ('GHC.Base.Just
                                                                                                                     "runIdentity")
                                                                                                                  'GHC.Generics.NoSourceUnpackedness
                                                                                                                  'GHC.Generics.NoSourceStrictness
                                                                                                                  'GHC.Generics.DecidedLazy)
                                                                                                               (GHC.Generics.K1
                                                                                                                  GHC.Generics.R
                                                                                                                  a_abHDk)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                           <*>_N
                                                                                                                                           <GHC.Generics.D>_P
                                                                                                                                           <'GHC.Generics.MetaData
                                                                                                                                              "Identity"
                                                                                                                                              "Data.Functor.Identity"
                                                                                                                                              "base"
                                                                                                                                              'True>_P
                                                                                                                                           <GHC.Generics.M1
                                                                                                                                              GHC.Generics.C
                                                                                                                                              ('GHC.Generics.MetaCons
                                                                                                                                                 "Identity"
                                                                                                                                                 'GHC.Generics.PrefixI
                                                                                                                                                 'True)
                                                                                                                                              (GHC.Generics.M1
                                                                                                                                                 GHC.Generics.S
                                                                                                                                                 ('GHC.Generics.MetaSel
                                                                                                                                                    ('GHC.Base.Just
                                                                                                                                                       "runIdentity")
                                                                                                                                                    'GHC.Generics.NoSourceUnpackedness
                                                                                                                                                    'GHC.Generics.NoSourceStrictness
                                                                                                                                                    'GHC.Generics.DecidedLazy)
                                                                                                                                                 (GHC.Generics.K1
                                                                                                                                                    GHC.Generics.R
                                                                                                                                                    a_abHDk))>_R) ; Sub (Sym (Data.Functor.Identity.Rep_Identity[0]
                                                                                                                                                                                  <a_abHDk>_N))))) <x>_N))
                                      :: (forall x.
                                          GHC.Generics.Rep (Identity a_abHDk) x
                                          -> GHC.Generics.Rep (Identity a_abHDk) x :: *)
                                         ~R# (forall x.
                                              GHC.Generics.Rep (Identity a_abHDk) x
                                              -> Identity a_abHDk :: *))]
Data.Functor.Identity.$fGenericIdentity
  = \ (@ a_XbIJW) ->
      GHC.Generics.C:Generic
        @ (Identity a_XbIJW)
        ((Data.Functor.Identity.$fGenericIdentity2 @ a_XbIJW)
         `cast` (forall (x :: <*>_N).
                 <Identity a_XbIJW>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          (Sym (GHC.Generics.N:K1[0]
                                    <*>_N
                                    <GHC.Generics.R>_P
                                    <a_XbIJW>_R
                                    <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                       <*>_N
                                                       <GHC.Generics.S>_P
                                                       <'GHC.Generics.MetaSel
                                                          ('GHC.Base.Just "runIdentity")
                                                          'GHC.Generics.NoSourceUnpackedness
                                                          'GHC.Generics.NoSourceStrictness
                                                          'GHC.Generics.DecidedLazy>_P
                                                       <GHC.Generics.K1
                                                          GHC.Generics.R
                                                          a_XbIJW>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                  <*>_N
                                                                                  <GHC.Generics.C>_P
                                                                                  <'GHC.Generics.MetaCons
                                                                                     "Identity"
                                                                                     'GHC.Generics.PrefixI
                                                                                     'True>_P
                                                                                  <GHC.Generics.M1
                                                                                     GHC.Generics.S
                                                                                     ('GHC.Generics.MetaSel
                                                                                        ('GHC.Base.Just
                                                                                           "runIdentity")
                                                                                        'GHC.Generics.NoSourceUnpackedness
                                                                                        'GHC.Generics.NoSourceStrictness
                                                                                        'GHC.Generics.DecidedLazy)
                                                                                     (GHC.Generics.K1
                                                                                        GHC.Generics.R
                                                                                        a_XbIJW)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                 <*>_N
                                                                                                                 <GHC.Generics.D>_P
                                                                                                                 <'GHC.Generics.MetaData
                                                                                                                    "Identity"
                                                                                                                    "Data.Functor.Identity"
                                                                                                                    "base"
                                                                                                                    'True>_P
                                                                                                                 <GHC.Generics.M1
                                                                                                                    GHC.Generics.C
                                                                                                                    ('GHC.Generics.MetaCons
                                                                                                                       "Identity"
                                                                                                                       'GHC.Generics.PrefixI
                                                                                                                       'True)
                                                                                                                    (GHC.Generics.M1
                                                                                                                       GHC.Generics.S
                                                                                                                       ('GHC.Generics.MetaSel
                                                                                                                          ('GHC.Base.Just
                                                                                                                             "runIdentity")
                                                                                                                          'GHC.Generics.NoSourceUnpackedness
                                                                                                                          'GHC.Generics.NoSourceStrictness
                                                                                                                          'GHC.Generics.DecidedLazy)
                                                                                                                       (GHC.Generics.K1
                                                                                                                          GHC.Generics.R
                                                                                                                          a_XbIJW))>_R) ; Sub (Sym (Data.Functor.Identity.Rep_Identity[0]
                                                                                                                                                        <a_XbIJW>_N))))) <x>_N)
                 :: (forall x. Identity a_XbIJW -> Identity a_XbIJW :: *)
                    ~R# (forall x.
                         Identity a_XbIJW -> GHC.Generics.Rep (Identity a_XbIJW) x :: *)))
        ((Data.Functor.Identity.$fGenericIdentity1 @ a_XbIJW)
         `cast` (forall (x :: <*>_N).
                 <GHC.Generics.Rep (Identity a_XbIJW) x>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               (Sym (GHC.Generics.N:K1[0]
                                         <*>_N
                                         <GHC.Generics.R>_P
                                         <a_XbIJW>_R
                                         <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                            <*>_N
                                                            <GHC.Generics.S>_P
                                                            <'GHC.Generics.MetaSel
                                                               ('GHC.Base.Just "runIdentity")
                                                               'GHC.Generics.NoSourceUnpackedness
                                                               'GHC.Generics.NoSourceStrictness
                                                               'GHC.Generics.DecidedLazy>_P
                                                            <GHC.Generics.K1
                                                               GHC.Generics.R
                                                               a_XbIJW>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                       <*>_N
                                                                                       <GHC.Generics.C>_P
                                                                                       <'GHC.Generics.MetaCons
                                                                                          "Identity"
                                                                                          'GHC.Generics.PrefixI
                                                                                          'True>_P
                                                                                       <GHC.Generics.M1
                                                                                          GHC.Generics.S
                                                                                          ('GHC.Generics.MetaSel
                                                                                             ('GHC.Base.Just
                                                                                                "runIdentity")
                                                                                             'GHC.Generics.NoSourceUnpackedness
                                                                                             'GHC.Generics.NoSourceStrictness
                                                                                             'GHC.Generics.DecidedLazy)
                                                                                          (GHC.Generics.K1
                                                                                             GHC.Generics.R
                                                                                             a_XbIJW)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                      <*>_N
                                                                                                                      <GHC.Generics.D>_P
                                                                                                                      <'GHC.Generics.MetaData
                                                                                                                         "Identity"
                                                                                                                         "Data.Functor.Identity"
                                                                                                                         "base"
                                                                                                                         'True>_P
                                                                                                                      <GHC.Generics.M1
                                                                                                                         GHC.Generics.C
                                                                                                                         ('GHC.Generics.MetaCons
                                                                                                                            "Identity"
                                                                                                                            'GHC.Generics.PrefixI
                                                                                                                            'True)
                                                                                                                         (GHC.Generics.M1
                                                                                                                            GHC.Generics.S
                                                                                                                            ('GHC.Generics.MetaSel
                                                                                                                               ('GHC.Base.Just
                                                                                                                                  "runIdentity")
                                                                                                                               'GHC.Generics.NoSourceUnpackedness
                                                                                                                               'GHC.Generics.NoSourceStrictness
                                                                                                                               'GHC.Generics.DecidedLazy)
                                                                                                                            (GHC.Generics.K1
                                                                                                                               GHC.Generics.R
                                                                                                                               a_XbIJW))>_R) ; Sub (Sym (Data.Functor.Identity.Rep_Identity[0]
                                                                                                                                                             <a_XbIJW>_N))))) <x>_N))
                 :: (forall x.
                     GHC.Generics.Rep (Identity a_XbIJW) x
                     -> GHC.Generics.Rep (Identity a_XbIJW) x :: *)
                    ~R# (forall x.
                         GHC.Generics.Rep (Identity a_XbIJW) x -> Identity a_XbIJW :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional
  :: forall a. Fractional a => Num (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIDx)
                 ($dFractional_abIDy [Occ=Once] :: Fractional a_abIDx) ->
                 Data.Functor.Identity.$fNumIdentity
                   @ a_abIDx (GHC.Real.$p1Fractional @ a_abIDx $dFractional_abIDy)}]
Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional
  = \ (@ a_abIDx) ($dFractional_abIDy :: Fractional a_abIDx) ->
      Data.Functor.Identity.$fNumIdentity
        @ a_abIDx (GHC.Real.$p1Fractional @ a_abIDx $dFractional_abIDy)

-- RHS size: {terms: 11, types: 10, coercions: 24, joins: 0/0}
Data.Functor.Identity.$fFractionalIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Fractional a => Fractional (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X5N :: Fractional a_abHDk) ->
       GHC.Real.C:Fractional TYPE: Identity a_abHDk
                             Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional
                               @ a_abHDk v_X5N
                             (GHC.Real./ @ a_abHDk v_X5N)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                        ~R# (Identity a_abHDk
                                             -> Identity a_abHDk -> Identity a_abHDk :: *))
                             (GHC.Real.recip @ a_abHDk v_X5N)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     :: (a_abHDk -> a_abHDk :: *)
                                        ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                             (GHC.Real.fromRational @ a_abHDk v_X5N)
                             `cast` (<GHC.Real.Ratio
                                        integer-simple-0.1.1.1:GHC.Integer.Type.Integer>_R
                                     ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     :: (GHC.Real.Ratio
                                           integer-simple-0.1.1.1:GHC.Integer.Type.Integer
                                         -> a_abHDk :: *)
                                        ~R# (GHC.Real.Ratio
                                               integer-simple-0.1.1.1:GHC.Integer.Type.Integer
                                             -> Identity a_abHDk :: *))]
Data.Functor.Identity.$fFractionalIdentity
  = \ (@ a_abIDx) ($dFractional_abIDy :: Fractional a_abIDx) ->
      GHC.Real.C:Fractional
        @ (Identity a_abIDx)
        (Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional
           @ a_abIDx $dFractional_abIDy)
        ((GHC.Real./ @ a_abIDx $dFractional_abIDy)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIDx>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIDx>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIDx>_R)
                 :: (a_abIDx -> a_abIDx -> a_abIDx :: *)
                    ~R# (Identity a_abIDx
                         -> Identity a_abIDx -> Identity a_abIDx :: *)))
        ((GHC.Real.recip @ a_abIDx $dFractional_abIDy)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIDx>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIDx>_R)
                 :: (a_abIDx -> a_abIDx :: *)
                    ~R# (Identity a_abIDx -> Identity a_abIDx :: *)))
        ((GHC.Real.fromRational @ a_abIDx $dFractional_abIDy)
         `cast` (<GHC.Real.Ratio
                    integer-simple-0.1.1.1:GHC.Integer.Type.Integer>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIDx>_R)
                 :: (GHC.Real.Ratio integer-simple-0.1.1.1:GHC.Integer.Type.Integer
                     -> a_abIDx :: *)
                    ~R# (GHC.Real.Ratio integer-simple-0.1.1.1:GHC.Integer.Type.Integer
                         -> Identity a_abIDx :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac
  :: forall a. RealFrac a => Fractional (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIOC)
                 ($dRealFrac_abIOD [Occ=Once] :: RealFrac a_abIOC) ->
                 Data.Functor.Identity.$fFractionalIdentity
                   @ a_abIOC (GHC.Real.$p2RealFrac @ a_abIOC $dRealFrac_abIOD)}]
Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac
  = \ (@ a_abIOC) ($dRealFrac_abIOD :: RealFrac a_abIOC) ->
      Data.Functor.Identity.$fFractionalIdentity
        @ a_abIOC (GHC.Real.$p2RealFrac @ a_abIOC $dRealFrac_abIOD)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFloatingIdentity_$cp1Floating
  :: forall a. Floating a => Fractional (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIzr)
                 ($dFloating_abIzs [Occ=Once] :: Floating a_abIzr) ->
                 Data.Functor.Identity.$fFractionalIdentity
                   @ a_abIzr (GHC.Float.$p1Floating @ a_abIzr $dFloating_abIzs)}]
Data.Functor.Identity.$fFloatingIdentity_$cp1Floating
  = \ (@ a_abIzr) ($dFloating_abIzs :: Floating a_abIzr) ->
      Data.Functor.Identity.$fFractionalIdentity
        @ a_abIzr (GHC.Float.$p1Floating @ a_abIzr $dFloating_abIzs)

-- RHS size: {terms: 49, types: 29, coercions: 158, joins: 0/0}
Data.Functor.Identity.$fFloatingIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Floating a => Floating (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=DFun: \ (@ a_abHDk) (v_X6c :: Floating a_abHDk) ->
       GHC.Float.C:Floating TYPE: Identity a_abHDk
                            Data.Functor.Identity.$fFloatingIdentity_$cp1Floating
                              @ a_abHDk v_X6c
                            (GHC.Float.pi @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk :: *) ~R# (Identity a_abHDk :: *))
                            (GHC.Float.exp @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.log @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.sqrt @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.** @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk
                                            -> Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.logBase @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk
                                            -> Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.sin @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.cos @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.tan @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.asin @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.acos @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.atan @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.sinh @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.cosh @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.tanh @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.asinh @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.acosh @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.atanh @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.log1p @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.expm1 @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.log1pexp @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                            (GHC.Float.log1mexp @ a_abHDk v_X6c)
                            `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                    :: (a_abHDk -> a_abHDk :: *)
                                       ~R# (Identity a_abHDk -> Identity a_abHDk :: *))]
Data.Functor.Identity.$fFloatingIdentity
  = \ (@ a_abIzr) ($dFloating_abIzs :: Floating a_abIzr) ->
      GHC.Float.C:Floating
        @ (Identity a_abIzr)
        (Data.Functor.Identity.$fFloatingIdentity_$cp1Floating
           @ a_abIzr $dFloating_abIzs)
        ((GHC.Float.pi @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr :: *) ~R# (Identity a_abIzr :: *)))
        ((GHC.Float.exp @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.log @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.sqrt @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.** @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr
                         -> Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.logBase @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr
                         -> Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.sin @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.cos @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.tan @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.asin @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.acos @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.atan @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.sinh @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.cosh @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.tanh @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.asinh @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.acosh @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.atanh @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.log1p @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.expm1 @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.log1pexp @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))
        ((GHC.Float.log1mexp @ a_abIzr $dFloating_abIzs)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIzr>_R)
                 :: (a_abIzr -> a_abIzr :: *)
                    ~R# (Identity a_abIzr -> Identity a_abIzr :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat
  :: forall a. RealFloat a => Floating (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIQK)
                 ($dRealFloat_abIQL [Occ=Once] :: RealFloat a_abIQK) ->
                 Data.Functor.Identity.$fFloatingIdentity
                   @ a_abIQK (GHC.Float.$p2RealFloat @ a_abIQK $dRealFloat_abIQL)}]
Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat
  = \ (@ a_abIQK) ($dRealFloat_abIQL :: RealFloat a_abIQK) ->
      Data.Functor.Identity.$fFloatingIdentity
        @ a_abIQK (GHC.Float.$p2RealFloat @ a_abIQK $dRealFloat_abIQL)

-- RHS size: {terms: 7, types: 8, coercions: 18, joins: 0/0}
Data.Functor.Identity.$fEqIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X6j :: Eq a_abHDk) ->
       GHC.Classes.C:Eq TYPE: Identity a_abHDk
                        (== @ a_abHDk v_X6j)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <Bool>_R
                                :: (a_abHDk -> a_abHDk -> Bool :: *)
                                   ~R# (Identity a_abHDk -> Identity a_abHDk -> Bool :: *))
                        (/= @ a_abHDk v_X6j)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <Bool>_R
                                :: (a_abHDk -> a_abHDk -> Bool :: *)
                                   ~R# (Identity a_abHDk -> Identity a_abHDk -> Bool :: *))]
Data.Functor.Identity.$fEqIdentity
  = \ (@ a_abIye) ($dEq_abIyf :: Eq a_abIye) ->
      GHC.Classes.C:Eq
        @ (Identity a_abIye)
        ((== @ a_abIye $dEq_abIyf)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIye>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIye>_R)
                 ->_R <Bool>_R
                 :: (a_abIye -> a_abIye -> Bool :: *)
                    ~R# (Identity a_abIye -> Identity a_abIye -> Bool :: *)))
        ((/= @ a_abIye $dEq_abIyf)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIye>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIye>_R)
                 ->_R <Bool>_R
                 :: (a_abIye -> a_abIye -> Bool :: *)
                    ~R# (Identity a_abIye -> Identity a_abIye -> Bool :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fOrdIdentity_$cp1Ord
  :: forall a. Ord a => Eq (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIMq) ($dOrd_abIMr [Occ=Once] :: Ord a_abIMq) ->
                 Data.Functor.Identity.$fEqIdentity
                   @ a_abIMq (GHC.Classes.$p1Ord @ a_abIMq $dOrd_abIMr)}]
Data.Functor.Identity.$fOrdIdentity_$cp1Ord
  = \ (@ a_abIMq) ($dOrd_abIMr :: Ord a_abIMq) ->
      Data.Functor.Identity.$fEqIdentity
        @ a_abIMq (GHC.Classes.$p1Ord @ a_abIMq $dOrd_abIMr)

-- RHS size: {terms: 19, types: 14, coercions: 67, joins: 0/0}
Data.Functor.Identity.$fOrdIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X6l :: Ord a_abHDk) ->
       GHC.Classes.C:Ord TYPE: Identity a_abHDk
                         Data.Functor.Identity.$fOrdIdentity_$cp1Ord @ a_abHDk v_X6l
                         (compare @ a_abHDk v_X6l)
                         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R <GHC.Types.Ordering>_R
                                 :: (a_abHDk -> a_abHDk -> GHC.Types.Ordering :: *)
                                    ~R# (Identity a_abHDk
                                         -> Identity a_abHDk -> GHC.Types.Ordering :: *))
                         (< @ a_abHDk v_X6l)
                         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R <Bool>_R
                                 :: (a_abHDk -> a_abHDk -> Bool :: *)
                                    ~R# (Identity a_abHDk -> Identity a_abHDk -> Bool :: *))
                         (<= @ a_abHDk v_X6l)
                         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R <Bool>_R
                                 :: (a_abHDk -> a_abHDk -> Bool :: *)
                                    ~R# (Identity a_abHDk -> Identity a_abHDk -> Bool :: *))
                         (> @ a_abHDk v_X6l)
                         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R <Bool>_R
                                 :: (a_abHDk -> a_abHDk -> Bool :: *)
                                    ~R# (Identity a_abHDk -> Identity a_abHDk -> Bool :: *))
                         (>= @ a_abHDk v_X6l)
                         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R <Bool>_R
                                 :: (a_abHDk -> a_abHDk -> Bool :: *)
                                    ~R# (Identity a_abHDk -> Identity a_abHDk -> Bool :: *))
                         (max @ a_abHDk v_X6l)
                         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                    ~R# (Identity a_abHDk
                                         -> Identity a_abHDk -> Identity a_abHDk :: *))
                         (min @ a_abHDk v_X6l)
                         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                 :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                    ~R# (Identity a_abHDk
                                         -> Identity a_abHDk -> Identity a_abHDk :: *))]
Data.Functor.Identity.$fOrdIdentity
  = \ (@ a_abIMq) ($dOrd_abIMr :: Ord a_abIMq) ->
      GHC.Classes.C:Ord
        @ (Identity a_abIMq)
        (Data.Functor.Identity.$fOrdIdentity_$cp1Ord @ a_abIMq $dOrd_abIMr)
        ((compare @ a_abIMq $dOrd_abIMr)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R <GHC.Types.Ordering>_R
                 :: (a_abIMq -> a_abIMq -> GHC.Types.Ordering :: *)
                    ~R# (Identity a_abIMq
                         -> Identity a_abIMq -> GHC.Types.Ordering :: *)))
        ((< @ a_abIMq $dOrd_abIMr)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R <Bool>_R
                 :: (a_abIMq -> a_abIMq -> Bool :: *)
                    ~R# (Identity a_abIMq -> Identity a_abIMq -> Bool :: *)))
        ((<= @ a_abIMq $dOrd_abIMr)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R <Bool>_R
                 :: (a_abIMq -> a_abIMq -> Bool :: *)
                    ~R# (Identity a_abIMq -> Identity a_abIMq -> Bool :: *)))
        ((> @ a_abIMq $dOrd_abIMr)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R <Bool>_R
                 :: (a_abIMq -> a_abIMq -> Bool :: *)
                    ~R# (Identity a_abIMq -> Identity a_abIMq -> Bool :: *)))
        ((>= @ a_abIMq $dOrd_abIMr)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R <Bool>_R
                 :: (a_abIMq -> a_abIMq -> Bool :: *)
                    ~R# (Identity a_abIMq -> Identity a_abIMq -> Bool :: *)))
        ((max @ a_abIMq $dOrd_abIMr)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 :: (a_abIMq -> a_abIMq -> a_abIMq :: *)
                    ~R# (Identity a_abIMq
                         -> Identity a_abIMq -> Identity a_abIMq :: *)))
        ((min @ a_abIMq $dOrd_abIMr)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIMq>_R)
                 :: (a_abIMq -> a_abIMq -> a_abIMq :: *)
                    ~R# (Identity a_abIMq
                         -> Identity a_abIMq -> Identity a_abIMq :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fIxIdentity_$cp1Ix
  :: forall a. Ix a => Ord (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIHW) ($dIx_abIHX [Occ=Once] :: Ix a_abIHW) ->
                 Data.Functor.Identity.$fOrdIdentity
                   @ a_abIHW (GHC.Arr.$p1Ix @ a_abIHW $dIx_abIHX)}]
Data.Functor.Identity.$fIxIdentity_$cp1Ix
  = \ (@ a_abIHW) ($dIx_abIHX :: Ix a_abIHW) ->
      Data.Functor.Identity.$fOrdIdentity
        @ a_abIHW (GHC.Arr.$p1Ix @ a_abIHW $dIx_abIHX)

-- RHS size: {terms: 17, types: 13, coercions: 69, joins: 0/0}
Data.Functor.Identity.$fIxIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ix a => Ix (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X6n :: Ix a_abHDk) ->
       GHC.Arr.C:Ix TYPE: Identity a_abHDk
                    Data.Functor.Identity.$fIxIdentity_$cp1Ix @ a_abHDk v_X6n
                    (GHC.Arr.range @ a_abHDk v_X6n)
                    `cast` (((,)
                               (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R))
                               (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)))_R
                            ->_R ([Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)])_R
                            :: ((a_abHDk, a_abHDk) -> [a_abHDk] :: *)
                               ~R# ((Identity a_abHDk, Identity a_abHDk)
                                    -> [Identity a_abHDk] :: *))
                    (GHC.Arr.index @ a_abHDk v_X6n)
                    `cast` (((,)
                               (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R))
                               (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)))_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                            ->_R <GHC.Types.Int>_R
                            :: ((a_abHDk, a_abHDk) -> a_abHDk -> GHC.Types.Int :: *)
                               ~R# ((Identity a_abHDk, Identity a_abHDk)
                                    -> Identity a_abHDk -> GHC.Types.Int :: *))
                    (GHC.Arr.unsafeIndex @ a_abHDk v_X6n)
                    `cast` (((,)
                               (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R))
                               (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)))_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                            ->_R <GHC.Types.Int>_R
                            :: ((a_abHDk, a_abHDk) -> a_abHDk -> GHC.Types.Int :: *)
                               ~R# ((Identity a_abHDk, Identity a_abHDk)
                                    -> Identity a_abHDk -> GHC.Types.Int :: *))
                    (GHC.Arr.inRange @ a_abHDk v_X6n)
                    `cast` (((,)
                               (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R))
                               (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)))_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                            ->_R <Bool>_R
                            :: ((a_abHDk, a_abHDk) -> a_abHDk -> Bool :: *)
                               ~R# ((Identity a_abHDk, Identity a_abHDk)
                                    -> Identity a_abHDk -> Bool :: *))
                    (GHC.Arr.rangeSize @ a_abHDk v_X6n)
                    `cast` (((,)
                               (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R))
                               (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)))_R
                            ->_R <GHC.Types.Int>_R
                            :: ((a_abHDk, a_abHDk) -> GHC.Types.Int :: *)
                               ~R# ((Identity a_abHDk, Identity a_abHDk) -> GHC.Types.Int :: *))
                    (GHC.Arr.unsafeRangeSize @ a_abHDk v_X6n)
                    `cast` (((,)
                               (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R))
                               (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)))_R
                            ->_R <GHC.Types.Int>_R
                            :: ((a_abHDk, a_abHDk) -> GHC.Types.Int :: *)
                               ~R# ((Identity a_abHDk, Identity a_abHDk) -> GHC.Types.Int :: *))]
Data.Functor.Identity.$fIxIdentity
  = \ (@ a_abIHW) ($dIx_abIHX :: Ix a_abIHW) ->
      GHC.Arr.C:Ix
        @ (Identity a_abIHW)
        (Data.Functor.Identity.$fIxIdentity_$cp1Ix @ a_abIHW $dIx_abIHX)
        ((GHC.Arr.range @ a_abIHW $dIx_abIHX)
         `cast` (((,)
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R))
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R)))_R
                 ->_R ([Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R)])_R
                 :: ((a_abIHW, a_abIHW) -> [a_abIHW] :: *)
                    ~R# ((Identity a_abIHW, Identity a_abIHW)
                         -> [Identity a_abIHW] :: *)))
        ((GHC.Arr.index @ a_abIHW $dIx_abIHX)
         `cast` (((,)
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R))
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R)))_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R)
                 ->_R <GHC.Types.Int>_R
                 :: ((a_abIHW, a_abIHW) -> a_abIHW -> GHC.Types.Int :: *)
                    ~R# ((Identity a_abIHW, Identity a_abIHW)
                         -> Identity a_abIHW -> GHC.Types.Int :: *)))
        ((GHC.Arr.unsafeIndex @ a_abIHW $dIx_abIHX)
         `cast` (((,)
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R))
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R)))_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R)
                 ->_R <GHC.Types.Int>_R
                 :: ((a_abIHW, a_abIHW) -> a_abIHW -> GHC.Types.Int :: *)
                    ~R# ((Identity a_abIHW, Identity a_abIHW)
                         -> Identity a_abIHW -> GHC.Types.Int :: *)))
        ((GHC.Arr.inRange @ a_abIHW $dIx_abIHX)
         `cast` (((,)
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R))
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R)))_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R)
                 ->_R <Bool>_R
                 :: ((a_abIHW, a_abIHW) -> a_abIHW -> Bool :: *)
                    ~R# ((Identity a_abIHW, Identity a_abIHW)
                         -> Identity a_abIHW -> Bool :: *)))
        ((GHC.Arr.rangeSize @ a_abIHW $dIx_abIHX)
         `cast` (((,)
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R))
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R)))_R
                 ->_R <GHC.Types.Int>_R
                 :: ((a_abIHW, a_abIHW) -> GHC.Types.Int :: *)
                    ~R# ((Identity a_abIHW, Identity a_abIHW) -> GHC.Types.Int :: *)))
        ((GHC.Arr.unsafeRangeSize @ a_abIHW $dIx_abIHX)
         `cast` (((,)
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R))
                    (Sym (Data.Functor.Identity.N:Identity[0] <a_abIHW>_R)))_R
                 ->_R <GHC.Types.Int>_R
                 :: ((a_abIHW, a_abIHW) -> GHC.Types.Int :: *)
                    ~R# ((Identity a_abIHW, Identity a_abIHW) -> GHC.Types.Int :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fRealIdentity_$cp2Real
  :: forall a. Real a => Ord (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIOf) ($dReal_abIOg [Occ=Once] :: Real a_abIOf) ->
                 Data.Functor.Identity.$fOrdIdentity
                   @ a_abIOf (GHC.Real.$p2Real @ a_abIOf $dReal_abIOg)}]
Data.Functor.Identity.$fRealIdentity_$cp2Real
  = \ (@ a_abIOf) ($dReal_abIOg :: Real a_abIOf) ->
      Data.Functor.Identity.$fOrdIdentity
        @ a_abIOf (GHC.Real.$p2Real @ a_abIOf $dReal_abIOg)

-- RHS size: {terms: 9, types: 9, coercions: 6, joins: 0/0}
Data.Functor.Identity.$fRealIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Real a => Real (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X6p :: Real a_abHDk) ->
       GHC.Real.C:Real TYPE: Identity a_abHDk
                       Data.Functor.Identity.$fRealIdentity_$cp1Real @ a_abHDk v_X6p
                       Data.Functor.Identity.$fRealIdentity_$cp2Real @ a_abHDk v_X6p
                       (GHC.Real.toRational @ a_abHDk v_X6p)
                       `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               ->_R <GHC.Real.Ratio
                                       integer-simple-0.1.1.1:GHC.Integer.Type.Integer>_R
                               :: (a_abHDk
                                   -> GHC.Real.Ratio
                                        integer-simple-0.1.1.1:GHC.Integer.Type.Integer :: *)
                                  ~R# (Identity a_abHDk
                                       -> GHC.Real.Ratio
                                            integer-simple-0.1.1.1:GHC.Integer.Type.Integer :: *))]
Data.Functor.Identity.$fRealIdentity
  = \ (@ a_abIOf) ($dReal_abIOg :: Real a_abIOf) ->
      GHC.Real.C:Real
        @ (Identity a_abIOf)
        (Data.Functor.Identity.$fRealIdentity_$cp1Real
           @ a_abIOf $dReal_abIOg)
        (Data.Functor.Identity.$fRealIdentity_$cp2Real
           @ a_abIOf $dReal_abIOg)
        ((GHC.Real.toRational @ a_abIOf $dReal_abIOg)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIOf>_R)
                 ->_R <GHC.Real.Ratio
                         integer-simple-0.1.1.1:GHC.Integer.Type.Integer>_R
                 :: (a_abIOf
                     -> GHC.Real.Ratio
                          integer-simple-0.1.1.1:GHC.Integer.Type.Integer :: *)
                    ~R# (Identity a_abIOf
                         -> GHC.Real.Ratio
                              integer-simple-0.1.1.1:GHC.Integer.Type.Integer :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fIntegralIdentity_$cp1Integral
  :: forall a. Integral a => Real (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),A,A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIG7)
                 ($dIntegral_abIG8 [Occ=Once] :: Integral a_abIG7) ->
                 Data.Functor.Identity.$fRealIdentity
                   @ a_abIG7 (GHC.Real.$p1Integral @ a_abIG7 $dIntegral_abIG8)}]
Data.Functor.Identity.$fIntegralIdentity_$cp1Integral
  = \ (@ a_abIG7) ($dIntegral_abIG8 :: Integral a_abIG7) ->
      Data.Functor.Identity.$fRealIdentity
        @ a_abIG7 (GHC.Real.$p1Integral @ a_abIG7 $dIntegral_abIG8)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac
  :: forall a. RealFrac a => Real (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIOC)
                 ($dRealFrac_abIOD [Occ=Once] :: RealFrac a_abIOC) ->
                 Data.Functor.Identity.$fRealIdentity
                   @ a_abIOC (GHC.Real.$p1RealFrac @ a_abIOC $dRealFrac_abIOD)}]
Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac
  = \ (@ a_abIOC) ($dRealFrac_abIOD :: RealFrac a_abIOC) ->
      Data.Functor.Identity.$fRealIdentity
        @ a_abIOC (GHC.Real.$p1RealFrac @ a_abIOC $dRealFrac_abIOD)

-- RHS size: {terms: 17, types: 13, coercions: 59, joins: 0/0}
Data.Functor.Identity.$fRealFracIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. RealFrac a => RealFrac (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X6s :: RealFrac a_abHDk) ->
       GHC.Real.C:RealFrac TYPE: Identity a_abHDk
                           Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac
                             @ a_abHDk v_X6s
                           Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac
                             @ a_abHDk v_X6s
                           (GHC.Real.properFraction @ a_abHDk v_X6s)
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R ((,)
                                           <b>_R
                                           (Sym (Data.Functor.Identity.N:Identity[0]
                                                     <a_abHDk>_R)))_R
                                   :: (forall b. Integral b => a_abHDk -> (b, a_abHDk) :: *)
                                      ~R# (forall b.
                                           Integral b =>
                                           Identity a_abHDk -> (b, Identity a_abHDk) :: *))
                           (GHC.Real.truncate @ a_abHDk v_X6s)
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R <b>_R
                                   :: (forall b. Integral b => a_abHDk -> b :: *)
                                      ~R# (forall b. Integral b => Identity a_abHDk -> b :: *))
                           (GHC.Real.round @ a_abHDk v_X6s)
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R <b>_R
                                   :: (forall b. Integral b => a_abHDk -> b :: *)
                                      ~R# (forall b. Integral b => Identity a_abHDk -> b :: *))
                           (GHC.Real.ceiling @ a_abHDk v_X6s)
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R <b>_R
                                   :: (forall b. Integral b => a_abHDk -> b :: *)
                                      ~R# (forall b. Integral b => Identity a_abHDk -> b :: *))
                           (GHC.Real.floor @ a_abHDk v_X6s)
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R <b>_R
                                   :: (forall b. Integral b => a_abHDk -> b :: *)
                                      ~R# (forall b. Integral b => Identity a_abHDk -> b :: *))]
Data.Functor.Identity.$fRealFracIdentity
  = \ (@ a_abIOC) ($dRealFrac_abIOD :: RealFrac a_abIOC) ->
      GHC.Real.C:RealFrac
        @ (Identity a_abIOC)
        (Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac
           @ a_abIOC $dRealFrac_abIOD)
        (Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac
           @ a_abIOC $dRealFrac_abIOD)
        ((GHC.Real.properFraction @ a_abIOC $dRealFrac_abIOD)
         `cast` (forall (b :: <*>_N).
                 <Integral b>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIOC>_R)
                 ->_R ((,)
                         <b>_R (Sym (Data.Functor.Identity.N:Identity[0] <a_abIOC>_R)))_R
                 :: (forall b. Integral b => a_abIOC -> (b, a_abIOC) :: *)
                    ~R# (forall b.
                         Integral b =>
                         Identity a_abIOC -> (b, Identity a_abIOC) :: *)))
        ((GHC.Real.truncate @ a_abIOC $dRealFrac_abIOD)
         `cast` (forall (b :: <*>_N).
                 <Integral b>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIOC>_R)
                 ->_R <b>_R
                 :: (forall b. Integral b => a_abIOC -> b :: *)
                    ~R# (forall b. Integral b => Identity a_abIOC -> b :: *)))
        ((GHC.Real.round @ a_abIOC $dRealFrac_abIOD)
         `cast` (forall (b :: <*>_N).
                 <Integral b>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIOC>_R)
                 ->_R <b>_R
                 :: (forall b. Integral b => a_abIOC -> b :: *)
                    ~R# (forall b. Integral b => Identity a_abIOC -> b :: *)))
        ((GHC.Real.ceiling @ a_abIOC $dRealFrac_abIOD)
         `cast` (forall (b :: <*>_N).
                 <Integral b>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIOC>_R)
                 ->_R <b>_R
                 :: (forall b. Integral b => a_abIOC -> b :: *)
                    ~R# (forall b. Integral b => Identity a_abIOC -> b :: *)))
        ((GHC.Real.floor @ a_abIOC $dRealFrac_abIOD)
         `cast` (forall (b :: <*>_N).
                 <Integral b>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIOC>_R)
                 ->_R <b>_R
                 :: (forall b. Integral b => a_abIOC -> b :: *)
                    ~R# (forall b. Integral b => Identity a_abIOC -> b :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat
  :: forall a. RealFloat a => RealFrac (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIQK)
                 ($dRealFloat_abIQL [Occ=Once] :: RealFloat a_abIQK) ->
                 Data.Functor.Identity.$fRealFracIdentity
                   @ a_abIQK (GHC.Float.$p1RealFloat @ a_abIQK $dRealFloat_abIQL)}]
Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat
  = \ (@ a_abIQK) ($dRealFloat_abIQL :: RealFloat a_abIQK) ->
      Data.Functor.Identity.$fRealFracIdentity
        @ a_abIQK (GHC.Float.$p1RealFloat @ a_abIQK $dRealFloat_abIQL)

-- RHS size: {terms: 35, types: 22, coercions: 88, joins: 0/0}
Data.Functor.Identity.$fRealFloatIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. RealFloat a => RealFloat (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=DFun: \ (@ a_abHDk) (v_X6u :: RealFloat a_abHDk) ->
       GHC.Float.C:RealFloat TYPE: Identity a_abHDk
                             Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat
                               @ a_abHDk v_X6u
                             Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat
                               @ a_abHDk v_X6u
                             (GHC.Float.floatRadix @ a_abHDk v_X6u)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R <integer-simple-0.1.1.1:GHC.Integer.Type.Integer>_R
                                     :: (a_abHDk
                                         -> integer-simple-0.1.1.1:GHC.Integer.Type.Integer :: *)
                                        ~R# (Identity a_abHDk
                                             -> integer-simple-0.1.1.1:GHC.Integer.Type.Integer :: *))
                             (GHC.Float.floatDigits @ a_abHDk v_X6u)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R <GHC.Types.Int>_R
                                     :: (a_abHDk -> GHC.Types.Int :: *)
                                        ~R# (Identity a_abHDk -> GHC.Types.Int :: *))
                             (GHC.Float.floatRange @ a_abHDk v_X6u)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R <(GHC.Types.Int, GHC.Types.Int)>_R
                                     :: (a_abHDk -> (GHC.Types.Int, GHC.Types.Int) :: *)
                                        ~R# (Identity a_abHDk
                                             -> (GHC.Types.Int, GHC.Types.Int) :: *))
                             (GHC.Float.decodeFloat @ a_abHDk v_X6u)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R <(integer-simple-0.1.1.1:GHC.Integer.Type.Integer,
                                            GHC.Types.Int)>_R
                                     :: (a_abHDk
                                         -> (integer-simple-0.1.1.1:GHC.Integer.Type.Integer,
                                             GHC.Types.Int) :: *)
                                        ~R# (Identity a_abHDk
                                             -> (integer-simple-0.1.1.1:GHC.Integer.Type.Integer,
                                                 GHC.Types.Int) :: *))
                             (GHC.Float.encodeFloat @ a_abHDk v_X6u)
                             `cast` (<integer-simple-0.1.1.1:GHC.Integer.Type.Integer>_R
                                     ->_R <GHC.Types.Int>_R
                                     ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     :: (integer-simple-0.1.1.1:GHC.Integer.Type.Integer
                                         -> GHC.Types.Int -> a_abHDk :: *)
                                        ~R# (integer-simple-0.1.1.1:GHC.Integer.Type.Integer
                                             -> GHC.Types.Int -> Identity a_abHDk :: *))
                             (GHC.Float.exponent @ a_abHDk v_X6u)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R <GHC.Types.Int>_R
                                     :: (a_abHDk -> GHC.Types.Int :: *)
                                        ~R# (Identity a_abHDk -> GHC.Types.Int :: *))
                             (GHC.Float.significand @ a_abHDk v_X6u)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     :: (a_abHDk -> a_abHDk :: *)
                                        ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                             (GHC.Float.scaleFloat @ a_abHDk v_X6u)
                             `cast` (<GHC.Types.Int>_R
                                     ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     :: (GHC.Types.Int -> a_abHDk -> a_abHDk :: *)
                                        ~R# (GHC.Types.Int
                                             -> Identity a_abHDk -> Identity a_abHDk :: *))
                             (GHC.Float.isNaN @ a_abHDk v_X6u)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R <Bool>_R
                                     :: (a_abHDk -> Bool :: *) ~R# (Identity a_abHDk -> Bool :: *))
                             (GHC.Float.isInfinite @ a_abHDk v_X6u)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R <Bool>_R
                                     :: (a_abHDk -> Bool :: *) ~R# (Identity a_abHDk -> Bool :: *))
                             (GHC.Float.isDenormalized @ a_abHDk v_X6u)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R <Bool>_R
                                     :: (a_abHDk -> Bool :: *) ~R# (Identity a_abHDk -> Bool :: *))
                             (GHC.Float.isNegativeZero @ a_abHDk v_X6u)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R <Bool>_R
                                     :: (a_abHDk -> Bool :: *) ~R# (Identity a_abHDk -> Bool :: *))
                             (GHC.Float.isIEEE @ a_abHDk v_X6u)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R <Bool>_R
                                     :: (a_abHDk -> Bool :: *) ~R# (Identity a_abHDk -> Bool :: *))
                             (GHC.Float.atan2 @ a_abHDk v_X6u)
                             `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                     :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                        ~R# (Identity a_abHDk
                                             -> Identity a_abHDk -> Identity a_abHDk :: *))]
Data.Functor.Identity.$fRealFloatIdentity
  = \ (@ a_abIQK) ($dRealFloat_abIQL :: RealFloat a_abIQK) ->
      GHC.Float.C:RealFloat
        @ (Identity a_abIQK)
        (Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat
           @ a_abIQK $dRealFloat_abIQL)
        (Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat
           @ a_abIQK $dRealFloat_abIQL)
        ((GHC.Float.floatRadix @ a_abIQK $dRealFloat_abIQL)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R <integer-simple-0.1.1.1:GHC.Integer.Type.Integer>_R
                 :: (a_abIQK
                     -> integer-simple-0.1.1.1:GHC.Integer.Type.Integer :: *)
                    ~R# (Identity a_abIQK
                         -> integer-simple-0.1.1.1:GHC.Integer.Type.Integer :: *)))
        ((GHC.Float.floatDigits @ a_abIQK $dRealFloat_abIQL)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R <GHC.Types.Int>_R
                 :: (a_abIQK -> GHC.Types.Int :: *)
                    ~R# (Identity a_abIQK -> GHC.Types.Int :: *)))
        ((GHC.Float.floatRange @ a_abIQK $dRealFloat_abIQL)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R <(GHC.Types.Int, GHC.Types.Int)>_R
                 :: (a_abIQK -> (GHC.Types.Int, GHC.Types.Int) :: *)
                    ~R# (Identity a_abIQK -> (GHC.Types.Int, GHC.Types.Int) :: *)))
        ((GHC.Float.decodeFloat @ a_abIQK $dRealFloat_abIQL)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R <(integer-simple-0.1.1.1:GHC.Integer.Type.Integer,
                        GHC.Types.Int)>_R
                 :: (a_abIQK
                     -> (integer-simple-0.1.1.1:GHC.Integer.Type.Integer,
                         GHC.Types.Int) :: *)
                    ~R# (Identity a_abIQK
                         -> (integer-simple-0.1.1.1:GHC.Integer.Type.Integer,
                             GHC.Types.Int) :: *)))
        ((GHC.Float.encodeFloat @ a_abIQK $dRealFloat_abIQL)
         `cast` (<integer-simple-0.1.1.1:GHC.Integer.Type.Integer>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 :: (integer-simple-0.1.1.1:GHC.Integer.Type.Integer
                     -> GHC.Types.Int -> a_abIQK :: *)
                    ~R# (integer-simple-0.1.1.1:GHC.Integer.Type.Integer
                         -> GHC.Types.Int -> Identity a_abIQK :: *)))
        ((GHC.Float.exponent @ a_abIQK $dRealFloat_abIQL)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R <GHC.Types.Int>_R
                 :: (a_abIQK -> GHC.Types.Int :: *)
                    ~R# (Identity a_abIQK -> GHC.Types.Int :: *)))
        ((GHC.Float.significand @ a_abIQK $dRealFloat_abIQL)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 :: (a_abIQK -> a_abIQK :: *)
                    ~R# (Identity a_abIQK -> Identity a_abIQK :: *)))
        ((GHC.Float.scaleFloat @ a_abIQK $dRealFloat_abIQL)
         `cast` (<GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 :: (GHC.Types.Int -> a_abIQK -> a_abIQK :: *)
                    ~R# (GHC.Types.Int -> Identity a_abIQK -> Identity a_abIQK :: *)))
        ((GHC.Float.isNaN @ a_abIQK $dRealFloat_abIQL)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R <Bool>_R
                 :: (a_abIQK -> Bool :: *) ~R# (Identity a_abIQK -> Bool :: *)))
        ((GHC.Float.isInfinite @ a_abIQK $dRealFloat_abIQL)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R <Bool>_R
                 :: (a_abIQK -> Bool :: *) ~R# (Identity a_abIQK -> Bool :: *)))
        ((GHC.Float.isDenormalized @ a_abIQK $dRealFloat_abIQL)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R <Bool>_R
                 :: (a_abIQK -> Bool :: *) ~R# (Identity a_abIQK -> Bool :: *)))
        ((GHC.Float.isNegativeZero @ a_abIQK $dRealFloat_abIQL)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R <Bool>_R
                 :: (a_abIQK -> Bool :: *) ~R# (Identity a_abIQK -> Bool :: *)))
        ((GHC.Float.isIEEE @ a_abIQK $dRealFloat_abIQL)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R <Bool>_R
                 :: (a_abIQK -> Bool :: *) ~R# (Identity a_abIQK -> Bool :: *)))
        ((GHC.Float.atan2 @ a_abIQK $dRealFloat_abIQL)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIQK>_R)
                 :: (a_abIQK -> a_abIQK -> a_abIQK :: *)
                    ~R# (Identity a_abIQK
                         -> Identity a_abIQK -> Identity a_abIQK :: *)))

-- RHS size: {terms: 19, types: 14, coercions: 72, joins: 0/0}
Data.Functor.Identity.$fEnumIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Enum a => Enum (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X6D :: Enum a_abHDk) ->
       GHC.Enum.C:Enum TYPE: Identity a_abHDk
                       (GHC.Enum.succ @ a_abHDk v_X6D)
                       `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               :: (a_abHDk -> a_abHDk :: *)
                                  ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                       (GHC.Enum.pred @ a_abHDk v_X6D)
                       `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               :: (a_abHDk -> a_abHDk :: *)
                                  ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                       (GHC.Enum.toEnum @ a_abHDk v_X6D)
                       `cast` (<GHC.Types.Int>_R
                               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               :: (GHC.Types.Int -> a_abHDk :: *)
                                  ~R# (GHC.Types.Int -> Identity a_abHDk :: *))
                       (GHC.Enum.fromEnum @ a_abHDk v_X6D)
                       `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               ->_R <GHC.Types.Int>_R
                               :: (a_abHDk -> GHC.Types.Int :: *)
                                  ~R# (Identity a_abHDk -> GHC.Types.Int :: *))
                       (GHC.Enum.enumFrom @ a_abHDk v_X6D)
                       `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               ->_R ([Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)])_R
                               :: (a_abHDk -> [a_abHDk] :: *)
                                  ~R# (Identity a_abHDk -> [Identity a_abHDk] :: *))
                       (GHC.Enum.enumFromThen @ a_abHDk v_X6D)
                       `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               ->_R ([Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)])_R
                               :: (a_abHDk -> a_abHDk -> [a_abHDk] :: *)
                                  ~R# (Identity a_abHDk
                                       -> Identity a_abHDk -> [Identity a_abHDk] :: *))
                       (GHC.Enum.enumFromTo @ a_abHDk v_X6D)
                       `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               ->_R ([Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)])_R
                               :: (a_abHDk -> a_abHDk -> [a_abHDk] :: *)
                                  ~R# (Identity a_abHDk
                                       -> Identity a_abHDk -> [Identity a_abHDk] :: *))
                       (GHC.Enum.enumFromThenTo @ a_abHDk v_X6D)
                       `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                               ->_R ([Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)])_R
                               :: (a_abHDk -> a_abHDk -> a_abHDk -> [a_abHDk] :: *)
                                  ~R# (Identity a_abHDk
                                       -> Identity a_abHDk
                                       -> Identity a_abHDk
                                       -> [Identity a_abHDk] :: *))]
Data.Functor.Identity.$fEnumIdentity
  = \ (@ a_abIwu) ($dEnum_abIwv :: Enum a_abIwu) ->
      GHC.Enum.C:Enum
        @ (Identity a_abIwu)
        ((GHC.Enum.succ @ a_abIwu $dEnum_abIwv)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 :: (a_abIwu -> a_abIwu :: *)
                    ~R# (Identity a_abIwu -> Identity a_abIwu :: *)))
        ((GHC.Enum.pred @ a_abIwu $dEnum_abIwv)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 :: (a_abIwu -> a_abIwu :: *)
                    ~R# (Identity a_abIwu -> Identity a_abIwu :: *)))
        ((GHC.Enum.toEnum @ a_abIwu $dEnum_abIwv)
         `cast` (<GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 :: (GHC.Types.Int -> a_abIwu :: *)
                    ~R# (GHC.Types.Int -> Identity a_abIwu :: *)))
        ((GHC.Enum.fromEnum @ a_abIwu $dEnum_abIwv)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 ->_R <GHC.Types.Int>_R
                 :: (a_abIwu -> GHC.Types.Int :: *)
                    ~R# (Identity a_abIwu -> GHC.Types.Int :: *)))
        ((GHC.Enum.enumFrom @ a_abIwu $dEnum_abIwv)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 ->_R ([Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)])_R
                 :: (a_abIwu -> [a_abIwu] :: *)
                    ~R# (Identity a_abIwu -> [Identity a_abIwu] :: *)))
        ((GHC.Enum.enumFromThen @ a_abIwu $dEnum_abIwv)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 ->_R ([Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)])_R
                 :: (a_abIwu -> a_abIwu -> [a_abIwu] :: *)
                    ~R# (Identity a_abIwu
                         -> Identity a_abIwu -> [Identity a_abIwu] :: *)))
        ((GHC.Enum.enumFromTo @ a_abIwu $dEnum_abIwv)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 ->_R ([Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)])_R
                 :: (a_abIwu -> a_abIwu -> [a_abIwu] :: *)
                    ~R# (Identity a_abIwu
                         -> Identity a_abIwu -> [Identity a_abIwu] :: *)))
        ((GHC.Enum.enumFromThenTo @ a_abIwu $dEnum_abIwv)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)
                 ->_R ([Sym (Data.Functor.Identity.N:Identity[0] <a_abIwu>_R)])_R
                 :: (a_abIwu -> a_abIwu -> a_abIwu -> [a_abIwu] :: *)
                    ~R# (Identity a_abIwu
                         -> Identity a_abIwu
                         -> Identity a_abIwu
                         -> [Identity a_abIwu] :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fIntegralIdentity_$cp2Integral
  :: forall a. Integral a => Enum (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIG7)
                 ($dIntegral_abIG8 [Occ=Once] :: Integral a_abIG7) ->
                 Data.Functor.Identity.$fEnumIdentity
                   @ a_abIG7 (GHC.Real.$p2Integral @ a_abIG7 $dIntegral_abIG8)}]
Data.Functor.Identity.$fIntegralIdentity_$cp2Integral
  = \ (@ a_abIG7) ($dIntegral_abIG8 :: Integral a_abIG7) ->
      Data.Functor.Identity.$fEnumIdentity
        @ a_abIG7 (GHC.Real.$p2Integral @ a_abIG7 $dIntegral_abIG8)

-- RHS size: {terms: 21, types: 15, coercions: 79, joins: 0/0}
Data.Functor.Identity.$fIntegralIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Integral a => Integral (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X6F :: Integral a_abHDk) ->
       GHC.Real.C:Integral TYPE: Identity a_abHDk
                           Data.Functor.Identity.$fIntegralIdentity_$cp1Integral
                             @ a_abHDk v_X6F
                           Data.Functor.Identity.$fIntegralIdentity_$cp2Integral
                             @ a_abHDk v_X6F
                           (GHC.Real.quot @ a_abHDk v_X6F)
                           `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                      ~R# (Identity a_abHDk
                                           -> Identity a_abHDk -> Identity a_abHDk :: *))
                           (GHC.Real.rem @ a_abHDk v_X6F)
                           `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                      ~R# (Identity a_abHDk
                                           -> Identity a_abHDk -> Identity a_abHDk :: *))
                           (GHC.Real.div @ a_abHDk v_X6F)
                           `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                      ~R# (Identity a_abHDk
                                           -> Identity a_abHDk -> Identity a_abHDk :: *))
                           (GHC.Real.mod @ a_abHDk v_X6F)
                           `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                      ~R# (Identity a_abHDk
                                           -> Identity a_abHDk -> Identity a_abHDk :: *))
                           (GHC.Real.quotRem @ a_abHDk v_X6F)
                           `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R ((,)
                                           (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R))
                                           (Sym (Data.Functor.Identity.N:Identity[0]
                                                     <a_abHDk>_R)))_R
                                   :: (a_abHDk -> a_abHDk -> (a_abHDk, a_abHDk) :: *)
                                      ~R# (Identity a_abHDk
                                           -> Identity a_abHDk
                                           -> (Identity a_abHDk, Identity a_abHDk) :: *))
                           (GHC.Real.divMod @ a_abHDk v_X6F)
                           `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R ((,)
                                           (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R))
                                           (Sym (Data.Functor.Identity.N:Identity[0]
                                                     <a_abHDk>_R)))_R
                                   :: (a_abHDk -> a_abHDk -> (a_abHDk, a_abHDk) :: *)
                                      ~R# (Identity a_abHDk
                                           -> Identity a_abHDk
                                           -> (Identity a_abHDk, Identity a_abHDk) :: *))
                           (GHC.Real.toInteger @ a_abHDk v_X6F)
                           `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                   ->_R <integer-simple-0.1.1.1:GHC.Integer.Type.Integer>_R
                                   :: (a_abHDk
                                       -> integer-simple-0.1.1.1:GHC.Integer.Type.Integer :: *)
                                      ~R# (Identity a_abHDk
                                           -> integer-simple-0.1.1.1:GHC.Integer.Type.Integer :: *))]
Data.Functor.Identity.$fIntegralIdentity
  = \ (@ a_abIG7) ($dIntegral_abIG8 :: Integral a_abIG7) ->
      GHC.Real.C:Integral
        @ (Identity a_abIG7)
        (Data.Functor.Identity.$fIntegralIdentity_$cp1Integral
           @ a_abIG7 $dIntegral_abIG8)
        (Data.Functor.Identity.$fIntegralIdentity_$cp2Integral
           @ a_abIG7 $dIntegral_abIG8)
        ((GHC.Real.quot @ a_abIG7 $dIntegral_abIG8)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 :: (a_abIG7 -> a_abIG7 -> a_abIG7 :: *)
                    ~R# (Identity a_abIG7
                         -> Identity a_abIG7 -> Identity a_abIG7 :: *)))
        ((GHC.Real.rem @ a_abIG7 $dIntegral_abIG8)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 :: (a_abIG7 -> a_abIG7 -> a_abIG7 :: *)
                    ~R# (Identity a_abIG7
                         -> Identity a_abIG7 -> Identity a_abIG7 :: *)))
        ((GHC.Real.div @ a_abIG7 $dIntegral_abIG8)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 :: (a_abIG7 -> a_abIG7 -> a_abIG7 :: *)
                    ~R# (Identity a_abIG7
                         -> Identity a_abIG7 -> Identity a_abIG7 :: *)))
        ((GHC.Real.mod @ a_abIG7 $dIntegral_abIG8)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 :: (a_abIG7 -> a_abIG7 -> a_abIG7 :: *)
                    ~R# (Identity a_abIG7
                         -> Identity a_abIG7 -> Identity a_abIG7 :: *)))
        ((GHC.Real.quotRem @ a_abIG7 $dIntegral_abIG8)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R ((,)
                         (Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R))
                         (Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)))_R
                 :: (a_abIG7 -> a_abIG7 -> (a_abIG7, a_abIG7) :: *)
                    ~R# (Identity a_abIG7
                         -> Identity a_abIG7 -> (Identity a_abIG7, Identity a_abIG7) :: *)))
        ((GHC.Real.divMod @ a_abIG7 $dIntegral_abIG8)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R ((,)
                         (Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R))
                         (Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)))_R
                 :: (a_abIG7 -> a_abIG7 -> (a_abIG7, a_abIG7) :: *)
                    ~R# (Identity a_abIG7
                         -> Identity a_abIG7 -> (Identity a_abIG7, Identity a_abIG7) :: *)))
        ((GHC.Real.toInteger @ a_abIG7 $dIntegral_abIG8)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIG7>_R)
                 ->_R <integer-simple-0.1.1.1:GHC.Integer.Type.Integer>_R
                 :: (a_abIG7
                     -> integer-simple-0.1.1.1:GHC.Integer.Type.Integer :: *)
                    ~R# (Identity a_abIG7
                         -> integer-simple-0.1.1.1:GHC.Integer.Type.Integer :: *)))

-- RHS size: {terms: 7, types: 8, coercions: 6, joins: 0/0}
Data.Functor.Identity.$fBoundedIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Bounded a => Bounded (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X6I :: Bounded a_abHDk) ->
       GHC.Enum.C:Bounded TYPE: Identity a_abHDk
                          (GHC.Enum.minBound @ a_abHDk v_X6I)
                          `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                  :: (a_abHDk :: *) ~R# (Identity a_abHDk :: *))
                          (GHC.Enum.maxBound @ a_abHDk v_X6I)
                          `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                  :: (a_abHDk :: *) ~R# (Identity a_abHDk :: *))]
Data.Functor.Identity.$fBoundedIdentity
  = \ (@ a_abIwc) ($dBounded_abIwd :: Bounded a_abIwc) ->
      GHC.Enum.C:Bounded
        @ (Identity a_abIwc)
        ((GHC.Enum.minBound @ a_abIwc $dBounded_abIwd)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIwc>_R)
                 :: (a_abIwc :: *) ~R# (Identity a_abIwc :: *)))
        ((GHC.Enum.maxBound @ a_abIwc $dBounded_abIwd)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIwc>_R)
                 :: (a_abIwc :: *) ~R# (Identity a_abIwc :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fBitsIdentity_$cp1Bits
  :: forall a. Bits a => Eq (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIrg) ($dBits_abIrh [Occ=Once] :: Bits a_abIrg) ->
                 Data.Functor.Identity.$fEqIdentity
                   @ a_abIrg (Data.Bits.$p1Bits @ a_abIrg $dBits_abIrh)}]
Data.Functor.Identity.$fBitsIdentity_$cp1Bits
  = \ (@ a_abIrg) ($dBits_abIrh :: Bits a_abIrg) ->
      Data.Functor.Identity.$fEqIdentity
        @ a_abIrg (Data.Bits.$p1Bits @ a_abIrg $dBits_abIrh)

-- RHS size: {terms: 49, types: 29, coercions: 174, joins: 0/0}
Data.Functor.Identity.$fBitsIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Bits a => Bits (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=DFun: \ (@ a_abHDk) (v_X76 :: Bits a_abHDk) ->
       Data.Bits.C:Bits TYPE: Identity a_abHDk
                        Data.Functor.Identity.$fBitsIdentity_$cp1Bits @ a_abHDk v_X76
                        (Data.Bits..&. @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk
                                        -> Identity a_abHDk -> Identity a_abHDk :: *))
                        (Data.Bits..|. @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk
                                        -> Identity a_abHDk -> Identity a_abHDk :: *))
                        (Data.Bits.xor @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> a_abHDk -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk
                                        -> Identity a_abHDk -> Identity a_abHDk :: *))
                        (Data.Bits.complement @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk -> Identity a_abHDk :: *))
                        (Data.Bits.shift @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> GHC.Types.Int -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int -> Identity a_abHDk :: *))
                        (Data.Bits.rotate @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> GHC.Types.Int -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int -> Identity a_abHDk :: *))
                        (Data.Bits.zeroBits @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk :: *) ~R# (Identity a_abHDk :: *))
                        (Data.Bits.bit @ a_abHDk v_X76)
                        `cast` (<GHC.Types.Int>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (GHC.Types.Int -> a_abHDk :: *)
                                   ~R# (GHC.Types.Int -> Identity a_abHDk :: *))
                        (Data.Bits.setBit @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> GHC.Types.Int -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int -> Identity a_abHDk :: *))
                        (Data.Bits.clearBit @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> GHC.Types.Int -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int -> Identity a_abHDk :: *))
                        (Data.Bits.complementBit @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> GHC.Types.Int -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int -> Identity a_abHDk :: *))
                        (Data.Bits.testBit @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int -> Bool>_R
                                :: (a_abHDk -> GHC.Types.Int -> Bool :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int -> Bool :: *))
                        (Data.Bits.bitSizeMaybe @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Base.Maybe GHC.Types.Int>_R
                                :: (a_abHDk -> GHC.Base.Maybe GHC.Types.Int :: *)
                                   ~R# (Identity a_abHDk -> GHC.Base.Maybe GHC.Types.Int :: *))
                        (Data.Bits.bitSize @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                :: (a_abHDk -> GHC.Types.Int :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int :: *))
                        (Data.Bits.isSigned @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <Bool>_R
                                :: (a_abHDk -> Bool :: *) ~R# (Identity a_abHDk -> Bool :: *))
                        (Data.Bits.shiftL @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> GHC.Types.Int -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int -> Identity a_abHDk :: *))
                        (Data.Bits.unsafeShiftL @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> GHC.Types.Int -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int -> Identity a_abHDk :: *))
                        (Data.Bits.shiftR @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> GHC.Types.Int -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int -> Identity a_abHDk :: *))
                        (Data.Bits.unsafeShiftR @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> GHC.Types.Int -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int -> Identity a_abHDk :: *))
                        (Data.Bits.rotateL @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> GHC.Types.Int -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int -> Identity a_abHDk :: *))
                        (Data.Bits.rotateR @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                :: (a_abHDk -> GHC.Types.Int -> a_abHDk :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int -> Identity a_abHDk :: *))
                        (Data.Bits.popCount @ a_abHDk v_X76)
                        `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                ->_R <GHC.Types.Int>_R
                                :: (a_abHDk -> GHC.Types.Int :: *)
                                   ~R# (Identity a_abHDk -> GHC.Types.Int :: *))]
Data.Functor.Identity.$fBitsIdentity
  = \ (@ a_abIrg) ($dBits_abIrh :: Bits a_abIrg) ->
      Data.Bits.C:Bits
        @ (Identity a_abIrg)
        (Data.Functor.Identity.$fBitsIdentity_$cp1Bits
           @ a_abIrg $dBits_abIrh)
        ((Data.Bits..&. @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> a_abIrg -> a_abIrg :: *)
                    ~R# (Identity a_abIrg
                         -> Identity a_abIrg -> Identity a_abIrg :: *)))
        ((Data.Bits..|. @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> a_abIrg -> a_abIrg :: *)
                    ~R# (Identity a_abIrg
                         -> Identity a_abIrg -> Identity a_abIrg :: *)))
        ((Data.Bits.xor @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> a_abIrg -> a_abIrg :: *)
                    ~R# (Identity a_abIrg
                         -> Identity a_abIrg -> Identity a_abIrg :: *)))
        ((Data.Bits.complement @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> a_abIrg :: *)
                    ~R# (Identity a_abIrg -> Identity a_abIrg :: *)))
        ((Data.Bits.shift @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> GHC.Types.Int -> a_abIrg :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int -> Identity a_abIrg :: *)))
        ((Data.Bits.rotate @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> GHC.Types.Int -> a_abIrg :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int -> Identity a_abIrg :: *)))
        ((Data.Bits.zeroBits @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg :: *) ~R# (Identity a_abIrg :: *)))
        ((Data.Bits.bit @ a_abIrg $dBits_abIrh)
         `cast` (<GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (GHC.Types.Int -> a_abIrg :: *)
                    ~R# (GHC.Types.Int -> Identity a_abIrg :: *)))
        ((Data.Bits.setBit @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> GHC.Types.Int -> a_abIrg :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int -> Identity a_abIrg :: *)))
        ((Data.Bits.clearBit @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> GHC.Types.Int -> a_abIrg :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int -> Identity a_abIrg :: *)))
        ((Data.Bits.complementBit @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> GHC.Types.Int -> a_abIrg :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int -> Identity a_abIrg :: *)))
        ((Data.Bits.testBit @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int -> Bool>_R
                 :: (a_abIrg -> GHC.Types.Int -> Bool :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int -> Bool :: *)))
        ((Data.Bits.bitSizeMaybe @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Base.Maybe GHC.Types.Int>_R
                 :: (a_abIrg -> GHC.Base.Maybe GHC.Types.Int :: *)
                    ~R# (Identity a_abIrg -> GHC.Base.Maybe GHC.Types.Int :: *)))
        ((Data.Bits.bitSize @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 :: (a_abIrg -> GHC.Types.Int :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int :: *)))
        ((Data.Bits.isSigned @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <Bool>_R
                 :: (a_abIrg -> Bool :: *) ~R# (Identity a_abIrg -> Bool :: *)))
        ((Data.Bits.shiftL @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> GHC.Types.Int -> a_abIrg :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int -> Identity a_abIrg :: *)))
        ((Data.Bits.unsafeShiftL @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> GHC.Types.Int -> a_abIrg :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int -> Identity a_abIrg :: *)))
        ((Data.Bits.shiftR @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> GHC.Types.Int -> a_abIrg :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int -> Identity a_abIrg :: *)))
        ((Data.Bits.unsafeShiftR @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> GHC.Types.Int -> a_abIrg :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int -> Identity a_abIrg :: *)))
        ((Data.Bits.rotateL @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> GHC.Types.Int -> a_abIrg :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int -> Identity a_abIrg :: *)))
        ((Data.Bits.rotateR @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 :: (a_abIrg -> GHC.Types.Int -> a_abIrg :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int -> Identity a_abIrg :: *)))
        ((Data.Bits.popCount @ a_abIrg $dBits_abIrh)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIrg>_R)
                 ->_R <GHC.Types.Int>_R
                 :: (a_abIrg -> GHC.Types.Int :: *)
                    ~R# (Identity a_abIrg -> GHC.Types.Int :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits
  :: forall a. FiniteBits a => Bits (Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIyM)
                 ($dFiniteBits_abIyN [Occ=Once] :: FiniteBits a_abIyM) ->
                 Data.Functor.Identity.$fBitsIdentity
                   @ a_abIyM (Data.Bits.$p1FiniteBits @ a_abIyM $dFiniteBits_abIyN)}]
Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits
  = \ (@ a_abIyM) ($dFiniteBits_abIyN :: FiniteBits a_abIyM) ->
      Data.Functor.Identity.$fBitsIdentity
        @ a_abIyM (Data.Bits.$p1FiniteBits @ a_abIyM $dFiniteBits_abIyN)

-- RHS size: {terms: 11, types: 10, coercions: 15, joins: 0/0}
Data.Functor.Identity.$fFiniteBitsIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. FiniteBits a => FiniteBits (Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_abHDk) (v_X78 :: FiniteBits a_abHDk) ->
       Data.Bits.C:FiniteBits TYPE: Identity a_abHDk
                              Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits
                                @ a_abHDk v_X78
                              (Data.Bits.finiteBitSize @ a_abHDk v_X78)
                              `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                      ->_R <GHC.Types.Int>_R
                                      :: (a_abHDk -> GHC.Types.Int :: *)
                                         ~R# (Identity a_abHDk -> GHC.Types.Int :: *))
                              (Data.Bits.countLeadingZeros @ a_abHDk v_X78)
                              `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                      ->_R <GHC.Types.Int>_R
                                      :: (a_abHDk -> GHC.Types.Int :: *)
                                         ~R# (Identity a_abHDk -> GHC.Types.Int :: *))
                              (Data.Bits.countTrailingZeros @ a_abHDk v_X78)
                              `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abHDk>_R)
                                      ->_R <GHC.Types.Int>_R
                                      :: (a_abHDk -> GHC.Types.Int :: *)
                                         ~R# (Identity a_abHDk -> GHC.Types.Int :: *))]
Data.Functor.Identity.$fFiniteBitsIdentity
  = \ (@ a_abIyM) ($dFiniteBits_abIyN :: FiniteBits a_abIyM) ->
      Data.Bits.C:FiniteBits
        @ (Identity a_abIyM)
        (Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits
           @ a_abIyM $dFiniteBits_abIyN)
        ((Data.Bits.finiteBitSize @ a_abIyM $dFiniteBits_abIyN)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIyM>_R)
                 ->_R <GHC.Types.Int>_R
                 :: (a_abIyM -> GHC.Types.Int :: *)
                    ~R# (Identity a_abIyM -> GHC.Types.Int :: *)))
        ((Data.Bits.countLeadingZeros @ a_abIyM $dFiniteBits_abIyN)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIyM>_R)
                 ->_R <GHC.Types.Int>_R
                 :: (a_abIyM -> GHC.Types.Int :: *)
                    ~R# (Identity a_abIyM -> GHC.Types.Int :: *)))
        ((Data.Bits.countTrailingZeros @ a_abIyM $dFiniteBits_abIyN)
         `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_abIyM>_R)
                 ->_R <GHC.Types.Int>_R
                 :: (a_abIyM -> GHC.Types.Int :: *)
                    ~R# (Identity a_abIyM -> GHC.Types.Int :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
runIdentity :: forall a. Identity a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Identity.$fFoldableIdentity2
               `cast` (forall (a :: <*>_N).
                       <Identity a>_R ->_R Data.Functor.Identity.N:Identity[0] <a>_R
                       :: (forall a. Identity a -> Identity a :: *)
                          ~R# (forall a. Identity a -> a :: *))}]
runIdentity
  = Data.Functor.Identity.$fFoldableIdentity2
    `cast` (forall (a :: <*>_N).
            <Identity a>_R ->_R Data.Functor.Identity.N:Identity[0] <a>_R
            :: (forall a. Identity a -> Identity a :: *)
               ~R# (forall a. Identity a -> a :: *))

-- RHS size: {terms: 6, types: 7, coercions: 2, joins: 0/1}
Data.Functor.Identity.$fMonadFixIdentity_$cmfix
  :: forall a. (a -> Identity a) -> Identity a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<C(S),C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abIVT)
                 (f_abHDl [Occ=Once!] :: a_abIVT -> Identity a_abIVT) ->
                 letrec {
                   x_sbJoA [Occ=LoopBreaker] :: Identity a_abIVT
                   [LclId]
                   x_sbJoA
                     = f_abHDl
                         (x_sbJoA
                          `cast` (Data.Functor.Identity.N:Identity[0] <a_abIVT>_R
                                  :: (Identity a_abIVT :: *) ~R# (a_abIVT :: *))); } in
                 x_sbJoA}]
Data.Functor.Identity.$fMonadFixIdentity_$cmfix
  = \ (@ a_abIVT) (f_abHDl :: a_abIVT -> Identity a_abIVT) ->
      letrec {
        x_sbJoA [Occ=LoopBreaker] :: Identity a_abIVT
        [LclId]
        x_sbJoA
          = f_abHDl
              (x_sbJoA
               `cast` (Data.Functor.Identity.N:Identity[0] <a_abIVT>_R
                       :: (Identity a_abIVT :: *) ~R# (a_abIVT :: *))); } in
      x_sbJoA

-- RHS size: {terms: 6, types: 9, coercions: 2, joins: 0/0}
Data.Functor.Identity.$fMonadIdentity_$c>>=
  :: forall a b. Identity a -> (a -> Identity b) -> Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIWa)
                 (@ b_abIWb)
                 (m_abHDm [Occ=Once] :: Identity a_abIWa)
                 (k_abHDn [Occ=Once!] :: a_abIWa -> Identity b_abIWb) ->
                 k_abHDn
                   (m_abHDm
                    `cast` (Data.Functor.Identity.N:Identity[0] <a_abIWa>_R
                            :: (Identity a_abIWa :: *) ~R# (a_abIWa :: *)))}]
Data.Functor.Identity.$fMonadIdentity_$c>>=
  = \ (@ a_abIWa)
      (@ b_abIWb)
      (m_abHDm :: Identity a_abIWa)
      (k_abHDn :: a_abIWa -> Identity b_abIWb) ->
      k_abHDn
        (m_abHDm
         `cast` (Data.Functor.Identity.N:Identity[0] <a_abIWa>_R
                 :: (Identity a_abIWa :: *) ~R# (a_abIWa :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fMonadIdentity_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. Identity a -> Identity b -> Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ a_abIWl)
                 (@ b_abIWm)
                 _ [Occ=Dead]
                 (k_ibJeM [Occ=Once] :: Identity b_abIWm) ->
                 k_ibJeM}]
Data.Functor.Identity.$fMonadIdentity_$c>>
  = Data.Functor.Identity.$fApplicativeIdentity_$c*>

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl_rbJt6 :: forall a. [GHC.Types.Char] -> Identity a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl_rbJt6
  = \ (@ a_abIWD) (eta_B1 :: [GHC.Types.Char]) ->
      GHC.Err.errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep @ (Identity a_abIWD) eta_B1

-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
Data.Functor.Identity.$fMonadIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Monad Identity
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: Identity
                        Data.Functor.Identity.$fApplicativeIdentity
                        Data.Functor.Identity.$fMonadIdentity_$c>>=
                        Data.Functor.Identity.$fMonadIdentity_$c>>
                        Data.Functor.Identity.$fApplicativeIdentity3
                        `cast` (forall (a :: <*>_N).
                                <a>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                                :: (forall a. a -> a :: *) ~R# (forall a. a -> Identity a :: *))
                        \ (@ a_abIWD) ->
                          GHC.Err.errorWithoutStackTrace
                            @ 'GHC.Types.LiftedRep @ (Identity a_abIWD)]
Data.Functor.Identity.$fMonadIdentity
  = GHC.Base.C:Monad
      @ Identity
      Data.Functor.Identity.$fApplicativeIdentity
      Data.Functor.Identity.$fMonadIdentity_$c>>=
      Data.Functor.Identity.$fMonadIdentity_$c>>
      (Data.Functor.Identity.$fApplicativeIdentity3
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
               :: (forall a. a -> a :: *) ~R# (forall a. a -> Identity a :: *)))
      lvl_rbJt6

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fMonadFixIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadFix Identity
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Control.Monad.Fix.C:MonadFix TYPE: Identity
                                    Data.Functor.Identity.$fMonadIdentity
                                    Data.Functor.Identity.$fMonadFixIdentity_$cmfix]
Data.Functor.Identity.$fMonadFixIdentity
  = Control.Monad.Fix.C:MonadFix
      @ Identity
      Data.Functor.Identity.$fMonadIdentity
      Data.Functor.Identity.$fMonadFixIdentity_$cmfix

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity5
  :: forall a. (a -> a -> a) -> Identity a -> Identity a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abIZd) _ [Occ=Dead] ->
                 Data.Functor.Identity.$fFoldableIdentity2 @ a_abIZd}]
Data.Functor.Identity.$fFoldableIdentity5
  = \ (@ a_abIZd) _ [Occ=Dead] ->
      Data.Functor.Identity.$fFoldableIdentity2 @ a_abIZd

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity3
  :: forall a. Ord a => Identity a -> Identity a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abJ05) _ [Occ=Dead] ->
                 Data.Functor.Identity.$fFoldableIdentity2 @ a_abJ05}]
Data.Functor.Identity.$fFoldableIdentity3
  = \ (@ a_abJ05) _ [Occ=Dead] ->
      Data.Functor.Identity.$fFoldableIdentity2 @ a_abJ05

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity1
  :: forall a. Num a => Identity a -> Identity a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abJ0n) _ [Occ=Dead] ->
                 Data.Functor.Identity.$fFoldableIdentity2 @ a_abJ0n}]
Data.Functor.Identity.$fFoldableIdentity1
  = \ (@ a_abJ0n) _ [Occ=Dead] ->
      Data.Functor.Identity.$fFoldableIdentity2 @ a_abJ0n

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity8
  :: forall m. Monoid m => m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_abIY8) _ [Occ=Dead] -> GHC.Base.id @ m_abIY8}]
Data.Functor.Identity.$fFoldableIdentity8
  = \ (@ m_abIY8) _ [Occ=Dead] -> GHC.Base.id @ m_abIY8

-- RHS size: {terms: 17, types: 1, coercions: 143, joins: 0/0}
Data.Functor.Identity.$fFoldableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Identity
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Identity
                                Data.Functor.Identity.$fFoldableIdentity8
                                `cast` (forall (m :: <*>_N).
                                        <Monoid m>_R
                                        ->_R Sym (Data.Functor.Identity.N:Identity[0] <m>_R)
                                        ->_R <m>_R
                                        :: (forall m. Monoid m => m -> m :: *)
                                           ~R# (forall m. Monoid m => Identity m -> m :: *))
                                Data.Functor.Identity.$fFoldableIdentity7
                                `cast` (forall (m :: <*>_N) (a :: <*>_N).
                                        <Monoid m>_R
                                        ->_R <a -> m>_R
                                        ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                                        ->_R <m>_R
                                        :: (forall m a. Monoid m => (a -> m) -> a -> m :: *)
                                           ~R# (forall m a.
                                                Monoid m =>
                                                (a -> m) -> Identity a -> m :: *))
                                Data.Functor.Identity.$fFoldableIdentity_$cfoldr
                                Data.Functor.Identity.$fFoldableIdentity_$cfoldr
                                Data.Functor.Identity.$fFoldableIdentity6
                                `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                        <b -> a -> b>_R
                                        ->_R <b>_R
                                        ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                                        ->_R <b>_R
                                        :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                                           ~R# (forall b a.
                                                (b -> a -> b) -> b -> Identity a -> b :: *))
                                Data.Functor.Identity.$fFoldableIdentity6
                                `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                        <b -> a -> b>_R
                                        ->_R <b>_R
                                        ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                                        ->_R <b>_R
                                        :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                                           ~R# (forall b a.
                                                (b -> a -> b) -> b -> Identity a -> b :: *))
                                Data.Functor.Identity.$fFoldableIdentity5
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Identity a>_R
                                        ->_R Data.Functor.Identity.N:Identity[0] <a>_R
                                        :: (forall a.
                                            (a -> a -> a) -> Identity a -> Identity a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Identity a -> a :: *))
                                Data.Functor.Identity.$fFoldableIdentity5
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Identity a>_R
                                        ->_R Data.Functor.Identity.N:Identity[0] <a>_R
                                        :: (forall a.
                                            (a -> a -> a) -> Identity a -> Identity a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Identity a -> a :: *))
                                Data.Functor.Identity.$fFoldableIdentity_$ctoList
                                Data.Functor.Identity.$fFoldableIdentity_$cnull
                                Data.Functor.Identity.$fFoldableIdentity_$clength
                                ==
                                `cast` (forall (a :: <*>_N).
                                        <Eq a>_R
                                        ->_R <a>_R
                                        ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
                                        ->_R <Bool>_R
                                        :: (forall a. Eq a => a -> a -> Bool :: *)
                                           ~R# (forall a. Eq a => a -> Identity a -> Bool :: *))
                                Data.Functor.Identity.$fFoldableIdentity3
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R <Identity a>_R
                                        ->_R Data.Functor.Identity.N:Identity[0] <a>_R
                                        :: (forall a. Ord a => Identity a -> Identity a :: *)
                                           ~R# (forall a. Ord a => Identity a -> a :: *))
                                Data.Functor.Identity.$fFoldableIdentity3
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R <Identity a>_R
                                        ->_R Data.Functor.Identity.N:Identity[0] <a>_R
                                        :: (forall a. Ord a => Identity a -> Identity a :: *)
                                           ~R# (forall a. Ord a => Identity a -> a :: *))
                                Data.Functor.Identity.$fFoldableIdentity1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Identity a>_R
                                        ->_R Data.Functor.Identity.N:Identity[0] <a>_R
                                        :: (forall a. Num a => Identity a -> Identity a :: *)
                                           ~R# (forall a. Num a => Identity a -> a :: *))
                                Data.Functor.Identity.$fFoldableIdentity1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Identity a>_R
                                        ->_R Data.Functor.Identity.N:Identity[0] <a>_R
                                        :: (forall a. Num a => Identity a -> Identity a :: *)
                                           ~R# (forall a. Num a => Identity a -> a :: *))]
Data.Functor.Identity.$fFoldableIdentity
  = Data.Foldable.C:Foldable
      @ Identity
      (Data.Functor.Identity.$fFoldableIdentity8
       `cast` (forall (m :: <*>_N).
               <Monoid m>_R
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <m>_R)
               ->_R <m>_R
               :: (forall m. Monoid m => m -> m :: *)
                  ~R# (forall m. Monoid m => Identity m -> m :: *)))
      (Data.Functor.Identity.$fFoldableIdentity7
       `cast` (forall (m :: <*>_N) (a :: <*>_N).
               <Monoid m>_R
               ->_R <a -> m>_R
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
               ->_R <m>_R
               :: (forall m a. Monoid m => (a -> m) -> a -> m :: *)
                  ~R# (forall m a. Monoid m => (a -> m) -> Identity a -> m :: *)))
      Data.Functor.Identity.$fFoldableIdentity_$cfoldr
      Data.Functor.Identity.$fFoldableIdentity_$cfoldr
      (Data.Functor.Identity.$fFoldableIdentity6
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b -> a -> b>_R
               ->_R <b>_R
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
               ->_R <b>_R
               :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                  ~R# (forall b a. (b -> a -> b) -> b -> Identity a -> b :: *)))
      (Data.Functor.Identity.$fFoldableIdentity6
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b -> a -> b>_R
               ->_R <b>_R
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
               ->_R <b>_R
               :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                  ~R# (forall b a. (b -> a -> b) -> b -> Identity a -> b :: *)))
      (Data.Functor.Identity.$fFoldableIdentity5
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R
               ->_R <Identity a>_R
               ->_R Data.Functor.Identity.N:Identity[0] <a>_R
               :: (forall a. (a -> a -> a) -> Identity a -> Identity a :: *)
                  ~R# (forall a. (a -> a -> a) -> Identity a -> a :: *)))
      (Data.Functor.Identity.$fFoldableIdentity5
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R
               ->_R <Identity a>_R
               ->_R Data.Functor.Identity.N:Identity[0] <a>_R
               :: (forall a. (a -> a -> a) -> Identity a -> Identity a :: *)
                  ~R# (forall a. (a -> a -> a) -> Identity a -> a :: *)))
      Data.Functor.Identity.$fFoldableIdentity_$ctoList
      Data.Functor.Identity.$fFoldableIdentity_$cnull
      Data.Functor.Identity.$fFoldableIdentity_$clength
      (==
       `cast` (forall (a :: <*>_N).
               <Eq a>_R
               ->_R <a>_R
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R)
               ->_R <Bool>_R
               :: (forall a. Eq a => a -> a -> Bool :: *)
                  ~R# (forall a. Eq a => a -> Identity a -> Bool :: *)))
      (Data.Functor.Identity.$fFoldableIdentity3
       `cast` (forall (a :: <*>_N).
               <Ord a>_R
               ->_R <Identity a>_R
               ->_R Data.Functor.Identity.N:Identity[0] <a>_R
               :: (forall a. Ord a => Identity a -> Identity a :: *)
                  ~R# (forall a. Ord a => Identity a -> a :: *)))
      (Data.Functor.Identity.$fFoldableIdentity3
       `cast` (forall (a :: <*>_N).
               <Ord a>_R
               ->_R <Identity a>_R
               ->_R Data.Functor.Identity.N:Identity[0] <a>_R
               :: (forall a. Ord a => Identity a -> Identity a :: *)
                  ~R# (forall a. Ord a => Identity a -> a :: *)))
      (Data.Functor.Identity.$fFoldableIdentity1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Identity a>_R
               ->_R Data.Functor.Identity.N:Identity[0] <a>_R
               :: (forall a. Num a => Identity a -> Identity a :: *)
                  ~R# (forall a. Num a => Identity a -> a :: *)))
      (Data.Functor.Identity.$fFoldableIdentity1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Identity a>_R
               ->_R Data.Functor.Identity.N:Identity[0] <a>_R
               :: (forall a. Num a => Identity a -> Identity a :: *)
                  ~R# (forall a. Num a => Identity a -> a :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Identity.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Identity.$trModule3
  = GHC.Types.TrNameS Data.Functor.Identity.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
Data.Functor.Identity.$trModule2 = "Data.Functor.Identity"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Identity.$trModule1
  = GHC.Types.TrNameS Data.Functor.Identity.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Functor.Identity.$trModule
  = GHC.Types.Module
      Data.Functor.Identity.$trModule3 Data.Functor.Identity.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep_rbJt7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep_rbJt7 = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$tcIdentity1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Identity.$tcIdentity1
  = GHC.Types.TrNameS Data.Functor.Identity.$fReadIdentity6

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$tcIdentity :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Identity.$tcIdentity
  = GHC.Types.TyCon
      3410104521590905987##
      16392070908630191652##
      Data.Functor.Identity.$trModule
      Data.Functor.Identity.$tcIdentity1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep1_rbJt8 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep1_rbJt8
  = GHC.Types.:
      @ GHC.Types.KindRep $krep_rbJt7 (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2_rbJt9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_rbJt9
  = GHC.Types.KindRepTyConApp
      Data.Functor.Identity.$tcIdentity $krep1_rbJt8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$tc'Identity1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Identity.$tc'Identity1
  = GHC.Types.KindRepFun $krep_rbJt7 $krep2_rbJt9

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$tc'Identity3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Functor.Identity.$tc'Identity3 = "'Identity"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$tc'Identity2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Identity.$tc'Identity2
  = GHC.Types.TrNameS Data.Functor.Identity.$tc'Identity3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Identity.$tc'Identity :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Identity.$tc'Identity
  = GHC.Types.TyCon
      11920310844698764515##
      3935129235072617509##
      Data.Functor.Identity.$trModule
      Data.Functor.Identity.$tc'Identity2
      1#
      Data.Functor.Identity.$tc'Identity1


