
==================== Output Cmm ====================
2018-03-16 16:11:54.939167892 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:54.940499227 UTC

[section ""data" . Data.Functor.Product.$fEq1Product_$cliftEq_closure" {
     Data.Functor.Product.$fEq1Product_$cliftEq_closure:
         const Data.Functor.Product.$fEq1Product_$cliftEq_info;
 },
 Data.Functor.Product.$fEq1Product_$cliftEq_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cg5Ka,
                       label: Data.Functor.Product.$fEq1Product_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Ka: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg5Ke; else goto cg5Kf;
       cg5Ke: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEq1Product_$cliftEq_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5Kf: // global
           I64[Sp - 40] = block_cg5K7_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5Kz; else goto cg5K8;
       ug5Kz: // global
           call _cg5K7(R1) args: 0, res: 0, upd: 0;
       cg5K8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5K7() //  [R1]
         { info_tbl: [(cg5K7,
                       label: block_cg5K7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5K7: // global
           I64[Sp - 8] = block_cg5Kd_info;
           _sg5ou::P64 = P64[R1 + 7];
           _sg5ov::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5ov::P64;
           P64[Sp + 32] = _sg5ou::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug5Ky; else goto cg5Kh;
       ug5Ky: // global
           call _cg5Kd(R1) args: 0, res: 0, upd: 0;
       cg5Kh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Kd() //  [R1]
         { info_tbl: [(cg5Kd,
                       label: block_cg5Kd_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Kd: // global
           I64[Sp] = block_cg5Kl_info;
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           _sg5oy::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp + 40] = _sg5oy::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Kl() //  [R1]
         { info_tbl: [(cg5Kl,
                       label: block_cg5Kl_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Kl: // global
           if (R1 & 7 == 1) goto cg5Ks; else goto cg5Kw;
       cg5Ks: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg5Kw: // global
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           R1 = P64[Sp + 24];
           Sp = Sp + 48;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.942453889 UTC

[section ""data" . Data.Functor.Product.$fEq1Product_closure" {
     Data.Functor.Product.$fEq1Product_closure:
         const Data.Functor.Product.$fEq1Product_info;
 },
 Data.Functor.Product.$fEq1Product_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg5KE,
                       label: Data.Functor.Product.$fEq1Product_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5KE: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Product.$fEq1Product_$cliftEq_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.943743298 UTC

[section ""data" . Data.Functor.Product.$w$cliftCompare_closure" {
     Data.Functor.Product.$w$cliftCompare_closure:
         const Data.Functor.Product.$w$cliftCompare_info;
 },
 Data.Functor.Product.$w$cliftCompare_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5KI: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cliftCompare_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cliftCompare_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cg5KT,
                       label: Data.Functor.Product.$w$cliftCompare_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5KT: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg5KU; else goto cg5KV;
       cg5KU: // global
           R1 = Data.Functor.Product.$w$cliftCompare_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg5KV: // global
           I64[Sp - 24] = block_cg5KM_info;
           R2 = R2;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = R4;
           P64[Sp - 40] = R5;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = R3;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg5KM() //  [R1]
         { info_tbl: [(cg5KM,
                       label: block_cg5KM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5KM: // global
           _cg5KS::P64 = R1 & 7;
           if (_cg5KS::P64 < 3) goto ug5L5; else goto cg5KR;
       ug5L5: // global
           if (_cg5KS::P64 < 2) goto cg5KP; else goto cg5KQ;
       cg5KP: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg5KQ: // global
           R2 = P64[Sp + 24];
           _sg5oC::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           _sg5oE::P64 = P64[Sp + 16];
           P64[Sp + 16] = _sg5oC::P64;
           P64[Sp + 24] = _sg5oE::P64;
           Sp = Sp + 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
       cg5KR: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.945744187 UTC

[section ""data" . Data.Functor.Product.$fOrd1Product_$cliftCompare_closure" {
     Data.Functor.Product.$fOrd1Product_$cliftCompare_closure:
         const Data.Functor.Product.$fOrd1Product_$cliftCompare_info;
 },
 Data.Functor.Product.$fOrd1Product_$cliftCompare_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cg5Ld,
                       label: Data.Functor.Product.$fOrd1Product_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Ld: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg5Lh; else goto cg5Li;
       cg5Lh: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrd1Product_$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5Li: // global
           I64[Sp - 40] = block_cg5La_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5Lq; else goto cg5Lb;
       ug5Lq: // global
           call _cg5La(R1) args: 0, res: 0, upd: 0;
       cg5Lb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5La() //  [R1]
         { info_tbl: [(cg5La,
                       label: block_cg5La_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5La: // global
           I64[Sp - 8] = block_cg5Lg_info;
           _sg5oO::P64 = P64[R1 + 7];
           _sg5oP::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5oP::P64;
           P64[Sp + 32] = _sg5oO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug5Lp; else goto cg5Lk;
       ug5Lp: // global
           call _cg5Lg(R1) args: 0, res: 0, upd: 0;
       cg5Lk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Lg() //  [R1]
         { info_tbl: [(cg5Lg,
                       label: block_cg5Lg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Lg: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cliftCompare_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.947673094 UTC

[section ""data" . Data.Functor.Product.$w$cp1Ord1_closure" {
     Data.Functor.Product.$w$cp1Ord1_closure:
         const Data.Functor.Product.$w$cp1Ord1_info;
 },
 Data.Functor.Product.$w$cp1Ord1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Ls: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cp1Ord1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cp1Ord1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg5LC,
                       label: Data.Functor.Product.$w$cp1Ord1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5LC: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg5LD; else goto cg5LE;
       cg5LD: // global
           R1 = Data.Functor.Product.$w$cp1Ord1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg5LE: // global
           I64[Sp - 24] = block_cg5Lw_info;
           R2 = R2;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = R4;
           P64[Sp - 40] = R5;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = R3;
           Sp = Sp - 56;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg5Lw() //  [R1]
         { info_tbl: [(cg5Lw,
                       label: block_cg5Lw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Lw: // global
           if (R1 & 7 == 1) goto cg5Lz; else goto cg5LA;
       cg5Lz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg5LA: // global
           R2 = P64[Sp + 24];
           _sg5oV::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           _sg5oX::P64 = P64[Sp + 16];
           P64[Sp + 16] = _sg5oV::P64;
           P64[Sp + 24] = _sg5oX::P64;
           Sp = Sp + 8;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.949584175 UTC

[section ""data" . Data.Functor.Product.$fOrd1Product1_closure" {
     Data.Functor.Product.$fOrd1Product1_closure:
         const Data.Functor.Product.$fOrd1Product1_info;
 },
 Data.Functor.Product.$fOrd1Product1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg5LS,
                       label: Data.Functor.Product.$fOrd1Product1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5LS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg5LW; else goto cg5LX;
       cg5LW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrd1Product1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5LX: // global
           I64[Sp - 40] = block_cg5LP_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5M5; else goto cg5LQ;
       ug5M5: // global
           call _cg5LP(R1) args: 0, res: 0, upd: 0;
       cg5LQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5LP() //  [R1]
         { info_tbl: [(cg5LP,
                       label: block_cg5LP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5LP: // global
           I64[Sp - 8] = block_cg5LV_info;
           _sg5p7::P64 = P64[R1 + 7];
           _sg5p8::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5p8::P64;
           P64[Sp + 32] = _sg5p7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug5M4; else goto cg5LZ;
       ug5M4: // global
           call _cg5LV(R1) args: 0, res: 0, upd: 0;
       cg5LZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5LV() //  [R1]
         { info_tbl: [(cg5LV,
                       label: block_cg5LV_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5LV: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cp1Ord1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.951511881 UTC

[section ""data" . Data.Functor.Product.$fOrd1Product_closure" {
     Data.Functor.Product.$fOrd1Product_closure:
         const Data.Functor.Product.$fOrd1Product_info;
 },
 sat_sg5pf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg5Mf,
                       label: sat_sg5pf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Mf: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fOrd1Product_$cliftCompare_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pe_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg5Mn,
                       label: sat_sg5pe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Mn: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fOrd1Product1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fOrd1Product_entry() //  [R2, R3]
         { info_tbl: [(cg5Mr,
                       label: Data.Functor.Product.$fOrd1Product_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Mr: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg5Mv; else goto cg5Mu;
       cg5Mv: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrd1Product_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5Mu: // global
           I64[Hp - 64] = sat_sg5pf_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5pe_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 37;
           P64[Hp] = Hp - 61;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.952951463 UTC

[section ""cstring" . Data.Functor.Product.$fRead1Product3_bytes" {
     Data.Functor.Product.$fRead1Product3_bytes:
         I8[] [80,97,105,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.953818117 UTC

[section ""data" . Data.Functor.Product.$fRead1Product2_closure" {
     Data.Functor.Product.$fRead1Product2_closure:
         const Data.Functor.Product.$fRead1Product2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fRead1Product2_entry() //  [R1]
         { info_tbl: [(cg5MC,
                       label: Data.Functor.Product.$fRead1Product2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5MC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5MD; else goto cg5ME;
       cg5MD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5ME: // global
           (_cg5Mz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg5Mz::I64 == 0) goto cg5MB; else goto cg5MA;
       cg5MB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg5MA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg5Mz::I64;
           R2 = Data.Functor.Product.$fRead1Product3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.954785564 UTC

[section ""data" . Data.Functor.Product.$fRead1Product1_closure" {
     Data.Functor.Product.$fRead1Product1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Product.$fRead1Product2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.955419389 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_lvl3_closure" {
     Data.Functor.Product.$fRead1Product_lvl3_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.957917151 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadPrec_info;
         const 0;
 },
 reader_sg5pk_entry() //  [R1]
         { info_tbl: [(cg5MN,
                       label: reader_sg5pk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5MN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg5MO; else goto cg5MP;
       cg5MO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5MP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 reader1_sg5pl_entry() //  [R1]
         { info_tbl: [(cg5MU,
                       label: reader1_sg5pl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5MU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg5MV; else goto cg5MW;
       cg5MV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5MW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5pu_entry() //  [R1, R2]
         { info_tbl: [(cg5Nm,
                       label: sat_sg5pu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Nm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg5Nq; else goto cg5Np;
       cg5Nq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg5Np: // global
           _sg5po::P64 = P64[R1 + 7];
           _sg5pr::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = _sg5pr::P64;
           P64[Hp] = R2;
           R2 = Hp - 15;
           R1 = _sg5po::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pv_entry() //  [R1, R2]
         { info_tbl: [(cg5Nr,
                       label: sat_sg5pv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Nr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg5Nv; else goto cg5Nu;
       cg5Nv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg5Nu: // global
           _sg5pl::P64 = P64[R1 + 7];
           _sg5po::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sg5pu_info;
           P64[Hp - 8] = _sg5po::P64;
           P64[Hp] = R2;
           R3 = Hp - 15;
           R2 = Data.Functor.Product.$fRead1Product_lvl3_closure+1;
           R1 = _sg5pl::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pw_entry() //  [R1, R2]
         { info_tbl: [(cg5Nw,
                       label: sat_sg5pw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Nw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg5NA; else goto cg5Nz;
       cg5NA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg5Nz: // global
           _sg5pk::P64 = P64[R1 + 7];
           _sg5pl::P64 = P64[R1 + 15];
           _sg5po::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_sg5pv_info;
           P64[Hp - 8] = _sg5pl::P64;
           P64[Hp] = _sg5po::P64;
           R3 = Hp - 15;
           R2 = Data.Functor.Product.$fRead1Product_lvl3_closure+1;
           R1 = _sg5pk::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wlvl_sg5pm_entry() //  [R1, R2, R3]
         { info_tbl: [(cg5NE,
                       label: $wlvl_sg5pm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5NE: // global
           _sg5po::P64 = R3;
           _sg5pn::I64 = R2;
           _sg5pm::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cg5NF; else goto cg5NG;
       cg5NG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg5NI; else goto cg5NH;
       cg5NI: // global
           HpAlloc = 32;
           goto cg5NF;
       cg5NF: // global
           R3 = _sg5po::P64;
           R2 = _sg5pn::I64;
           R1 = _sg5pm::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5NH: // global
           if (%MO_S_Gt_W64(_sg5pn::I64, 10)) goto cg5NC; else goto cg5ND;
       cg5NC: // global
           Hp = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg5ND: // global
           _sg5pk::P64 = P64[_sg5pm::P64 + 6];
           _sg5pl::P64 = P64[_sg5pm::P64 + 14];
           I64[Hp - 24] = sat_sg5pw_info;
           P64[Hp - 16] = _sg5pk::P64;
           P64[Hp - 8] = _sg5pl::P64;
           P64[Hp] = _sg5po::P64;
           I64[Sp - 8] = block_cg5NJ_info;
           R3 = Hp - 23;
           R2 = Data.Functor.Product.$fRead1Product1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg5NJ() //  [R1]
         { info_tbl: [(cg5NJ,
                       label: block_cg5NJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5NJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg5NO; else goto cg5NN;
       cg5NO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg5NN: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl9_sg5pz_entry() //  [R1, R2, R3]
         { info_tbl: [(cg5NX,
                       label: lvl9_sg5pz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5NX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg5NY; else goto cg5NZ;
       cg5NY: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5NZ: // global
           I64[Sp - 24] = block_cg5NU_info;
           _sg5pm::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sg5pm::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug5O3; else goto cg5NV;
       ug5O3: // global
           call _cg5NU(R1) args: 0, res: 0, upd: 0;
       cg5NV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5NU() //  [R1]
         { info_tbl: [(cg5NU,
                       label: block_cg5NU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5NU: // global
           R3 = P64[Sp + 16];
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call $wlvl_sg5pm_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pG_entry() //  [R1, R2, R3]
         { info_tbl: [(cg5O9,
                       label: sat_sg5pG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5O9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cg5Oc,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Oc: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cg5Og; else goto cg5Of;
       cg5Og: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5Of: // global
           I64[Hp - 128] = reader_sg5pk_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R4;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = reader1_sg5pl_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = $wlvl_sg5pm_info;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 88;
           I64[Hp - 24] = lvl9_sg5pz_info;
           P64[Hp - 16] = Hp - 46;
           I64[Hp - 8] = sat_sg5pG_info;
           P64[Hp] = Hp - 22;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.963264846 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadsPrec_info;
         const 0;
 },
 sat_sg5pR_entry() //  [R1, R2, R3]
         { info_tbl: [(cg5Oy,
                       label: sat_sg5pR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Oy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg5Oz; else goto cg5OA;
       cg5Oz: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5OA: // global
           I64[Sp - 8] = block_cg5Ov_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Ov() //  [R1]
         { info_tbl: [(cg5Ov,
                       label: block_cg5Ov_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Ov: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg5OD; else goto cg5OC;
       cg5OD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg5OC: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pM_entry() //  [R1, R2]
         { info_tbl: [(cg5OJ,
                       label: sat_sg5pM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5OJ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sg5pL_entry() //  [R1]
         { info_tbl: [(cg5OM,
                       label: ds_sg5pL_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5OM: // global
           _sg5pL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg5ON; else goto cg5OO;
       cg5OO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg5OQ; else goto cg5OP;
       cg5OQ: // global
           HpAlloc = 32;
           goto cg5ON;
       cg5ON: // global
           R1 = _sg5pL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5OP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5pL::P64;
           _sg5pH::P64 = P64[_sg5pL::P64 + 16];
           _sg5pI::P64 = P64[_sg5pL::P64 + 24];
           _sg5pJ::P64 = P64[_sg5pL::P64 + 32];
           _sg5pK::P64 = P64[_sg5pL::P64 + 40];
           I64[Hp - 24] = sat_sg5pR_info;
           P64[Hp - 16] = _sg5pK::P64;
           I64[Hp - 8] = sat_sg5pM_info;
           P64[Hp] = _sg5pJ::P64;
           R5 = Hp - 22;
           R4 = Hp - 7;
           R3 = _sg5pI::P64;
           R2 = _sg5pH::P64;
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5pT_entry() //  [R1]
         { info_tbl: [(cg5P0,
                       label: sat_sg5pT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5P0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5P1; else goto cg5P2;
       cg5P1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5P2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5pU_entry() //  [R1, R2]
         { info_tbl: [(cg5P3,
                       label: sat_sg5pU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5P3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg5P7; else goto cg5P6;
       cg5P7: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg5P6: // global
           _sg5pL::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sg5pT_info;
           P64[Hp - 8] = _sg5pL::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadsPrec_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cg5P8,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5P8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg5Pc; else goto cg5Pb;
       cg5Pc: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5Pb: // global
           I64[Hp - 56] = ds_sg5pL_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = sat_sg5pU_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.966528554 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadListPrec_info;
         const 0;
 },
 sat_sg5pZ_entry() //  [R1]
         { info_tbl: [(cg5Pl,
                       label: sat_sg5pZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Pl: // global
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadListPrec_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cg5Po,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Po: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg5Ps; else goto cg5Pr;
       cg5Ps: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5Pr: // global
           I64[Hp - 40] = sat_sg5pZ_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.968890665 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_closure" {
     Data.Functor.Product.$fRead1Product_closure:
         const Data.Functor.Product.$fRead1Product_info;
         const 0;
 },
 sat_sg5q5_entry() //  [R1, R2, R3]
         { info_tbl: [(cg5PC,
                       label: sat_sg5q5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5PC: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fRead1Product_$cliftReadListPrec_entry(R5,
                                                                             R4,
                                                                             R3,
                                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5q4_entry() //  [R1, R2, R3]
         { info_tbl: [(cg5PK,
                       label: sat_sg5q4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5PK: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5q3_entry() //  [R1]
         { info_tbl: [(cg5PR,
                       label: sat_sg5q3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5PR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5PS; else goto cg5PT;
       cg5PS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5PT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_$cliftReadList_entry(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5q2_entry() //  [R1, R2, R3]
         { info_tbl: [(cg5PZ,
                       label: sat_sg5q2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5PZ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fRead1Product_$cliftReadsPrec_entry(R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_entry() //  [R2, R3]
         { info_tbl: [(cg5Q3,
                       label: Data.Functor.Product.$fRead1Product_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Q3: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cg5Q7; else goto cg5Q6;
       cg5Q7: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5Q6: // global
           I64[Hp - 136] = sat_sg5q5_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sg5q4_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sg5q3_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sg5q2_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 54;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 134;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadList_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadList_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadList_info;
         const 0;
 },
 sat_sg5q8_entry() //  [R1]
         { info_tbl: [(cg5Qg,
                       label: sat_sg5q8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Qg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5Qh; else goto cg5Qi;
       cg5Qh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5Qi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_entry(R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadList_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cg5Qj,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Qj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg5Qn; else goto cg5Qm;
       cg5Qn: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5Qm: // global
           I64[Hp - 24] = sat_sg5q8_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.973985821 UTC

[section ""data" . Data.Functor.Product.$w$cliftShowsPrec_closure" {
     Data.Functor.Product.$w$cliftShowsPrec_closure:
         const Data.Functor.Product.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Qp: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5qh_entry() //  [R1]
         { info_tbl: [(cg5Qx,
                       label: sat_sg5qh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Qx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg5Qy; else goto cg5Qz;
       cg5Qy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5Qz: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5qg_entry() //  [R1]
         { info_tbl: [(cg5QE,
                       label: sat_sg5qg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5QE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg5QF; else goto cg5QG;
       cg5QF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5QG: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg5QH,
                       label: Data.Functor.Product.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, True, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5QH: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg5QL; else goto cg5QK;
       cg5QL: // global
           HpAlloc = 80;
           R1 = Data.Functor.Product.$w$cliftShowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg5QK: // global
           I64[Hp - 72] = sat_sg5qh_info;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sg5qg_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sg5qd::I64 = R6;
           R6 = P64[Sp];
           R5 = _sg5qd::I64;
           R4 = Data.Functor.Product.$fRead1Product2_closure;
           R3 = Hp - 72;
           R2 = Hp - 32;
           Sp = Sp + 8;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.976109912 UTC

[section ""data" . Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure" {
     Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure:
         const Data.Functor.Product.$fShow1Product_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$fShow1Product_$cliftShowsPrec_entry() //  [R2,
                                                                  R3, R4, R5, R6]
         { info_tbl: [(cg5QT,
                       label: Data.Functor.Product.$fShow1Product_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5QT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg5QX; else goto cg5QY;
       cg5QX: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg5QY: // global
           I64[Sp - 40] = block_cg5QQ_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5R6; else goto cg5QR;
       ug5R6: // global
           call _cg5QQ(R1) args: 0, res: 0, upd: 0;
       cg5QR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5QQ() //  [R1]
         { info_tbl: [(cg5QQ,
                       label: block_cg5QQ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5QQ: // global
           I64[Sp] = block_cg5QW_info;
           _sg5qp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sg5qp::I64;
           if (R1 & 7 != 0) goto ug5R5; else goto cg5R0;
       ug5R5: // global
           call _cg5QW(R1) args: 0, res: 0, upd: 0;
       cg5R0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5QW() //  [R1]
         { info_tbl: [(cg5QW,
                       label: block_cg5QW_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5QW: // global
           R6 = I64[Sp + 40];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.977534143 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct4_closure" {
     Data.Functor.Product.$fFoldableProduct4_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.978664116 UTC

[section ""data" . Data.Functor.Product.$fShow1Product_$cliftShowList_closure" {
     Data.Functor.Product.$fShow1Product_$cliftShowList_closure:
         const Data.Functor.Product.$fShow1Product_$cliftShowList_info;
         const 0;
 },
 sat_sg5qD_entry() //  [R1, R2]
         { info_tbl: [(cg5Rj,
                       label: sat_sg5qD_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Rj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg5Rk; else goto cg5Rl;
       cg5Rk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg5Rl: // global
           I64[Sp - 40] = block_cg5Rg_info;
           _sg5qt::P64 = P64[R1 + 7];
           _sg5qu::P64 = P64[R1 + 15];
           _sg5qv::P64 = P64[R1 + 23];
           _sg5qw::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5qt::P64;
           P64[Sp - 24] = _sg5qu::P64;
           P64[Sp - 16] = _sg5qv::P64;
           P64[Sp - 8] = _sg5qw::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5Rp; else goto cg5Rh;
       ug5Rp: // global
           call _cg5Rg(R1) args: 0, res: 0, upd: 0;
       cg5Rh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Rg() //  [R1]
         { info_tbl: [(cg5Rg,
                       label: block_cg5Rg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Rg: // global
           R6 = 0;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShow1Product_$cliftShowList_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cg5Rq,
                       label: Data.Functor.Product.$fShow1Product_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Rq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg5Ru; else goto cg5Rt;
       cg5Ru: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShow1Product_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg5Rt: // global
           I64[Hp - 32] = sat_sg5qD_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 31;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.980768765 UTC

[section ""data" . Data.Functor.Product.$fShow1Product_closure" {
     Data.Functor.Product.$fShow1Product_closure:
         const Data.Functor.Product.$fShow1Product_info;
         const 0;
 },
 sat_sg5qH_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg5RE,
                       label: sat_sg5qH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5RE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg5RF; else goto cg5RG;
       cg5RF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5RG: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Product.$fShow1Product_$cliftShowList_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_sg5qG_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg5RM,
                       label: sat_sg5qG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5RM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg5RN; else goto cg5RO;
       cg5RN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5RO: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Product.$fShow1Product_$cliftShowsPrec_entry(R6,
                                                                          R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShow1Product_entry() //  [R2, R3]
         { info_tbl: [(cg5RQ,
                       label: Data.Functor.Product.$fShow1Product_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5RQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg5RU; else goto cg5RT;
       cg5RU: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShow1Product_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5RT: // global
           I64[Hp - 64] = sat_sg5qH_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5qG_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 36;
           P64[Hp] = Hp - 60;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.983323724 UTC

[section ""data" . Data.Functor.Product.$w$c==_closure" {
     Data.Functor.Product.$w$c==_closure:
         const Data.Functor.Product.$w$c==_info;
 },
 Data.Functor.Product.$w$c==_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5RW: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c==_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 24, res: 0, upd: 8;
     }
 },
 eq_sg5qP_entry() //  [R1]
         { info_tbl: [(cg5S4,
                       label: eq_sg5qP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5S4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5S5; else goto cg5S6;
       cg5S5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5S6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c==_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg5Sd,
                       label: Data.Functor.Product.$w$c==_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Sd: // global
           _sg5qM::P64 = R6;
           _sg5qL::P64 = R5;
           _sg5qK::P64 = R4;
           _sg5qJ::P64 = R3;
           _sg5qI::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cg5Se; else goto cg5Sf;
       cg5Sf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg5Sh; else goto cg5Sg;
       cg5Sh: // global
           HpAlloc = 24;
           goto cg5Se;
       cg5Se: // global
           R1 = Data.Functor.Product.$w$c==_closure;
           P64[Sp - 40] = _sg5qI::P64;
           P64[Sp - 32] = _sg5qJ::P64;
           P64[Sp - 24] = _sg5qK::P64;
           P64[Sp - 16] = _sg5qL::P64;
           P64[Sp - 8] = _sg5qM::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg5Sg: // global
           I64[Hp - 16] = eq_sg5qP_info;
           P64[Hp] = _sg5qK::P64;
           I64[Sp - 24] = block_cg5S7_info;
           R4 = P64[Sp];
           R3 = _sg5qL::P64;
           _cg5S0::P64 = Hp - 16;
           R2 = _cg5S0::P64;
           R1 = _sg5qI::P64;
           P64[Sp - 16] = _sg5qJ::P64;
           P64[Sp - 8] = _sg5qM::P64;
           P64[Sp] = _cg5S0::P64;
           Sp = Sp - 24;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5S7() //  [R1]
         { info_tbl: [(cg5S7,
                       label: block_cg5S7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5S7: // global
           if (R1 & 7 == 1) goto cg5Sa; else goto cg5Sb;
       cg5Sa: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg5Sb: // global
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.985503666 UTC

[section ""data" . Data.Functor.Product.$fEqProduct_$c==_closure" {
     Data.Functor.Product.$fEqProduct_$c==_closure:
         const Data.Functor.Product.$fEqProduct_$c==_info;
 },
 Data.Functor.Product.$fEqProduct_$c==_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg5Sv,
                       label: Data.Functor.Product.$fEqProduct_$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Sv: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg5Sz; else goto cg5SA;
       cg5Sz: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEqProduct_$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5SA: // global
           I64[Sp - 40] = block_cg5Ss_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5SI; else goto cg5St;
       ug5SI: // global
           call _cg5Ss(R1) args: 0, res: 0, upd: 0;
       cg5St: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Ss() //  [R1]
         { info_tbl: [(cg5Ss,
                       label: block_cg5Ss_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Ss: // global
           I64[Sp - 8] = block_cg5Sy_info;
           _sg5qX::P64 = P64[R1 + 7];
           _sg5qY::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5qY::P64;
           P64[Sp + 32] = _sg5qX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug5SH; else goto cg5SC;
       ug5SH: // global
           call _cg5Sy(R1) args: 0, res: 0, upd: 0;
       cg5SC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Sy() //  [R1]
         { info_tbl: [(cg5Sy,
                       label: block_cg5Sy_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Sy: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c==_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.987823432 UTC

[section ""data" . Data.Functor.Product.$fEqProduct_$c/=_closure" {
     Data.Functor.Product.$fEqProduct_$c/=_closure:
         const Data.Functor.Product.$fEqProduct_$c/=_info;
 },
 eq_sg5rd_entry() //  [R1]
         { info_tbl: [(cg5T1,
                       label: eq_sg5rd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5T1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5T2; else goto cg5T3;
       cg5T2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5T3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fEqProduct_$c/=_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg5T4,
                       label: Data.Functor.Product.$fEqProduct_$c/=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5T4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg5T5; else goto cg5T6;
       cg5T5: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEqProduct_$c/=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5T6: // global
           I64[Sp - 40] = block_cg5SN_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5TC; else goto cg5SO;
       ug5TC: // global
           call _cg5SN(R1) args: 0, res: 0, upd: 0;
       cg5SO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5SN() //  [R1]
         { info_tbl: [(cg5SN,
                       label: block_cg5SN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5SN: // global
           I64[Sp - 8] = block_cg5SS_info;
           _sg5r8::P64 = P64[R1 + 7];
           _sg5r9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5r9::P64;
           P64[Sp + 32] = _sg5r8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug5TB; else goto cg5ST;
       ug5TB: // global
           call _cg5SS(R1) args: 0, res: 0, upd: 0;
       cg5ST: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5SS() //  [R1]
         { info_tbl: [(cg5SS,
                       label: block_cg5SS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5SS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg5Tb; else goto cg5Ta;
       cg5Tb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg5Ta: // global
           _sg5rb::P64 = P64[R1 + 7];
           _sg5rc::P64 = P64[R1 + 15];
           I64[Hp - 16] = eq_sg5rd_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_cg5T8_info;
           R4 = _sg5rb::P64;
           R3 = P64[Sp + 40];
           _cg5SX::P64 = Hp - 16;
           R2 = _cg5SX::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 32] = _sg5rc::P64;
           P64[Sp + 40] = _cg5SX::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5T8() //  [R1]
         { info_tbl: [(cg5T8,
                       label: block_cg5T8_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5T8: // global
           if (R1 & 7 == 1) goto ug5Tz; else goto cg5Tm;
       ug5Tz: // global
           Sp = Sp + 48;
           call _cg5Ts() args: 0, res: 0, upd: 0;
       cg5Tm: // global
           _cg5SX::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cg5Tk_info;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 8];
           R2 = _cg5SX::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Tk() //  [R1]
         { info_tbl: [(cg5Tk,
                       label: block_cg5Tk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Tk: // global
           if (R1 & 7 == 1) goto ug5TA; else goto cg5Tw;
       ug5TA: // global
           Sp = Sp + 8;
           call _cg5Ts() args: 0, res: 0, upd: 0;
       cg5Tw: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg5Ts() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Ts: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.99066355 UTC

[section ""data" . Data.Functor.Product.$fEqProduct_closure" {
     Data.Functor.Product.$fEqProduct_closure:
         const Data.Functor.Product.$fEqProduct_info;
 },
 sat_sg5rk_entry() //  [R1, R2, R3]
         { info_tbl: [(cg5TO,
                       label: sat_sg5rk_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5TO: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fEqProduct_$c/=_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5rj_entry() //  [R1, R2, R3]
         { info_tbl: [(cg5TW,
                       label: sat_sg5rj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5TW: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fEqProduct_$c==_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fEqProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cg5U0,
                       label: Data.Functor.Product.$fEqProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5U0: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg5U4; else goto cg5U3;
       cg5U4: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEqProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5U3: // global
           I64[Hp - 80] = sat_sg5rk_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg5rj_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 78;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.992831086 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$ccompare_closure" {
     Data.Functor.Product.$fOrdProduct_$ccompare_closure:
         const Data.Functor.Product.$fOrdProduct_$ccompare_info;
 },
 w_sg5rw_entry() //  [R1]
         { info_tbl: [(cg5Un,
                       label: w_sg5rw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Un: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5Uo; else goto cg5Up;
       cg5Uo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5Up: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$ccompare_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cg5Uq,
                       label: Data.Functor.Product.$fOrdProduct_$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Uq: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cg5Ur; else goto cg5Us;
       cg5Ur: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5Us: // global
           I64[Sp - 40] = block_cg5U9_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5UP; else goto cg5Ua;
       ug5UP: // global
           call _cg5U9(R1) args: 0, res: 0, upd: 0;
       cg5Ua: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5U9() //  [R1]
         { info_tbl: [(cg5U9,
                       label: block_cg5U9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5U9: // global
           I64[Sp - 8] = block_cg5Ue_info;
           _sg5rr::P64 = P64[R1 + 7];
           _sg5rs::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5rs::P64;
           P64[Sp + 32] = _sg5rr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug5UO; else goto cg5Uf;
       ug5UO: // global
           call _cg5Ue(R1) args: 0, res: 0, upd: 0;
       cg5Uf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Ue() //  [R1]
         { info_tbl: [(cg5Ue,
                       label: block_cg5Ue_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Ue: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg5Ux; else goto cg5Uw;
       cg5Ux: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg5Uw: // global
           _sg5ru::P64 = P64[R1 + 7];
           _sg5rv::P64 = P64[R1 + 15];
           I64[Hp - 16] = w_sg5rw_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_cg5Uu_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           _cg5Uj::P64 = Hp - 16;
           P64[Sp - 24] = _cg5Uj::P64;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = _sg5ru::P64;
           P64[Sp + 32] = _sg5rv::P64;
           P64[Sp + 40] = _cg5Uj::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg5Uu() //  [R1]
         { info_tbl: [(cg5Uu,
                       label: block_cg5Uu_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Uu: // global
           _cg5UM::P64 = R1 & 7;
           if (_cg5UM::P64 < 3) goto ug5UN; else goto cg5UL;
       ug5UN: // global
           if (_cg5UM::P64 < 2) goto cg5UD; else goto cg5UH;
       cg5UD: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg5UH: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_ppp_info;
           P64[Sp + 24] = P64[Sp + 40];
           _sg5rv::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 8];
           P64[Sp + 40] = _sg5rv::P64;
           Sp = Sp + 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
       cg5UL: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.995620974 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$cp1Ord_closure" {
     Data.Functor.Product.$fOrdProduct_$cp1Ord_closure:
         const Data.Functor.Product.$fOrdProduct_$cp1Ord_info;
 },
 sat_sg5rD_entry() //  [R1]
         { info_tbl: [(cg5UY,
                       label: sat_sg5rD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5UY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5UZ; else goto cg5V0;
       cg5UZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5V0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5rC_entry() //  [R1]
         { info_tbl: [(cg5V5,
                       label: sat_sg5rC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5V5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5V6; else goto cg5V7;
       cg5V6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5V7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5rB_entry() //  [R1]
         { info_tbl: [(cg5Vc,
                       label: sat_sg5rB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Vc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5Vd; else goto cg5Ve;
       cg5Vd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5Ve: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$cp1Ord_entry() //  [R2, R3, R4]
         { info_tbl: [(cg5Vf,
                       label: Data.Functor.Product.$fOrdProduct_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Vf: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg5Vj; else goto cg5Vi;
       cg5Vj: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$cp1Ord_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5Vi: // global
           I64[Hp - 64] = sat_sg5rD_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sg5rC_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5rB_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fEqProduct_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:54.998141306 UTC

[section ""data" . Data.Functor.Product.$w$c<_closure" {
     Data.Functor.Product.$w$c<_closure:
         const Data.Functor.Product.$w$c<_info;
 },
 Data.Functor.Product.$w$c<_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Vl: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c<_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sg5rL_entry() //  [R1]
         { info_tbl: [(cg5Vt,
                       label: comp_sg5rL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Vt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5Vu; else goto cg5Vv;
       cg5Vu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5Vv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg5VD,
                       label: Data.Functor.Product.$w$c<_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5VD: // global
           _sg5rI::P64 = R6;
           _sg5rH::P64 = R5;
           _sg5rG::P64 = R4;
           _sg5rF::P64 = R3;
           _sg5rE::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg5VE; else goto cg5VF;
       cg5VF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg5VH; else goto cg5VG;
       cg5VH: // global
           HpAlloc = 24;
           goto cg5VE;
       cg5VE: // global
           R1 = Data.Functor.Product.$w$c<_closure;
           P64[Sp - 40] = _sg5rE::P64;
           P64[Sp - 32] = _sg5rF::P64;
           P64[Sp - 24] = _sg5rG::P64;
           P64[Sp - 16] = _sg5rH::P64;
           P64[Sp - 8] = _sg5rI::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg5VG: // global
           I64[Hp - 16] = comp_sg5rL_info;
           P64[Hp] = _sg5rG::P64;
           I64[Sp - 24] = block_cg5Vw_info;
           R2 = _sg5rE::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cg5Vp::P64 = Hp - 16;
           P64[Sp - 48] = _cg5Vp::P64;
           P64[Sp - 40] = _sg5rH::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sg5rF::P64;
           P64[Sp - 8] = _sg5rI::P64;
           P64[Sp] = _cg5Vp::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg5Vw() //  [R1]
         { info_tbl: [(cg5Vw,
                       label: block_cg5Vw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Vw: // global
           _cg5VC::P64 = R1 & 7;
           if (_cg5VC::P64 < 3) goto ug5W3; else goto ug5W4;
       ug5W3: // global
           if (_cg5VC::P64 < 2) goto ug5W5; else goto cg5VA;
       ug5W5: // global
           Sp = Sp + 40;
           call _cg5VY() args: 0, res: 0, upd: 0;
       cg5VA: // global
           _sg5rK::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg5VN_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sg5rK::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug5W4: // global
           Sp = Sp + 40;
           call _cg5VB() args: 0, res: 0, upd: 0;
     }
 },
 _cg5VN() //  [R1]
         { info_tbl: [(cg5VN,
                       label: block_cg5VN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5VN: // global
           if (R1 & 7 == 1) goto ug5W6; else goto ug5W7;
       ug5W6: // global
           Sp = Sp + 8;
           call _cg5VY() args: 0, res: 0, upd: 0;
       ug5W7: // global
           Sp = Sp + 8;
           call _cg5VB() args: 0, res: 0, upd: 0;
     }
 },
 _cg5VY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5VY: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg5VB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5VB: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.000877924 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c<_closure" {
     Data.Functor.Product.$fOrdProduct_$c<_closure:
         const Data.Functor.Product.$fOrdProduct_$c<_info;
 },
 Data.Functor.Product.$fOrdProduct_$c<_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg5Wj,
                       label: Data.Functor.Product.$fOrdProduct_$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Wj: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg5Wn; else goto cg5Wo;
       cg5Wn: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5Wo: // global
           I64[Sp - 40] = block_cg5Wg_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5Ww; else goto cg5Wh;
       ug5Ww: // global
           call _cg5Wg(R1) args: 0, res: 0, upd: 0;
       cg5Wh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Wg() //  [R1]
         { info_tbl: [(cg5Wg,
                       label: block_cg5Wg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Wg: // global
           I64[Sp - 8] = block_cg5Wm_info;
           _sg5rU::P64 = P64[R1 + 7];
           _sg5rV::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5rV::P64;
           P64[Sp + 32] = _sg5rU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug5Wv; else goto cg5Wq;
       ug5Wv: // global
           call _cg5Wm(R1) args: 0, res: 0, upd: 0;
       cg5Wq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Wm() //  [R1]
         { info_tbl: [(cg5Wm,
                       label: block_cg5Wm_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Wm: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c<_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.003221522 UTC

[section ""data" . Data.Functor.Product.$w$c>=_closure" {
     Data.Functor.Product.$w$c>=_closure:
         const Data.Functor.Product.$w$c>=_info;
 },
 Data.Functor.Product.$w$c>=_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Wy: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c>=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sg5s6_entry() //  [R1]
         { info_tbl: [(cg5WG,
                       label: comp_sg5s6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5WG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5WH; else goto cg5WI;
       cg5WH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5WI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c>=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg5WQ,
                       label: Data.Functor.Product.$w$c>=_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5WQ: // global
           _sg5s3::P64 = R6;
           _sg5s2::P64 = R5;
           _sg5s1::P64 = R4;
           _sg5s0::P64 = R3;
           _sg5rZ::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg5WR; else goto cg5WS;
       cg5WS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg5WU; else goto cg5WT;
       cg5WU: // global
           HpAlloc = 24;
           goto cg5WR;
       cg5WR: // global
           R1 = Data.Functor.Product.$w$c>=_closure;
           P64[Sp - 40] = _sg5rZ::P64;
           P64[Sp - 32] = _sg5s0::P64;
           P64[Sp - 24] = _sg5s1::P64;
           P64[Sp - 16] = _sg5s2::P64;
           P64[Sp - 8] = _sg5s3::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg5WT: // global
           I64[Hp - 16] = comp_sg5s6_info;
           P64[Hp] = _sg5s1::P64;
           I64[Sp - 24] = block_cg5WJ_info;
           R2 = _sg5rZ::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cg5WC::P64 = Hp - 16;
           P64[Sp - 48] = _cg5WC::P64;
           P64[Sp - 40] = _sg5s2::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sg5s0::P64;
           P64[Sp - 8] = _sg5s3::P64;
           P64[Sp] = _cg5WC::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg5WJ() //  [R1]
         { info_tbl: [(cg5WJ,
                       label: block_cg5WJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5WJ: // global
           _cg5WP::P64 = R1 & 7;
           if (_cg5WP::P64 < 3) goto ug5Xg; else goto ug5Xh;
       ug5Xg: // global
           if (_cg5WP::P64 < 2) goto ug5Xi; else goto cg5WN;
       ug5Xi: // global
           Sp = Sp + 40;
           call _cg5Xb() args: 0, res: 0, upd: 0;
       cg5WN: // global
           _sg5s5::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg5X0_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sg5s5::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug5Xh: // global
           Sp = Sp + 40;
           call _cg5WO() args: 0, res: 0, upd: 0;
     }
 },
 _cg5X0() //  [R1]
         { info_tbl: [(cg5X0,
                       label: block_cg5X0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5X0: // global
           if (R1 & 7 == 1) goto ug5Xj; else goto ug5Xk;
       ug5Xj: // global
           Sp = Sp + 8;
           call _cg5Xb() args: 0, res: 0, upd: 0;
       ug5Xk: // global
           Sp = Sp + 8;
           call _cg5WO() args: 0, res: 0, upd: 0;
     }
 },
 _cg5Xb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Xb: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg5WO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5WO: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.007084796 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c>=_closure" {
     Data.Functor.Product.$fOrdProduct_$c>=_closure:
         const Data.Functor.Product.$fOrdProduct_$c>=_info;
 },
 Data.Functor.Product.$fOrdProduct_$c>=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg5Xw,
                       label: Data.Functor.Product.$fOrdProduct_$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Xw: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg5XA; else goto cg5XB;
       cg5XA: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5XB: // global
           I64[Sp - 40] = block_cg5Xt_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5XJ; else goto cg5Xu;
       ug5XJ: // global
           call _cg5Xt(R1) args: 0, res: 0, upd: 0;
       cg5Xu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Xt() //  [R1]
         { info_tbl: [(cg5Xt,
                       label: block_cg5Xt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Xt: // global
           I64[Sp - 8] = block_cg5Xz_info;
           _sg5sf::P64 = P64[R1 + 7];
           _sg5sg::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5sg::P64;
           P64[Sp + 32] = _sg5sf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug5XI; else goto cg5XD;
       ug5XI: // global
           call _cg5Xz(R1) args: 0, res: 0, upd: 0;
       cg5XD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5Xz() //  [R1]
         { info_tbl: [(cg5Xz,
                       label: block_cg5Xz_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Xz: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c>=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.009323504 UTC

[section ""data" . Data.Functor.Product.$w$c>_closure" {
     Data.Functor.Product.$w$c>_closure:
         const Data.Functor.Product.$w$c>_info;
 },
 Data.Functor.Product.$w$c>_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5XL: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sg5sr_entry() //  [R1]
         { info_tbl: [(cg5XT,
                       label: comp_sg5sr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5XT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5XU; else goto cg5XV;
       cg5XU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5XV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg5Y3,
                       label: Data.Functor.Product.$w$c>_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Y3: // global
           _sg5so::P64 = R6;
           _sg5sn::P64 = R5;
           _sg5sm::P64 = R4;
           _sg5sl::P64 = R3;
           _sg5sk::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg5Y4; else goto cg5Y5;
       cg5Y5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg5Y7; else goto cg5Y6;
       cg5Y7: // global
           HpAlloc = 24;
           goto cg5Y4;
       cg5Y4: // global
           R1 = Data.Functor.Product.$w$c>_closure;
           P64[Sp - 40] = _sg5sk::P64;
           P64[Sp - 32] = _sg5sl::P64;
           P64[Sp - 24] = _sg5sm::P64;
           P64[Sp - 16] = _sg5sn::P64;
           P64[Sp - 8] = _sg5so::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg5Y6: // global
           I64[Hp - 16] = comp_sg5sr_info;
           P64[Hp] = _sg5sm::P64;
           I64[Sp - 24] = block_cg5XW_info;
           R2 = _sg5sk::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cg5XP::P64 = Hp - 16;
           P64[Sp - 48] = _cg5XP::P64;
           P64[Sp - 40] = _sg5sn::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sg5sl::P64;
           P64[Sp - 8] = _sg5so::P64;
           P64[Sp] = _cg5XP::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg5XW() //  [R1]
         { info_tbl: [(cg5XW,
                       label: block_cg5XW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5XW: // global
           _cg5Y2::P64 = R1 & 7;
           if (_cg5Y2::P64 < 3) goto ug5Yt; else goto ug5Yu;
       ug5Yt: // global
           if (_cg5Y2::P64 < 2) goto ug5Yv; else goto cg5Y0;
       ug5Yv: // global
           Sp = Sp + 40;
           call _cg5Yk() args: 0, res: 0, upd: 0;
       cg5Y0: // global
           _sg5sq::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg5Yd_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sg5sq::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug5Yu: // global
           Sp = Sp + 40;
           call _cg5Y1() args: 0, res: 0, upd: 0;
     }
 },
 _cg5Yd() //  [R1]
         { info_tbl: [(cg5Yd,
                       label: block_cg5Yd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Yd: // global
           if (R1 & 7 == 3) goto ug5Yw; else goto ug5Yx;
       ug5Yw: // global
           Sp = Sp + 8;
           call _cg5Y1() args: 0, res: 0, upd: 0;
       ug5Yx: // global
           Sp = Sp + 8;
           call _cg5Yk() args: 0, res: 0, upd: 0;
     }
 },
 _cg5Yk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Yk: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg5Y1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Y1: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.011738803 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c>_closure" {
     Data.Functor.Product.$fOrdProduct_$c>_closure:
         const Data.Functor.Product.$fOrdProduct_$c>_info;
 },
 Data.Functor.Product.$fOrdProduct_$c>_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg5YJ,
                       label: Data.Functor.Product.$fOrdProduct_$c>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5YJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg5YN; else goto cg5YO;
       cg5YN: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5YO: // global
           I64[Sp - 40] = block_cg5YG_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5YW; else goto cg5YH;
       ug5YW: // global
           call _cg5YG(R1) args: 0, res: 0, upd: 0;
       cg5YH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5YG() //  [R1]
         { info_tbl: [(cg5YG,
                       label: block_cg5YG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5YG: // global
           I64[Sp - 8] = block_cg5YM_info;
           _sg5sA::P64 = P64[R1 + 7];
           _sg5sB::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5sB::P64;
           P64[Sp + 32] = _sg5sA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug5YV; else goto cg5YQ;
       ug5YV: // global
           call _cg5YM(R1) args: 0, res: 0, upd: 0;
       cg5YQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5YM() //  [R1]
         { info_tbl: [(cg5YM,
                       label: block_cg5YM_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5YM: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.014223163 UTC

[section ""data" . Data.Functor.Product.$w$c<=_closure" {
     Data.Functor.Product.$w$c<=_closure:
         const Data.Functor.Product.$w$c<=_info;
 },
 Data.Functor.Product.$w$c<=_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5YY: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c<=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sg5sM_entry() //  [R1]
         { info_tbl: [(cg5Z6,
                       label: comp_sg5sM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Z6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg5Z7; else goto cg5Z8;
       cg5Z7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5Z8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg5Zg,
                       label: Data.Functor.Product.$w$c<=_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Zg: // global
           _sg5sJ::P64 = R6;
           _sg5sI::P64 = R5;
           _sg5sH::P64 = R4;
           _sg5sG::P64 = R3;
           _sg5sF::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg5Zh; else goto cg5Zi;
       cg5Zi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg5Zk; else goto cg5Zj;
       cg5Zk: // global
           HpAlloc = 24;
           goto cg5Zh;
       cg5Zh: // global
           R1 = Data.Functor.Product.$w$c<=_closure;
           P64[Sp - 40] = _sg5sF::P64;
           P64[Sp - 32] = _sg5sG::P64;
           P64[Sp - 24] = _sg5sH::P64;
           P64[Sp - 16] = _sg5sI::P64;
           P64[Sp - 8] = _sg5sJ::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg5Zj: // global
           I64[Hp - 16] = comp_sg5sM_info;
           P64[Hp] = _sg5sH::P64;
           I64[Sp - 24] = block_cg5Z9_info;
           R2 = _sg5sF::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cg5Z2::P64 = Hp - 16;
           P64[Sp - 48] = _cg5Z2::P64;
           P64[Sp - 40] = _sg5sI::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sg5sG::P64;
           P64[Sp - 8] = _sg5sJ::P64;
           P64[Sp] = _cg5Z2::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg5Z9() //  [R1]
         { info_tbl: [(cg5Z9,
                       label: block_cg5Z9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Z9: // global
           _cg5Zf::P64 = R1 & 7;
           if (_cg5Zf::P64 < 3) goto ug5ZG; else goto ug5ZH;
       ug5ZG: // global
           if (_cg5Zf::P64 < 2) goto ug5ZI; else goto cg5Zd;
       ug5ZI: // global
           Sp = Sp + 40;
           call _cg5Zx() args: 0, res: 0, upd: 0;
       cg5Zd: // global
           _sg5sL::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg5Zq_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sg5sL::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug5ZH: // global
           Sp = Sp + 40;
           call _cg5Ze() args: 0, res: 0, upd: 0;
     }
 },
 _cg5Zq() //  [R1]
         { info_tbl: [(cg5Zq,
                       label: block_cg5Zq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Zq: // global
           if (R1 & 7 == 3) goto ug5ZJ; else goto ug5ZK;
       ug5ZJ: // global
           Sp = Sp + 8;
           call _cg5Ze() args: 0, res: 0, upd: 0;
       ug5ZK: // global
           Sp = Sp + 8;
           call _cg5Zx() args: 0, res: 0, upd: 0;
     }
 },
 _cg5Zx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Zx: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg5Ze() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5Ze: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.016725001 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c<=_closure" {
     Data.Functor.Product.$fOrdProduct_$c<=_closure:
         const Data.Functor.Product.$fOrdProduct_$c<=_info;
 },
 Data.Functor.Product.$fOrdProduct_$c<=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg5ZW,
                       label: Data.Functor.Product.$fOrdProduct_$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5ZW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg600; else goto cg601;
       cg600: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg601: // global
           I64[Sp - 40] = block_cg5ZT_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug609; else goto cg5ZU;
       ug609: // global
           call _cg5ZT(R1) args: 0, res: 0, upd: 0;
       cg5ZU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5ZT() //  [R1]
         { info_tbl: [(cg5ZT,
                       label: block_cg5ZT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5ZT: // global
           I64[Sp - 8] = block_cg5ZZ_info;
           _sg5sV::P64 = P64[R1 + 7];
           _sg5sW::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5sW::P64;
           P64[Sp + 32] = _sg5sV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug608; else goto cg603;
       ug608: // global
           call _cg5ZZ(R1) args: 0, res: 0, upd: 0;
       cg603: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg5ZZ() //  [R1]
         { info_tbl: [(cg5ZZ,
                       label: block_cg5ZZ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5ZZ: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c<=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.019187154 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$cmax_closure" {
     Data.Functor.Product.$fOrdProduct_$cmax_closure:
         const Data.Functor.Product.$fOrdProduct_$cmax_info;
 },
 comp_sg5tb_entry() //  [R1]
         { info_tbl: [(cg60s,
                       label: comp_sg5tb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg60s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg60t; else goto cg60u;
       cg60t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg60u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$cmax_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cg60v,
                       label: Data.Functor.Product.$fOrdProduct_$cmax_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg60v: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cg60w; else goto cg60x;
       cg60w: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$cmax_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg60x: // global
           I64[Sp - 40] = block_cg60e_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug61a; else goto cg60f;
       ug61a: // global
           call _cg60e(R1) args: 0, res: 0, upd: 0;
       cg60f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg60e() //  [R1]
         { info_tbl: [(cg60e,
                       label: block_cg60e_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg60e: // global
           I64[Sp - 16] = block_cg60j_info;
           _sg5t5::P64 = R1;
           _sg5t6::P64 = P64[R1 + 7];
           _sg5t7::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _sg5t7::P64;
           P64[Sp] = _sg5t6::P64;
           P64[Sp + 32] = _sg5t5::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ug619; else goto cg60k;
       ug619: // global
           call _cg60j(R1) args: 0, res: 0, upd: 0;
       cg60k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg60j() //  [R1]
         { info_tbl: [(cg60j,
                       label: block_cg60j_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg60j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg60C; else goto cg60B;
       cg60C: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg60B: // global
           _sg5t9::P64 = P64[R1 + 7];
           _sg5ta::P64 = P64[R1 + 15];
           I64[Hp - 16] = comp_sg5tb_info;
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_cg60z_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_ppp_info;
           _cg60o::P64 = Hp - 16;
           P64[Sp - 24] = _cg60o::P64;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = _sg5t9::P64;
           P64[Sp + 16] = _sg5ta::P64;
           P64[Sp + 24] = R1;
           P64[Sp + 40] = _cg60o::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg60z() //  [R1]
         { info_tbl: [(cg60z,
                       label: block_cg60z_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg60z: // global
           _cg612::P64 = R1 & 7;
           if (_cg612::P64 < 3) goto ug614; else goto ug615;
       ug614: // global
           if (_cg612::P64 < 2) goto ug616; else goto cg60N;
       ug616: // global
           Sp = Sp + 24;
           call _cg60T() args: 0, res: 0, upd: 0;
       cg60N: // global
           _sg5ta::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cg60L_info;
           R2 = P64[Sp + 32];
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _sg5ta::P64;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug615: // global
           Sp = Sp + 48;
           call _cg611() args: 0, res: 0, upd: 0;
     }
 },
 _cg60L() //  [R1]
         { info_tbl: [(cg60L,
                       label: block_cg60L_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg60L: // global
           if (R1 & 7 == 3) goto ug617; else goto ug618;
       ug617: // global
           Sp = Sp + 32;
           call _cg611() args: 0, res: 0, upd: 0;
       ug618: // global
           Sp = Sp + 8;
           call _cg60T() args: 0, res: 0, upd: 0;
     }
 },
 _cg60T() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg60T: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg611() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg611: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.02271831 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$cmin_closure" {
     Data.Functor.Product.$fOrdProduct_$cmin_closure:
         const Data.Functor.Product.$fOrdProduct_$cmin_info;
 },
 comp_sg5tp_entry() //  [R1]
         { info_tbl: [(cg61x,
                       label: comp_sg5tp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg61x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg61y; else goto cg61z;
       cg61y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg61z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$cmin_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cg61A,
                       label: Data.Functor.Product.$fOrdProduct_$cmin_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg61A: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cg61B; else goto cg61C;
       cg61B: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$cmin_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg61C: // global
           I64[Sp - 40] = block_cg61j_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug62f; else goto cg61k;
       ug62f: // global
           call _cg61j(R1) args: 0, res: 0, upd: 0;
       cg61k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg61j() //  [R1]
         { info_tbl: [(cg61j,
                       label: block_cg61j_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg61j: // global
           I64[Sp - 16] = block_cg61o_info;
           _sg5tj::P64 = R1;
           _sg5tk::P64 = P64[R1 + 7];
           _sg5tl::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _sg5tl::P64;
           P64[Sp] = _sg5tk::P64;
           P64[Sp + 32] = _sg5tj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ug62e; else goto cg61p;
       ug62e: // global
           call _cg61o(R1) args: 0, res: 0, upd: 0;
       cg61p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg61o() //  [R1]
         { info_tbl: [(cg61o,
                       label: block_cg61o_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg61o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg61H; else goto cg61G;
       cg61H: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg61G: // global
           _sg5tn::P64 = P64[R1 + 7];
           _sg5to::P64 = P64[R1 + 15];
           I64[Hp - 16] = comp_sg5tp_info;
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_cg61E_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_ppp_info;
           _cg61t::P64 = Hp - 16;
           P64[Sp - 24] = _cg61t::P64;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = _sg5tn::P64;
           P64[Sp + 16] = _sg5to::P64;
           P64[Sp + 24] = R1;
           P64[Sp + 40] = _cg61t::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg61E() //  [R1]
         { info_tbl: [(cg61E,
                       label: block_cg61E_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg61E: // global
           _cg627::P64 = R1 & 7;
           if (_cg627::P64 < 3) goto ug629; else goto ug62a;
       ug629: // global
           if (_cg627::P64 < 2) goto ug62b; else goto cg61S;
       ug62b: // global
           Sp = Sp + 48;
           call _cg61Y() args: 0, res: 0, upd: 0;
       cg61S: // global
           _sg5to::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cg61Q_info;
           R2 = P64[Sp + 32];
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _sg5to::P64;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug62a: // global
           Sp = Sp + 24;
           call _cg626() args: 0, res: 0, upd: 0;
     }
 },
 _cg61Q() //  [R1]
         { info_tbl: [(cg61Q,
                       label: block_cg61Q_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg61Q: // global
           if (R1 & 7 == 3) goto ug62c; else goto ug62d;
       ug62c: // global
           Sp = Sp + 8;
           call _cg626() args: 0, res: 0, upd: 0;
       ug62d: // global
           Sp = Sp + 32;
           call _cg61Y() args: 0, res: 0, upd: 0;
     }
 },
 _cg61Y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg61Y: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg626() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg626: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.026698885 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_closure" {
     Data.Functor.Product.$fOrdProduct_closure:
         const Data.Functor.Product.$fOrdProduct_info;
 },
 sat_sg5tC_entry() //  [R1, R2, R3]
         { info_tbl: [(cg62t,
                       label: sat_sg5tC_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg62t: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$cmin_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tB_entry() //  [R1, R2, R3]
         { info_tbl: [(cg62B,
                       label: sat_sg5tB_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg62B: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$cmax_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tA_entry() //  [R1, R2, R3]
         { info_tbl: [(cg62J,
                       label: sat_sg5tA_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg62J: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c>=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tz_entry() //  [R1, R2, R3]
         { info_tbl: [(cg62R,
                       label: sat_sg5tz_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg62R: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c>_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5ty_entry() //  [R1, R2, R3]
         { info_tbl: [(cg62Z,
                       label: sat_sg5ty_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg62Z: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c<=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tx_entry() //  [R1, R2, R3]
         { info_tbl: [(cg637,
                       label: sat_sg5tx_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg637: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c<_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tw_entry() //  [R1, R2, R3]
         { info_tbl: [(cg63f,
                       label: sat_sg5tw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg63f: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$ccompare_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tv_entry() //  [R1]
         { info_tbl: [(cg63m,
                       label: sat_sg5tv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg63m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg63n; else goto cg63o;
       cg63n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg63o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fOrdProduct_$cp1Ord_entry(R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cg63q,
                       label: Data.Functor.Product.$fOrdProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg63q: // global
           Hp = Hp + 336;
           if (Hp > HpLim) (likely: False) goto cg63u; else goto cg63t;
       cg63u: // global
           HpAlloc = 336;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg63t: // global
           I64[Hp - 328] = sat_sg5tC_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           I64[Hp - 296] = sat_sg5tB_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           P64[Hp - 272] = R4;
           I64[Hp - 264] = sat_sg5tA_info;
           P64[Hp - 256] = R2;
           P64[Hp - 248] = R3;
           P64[Hp - 240] = R4;
           I64[Hp - 232] = sat_sg5tz_info;
           P64[Hp - 224] = R2;
           P64[Hp - 216] = R3;
           P64[Hp - 208] = R4;
           I64[Hp - 200] = sat_sg5ty_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           P64[Hp - 176] = R4;
           I64[Hp - 168] = sat_sg5tx_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = sat_sg5tw_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sat_sg5tv_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 104;
           P64[Hp - 48] = Hp - 134;
           P64[Hp - 40] = Hp - 166;
           P64[Hp - 32] = Hp - 198;
           P64[Hp - 24] = Hp - 230;
           P64[Hp - 16] = Hp - 262;
           P64[Hp - 8] = Hp - 294;
           P64[Hp] = Hp - 326;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.030151788 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadPrec_closure" {
     Data.Functor.Product.$fReadProduct_$creadPrec_closure:
         const Data.Functor.Product.$fReadProduct_$creadPrec_info;
         const 0;
 },
 sat_sg5tH_entry() //  [R1]
         { info_tbl: [(cg63D,
                       label: sat_sg5tH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg63D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg63E; else goto cg63F;
       cg63E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg63F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tG_entry() //  [R1]
         { info_tbl: [(cg63K,
                       label: sat_sg5tG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg63K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg63L; else goto cg63M;
       cg63L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg63M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cg63N,
                       label: Data.Functor.Product.$fReadProduct_$creadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg63N: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg63R; else goto cg63Q;
       cg63R: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg63Q: // global
           I64[Hp - 40] = sat_sg5tH_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sg5tG_info;
           P64[Hp] = R4;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.032513222 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadsPrec_closure" {
     Data.Functor.Product.$fReadProduct_$creadsPrec_closure:
         const Data.Functor.Product.$fReadProduct_$creadsPrec_info;
         const 0;
 },
 sat_sg5tN_entry() //  [R1]
         { info_tbl: [(cg644,
                       label: sat_sg5tN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg644: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg645; else goto cg646;
       cg645: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg646: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tM_entry() //  [R1]
         { info_tbl: [(cg64b,
                       label: sat_sg5tM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg64b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg64c; else goto cg64d;
       cg64c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg64d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sg5tL_entry() //  [R1]
         { info_tbl: [(cg64e,
                       label: ds_sg5tL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg64e: // global
           _sg5tL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg64f; else goto cg64g;
       cg64g: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg64i; else goto cg64h;
       cg64i: // global
           HpAlloc = 48;
           goto cg64f;
       cg64f: // global
           R1 = _sg5tL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg64h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5tL::P64;
           _sg5tI::P64 = P64[_sg5tL::P64 + 16];
           _sg5tJ::P64 = P64[_sg5tL::P64 + 24];
           _sg5tK::P64 = P64[_sg5tL::P64 + 32];
           I64[Hp - 40] = sat_sg5tN_info;
           P64[Hp - 24] = _sg5tK::P64;
           I64[Hp - 16] = sat_sg5tM_info;
           P64[Hp] = _sg5tK::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sg5tJ::P64;
           R2 = _sg5tI::P64;
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tP_entry() //  [R1]
         { info_tbl: [(cg64s,
                       label: sat_sg5tP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg64s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg64t; else goto cg64u;
       cg64t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg64u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tQ_entry() //  [R1, R2]
         { info_tbl: [(cg64v,
                       label: sat_sg5tQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg64v: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg64z; else goto cg64y;
       cg64z: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg64y: // global
           _sg5tL::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sg5tP_info;
           P64[Hp - 8] = _sg5tL::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cg64A,
                       label: Data.Functor.Product.$fReadProduct_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg64A: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg64E; else goto cg64D;
       cg64E: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg64D: // global
           I64[Hp - 48] = ds_sg5tL_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sg5tQ_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.035578608 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadListPrec_closure" {
     Data.Functor.Product.$fReadProduct_$creadListPrec_closure:
         const Data.Functor.Product.$fReadProduct_$creadListPrec_info;
         const 0;
 },
 sat_sg5tV_entry() //  [R1]
         { info_tbl: [(cg64R,
                       label: sat_sg5tV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg64R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg64S; else goto cg64T;
       cg64S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg64T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tU_entry() //  [R1]
         { info_tbl: [(cg64Y,
                       label: sat_sg5tU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg64Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg64Z; else goto cg650;
       cg64Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg650: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tW_entry() //  [R1]
         { info_tbl: [(cg651,
                       label: sat_sg5tW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg651: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg655; else goto cg654;
       cg655: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg654: // global
           _sg5tR::P64 = P64[R1 + 16];
           _sg5tS::P64 = P64[R1 + 24];
           _sg5tT::P64 = P64[R1 + 32];
           I64[Hp - 40] = sat_sg5tV_info;
           P64[Hp - 24] = _sg5tT::P64;
           I64[Hp - 16] = sat_sg5tU_info;
           P64[Hp] = _sg5tT::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sg5tS::P64;
           R2 = _sg5tR::P64;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadListPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cg656,
                       label: Data.Functor.Product.$fReadProduct_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg656: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg65a; else goto cg659;
       cg65a: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg659: // global
           I64[Hp - 32] = sat_sg5tW_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.037726424 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadList_closure" {
     Data.Functor.Product.$fReadProduct_$creadList_closure:
         const Data.Functor.Product.$fReadProduct_$creadList_info;
         const 0;
 },
 sat_sg5u0_entry() //  [R1]
         { info_tbl: [(cg65j,
                       label: sat_sg5u0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg65j: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg65k; else goto cg65l;
       cg65k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg65l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call Data.Functor.Product.$fReadProduct_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadList_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cg65m,
                       label: Data.Functor.Product.$fReadProduct_$creadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg65m: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg65q; else goto cg65p;
       cg65q: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg65p: // global
           I64[Hp - 32] = sat_sg5u0_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.040992201 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_closure" {
     Data.Functor.Product.$fReadProduct_closure:
         const Data.Functor.Product.$fReadProduct_info;
         const 0;
 },
 sat_sg5u7_entry() //  [R1]
         { info_tbl: [(cg65z,
                       label: sat_sg5u7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg65z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg65A; else goto cg65B;
       cg65A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg65B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5u6_entry() //  [R1]
         { info_tbl: [(cg65G,
                       label: sat_sg5u6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg65G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg65H; else goto cg65I;
       cg65H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg65I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5u5_entry() //  [R1]
         { info_tbl: [(cg65N,
                       label: sat_sg5u5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg65N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg65O; else goto cg65P;
       cg65O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg65P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadList_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5u4_entry() //  [R1]
         { info_tbl: [(cg65U,
                       label: sat_sg5u4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg65U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg65V; else goto cg65W;
       cg65V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg65W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadsPrec_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fReadProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cg65Y,
                       label: Data.Functor.Product.$fReadProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg65Y: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cg662; else goto cg661;
       cg662: // global
           HpAlloc = 200;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg661: // global
           I64[Hp - 192] = sat_sg5u7_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           I64[Hp - 152] = sat_sg5u6_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_sg5u5_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sg5u4_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.043884321 UTC

[section ""data" . Data.Functor.Product.$w$cshowsPrec_closure" {
     Data.Functor.Product.$w$cshowsPrec_closure:
         const Data.Functor.Product.$w$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg664: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cshowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 16, res: 0, upd: 8;
     }
 },
 sp_sg5ue_entry() //  [R1]
         { info_tbl: [(cg66c,
                       label: sp_sg5ue_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg66c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg66d; else goto cg66e;
       cg66d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg66e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sl_sg5uf_entry() //  [R1]
         { info_tbl: [(cg66j,
                       label: sl_sg5uf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg66j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg66k; else goto cg66l;
       cg66k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg66l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5uh_entry() //  [R1]
         { info_tbl: [(cg66q,
                       label: sat_sg5uh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg66q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg66r; else goto cg66s;
       cg66r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg66s: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5ug_entry() //  [R1]
         { info_tbl: [(cg66x,
                       label: sat_sg5ug_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg66x: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg66y; else goto cg66z;
       cg66y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg66z: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cshowsPrec_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg66A,
                       label: Data.Functor.Product.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg66A: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg66E; else goto cg66D;
       cg66E: // global
           HpAlloc = 128;
           R1 = Data.Functor.Product.$w$cshowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cg66D: // global
           I64[Hp - 120] = sp_sg5ue_info;
           P64[Hp - 104] = R4;
           I64[Hp - 96] = sl_sg5uf_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sg5uh_info;
           P64[Hp - 56] = R3;
           _cg668::P64 = Hp - 120;
           P64[Hp - 48] = _cg668::P64;
           _cg66f::P64 = Hp - 96;
           P64[Hp - 40] = _cg66f::P64;
           I64[Hp - 32] = sat_sg5ug_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cg668::P64;
           P64[Hp] = _cg66f::P64;
           R6 = R6;
           R5 = R5;
           R4 = Data.Functor.Product.$fRead1Product2_closure;
           R3 = Hp - 72;
           R2 = Hp - 32;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.046589827 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_$cshowsPrec_closure" {
     Data.Functor.Product.$fShowProduct_$cshowsPrec_closure:
         const Data.Functor.Product.$fShowProduct_$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$fShowProduct_$cshowsPrec_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cg66M,
                       label: Data.Functor.Product.$fShowProduct_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg66M: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg66Q; else goto cg66R;
       cg66Q: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_$cshowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg66R: // global
           I64[Sp - 40] = block_cg66J_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug66Z; else goto cg66K;
       ug66Z: // global
           call _cg66J(R1) args: 0, res: 0, upd: 0;
       cg66K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg66J() //  [R1]
         { info_tbl: [(cg66J,
                       label: block_cg66J_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg66J: // global
           I64[Sp] = block_cg66P_info;
           _sg5uo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sg5uo::I64;
           if (R1 & 7 != 0) goto ug66Y; else goto cg66T;
       ug66Y: // global
           call _cg66P(R1) args: 0, res: 0, upd: 0;
       cg66T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg66P() //  [R1]
         { info_tbl: [(cg66P,
                       label: block_cg66P_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg66P: // global
           R6 = P64[R1 + 7];
           R5 = I64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cshowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.048852809 UTC

[section ""data" . Data.Functor.Product.$w$cshow_closure" {
     Data.Functor.Product.$w$cshow_closure:
         const Data.Functor.Product.$w$cshow_info;
         const 0;
 },
 sp_sg5ux_entry() //  [R1]
         { info_tbl: [(cg678,
                       label: sp_sg5ux_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg678: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg679; else goto cg67a;
       cg679: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg67a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sl_sg5uy_entry() //  [R1]
         { info_tbl: [(cg67f,
                       label: sl_sg5uy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg67f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg67g; else goto cg67h;
       cg67g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg67h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5uz_entry() //  [R1]
         { info_tbl: [(cg67q,
                       label: sat_sg5uz_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg67q: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cg67r; else goto cg67s;
       cg67r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg67s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = P64[R1 + 32];
           P64[Sp - 48] = P64[R1 + 40];
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 sat_sg5uB_entry() //  [R1]
         { info_tbl: [(cg67u,
                       label: sat_sg5uB_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg67u: // global
           _sg5uB::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cg67v; else goto cg67w;
       cg67w: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg67y; else goto cg67x;
       cg67y: // global
           HpAlloc = 72;
           goto cg67v;
       cg67v: // global
           R1 = _sg5uB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg67x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5uB::P64;
           _sg5us::P64 = P64[_sg5uB::P64 + 16];
           _sg5ut::P64 = P64[_sg5uB::P64 + 24];
           _sg5uv::P64 = P64[_sg5uB::P64 + 32];
           _sg5uw::P64 = P64[_sg5uB::P64 + 40];
           _sg5ux::P64 = P64[_sg5uB::P64 + 48];
           _sg5uy::P64 = P64[_sg5uB::P64 + 56];
           I64[Hp - 64] = sat_sg5uz_info;
           P64[Hp - 48] = _sg5ut::P64;
           P64[Hp - 40] = _sg5uw::P64;
           P64[Hp - 32] = _sg5ux::P64;
           P64[Hp - 24] = _sg5uy::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 64;
           R2 = _sg5us::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = _sg5ux::P64;
           P64[Sp - 48] = _sg5uy::P64;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sg5uv::P64;
           P64[Sp - 24] = Hp - 14;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cshow_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg67A,
                       label: Data.Functor.Product.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg67A: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cg67E; else goto cg67D;
       cg67E: // global
           HpAlloc = 136;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$cshow_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg67D: // global
           I64[Hp - 128] = sp_sg5ux_info;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sl_sg5uy_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_sg5uB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = R6;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 80;
           R3 = Hp - 14;
           R2 = Data.Functor.Product.$fRead1Product2_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.051497514 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_$cshow_closure" {
     Data.Functor.Product.$fShowProduct_$cshow_closure:
         const Data.Functor.Product.$fShowProduct_$cshow_info;
         const 0;
 },
 Data.Functor.Product.$fShowProduct_$cshow_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cg67M,
                       label: Data.Functor.Product.$fShowProduct_$cshow_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg67M: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg67N; else goto cg67O;
       cg67N: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_$cshow_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg67O: // global
           I64[Sp - 32] = block_cg67J_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug67S; else goto cg67K;
       ug67S: // global
           call _cg67J(R1) args: 0, res: 0, upd: 0;
       cg67K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg67J() //  [R1]
         { info_tbl: [(cg67J,
                       label: block_cg67J_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg67J: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cshow_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.053538749 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_$cshowList_closure" {
     Data.Functor.Product.$fShowProduct_$cshowList_closure:
         const Data.Functor.Product.$fShowProduct_$cshowList_info;
         const 0;
 },
 lvl9_sg5uP_entry() //  [R1]
         { info_tbl: [(cg681,
                       label: lvl9_sg5uP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg681: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg682; else goto cg683;
       cg682: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg683: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl10_sg5uQ_entry() //  [R1]
         { info_tbl: [(cg688,
                       label: lvl10_sg5uQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg688: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg689; else goto cg68a;
       cg689: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg68a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5uV_entry() //  [R1, R2]
         { info_tbl: [(cg68j,
                       label: sat_sg5uV_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg68j: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg68k; else goto cg68l;
       cg68k: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg68l: // global
           I64[Sp - 40] = block_cg68g_info;
           _sg5uK::P64 = P64[R1 + 7];
           _sg5uL::P64 = P64[R1 + 15];
           _sg5uP::P64 = P64[R1 + 23];
           _sg5uQ::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5uK::P64;
           P64[Sp - 24] = _sg5uL::P64;
           P64[Sp - 16] = _sg5uP::P64;
           P64[Sp - 8] = _sg5uQ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug68p; else goto cg68h;
       ug68p: // global
           call _cg68g(R1) args: 0, res: 0, upd: 0;
       cg68h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg68g() //  [R1]
         { info_tbl: [(cg68g,
                       label: block_cg68g_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg68g: // global
           R6 = 0;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShowProduct_$cshowList_entry() //  [R2, R3,
                                                            R4, R5, R6]
         { info_tbl: [(cg68q,
                       label: Data.Functor.Product.$fShowProduct_$cshowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg68q: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg68u; else goto cg68t;
       cg68u: // global
           HpAlloc = 88;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_$cshowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg68t: // global
           I64[Hp - 80] = lvl9_sg5uP_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl10_sg5uQ_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5uV_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 31;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.056175876 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_closure" {
     Data.Functor.Product.$fShowProduct_closure:
         const Data.Functor.Product.$fShowProduct_info;
         const 0;
 },
 sat_sg5v1_entry() //  [R1, R2, R3]
         { info_tbl: [(cg68E,
                       label: sat_sg5v1_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg68E: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fShowProduct_$cshowList_entry(R6,
                                                                    R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5v0_entry() //  [R1, R2]
         { info_tbl: [(cg68M,
                       label: sat_sg5v0_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg68M: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fShowProduct_$cshow_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5uZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cg68U,
                       label: sat_sg5uZ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg68U: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fShowProduct_$cshowsPrec_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShowProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cg68Y,
                       label: Data.Functor.Product.$fShowProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg68Y: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg692; else goto cg691;
       cg692: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg691: // global
           I64[Hp - 120] = sat_sg5v1_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sg5v0_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sg5uZ_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 118;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.058433675 UTC

[section ""data" . Data.Functor.Product.$fFunctorProduct_$cfmap_closure" {
     Data.Functor.Product.$fFunctorProduct_$cfmap_closure:
         const Data.Functor.Product.$fFunctorProduct_$cfmap_info;
 },
 sat_sg5va_entry() //  [R1]
         { info_tbl: [(cg69g,
                       label: sat_sg5va_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg69g: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg69h; else goto cg69i;
       cg69h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg69i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5v9_entry() //  [R1]
         { info_tbl: [(cg69n,
                       label: sat_sg5v9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg69n: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg69o; else goto cg69p;
       cg69o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg69p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFunctorProduct_$cfmap_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cg69q,
                       label: Data.Functor.Product.$fFunctorProduct_$cfmap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg69q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg69s; else goto cg69t;
       cg69s: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFunctorProduct_$cfmap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg69t: // global
           I64[Sp - 32] = block_cg697_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug69x; else goto cg698;
       ug69x: // global
           call _cg697(R1) args: 0, res: 0, upd: 0;
       cg698: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg697() //  [R1]
         { info_tbl: [(cg697,
                       label: block_cg697_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg697: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg69w; else goto cg69v;
       cg69w: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg69v: // global
           _sg5v7::P64 = P64[R1 + 7];
           _sg5v8::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5va_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sg5v4::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sg5v4::P64;
           P64[Hp - 64] = _sg5v8::P64;
           I64[Hp - 56] = sat_sg5v9_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg5v4::P64;
           P64[Hp - 24] = _sg5v7::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.060995641 UTC

[section ""data" . Data.Functor.Product.$fFunctorProduct_$c<$_closure" {
     Data.Functor.Product.$fFunctorProduct_$c<$_closure:
         const Data.Functor.Product.$fFunctorProduct_$c<$_info;
 },
 f1_sg5vi_entry() //  [R1]
         { info_tbl: [(cg69M,
                       label: f1_sg5vi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg69M: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5vl_entry() //  [R1]
         { info_tbl: [(cg69T,
                       label: sat_sg5vl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg69T: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg69U; else goto cg69V;
       cg69U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg69V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5vk_entry() //  [R1]
         { info_tbl: [(cg6a0,
                       label: sat_sg5vk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6a0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6a1; else goto cg6a2;
       cg6a1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6a2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFunctorProduct_$c<$_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cg6a3,
                       label: Data.Functor.Product.$fFunctorProduct_$c<$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6a3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6a5; else goto cg6a6;
       cg6a5: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFunctorProduct_$c<$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6a6: // global
           I64[Sp - 32] = block_cg69C_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6aa; else goto cg69D;
       ug6aa: // global
           call _cg69C(R1) args: 0, res: 0, upd: 0;
       cg69D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg69C() //  [R1]
         { info_tbl: [(cg69C,
                       label: block_cg69C_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg69C: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cg6a9; else goto cg6a8;
       cg6a9: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6a8: // global
           _sg5vg::P64 = P64[R1 + 7];
           _sg5vh::P64 = P64[R1 + 15];
           I64[Hp - 112] = f1_sg5vi_info;
           P64[Hp - 104] = P64[Sp + 24];
           I64[Hp - 96] = sat_sg5vl_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sg5vh::P64;
           _cg69H::P64 = Hp - 111;
           P64[Hp - 64] = _cg69H::P64;
           I64[Hp - 56] = sat_sg5vk_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg5vg::P64;
           P64[Hp - 24] = _cg69H::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.063483253 UTC

[section ""data" . Data.Functor.Product.$fFunctorProduct_closure" {
     Data.Functor.Product.$fFunctorProduct_closure:
         const Data.Functor.Product.$fFunctorProduct_info;
 },
 sat_sg5vp_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6ak,
                       label: sat_sg5vp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ak: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFunctorProduct_$c<$_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5vo_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6as,
                       label: sat_sg5vo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6as: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFunctorProduct_$cfmap_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFunctorProduct_entry() //  [R2, R3]
         { info_tbl: [(cg6aw,
                       label: Data.Functor.Product.$fFunctorProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6aw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg6aA; else goto cg6az;
       cg6aA: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFunctorProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6az: // global
           I64[Hp - 64] = sat_sg5vp_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5vo_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.065466156 UTC

[section ""data" . Data.Functor.Product.$w$cfoldMap_closure" {
     Data.Functor.Product.$w$cfoldMap_closure:
         const Data.Functor.Product.$w$cfoldMap_info;
 },
 sat_sg5vx_entry() //  [R1]
         { info_tbl: [(cg6aJ,
                       label: sat_sg5vx_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6aJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6aK; else goto cg6aL;
       cg6aK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6aL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5vw_entry() //  [R1]
         { info_tbl: [(cg6aQ,
                       label: sat_sg5vw_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6aQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6aR; else goto cg6aS;
       cg6aR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6aS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldMap_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg6aT,
                       label: Data.Functor.Product.$w$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6aT: // global
           _sg5vu::P64 = R6;
           _sg5vt::P64 = R5;
           _sg5vs::P64 = R4;
           _sg5vr::P64 = R3;
           _sg5vq::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6aU; else goto cg6aV;
       cg6aV: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cg6aX; else goto cg6aW;
       cg6aX: // global
           HpAlloc = 96;
           goto cg6aU;
       cg6aU: // global
           R6 = _sg5vu::P64;
           R5 = _sg5vt::P64;
           R4 = _sg5vs::P64;
           R3 = _sg5vr::P64;
           R2 = _sg5vq::P64;
           R1 = Data.Functor.Product.$w$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg6aW: // global
           I64[Hp - 88] = sat_sg5vx_info;
           P64[Hp - 72] = _sg5vr::P64;
           P64[Hp - 64] = _sg5vs::P64;
           P64[Hp - 56] = _sg5vt::P64;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = sat_sg5vw_info;
           P64[Hp - 24] = _sg5vq::P64;
           P64[Hp - 16] = _sg5vs::P64;
           P64[Hp - 8] = _sg5vt::P64;
           P64[Hp] = _sg5vu::P64;
           R2 = _sg5vs::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = Hp - 40;
           P64[Sp] = Hp - 88;
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.067543877 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldMap_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldMap_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldMap_info;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldMap_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cg6b5,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6b5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6b6; else goto cg6b7;
       cg6b6: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6b7: // global
           I64[Sp - 40] = block_cg6b2_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6bb; else goto cg6b3;
       ug6bb: // global
           call _cg6b2(R1) args: 0, res: 0, upd: 0;
       cg6b3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6b2() //  [R1]
         { info_tbl: [(cg6b2,
                       label: block_cg6b2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6b2: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldMap_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.069080716 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfold_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfold_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfold_info;
 },
 Data.Functor.Product.$fFoldableProduct_$cfold_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cg6bj,
                       label: Data.Functor.Product.$fFoldableProduct_$cfold_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6bj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6bk; else goto cg6bl;
       cg6bk: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfold_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6bl: // global
           I64[Sp - 32] = block_cg6bg_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6bp; else goto cg6bh;
       ug6bp: // global
           call _cg6bg(R1) args: 0, res: 0, upd: 0;
       cg6bh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6bg() //  [R1]
         { info_tbl: [(cg6bg,
                       label: block_cg6bg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6bg: // global
           R6 = P64[R1 + 7];
           R5 = GHC.Base.id_closure+1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$cfoldMap_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.070467834 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct1_closure" {
     Data.Functor.Product.$fFoldableProduct1_closure:
         const Data.Functor.Product.$fFoldableProduct1_info;
 },
 Data.Functor.Product.$fFoldableProduct1_entry() //  [R2]
         { info_tbl: [(cg6bu,
                       label: Data.Functor.Product.$fFoldableProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6bu: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.072200265 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$csum_closure" {
     Data.Functor.Product.$fFoldableProduct_$csum_closure:
         const Data.Functor.Product.$fFoldableProduct_$csum_info;
         const 0;
 },
 $dMonoid_sg5vR_entry() //  [R1]
         { info_tbl: [(cg6bF,
                       label: $dMonoid_sg5vR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6bF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6bG; else goto cg6bH;
       cg6bG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6bH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5vX_entry() //  [R1]
         { info_tbl: [(cg6bW,
                       label: sat_sg5vX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6bW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6bX; else goto cg6bY;
       cg6bX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6bY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5vW_entry() //  [R1]
         { info_tbl: [(cg6c3,
                       label: sat_sg5vW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6c3: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6c4; else goto cg6c5;
       cg6c4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6c5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5vY_entry() //  [R1, R2]
         { info_tbl: [(cg6c6,
                       label: sat_sg5vY_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6c6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6c7; else goto cg6c8;
       cg6c7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6c8: // global
           I64[Sp - 40] = block_cg6bN_info;
           _sg5vO::P64 = P64[R1 + 7];
           _sg5vP::P64 = P64[R1 + 15];
           _sg5vQ::P64 = P64[R1 + 23];
           _sg5vR::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5vO::P64;
           P64[Sp - 24] = _sg5vP::P64;
           P64[Sp - 16] = _sg5vQ::P64;
           P64[Sp - 8] = _sg5vR::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6cc; else goto cg6bO;
       ug6cc: // global
           call _cg6bN(R1) args: 0, res: 0, upd: 0;
       cg6bO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6bN() //  [R1]
         { info_tbl: [(cg6bN,
                       label: block_cg6bN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6bN: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg6cb; else goto cg6ca;
       cg6cb: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6ca: // global
           _sg5vU::P64 = P64[R1 + 7];
           _sg5vV::P64 = P64[R1 + 15];
           I64[Hp - 72] = sat_sg5vX_info;
           P64[Hp - 56] = P64[Sp + 16];
           _sg5vR::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sg5vR::P64;
           P64[Hp - 40] = _sg5vV::P64;
           I64[Hp - 32] = sat_sg5vW_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sg5vR::P64;
           P64[Hp] = _sg5vU::P64;
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$csum_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cg6cd,
                       label: Data.Functor.Product.$fFoldableProduct_$csum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6cd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg6ch; else goto cg6cg;
       cg6ch: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$csum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6cg: // global
           I64[Hp - 56] = $dMonoid_sg5vR_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5vY_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.076138875 UTC

[section ""cstring" . lvl_rg5nW_bytes" {
     lvl_rg5nW_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.076952331 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct2_closure" {
     Data.Functor.Product.$fFoldableProduct2_closure:
         const Data.Functor.Product.$fFoldableProduct2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct2_entry() //  [R1]
         { info_tbl: [(cg6cq,
                       label: Data.Functor.Product.$fFoldableProduct2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6cq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg6cr; else goto cg6cs;
       cg6cr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6cs: // global
           (_cg6cl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg6cl::I64 == 0) goto cg6cn; else goto cg6cm;
       cg6cn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg6cm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg6cl::I64;
           I64[Sp - 24] = block_cg6co_info;
           R2 = lvl_rg5nW_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg6co() //  [R1]
         { info_tbl: [(cg6co,
                       label: block_cg6co_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6co: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.07913903 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cminimum_closure" {
     Data.Functor.Product.$fFoldableProduct_$cminimum_closure:
         const Data.Functor.Product.$fFoldableProduct_$cminimum_info;
         const 0;
 },
 $dMonoid_sg5w3_entry() //  [R1]
         { info_tbl: [(cg6cE,
                       label: $dMonoid_sg5w3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6cE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6cF; else goto cg6cG;
       cg6cF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6cG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5wf_entry() //  [R1, R2]
         { info_tbl: [(cg6cP,
                       label: sat_sg5wf_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6cP: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cg6cQ; else goto cg6cR;
       cg6cQ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6cR: // global
           I64[Sp - 40] = block_cg6cM_info;
           _sg5w0::P64 = P64[R1 + 7];
           _sg5w1::P64 = P64[R1 + 15];
           _sg5w2::P64 = P64[R1 + 23];
           _sg5w3::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5w0::P64;
           P64[Sp - 24] = _sg5w1::P64;
           P64[Sp - 16] = _sg5w2::P64;
           P64[Sp - 8] = _sg5w3::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6dJ; else goto cg6cN;
       ug6dJ: // global
           call _cg6cM(R1) args: 0, res: 0, upd: 0;
       cg6cN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6cM() //  [R1]
         { info_tbl: [(cg6cM,
                       label: block_cg6cM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6cM: // global
           I64[Sp] = block_cg6cU_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = GHC.Base.Just_closure+1;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg6cU() //  [R1]
         { info_tbl: [(cg6cU,
                       label: block_cg6cU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6cU: // global
           _sg5w0::P64 = P64[Sp + 8];
           _sg5w3::P64 = P64[Sp + 32];
           _sg5w6::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg6d2; else goto cg6dh;
       cg6d2: // global
           I64[Sp + 32] = block_cg6cZ_info;
           R2 = _sg5w0::P64;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sg5w3::P64;
           P64[Sp + 16] = GHC.Base.Just_closure+1;
           P64[Sp + 24] = _sg5w6::P64;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cg6dh: // global
           I64[Sp + 16] = block_cg6df_info;
           R2 = _sg5w0::P64;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = _sg5w3::P64;
           P64[Sp] = GHC.Base.Just_closure+1;
           P64[Sp + 8] = _sg5w6::P64;
           P64[Sp + 32] = P64[R1 + 6];
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg6cZ() //  [R1]
         { info_tbl: [(cg6cZ,
                       label: block_cg6cZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6cZ: // global
           if (R1 & 7 == 1) goto cg6d8; else goto cg6dc;
       cg6d8: // global
           R1 = Data.Functor.Product.$fFoldableProduct2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg6dc: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg6df() //  [R1]
         { info_tbl: [(cg6df,
                       label: block_cg6df_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6df: // global
           if (R1 & 7 == 1) goto ug6dH; else goto cg6ds;
       ug6dH: // global
           Sp = Sp + 16;
           call _cg6dy() args: 0, res: 0, upd: 0;
       cg6ds: // global
           I64[Sp] = block_cg6dq_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           _sg5wd::P64 = P64[R1 + 6];
           P64[Sp - 16] = _sg5wd::P64;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = _sg5wd::P64;
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cg6dq() //  [R1]
         { info_tbl: [(cg6dq,
                       label: block_cg6dq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6dq: // global
           if (R1 & 7 == 1) goto ug6dI; else goto cg6dC;
       ug6dI: // global
           Sp = Sp + 16;
           call _cg6dy() args: 0, res: 0, upd: 0;
       cg6dC: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg6dy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6dy: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cminimum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg6dM,
                       label: Data.Functor.Product.$fFoldableProduct_$cminimum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6dM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg6dQ; else goto cg6dP;
       cg6dQ: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cminimum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6dP: // global
           I64[Hp - 56] = $dMonoid_sg5w3_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5wf_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.082193255 UTC

[section ""cstring" . lvl1_rg5nX_bytes" {
     lvl1_rg5nX_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.083015164 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct3_closure" {
     Data.Functor.Product.$fFoldableProduct3_closure:
         const Data.Functor.Product.$fFoldableProduct3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct3_entry() //  [R1]
         { info_tbl: [(cg6dZ,
                       label: Data.Functor.Product.$fFoldableProduct3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6dZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg6e0; else goto cg6e1;
       cg6e0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6e1: // global
           (_cg6dU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg6dU::I64 == 0) goto cg6dW; else goto cg6dV;
       cg6dW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg6dV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg6dU::I64;
           I64[Sp - 24] = block_cg6dX_info;
           R2 = lvl1_rg5nX_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg6dX() //  [R1]
         { info_tbl: [(cg6dX,
                       label: block_cg6dX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6dX: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.085162142 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cmaximum_closure" {
     Data.Functor.Product.$fFoldableProduct_$cmaximum_closure:
         const Data.Functor.Product.$fFoldableProduct_$cmaximum_info;
         const 0;
 },
 $dMonoid_sg5wk_entry() //  [R1]
         { info_tbl: [(cg6ed,
                       label: $dMonoid_sg5wk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ed: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6ee; else goto cg6ef;
       cg6ee: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6ef: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5ww_entry() //  [R1, R2]
         { info_tbl: [(cg6eo,
                       label: sat_sg5ww_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6eo: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cg6ep; else goto cg6eq;
       cg6ep: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6eq: // global
           I64[Sp - 40] = block_cg6el_info;
           _sg5wh::P64 = P64[R1 + 7];
           _sg5wi::P64 = P64[R1 + 15];
           _sg5wj::P64 = P64[R1 + 23];
           _sg5wk::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5wh::P64;
           P64[Sp - 24] = _sg5wi::P64;
           P64[Sp - 16] = _sg5wj::P64;
           P64[Sp - 8] = _sg5wk::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6fi; else goto cg6em;
       ug6fi: // global
           call _cg6el(R1) args: 0, res: 0, upd: 0;
       cg6em: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6el() //  [R1]
         { info_tbl: [(cg6el,
                       label: block_cg6el_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6el: // global
           I64[Sp] = block_cg6et_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = GHC.Base.Just_closure+1;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg6et() //  [R1]
         { info_tbl: [(cg6et,
                       label: block_cg6et_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6et: // global
           _sg5wh::P64 = P64[Sp + 8];
           _sg5wk::P64 = P64[Sp + 32];
           _sg5wn::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg6eB; else goto cg6eQ;
       cg6eB: // global
           I64[Sp + 32] = block_cg6ey_info;
           R2 = _sg5wh::P64;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sg5wk::P64;
           P64[Sp + 16] = GHC.Base.Just_closure+1;
           P64[Sp + 24] = _sg5wn::P64;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cg6eQ: // global
           I64[Sp + 16] = block_cg6eO_info;
           R2 = _sg5wh::P64;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = _sg5wk::P64;
           P64[Sp] = GHC.Base.Just_closure+1;
           P64[Sp + 8] = _sg5wn::P64;
           P64[Sp + 32] = P64[R1 + 6];
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg6ey() //  [R1]
         { info_tbl: [(cg6ey,
                       label: block_cg6ey_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ey: // global
           if (R1 & 7 == 1) goto cg6eH; else goto cg6eL;
       cg6eH: // global
           R1 = Data.Functor.Product.$fFoldableProduct3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg6eL: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg6eO() //  [R1]
         { info_tbl: [(cg6eO,
                       label: block_cg6eO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6eO: // global
           if (R1 & 7 == 1) goto ug6fg; else goto cg6f1;
       ug6fg: // global
           Sp = Sp + 16;
           call _cg6f7() args: 0, res: 0, upd: 0;
       cg6f1: // global
           I64[Sp] = block_cg6eZ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           _sg5wu::P64 = P64[R1 + 6];
           P64[Sp - 16] = _sg5wu::P64;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = _sg5wu::P64;
           Sp = Sp - 24;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cg6eZ() //  [R1]
         { info_tbl: [(cg6eZ,
                       label: block_cg6eZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6eZ: // global
           if (R1 & 7 == 1) goto ug6fh; else goto cg6fb;
       ug6fh: // global
           Sp = Sp + 16;
           call _cg6f7() args: 0, res: 0, upd: 0;
       cg6fb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg6f7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6f7: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cmaximum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg6fl,
                       label: Data.Functor.Product.$fFoldableProduct_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6fl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg6fp; else goto cg6fo;
       cg6fp: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cmaximum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6fo: // global
           I64[Hp - 56] = $dMonoid_sg5wk_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5ww_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.088760696 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$celem_closure" {
     Data.Functor.Product.$fFoldableProduct_$celem_closure:
         const Data.Functor.Product.$fFoldableProduct_$celem_info;
         const 0;
 },
 f1_sg5wB_entry() //  [R1]
         { info_tbl: [(cg6fy,
                       label: f1_sg5wB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6fy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6fz; else goto cg6fA;
       cg6fz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6fA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5wH_entry() //  [R1, R2]
         { info_tbl: [(cg6fJ,
                       label: sat_sg5wH_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6fJ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cg6fK; else goto cg6fL;
       cg6fK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6fL: // global
           I64[Sp - 32] = block_cg6fG_info;
           _sg5wx::P64 = P64[R1 + 7];
           _sg5wy::P64 = P64[R1 + 15];
           _sg5wB::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sg5wx::P64;
           P64[Sp - 16] = _sg5wy::P64;
           P64[Sp - 8] = _sg5wB::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6g1; else goto cg6fH;
       ug6g1: // global
           call _cg6fG(R1) args: 0, res: 0, upd: 0;
       cg6fH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6fG() //  [R1]
         { info_tbl: [(cg6fG,
                       label: block_cg6fG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6fG: // global
           I64[Sp] = block_cg6fO_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 8] = P64[R1 + 15];
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg6fO() //  [R1]
         { info_tbl: [(cg6fO,
                       label: block_cg6fO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6fO: // global
           if (R1 & 7 == 1) goto cg6fV; else goto cg6fZ;
       cg6fV: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           _sg5wF::P64 = P64[Sp + 8];
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = _sg5wF::P64;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg6fZ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$celem_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cg6g2,
                       label: Data.Functor.Product.$fFoldableProduct_$celem_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6g2: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg6g6; else goto cg6g5;
       cg6g6: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$celem_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6g5: // global
           I64[Hp - 56] = f1_sg5wB_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = sat_sg5wH_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.090997537 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct8_closure" {
     Data.Functor.Product.$fFoldableProduct8_closure:
         const Data.Functor.Product.$fFoldableProduct8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct8_entry() //  [R1]
         { info_tbl: [(cg6gd,
                       label: Data.Functor.Product.$fFoldableProduct8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6gd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6ge; else goto cg6gf;
       cg6ge: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6gf: // global
           (_cg6ga::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg6ga::I64 == 0) goto cg6gc; else goto cg6gb;
       cg6gc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg6gb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg6ga::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.092467325 UTC

[section ""data" . Data.Functor.Product.$w$cfoldl_closure" {
     Data.Functor.Product.$w$cfoldl_closure:
         const Data.Functor.Product.$w$cfoldl_info;
         const 0;
 },
 f1_sg5wO_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6gp,
                       label: f1_sg5wO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6gp: // global
           _sg5wQ::P64 = R3;
           R3 = R2;
           R2 = _sg5wQ::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5wR_entry() //  [R1]
         { info_tbl: [(cg6gw,
                       label: sat_sg5wR_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6gw: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg6gx; else goto cg6gy;
       cg6gx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6gy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg6gz,
                       label: Data.Functor.Product.$w$cfoldl_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6gz: // global
           _sg5wM::P64 = R6;
           _sg5wL::P64 = R5;
           _sg5wK::P64 = R4;
           _sg5wJ::P64 = R3;
           _sg5wI::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cg6gA; else goto cg6gB;
       cg6gB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg6gD; else goto cg6gC;
       cg6gD: // global
           HpAlloc = 64;
           goto cg6gA;
       cg6gA: // global
           R6 = _sg5wM::P64;
           R5 = _sg5wL::P64;
           R4 = _sg5wK::P64;
           R3 = _sg5wJ::P64;
           R2 = _sg5wI::P64;
           R1 = Data.Functor.Product.$w$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg6gC: // global
           I64[Hp - 56] = f1_sg5wO_info;
           P64[Hp - 48] = _sg5wK::P64;
           I64[Hp - 40] = sat_sg5wR_info;
           P64[Hp - 24] = _sg5wI::P64;
           P64[Hp - 16] = _sg5wL::P64;
           P64[Hp - 8] = _sg5wM::P64;
           _cg6gk::P64 = Hp - 54;
           P64[Hp] = _cg6gk::P64;
           R2 = _sg5wJ::P64;
           I64[Sp - 32] = stg_ap_pppp_info;
           P64[Sp - 24] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 16] = _cg6gk::P64;
           P64[Sp - 8] = P64[Sp];
           P64[Sp] = Hp - 40;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.094424728 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldl_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldl_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldl_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldl_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cg6gL,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6gL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6gM; else goto cg6gN;
       cg6gM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6gN: // global
           I64[Sp - 40] = block_cg6gI_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6gR; else goto cg6gJ;
       ug6gR: // global
           call _cg6gI(R1) args: 0, res: 0, upd: 0;
       cg6gJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6gI() //  [R1]
         { info_tbl: [(cg6gI,
                       label: block_cg6gI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6gI: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldl_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.0956135 UTC

[section ""cstring" . lvl2_rg5nY_bytes" {
     lvl2_rg5nY_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.0963798 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct7_closure" {
     Data.Functor.Product.$fFoldableProduct7_closure:
         const Data.Functor.Product.$fFoldableProduct7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct7_entry() //  [R1]
         { info_tbl: [(cg6h0,
                       label: Data.Functor.Product.$fFoldableProduct7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6h0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg6h1; else goto cg6h2;
       cg6h1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6h2: // global
           (_cg6gV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg6gV::I64 == 0) goto cg6gX; else goto cg6gW;
       cg6gX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg6gW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg6gV::I64;
           I64[Sp - 24] = block_cg6gY_info;
           R2 = lvl2_rg5nY_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg6gY() //  [R1]
         { info_tbl: [(cg6gY,
                       label: block_cg6gY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6gY: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.098562745 UTC

[section ""data" . Data.Functor.Product.$w$cfoldl1_closure" {
     Data.Functor.Product.$w$cfoldl1_closure:
         const Data.Functor.Product.$w$cfoldl1_info;
         const 0;
 },
 sat_sg5xb_entry() //  [R1]
         { info_tbl: [(cg6hq,
                       label: sat_sg5xb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6hq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6hr; else goto cg6hs;
       cg6hr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6hs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg6hj_info;
           _sg5x3::P64 = P64[R1 + 16];
           _sg5x7::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sg5x3::P64;
           P64[Sp - 24] = _sg5x7::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6hz; else goto cg6hk;
       ug6hz: // global
           call _cg6hj(R1) args: 0, res: 0, upd: 0;
       cg6hk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg6hj() //  [R1]
         { info_tbl: [(cg6hj,
                       label: block_cg6hj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6hj: // global
           _sg5x7::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg6hn; else goto cg6ho;
       cg6hn: // global
           R1 = _sg5x7::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cg6ho: // global
           R3 = _sg5x7::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 f1_sg5x6_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6hB,
                       label: f1_sg5x6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6hB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg6hF; else goto cg6hE;
       cg6hF: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6hE: // global
           _sg5x3::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sg5xb_info;
           P64[Hp - 32] = _sg5x3::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5xc_entry() //  [R1]
         { info_tbl: [(cg6hK,
                       label: sat_sg5xc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6hK: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg6hL; else goto cg6hM;
       cg6hL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6hM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldl1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg6hT,
                       label: Data.Functor.Product.$w$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6hT: // global
           _sg5x5::P64 = R6;
           _sg5x4::P64 = R5;
           _sg5x3::P64 = R4;
           _sg5x2::P64 = R3;
           _sg5x1::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cg6hU; else goto cg6hV;
       cg6hV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg6hX; else goto cg6hW;
       cg6hX: // global
           HpAlloc = 56;
           goto cg6hU;
       cg6hU: // global
           R6 = _sg5x5::P64;
           R5 = _sg5x4::P64;
           R4 = _sg5x3::P64;
           R3 = _sg5x2::P64;
           R2 = _sg5x1::P64;
           R1 = Data.Functor.Product.$w$cfoldl1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6hW: // global
           I64[Hp - 48] = f1_sg5x6_info;
           P64[Hp - 40] = _sg5x3::P64;
           I64[Hp - 32] = sat_sg5xc_info;
           P64[Hp - 16] = _sg5x1::P64;
           P64[Hp - 8] = _sg5x4::P64;
           _cg6ha::P64 = Hp - 46;
           P64[Hp] = _cg6ha::P64;
           I64[Sp - 8] = block_cg6hN_info;
           R2 = _sg5x2::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 32] = _cg6ha::P64;
           P64[Sp - 24] = _sg5x5::P64;
           P64[Sp - 16] = Hp - 32;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cg6hN() //  [R1]
         { info_tbl: [(cg6hN,
                       label: block_cg6hN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6hN: // global
           if (R1 & 7 == 1) goto cg6hQ; else goto cg6hR;
       cg6hQ: // global
           R1 = Data.Functor.Product.$fFoldableProduct7_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg6hR: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.101424269 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldl1_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldl1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg6ib,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ib: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6ic; else goto cg6id;
       cg6ic: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6id: // global
           I64[Sp - 32] = block_cg6i8_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6ih; else goto cg6i9;
       ug6ih: // global
           call _cg6i8(R1) args: 0, res: 0, upd: 0;
       cg6i9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6i8() //  [R1]
         { info_tbl: [(cg6i8,
                       label: block_cg6i8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6i8: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldl1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.103216649 UTC

[section ""data" . Data.Functor.Product.$w$cfoldr'_closure" {
     Data.Functor.Product.$w$cfoldr'_closure:
         const Data.Functor.Product.$w$cfoldr'_info;
         const 0;
 },
 f1_sg5xs_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6it,
                       label: f1_sg5xs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6it: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6iu; else goto cg6iv;
       cg6iu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6iv: // global
           I64[Sp - 16] = block_cg6ir_info;
           _sg5xu::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sg5xu::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6ir() //  [R1]
         { info_tbl: [(cg6ir,
                       label: block_cg6ir_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ir: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5xx_entry() //  [R1]
         { info_tbl: [(cg6iB,
                       label: sat_sg5xx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6iB: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg6iC; else goto cg6iD;
       cg6iC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6iD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldr'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg6iE,
                       label: Data.Functor.Product.$w$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6iE: // global
           _sg5xq::P64 = R6;
           _sg5xp::P64 = R5;
           _sg5xo::P64 = R4;
           _sg5xn::P64 = R3;
           _sg5xm::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6iF; else goto cg6iG;
       cg6iG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg6iI; else goto cg6iH;
       cg6iI: // global
           HpAlloc = 56;
           goto cg6iF;
       cg6iF: // global
           R6 = _sg5xq::P64;
           R5 = _sg5xp::P64;
           R4 = _sg5xo::P64;
           R3 = _sg5xn::P64;
           R2 = _sg5xm::P64;
           R1 = Data.Functor.Product.$w$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg6iH: // global
           I64[Hp - 48] = f1_sg5xs_info;
           P64[Hp - 40] = _sg5xo::P64;
           I64[Hp - 32] = sat_sg5xx_info;
           P64[Hp - 16] = _sg5xm::P64;
           P64[Hp - 8] = _sg5xq::P64;
           _cg6im::P64 = Hp - 45;
           P64[Hp] = _cg6im::P64;
           R2 = _sg5xn::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 24] = _cg6im::P64;
           P64[Sp - 16] = P64[Sp];
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = _sg5xp::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.105452674 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldr'_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldr'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cg6iQ,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6iQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6iR; else goto cg6iS;
       cg6iR: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6iS: // global
           I64[Sp - 40] = block_cg6iN_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6iW; else goto cg6iO;
       ug6iW: // global
           call _cg6iN(R1) args: 0, res: 0, upd: 0;
       cg6iO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6iN() //  [R1]
         { info_tbl: [(cg6iN,
                       label: block_cg6iN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6iN: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldr'_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.108331748 UTC

[section ""data" . Data.Functor.Product.$w$cfoldr_closure" {
     Data.Functor.Product.$w$cfoldr_closure:
         const Data.Functor.Product.$w$cfoldr_info;
         const 0;
 },
 sat_sg5xM_entry() //  [R1]
         { info_tbl: [(cg6j5,
                       label: sat_sg5xM_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6j5: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg6j6; else goto cg6j7;
       cg6j6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6j7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg6j8,
                       label: Data.Functor.Product.$w$cfoldr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6j8: // global
           _sg5xK::P64 = R6;
           _sg5xJ::P64 = R5;
           _sg5xI::P64 = R4;
           _sg5xH::P64 = R3;
           _sg5xG::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cg6j9; else goto cg6ja;
       cg6ja: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg6jc; else goto cg6jb;
       cg6jc: // global
           HpAlloc = 48;
           goto cg6j9;
       cg6j9: // global
           R6 = _sg5xK::P64;
           R5 = _sg5xJ::P64;
           R4 = _sg5xI::P64;
           R3 = _sg5xH::P64;
           R2 = _sg5xG::P64;
           R1 = Data.Functor.Product.$w$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg6jb: // global
           I64[Hp - 40] = sat_sg5xM_info;
           P64[Hp - 24] = _sg5xH::P64;
           P64[Hp - 16] = _sg5xI::P64;
           P64[Hp - 8] = _sg5xJ::P64;
           P64[Hp] = P64[Sp];
           R2 = _sg5xG::P64;
           I64[Sp - 32] = stg_ap_pppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 16] = _sg5xI::P64;
           P64[Sp - 8] = _sg5xK::P64;
           P64[Sp] = Hp - 40;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.109971714 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldr_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldr_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldr_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldr_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cg6jk,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6jk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6jl; else goto cg6jm;
       cg6jl: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6jm: // global
           I64[Sp - 40] = block_cg6jh_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6jq; else goto cg6ji;
       ug6jq: // global
           call _cg6jh(R1) args: 0, res: 0, upd: 0;
       cg6ji: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6jh() //  [R1]
         { info_tbl: [(cg6jh,
                       label: block_cg6jh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6jh: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldr_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.11173756 UTC

[section ""data" . Data.Functor.Product.$w$cfoldl'_closure" {
     Data.Functor.Product.$w$cfoldl'_closure:
         const Data.Functor.Product.$w$cfoldl'_info;
         const 0;
 },
 f1_sg5y1_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6jC,
                       label: f1_sg5y1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6jC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6jD; else goto cg6jE;
       cg6jD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6jE: // global
           I64[Sp - 16] = block_cg6jA_info;
           _sg5y3::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sg5y3::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6jA() //  [R1]
         { info_tbl: [(cg6jA,
                       label: block_cg6jA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6jA: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5y6_entry() //  [R1]
         { info_tbl: [(cg6jK,
                       label: sat_sg5y6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6jK: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg6jL; else goto cg6jM;
       cg6jL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6jM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldl'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg6jN,
                       label: Data.Functor.Product.$w$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6jN: // global
           _sg5xZ::P64 = R6;
           _sg5xY::P64 = R5;
           _sg5xX::P64 = R4;
           _sg5xW::P64 = R3;
           _sg5xV::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6jO; else goto cg6jP;
       cg6jP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg6jR; else goto cg6jQ;
       cg6jR: // global
           HpAlloc = 56;
           goto cg6jO;
       cg6jO: // global
           R6 = _sg5xZ::P64;
           R5 = _sg5xY::P64;
           R4 = _sg5xX::P64;
           R3 = _sg5xW::P64;
           R2 = _sg5xV::P64;
           R1 = Data.Functor.Product.$w$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg6jQ: // global
           I64[Hp - 48] = f1_sg5y1_info;
           P64[Hp - 40] = _sg5xX::P64;
           I64[Hp - 32] = sat_sg5y6_info;
           P64[Hp - 16] = _sg5xW::P64;
           P64[Hp - 8] = P64[Sp];
           _cg6jv::P64 = Hp - 45;
           P64[Hp] = _cg6jv::P64;
           R2 = _sg5xV::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = _cg6jv::P64;
           P64[Sp - 16] = _sg5xZ::P64;
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = _sg5xY::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.113881921 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldl'_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldl'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cg6jZ,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6jZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6k0; else goto cg6k1;
       cg6k0: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6k1: // global
           I64[Sp - 40] = block_cg6jW_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6k5; else goto cg6jX;
       ug6k5: // global
           call _cg6jW(R1) args: 0, res: 0, upd: 0;
       cg6jX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6jW() //  [R1]
         { info_tbl: [(cg6jW,
                       label: block_cg6jW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6jW: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldl'_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.115405108 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct5_closure" {
     Data.Functor.Product.$fFoldableProduct5_closure:
         const Data.Functor.Product.$fFoldableProduct5_info;
 },
 Data.Functor.Product.$fFoldableProduct5_entry() //  [R2, R3]
         { info_tbl: [(cg6kd,
                       label: Data.Functor.Product.$fFoldableProduct5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6kd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6kk; else goto cg6kl;
       cg6kk: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6kl: // global
           I64[Sp - 8] = block_cg6ka_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6kp; else goto cg6kb;
       ug6kp: // global
           call _cg6ka(R1) args: 0, res: 0, upd: 0;
       cg6kb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6ka() //  [R1]
         { info_tbl: [(cg6ka,
                       label: block_cg6ka_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ka: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg6ko; else goto cg6kn;
       cg6ko: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6kn: // global
           _sg5yj::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sg5yj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.116799815 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$clength_closure" {
     Data.Functor.Product.$fFoldableProduct_$clength_closure:
         const Data.Functor.Product.$fFoldableProduct_$clength_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$clength_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cg6kx,
                       label: Data.Functor.Product.$fFoldableProduct_$clength_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6kx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg6ky; else goto cg6kz;
       cg6ky: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$clength_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6kz: // global
           I64[Sp - 24] = block_cg6ku_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug6kD; else goto cg6kv;
       ug6kD: // global
           call _cg6ku(R1) args: 0, res: 0, upd: 0;
       cg6kv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6ku() //  [R1]
         { info_tbl: [(cg6ku,
                       label: block_cg6ku_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ku: // global
           R6 = P64[R1 + 7];
           R5 = Data.Functor.Product.$fFoldableProduct4_closure+1;
           R4 = Data.Functor.Product.$fFoldableProduct5_closure+2;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 16] = P64[R1 + 15];
           Sp = Sp + 16;
           call Data.Functor.Product.$w$cfoldl'_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.118010808 UTC

[section ""cstring" . lvl3_rg5nZ_bytes" {
     lvl3_rg5nZ_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.118789126 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct9_closure" {
     Data.Functor.Product.$fFoldableProduct9_closure:
         const Data.Functor.Product.$fFoldableProduct9_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct9_entry() //  [R1]
         { info_tbl: [(cg6kM,
                       label: Data.Functor.Product.$fFoldableProduct9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6kM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg6kN; else goto cg6kO;
       cg6kN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6kO: // global
           (_cg6kH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg6kH::I64 == 0) goto cg6kJ; else goto cg6kI;
       cg6kJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg6kI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg6kH::I64;
           I64[Sp - 24] = block_cg6kK_info;
           R2 = lvl3_rg5nZ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg6kK() //  [R1]
         { info_tbl: [(cg6kK,
                       label: block_cg6kK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6kK: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.120813658 UTC

[section ""data" . Data.Functor.Product.$w$cfoldr1_closure" {
     Data.Functor.Product.$w$cfoldr1_closure:
         const Data.Functor.Product.$w$cfoldr1_info;
         const 0;
 },
 sat_sg5yB_entry() //  [R1]
         { info_tbl: [(cg6lc,
                       label: sat_sg5yB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6lc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6ld; else goto cg6le;
       cg6ld: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6le: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg6l5_info;
           _sg5yt::P64 = P64[R1 + 16];
           _sg5yx::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sg5yt::P64;
           P64[Sp - 24] = _sg5yx::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6ll; else goto cg6l6;
       ug6ll: // global
           call _cg6l5(R1) args: 0, res: 0, upd: 0;
       cg6l6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg6l5() //  [R1]
         { info_tbl: [(cg6l5,
                       label: block_cg6l5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6l5: // global
           _sg5yx::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg6l9; else goto cg6la;
       cg6l9: // global
           R1 = _sg5yx::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cg6la: // global
           R3 = P64[R1 + 6];
           R2 = _sg5yx::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 w3_sg5yw_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6ln,
                       label: w3_sg5yw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ln: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg6lr; else goto cg6lq;
       cg6lr: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6lq: // global
           _sg5yt::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sg5yB_info;
           P64[Hp - 32] = _sg5yt::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5yC_entry() //  [R1]
         { info_tbl: [(cg6lw,
                       label: sat_sg5yC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6lw: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg6lx; else goto cg6ly;
       cg6lx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6ly: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldr1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg6lF,
                       label: Data.Functor.Product.$w$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6lF: // global
           _sg5yv::P64 = R6;
           _sg5yu::P64 = R5;
           _sg5yt::P64 = R4;
           _sg5ys::P64 = R3;
           _sg5yr::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cg6lG; else goto cg6lH;
       cg6lH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg6lJ; else goto cg6lI;
       cg6lJ: // global
           HpAlloc = 56;
           goto cg6lG;
       cg6lG: // global
           R6 = _sg5yv::P64;
           R5 = _sg5yu::P64;
           R4 = _sg5yt::P64;
           R3 = _sg5ys::P64;
           R2 = _sg5yr::P64;
           R1 = Data.Functor.Product.$w$cfoldr1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6lI: // global
           I64[Hp - 48] = w3_sg5yw_info;
           P64[Hp - 40] = _sg5yt::P64;
           I64[Hp - 32] = sat_sg5yC_info;
           P64[Hp - 16] = _sg5ys::P64;
           P64[Hp - 8] = _sg5yv::P64;
           _cg6kW::P64 = Hp - 46;
           P64[Hp] = _cg6kW::P64;
           I64[Sp - 8] = block_cg6lz_info;
           R2 = _sg5yr::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = _cg6kW::P64;
           P64[Sp - 24] = _sg5yu::P64;
           P64[Sp - 16] = Hp - 32;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cg6lz() //  [R1]
         { info_tbl: [(cg6lz,
                       label: block_cg6lz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6lz: // global
           if (R1 & 7 == 1) goto cg6lC; else goto cg6lD;
       cg6lC: // global
           R1 = Data.Functor.Product.$fFoldableProduct9_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg6lD: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.123813276 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldr1_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldr1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg6lX,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6lX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6lY; else goto cg6lZ;
       cg6lY: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6lZ: // global
           I64[Sp - 32] = block_cg6lU_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6m3; else goto cg6lV;
       ug6m3: // global
           call _cg6lU(R1) args: 0, res: 0, upd: 0;
       cg6lV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6lU() //  [R1]
         { info_tbl: [(cg6lU,
                       label: block_cg6lU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6lU: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldr1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.125042189 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct6_closure" {
     Data.Functor.Product.$fFoldableProduct6_closure:
         const Data.Functor.Product.$fFoldableProduct6_info;
 },
 Data.Functor.Product.$fFoldableProduct6_entry() //  []
         { info_tbl: [(cg6m8,
                       label: Data.Functor.Product.$fFoldableProduct6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6m8: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.12624644 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cnull_closure" {
     Data.Functor.Product.$fFoldableProduct_$cnull_closure:
         const Data.Functor.Product.$fFoldableProduct_$cnull_info;
         const 0;
 },
 sat_sg5yU_entry() //  [R1]
         { info_tbl: [(cg6mo,
                       label: sat_sg5yU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6mo: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg6mp; else goto cg6mq;
       cg6mp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6mq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = Data.Functor.Product.$fFoldableProduct6_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.True_closure+2;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cnull_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cg6mr,
                       label: Data.Functor.Product.$fFoldableProduct_$cnull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6mr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6ms; else goto cg6mt;
       cg6ms: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cnull_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6mt: // global
           I64[Sp - 24] = block_cg6mf_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug6mx; else goto cg6mg;
       ug6mx: // global
           call _cg6mf(R1) args: 0, res: 0, upd: 0;
       cg6mg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6mf() //  [R1]
         { info_tbl: [(cg6mf,
                       label: block_cg6mf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6mf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg6mw; else goto cg6mv;
       cg6mw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6mv: // global
           _sg5yS::P64 = P64[R1 + 7];
           _sg5yT::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sg5yU_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sg5yT::P64;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp] = Data.Functor.Product.$fFoldableProduct6_closure+2;
           P64[Sp + 8] = _sg5yS::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.128733961 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cproduct_closure" {
     Data.Functor.Product.$fFoldableProduct_$cproduct_closure:
         const Data.Functor.Product.$fFoldableProduct_$cproduct_info;
         const 0;
 },
 $dMonoid_sg5yY_entry() //  [R1]
         { info_tbl: [(cg6mG,
                       label: $dMonoid_sg5yY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6mG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6mH; else goto cg6mI;
       cg6mH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6mI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5z4_entry() //  [R1]
         { info_tbl: [(cg6mX,
                       label: sat_sg5z4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6mX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6mY; else goto cg6mZ;
       cg6mY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6mZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5z3_entry() //  [R1]
         { info_tbl: [(cg6n4,
                       label: sat_sg5z3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6n4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6n5; else goto cg6n6;
       cg6n5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6n6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5z5_entry() //  [R1, R2]
         { info_tbl: [(cg6n7,
                       label: sat_sg5z5_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6n7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6n8; else goto cg6n9;
       cg6n8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6n9: // global
           I64[Sp - 40] = block_cg6mO_info;
           _sg5yV::P64 = P64[R1 + 7];
           _sg5yW::P64 = P64[R1 + 15];
           _sg5yX::P64 = P64[R1 + 23];
           _sg5yY::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5yV::P64;
           P64[Sp - 24] = _sg5yW::P64;
           P64[Sp - 16] = _sg5yX::P64;
           P64[Sp - 8] = _sg5yY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6nd; else goto cg6mP;
       ug6nd: // global
           call _cg6mO(R1) args: 0, res: 0, upd: 0;
       cg6mP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6mO() //  [R1]
         { info_tbl: [(cg6mO,
                       label: block_cg6mO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6mO: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg6nc; else goto cg6nb;
       cg6nc: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6nb: // global
           _sg5z1::P64 = P64[R1 + 7];
           _sg5z2::P64 = P64[R1 + 15];
           I64[Hp - 72] = sat_sg5z4_info;
           P64[Hp - 56] = P64[Sp + 16];
           _sg5yY::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sg5yY::P64;
           P64[Hp - 40] = _sg5z2::P64;
           I64[Hp - 32] = sat_sg5z3_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sg5yY::P64;
           P64[Hp] = _sg5z1::P64;
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cproduct_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg6ne,
                       label: Data.Functor.Product.$fFoldableProduct_$cproduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ne: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg6ni; else goto cg6nh;
       cg6ni: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cproduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6nh: // global
           I64[Hp - 56] = $dMonoid_sg5yY_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5z5_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.131923822 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$ctoList_closure" {
     Data.Functor.Product.$fFoldableProduct_$ctoList_closure:
         const Data.Functor.Product.$fFoldableProduct_$ctoList_info;
         const 0;
 },
 sat_sg5zc_entry() //  [R1]
         { info_tbl: [(cg6nw,
                       label: sat_sg5zc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6nw: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg6nx; else goto cg6ny;
       cg6nx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6ny: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = GHC.Types.:_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$ctoList_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cg6nz,
                       label: Data.Functor.Product.$fFoldableProduct_$ctoList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6nz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6nA; else goto cg6nB;
       cg6nA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$ctoList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6nB: // global
           I64[Sp - 24] = block_cg6nn_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug6nF; else goto cg6no;
       ug6nF: // global
           call _cg6nn(R1) args: 0, res: 0, upd: 0;
       cg6no: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6nn() //  [R1]
         { info_tbl: [(cg6nn,
                       label: block_cg6nn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6nn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg6nE; else goto cg6nD;
       cg6nE: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6nD: // global
           _sg5za::P64 = P64[R1 + 7];
           _sg5zb::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sg5zc_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sg5zb::P64;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp] = GHC.Types.:_closure+2;
           P64[Sp + 8] = _sg5za::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.135841685 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_closure" {
     Data.Functor.Product.$fFoldableProduct_closure:
         const Data.Functor.Product.$fFoldableProduct_info;
         const 0;
 },
 sat_sg5zu_entry() //  [R1, R2]
         { info_tbl: [(cg6nP,
                       label: sat_sg5zu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6nP: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cproduct_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zt_entry() //  [R1, R2]
         { info_tbl: [(cg6nX,
                       label: sat_sg5zt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6nX: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$csum_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zs_entry() //  [R1, R2]
         { info_tbl: [(cg6o5,
                       label: sat_sg5zs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6o5: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cminimum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zr_entry() //  [R1, R2]
         { info_tbl: [(cg6od,
                       label: sat_sg5zr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6od: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cmaximum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zq_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6ol,
                       label: sat_sg5zq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ol: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$celem_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zp_entry() //  [R1, R2]
         { info_tbl: [(cg6ot,
                       label: sat_sg5zp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ot: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$clength_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zo_entry() //  [R1, R2]
         { info_tbl: [(cg6oB,
                       label: sat_sg5zo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6oB: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cnull_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zn_entry() //  [R1, R2]
         { info_tbl: [(cg6oJ,
                       label: sat_sg5zn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6oJ: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$ctoList_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zm_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6oR,
                       label: sat_sg5zm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6oR: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$cfoldl1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zl_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6oZ,
                       label: sat_sg5zl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6oZ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$cfoldr1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6p7,
                       label: sat_sg5zk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6p7: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldl'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zj_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6pf,
                       label: sat_sg5zj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6pf: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldl_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zi_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6pn,
                       label: sat_sg5zi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6pn: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldr'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zh_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6pv,
                       label: sat_sg5zh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6pv: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldr_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6pD,
                       label: sat_sg5zg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6pD: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldMap_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zf_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6pL,
                       label: sat_sg5zf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6pL: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$cfold_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_entry() //  [R2, R3]
         { info_tbl: [(cg6pP,
                       label: Data.Functor.Product.$fFoldableProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6pP: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cg6pT; else goto cg6pS;
       cg6pT: // global
           HpAlloc = 520;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6pS: // global
           I64[Hp - 512] = sat_sg5zu_info;
           P64[Hp - 504] = R2;
           P64[Hp - 496] = R3;
           I64[Hp - 488] = sat_sg5zt_info;
           P64[Hp - 480] = R2;
           P64[Hp - 472] = R3;
           I64[Hp - 464] = sat_sg5zs_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           I64[Hp - 440] = sat_sg5zr_info;
           P64[Hp - 432] = R2;
           P64[Hp - 424] = R3;
           I64[Hp - 416] = sat_sg5zq_info;
           P64[Hp - 408] = R2;
           P64[Hp - 400] = R3;
           I64[Hp - 392] = sat_sg5zp_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           I64[Hp - 368] = sat_sg5zo_info;
           P64[Hp - 360] = R2;
           P64[Hp - 352] = R3;
           I64[Hp - 344] = sat_sg5zn_info;
           P64[Hp - 336] = R2;
           P64[Hp - 328] = R3;
           I64[Hp - 320] = sat_sg5zm_info;
           P64[Hp - 312] = R2;
           P64[Hp - 304] = R3;
           I64[Hp - 296] = sat_sg5zl_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           I64[Hp - 272] = sat_sg5zk_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_sg5zj_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_sg5zi_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_sg5zh_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sg5zg_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sg5zf_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = Data.Foldable.C:Foldable_con_info;
           P64[Hp - 120] = Hp - 150;
           P64[Hp - 112] = Hp - 173;
           P64[Hp - 104] = Hp - 197;
           P64[Hp - 96] = Hp - 221;
           P64[Hp - 88] = Hp - 245;
           P64[Hp - 80] = Hp - 269;
           P64[Hp - 72] = Hp - 294;
           P64[Hp - 64] = Hp - 318;
           P64[Hp - 56] = Hp - 343;
           P64[Hp - 48] = Hp - 367;
           P64[Hp - 40] = Hp - 391;
           P64[Hp - 32] = Hp - 414;
           P64[Hp - 24] = Hp - 439;
           P64[Hp - 16] = Hp - 463;
           P64[Hp - 8] = Hp - 487;
           P64[Hp] = Hp - 511;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.142275812 UTC

[section ""data" . Data.Functor.Product.$w$ctraverse_closure" {
     Data.Functor.Product.$w$ctraverse_closure:
         const Data.Functor.Product.$w$ctraverse_info;
 },
 sat_sg5zC_entry() //  [R1]
         { info_tbl: [(cg6q2,
                       label: sat_sg5zC_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6q2: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6q3; else goto cg6q4;
       cg6q3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6q4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5zB_entry() //  [R1]
         { info_tbl: [(cg6q9,
                       label: sat_sg5zB_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6q9: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6qa; else goto cg6qb;
       cg6qa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6qb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$ctraverse_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg6qc,
                       label: Data.Functor.Product.$w$ctraverse_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6qc: // global
           _sg5zz::P64 = R6;
           _sg5zy::P64 = R5;
           _sg5zx::P64 = R4;
           _sg5zw::P64 = R3;
           _sg5zv::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cg6qd; else goto cg6qe;
       cg6qe: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cg6qg; else goto cg6qf;
       cg6qg: // global
           HpAlloc = 96;
           goto cg6qd;
       cg6qd: // global
           R6 = _sg5zz::P64;
           R5 = _sg5zy::P64;
           R4 = _sg5zx::P64;
           R3 = _sg5zw::P64;
           R2 = _sg5zv::P64;
           R1 = Data.Functor.Product.$w$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg6qf: // global
           I64[Hp - 88] = sat_sg5zC_info;
           P64[Hp - 72] = _sg5zw::P64;
           P64[Hp - 64] = _sg5zx::P64;
           P64[Hp - 56] = _sg5zy::P64;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = sat_sg5zB_info;
           P64[Hp - 24] = _sg5zv::P64;
           P64[Hp - 16] = _sg5zx::P64;
           P64[Hp - 8] = _sg5zy::P64;
           P64[Hp] = _sg5zz::P64;
           R2 = _sg5zx::P64;
           I64[Sp - 24] = stg_ap_ppp_info;
           P64[Sp - 16] = Data.Functor.Product.Pair_closure+2;
           P64[Sp - 8] = Hp - 40;
           P64[Sp] = Hp - 88;
           Sp = Sp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.14418896 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$ctraverse_closure" {
     Data.Functor.Product.$fTraversableProduct_$ctraverse_closure:
         const Data.Functor.Product.$fTraversableProduct_$ctraverse_info;
 },
 Data.Functor.Product.$fTraversableProduct_$ctraverse_entry() //  [R2,
                                                                   R3, R4, R5, R6]
         { info_tbl: [(cg6qo,
                       label: Data.Functor.Product.$fTraversableProduct_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6qo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6qp; else goto cg6qq;
       cg6qp: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6qq: // global
           I64[Sp - 40] = block_cg6ql_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6qu; else goto cg6qm;
       ug6qu: // global
           call _cg6ql(R1) args: 0, res: 0, upd: 0;
       cg6qm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6ql() //  [R1]
         { info_tbl: [(cg6ql,
                       label: block_cg6ql_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ql: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.14587549 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure" {
     Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure:
         const Data.Functor.Product.$fTraversableProduct_$cp2Traversable_info;
         const 0;
 },
 sat_sg5zO_entry() //  [R1]
         { info_tbl: [(cg6qD,
                       label: sat_sg5zO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6qD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6qE; else goto cg6qF;
       cg6qE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6qF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5zN_entry() //  [R1]
         { info_tbl: [(cg6qK,
                       label: sat_sg5zN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6qK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6qL; else goto cg6qM;
       cg6qL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6qM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fTraversableProduct_$cp2Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cg6qN,
                       label: Data.Functor.Product.$fTraversableProduct_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6qN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg6qR; else goto cg6qQ;
       cg6qR: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6qQ: // global
           I64[Hp - 40] = sat_sg5zO_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5zN_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fFoldableProduct_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.147598257 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$cp1Traversable_closure" {
     Data.Functor.Product.$fTraversableProduct_$cp1Traversable_closure:
         const Data.Functor.Product.$fTraversableProduct_$cp1Traversable_info;
 },
 sat_sg5zS_entry() //  [R1]
         { info_tbl: [(cg6r0,
                       label: sat_sg5zS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6r0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6r1; else goto cg6r2;
       cg6r1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6r2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5zR_entry() //  [R1]
         { info_tbl: [(cg6r7,
                       label: sat_sg5zR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6r7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6r8; else goto cg6r9;
       cg6r8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6r9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fTraversableProduct_$cp1Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cg6ra,
                       label: Data.Functor.Product.$fTraversableProduct_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ra: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg6re; else goto cg6rd;
       cg6re: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6rd: // global
           I64[Hp - 40] = sat_sg5zS_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5zR_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fFunctorProduct_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.149177032 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$csequenceA_closure" {
     Data.Functor.Product.$fTraversableProduct_$csequenceA_closure:
         const Data.Functor.Product.$fTraversableProduct_$csequenceA_info;
 },
 Data.Functor.Product.$fTraversableProduct_$csequenceA_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cg6rm,
                       label: Data.Functor.Product.$fTraversableProduct_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6rm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6rn; else goto cg6ro;
       cg6rn: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$csequenceA_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6ro: // global
           I64[Sp - 32] = block_cg6rj_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6rs; else goto cg6rk;
       ug6rs: // global
           call _cg6rj(R1) args: 0, res: 0, upd: 0;
       cg6rk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6rj() //  [R1]
         { info_tbl: [(cg6rj,
                       label: block_cg6rj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6rj: // global
           R6 = P64[R1 + 7];
           R5 = GHC.Base.id_closure+1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.150712095 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$cmapM_closure" {
     Data.Functor.Product.$fTraversableProduct_$cmapM_closure:
         const Data.Functor.Product.$fTraversableProduct_$cmapM_info;
 },
 Data.Functor.Product.$fTraversableProduct_$cmapM_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cg6rA,
                       label: Data.Functor.Product.$fTraversableProduct_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6rA: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6rE; else goto cg6rF;
       cg6rE: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6rF: // global
           I64[Sp - 40] = block_cg6rx_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6rL; else goto cg6ry;
       ug6rL: // global
           call _cg6rx(R1) args: 0, res: 0, upd: 0;
       cg6ry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6rx() //  [R1]
         { info_tbl: [(cg6rx,
                       label: block_cg6rx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6rx: // global
           I64[Sp - 8] = block_cg6rD_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg6rD() //  [R1]
         { info_tbl: [(cg6rD,
                       label: block_cg6rD_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6rD: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 40];
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.15233196 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$csequence_closure" {
     Data.Functor.Product.$fTraversableProduct_$csequence_closure:
         const Data.Functor.Product.$fTraversableProduct_$csequence_info;
 },
 Data.Functor.Product.$fTraversableProduct_$csequence_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cg6rT,
                       label: Data.Functor.Product.$fTraversableProduct_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6rT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6rX; else goto cg6rY;
       cg6rX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6rY: // global
           I64[Sp - 32] = block_cg6rQ_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6s4; else goto cg6rR;
       ug6s4: // global
           call _cg6rQ(R1) args: 0, res: 0, upd: 0;
       cg6rR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6rQ() //  [R1]
         { info_tbl: [(cg6rQ,
                       label: block_cg6rQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6rQ: // global
           I64[Sp - 8] = block_cg6rW_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg6rW() //  [R1]
         { info_tbl: [(cg6rW,
                       label: block_cg6rW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6rW: // global
           R6 = P64[Sp + 32];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.154676434 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_closure" {
     Data.Functor.Product.$fTraversableProduct_closure:
         const Data.Functor.Product.$fTraversableProduct_info;
         const 0;
 },
 sat_sg5Ao_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6se,
                       label: sat_sg5Ao_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6se: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fTraversableProduct_$csequence_entry(R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5An_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6sm,
                       label: sat_sg5An_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6sm: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fTraversableProduct_$cmapM_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Am_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6su,
                       label: sat_sg5Am_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6su: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fTraversableProduct_$csequenceA_entry(R5,
                                                                            R4,
                                                                            R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Al_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6sC,
                       label: sat_sg5Al_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6sC: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fTraversableProduct_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Ak_entry() //  [R1]
         { info_tbl: [(cg6sJ,
                       label: sat_sg5Ak_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6sJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6sK; else goto cg6sL;
       cg6sK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6sL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fTraversableProduct_$cp2Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Aj_entry() //  [R1]
         { info_tbl: [(cg6sQ,
                       label: sat_sg5Aj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6sQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6sR; else goto cg6sS;
       cg6sR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6sS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fTraversableProduct_$cp1Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fTraversableProduct_entry() //  [R2, R3]
         { info_tbl: [(cg6sU,
                       label: Data.Functor.Product.$fTraversableProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6sU: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cg6sY; else goto cg6sX;
       cg6sY: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6sX: // global
           I64[Hp - 208] = sat_sg5Ao_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sg5An_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sg5Am_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sg5Al_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sg5Ak_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sg5Aj_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.157789022 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$cliftA2_closure" {
     Data.Functor.Product.$fApplicativeProduct_$cliftA2_closure:
         const Data.Functor.Product.$fApplicativeProduct_$cliftA2_info;
 },
 sat_sg5AB_entry() //  [R1]
         { info_tbl: [(cg6th,
                       label: sat_sg5AB_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6th: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6ti; else goto cg6tj;
       cg6ti: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6tj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5AA_entry() //  [R1]
         { info_tbl: [(cg6to,
                       label: sat_sg5AA_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6to: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6tp; else goto cg6tq;
       cg6tp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6tq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$cliftA2_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cg6tr,
                       label: Data.Functor.Product.$fApplicativeProduct_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6tr: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6tt; else goto cg6tu;
       cg6tt: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$cliftA2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6tu: // global
           I64[Sp - 40] = block_cg6t3_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6tA; else goto cg6t4;
       ug6tA: // global
           call _cg6t3(R1) args: 0, res: 0, upd: 0;
       cg6t4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6t3() //  [R1]
         { info_tbl: [(cg6t3,
                       label: block_cg6t3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6t3: // global
           I64[Sp - 8] = block_cg6t8_info;
           _sg5Av::P64 = P64[R1 + 7];
           _sg5Aw::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5Aw::P64;
           P64[Sp + 32] = _sg5Av::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6tz; else goto cg6t9;
       ug6tz: // global
           call _cg6t8(R1) args: 0, res: 0, upd: 0;
       cg6t9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6t8() //  [R1]
         { info_tbl: [(cg6t8,
                       label: block_cg6t8_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6t8: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cg6ty; else goto cg6tx;
       cg6ty: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6tx: // global
           _sg5Ay::P64 = P64[R1 + 7];
           _sg5Az::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sg5AB_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sg5Ar::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sg5Ar::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sg5Az::P64;
           I64[Hp - 64] = sat_sg5AA_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sg5Ar::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sg5Ay::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.160715413 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$c<*>_closure" {
     Data.Functor.Product.$fApplicativeProduct_$c<*>_closure:
         const Data.Functor.Product.$fApplicativeProduct_$c<*>_info;
 },
 sat_sg5AN_entry() //  [R1]
         { info_tbl: [(cg6tT,
                       label: sat_sg5AN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6tT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6tU; else goto cg6tV;
       cg6tU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6tV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5AM_entry() //  [R1]
         { info_tbl: [(cg6u0,
                       label: sat_sg5AM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6u0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6u1; else goto cg6u2;
       cg6u1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6u2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$c<*>_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg6u3,
                       label: Data.Functor.Product.$fApplicativeProduct_$c<*>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6u3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6u5; else goto cg6u6;
       cg6u5: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$c<*>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6u6: // global
           I64[Sp - 32] = block_cg6tF_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6uc; else goto cg6tG;
       ug6uc: // global
           call _cg6tF(R1) args: 0, res: 0, upd: 0;
       cg6tG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6tF() //  [R1]
         { info_tbl: [(cg6tF,
                       label: block_cg6tF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6tF: // global
           I64[Sp - 8] = block_cg6tK_info;
           _sg5AH::P64 = P64[R1 + 7];
           _sg5AI::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5AI::P64;
           P64[Sp + 24] = _sg5AH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6ub; else goto cg6tL;
       ug6ub: // global
           call _cg6tK(R1) args: 0, res: 0, upd: 0;
       cg6tL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6tK() //  [R1]
         { info_tbl: [(cg6tK,
                       label: block_cg6tK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6tK: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg6ua; else goto cg6u9;
       cg6ua: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6u9: // global
           _sg5AK::P64 = P64[R1 + 7];
           _sg5AL::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5AN_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5AL::P64;
           I64[Hp - 56] = sat_sg5AM_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5AK::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.163294768 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$cpure_closure" {
     Data.Functor.Product.$fApplicativeProduct_$cpure_closure:
         const Data.Functor.Product.$fApplicativeProduct_$cpure_info;
 },
 sat_sg5AS_entry() //  [R1]
         { info_tbl: [(cg6ul,
                       label: sat_sg5AS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ul: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6um; else goto cg6un;
       cg6um: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6un: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5AR_entry() //  [R1]
         { info_tbl: [(cg6us,
                       label: sat_sg5AR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6us: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6ut; else goto cg6uu;
       cg6ut: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6uu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$cpure_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg6uw,
                       label: Data.Functor.Product.$fApplicativeProduct_$cpure_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6uw: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg6uA; else goto cg6uz;
       cg6uA: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$cpure_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6uz: // global
           I64[Hp - 80] = sat_sg5AS_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg5AR_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.165167189 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_closure" {
     Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_closure:
         const Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_info;
 },
 sat_sg5AW_entry() //  [R1]
         { info_tbl: [(cg6uJ,
                       label: sat_sg5AW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6uJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6uK; else goto cg6uL;
       cg6uK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6uL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5AV_entry() //  [R1]
         { info_tbl: [(cg6uQ,
                       label: sat_sg5AV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6uQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6uR; else goto cg6uS;
       cg6uR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6uS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cg6uT,
                       label: Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6uT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg6uX; else goto cg6uW;
       cg6uX: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6uW: // global
           I64[Hp - 40] = sat_sg5AW_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5AV_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fFunctorProduct_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.166958264 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct1_closure" {
     Data.Functor.Product.$fApplicativeProduct1_closure:
         const Data.Functor.Product.$fApplicativeProduct1_info;
 },
 Data.Functor.Product.$fApplicativeProduct1_entry() //  [R3]
         { info_tbl: [(cg6v2,
                       label: Data.Functor.Product.$fApplicativeProduct1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6v2: // global
           R2 = R3;
           call GHC.Base.breakpoint_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.168677961 UTC

[section ""data" . Data.Functor.Product.$w$c*>_closure" {
     Data.Functor.Product.$w$c*>_closure:
         const Data.Functor.Product.$w$c*>_info;
 },
 sat_sg5B8_entry() //  [R1]
         { info_tbl: [(cg6vj,
                       label: sat_sg5B8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6vj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6vk; else goto cg6vl;
       cg6vk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6vl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cg6vh_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg6vh() //  [R1]
         { info_tbl: [(cg6vh,
                       label: block_cg6vh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6vh: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Product.$fApplicativeProduct1_closure+2;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5B9_entry() //  [R1]
         { info_tbl: [(cg6vp,
                       label: sat_sg5B9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6vp: // global
           _sg5B9::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6vq; else goto cg6vr;
       cg6vr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg6vt; else goto cg6vs;
       cg6vt: // global
           HpAlloc = 32;
           goto cg6vq;
       cg6vq: // global
           R1 = _sg5B9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6vs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5B9::P64;
           _sg5AZ::P64 = P64[_sg5B9::P64 + 16];
           _sg5B1::P64 = P64[_sg5B9::P64 + 24];
           _sg5B3::P64 = P64[_sg5B9::P64 + 32];
           I64[Hp - 24] = sat_sg5B8_info;
           P64[Hp - 8] = _sg5AZ::P64;
           P64[Hp] = _sg5B1::P64;
           R2 = _sg5AZ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sg5B3::P64;
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5B5_entry() //  [R1]
         { info_tbl: [(cg6vE,
                       label: sat_sg5B5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6vE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6vF; else goto cg6vG;
       cg6vF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6vG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cg6vC_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg6vC() //  [R1]
         { info_tbl: [(cg6vC,
                       label: block_cg6vC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6vC: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Product.$fApplicativeProduct1_closure+2;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5B6_entry() //  [R1]
         { info_tbl: [(cg6vK,
                       label: sat_sg5B6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6vK: // global
           _sg5B6::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6vL; else goto cg6vM;
       cg6vM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg6vO; else goto cg6vN;
       cg6vO: // global
           HpAlloc = 32;
           goto cg6vL;
       cg6vL: // global
           R1 = _sg5B6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6vN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5B6::P64;
           _sg5AY::P64 = P64[_sg5B6::P64 + 16];
           _sg5B0::P64 = P64[_sg5B6::P64 + 24];
           _sg5B2::P64 = P64[_sg5B6::P64 + 32];
           I64[Hp - 24] = sat_sg5B5_info;
           P64[Hp - 8] = _sg5AY::P64;
           P64[Hp] = _sg5B0::P64;
           R2 = _sg5AY::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sg5B2::P64;
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c*>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg6vP,
                       label: Data.Functor.Product.$w$c*>_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6vP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg6vT; else goto cg6vS;
       cg6vT: // global
           HpAlloc = 80;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$c*>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg6vS: // global
           I64[Hp - 72] = sat_sg5B9_info;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = P64[Sp];
           I64[Hp - 32] = sat_sg5B6_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R6;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.171835808 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$c*>_closure" {
     Data.Functor.Product.$fApplicativeProduct_$c*>_closure:
         const Data.Functor.Product.$fApplicativeProduct_$c*>_info;
 },
 Data.Functor.Product.$fApplicativeProduct_$c*>_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cg6w1,
                       label: Data.Functor.Product.$fApplicativeProduct_$c*>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6w1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6wc; else goto cg6wd;
       cg6wc: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$c*>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6wd: // global
           I64[Sp - 32] = block_cg6vY_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6wk; else goto cg6vZ;
       ug6wk: // global
           call _cg6vY(R1) args: 0, res: 0, upd: 0;
       cg6vZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6vY() //  [R1]
         { info_tbl: [(cg6vY,
                       label: block_cg6vY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6vY: // global
           I64[Sp - 8] = block_cg6w4_info;
           _sg5Bf::P64 = P64[R1 + 7];
           _sg5Bg::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5Bg::P64;
           P64[Sp + 24] = _sg5Bf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6wj; else goto cg6w5;
       ug6wj: // global
           call _cg6w4(R1) args: 0, res: 0, upd: 0;
       cg6w5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6w4() //  [R1]
         { info_tbl: [(cg6w4,
                       label: block_cg6w4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6w4: // global
           _sg5Bf::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg6w9_info;
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 8];
           R4 = _sg5Bf::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$c*>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 8, upd: 8;
     }
 },
 _cg6w9() //  [R1, R2]
         { info_tbl: [(cg6w9,
                       label: block_cg6w9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6w9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6wi; else goto cg6wh;
       cg6wi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cg6wh: // global
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.175520129 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$c<*_closure" {
     Data.Functor.Product.$fApplicativeProduct_$c<*_closure:
         const Data.Functor.Product.$fApplicativeProduct_$c<*_info;
 },
 sat_sg5By_entry() //  [R1]
         { info_tbl: [(cg6wD,
                       label: sat_sg5By_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6wD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6wE; else goto cg6wF;
       cg6wE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6wF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Base.const_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5Bx_entry() //  [R1]
         { info_tbl: [(cg6wK,
                       label: sat_sg5Bx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6wK: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6wL; else goto cg6wM;
       cg6wL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6wM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Base.const_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$c<*_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cg6wN,
                       label: Data.Functor.Product.$fApplicativeProduct_$c<*_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6wN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6wP; else goto cg6wQ;
       cg6wP: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$c<*_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6wQ: // global
           I64[Sp - 32] = block_cg6wp_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6wW; else goto cg6wq;
       ug6wW: // global
           call _cg6wp(R1) args: 0, res: 0, upd: 0;
       cg6wq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6wp() //  [R1]
         { info_tbl: [(cg6wp,
                       label: block_cg6wp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6wp: // global
           I64[Sp - 8] = block_cg6wu_info;
           _sg5Bs::P64 = P64[R1 + 7];
           _sg5Bt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5Bt::P64;
           P64[Sp + 24] = _sg5Bs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6wV; else goto cg6wv;
       ug6wV: // global
           call _cg6wu(R1) args: 0, res: 0, upd: 0;
       cg6wv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6wu() //  [R1]
         { info_tbl: [(cg6wu,
                       label: block_cg6wu_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6wu: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg6wU; else goto cg6wT;
       cg6wU: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6wT: // global
           _sg5Bv::P64 = P64[R1 + 7];
           _sg5Bw::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5By_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5Bw::P64;
           I64[Hp - 56] = sat_sg5Bx_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5Bv::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.178534484 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_closure" {
     Data.Functor.Product.$fApplicativeProduct_closure:
         const Data.Functor.Product.$fApplicativeProduct_info;
 },
 sat_sg5BG_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6x6,
                       label: sat_sg5BG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6x6: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fApplicativeProduct_$c<*_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BF_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6xe,
                       label: sat_sg5BF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6xe: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fApplicativeProduct_$c*>_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BE_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6xm,
                       label: sat_sg5BE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6xm: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fApplicativeProduct_$cliftA2_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BD_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6xu,
                       label: sat_sg5BD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6xu: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fApplicativeProduct_$c<*>_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BC_entry() //  [R1, R2]
         { info_tbl: [(cg6xC,
                       label: sat_sg5BC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6xC: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fApplicativeProduct_$cpure_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BB_entry() //  [R1]
         { info_tbl: [(cg6xJ,
                       label: sat_sg5BB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6xJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6xK; else goto cg6xL;
       cg6xK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6xL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_entry() //  [R2, R3]
         { info_tbl: [(cg6xN,
                       label: Data.Functor.Product.$fApplicativeProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6xN: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cg6xR; else goto cg6xQ;
       cg6xR: // global
           HpAlloc = 208;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6xQ: // global
           I64[Hp - 200] = sat_sg5BG_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sg5BF_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sg5BE_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sg5BD_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sg5BC_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sg5BB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 103;
           P64[Hp - 24] = Hp - 126;
           P64[Hp - 16] = Hp - 149;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 198;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.18142748 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$c<|>_closure" {
     Data.Functor.Product.$fAlternativeProduct_$c<|>_closure:
         const Data.Functor.Product.$fAlternativeProduct_$c<|>_info;
 },
 sat_sg5BS_entry() //  [R1]
         { info_tbl: [(cg6ya,
                       label: sat_sg5BS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ya: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6yb; else goto cg6yc;
       cg6yb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6yc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5BR_entry() //  [R1]
         { info_tbl: [(cg6yh,
                       label: sat_sg5BR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6yh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6yi; else goto cg6yj;
       cg6yi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6yj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_$c<|>_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg6yk,
                       label: Data.Functor.Product.$fAlternativeProduct_$c<|>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6yk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6ym; else goto cg6yn;
       cg6ym: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$c<|>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6yn: // global
           I64[Sp - 32] = block_cg6xW_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6yt; else goto cg6xX;
       ug6yt: // global
           call _cg6xW(R1) args: 0, res: 0, upd: 0;
       cg6xX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6xW() //  [R1]
         { info_tbl: [(cg6xW,
                       label: block_cg6xW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6xW: // global
           I64[Sp - 8] = block_cg6y1_info;
           _sg5BM::P64 = P64[R1 + 7];
           _sg5BN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5BN::P64;
           P64[Sp + 24] = _sg5BM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6ys; else goto cg6y2;
       ug6ys: // global
           call _cg6y1(R1) args: 0, res: 0, upd: 0;
       cg6y2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6y1() //  [R1]
         { info_tbl: [(cg6y1,
                       label: block_cg6y1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6y1: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg6yr; else goto cg6yq;
       cg6yr: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6yq: // global
           _sg5BP::P64 = P64[R1 + 7];
           _sg5BQ::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5BS_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5BQ::P64;
           I64[Hp - 56] = sat_sg5BR_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5BP::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.183904007 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$cempty_closure" {
     Data.Functor.Product.$fAlternativeProduct_$cempty_closure:
         const Data.Functor.Product.$fAlternativeProduct_$cempty_info;
 },
 sat_sg5BW_entry() //  [R1]
         { info_tbl: [(cg6yC,
                       label: sat_sg5BW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6yC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6yD; else goto cg6yE;
       cg6yD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6yE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5BV_entry() //  [R1]
         { info_tbl: [(cg6yJ,
                       label: sat_sg5BV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6yJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6yK; else goto cg6yL;
       cg6yK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6yL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_$cempty_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cg6yN,
                       label: Data.Functor.Product.$fAlternativeProduct_$cempty_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6yN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg6yR; else goto cg6yQ;
       cg6yR: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$cempty_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6yQ: // global
           I64[Hp - 64] = sat_sg5BW_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5BV_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.185678815 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_closure" {
     Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_closure:
         const Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_info;
 },
 sat_sg5C0_entry() //  [R1]
         { info_tbl: [(cg6z0,
                       label: sat_sg5C0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6z0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6z1; else goto cg6z2;
       cg6z1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6z2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5BZ_entry() //  [R1]
         { info_tbl: [(cg6z7,
                       label: sat_sg5BZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6z7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6z8; else goto cg6z9;
       cg6z8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6z9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cg6za,
                       label: Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6za: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg6ze; else goto cg6zd;
       cg6ze: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6zd: // global
           I64[Hp - 40] = sat_sg5C0_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5BZ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fApplicativeProduct_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.187198338 UTC

[section ""data" . poly_some_v_rg5o0_closure" {
     poly_some_v_rg5o0_closure:
         const poly_some_v_rg5o0_info;
         const 0;
         const 0;
         const 0;
 },
 poly_some_v_rg5o0_entry() //  [R1]
         { info_tbl: [(cg6zl,
                       label: poly_some_v_rg5o0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6zl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6zm; else goto cg6zn;
       cg6zm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6zn: // global
           (_cg6zi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg6zi::I64 == 0) goto cg6zk; else goto cg6zj;
       cg6zk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg6zj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg6zi::I64;
           R1 = poly_some_v_rg5o0_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.188377214 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$csome_closure" {
     Data.Functor.Product.$fAlternativeProduct_$csome_closure:
         const Data.Functor.Product.$fAlternativeProduct_$csome_info;
         const 0;
 },
 Data.Functor.Product.$fAlternativeProduct_$csome_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg6zv,
                       label: Data.Functor.Product.$fAlternativeProduct_$csome_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6zv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6zw; else goto cg6zx;
       cg6zw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$csome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6zx: // global
           I64[Sp - 8] = block_cg6zs_info;
           R1 = R4;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6zB; else goto cg6zt;
       ug6zB: // global
           call _cg6zs() args: 0, res: 0, upd: 0;
       cg6zt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6zs() //  []
         { info_tbl: [(cg6zs,
                       label: block_cg6zs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6zs: // global
           R1 = poly_some_v_rg5o0_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.190454256 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_closure" {
     Data.Functor.Product.$fAlternativeProduct_closure:
         const Data.Functor.Product.$fAlternativeProduct_info;
         const 0;
 },
 sat_sg5Cd_entry() //  [R1, R2]
         { info_tbl: [(cg6zL,
                       label: sat_sg5Cd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6zL: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fAlternativeProduct_$csome_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Cc_entry() //  [R1, R2]
         { info_tbl: [(cg6zT,
                       label: sat_sg5Cc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6zT: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fAlternativeProduct_$csome_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Cb_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6A1,
                       label: sat_sg5Cb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6A1: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fAlternativeProduct_$c<|>_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Ca_entry() //  [R1]
         { info_tbl: [(cg6A8,
                       label: sat_sg5Ca_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6A8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6A9; else goto cg6Aa;
       cg6A9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Aa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fAlternativeProduct_$cempty_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5C9_entry() //  [R1]
         { info_tbl: [(cg6Af,
                       label: sat_sg5C9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Af: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Ag; else goto cg6Ah;
       cg6Ag: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Ah: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_entry() //  [R2, R3]
         { info_tbl: [(cg6Aj,
                       label: Data.Functor.Product.$fAlternativeProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Aj: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cg6An; else goto cg6Am;
       cg6An: // global
           HpAlloc = 184;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Am: // global
           I64[Hp - 176] = sat_sg5Cd_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sg5Cc_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sg5Cb_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sg5Ca_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_sg5C9_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 104;
           P64[Hp - 16] = Hp - 126;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 175;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.193573903 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$c>>=_closure" {
     Data.Functor.Product.$fMonadProduct_$c>>=_closure:
         const Data.Functor.Product.$fMonadProduct_$c>>=_info;
 },
 sat_sg5Cv_entry() //  [R1, R2]
         { info_tbl: [(cg6AI,
                       label: sat_sg5Cv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6AI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6AJ; else goto cg6AK;
       cg6AJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6AK: // global
           I64[Sp - 8] = block_cg6AG_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6AG() //  [R1]
         { info_tbl: [(cg6AG,
                       label: block_cg6AG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6AG: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Cw_entry() //  [R1]
         { info_tbl: [(cg6AO,
                       label: sat_sg5Cw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6AO: // global
           _sg5Cw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6AP; else goto cg6AQ;
       cg6AQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg6AS; else goto cg6AR;
       cg6AS: // global
           HpAlloc = 16;
           goto cg6AP;
       cg6AP: // global
           R1 = _sg5Cw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6AR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Cw::P64;
           _sg5Cf::P64 = P64[_sg5Cw::P64 + 16];
           _sg5Ch::P64 = P64[_sg5Cw::P64 + 24];
           _sg5Ck::P64 = P64[_sg5Cw::P64 + 32];
           I64[Hp - 8] = sat_sg5Cv_info;
           P64[Hp] = _sg5Ch::P64;
           R2 = _sg5Cf::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5Ck::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5Cp_entry() //  [R1, R2]
         { info_tbl: [(cg6B4,
                       label: sat_sg5Cp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6B4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6B5; else goto cg6B6;
       cg6B5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6B6: // global
           I64[Sp - 8] = block_cg6B2_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6B2() //  [R1]
         { info_tbl: [(cg6B2,
                       label: block_cg6B2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6B2: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Cq_entry() //  [R1]
         { info_tbl: [(cg6Ba,
                       label: sat_sg5Cq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ba: // global
           _sg5Cq::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6Bb; else goto cg6Bc;
       cg6Bc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg6Be; else goto cg6Bd;
       cg6Be: // global
           HpAlloc = 16;
           goto cg6Bb;
       cg6Bb: // global
           R1 = _sg5Cq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Bd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Cq::P64;
           _sg5Ce::P64 = P64[_sg5Cq::P64 + 16];
           _sg5Ch::P64 = P64[_sg5Cq::P64 + 24];
           _sg5Cj::P64 = P64[_sg5Cq::P64 + 32];
           I64[Hp - 8] = sat_sg5Cp_info;
           P64[Hp] = _sg5Ch::P64;
           R2 = _sg5Ce::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5Cj::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$c>>=_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cg6Bf,
                       label: Data.Functor.Product.$fMonadProduct_$c>>=_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Bf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6Bh; else goto cg6Bi;
       cg6Bh: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$c>>=_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Bi: // global
           I64[Sp - 32] = block_cg6As_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6Bm; else goto cg6At;
       ug6Bm: // global
           call _cg6As(R1) args: 0, res: 0, upd: 0;
       cg6At: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6As() //  [R1]
         { info_tbl: [(cg6As,
                       label: block_cg6As_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6As: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg6Bl; else goto cg6Bk;
       cg6Bl: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6Bk: // global
           _sg5Cj::P64 = P64[R1 + 7];
           _sg5Ck::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5Cw_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sg5Ch::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sg5Ch::P64;
           P64[Hp - 64] = _sg5Ck::P64;
           I64[Hp - 56] = sat_sg5Cq_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg5Ch::P64;
           P64[Hp - 24] = _sg5Cj::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.196719193 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$cp1Monad_closure" {
     Data.Functor.Product.$fMonadProduct_$cp1Monad_closure:
         const Data.Functor.Product.$fMonadProduct_$cp1Monad_info;
 },
 sat_sg5CA_entry() //  [R1]
         { info_tbl: [(cg6Bv,
                       label: sat_sg5CA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Bv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Bw; else goto cg6Bx;
       cg6Bw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Bx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Cz_entry() //  [R1]
         { info_tbl: [(cg6BC,
                       label: sat_sg5Cz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6BC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6BD; else goto cg6BE;
       cg6BD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6BE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$cp1Monad_entry() //  [R2, R3]
         { info_tbl: [(cg6BF,
                       label: Data.Functor.Product.$fMonadProduct_$cp1Monad_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6BF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg6BJ; else goto cg6BI;
       cg6BJ: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$cp1Monad_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6BI: // global
           I64[Hp - 40] = sat_sg5CA_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5Cz_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fApplicativeProduct_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.198687322 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$creturn_closure" {
     Data.Functor.Product.$fMonadProduct_$creturn_closure:
         const Data.Functor.Product.$fMonadProduct_$creturn_info;
 },
 sat_sg5CH_entry() //  [R1]
         { info_tbl: [(cg6BU,
                       label: sat_sg5CH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6BU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6BV; else goto cg6BW;
       cg6BV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6BW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cg6BS_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg6BS() //  [R1]
         { info_tbl: [(cg6BS,
                       label: block_cg6BS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6BS: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5CF_entry() //  [R1]
         { info_tbl: [(cg6C6,
                       label: sat_sg5CF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6C6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6C7; else goto cg6C8;
       cg6C7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6C8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cg6C4_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg6C4() //  [R1]
         { info_tbl: [(cg6C4,
                       label: block_cg6C4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6C4: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$creturn_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cg6Cd,
                       label: Data.Functor.Product.$fMonadProduct_$creturn_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Cd: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg6Ch; else goto cg6Cg;
       cg6Ch: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$creturn_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Cg: // global
           I64[Hp - 80] = sat_sg5CH_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg5CF_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.20154478 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$c>>_closure" {
     Data.Functor.Product.$fMonadProduct_$c>>_closure:
         const Data.Functor.Product.$fMonadProduct_$c>>_info;
 },
 sat_sg5CZ_entry() //  [R1, R2]
         { info_tbl: [(cg6CD,
                       label: sat_sg5CZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6CD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6CE; else goto cg6CF;
       cg6CE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6CF: // global
           I64[Sp - 8] = block_cg6CA_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6CJ; else goto cg6CB;
       ug6CJ: // global
           call _cg6CA(R1) args: 0, res: 0, upd: 0;
       cg6CB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6CA() //  [R1]
         { info_tbl: [(cg6CA,
                       label: block_cg6CA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6CA: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5D0_entry() //  [R1]
         { info_tbl: [(cg6CK,
                       label: sat_sg5D0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6CK: // global
           _sg5D0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6CL; else goto cg6CM;
       cg6CM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg6CO; else goto cg6CN;
       cg6CO: // global
           HpAlloc = 16;
           goto cg6CL;
       cg6CL: // global
           R1 = _sg5D0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6CN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5D0::P64;
           _sg5CJ::P64 = P64[_sg5D0::P64 + 16];
           _sg5CL::P64 = P64[_sg5D0::P64 + 24];
           _sg5CO::P64 = P64[_sg5D0::P64 + 32];
           I64[Hp - 8] = sat_sg5CZ_info;
           P64[Hp] = _sg5CL::P64;
           R2 = _sg5CJ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5CO::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5CT_entry() //  [R1, R2]
         { info_tbl: [(cg6D1,
                       label: sat_sg5CT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6D1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6D2; else goto cg6D3;
       cg6D2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6D3: // global
           I64[Sp - 8] = block_cg6CY_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6D7; else goto cg6CZ;
       ug6D7: // global
           call _cg6CY(R1) args: 0, res: 0, upd: 0;
       cg6CZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6CY() //  [R1]
         { info_tbl: [(cg6CY,
                       label: block_cg6CY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6CY: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5CU_entry() //  [R1]
         { info_tbl: [(cg6D8,
                       label: sat_sg5CU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6D8: // global
           _sg5CU::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6D9; else goto cg6Da;
       cg6Da: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg6Dc; else goto cg6Db;
       cg6Dc: // global
           HpAlloc = 16;
           goto cg6D9;
       cg6D9: // global
           R1 = _sg5CU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Db: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5CU::P64;
           _sg5CI::P64 = P64[_sg5CU::P64 + 16];
           _sg5CL::P64 = P64[_sg5CU::P64 + 24];
           _sg5CN::P64 = P64[_sg5CU::P64 + 32];
           I64[Hp - 8] = sat_sg5CT_info;
           P64[Hp] = _sg5CL::P64;
           R2 = _sg5CI::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5CN::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$c>>_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(cg6Dd,
                       label: Data.Functor.Product.$fMonadProduct_$c>>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Dd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6Df; else goto cg6Dg;
       cg6Df: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$c>>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Dg: // global
           I64[Sp - 32] = block_cg6Cm_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6Dk; else goto cg6Cn;
       ug6Dk: // global
           call _cg6Cm(R1) args: 0, res: 0, upd: 0;
       cg6Cn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Cm() //  [R1]
         { info_tbl: [(cg6Cm,
                       label: block_cg6Cm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Cm: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg6Dj; else goto cg6Di;
       cg6Dj: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6Di: // global
           _sg5CN::P64 = P64[R1 + 7];
           _sg5CO::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5D0_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sg5CL::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sg5CL::P64;
           P64[Hp - 64] = _sg5CO::P64;
           I64[Hp - 56] = sat_sg5CU_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg5CL::P64;
           P64[Hp - 24] = _sg5CN::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.204642795 UTC

[section ""data" . lvl4_rg5o1_closure" {
     lvl4_rg5o1_closure:
         const lvl4_rg5o1_info;
         const 0;
 },
 lvl4_rg5o1_entry() //  [R2]
         { info_tbl: [(cg6Dp,
                       label: lvl4_rg5o1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Dp: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.207674385 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_closure" {
     Data.Functor.Product.$fMonadProduct_closure:
         const Data.Functor.Product.$fMonadProduct_info;
         const 0;
 },
 sat_sg5D7_entry() //  [R1, R2]
         { info_tbl: [(cg6DB,
                       label: sat_sg5D7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6DB: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fMonadProduct_$creturn_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5D6_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6DJ,
                       label: sat_sg5D6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6DJ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadProduct_$c>>_entry(R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5D5_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6DR,
                       label: sat_sg5D5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6DR: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadProduct_$c>>=_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5D4_entry() //  [R1]
         { info_tbl: [(cg6DY,
                       label: sat_sg5D4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6DY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6DZ; else goto cg6E0;
       cg6DZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6E0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadProduct_$cp1Monad_entry(R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_entry() //  [R2, R3]
         { info_tbl: [(cg6E2,
                       label: Data.Functor.Product.$fMonadProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6E2: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cg6E6; else goto cg6E5;
       cg6E6: // global
           HpAlloc = 152;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6E5: // global
           I64[Hp - 144] = sat_sg5D7_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_sg5D6_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_sg5D5_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_sg5D4_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 94;
           P64[Hp - 16] = Hp - 118;
           P64[Hp - 8] = Hp - 143;
           P64[Hp] = lvl4_rg5o1_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.210152603 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cmplus_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cmplus_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cmplus_info;
 },
 sat_sg5Dj_entry() //  [R1]
         { info_tbl: [(cg6Ep,
                       label: sat_sg5Dj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ep: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6Eq; else goto cg6Er;
       cg6Eq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Er: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5Di_entry() //  [R1]
         { info_tbl: [(cg6Ew,
                       label: sat_sg5Di_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ew: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6Ex; else goto cg6Ey;
       cg6Ex: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Ey: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cmplus_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg6Ez,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cmplus_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ez: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6EB; else goto cg6EC;
       cg6EB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cmplus_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6EC: // global
           I64[Sp - 32] = block_cg6Eb_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6EI; else goto cg6Ec;
       ug6EI: // global
           call _cg6Eb(R1) args: 0, res: 0, upd: 0;
       cg6Ec: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Eb() //  [R1]
         { info_tbl: [(cg6Eb,
                       label: block_cg6Eb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Eb: // global
           I64[Sp - 8] = block_cg6Eg_info;
           _sg5Dd::P64 = P64[R1 + 7];
           _sg5De::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5De::P64;
           P64[Sp + 24] = _sg5Dd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6EH; else goto cg6Eh;
       ug6EH: // global
           call _cg6Eg(R1) args: 0, res: 0, upd: 0;
       cg6Eh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Eg() //  [R1]
         { info_tbl: [(cg6Eg,
                       label: block_cg6Eg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Eg: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg6EG; else goto cg6EF;
       cg6EG: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6EF: // global
           _sg5Dg::P64 = P64[R1 + 7];
           _sg5Dh::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5Dj_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5Dh::P64;
           I64[Hp - 56] = sat_sg5Di_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5Dg::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.212572041 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cmzero_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cmzero_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cmzero_info;
 },
 sat_sg5Dn_entry() //  [R1]
         { info_tbl: [(cg6ER,
                       label: sat_sg5Dn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ER: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6ES; else goto cg6ET;
       cg6ES: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6ET: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Dm_entry() //  [R1]
         { info_tbl: [(cg6EY,
                       label: sat_sg5Dm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6EY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6EZ; else goto cg6F0;
       cg6EZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6F0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cmzero_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cg6F2,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cmzero_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6F2: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg6F6; else goto cg6F5;
       cg6F6: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cmzero_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6F5: // global
           I64[Hp - 64] = sat_sg5Dn_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5Dm_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.214401692 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_info;
         const 0;
 },
 sat_sg5Dr_entry() //  [R1]
         { info_tbl: [(cg6Ff,
                       label: sat_sg5Dr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ff: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Fg; else goto cg6Fh;
       cg6Fg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Fh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Dq_entry() //  [R1]
         { info_tbl: [(cg6Fm,
                       label: sat_sg5Dq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Fm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Fn; else goto cg6Fo;
       cg6Fn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Fo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cg6Fp,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Fp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg6Ft; else goto cg6Fs;
       cg6Ft: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Fs: // global
           I64[Hp - 40] = sat_sg5Dr_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5Dq_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fMonadProduct_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.216159432 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_info;
         const 0;
 },
 sat_sg5Dv_entry() //  [R1]
         { info_tbl: [(cg6FC,
                       label: sat_sg5Dv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6FC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6FD; else goto cg6FE;
       cg6FD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6FE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Du_entry() //  [R1]
         { info_tbl: [(cg6FJ,
                       label: sat_sg5Du_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6FJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6FK; else goto cg6FL;
       cg6FK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6FL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cg6FM,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6FM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg6FQ; else goto cg6FP;
       cg6FQ: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6FP: // global
           I64[Hp - 40] = sat_sg5Dv_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5Du_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fAlternativeProduct_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.218205317 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_closure" {
     Data.Functor.Product.$fMonadPlusProduct_closure:
         const Data.Functor.Product.$fMonadPlusProduct_info;
         const 0;
 },
 sat_sg5DB_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6G0,
                       label: sat_sg5DB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6G0: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadPlusProduct_$cmplus_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5DA_entry() //  [R1]
         { info_tbl: [(cg6G7,
                       label: sat_sg5DA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6G7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6G8; else goto cg6G9;
       cg6G8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6G9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadPlusProduct_$cmzero_entry(R3,
                                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Dz_entry() //  [R1]
         { info_tbl: [(cg6Ge,
                       label: sat_sg5Dz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ge: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Gf; else goto cg6Gg;
       cg6Gf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Gg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_entry(R3,
                                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Dy_entry() //  [R1]
         { info_tbl: [(cg6Gl,
                       label: sat_sg5Dy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Gl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Gm; else goto cg6Gn;
       cg6Gm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Gn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_entry(R3,
                                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_entry() //  [R2, R3]
         { info_tbl: [(cg6Gp,
                       label: Data.Functor.Product.$fMonadPlusProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Gp: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cg6Gt; else goto cg6Gs;
       cg6Gt: // global
           HpAlloc = 160;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Gs: // global
           I64[Hp - 152] = sat_sg5DB_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sg5DA_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_sg5Dz_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sg5Dy_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 96;
           P64[Hp - 8] = Hp - 128;
           P64[Hp] = Hp - 150;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.221023272 UTC

[section ""data" . Data.Functor.Product.$fMonadFixProduct_$cmfix_closure" {
     Data.Functor.Product.$fMonadFixProduct_$cmfix_closure:
         const Data.Functor.Product.$fMonadFixProduct_$cmfix_info;
 },
 sat_sg5DP_entry() //  [R1, R2]
         { info_tbl: [(cg6GJ,
                       label: sat_sg5DP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6GJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6GK; else goto cg6GL;
       cg6GK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6GL: // global
           I64[Sp - 8] = block_cg6GH_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6GH() //  [R1]
         { info_tbl: [(cg6GH,
                       label: block_cg6GH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6GH: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5DQ_entry() //  [R1]
         { info_tbl: [(cg6GP,
                       label: sat_sg5DQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6GP: // global
           _sg5DQ::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg6GQ; else goto cg6GR;
       cg6GR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg6GT; else goto cg6GS;
       cg6GT: // global
           HpAlloc = 16;
           goto cg6GQ;
       cg6GQ: // global
           R1 = _sg5DQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6GS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5DQ::P64;
           _sg5DD::P64 = P64[_sg5DQ::P64 + 16];
           _sg5DE::P64 = P64[_sg5DQ::P64 + 24];
           I64[Hp - 8] = sat_sg5DP_info;
           P64[Hp] = _sg5DE::P64;
           R2 = _sg5DD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5DJ_entry() //  [R1, R2]
         { info_tbl: [(cg6H5,
                       label: sat_sg5DJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6H5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6H6; else goto cg6H7;
       cg6H6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6H7: // global
           I64[Sp - 8] = block_cg6H3_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6H3() //  [R1]
         { info_tbl: [(cg6H3,
                       label: block_cg6H3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6H3: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5DK_entry() //  [R1]
         { info_tbl: [(cg6Hb,
                       label: sat_sg5DK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Hb: // global
           _sg5DK::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg6Hc; else goto cg6Hd;
       cg6Hd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg6Hf; else goto cg6He;
       cg6Hf: // global
           HpAlloc = 16;
           goto cg6Hc;
       cg6Hc: // global
           R1 = _sg5DK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6He: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5DK::P64;
           _sg5DC::P64 = P64[_sg5DK::P64 + 16];
           _sg5DE::P64 = P64[_sg5DK::P64 + 24];
           I64[Hp - 8] = sat_sg5DJ_info;
           P64[Hp] = _sg5DE::P64;
           R2 = _sg5DC::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadFixProduct_$cmfix_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cg6Hh,
                       label: Data.Functor.Product.$fMonadFixProduct_$cmfix_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Hh: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg6Hl; else goto cg6Hk;
       cg6Hl: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadFixProduct_$cmfix_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Hk: // global
           I64[Hp - 80] = sat_sg5DQ_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg5DK_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.223808223 UTC

[section ""data" . Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure" {
     Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure:
         const Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_info;
         const 0;
 },
 sat_sg5DU_entry() //  [R1]
         { info_tbl: [(cg6Hu,
                       label: sat_sg5DU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Hu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Hv; else goto cg6Hw;
       cg6Hv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Hw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5DT_entry() //  [R1]
         { info_tbl: [(cg6HB,
                       label: sat_sg5DT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6HB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6HC; else goto cg6HD;
       cg6HC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6HD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cg6HE,
                       label: Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6HE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg6HI; else goto cg6HH;
       cg6HI: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6HH: // global
           I64[Hp - 40] = sat_sg5DU_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5DT_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fMonadProduct_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.225620735 UTC

[section ""data" . Data.Functor.Product.$fMonadFixProduct_closure" {
     Data.Functor.Product.$fMonadFixProduct_closure:
         const Data.Functor.Product.$fMonadFixProduct_info;
         const 0;
 },
 sat_sg5DY_entry() //  [R1, R2]
         { info_tbl: [(cg6HS,
                       label: sat_sg5DY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6HS: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fMonadFixProduct_$cmfix_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5DX_entry() //  [R1]
         { info_tbl: [(cg6HZ,
                       label: sat_sg5DX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6HZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6I0; else goto cg6I1;
       cg6I0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6I1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_entry(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadFixProduct_entry() //  [R2, R3]
         { info_tbl: [(cg6I3,
                       label: Data.Functor.Product.$fMonadFixProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6I3: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg6I7; else goto cg6I6;
       cg6I7: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadFixProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6I6: // global
           I64[Hp - 72] = sat_sg5DY_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sg5DX_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 71;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.22772512 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cmzipWith_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cmzipWith_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cmzipWith_info;
 },
 sat_sg5Eb_entry() //  [R1]
         { info_tbl: [(cg6Iq,
                       label: sat_sg5Eb_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Iq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6Ir; else goto cg6Is;
       cg6Ir: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Is: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5Ea_entry() //  [R1]
         { info_tbl: [(cg6Ix,
                       label: sat_sg5Ea_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ix: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6Iy; else goto cg6Iz;
       cg6Iy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Iz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_$cmzipWith_entry() //  [R2,
                                                                R3, R4, R5, R6]
         { info_tbl: [(cg6IA,
                       label: Data.Functor.Product.$fMonadZipProduct_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6IA: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6IC; else goto cg6ID;
       cg6IC: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cmzipWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6ID: // global
           I64[Sp - 40] = block_cg6Ic_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6IJ; else goto cg6Id;
       ug6IJ: // global
           call _cg6Ic(R1) args: 0, res: 0, upd: 0;
       cg6Id: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Ic() //  [R1]
         { info_tbl: [(cg6Ic,
                       label: block_cg6Ic_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ic: // global
           I64[Sp - 8] = block_cg6Ih_info;
           _sg5E5::P64 = P64[R1 + 7];
           _sg5E6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5E6::P64;
           P64[Sp + 32] = _sg5E5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6II; else goto cg6Ii;
       ug6II: // global
           call _cg6Ih(R1) args: 0, res: 0, upd: 0;
       cg6Ii: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Ih() //  [R1]
         { info_tbl: [(cg6Ih,
                       label: block_cg6Ih_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ih: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cg6IH; else goto cg6IG;
       cg6IH: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6IG: // global
           _sg5E8::P64 = P64[R1 + 7];
           _sg5E9::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sg5Eb_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sg5E1::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sg5E1::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sg5E9::P64;
           I64[Hp - 64] = sat_sg5Ea_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sg5E1::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sg5E8::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.230429122 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_info;
         const 0;
 },
 sat_sg5Ef_entry() //  [R1]
         { info_tbl: [(cg6IS,
                       label: sat_sg5Ef_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6IS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6IT; else goto cg6IU;
       cg6IT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6IU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Ee_entry() //  [R1]
         { info_tbl: [(cg6IZ,
                       label: sat_sg5Ee_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6IZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6J0; else goto cg6J1;
       cg6J0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6J1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cg6J2,
                       label: Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6J2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg6J6; else goto cg6J5;
       cg6J6: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6J5: // global
           I64[Hp - 40] = sat_sg5Ef_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5Ee_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fMonadProduct_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.232555319 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cmzip_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cmzip_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cmzip_info;
 },
 sat_sg5Er_entry() //  [R1]
         { info_tbl: [(cg6Jp,
                       label: sat_sg5Er_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Jp: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6Jq; else goto cg6Jr;
       cg6Jq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Jr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5Eq_entry() //  [R1]
         { info_tbl: [(cg6Jw,
                       label: sat_sg5Eq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Jw: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6Jx; else goto cg6Jy;
       cg6Jx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Jy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_$cmzip_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cg6Jz,
                       label: Data.Functor.Product.$fMonadZipProduct_$cmzip_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Jz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6JB; else goto cg6JC;
       cg6JB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cmzip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6JC: // global
           I64[Sp - 32] = block_cg6Jb_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6JI; else goto cg6Jc;
       ug6JI: // global
           call _cg6Jb(R1) args: 0, res: 0, upd: 0;
       cg6Jc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Jb() //  [R1]
         { info_tbl: [(cg6Jb,
                       label: block_cg6Jb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Jb: // global
           I64[Sp - 8] = block_cg6Jg_info;
           _sg5El::P64 = P64[R1 + 7];
           _sg5Em::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5Em::P64;
           P64[Sp + 24] = _sg5El::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6JH; else goto cg6Jh;
       ug6JH: // global
           call _cg6Jg(R1) args: 0, res: 0, upd: 0;
       cg6Jh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Jg() //  [R1]
         { info_tbl: [(cg6Jg,
                       label: block_cg6Jg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Jg: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg6JG; else goto cg6JF;
       cg6JG: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6JF: // global
           _sg5Eo::P64 = P64[R1 + 7];
           _sg5Ep::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5Er_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5Ep::P64;
           I64[Hp - 56] = sat_sg5Eq_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5Eo::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.23783057 UTC

[section ""data" . Data.Functor.Product.$w$cmunzip_closure" {
     Data.Functor.Product.$w$cmunzip_closure:
         const Data.Functor.Product.$w$cmunzip_info;
 },
 $dMonad_sg5Ev_entry() //  [R1]
         { info_tbl: [(cg6JR,
                       label: $dMonad_sg5Ev_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6JR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6JS; else goto cg6JT;
       cg6JS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6JT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dMonad1_sg5Ew_entry() //  [R1]
         { info_tbl: [(cg6JY,
                       label: $dMonad1_sg5Ew_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6JY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6JZ; else goto cg6K0;
       cg6JZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6K0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sg5F2_entry() //  [R1]
         { info_tbl: [(cg6Ki,
                       label: lvl9_sg5F2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ki: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Kj; else goto cg6Kk;
       cg6Kj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Kk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5F8_entry() //  [R1, R2]
         { info_tbl: [(cg6Kr,
                       label: sat_sg5F8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Kr: // global
           _sg5F3::P64 = R2;
           _sg5F8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Ks; else goto cg6Kt;
       cg6Kt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6Kv; else goto cg6Ku;
       cg6Kv: // global
           HpAlloc = 24;
           goto cg6Ks;
       cg6Ks: // global
           R2 = _sg5F3::P64;
           R1 = _sg5F8::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6Ku: // global
           _sg5F2::P64 = P64[_sg5F8::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sg5F3::P64;
           R2 = _sg5F2::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5F9_entry() //  [R1]
         { info_tbl: [(cg6Kw,
                       label: sat_sg5F9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Kw: // global
           _sg5F9::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6Kx; else goto cg6Ky;
       cg6Ky: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg6KA; else goto cg6Kz;
       cg6KA: // global
           HpAlloc = 40;
           goto cg6Kx;
       cg6Kx: // global
           R1 = _sg5F9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Kz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5F9::P64;
           _sg5Ew::P64 = P64[_sg5F9::P64 + 16];
           _sg5ET::P64 = P64[_sg5F9::P64 + 24];
           I64[Hp - 32] = lvl9_sg5F2_info;
           P64[Hp - 16] = _sg5Ew::P64;
           I64[Hp - 8] = sat_sg5F8_info;
           P64[Hp] = Hp - 32;
           R2 = _sg5Ew::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5ET::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 lvl9_sg5EU_entry() //  [R1]
         { info_tbl: [(cg6KJ,
                       label: lvl9_sg5EU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6KJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6KK; else goto cg6KL;
       cg6KK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6KL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5F0_entry() //  [R1, R2]
         { info_tbl: [(cg6KS,
                       label: sat_sg5F0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6KS: // global
           _sg5EV::P64 = R2;
           _sg5F0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6KT; else goto cg6KU;
       cg6KU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6KW; else goto cg6KV;
       cg6KW: // global
           HpAlloc = 24;
           goto cg6KT;
       cg6KT: // global
           R2 = _sg5EV::P64;
           R1 = _sg5F0::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6KV: // global
           _sg5EU::P64 = P64[_sg5F0::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sg5EV::P64;
           R2 = _sg5EU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5F1_entry() //  [R1]
         { info_tbl: [(cg6KX,
                       label: sat_sg5F1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6KX: // global
           _sg5F1::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6KY; else goto cg6KZ;
       cg6KZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg6L1; else goto cg6L0;
       cg6L1: // global
           HpAlloc = 40;
           goto cg6KY;
       cg6KY: // global
           R1 = _sg5F1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6L0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5F1::P64;
           _sg5Ev::P64 = P64[_sg5F1::P64 + 16];
           _sg5ES::P64 = P64[_sg5F1::P64 + 24];
           I64[Hp - 32] = lvl9_sg5EU_info;
           P64[Hp - 16] = _sg5Ev::P64;
           I64[Hp - 8] = sat_sg5F0_info;
           P64[Hp] = Hp - 32;
           R2 = _sg5Ev::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5ES::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5Fa_entry() //  [R1]
         { info_tbl: [(cg6L2,
                       label: sat_sg5Fa_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6L2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6L4; else goto cg6L5;
       cg6L4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6L5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg6K5_info;
           _sg5Ev::P64 = P64[R1 + 24];
           _sg5Ew::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sg5Ev::P64;
           P64[Sp - 24] = _sg5Ew::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6L9; else goto cg6K6;
       ug6L9: // global
           call _cg6K5(R1) args: 0, res: 0, upd: 0;
       cg6K6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg6K5() //  [R1]
         { info_tbl: [(cg6K5,
                       label: block_cg6K5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6K5: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg6L8; else goto cg6L7;
       cg6L8: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg6L7: // global
           _sg5ES::P64 = P64[R1 + 7];
           _sg5ET::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sg5F9_info;
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = _sg5ET::P64;
           I64[Hp - 48] = sat_sg5F1_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg5ES::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sg5EI_entry() //  [R1]
         { info_tbl: [(cg6Lr,
                       label: lvl9_sg5EI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Lr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Ls; else goto cg6Lt;
       cg6Ls: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Lt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5EO_entry() //  [R1, R2]
         { info_tbl: [(cg6LA,
                       label: sat_sg5EO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6LA: // global
           _sg5EJ::P64 = R2;
           _sg5EO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6LB; else goto cg6LC;
       cg6LC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6LE; else goto cg6LD;
       cg6LE: // global
           HpAlloc = 24;
           goto cg6LB;
       cg6LB: // global
           R2 = _sg5EJ::P64;
           R1 = _sg5EO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6LD: // global
           _sg5EI::P64 = P64[_sg5EO::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sg5EJ::P64;
           R2 = _sg5EI::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5EP_entry() //  [R1]
         { info_tbl: [(cg6LF,
                       label: sat_sg5EP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6LF: // global
           _sg5EP::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6LG; else goto cg6LH;
       cg6LH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg6LJ; else goto cg6LI;
       cg6LJ: // global
           HpAlloc = 40;
           goto cg6LG;
       cg6LG: // global
           R1 = _sg5EP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6LI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5EP::P64;
           _sg5Ew::P64 = P64[_sg5EP::P64 + 16];
           _sg5Ez::P64 = P64[_sg5EP::P64 + 24];
           I64[Hp - 32] = lvl9_sg5EI_info;
           P64[Hp - 16] = _sg5Ew::P64;
           I64[Hp - 8] = sat_sg5EO_info;
           P64[Hp] = Hp - 32;
           R2 = _sg5Ew::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5Ez::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 lvl9_sg5EA_entry() //  [R1]
         { info_tbl: [(cg6LS,
                       label: lvl9_sg5EA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6LS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6LT; else goto cg6LU;
       cg6LT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6LU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5EG_entry() //  [R1, R2]
         { info_tbl: [(cg6M1,
                       label: sat_sg5EG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6M1: // global
           _sg5EB::P64 = R2;
           _sg5EG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6M2; else goto cg6M3;
       cg6M3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6M5; else goto cg6M4;
       cg6M5: // global
           HpAlloc = 24;
           goto cg6M2;
       cg6M2: // global
           R2 = _sg5EB::P64;
           R1 = _sg5EG::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6M4: // global
           _sg5EA::P64 = P64[_sg5EG::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sg5EB::P64;
           R2 = _sg5EA::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5EH_entry() //  [R1]
         { info_tbl: [(cg6M6,
                       label: sat_sg5EH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6M6: // global
           _sg5EH::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6M7; else goto cg6M8;
       cg6M8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg6Ma; else goto cg6M9;
       cg6Ma: // global
           HpAlloc = 40;
           goto cg6M7;
       cg6M7: // global
           R1 = _sg5EH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6M9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5EH::P64;
           _sg5Ev::P64 = P64[_sg5EH::P64 + 16];
           _sg5Ey::P64 = P64[_sg5EH::P64 + 24];
           I64[Hp - 32] = lvl9_sg5EA_info;
           P64[Hp - 16] = _sg5Ev::P64;
           I64[Hp - 8] = sat_sg5EG_info;
           P64[Hp] = Hp - 32;
           R2 = _sg5Ev::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5Ey::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5EQ_entry() //  [R1]
         { info_tbl: [(cg6Mb,
                       label: sat_sg5EQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Mb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6Md; else goto cg6Me;
       cg6Md: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Me: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg6Le_info;
           _sg5Ev::P64 = P64[R1 + 24];
           _sg5Ew::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sg5Ev::P64;
           P64[Sp - 24] = _sg5Ew::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6Mi; else goto cg6Lf;
       ug6Mi: // global
           call _cg6Le(R1) args: 0, res: 0, upd: 0;
       cg6Lf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg6Le() //  [R1]
         { info_tbl: [(cg6Le,
                       label: block_cg6Le_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Le: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg6Mh; else goto cg6Mg;
       cg6Mh: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg6Mg: // global
           _sg5Ey::P64 = P64[R1 + 7];
           _sg5Ez::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sg5EP_info;
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = _sg5Ez::P64;
           I64[Hp - 48] = sat_sg5EH_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg5Ey::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cmunzip_entry() //  [R2, R3, R4]
         { info_tbl: [(cg6Mj,
                       label: Data.Functor.Product.$w$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Mj: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg6Mn; else goto cg6Mm;
       cg6Mn: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Mm: // global
           I64[Hp - 120] = $dMonad_sg5Ev_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = $dMonad1_sg5Ew_info;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_sg5Fa_info;
           P64[Hp - 56] = R4;
           _cg6JN::P64 = Hp - 120;
           P64[Hp - 48] = _cg6JN::P64;
           _cg6JU::P64 = Hp - 96;
           P64[Hp - 40] = _cg6JU::P64;
           I64[Hp - 32] = sat_sg5EQ_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _cg6JN::P64;
           P64[Hp] = _cg6JU::P64;
           R2 = Hp - 72;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.246002892 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cmunzip_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cmunzip_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cmunzip_info;
 },
 Data.Functor.Product.$fMonadZipProduct_$cmunzip_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cg6Mv,
                       label: Data.Functor.Product.$fMonadZipProduct_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Mv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6Mw; else goto cg6Mx;
       cg6Mw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Mx: // global
           I64[Sp - 8] = block_cg6Ms_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Functor.Product.$w$cmunzip_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Ms() //  [R1, R2]
         { info_tbl: [(cg6Ms,
                       label: block_cg6Ms_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ms: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6MA; else goto cg6Mz;
       cg6MA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cg6Mz: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.247845272 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_closure" {
     Data.Functor.Product.$fMonadZipProduct_closure:
         const Data.Functor.Product.$fMonadZipProduct_info;
         const 0;
 },
 sat_sg5Fm_entry() //  [R1, R2]
         { info_tbl: [(cg6MK,
                       label: sat_sg5Fm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6MK: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fMonadZipProduct_$cmunzip_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Fl_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6MS,
                       label: sat_sg5Fl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6MS: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fMonadZipProduct_$cmzipWith_entry(R6,
                                                                        R5,
                                                                        R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Fk_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6N0,
                       label: sat_sg5Fk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6N0: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadZipProduct_$cmzip_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Fj_entry() //  [R1]
         { info_tbl: [(cg6N7,
                       label: sat_sg5Fj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6N7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6N8; else goto cg6N9;
       cg6N8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6N9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_entry(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_entry() //  [R2, R3]
         { info_tbl: [(cg6Nb,
                       label: Data.Functor.Product.$fMonadZipProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Nb: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cg6Nf; else goto cg6Ne;
       cg6Nf: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Ne: // global
           I64[Hp - 136] = sat_sg5Fm_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sg5Fl_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sg5Fk_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sg5Fj_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 86;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = Hp - 135;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.250011056 UTC

[section ""data" . Data.Functor.Product.$fGeneric1Product_$cto1_closure" {
     Data.Functor.Product.$fGeneric1Product_$cto1_closure:
         const Data.Functor.Product.$fGeneric1Product_$cto1_info;
 },
 Data.Functor.Product.$fGeneric1Product_$cto1_entry() //  [R2]
         { info_tbl: [(cg6Nm,
                       label: Data.Functor.Product.$fGeneric1Product_$cto1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Nm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6Nq; else goto cg6Nr;
       cg6Nq: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGeneric1Product_$cto1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6Nr: // global
           I64[Sp - 8] = block_cg6Nk_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Nk() //  [R1]
         { info_tbl: [(cg6Nk,
                       label: block_cg6Nk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Nk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6Nu; else goto cg6Nt;
       cg6Nu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6Nt: // global
           _sg5Fp::P64 = P64[R1 + 7];
           _sg5Fq::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = _sg5Fp::P64;
           P64[Hp] = _sg5Fq::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.25133507 UTC

[section ""data" . Data.Functor.Product.$fGeneric1Product1_closure" {
     Data.Functor.Product.$fGeneric1Product1_closure:
         const Data.Functor.Product.$fGeneric1Product1_info;
 },
 Data.Functor.Product.$fGeneric1Product1_entry() //  [R2]
         { info_tbl: [(cg6NC,
                       label: Data.Functor.Product.$fGeneric1Product1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6NC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6NG; else goto cg6NH;
       cg6NG: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGeneric1Product1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6NH: // global
           I64[Sp - 8] = block_cg6Nz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6NL; else goto cg6NA;
       ug6NL: // global
           call _cg6Nz(R1) args: 0, res: 0, upd: 0;
       cg6NA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Nz() //  [R1]
         { info_tbl: [(cg6Nz,
                       label: block_cg6Nz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Nz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6NK; else goto cg6NJ;
       cg6NK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6NJ: // global
           _sg5Ft::P64 = P64[R1 + 7];
           _sg5Fu::P64 = P64[R1 + 15];
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = _sg5Ft::P64;
           P64[Hp] = _sg5Fu::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.252484287 UTC

[section ""data" . Data.Functor.Product.$fGeneric1Product_closure" {
     Data.Functor.Product.$fGeneric1Product_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Product.$fGeneric1Product1_closure+1;
         const Data.Functor.Product.$fGeneric1Product_$cto1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.253356406 UTC

[section ""data" . Data.Functor.Product.$fGenericProduct_$cto_closure" {
     Data.Functor.Product.$fGenericProduct_$cto_closure:
         const Data.Functor.Product.$fGenericProduct_$cto_info;
 },
 Data.Functor.Product.$fGenericProduct_$cto_entry() //  [R2]
         { info_tbl: [(cg6NS,
                       label: Data.Functor.Product.$fGenericProduct_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6NS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6NW; else goto cg6NX;
       cg6NW: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGenericProduct_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6NX: // global
           I64[Sp - 8] = block_cg6NQ_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6NQ() //  [R1]
         { info_tbl: [(cg6NQ,
                       label: block_cg6NQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6NQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6O0; else goto cg6NZ;
       cg6O0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6NZ: // global
           _sg5Fx::P64 = P64[R1 + 7];
           _sg5Fy::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = _sg5Fx::P64;
           P64[Hp] = _sg5Fy::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.254729251 UTC

[section ""data" . Data.Functor.Product.$fGenericProduct1_closure" {
     Data.Functor.Product.$fGenericProduct1_closure:
         const Data.Functor.Product.$fGenericProduct1_info;
 },
 Data.Functor.Product.$fGenericProduct1_entry() //  [R2]
         { info_tbl: [(cg6O8,
                       label: Data.Functor.Product.$fGenericProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6O8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6Oc; else goto cg6Od;
       cg6Oc: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGenericProduct1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6Od: // global
           I64[Sp - 8] = block_cg6O5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6Oh; else goto cg6O6;
       ug6Oh: // global
           call _cg6O5(R1) args: 0, res: 0, upd: 0;
       cg6O6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6O5() //  [R1]
         { info_tbl: [(cg6O5,
                       label: block_cg6O5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6O5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6Og; else goto cg6Of;
       cg6Og: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6Of: // global
           _sg5FB::P64 = P64[R1 + 7];
           _sg5FC::P64 = P64[R1 + 15];
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = _sg5FB::P64;
           P64[Hp] = _sg5FC::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.255908157 UTC

[section ""data" . Data.Functor.Product.$fGenericProduct_closure" {
     Data.Functor.Product.$fGenericProduct_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Product.$fGenericProduct1_closure+1;
         const Data.Functor.Product.$fGenericProduct_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.257330544 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgfoldl_closure" {
     Data.Functor.Product.$fDataProduct_$cgfoldl_closure:
         const Data.Functor.Product.$fDataProduct_$cgfoldl_info;
 },
 Data.Functor.Product.$fDataProduct_$cgfoldl_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Oj: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgfoldl_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg5FP_entry() //  [R1]
         { info_tbl: [(cg6OA,
                       label: sat_sg5FP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6OA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6OB; else goto cg6OC;
       cg6OB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6OC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Product.Pair_closure+2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5FQ_entry() //  [R1]
         { info_tbl: [(cg6OD,
                       label: sat_sg5FQ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6OD: // global
           _sg5FQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6OE; else goto cg6OF;
       cg6OF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6OH; else goto cg6OG;
       cg6OH: // global
           HpAlloc = 24;
           goto cg6OE;
       cg6OE: // global
           R1 = _sg5FQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6OG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5FQ::P64;
           _sg5FH::P64 = P64[_sg5FQ::P64 + 16];
           _sg5FJ::P64 = P64[_sg5FQ::P64 + 24];
           _sg5FK::P64 = P64[_sg5FQ::P64 + 32];
           _sg5FN::P64 = P64[_sg5FQ::P64 + 40];
           I64[Hp - 16] = sat_sg5FP_info;
           P64[Hp] = _sg5FK::P64;
           R4 = _sg5FN::P64;
           R3 = Hp - 16;
           R2 = _sg5FH::P64;
           R1 = _sg5FJ::P64;
           Sp = Sp - 16;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgfoldl_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cg6OI,
                       label: Data.Functor.Product.$fDataProduct_$cgfoldl_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6OI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6OJ; else goto cg6OK;
       cg6OJ: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgfoldl_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cg6OK: // global
           I64[Sp - 8] = block_cg6On_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6OO; else goto cg6Oo;
       ug6OO: // global
           call _cg6On(R1) args: 0, res: 0, upd: 0;
       cg6Oo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6On() //  [R1]
         { info_tbl: [(cg6On,
                       label: block_cg6On_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6On: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg6ON; else goto cg6OM;
       cg6ON: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6OM: // global
           _sg5FN::P64 = P64[R1 + 7];
           _sg5FO::P64 = P64[R1 + 15];
           I64[Hp - 40] = sat_sg5FQ_info;
           P64[Hp - 24] = P64[Sp + 32];
           _sg5FJ::P64 = P64[Sp + 16];
           P64[Hp - 16] = _sg5FJ::P64;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sg5FN::P64;
           R4 = _sg5FO::P64;
           R3 = Hp - 40;
           R2 = P64[Sp + 8];
           R1 = _sg5FJ::P64;
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.259492672 UTC

[section ""cstring" . Data.Functor.Product.$fDataProduct6_bytes" {
     Data.Functor.Product.$fDataProduct6_bytes:
         I8[] [80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.260243837 UTC

[section ""data" . Data.Functor.Product.$fDataProduct5_closure" {
     Data.Functor.Product.$fDataProduct5_closure:
         const Data.Functor.Product.$fDataProduct5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fDataProduct5_entry() //  [R1]
         { info_tbl: [(cg6OV,
                       label: Data.Functor.Product.$fDataProduct5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6OV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6OW; else goto cg6OX;
       cg6OW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6OX: // global
           (_cg6OS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg6OS::I64 == 0) goto cg6OU; else goto cg6OT;
       cg6OU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg6OT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg6OS::I64;
           R2 = Data.Functor.Product.$fDataProduct6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.262096017 UTC

[section ""data" . go61_rg5o2_closure" {
     go61_rg5o2_closure:
         const go61_rg5o2_info;
         const 0;
 },
 go61_rg5o2_entry() //  [R2, R3]
         { info_tbl: [(cg6P9,
                       label: go61_rg5o2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6P9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6Pa; else goto ug6PN;
       cg6Pa: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rg5o2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ug6PN: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cg6OZ() args: 0, res: 0, upd: 0;
     }
 },
 _cg6OZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6OZ: // global
           _sg5FR::P64 = P64[Sp];
           I64[Sp] = block_cg6P2_info;
           R1 = _sg5FR::P64;
           if (R1 & 7 != 0) goto ug6PR; else goto cg6P3;
       ug6PR: // global
           call _cg6P2(R1) args: 0, res: 0, upd: 0;
       cg6P3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6P2() //  [R1]
         { info_tbl: [(cg6P2,
                       label: block_cg6P2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6P2: // global
           if (R1 & 7 == 1) goto ug6PO; else goto cg6P7;
       ug6PO: // global
           Sp = Sp + 16;
           call _cg6Pp() args: 0, res: 0, upd: 0;
       cg6P7: // global
           I64[Sp - 8] = block_cg6Ph_info;
           _sg5FU::P64 = P64[R1 + 6];
           _sg5FV::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sg5FV::P64;
           P64[Sp + 8] = _sg5FU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6PS; else goto cg6Pj;
       ug6PS: // global
           call _cg6Ph(R1) args: 0, res: 0, upd: 0;
       cg6Pj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Ph() //  [R1]
         { info_tbl: [(cg6Ph,
                       label: block_cg6Ph_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ph: // global
           if (R1 & 7 == 1) goto ug6PP; else goto cg6Pu;
       ug6PP: // global
           Sp = Sp + 24;
           call _cg6Pp() args: 0, res: 0, upd: 0;
       cg6Pu: // global
           I64[Sp - 8] = block_cg6Ps_info;
           _sg5FX::P64 = P64[R1 + 6];
           _sg5FY::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sg5FY::P64;
           P64[Sp + 16] = _sg5FX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6PV; else goto cg6Pv;
       ug6PV: // global
           call _cg6Ps(R1) args: 0, res: 0, upd: 0;
       cg6Pv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Pp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Pp: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg6Ps() //  [R1]
         { info_tbl: [(cg6Ps,
                       label: block_cg6Ps_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ps: // global
           I64[Sp] = block_cg6Pz_info;
           R3 = Data.Functor.Product.$fRead1Product2_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Pz() //  [R1]
         { info_tbl: [(cg6Pz,
                       label: block_cg6Pz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Pz: // global
           if (R1 & 7 == 1) goto cg6PG; else goto cg6PK;
       cg6PG: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cg6OZ() args: 0, res: 0, upd: 0;
       cg6PK: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.2643402 UTC

[section ""data" . $cPair1_rg5o3_closure" {
     $cPair1_rg5o3_closure:
         const Data.Data.AlgConstr_con_info;
         const $cPair2_rg5o4_closure;
         const 0;
 },
 section ""data" . Data.Functor.Product.$fDataProduct4_closure" {
     Data.Functor.Product.$fDataProduct4_closure:
         const :_con_info;
         const Data.Functor.Product.$cPair_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Product.$fDataProduct3_closure" {
     Data.Functor.Product.$fDataProduct3_closure:
         const Data.Data.AlgRep_con_info;
         const Data.Functor.Product.$fDataProduct4_closure+2;
         const 0;
 },
 section ""data" . Data.Functor.Product.$tProduct_closure" {
     Data.Functor.Product.$tProduct_closure:
         const Data.Data.DataType_con_info;
         const Data.Functor.Product.$fDataProduct5_closure;
         const Data.Functor.Product.$fDataProduct3_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Product.$cPair_closure" {
     Data.Functor.Product.$cPair_closure:
         const Data.Data.Constr_con_info;
         const $cPair1_rg5o3_closure+1;
         const Data.Functor.Product.$fRead1Product2_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Product.$tProduct_closure+1;
         const 0;
 },
 section ""data" . $cPair2_rg5o4_closure" {
     $cPair2_rg5o4_closure:
         const $cPair2_rg5o4_info;
         const 0;
         const 0;
         const 0;
 },
 $cPair2_rg5o4_entry() //  [R1]
         { info_tbl: [(cg6Q4,
                       label: $cPair2_rg5o4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Q4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Q5; else goto cg6Q6;
       cg6Q5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Q6: // global
           (_cg6Q1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg6Q1::I64 == 0) goto cg6Q3; else goto cg6Q2;
       cg6Q3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg6Q2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg6Q1::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = Data.Functor.Product.$fDataProduct4_closure+2;
           Sp = Sp - 16;
           call go61_rg5o2_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.265649558 UTC

[section ""cstring" . Data.Functor.Product.$trModule4_bytes" {
     Data.Functor.Product.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.266289116 UTC

[section ""data" . Data.Functor.Product.$trModule3_closure" {
     Data.Functor.Product.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.266884146 UTC

[section ""cstring" . Data.Functor.Product.$trModule2_bytes" {
     Data.Functor.Product.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.267505443 UTC

[section ""data" . Data.Functor.Product.$trModule1_closure" {
     Data.Functor.Product.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.268166025 UTC

[section ""data" . Data.Functor.Product.$trModule_closure" {
     Data.Functor.Product.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Product.$trModule3_closure+1;
         const Data.Functor.Product.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.26877576 UTC

[section ""data" . $krep_rg5o5_closure" {
     $krep_rg5o5_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.269435888 UTC

[section ""data" . $krep1_rg5o6_closure" {
     $krep1_rg5o6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rg5o5_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.270078928 UTC

[section ""data" . $krep2_rg5o7_closure" {
     $krep2_rg5o7_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rg5o6_closure+4;
         const $krep1_rg5o6_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.271828838 UTC

[section ""data" . Data.Functor.Product.$fDataProduct8_closure" {
     Data.Functor.Product.$fDataProduct8_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rg5o6_closure+4;
         const $krep2_rg5o7_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.272426185 UTC

[section ""data" . $krep3_rg5o8_closure" {
     $krep3_rg5o8_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.27297717 UTC

[section ""data" . $krep4_rg5o9_closure" {
     $krep4_rg5o9_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.273814841 UTC

[section ""data" . $krep5_rg5oa_closure" {
     $krep5_rg5oa_closure:
         const GHC.Types.KindRepVar_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.274423519 UTC

[section ""data" . $krep6_rg5ob_closure" {
     $krep6_rg5ob_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rg5o9_closure+2;
         const $krep5_rg5oa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.275020846 UTC

[section ""data" . $krep7_rg5oc_closure" {
     $krep7_rg5oc_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep3_rg5o8_closure+2;
         const $krep5_rg5oa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.275608565 UTC

[section ""data" . Data.Functor.Product.$fDataProduct9_closure" {
     Data.Functor.Product.$fDataProduct9_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$fDataProduct6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.276191904 UTC

[section ""data" . Data.Functor.Product.$tcProduct_closure" {
     Data.Functor.Product.$tcProduct_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Product.$trModule_closure+1;
         const Data.Functor.Product.$fDataProduct9_closure+1;
         const Data.Functor.Product.$fDataProduct8_closure+4;
         const 9904636435990105341;
         const 16069493191308336164;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.276826439 UTC

[section ""data" . $krep8_rg5od_closure" {
     $krep8_rg5od_closure:
         const :_con_info;
         const $krep5_rg5oa_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.277490356 UTC

[section ""data" . $krep9_rg5oe_closure" {
     $krep9_rg5oe_closure:
         const :_con_info;
         const $krep3_rg5o8_closure+2;
         const $krep8_rg5od_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.278125143 UTC

[section ""data" . $krep10_rg5of_closure" {
     $krep10_rg5of_closure:
         const :_con_info;
         const $krep4_rg5o9_closure+2;
         const $krep9_rg5oe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.278731746 UTC

[section ""data" . $krep11_rg5og_closure" {
     $krep11_rg5og_closure:
         const :_con_info;
         const $krep_rg5o5_closure+2;
         const $krep10_rg5of_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.27935314 UTC

[section ""data" . $krep12_rg5oh_closure" {
     $krep12_rg5oh_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Product.$tcProduct_closure+1;
         const $krep11_rg5og_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.279948541 UTC

[section ""data" . $krep13_rg5oi_closure" {
     $krep13_rg5oi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rg5oc_closure+3;
         const $krep12_rg5oh_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.280573728 UTC

[section ""data" . Data.Functor.Product.$tc'Pair1_closure" {
     Data.Functor.Product.$tc'Pair1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rg5ob_closure+3;
         const $krep13_rg5oi_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.281158345 UTC

[section ""cstring" . Data.Functor.Product.$tc'Pair3_bytes" {
     Data.Functor.Product.$tc'Pair3_bytes:
         I8[] [39,80,97,105,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.281812993 UTC

[section ""data" . Data.Functor.Product.$tc'Pair2_closure" {
     Data.Functor.Product.$tc'Pair2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$tc'Pair3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.282435949 UTC

[section ""data" . Data.Functor.Product.$tc'Pair_closure" {
     Data.Functor.Product.$tc'Pair_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Product.$trModule_closure+1;
         const Data.Functor.Product.$tc'Pair2_closure+1;
         const Data.Functor.Product.$tc'Pair1_closure+4;
         const 11374113252541295849;
         const 18011678063065699923;
         const 4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.283820734 UTC

[section ""data" . Data.Functor.Product.$w$cp1Data_closure" {
     Data.Functor.Product.$w$cp1Data_closure:
         const Data.Functor.Product.$w$cp1Data_info;
         const 0;
 },
 Data.Functor.Product.$w$cp1Data_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg6Qk,
                       label: Data.Functor.Product.$w$cp1Data_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Qk: // global
           _sg5G9::P64 = R5;
           _sg5G8::P64 = R4;
           _sg5G7::P64 = R3;
           _sg5G6::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cg6Qo; else goto cg6Qp;
       cg6Qp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg6Qr; else goto cg6Qq;
       cg6Qr: // global
           HpAlloc = 40;
           goto cg6Qo;
       cg6Qo: // global
           R5 = _sg5G9::P64;
           R4 = _sg5G8::P64;
           R3 = _sg5G7::P64;
           R2 = _sg5G6::P64;
           R1 = Data.Functor.Product.$w$cp1Data_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Qq: // global
           I64[Hp - 32] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 24] = _sg5G9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 32] = block_cg6Qd_info;
           R6 = 1;
           R5 = Data.Functor.Product.$fDataProduct9_closure+1;
           R4 = Data.Functor.Product.$trModule_closure+1;
           R3 = 16069493191308336164;
           R2 = 9904636435990105341;
           P64[Sp - 48] = Data.Functor.Product.$fDataProduct8_closure+4;
           P64[Sp - 40] = Hp - 14;
           P64[Sp - 24] = _sg5G6::P64;
           P64[Sp - 16] = _sg5G7::P64;
           P64[Sp - 8] = _sg5G8::P64;
           Sp = Sp - 48;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 8;
     }
 },
 _cg6Qd() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg6Qd,
                       label: block_cg6Qd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Qd: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cg6Qe() args: 0, res: 0, upd: 0;
     }
 },
 _cg6Qe() //  []
         { info_tbl: [(cg6Qe,
                       label: block_cg6Qe_info
                       rep:StackRep [True, False, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Qe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg6Qu; else goto cg6Qt;
       cg6Qu: // global
           HpAlloc = 48;
           I64[Sp] = block_cg6Qe_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cg6Qt: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 40] = block_cg6Qi_info;
           R3 = P64[Sp + 56];
           R2 = Hp - 38;
           Sp = Sp + 40;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Qi() //  [R1]
         { info_tbl: [(cg6Qi,
                       label: block_cg6Qi_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Qi: // global
           I64[Sp] = block_cg6Qn_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Qn() //  [R1]
         { info_tbl: [(cg6Qn,
                       label: block_cg6Qn_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Qn: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.286063056 UTC

[section ""data" . Data.Functor.Product.$fDataProduct7_closure" {
     Data.Functor.Product.$fDataProduct7_closure:
         const Data.Functor.Product.$fDataProduct7_info;
         const 0;
 },
 Data.Functor.Product.$fDataProduct7_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg6QG,
                       label: Data.Functor.Product.$fDataProduct7_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6QG: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Product.$w$cp1Data_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.286888387 UTC

[section ""data" . Data.Functor.Product.$fDataProduct1_closure" {
     Data.Functor.Product.$fDataProduct1_closure:
         const (,)_con_info;
         const Data.Functor.Product.Pair_closure+2;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.290186182 UTC

[section ""data" . Data.Functor.Product.$w$cgmapMp_closure" {
     Data.Functor.Product.$w$cgmapMp_closure:
         const Data.Functor.Product.$w$cgmapMp_info;
 },
 lvl9_sg5Gw_entry() //  [R1]
         { info_tbl: [(cg6QR,
                       label: lvl9_sg5Gw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6QR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6QS; else goto cg6QT;
       cg6QS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6QT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5H1_entry() //  [R1, R2]
         { info_tbl: [(cg6R6,
                       label: sat_sg5H1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6R6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6R7; else goto cg6R8;
       cg6R7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6R8: // global
           I64[Sp - 24] = block_cg6R3_info;
           _sg5Gw::P64 = P64[R1 + 7];
           _sg5Gx::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sg5Gw::P64;
           P64[Sp - 8] = _sg5Gx::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug6Rq; else goto cg6R4;
       ug6Rq: // global
           call _cg6R3(R1) args: 0, res: 0, upd: 0;
       cg6R4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6R3() //  [R1]
         { info_tbl: [(cg6R3,
                       label: block_cg6R3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6R3: // global
           I64[Sp - 8] = block_cg6Rb_info;
           _sg5GY::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sg5GY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6Rp; else goto cg6Rd;
       ug6Rp: // global
           call _cg6Rb(R1) args: 0, res: 0, upd: 0;
       cg6Rd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Rb() //  [R1]
         { info_tbl: [(cg6Rb,
                       label: block_cg6Rb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Rb: // global
           if (R1 & 7 == 1) goto cg6Rj; else goto cg6Rn;
       cg6Rj: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg6Rn: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5GR_entry() //  [R1]
         { info_tbl: [(cg6RW,
                       label: sat_sg5GR_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6RW: // global
           _sg5GR::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg6RX; else goto cg6RY;
       cg6RY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg6S0; else goto cg6RZ;
       cg6S0: // global
           HpAlloc = 56;
           goto cg6RX;
       cg6RX: // global
           R1 = _sg5GR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6RZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5GR::P64;
           _sg5Gx::P64 = P64[_sg5GR::P64 + 16];
           _sg5GE::P64 = P64[_sg5GR::P64 + 24];
           _sg5GI::P64 = P64[_sg5GR::P64 + 32];
           _sg5GJ::P64 = P64[_sg5GR::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5GI::P64;
           P64[Hp - 24] = _sg5GE::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sg5GJ::P64;
           R2 = _sg5Gx::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5GN_entry() //  [R1, R2]
         { info_tbl: [(cg6Sc,
                       label: sat_sg5GN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Sc: // global
           _sg5GK::P64 = R2;
           _sg5GN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Sd; else goto cg6Se;
       cg6Se: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg6Sg; else goto cg6Sf;
       cg6Sg: // global
           HpAlloc = 56;
           goto cg6Sd;
       cg6Sd: // global
           R2 = _sg5GK::P64;
           R1 = _sg5GN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6Sf: // global
           _sg5Gx::P64 = P64[_sg5GN::P64 + 7];
           _sg5GI::P64 = P64[_sg5GN::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5GI::P64;
           P64[Hp - 24] = _sg5GK::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sg5Gx::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5GO_entry() //  [R1]
         { info_tbl: [(cg6Sh,
                       label: sat_sg5GO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Sh: // global
           _sg5GO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6Si; else goto cg6Sj;
       cg6Sj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6Sl; else goto cg6Sk;
       cg6Sl: // global
           HpAlloc = 24;
           goto cg6Si;
       cg6Si: // global
           R1 = _sg5GO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Sk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5GO::P64;
           _sg5Gx::P64 = P64[_sg5GO::P64 + 16];
           _sg5GF::P64 = P64[_sg5GO::P64 + 24];
           _sg5GI::P64 = P64[_sg5GO::P64 + 32];
           I64[Hp - 16] = sat_sg5GN_info;
           P64[Hp - 8] = _sg5Gx::P64;
           P64[Hp] = _sg5GI::P64;
           R2 = _sg5Gx::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5GF::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5GS_entry() //  [R1, R2]
         { info_tbl: [(cg6Sm,
                       label: sat_sg5GS_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Sm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6Sn; else goto cg6So;
       cg6Sn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6So: // global
           I64[Sp - 40] = block_cg6RL_info;
           _sg5Gt::P64 = P64[R1 + 7];
           _sg5Gx::P64 = P64[R1 + 15];
           _sg5GE::P64 = P64[R1 + 23];
           _sg5GF::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5Gt::P64;
           P64[Sp - 24] = _sg5Gx::P64;
           P64[Sp - 16] = _sg5GE::P64;
           P64[Sp - 8] = _sg5GF::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6Ss; else goto cg6RM;
       ug6Ss: // global
           call _cg6RL(R1) args: 0, res: 0, upd: 0;
       cg6RM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6RL() //  [R1]
         { info_tbl: [(cg6RL,
                       label: block_cg6RL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6RL: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg6Sr; else goto cg6Sq;
       cg6Sr: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6Sq: // global
           _sg5GI::P64 = P64[R1 + 7];
           _sg5GJ::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sg5GR_info;
           _sg5Gx::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sg5Gx::P64;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _sg5GI::P64;
           P64[Hp - 40] = _sg5GJ::P64;
           I64[Hp - 32] = sat_sg5GO_info;
           P64[Hp - 16] = _sg5Gx::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sg5GI::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sg5GB_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6St,
                       label: k1_sg5GB_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6St: // global
           _sg5GE::P64 = R4;
           _sg5GD::P64 = R3;
           _sg5GC::P64 = R2;
           _sg5GB::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg6Su; else goto cg6Sv;
       cg6Sv: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg6Sx; else goto cg6Sw;
       cg6Sx: // global
           HpAlloc = 80;
           goto cg6Su;
       cg6Su: // global
           R4 = _sg5GE::P64;
           R3 = _sg5GD::P64;
           R2 = _sg5GC::P64;
           R1 = _sg5GB::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Sw: // global
           _sg5Gt::P64 = P64[_sg5GB::P64 + 5];
           _sg5Gu::P64 = P64[_sg5GB::P64 + 13];
           _sg5Gx::P64 = P64[_sg5GB::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sg5Gu::P64;
           P64[Hp - 48] = _sg5GC::P64;
           P64[Hp - 40] = _sg5GE::P64;
           I64[Hp - 32] = sat_sg5GS_info;
           P64[Hp - 24] = _sg5Gt::P64;
           P64[Hp - 16] = _sg5Gx::P64;
           P64[Hp - 8] = _sg5GE::P64;
           P64[Hp] = Hp - 72;
           R2 = _sg5Gx::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg5GD::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5GT_entry() //  [R1]
         { info_tbl: [(cg6SG,
                       label: sat_sg5GT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6SG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6SH; else goto cg6SI;
       cg6SH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6SI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Product.$fDataProduct1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5GU_entry() //  [R1]
         { info_tbl: [(cg6SJ,
                       label: sat_sg5GU_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6SJ: // global
           _sg5GU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6SK; else goto cg6SL;
       cg6SL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6SN; else goto cg6SM;
       cg6SN: // global
           HpAlloc = 24;
           goto cg6SK;
       cg6SK: // global
           R1 = _sg5GU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6SM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5GU::P64;
           _sg5Gr::P64 = P64[_sg5GU::P64 + 16];
           _sg5Gx::P64 = P64[_sg5GU::P64 + 24];
           _sg5Gz::P64 = P64[_sg5GU::P64 + 32];
           _sg5GB::P64 = P64[_sg5GU::P64 + 40];
           I64[Hp - 16] = sat_sg5GT_info;
           P64[Hp] = _sg5Gx::P64;
           R4 = _sg5Gz::P64;
           R3 = Hp - 16;
           R2 = _sg5Gr::P64;
           R1 = _sg5GB::P64;
           Sp = Sp - 16;
           call k1_sg5GB_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5GV_entry() //  [R1]
         { info_tbl: [(cg6SO,
                       label: sat_sg5GV_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6SO: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cg6SP; else goto cg6SQ;
       cg6SP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6SQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cg6Rv_info;
           _sg5Gr::P64 = P64[R1 + 16];
           _sg5Gs::P64 = P64[R1 + 24];
           _sg5Gt::P64 = P64[R1 + 32];
           _sg5Gu::P64 = P64[R1 + 40];
           _sg5Gx::P64 = P64[R1 + 56];
           R1 = P64[R1 + 48];
           P64[Sp - 56] = _sg5Gr::P64;
           P64[Sp - 48] = _sg5Gs::P64;
           P64[Sp - 40] = _sg5Gt::P64;
           P64[Sp - 32] = _sg5Gu::P64;
           P64[Sp - 24] = _sg5Gx::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ug6SU; else goto cg6Rw;
       ug6SU: // global
           call _cg6Rv(R1) args: 0, res: 0, upd: 0;
       cg6Rw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg6Rv() //  [R1]
         { info_tbl: [(cg6Rv,
                       label: block_cg6Rv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Rv: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg6ST; else goto cg6SS;
       cg6ST: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg6SS: // global
           _sg5Gz::P64 = P64[R1 + 7];
           _sg5GA::P64 = P64[R1 + 15];
           I64[Hp - 72] = k1_sg5GB_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = P64[Sp + 32];
           _sg5Gx::P64 = P64[Sp + 40];
           P64[Hp - 48] = _sg5Gx::P64;
           I64[Hp - 40] = sat_sg5GU_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sg5Gx::P64;
           P64[Hp - 8] = _sg5Gz::P64;
           _cg6RA::P64 = Hp - 69;
           P64[Hp] = _cg6RA::P64;
           R4 = _sg5GA::P64;
           R3 = Hp - 40;
           R2 = P64[Sp + 16];
           R1 = _cg6RA::P64;
           Sp = Sp + 48;
           call k1_sg5GB_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cgmapMp_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg6SV,
                       label: Data.Functor.Product.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6SV: // global
           _sg5Gv::P64 = R6;
           _sg5Gu::P64 = R5;
           _sg5Gt::P64 = R4;
           _sg5Gs::P64 = R3;
           _sg5Gr::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg6SW; else goto cg6SX;
       cg6SX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6SZ; else goto cg6SY;
       cg6SZ: // global
           HpAlloc = 24;
           goto cg6SW;
       cg6SW: // global
           R6 = _sg5Gv::P64;
           R5 = _sg5Gu::P64;
           R4 = _sg5Gt::P64;
           R3 = _sg5Gs::P64;
           R2 = _sg5Gr::P64;
           R1 = Data.Functor.Product.$w$cgmapMp_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6SY: // global
           I64[Hp - 16] = lvl9_sg5Gw_info;
           P64[Hp] = _sg5Gt::P64;
           I64[Sp - 56] = block_cg6QU_info;
           R2 = _sg5Gt::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sg5Gr::P64;
           P64[Sp - 32] = _sg5Gs::P64;
           P64[Sp - 24] = _sg5Gt::P64;
           P64[Sp - 16] = _sg5Gu::P64;
           P64[Sp - 8] = _sg5Gv::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg6QU() //  [R1]
         { info_tbl: [(cg6QU,
                       label: block_cg6QU_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6QU: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg6T2; else goto cg6T1;
       cg6T2: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6T1: // global
           I64[Hp - 80] = sat_sg5H1_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sg5GV_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.297629116 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapMp_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapMp_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapMp_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapMp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6T4: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapMp_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapMp_entry() //  [R6]
         { info_tbl: [(cg6T8,
                       label: Data.Functor.Product.$fDataProduct_$cgmapMp_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6T8: // global
           _sg5H6::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sg5H6::P64;
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cgmapMp_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.299862319 UTC

[section ""data" . Data.Functor.Product.$w$cgmapM_closure" {
     Data.Functor.Product.$w$cgmapM_closure:
         const Data.Functor.Product.$w$cgmapM_info;
 },
 sat_sg5Hp_entry() //  [R1, R2]
         { info_tbl: [(cg6Tw,
                       label: sat_sg5Hp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Tw: // global
           _sg5Hn::P64 = R2;
           _sg5Hp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Tx; else goto cg6Ty;
       cg6Ty: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg6TA; else goto cg6Tz;
       cg6TA: // global
           HpAlloc = 32;
           goto cg6Tx;
       cg6Tx: // global
           R2 = _sg5Hn::P64;
           R1 = _sg5Hp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6Tz: // global
           _sg5Hd::P64 = P64[_sg5Hp::P64 + 7];
           _sg5Hm::P64 = P64[_sg5Hp::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sg5Hm::P64;
           P64[Hp] = _sg5Hn::P64;
           R2 = _sg5Hd::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5Hq_entry() //  [R1, R2]
         { info_tbl: [(cg6TB,
                       label: sat_sg5Hq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6TB: // global
           _sg5Hm::P64 = R2;
           _sg5Hq::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg6TC; else goto cg6TD;
       cg6TD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6TF; else goto cg6TE;
       cg6TF: // global
           HpAlloc = 24;
           goto cg6TC;
       cg6TC: // global
           R2 = _sg5Hm::P64;
           R1 = _sg5Hq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6TE: // global
           _sg5Hd::P64 = P64[_sg5Hq::P64 + 7];
           _sg5Hl::P64 = P64[_sg5Hq::P64 + 15];
           I64[Hp - 16] = sat_sg5Hp_info;
           P64[Hp - 8] = _sg5Hd::P64;
           P64[Hp] = _sg5Hm::P64;
           R2 = _sg5Hd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg5Hl::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sg5Hh_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6TG,
                       label: k1_sg5Hh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6TG: // global
           _sg5Hk::P64 = R4;
           _sg5Hj::P64 = R3;
           _sg5Hi::P64 = R2;
           _sg5Hh::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg6TH; else goto cg6TI;
       cg6TI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg6TK; else goto cg6TJ;
       cg6TK: // global
           HpAlloc = 64;
           goto cg6TH;
       cg6TH: // global
           R4 = _sg5Hk::P64;
           R3 = _sg5Hj::P64;
           R2 = _sg5Hi::P64;
           R1 = _sg5Hh::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6TJ: // global
           _sg5Hd::P64 = P64[_sg5Hh::P64 + 5];
           _sg5He::P64 = P64[_sg5Hh::P64 + 13];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sg5He::P64;
           P64[Hp - 32] = _sg5Hi::P64;
           P64[Hp - 24] = _sg5Hk::P64;
           I64[Hp - 16] = sat_sg5Hq_info;
           P64[Hp - 8] = _sg5Hd::P64;
           P64[Hp] = Hp - 56;
           R2 = _sg5Hd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg5Hj::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5Hr_entry() //  [R1]
         { info_tbl: [(cg6TT,
                       label: sat_sg5Hr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6TT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6TU; else goto cg6TV;
       cg6TU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6TV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Product.Pair_closure+2;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5Hs_entry() //  [R1]
         { info_tbl: [(cg6TW,
                       label: sat_sg5Hs_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6TW: // global
           _sg5Hs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6TX; else goto cg6TY;
       cg6TY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6U0; else goto cg6TZ;
       cg6U0: // global
           HpAlloc = 24;
           goto cg6TX;
       cg6TX: // global
           R1 = _sg5Hs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6TZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Hs::P64;
           _sg5Hb::P64 = P64[_sg5Hs::P64 + 16];
           _sg5Hd::P64 = P64[_sg5Hs::P64 + 24];
           _sg5Hf::P64 = P64[_sg5Hs::P64 + 32];
           _sg5Hh::P64 = P64[_sg5Hs::P64 + 40];
           I64[Hp - 16] = sat_sg5Hr_info;
           P64[Hp] = _sg5Hd::P64;
           R4 = _sg5Hf::P64;
           R3 = Hp - 16;
           R2 = _sg5Hb::P64;
           R1 = _sg5Hh::P64;
           Sp = Sp - 16;
           call k1_sg5Hh_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cgmapM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg6U1,
                       label: Data.Functor.Product.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6U1: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg6U5; else goto cg6U4;
       cg6U5: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$cgmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg6U4: // global
           I64[Hp - 64] = k1_sg5Hh_info;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           I64[Hp - 40] = sat_sg5Hs_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R6;
           _cg6Tf::P64 = Hp - 61;
           P64[Hp] = _cg6Tf::P64;
           R4 = P64[Sp];
           _sg5Hc::P64 = R3;
           R3 = Hp - 40;
           R2 = _sg5Hc::P64;
           R1 = _cg6Tf::P64;
           Sp = Sp + 8;
           call k1_sg5Hh_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.304171536 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapM_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapM_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapM_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapM_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6U7: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapM_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2,
                                                                 R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapM_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cg6Ue,
                       label: Data.Functor.Product.$fDataProduct_$cgmapM_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ue: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6Uf; else goto cg6Ug;
       cg6Uf: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgmapM_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cg6Ug: // global
           I64[Sp - 8] = block_cg6Ub_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6Uk; else goto cg6Uc;
       ug6Uk: // global
           call _cg6Ub(R1) args: 0, res: 0, upd: 0;
       cg6Uc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Ub() //  [R1]
         { info_tbl: [(cg6Ub,
                       label: block_cg6Ub_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ub: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cgmapM_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.306072109 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapQi_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapQi_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapQi_info;
         const 0;
 },
 Data.Functor.Product.$fDataProduct_$cgmapQi_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Um: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapQi_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapQi_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cg6Ut,
                       label: Data.Functor.Product.$fDataProduct_$cgmapQi_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Ut: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Ux; else goto cg6Uy;
       cg6Ux: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgmapQi_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cg6Uy: // global
           I64[Sp - 8] = block_cg6Uq_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6UM; else goto cg6Ur;
       ug6UM: // global
           call _cg6Uq(R1) args: 0, res: 0, upd: 0;
       cg6Ur: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Uq() //  [R1]
         { info_tbl: [(cg6Uq,
                       label: block_cg6Uq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Uq: // global
           I64[Sp - 8] = block_cg6Uw_info;
           _sg5HP::P64 = P64[R1 + 7];
           _sg5HQ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sg5HQ::P64;
           P64[Sp + 16] = _sg5HP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6UL; else goto cg6UA;
       ug6UL: // global
           call _cg6Uw(R1) args: 0, res: 0, upd: 0;
       cg6UA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Uw() //  [R1]
         { info_tbl: [(cg6Uw,
                       label: block_cg6Uw_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Uw: // global
           _sg5HM::P64 = P64[Sp + 32];
           _sg5HT::I64 = I64[R1 + 7];
           if (_sg5HT::I64 != 0) goto ug6UK; else goto cg6UI;
       ug6UK: // global
           if (_sg5HT::I64 != 1) goto cg6UH; else goto cg6UJ;
       cg6UH: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg6UJ: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           R1 = _sg5HM::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6UI: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 40];
           R1 = _sg5HM::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.308488274 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapQr_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapQr_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapQr_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapQr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6UO: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapQr_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg5I9_entry() //  [R1]
         { info_tbl: [(cg6V2,
                       label: sat_sg5I9_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6V2: // global
           _sg5I9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6V3; else goto cg6V4;
       cg6V4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg6V6; else goto cg6V5;
       cg6V6: // global
           HpAlloc = 40;
           goto cg6V3;
       cg6V3: // global
           R1 = _sg5I9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6V5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5I9::P64;
           _sg5HZ::P64 = P64[_sg5I9::P64 + 16];
           _sg5I0::P64 = P64[_sg5I9::P64 + 24];
           _sg5I1::P64 = P64[_sg5I9::P64 + 32];
           _sg5I2::P64 = P64[_sg5I9::P64 + 40];
           _sg5I6::P64 = P64[_sg5I9::P64 + 48];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg5I2::P64;
           P64[Hp - 8] = _sg5HZ::P64;
           P64[Hp] = _sg5I6::P64;
           R3 = _sg5I1::P64;
           R2 = Hp - 32;
           R1 = _sg5I0::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapQr_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cg6V7,
                       label: Data.Functor.Product.$fDataProduct_$cgmapQr_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6V7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6V9; else goto cg6Va;
       cg6V9: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgmapQr_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cg6Va: // global
           I64[Sp - 8] = block_cg6US_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6Ve; else goto cg6UT;
       ug6Ve: // global
           call _cg6US(R1) args: 0, res: 0, upd: 0;
       cg6UT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6US() //  [R1]
         { info_tbl: [(cg6US,
                       label: block_cg6US_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6US: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cg6Vd; else goto cg6Vc;
       cg6Vd: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6Vc: // global
           _sg5I5::P64 = P64[R1 + 7];
           _sg5I6::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_sg5I9_info;
           P64[Hp - 72] = P64[Sp + 8];
           _sg5I0::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sg5I0::P64;
           P64[Hp - 56] = P64[Sp + 24];
           _sg5I2::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sg5I2::P64;
           P64[Hp - 40] = _sg5I6::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg5I2::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sg5I5::P64;
           R3 = Hp - 88;
           R2 = Hp - 32;
           R1 = _sg5I0::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.311313606 UTC

[section ""data" . Data.Functor.Product.$fDataProduct2_closure" {
     Data.Functor.Product.$fDataProduct2_closure:
         const Data.Functor.Product.$fDataProduct2_info;
 },
 Data.Functor.Product.$fDataProduct2_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Vg: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct2_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg5Io_entry() //  [R1]
         { info_tbl: [(cg6Vv,
                       label: sat_sg5Io_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Vv: // global
           _sg5Io::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Vw; else goto cg6Vx;
       cg6Vx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg6Vz; else goto cg6Vy;
       cg6Vz: // global
           HpAlloc = 40;
           goto cg6Vw;
       cg6Vw: // global
           R1 = _sg5Io::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Vy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Io::P64;
           _sg5Ie::P64 = P64[_sg5Io::P64 + 16];
           _sg5Ig::P64 = P64[_sg5Io::P64 + 24];
           _sg5Ih::P64 = P64[_sg5Io::P64 + 32];
           _sg5Ii::P64 = P64[_sg5Io::P64 + 40];
           _sg5Il::P64 = P64[_sg5Io::P64 + 48];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg5Ii::P64;
           P64[Hp - 8] = _sg5Ie::P64;
           P64[Hp] = _sg5Il::P64;
           R3 = Hp - 32;
           R2 = _sg5Ih::P64;
           R1 = _sg5Ig::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct2_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg6VA,
                       label: Data.Functor.Product.$fDataProduct2_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6VA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6VB; else goto cg6VC;
       cg6VB: // global
           R1 = Data.Functor.Product.$fDataProduct2_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cg6VC: // global
           I64[Sp - 8] = block_cg6Vk_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6VG; else goto cg6Vl;
       ug6VG: // global
           call _cg6Vk(R1) args: 0, res: 0, upd: 0;
       cg6Vl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Vk() //  [R1]
         { info_tbl: [(cg6Vk,
                       label: block_cg6Vk_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Vk: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cg6VF; else goto cg6VE;
       cg6VF: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6VE: // global
           _sg5Il::P64 = P64[R1 + 7];
           _sg5Im::P64 = P64[R1 + 15];
           I64[Hp - 88] = stg_ap_3_upd_info;
           _sg5Ii::P64 = P64[Sp + 32];
           P64[Hp - 72] = _sg5Ii::P64;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sg5Im::P64;
           I64[Hp - 48] = sat_sg5Io_info;
           P64[Hp - 32] = P64[Sp + 40];
           _sg5Ig::P64 = P64[Sp + 16];
           P64[Hp - 24] = _sg5Ig::P64;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sg5Ii::P64;
           P64[Hp] = _sg5Il::P64;
           R3 = Hp - 88;
           R2 = Hp - 48;
           R1 = _sg5Ig::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.316068514 UTC

[section ""data" . Data.Functor.Product.$w$cgmapMo_closure" {
     Data.Functor.Product.$w$cgmapMo_closure:
         const Data.Functor.Product.$w$cgmapMo_info;
 },
 lvl9_sg5Iv_entry() //  [R1]
         { info_tbl: [(cg6VP,
                       label: lvl9_sg5Iv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6VP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg6VQ; else goto cg6VR;
       cg6VQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6VR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5J3_entry() //  [R1, R2]
         { info_tbl: [(cg6W4,
                       label: sat_sg5J3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6W4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6W5; else goto cg6W6;
       cg6W5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6W6: // global
           I64[Sp - 24] = block_cg6W1_info;
           _sg5Iv::P64 = P64[R1 + 7];
           _sg5Iw::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sg5Iv::P64;
           P64[Sp - 8] = _sg5Iw::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug6Wo; else goto cg6W2;
       ug6Wo: // global
           call _cg6W1(R1) args: 0, res: 0, upd: 0;
       cg6W2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6W1() //  [R1]
         { info_tbl: [(cg6W1,
                       label: block_cg6W1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6W1: // global
           I64[Sp - 8] = block_cg6W9_info;
           _sg5J0::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sg5J0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6Wn; else goto cg6Wb;
       ug6Wn: // global
           call _cg6W9(R1) args: 0, res: 0, upd: 0;
       cg6Wb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6W9() //  [R1]
         { info_tbl: [(cg6W9,
                       label: block_cg6W9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6W9: // global
           if (R1 & 7 == 1) goto cg6Wh; else goto cg6Wl;
       cg6Wh: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg6Wl: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5IR_entry() //  [R1]
         { info_tbl: [(cg6WZ,
                       label: sat_sg5IR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6WZ: // global
           _sg5IR::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg6X0; else goto cg6X1;
       cg6X1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg6X3; else goto cg6X2;
       cg6X3: // global
           HpAlloc = 56;
           goto cg6X0;
       cg6X0: // global
           R1 = _sg5IR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6X2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5IR::P64;
           _sg5Iw::P64 = P64[_sg5IR::P64 + 16];
           _sg5ID::P64 = P64[_sg5IR::P64 + 24];
           _sg5IH::P64 = P64[_sg5IR::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5IH::P64;
           P64[Hp - 24] = _sg5ID::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sg5Iw::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5IN_entry() //  [R1, R2]
         { info_tbl: [(cg6Xf,
                       label: sat_sg5IN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Xf: // global
           _sg5IK::P64 = R2;
           _sg5IN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Xg; else goto cg6Xh;
       cg6Xh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg6Xj; else goto cg6Xi;
       cg6Xj: // global
           HpAlloc = 56;
           goto cg6Xg;
       cg6Xg: // global
           R2 = _sg5IK::P64;
           R1 = _sg5IN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6Xi: // global
           _sg5Iw::P64 = P64[_sg5IN::P64 + 7];
           _sg5IH::P64 = P64[_sg5IN::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5IH::P64;
           P64[Hp - 24] = _sg5IK::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sg5Iw::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5IO_entry() //  [R1]
         { info_tbl: [(cg6Xk,
                       label: sat_sg5IO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Xk: // global
           _sg5IO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg6Xl; else goto cg6Xm;
       cg6Xm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6Xo; else goto cg6Xn;
       cg6Xo: // global
           HpAlloc = 24;
           goto cg6Xl;
       cg6Xl: // global
           R1 = _sg5IO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Xn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5IO::P64;
           _sg5Iw::P64 = P64[_sg5IO::P64 + 16];
           _sg5IE::P64 = P64[_sg5IO::P64 + 24];
           _sg5IH::P64 = P64[_sg5IO::P64 + 32];
           I64[Hp - 16] = sat_sg5IN_info;
           P64[Hp - 8] = _sg5Iw::P64;
           P64[Hp] = _sg5IH::P64;
           R2 = _sg5Iw::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5IE::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5IU_entry() //  [R1, R2]
         { info_tbl: [(cg6Xp,
                       label: sat_sg5IU_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Xp: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg6Xq; else goto cg6Xr;
       cg6Xq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6Xr: // global
           I64[Sp - 40] = block_cg6WJ_info;
           _sg5Is::P64 = P64[R1 + 7];
           _sg5Iw::P64 = P64[R1 + 15];
           _sg5ID::P64 = P64[R1 + 23];
           _sg5IE::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5Is::P64;
           P64[Sp - 24] = _sg5Iw::P64;
           P64[Sp - 16] = _sg5ID::P64;
           P64[Sp - 8] = _sg5IE::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug6XI; else goto cg6WK;
       ug6XI: // global
           call _cg6WJ(R1) args: 0, res: 0, upd: 0;
       cg6WK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6WJ() //  [R1]
         { info_tbl: [(cg6WJ,
                       label: block_cg6WJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6WJ: // global
           I64[Sp - 8] = block_cg6WO_info;
           _sg5IH::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sg5IH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6XH; else goto cg6WP;
       ug6XH: // global
           call _cg6WO(R1) args: 0, res: 0, upd: 0;
       cg6WP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6WO() //  [R1]
         { info_tbl: [(cg6WO,
                       label: block_cg6WO_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6WO: // global
           _sg5Iw::P64 = P64[Sp + 24];
           _sg5ID::P64 = P64[Sp + 32];
           _sg5IH::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cg6Xu; else goto cg6Xy;
       cg6Xu: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg6Xx; else goto cg6Xw;
       cg6Xx: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6Xw: // global
           I64[Hp - 72] = sat_sg5IR_info;
           P64[Hp - 56] = _sg5Iw::P64;
           P64[Hp - 48] = _sg5ID::P64;
           P64[Hp - 40] = _sg5IH::P64;
           I64[Hp - 32] = sat_sg5IO_info;
           P64[Hp - 16] = _sg5Iw::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sg5IH::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cg6Xy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg6XD; else goto cg6XC;
       cg6XD: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6XC: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5IH::P64;
           P64[Hp - 24] = _sg5ID::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sg5Iw::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 k1_sg5IA_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6XJ,
                       label: k1_sg5IA_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6XJ: // global
           _sg5ID::P64 = R4;
           _sg5IC::P64 = R3;
           _sg5IB::P64 = R2;
           _sg5IA::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg6XK; else goto cg6XL;
       cg6XL: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg6XN; else goto cg6XM;
       cg6XN: // global
           HpAlloc = 80;
           goto cg6XK;
       cg6XK: // global
           R4 = _sg5ID::P64;
           R3 = _sg5IC::P64;
           R2 = _sg5IB::P64;
           R1 = _sg5IA::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6XM: // global
           _sg5Is::P64 = P64[_sg5IA::P64 + 5];
           _sg5It::P64 = P64[_sg5IA::P64 + 13];
           _sg5Iw::P64 = P64[_sg5IA::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sg5It::P64;
           P64[Hp - 48] = _sg5IB::P64;
           P64[Hp - 40] = _sg5ID::P64;
           I64[Hp - 32] = sat_sg5IU_info;
           P64[Hp - 24] = _sg5Is::P64;
           P64[Hp - 16] = _sg5Iw::P64;
           P64[Hp - 8] = _sg5ID::P64;
           P64[Hp] = Hp - 72;
           R2 = _sg5Iw::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg5IC::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5IV_entry() //  [R1]
         { info_tbl: [(cg6XW,
                       label: sat_sg5IV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6XW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6XX; else goto cg6XY;
       cg6XX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6XY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Product.$fDataProduct1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5IW_entry() //  [R1]
         { info_tbl: [(cg6XZ,
                       label: sat_sg5IW_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6XZ: // global
           _sg5IW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg6Y0; else goto cg6Y1;
       cg6Y1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6Y3; else goto cg6Y2;
       cg6Y3: // global
           HpAlloc = 24;
           goto cg6Y0;
       cg6Y0: // global
           R1 = _sg5IW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Y2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5IW::P64;
           _sg5Iq::P64 = P64[_sg5IW::P64 + 16];
           _sg5Iw::P64 = P64[_sg5IW::P64 + 24];
           _sg5Iy::P64 = P64[_sg5IW::P64 + 32];
           _sg5IA::P64 = P64[_sg5IW::P64 + 40];
           I64[Hp - 16] = sat_sg5IV_info;
           P64[Hp] = _sg5Iw::P64;
           R4 = _sg5Iy::P64;
           R3 = Hp - 16;
           R2 = _sg5Iq::P64;
           R1 = _sg5IA::P64;
           Sp = Sp - 16;
           call k1_sg5IA_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5IX_entry() //  [R1]
         { info_tbl: [(cg6Y4,
                       label: sat_sg5IX_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Y4: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cg6Y5; else goto cg6Y6;
       cg6Y5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6Y6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cg6Wt_info;
           _sg5Iq::P64 = P64[R1 + 16];
           _sg5Ir::P64 = P64[R1 + 24];
           _sg5Is::P64 = P64[R1 + 32];
           _sg5It::P64 = P64[R1 + 40];
           _sg5Iw::P64 = P64[R1 + 56];
           R1 = P64[R1 + 48];
           P64[Sp - 56] = _sg5Iq::P64;
           P64[Sp - 48] = _sg5Ir::P64;
           P64[Sp - 40] = _sg5Is::P64;
           P64[Sp - 32] = _sg5It::P64;
           P64[Sp - 24] = _sg5Iw::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ug6Ya; else goto cg6Wu;
       ug6Ya: // global
           call _cg6Wt(R1) args: 0, res: 0, upd: 0;
       cg6Wu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg6Wt() //  [R1]
         { info_tbl: [(cg6Wt,
                       label: block_cg6Wt_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Wt: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg6Y9; else goto cg6Y8;
       cg6Y9: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg6Y8: // global
           _sg5Iy::P64 = P64[R1 + 7];
           _sg5Iz::P64 = P64[R1 + 15];
           I64[Hp - 72] = k1_sg5IA_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = P64[Sp + 32];
           _sg5Iw::P64 = P64[Sp + 40];
           P64[Hp - 48] = _sg5Iw::P64;
           I64[Hp - 40] = sat_sg5IW_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sg5Iw::P64;
           P64[Hp - 8] = _sg5Iy::P64;
           _cg6Wy::P64 = Hp - 69;
           P64[Hp] = _cg6Wy::P64;
           R4 = _sg5Iz::P64;
           R3 = Hp - 40;
           R2 = P64[Sp + 16];
           R1 = _cg6Wy::P64;
           Sp = Sp + 48;
           call k1_sg5IA_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cgmapMo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg6Yb,
                       label: Data.Functor.Product.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Yb: // global
           _sg5Iu::P64 = R6;
           _sg5It::P64 = R5;
           _sg5Is::P64 = R4;
           _sg5Ir::P64 = R3;
           _sg5Iq::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg6Yc; else goto cg6Yd;
       cg6Yd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg6Yf; else goto cg6Ye;
       cg6Yf: // global
           HpAlloc = 24;
           goto cg6Yc;
       cg6Yc: // global
           R6 = _sg5Iu::P64;
           R5 = _sg5It::P64;
           R4 = _sg5Is::P64;
           R3 = _sg5Ir::P64;
           R2 = _sg5Iq::P64;
           R1 = Data.Functor.Product.$w$cgmapMo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Ye: // global
           I64[Hp - 16] = lvl9_sg5Iv_info;
           P64[Hp] = _sg5Is::P64;
           I64[Sp - 56] = block_cg6VS_info;
           R2 = _sg5Is::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sg5Iq::P64;
           P64[Sp - 32] = _sg5Ir::P64;
           P64[Sp - 24] = _sg5Is::P64;
           P64[Sp - 16] = _sg5It::P64;
           P64[Sp - 8] = _sg5Iu::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg6VS() //  [R1]
         { info_tbl: [(cg6VS,
                       label: block_cg6VS_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6VS: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg6Yi; else goto cg6Yh;
       cg6Yi: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6Yh: // global
           I64[Hp - 80] = sat_sg5J3_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sg5IX_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.323220366 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapMo_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapMo_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapMo_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapMo_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Yk: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapMo_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapMo_entry() //  [R6]
         { info_tbl: [(cg6Yo,
                       label: Data.Functor.Product.$fDataProduct_$cgmapMo_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Yo: // global
           _sg5J8::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sg5J8::P64;
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cgmapMo_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.324440678 UTC

[section ""data" . lvl5_rg5oj_closure" {
     lvl5_rg5oj_closure:
         const lvl5_rg5oj_info;
         const 0;
 },
 lvl5_rg5oj_entry() //  [R2]
         { info_tbl: [(cg6Yy,
                       label: lvl5_rg5oj_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Yy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg6Yz; else goto cg6YA;
       cg6Yz: // global
           R2 = R2;
           R1 = lvl5_rg5oj_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg6YA: // global
           I64[Sp - 8] = block_cg6Yv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug6YE; else goto cg6Yw;
       ug6YE: // global
           call _cg6Yv() args: 0, res: 0, upd: 0;
       cg6Yw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6Yv() //  []
         { info_tbl: [(cg6Yv,
                       label: block_cg6Yv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Yv: // global
           R1 = Data.Functor.Product.$cPair_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.325626251 UTC

[section ""data" . lvl6_rg5ok_closure" {
     lvl6_rg5ok_closure:
         const lvl6_rg5ok_info;
         const 0;
 },
 lvl6_rg5ok_entry() //  []
         { info_tbl: [(cg6YJ,
                       label: lvl6_rg5ok_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6YJ: // global
           R1 = Data.Functor.Product.$tProduct_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.326484212 UTC

[section ""data" . lvl7_rg5ol_closure" {
     lvl7_rg5ol_closure:
         const lvl7_rg5ol_info;
 },
 lvl7_rg5ol_entry() //  []
         { info_tbl: [(cg6YQ,
                       label: lvl7_rg5ol_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6YQ: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.327358716 UTC

[section ""data" . lvl8_rg5om_closure" {
     lvl8_rg5om_closure:
         const lvl8_rg5om_info;
 },
 lvl8_rg5om_entry() //  []
         { info_tbl: [(cg6YX,
                       label: lvl8_rg5om_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6YX: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.331300744 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_closure" {
     Data.Functor.Product.$fDataProduct_closure:
         const Data.Functor.Product.$fDataProduct_info;
         const 0;
 },
 sat_sg5K2_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6Z9,
                       label: sat_sg5K2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Z9: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$w$cgmapMo_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5JY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6Zh,
                       label: sat_sg5JY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Zh: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$w$cgmapMp_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5JU_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6Zp,
                       label: sat_sg5JU_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Zp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6Zq; else goto cg6Zr;
       cg6Zq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Zr: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Product.$fDataProduct_$cgmapM_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg5JT_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg6Zx,
                       label: sat_sg5JT_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Zx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6Zy; else goto cg6Zz;
       cg6Zy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6Zz: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Product.$fDataProduct_$cgmapQi_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg5JS_entry() //  [R1, R2, R3]
         { info_tbl: [(cg6ZI,
                       label: sat_sg5JS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ZI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg6ZP; else goto cg6ZQ;
       cg6ZP: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg6ZQ: // global
           I64[Sp - 32] = block_cg6ZF_info;
           _sg5Jq::P64 = P64[R1 + 6];
           _sg5Jr::P64 = P64[R1 + 14];
           R1 = R3;
           P64[Sp - 24] = _sg5Jq::P64;
           P64[Sp - 16] = _sg5Jr::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug6ZU; else goto cg6ZG;
       ug6ZU: // global
           call _cg6ZF(R1) args: 0, res: 0, upd: 0;
       cg6ZG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6ZF() //  [R1]
         { info_tbl: [(cg6ZF,
                       label: block_cg6ZF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6ZF: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg6ZT; else goto cg6ZS;
       cg6ZT: // global
           HpAlloc = 128;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg6ZS: // global
           _sg5JN::P64 = P64[R1 + 7];
           _sg5JO::P64 = P64[R1 + 15];
           I64[Hp - 120] = stg_ap_3_upd_info;
           _sg5JK::P64 = P64[Sp + 24];
           P64[Hp - 104] = _sg5JK::P64;
           P64[Hp - 96] = P64[Sp + 16];
           P64[Hp - 88] = _sg5JO::P64;
           I64[Hp - 80] = :_con_info;
           P64[Hp - 72] = Hp - 120;
           P64[Hp - 64] = GHC.Types.[]_closure+1;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sg5JK::P64;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg5JN::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 78;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5JJ_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg700,
                       label: sat_sg5JJ_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg700: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg701; else goto cg702;
       cg701: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg702: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Product.$fDataProduct_$cgmapQr_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg5JI_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg708,
                       label: sat_sg5JI_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg708: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg709; else goto cg70a;
       cg709: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg70a: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Product.$fDataProduct2_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg5JH_entry() //  [R1, R2, R3]
         { info_tbl: [(cg70j,
                       label: sat_sg5JH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg70j: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg70p; else goto cg70q;
       cg70p: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg70q: // global
           I64[Sp - 32] = block_cg70g_info;
           _sg5Jq::P64 = P64[R1 + 6];
           _sg5Jr::P64 = P64[R1 + 14];
           R1 = R3;
           P64[Sp - 24] = _sg5Jq::P64;
           P64[Sp - 16] = _sg5Jr::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug70u; else goto cg70h;
       ug70u: // global
           call _cg70g(R1) args: 0, res: 0, upd: 0;
       cg70h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg70g() //  [R1]
         { info_tbl: [(cg70g,
                       label: block_cg70g_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg70g: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg70t; else goto cg70s;
       cg70t: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg70s: // global
           _sg5JD::P64 = P64[R1 + 7];
           _sg5JE::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           _sg5JA::P64 = P64[Sp + 24];
           P64[Hp - 80] = _sg5JA::P64;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sg5JE::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sg5JA::P64;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg5JD::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Jx_entry() //  [R1]
         { info_tbl: [(cg70I,
                       label: sat_sg5Jx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg70I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg70J; else goto cg70K;
       cg70J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg70K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Product.Pair_closure+2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Jy_entry() //  [R1]
         { info_tbl: [(cg70L,
                       label: sat_sg5Jy_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg70L: // global
           _sg5Jy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg70M; else goto cg70N;
       cg70N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg70P; else goto cg70O;
       cg70P: // global
           HpAlloc = 24;
           goto cg70M;
       cg70M: // global
           R1 = _sg5Jy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg70O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Jy::P64;
           _sg5Jq::P64 = P64[_sg5Jy::P64 + 16];
           _sg5Ju::P64 = P64[_sg5Jy::P64 + 24];
           _sg5Jv::P64 = P64[_sg5Jy::P64 + 32];
           I64[Hp - 16] = sat_sg5Jx_info;
           P64[Hp] = _sg5Jv::P64;
           R3 = Hp - 16;
           R2 = _sg5Jq::P64;
           R1 = _sg5Ju::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Jz_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg70Q,
                       label: sat_sg5Jz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg70Q: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg70U; else goto cg70T;
       cg70U: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg70T: // global
           _sg5Jq::P64 = P64[R1 + 5];
           _sg5Jr::P64 = P64[R1 + 13];
           I64[Hp - 32] = sat_sg5Jy_info;
           P64[Hp - 16] = _sg5Jq::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 32;
           _sg5Ju::P64 = R2;
           R2 = _sg5Jr::P64;
           R1 = _sg5Ju::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Jt_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg710,
                       label: sat_sg5Jt_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg710: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg711; else goto cg712;
       cg711: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg712: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Product.$fDataProduct_$cgfoldl_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg5Js_entry() //  [R1]
         { info_tbl: [(cg717,
                       label: sat_sg5Js_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg717: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg718; else goto cg719;
       cg718: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg719: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$w$cp1Data_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg71b,
                       label: Data.Functor.Product.$fDataProduct_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg71b: // global
           Hp = Hp + 576;
           if (Hp > HpLim) (likely: False) goto cg71f; else goto cg71e;
       cg71f: // global
           HpAlloc = 576;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fDataProduct_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg71e: // global
           I64[Hp - 568] = sat_sg5K2_info;
           P64[Hp - 560] = R6;
           _sg5Jr::P64 = P64[Sp];
           P64[Hp - 552] = _sg5Jr::P64;
           I64[Hp - 544] = sat_sg5JY_info;
           P64[Hp - 536] = R6;
           P64[Hp - 528] = _sg5Jr::P64;
           I64[Hp - 520] = sat_sg5JU_info;
           P64[Hp - 512] = R2;
           P64[Hp - 504] = R3;
           P64[Hp - 496] = R4;
           P64[Hp - 488] = R5;
           P64[Hp - 480] = R6;
           P64[Hp - 472] = _sg5Jr::P64;
           I64[Hp - 464] = sat_sg5JT_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           P64[Hp - 440] = R4;
           P64[Hp - 432] = R5;
           P64[Hp - 424] = R6;
           P64[Hp - 416] = _sg5Jr::P64;
           I64[Hp - 408] = sat_sg5JS_info;
           P64[Hp - 400] = R6;
           P64[Hp - 392] = _sg5Jr::P64;
           I64[Hp - 384] = sat_sg5JJ_info;
           P64[Hp - 376] = R2;
           P64[Hp - 368] = R3;
           P64[Hp - 360] = R4;
           P64[Hp - 352] = R5;
           P64[Hp - 344] = R6;
           P64[Hp - 336] = _sg5Jr::P64;
           I64[Hp - 328] = sat_sg5JI_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           P64[Hp - 296] = R5;
           P64[Hp - 288] = R6;
           P64[Hp - 280] = _sg5Jr::P64;
           I64[Hp - 272] = sat_sg5JH_info;
           P64[Hp - 264] = R6;
           P64[Hp - 256] = _sg5Jr::P64;
           I64[Hp - 248] = sat_sg5Jz_info;
           P64[Hp - 240] = R6;
           P64[Hp - 232] = _sg5Jr::P64;
           I64[Hp - 224] = sat_sg5Jt_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           P64[Hp - 200] = R4;
           P64[Hp - 192] = R5;
           P64[Hp - 184] = R6;
           P64[Hp - 176] = _sg5Jr::P64;
           I64[Hp - 168] = sat_sg5Js_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           P64[Hp - 136] = R4;
           P64[Hp - 128] = R5;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 168;
           P64[Hp - 104] = Hp - 221;
           P64[Hp - 96] = Hp - 245;
           P64[Hp - 88] = lvl5_rg5oj_closure+1;
           P64[Hp - 80] = lvl6_rg5ok_closure+1;
           P64[Hp - 72] = lvl7_rg5ol_closure+2;
           P64[Hp - 64] = lvl8_rg5om_closure+2;
           P64[Hp - 56] = Hp - 270;
           P64[Hp - 48] = Hp - 324;
           P64[Hp - 40] = Hp - 380;
           P64[Hp - 32] = Hp - 406;
           P64[Hp - 24] = Hp - 461;
           P64[Hp - 16] = Hp - 517;
           P64[Hp - 8] = Hp - 541;
           P64[Hp] = Hp - 565;
           R1 = Hp - 119;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.339681818 UTC

[section ""data" . Data.Functor.Product.Pair_closure" {
     Data.Functor.Product.Pair_closure:
         const Data.Functor.Product.Pair_info;
 },
 Data.Functor.Product.Pair_entry() //  [R2, R3]
         { info_tbl: [(cg71l,
                       label: Data.Functor.Product.Pair_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg71l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg71p; else goto cg71o;
       cg71p: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.Pair_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg71o: // global
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.34063595 UTC

[Data.Functor.Product.Pair_con_entry() //  [R1]
         { info_tbl: [(cg71q,
                       label: Data.Functor.Product.Pair_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,80,114,111,100,117,99,116,46,80,97,105,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg71q: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.341411041 UTC

[section ""relreadonly" . Sg5Oh_srt" {
     Sg5Oh_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Product.$fRead1Product1_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadList_closure;
         const Data.Functor.Product.$fRead1Product_closure;
         const Data.Functor.Product.$fRead1Product2_closure;
         const Data.Functor.Product.$w$cliftShowsPrec_closure;
         const Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure;
         const Data.Functor.Product.$fShow1Product_$cliftShowList_closure;
         const Data.Functor.Product.$fShow1Product_closure;
         const Data.Functor.Product.$fReadProduct_$creadPrec_closure;
         const Data.Functor.Product.$fReadProduct_$creadsPrec_closure;
         const Data.Functor.Product.$fReadProduct_$creadListPrec_closure;
         const Data.Functor.Product.$fReadProduct_$creadList_closure;
         const Data.Functor.Product.$fReadProduct_closure;
         const Data.Functor.Product.$w$cshowsPrec_closure;
         const Data.Functor.Product.$fShowProduct_$cshowsPrec_closure;
         const Data.Functor.Product.$w$cshow_closure;
         const Data.Functor.Product.$fShowProduct_$cshow_closure;
         const Data.Functor.Product.$fShowProduct_$cshowList_closure;
         const Data.Functor.Product.$fShowProduct_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Functor.Product.$fFoldableProduct_$csum_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Functor.Product.$fFoldableProduct2_closure;
         const Data.Functor.Product.$fFoldableProduct_$cminimum_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Product.$fFoldableProduct3_closure;
         const Data.Functor.Product.$fFoldableProduct_$cmaximum_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Functor.Product.$fFoldableProduct_$celem_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Functor.Product.$fFoldableProduct8_closure;
         const Data.Functor.Product.$w$cfoldl_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldl_closure;
         const Data.Functor.Product.$w$cfoldl1_closure;
         const Data.Functor.Product.$fFoldableProduct7_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure;
         const Data.Functor.Product.$w$cfoldr'_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure;
         const Data.Functor.Product.$w$cfoldr_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldr_closure;
         const Data.Functor.Product.$w$cfoldl'_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure;
         const Data.Functor.Product.$fFoldableProduct_$clength_closure;
         const Data.Functor.Product.$w$cfoldr1_closure;
         const Data.Functor.Product.$fFoldableProduct9_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure;
         const Data.Functor.Product.$fFoldableProduct_$cnull_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Functor.Product.$fFoldableProduct_$cproduct_closure;
         const Data.Functor.Product.$fFoldableProduct_$ctoList_closure;
         const Data.Functor.Product.$fFoldableProduct_closure;
         const Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure;
         const Data.Functor.Product.$fTraversableProduct_closure;
         const poly_some_v_rg5o0_closure;
         const Data.Functor.Product.$fAlternativeProduct_$csome_closure;
         const Data.Functor.Product.$fAlternativeProduct_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Product.$fMonadProduct_closure;
         const lvl4_rg5o1_closure;
         const Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure;
         const Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure;
         const Data.Functor.Product.$fMonadPlusProduct_closure;
         const Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure;
         const Data.Functor.Product.$fMonadFixProduct_closure;
         const Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure;
         const Data.Functor.Product.$fMonadZipProduct_closure;
         const GHC.List.badHead_closure;
         const go61_rg5o2_closure;
         const Data.Functor.Product.$fRead1Product2_closure;
         const Data.Data.mkConstr1_closure;
         const Data.Functor.Product.$fDataProduct4_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Functor.Product.$w$cp1Data_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Functor.Product.$fDataProduct_$cgmapQi_closure;
         const Data.Functor.Product.$cPair_closure;
         const lvl5_rg5oj_closure;
         const Data.Functor.Product.$tProduct_closure;
         const Data.Functor.Product.$fDataProduct_closure;
         const lvl6_rg5ok_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.342587712 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:55.343661396 UTC

[section ""data" . Data.Functor.Product.$fEq1Product_$cliftEq_closure" {
     Data.Functor.Product.$fEq1Product_$cliftEq_closure:
         const Data.Functor.Product.$fEq1Product_$cliftEq_info;
 },
 Data.Functor.Product.$fEq1Product_$cliftEq_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cg71y,
                       label: Data.Functor.Product.$fEq1Product_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg71y: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg71C; else goto cg71D;
       cg71C: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEq1Product_$cliftEq_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg71D: // global
           I64[Sp - 40] = block_cg71v_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug71X; else goto cg71w;
       ug71X: // global
           call _cg71v(R1) args: 0, res: 0, upd: 0;
       cg71w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg71v() //  [R1]
         { info_tbl: [(cg71v,
                       label: block_cg71v_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg71v: // global
           I64[Sp - 8] = block_cg71B_info;
           _sg5ou::P64 = P64[R1 + 7];
           _sg5ov::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5ov::P64;
           P64[Sp + 32] = _sg5ou::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug71W; else goto cg71F;
       ug71W: // global
           call _cg71B(R1) args: 0, res: 0, upd: 0;
       cg71F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg71B() //  [R1]
         { info_tbl: [(cg71B,
                       label: block_cg71B_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg71B: // global
           I64[Sp] = block_cg71J_info;
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           _sg5oy::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp + 40] = _sg5oy::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg71J() //  [R1]
         { info_tbl: [(cg71J,
                       label: block_cg71J_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg71J: // global
           if (R1 & 7 == 1) goto cg71Q; else goto cg71U;
       cg71Q: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg71U: // global
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           R1 = P64[Sp + 24];
           Sp = Sp + 48;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.345488728 UTC

[section ""data" . Data.Functor.Product.$fEq1Product_closure" {
     Data.Functor.Product.$fEq1Product_closure:
         const Data.Functor.Product.$fEq1Product_info;
 },
 Data.Functor.Product.$fEq1Product_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg722,
                       label: Data.Functor.Product.$fEq1Product_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg722: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Product.$fEq1Product_$cliftEq_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.346759391 UTC

[section ""data" . Data.Functor.Product.$w$cliftCompare_closure" {
     Data.Functor.Product.$w$cliftCompare_closure:
         const Data.Functor.Product.$w$cliftCompare_info;
 },
 Data.Functor.Product.$w$cliftCompare_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg726: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cliftCompare_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cliftCompare_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cg72h,
                       label: Data.Functor.Product.$w$cliftCompare_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg72h: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg72i; else goto cg72j;
       cg72i: // global
           R1 = Data.Functor.Product.$w$cliftCompare_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg72j: // global
           I64[Sp - 24] = block_cg72a_info;
           R2 = R2;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = R4;
           P64[Sp - 40] = R5;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = R3;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg72a() //  [R1]
         { info_tbl: [(cg72a,
                       label: block_cg72a_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg72a: // global
           _cg72g::P64 = R1 & 7;
           if (_cg72g::P64 < 3) goto ug72t; else goto cg72f;
       ug72t: // global
           if (_cg72g::P64 < 2) goto cg72d; else goto cg72e;
       cg72d: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg72e: // global
           R2 = P64[Sp + 24];
           _sg5oC::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           _sg5oE::P64 = P64[Sp + 16];
           P64[Sp + 16] = _sg5oC::P64;
           P64[Sp + 24] = _sg5oE::P64;
           Sp = Sp + 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
       cg72f: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.348713282 UTC

[section ""data" . Data.Functor.Product.$fOrd1Product_$cliftCompare_closure" {
     Data.Functor.Product.$fOrd1Product_$cliftCompare_closure:
         const Data.Functor.Product.$fOrd1Product_$cliftCompare_info;
 },
 Data.Functor.Product.$fOrd1Product_$cliftCompare_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cg72B,
                       label: Data.Functor.Product.$fOrd1Product_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg72B: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg72F; else goto cg72G;
       cg72F: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrd1Product_$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg72G: // global
           I64[Sp - 40] = block_cg72y_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug72O; else goto cg72z;
       ug72O: // global
           call _cg72y(R1) args: 0, res: 0, upd: 0;
       cg72z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg72y() //  [R1]
         { info_tbl: [(cg72y,
                       label: block_cg72y_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg72y: // global
           I64[Sp - 8] = block_cg72E_info;
           _sg5oO::P64 = P64[R1 + 7];
           _sg5oP::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5oP::P64;
           P64[Sp + 32] = _sg5oO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug72N; else goto cg72I;
       ug72N: // global
           call _cg72E(R1) args: 0, res: 0, upd: 0;
       cg72I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg72E() //  [R1]
         { info_tbl: [(cg72E,
                       label: block_cg72E_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg72E: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cliftCompare_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.350755626 UTC

[section ""data" . Data.Functor.Product.$w$cp1Ord1_closure" {
     Data.Functor.Product.$w$cp1Ord1_closure:
         const Data.Functor.Product.$w$cp1Ord1_info;
 },
 Data.Functor.Product.$w$cp1Ord1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg72Q: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cp1Ord1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cp1Ord1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg730,
                       label: Data.Functor.Product.$w$cp1Ord1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg730: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg731; else goto cg732;
       cg731: // global
           R1 = Data.Functor.Product.$w$cp1Ord1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg732: // global
           I64[Sp - 24] = block_cg72U_info;
           R2 = R2;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = R4;
           P64[Sp - 40] = R5;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = R3;
           Sp = Sp - 56;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg72U() //  [R1]
         { info_tbl: [(cg72U,
                       label: block_cg72U_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg72U: // global
           if (R1 & 7 == 1) goto cg72X; else goto cg72Y;
       cg72X: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg72Y: // global
           R2 = P64[Sp + 24];
           _sg5oV::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           _sg5oX::P64 = P64[Sp + 16];
           P64[Sp + 16] = _sg5oV::P64;
           P64[Sp + 24] = _sg5oX::P64;
           Sp = Sp + 8;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.352533147 UTC

[section ""data" . Data.Functor.Product.$fOrd1Product1_closure" {
     Data.Functor.Product.$fOrd1Product1_closure:
         const Data.Functor.Product.$fOrd1Product1_info;
 },
 Data.Functor.Product.$fOrd1Product1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg73g,
                       label: Data.Functor.Product.$fOrd1Product1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg73g: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg73k; else goto cg73l;
       cg73k: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrd1Product1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg73l: // global
           I64[Sp - 40] = block_cg73d_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug73t; else goto cg73e;
       ug73t: // global
           call _cg73d(R1) args: 0, res: 0, upd: 0;
       cg73e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg73d() //  [R1]
         { info_tbl: [(cg73d,
                       label: block_cg73d_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg73d: // global
           I64[Sp - 8] = block_cg73j_info;
           _sg5p7::P64 = P64[R1 + 7];
           _sg5p8::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5p8::P64;
           P64[Sp + 32] = _sg5p7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug73s; else goto cg73n;
       ug73s: // global
           call _cg73j(R1) args: 0, res: 0, upd: 0;
       cg73n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg73j() //  [R1]
         { info_tbl: [(cg73j,
                       label: block_cg73j_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg73j: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cp1Ord1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.354446937 UTC

[section ""data" . Data.Functor.Product.$fOrd1Product_closure" {
     Data.Functor.Product.$fOrd1Product_closure:
         const Data.Functor.Product.$fOrd1Product_info;
 },
 sat_sg5pf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg73D,
                       label: sat_sg5pf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg73D: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fOrd1Product_$cliftCompare_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pe_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg73L,
                       label: sat_sg5pe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg73L: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fOrd1Product1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fOrd1Product_entry() //  [R2, R3]
         { info_tbl: [(cg73P,
                       label: Data.Functor.Product.$fOrd1Product_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg73P: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg73T; else goto cg73S;
       cg73T: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrd1Product_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg73S: // global
           I64[Hp - 64] = sat_sg5pf_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5pe_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 37;
           P64[Hp] = Hp - 61;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.355849951 UTC

[section ""cstring" . Data.Functor.Product.$fRead1Product3_bytes" {
     Data.Functor.Product.$fRead1Product3_bytes:
         I8[] [80,97,105,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.356686629 UTC

[section ""data" . Data.Functor.Product.$fRead1Product2_closure" {
     Data.Functor.Product.$fRead1Product2_closure:
         const Data.Functor.Product.$fRead1Product2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fRead1Product2_entry() //  [R1]
         { info_tbl: [(cg740,
                       label: Data.Functor.Product.$fRead1Product2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg740: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg741; else goto cg742;
       cg741: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg742: // global
           (_cg73X::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg73X::I64 == 0) goto cg73Z; else goto cg73Y;
       cg73Z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg73Y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg73X::I64;
           R2 = Data.Functor.Product.$fRead1Product3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.357718604 UTC

[section ""data" . Data.Functor.Product.$fRead1Product1_closure" {
     Data.Functor.Product.$fRead1Product1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Product.$fRead1Product2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.358359697 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_lvl3_closure" {
     Data.Functor.Product.$fRead1Product_lvl3_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.360754793 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadPrec_info;
         const 0;
 },
 reader_sg5pk_entry() //  [R1]
         { info_tbl: [(cg74b,
                       label: reader_sg5pk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg74b: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg74c; else goto cg74d;
       cg74c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg74d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 reader1_sg5pl_entry() //  [R1]
         { info_tbl: [(cg74i,
                       label: reader1_sg5pl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg74i: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg74j; else goto cg74k;
       cg74j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg74k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5pu_entry() //  [R1, R2]
         { info_tbl: [(cg74K,
                       label: sat_sg5pu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg74K: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg74O; else goto cg74N;
       cg74O: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg74N: // global
           _sg5po::P64 = P64[R1 + 7];
           _sg5pr::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = _sg5pr::P64;
           P64[Hp] = R2;
           R2 = Hp - 15;
           R1 = _sg5po::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pv_entry() //  [R1, R2]
         { info_tbl: [(cg74P,
                       label: sat_sg5pv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg74P: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg74T; else goto cg74S;
       cg74T: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg74S: // global
           _sg5pl::P64 = P64[R1 + 7];
           _sg5po::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sg5pu_info;
           P64[Hp - 8] = _sg5po::P64;
           P64[Hp] = R2;
           R3 = Hp - 15;
           R2 = Data.Functor.Product.$fRead1Product_lvl3_closure+1;
           R1 = _sg5pl::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pw_entry() //  [R1, R2]
         { info_tbl: [(cg74U,
                       label: sat_sg5pw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg74U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg74Y; else goto cg74X;
       cg74Y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg74X: // global
           _sg5pk::P64 = P64[R1 + 7];
           _sg5pl::P64 = P64[R1 + 15];
           _sg5po::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_sg5pv_info;
           P64[Hp - 8] = _sg5pl::P64;
           P64[Hp] = _sg5po::P64;
           R3 = Hp - 15;
           R2 = Data.Functor.Product.$fRead1Product_lvl3_closure+1;
           R1 = _sg5pk::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wlvl_sg5pm_entry() //  [R1, R2, R3]
         { info_tbl: [(cg752,
                       label: $wlvl_sg5pm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg752: // global
           _sg5po::P64 = R3;
           _sg5pn::I64 = R2;
           _sg5pm::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cg753; else goto cg754;
       cg754: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg756; else goto cg755;
       cg756: // global
           HpAlloc = 32;
           goto cg753;
       cg753: // global
           R3 = _sg5po::P64;
           R2 = _sg5pn::I64;
           R1 = _sg5pm::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg755: // global
           if (%MO_S_Gt_W64(_sg5pn::I64, 10)) goto cg750; else goto cg751;
       cg750: // global
           Hp = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg751: // global
           _sg5pk::P64 = P64[_sg5pm::P64 + 6];
           _sg5pl::P64 = P64[_sg5pm::P64 + 14];
           I64[Hp - 24] = sat_sg5pw_info;
           P64[Hp - 16] = _sg5pk::P64;
           P64[Hp - 8] = _sg5pl::P64;
           P64[Hp] = _sg5po::P64;
           I64[Sp - 8] = block_cg757_info;
           R3 = Hp - 23;
           R2 = Data.Functor.Product.$fRead1Product1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg757() //  [R1]
         { info_tbl: [(cg757,
                       label: block_cg757_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg757: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg75c; else goto cg75b;
       cg75c: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg75b: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl9_sg5pz_entry() //  [R1, R2, R3]
         { info_tbl: [(cg75l,
                       label: lvl9_sg5pz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg75l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg75m; else goto cg75n;
       cg75m: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg75n: // global
           I64[Sp - 24] = block_cg75i_info;
           _sg5pm::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sg5pm::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug75r; else goto cg75j;
       ug75r: // global
           call _cg75i(R1) args: 0, res: 0, upd: 0;
       cg75j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg75i() //  [R1]
         { info_tbl: [(cg75i,
                       label: block_cg75i_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg75i: // global
           R3 = P64[Sp + 16];
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call $wlvl_sg5pm_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pG_entry() //  [R1, R2, R3]
         { info_tbl: [(cg75x,
                       label: sat_sg5pG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg75x: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cg75A,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg75A: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cg75E; else goto cg75D;
       cg75E: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg75D: // global
           I64[Hp - 128] = reader_sg5pk_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R4;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = reader1_sg5pl_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = $wlvl_sg5pm_info;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 88;
           I64[Hp - 24] = lvl9_sg5pz_info;
           P64[Hp - 16] = Hp - 46;
           I64[Hp - 8] = sat_sg5pG_info;
           P64[Hp] = Hp - 22;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.367677079 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadsPrec_info;
         const 0;
 },
 sat_sg5pR_entry() //  [R1, R2, R3]
         { info_tbl: [(cg75V,
                       label: sat_sg5pR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg75V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg75W; else goto cg75X;
       cg75W: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg75X: // global
           I64[Sp - 8] = block_cg75S_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg75S() //  [R1]
         { info_tbl: [(cg75S,
                       label: block_cg75S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg75S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg760; else goto cg75Z;
       cg760: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg75Z: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pM_entry() //  [R1, R2]
         { info_tbl: [(cg766,
                       label: sat_sg5pM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg766: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sg5pL_entry() //  [R1]
         { info_tbl: [(cg769,
                       label: ds_sg5pL_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg769: // global
           _sg5pL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg76a; else goto cg76b;
       cg76b: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg76d; else goto cg76c;
       cg76d: // global
           HpAlloc = 32;
           goto cg76a;
       cg76a: // global
           R1 = _sg5pL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg76c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5pL::P64;
           _sg5pH::P64 = P64[_sg5pL::P64 + 16];
           _sg5pI::P64 = P64[_sg5pL::P64 + 24];
           _sg5pJ::P64 = P64[_sg5pL::P64 + 32];
           _sg5pK::P64 = P64[_sg5pL::P64 + 40];
           I64[Hp - 24] = sat_sg5pR_info;
           P64[Hp - 16] = _sg5pK::P64;
           I64[Hp - 8] = sat_sg5pM_info;
           P64[Hp] = _sg5pJ::P64;
           R5 = Hp - 22;
           R4 = Hp - 7;
           R3 = _sg5pI::P64;
           R2 = _sg5pH::P64;
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5pT_entry() //  [R1]
         { info_tbl: [(cg76n,
                       label: sat_sg5pT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg76n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg76o; else goto cg76p;
       cg76o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg76p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5pU_entry() //  [R1, R2]
         { info_tbl: [(cg76q,
                       label: sat_sg5pU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg76q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg76u; else goto cg76t;
       cg76u: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg76t: // global
           _sg5pL::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sg5pT_info;
           P64[Hp - 8] = _sg5pL::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadsPrec_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cg76v,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg76v: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg76z; else goto cg76y;
       cg76z: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg76y: // global
           I64[Hp - 56] = ds_sg5pL_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = sat_sg5pU_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.37057973 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadListPrec_info;
         const 0;
 },
 sat_sg5pZ_entry() //  [R1]
         { info_tbl: [(cg76I,
                       label: sat_sg5pZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg76I: // global
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadListPrec_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cg76L,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg76L: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg76P; else goto cg76O;
       cg76P: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg76O: // global
           I64[Hp - 40] = sat_sg5pZ_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.372636832 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_closure" {
     Data.Functor.Product.$fRead1Product_closure:
         const Data.Functor.Product.$fRead1Product_info;
         const 0;
 },
 sat_sg5q5_entry() //  [R1, R2, R3]
         { info_tbl: [(cg76Z,
                       label: sat_sg5q5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg76Z: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fRead1Product_$cliftReadListPrec_entry(R5,
                                                                             R4,
                                                                             R3,
                                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5q4_entry() //  [R1, R2, R3]
         { info_tbl: [(cg777,
                       label: sat_sg5q4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg777: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5q3_entry() //  [R1]
         { info_tbl: [(cg77e,
                       label: sat_sg5q3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg77e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg77f; else goto cg77g;
       cg77f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg77g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_$cliftReadList_entry(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5q2_entry() //  [R1, R2, R3]
         { info_tbl: [(cg77m,
                       label: sat_sg5q2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg77m: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fRead1Product_$cliftReadsPrec_entry(R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_entry() //  [R2, R3]
         { info_tbl: [(cg77q,
                       label: Data.Functor.Product.$fRead1Product_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg77q: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cg77u; else goto cg77t;
       cg77u: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg77t: // global
           I64[Hp - 136] = sat_sg5q5_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sg5q4_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sg5q3_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sg5q2_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 54;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 134;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadList_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadList_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadList_info;
         const 0;
 },
 sat_sg5q8_entry() //  [R1]
         { info_tbl: [(cg77D,
                       label: sat_sg5q8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg77D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg77E; else goto cg77F;
       cg77E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg77F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_entry(R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadList_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cg77G,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg77G: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg77K; else goto cg77J;
       cg77K: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg77J: // global
           I64[Hp - 24] = sat_sg5q8_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.375898387 UTC

[section ""data" . Data.Functor.Product.$w$cliftShowsPrec_closure" {
     Data.Functor.Product.$w$cliftShowsPrec_closure:
         const Data.Functor.Product.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg77M: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5qh_entry() //  [R1]
         { info_tbl: [(cg77U,
                       label: sat_sg5qh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg77U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg77V; else goto cg77W;
       cg77V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg77W: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5qg_entry() //  [R1]
         { info_tbl: [(cg781,
                       label: sat_sg5qg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg781: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg782; else goto cg783;
       cg782: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg783: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg784,
                       label: Data.Functor.Product.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, True, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg784: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg788; else goto cg787;
       cg788: // global
           HpAlloc = 80;
           R1 = Data.Functor.Product.$w$cliftShowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg787: // global
           I64[Hp - 72] = sat_sg5qh_info;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sg5qg_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sg5qd::I64 = R6;
           R6 = P64[Sp];
           R5 = _sg5qd::I64;
           R4 = Data.Functor.Product.$fRead1Product2_closure;
           R3 = Hp - 72;
           R2 = Hp - 32;
           Sp = Sp + 8;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.378365505 UTC

[section ""data" . Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure" {
     Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure:
         const Data.Functor.Product.$fShow1Product_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$fShow1Product_$cliftShowsPrec_entry() //  [R2,
                                                                  R3, R4, R5, R6]
         { info_tbl: [(cg78g,
                       label: Data.Functor.Product.$fShow1Product_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg78g: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg78k; else goto cg78l;
       cg78k: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg78l: // global
           I64[Sp - 40] = block_cg78d_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug78t; else goto cg78e;
       ug78t: // global
           call _cg78d(R1) args: 0, res: 0, upd: 0;
       cg78e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg78d() //  [R1]
         { info_tbl: [(cg78d,
                       label: block_cg78d_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg78d: // global
           I64[Sp] = block_cg78j_info;
           _sg5qp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sg5qp::I64;
           if (R1 & 7 != 0) goto ug78s; else goto cg78n;
       ug78s: // global
           call _cg78j(R1) args: 0, res: 0, upd: 0;
       cg78n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg78j() //  [R1]
         { info_tbl: [(cg78j,
                       label: block_cg78j_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg78j: // global
           R6 = I64[Sp + 40];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.379807168 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct4_closure" {
     Data.Functor.Product.$fFoldableProduct4_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.380953527 UTC

[section ""data" . Data.Functor.Product.$fShow1Product_$cliftShowList_closure" {
     Data.Functor.Product.$fShow1Product_$cliftShowList_closure:
         const Data.Functor.Product.$fShow1Product_$cliftShowList_info;
         const 0;
 },
 sat_sg5qD_entry() //  [R1, R2]
         { info_tbl: [(cg78G,
                       label: sat_sg5qD_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg78G: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg78H; else goto cg78I;
       cg78H: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg78I: // global
           I64[Sp - 40] = block_cg78D_info;
           _sg5qt::P64 = P64[R1 + 7];
           _sg5qu::P64 = P64[R1 + 15];
           _sg5qv::P64 = P64[R1 + 23];
           _sg5qw::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5qt::P64;
           P64[Sp - 24] = _sg5qu::P64;
           P64[Sp - 16] = _sg5qv::P64;
           P64[Sp - 8] = _sg5qw::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug78M; else goto cg78E;
       ug78M: // global
           call _cg78D(R1) args: 0, res: 0, upd: 0;
       cg78E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg78D() //  [R1]
         { info_tbl: [(cg78D,
                       label: block_cg78D_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg78D: // global
           R6 = 0;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShow1Product_$cliftShowList_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cg78N,
                       label: Data.Functor.Product.$fShow1Product_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg78N: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg78R; else goto cg78Q;
       cg78R: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShow1Product_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg78Q: // global
           I64[Hp - 32] = sat_sg5qD_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 31;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.383085684 UTC

[section ""data" . Data.Functor.Product.$fShow1Product_closure" {
     Data.Functor.Product.$fShow1Product_closure:
         const Data.Functor.Product.$fShow1Product_info;
         const 0;
 },
 sat_sg5qH_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg791,
                       label: sat_sg5qH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg791: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg792; else goto cg793;
       cg792: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg793: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Product.$fShow1Product_$cliftShowList_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_sg5qG_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg799,
                       label: sat_sg5qG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg799: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg79a; else goto cg79b;
       cg79a: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg79b: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Product.$fShow1Product_$cliftShowsPrec_entry(R6,
                                                                          R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShow1Product_entry() //  [R2, R3]
         { info_tbl: [(cg79d,
                       label: Data.Functor.Product.$fShow1Product_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg79d: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg79h; else goto cg79g;
       cg79h: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShow1Product_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg79g: // global
           I64[Hp - 64] = sat_sg5qH_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5qG_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 36;
           P64[Hp] = Hp - 60;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.385353824 UTC

[section ""data" . Data.Functor.Product.$w$c==_closure" {
     Data.Functor.Product.$w$c==_closure:
         const Data.Functor.Product.$w$c==_info;
 },
 Data.Functor.Product.$w$c==_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg79j: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c==_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 24, res: 0, upd: 8;
     }
 },
 eq_sg5qP_entry() //  [R1]
         { info_tbl: [(cg79r,
                       label: eq_sg5qP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg79r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg79s; else goto cg79t;
       cg79s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg79t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c==_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg79A,
                       label: Data.Functor.Product.$w$c==_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg79A: // global
           _sg5qM::P64 = R6;
           _sg5qL::P64 = R5;
           _sg5qK::P64 = R4;
           _sg5qJ::P64 = R3;
           _sg5qI::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cg79B; else goto cg79C;
       cg79C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg79E; else goto cg79D;
       cg79E: // global
           HpAlloc = 24;
           goto cg79B;
       cg79B: // global
           R1 = Data.Functor.Product.$w$c==_closure;
           P64[Sp - 40] = _sg5qI::P64;
           P64[Sp - 32] = _sg5qJ::P64;
           P64[Sp - 24] = _sg5qK::P64;
           P64[Sp - 16] = _sg5qL::P64;
           P64[Sp - 8] = _sg5qM::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg79D: // global
           I64[Hp - 16] = eq_sg5qP_info;
           P64[Hp] = _sg5qK::P64;
           I64[Sp - 24] = block_cg79u_info;
           R4 = P64[Sp];
           R3 = _sg5qL::P64;
           _cg79n::P64 = Hp - 16;
           R2 = _cg79n::P64;
           R1 = _sg5qI::P64;
           P64[Sp - 16] = _sg5qJ::P64;
           P64[Sp - 8] = _sg5qM::P64;
           P64[Sp] = _cg79n::P64;
           Sp = Sp - 24;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg79u() //  [R1]
         { info_tbl: [(cg79u,
                       label: block_cg79u_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg79u: // global
           if (R1 & 7 == 1) goto cg79x; else goto cg79y;
       cg79x: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg79y: // global
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.387425886 UTC

[section ""data" . Data.Functor.Product.$fEqProduct_$c==_closure" {
     Data.Functor.Product.$fEqProduct_$c==_closure:
         const Data.Functor.Product.$fEqProduct_$c==_info;
 },
 Data.Functor.Product.$fEqProduct_$c==_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg79S,
                       label: Data.Functor.Product.$fEqProduct_$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg79S: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg79W; else goto cg79X;
       cg79W: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEqProduct_$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg79X: // global
           I64[Sp - 40] = block_cg79P_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7a5; else goto cg79Q;
       ug7a5: // global
           call _cg79P(R1) args: 0, res: 0, upd: 0;
       cg79Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg79P() //  [R1]
         { info_tbl: [(cg79P,
                       label: block_cg79P_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg79P: // global
           I64[Sp - 8] = block_cg79V_info;
           _sg5qX::P64 = P64[R1 + 7];
           _sg5qY::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5qY::P64;
           P64[Sp + 32] = _sg5qX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7a4; else goto cg79Z;
       ug7a4: // global
           call _cg79V(R1) args: 0, res: 0, upd: 0;
       cg79Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg79V() //  [R1]
         { info_tbl: [(cg79V,
                       label: block_cg79V_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg79V: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c==_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.389734888 UTC

[section ""data" . Data.Functor.Product.$fEqProduct_$c/=_closure" {
     Data.Functor.Product.$fEqProduct_$c/=_closure:
         const Data.Functor.Product.$fEqProduct_$c/=_info;
 },
 eq_sg5rd_entry() //  [R1]
         { info_tbl: [(cg7ao,
                       label: eq_sg5rd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ao: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7ap; else goto cg7aq;
       cg7ap: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7aq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fEqProduct_$c/=_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg7ar,
                       label: Data.Functor.Product.$fEqProduct_$c/=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ar: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7as; else goto cg7at;
       cg7as: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEqProduct_$c/=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7at: // global
           I64[Sp - 40] = block_cg7aa_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7aZ; else goto cg7ab;
       ug7aZ: // global
           call _cg7aa(R1) args: 0, res: 0, upd: 0;
       cg7ab: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7aa() //  [R1]
         { info_tbl: [(cg7aa,
                       label: block_cg7aa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7aa: // global
           I64[Sp - 8] = block_cg7af_info;
           _sg5r8::P64 = P64[R1 + 7];
           _sg5r9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5r9::P64;
           P64[Sp + 32] = _sg5r8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7aY; else goto cg7ag;
       ug7aY: // global
           call _cg7af(R1) args: 0, res: 0, upd: 0;
       cg7ag: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7af() //  [R1]
         { info_tbl: [(cg7af,
                       label: block_cg7af_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7af: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg7ay; else goto cg7ax;
       cg7ay: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7ax: // global
           _sg5rb::P64 = P64[R1 + 7];
           _sg5rc::P64 = P64[R1 + 15];
           I64[Hp - 16] = eq_sg5rd_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_cg7av_info;
           R4 = _sg5rb::P64;
           R3 = P64[Sp + 40];
           _cg7ak::P64 = Hp - 16;
           R2 = _cg7ak::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 32] = _sg5rc::P64;
           P64[Sp + 40] = _cg7ak::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7av() //  [R1]
         { info_tbl: [(cg7av,
                       label: block_cg7av_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7av: // global
           if (R1 & 7 == 1) goto ug7aW; else goto cg7aJ;
       ug7aW: // global
           Sp = Sp + 48;
           call _cg7aP() args: 0, res: 0, upd: 0;
       cg7aJ: // global
           _cg7ak::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cg7aH_info;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 8];
           R2 = _cg7ak::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7aH() //  [R1]
         { info_tbl: [(cg7aH,
                       label: block_cg7aH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7aH: // global
           if (R1 & 7 == 1) goto ug7aX; else goto cg7aT;
       ug7aX: // global
           Sp = Sp + 8;
           call _cg7aP() args: 0, res: 0, upd: 0;
       cg7aT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg7aP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7aP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.392553413 UTC

[section ""data" . Data.Functor.Product.$fEqProduct_closure" {
     Data.Functor.Product.$fEqProduct_closure:
         const Data.Functor.Product.$fEqProduct_info;
 },
 sat_sg5rk_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7bb,
                       label: sat_sg5rk_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7bb: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fEqProduct_$c/=_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5rj_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7bj,
                       label: sat_sg5rj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7bj: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fEqProduct_$c==_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fEqProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cg7bn,
                       label: Data.Functor.Product.$fEqProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7bn: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg7br; else goto cg7bq;
       cg7br: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEqProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7bq: // global
           I64[Hp - 80] = sat_sg5rk_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg5rj_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 78;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.39494071 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$ccompare_closure" {
     Data.Functor.Product.$fOrdProduct_$ccompare_closure:
         const Data.Functor.Product.$fOrdProduct_$ccompare_info;
 },
 w_sg5rw_entry() //  [R1]
         { info_tbl: [(cg7bK,
                       label: w_sg5rw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7bK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7bL; else goto cg7bM;
       cg7bL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7bM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$ccompare_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cg7bN,
                       label: Data.Functor.Product.$fOrdProduct_$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7bN: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cg7bO; else goto cg7bP;
       cg7bO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7bP: // global
           I64[Sp - 40] = block_cg7bw_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7cc; else goto cg7bx;
       ug7cc: // global
           call _cg7bw(R1) args: 0, res: 0, upd: 0;
       cg7bx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7bw() //  [R1]
         { info_tbl: [(cg7bw,
                       label: block_cg7bw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7bw: // global
           I64[Sp - 8] = block_cg7bB_info;
           _sg5rr::P64 = P64[R1 + 7];
           _sg5rs::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5rs::P64;
           P64[Sp + 32] = _sg5rr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7cb; else goto cg7bC;
       ug7cb: // global
           call _cg7bB(R1) args: 0, res: 0, upd: 0;
       cg7bC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7bB() //  [R1]
         { info_tbl: [(cg7bB,
                       label: block_cg7bB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7bB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg7bU; else goto cg7bT;
       cg7bU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7bT: // global
           _sg5ru::P64 = P64[R1 + 7];
           _sg5rv::P64 = P64[R1 + 15];
           I64[Hp - 16] = w_sg5rw_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_cg7bR_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           _cg7bG::P64 = Hp - 16;
           P64[Sp - 24] = _cg7bG::P64;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = _sg5ru::P64;
           P64[Sp + 32] = _sg5rv::P64;
           P64[Sp + 40] = _cg7bG::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg7bR() //  [R1]
         { info_tbl: [(cg7bR,
                       label: block_cg7bR_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7bR: // global
           _cg7c9::P64 = R1 & 7;
           if (_cg7c9::P64 < 3) goto ug7ca; else goto cg7c8;
       ug7ca: // global
           if (_cg7c9::P64 < 2) goto cg7c0; else goto cg7c4;
       cg7c0: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg7c4: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_ppp_info;
           P64[Sp + 24] = P64[Sp + 40];
           _sg5rv::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 8];
           P64[Sp + 40] = _sg5rv::P64;
           Sp = Sp + 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
       cg7c8: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.399066623 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$cp1Ord_closure" {
     Data.Functor.Product.$fOrdProduct_$cp1Ord_closure:
         const Data.Functor.Product.$fOrdProduct_$cp1Ord_info;
 },
 sat_sg5rD_entry() //  [R1]
         { info_tbl: [(cg7cl,
                       label: sat_sg5rD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7cl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7cm; else goto cg7cn;
       cg7cm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7cn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5rC_entry() //  [R1]
         { info_tbl: [(cg7cs,
                       label: sat_sg5rC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7cs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7ct; else goto cg7cu;
       cg7ct: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7cu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5rB_entry() //  [R1]
         { info_tbl: [(cg7cz,
                       label: sat_sg5rB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7cz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7cA; else goto cg7cB;
       cg7cA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7cB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$cp1Ord_entry() //  [R2, R3, R4]
         { info_tbl: [(cg7cC,
                       label: Data.Functor.Product.$fOrdProduct_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7cC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg7cG; else goto cg7cF;
       cg7cG: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$cp1Ord_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7cF: // global
           I64[Hp - 64] = sat_sg5rD_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sg5rC_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5rB_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fEqProduct_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.401394974 UTC

[section ""data" . Data.Functor.Product.$w$c<_closure" {
     Data.Functor.Product.$w$c<_closure:
         const Data.Functor.Product.$w$c<_info;
 },
 Data.Functor.Product.$w$c<_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7cI: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c<_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sg5rL_entry() //  [R1]
         { info_tbl: [(cg7cQ,
                       label: comp_sg5rL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7cQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7cR; else goto cg7cS;
       cg7cR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7cS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7d0,
                       label: Data.Functor.Product.$w$c<_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7d0: // global
           _sg5rI::P64 = R6;
           _sg5rH::P64 = R5;
           _sg5rG::P64 = R4;
           _sg5rF::P64 = R3;
           _sg5rE::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg7d1; else goto cg7d2;
       cg7d2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg7d4; else goto cg7d3;
       cg7d4: // global
           HpAlloc = 24;
           goto cg7d1;
       cg7d1: // global
           R1 = Data.Functor.Product.$w$c<_closure;
           P64[Sp - 40] = _sg5rE::P64;
           P64[Sp - 32] = _sg5rF::P64;
           P64[Sp - 24] = _sg5rG::P64;
           P64[Sp - 16] = _sg5rH::P64;
           P64[Sp - 8] = _sg5rI::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg7d3: // global
           I64[Hp - 16] = comp_sg5rL_info;
           P64[Hp] = _sg5rG::P64;
           I64[Sp - 24] = block_cg7cT_info;
           R2 = _sg5rE::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cg7cM::P64 = Hp - 16;
           P64[Sp - 48] = _cg7cM::P64;
           P64[Sp - 40] = _sg5rH::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sg5rF::P64;
           P64[Sp - 8] = _sg5rI::P64;
           P64[Sp] = _cg7cM::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg7cT() //  [R1]
         { info_tbl: [(cg7cT,
                       label: block_cg7cT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7cT: // global
           _cg7cZ::P64 = R1 & 7;
           if (_cg7cZ::P64 < 3) goto ug7dq; else goto ug7dr;
       ug7dq: // global
           if (_cg7cZ::P64 < 2) goto ug7ds; else goto cg7cX;
       ug7ds: // global
           Sp = Sp + 40;
           call _cg7dl() args: 0, res: 0, upd: 0;
       cg7cX: // global
           _sg5rK::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg7da_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sg5rK::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug7dr: // global
           Sp = Sp + 40;
           call _cg7cY() args: 0, res: 0, upd: 0;
     }
 },
 _cg7da() //  [R1]
         { info_tbl: [(cg7da,
                       label: block_cg7da_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7da: // global
           if (R1 & 7 == 1) goto ug7dt; else goto ug7du;
       ug7dt: // global
           Sp = Sp + 8;
           call _cg7dl() args: 0, res: 0, upd: 0;
       ug7du: // global
           Sp = Sp + 8;
           call _cg7cY() args: 0, res: 0, upd: 0;
     }
 },
 _cg7dl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7dl: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg7cY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7cY: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.403843109 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c<_closure" {
     Data.Functor.Product.$fOrdProduct_$c<_closure:
         const Data.Functor.Product.$fOrdProduct_$c<_info;
 },
 Data.Functor.Product.$fOrdProduct_$c<_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg7dG,
                       label: Data.Functor.Product.$fOrdProduct_$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7dG: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7dK; else goto cg7dL;
       cg7dK: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7dL: // global
           I64[Sp - 40] = block_cg7dD_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7dT; else goto cg7dE;
       ug7dT: // global
           call _cg7dD(R1) args: 0, res: 0, upd: 0;
       cg7dE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7dD() //  [R1]
         { info_tbl: [(cg7dD,
                       label: block_cg7dD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7dD: // global
           I64[Sp - 8] = block_cg7dJ_info;
           _sg5rU::P64 = P64[R1 + 7];
           _sg5rV::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5rV::P64;
           P64[Sp + 32] = _sg5rU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7dS; else goto cg7dN;
       ug7dS: // global
           call _cg7dJ(R1) args: 0, res: 0, upd: 0;
       cg7dN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7dJ() //  [R1]
         { info_tbl: [(cg7dJ,
                       label: block_cg7dJ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7dJ: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c<_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.406031644 UTC

[section ""data" . Data.Functor.Product.$w$c>=_closure" {
     Data.Functor.Product.$w$c>=_closure:
         const Data.Functor.Product.$w$c>=_info;
 },
 Data.Functor.Product.$w$c>=_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7dV: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c>=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sg5s6_entry() //  [R1]
         { info_tbl: [(cg7e3,
                       label: comp_sg5s6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7e3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7e4; else goto cg7e5;
       cg7e4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7e5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c>=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7ed,
                       label: Data.Functor.Product.$w$c>=_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ed: // global
           _sg5s3::P64 = R6;
           _sg5s2::P64 = R5;
           _sg5s1::P64 = R4;
           _sg5s0::P64 = R3;
           _sg5rZ::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg7ee; else goto cg7ef;
       cg7ef: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg7eh; else goto cg7eg;
       cg7eh: // global
           HpAlloc = 24;
           goto cg7ee;
       cg7ee: // global
           R1 = Data.Functor.Product.$w$c>=_closure;
           P64[Sp - 40] = _sg5rZ::P64;
           P64[Sp - 32] = _sg5s0::P64;
           P64[Sp - 24] = _sg5s1::P64;
           P64[Sp - 16] = _sg5s2::P64;
           P64[Sp - 8] = _sg5s3::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg7eg: // global
           I64[Hp - 16] = comp_sg5s6_info;
           P64[Hp] = _sg5s1::P64;
           I64[Sp - 24] = block_cg7e6_info;
           R2 = _sg5rZ::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cg7dZ::P64 = Hp - 16;
           P64[Sp - 48] = _cg7dZ::P64;
           P64[Sp - 40] = _sg5s2::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sg5s0::P64;
           P64[Sp - 8] = _sg5s3::P64;
           P64[Sp] = _cg7dZ::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg7e6() //  [R1]
         { info_tbl: [(cg7e6,
                       label: block_cg7e6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7e6: // global
           _cg7ec::P64 = R1 & 7;
           if (_cg7ec::P64 < 3) goto ug7eD; else goto ug7eE;
       ug7eD: // global
           if (_cg7ec::P64 < 2) goto ug7eF; else goto cg7ea;
       ug7eF: // global
           Sp = Sp + 40;
           call _cg7ey() args: 0, res: 0, upd: 0;
       cg7ea: // global
           _sg5s5::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg7en_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sg5s5::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug7eE: // global
           Sp = Sp + 40;
           call _cg7eb() args: 0, res: 0, upd: 0;
     }
 },
 _cg7en() //  [R1]
         { info_tbl: [(cg7en,
                       label: block_cg7en_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7en: // global
           if (R1 & 7 == 1) goto ug7eG; else goto ug7eH;
       ug7eG: // global
           Sp = Sp + 8;
           call _cg7ey() args: 0, res: 0, upd: 0;
       ug7eH: // global
           Sp = Sp + 8;
           call _cg7eb() args: 0, res: 0, upd: 0;
     }
 },
 _cg7ey() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ey: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg7eb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7eb: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.408449529 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c>=_closure" {
     Data.Functor.Product.$fOrdProduct_$c>=_closure:
         const Data.Functor.Product.$fOrdProduct_$c>=_info;
 },
 Data.Functor.Product.$fOrdProduct_$c>=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg7eT,
                       label: Data.Functor.Product.$fOrdProduct_$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7eT: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7eX; else goto cg7eY;
       cg7eX: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7eY: // global
           I64[Sp - 40] = block_cg7eQ_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7f6; else goto cg7eR;
       ug7f6: // global
           call _cg7eQ(R1) args: 0, res: 0, upd: 0;
       cg7eR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7eQ() //  [R1]
         { info_tbl: [(cg7eQ,
                       label: block_cg7eQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7eQ: // global
           I64[Sp - 8] = block_cg7eW_info;
           _sg5sf::P64 = P64[R1 + 7];
           _sg5sg::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5sg::P64;
           P64[Sp + 32] = _sg5sf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7f5; else goto cg7f0;
       ug7f5: // global
           call _cg7eW(R1) args: 0, res: 0, upd: 0;
       cg7f0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7eW() //  [R1]
         { info_tbl: [(cg7eW,
                       label: block_cg7eW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7eW: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c>=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.410867926 UTC

[section ""data" . Data.Functor.Product.$w$c>_closure" {
     Data.Functor.Product.$w$c>_closure:
         const Data.Functor.Product.$w$c>_info;
 },
 Data.Functor.Product.$w$c>_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7f8: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sg5sr_entry() //  [R1]
         { info_tbl: [(cg7fg,
                       label: comp_sg5sr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7fg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7fh; else goto cg7fi;
       cg7fh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7fi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7fq,
                       label: Data.Functor.Product.$w$c>_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7fq: // global
           _sg5so::P64 = R6;
           _sg5sn::P64 = R5;
           _sg5sm::P64 = R4;
           _sg5sl::P64 = R3;
           _sg5sk::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg7fr; else goto cg7fs;
       cg7fs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg7fu; else goto cg7ft;
       cg7fu: // global
           HpAlloc = 24;
           goto cg7fr;
       cg7fr: // global
           R1 = Data.Functor.Product.$w$c>_closure;
           P64[Sp - 40] = _sg5sk::P64;
           P64[Sp - 32] = _sg5sl::P64;
           P64[Sp - 24] = _sg5sm::P64;
           P64[Sp - 16] = _sg5sn::P64;
           P64[Sp - 8] = _sg5so::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg7ft: // global
           I64[Hp - 16] = comp_sg5sr_info;
           P64[Hp] = _sg5sm::P64;
           I64[Sp - 24] = block_cg7fj_info;
           R2 = _sg5sk::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cg7fc::P64 = Hp - 16;
           P64[Sp - 48] = _cg7fc::P64;
           P64[Sp - 40] = _sg5sn::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sg5sl::P64;
           P64[Sp - 8] = _sg5so::P64;
           P64[Sp] = _cg7fc::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg7fj() //  [R1]
         { info_tbl: [(cg7fj,
                       label: block_cg7fj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7fj: // global
           _cg7fp::P64 = R1 & 7;
           if (_cg7fp::P64 < 3) goto ug7fQ; else goto ug7fR;
       ug7fQ: // global
           if (_cg7fp::P64 < 2) goto ug7fS; else goto cg7fn;
       ug7fS: // global
           Sp = Sp + 40;
           call _cg7fH() args: 0, res: 0, upd: 0;
       cg7fn: // global
           _sg5sq::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg7fA_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sg5sq::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug7fR: // global
           Sp = Sp + 40;
           call _cg7fo() args: 0, res: 0, upd: 0;
     }
 },
 _cg7fA() //  [R1]
         { info_tbl: [(cg7fA,
                       label: block_cg7fA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7fA: // global
           if (R1 & 7 == 3) goto ug7fT; else goto ug7fU;
       ug7fT: // global
           Sp = Sp + 8;
           call _cg7fo() args: 0, res: 0, upd: 0;
       ug7fU: // global
           Sp = Sp + 8;
           call _cg7fH() args: 0, res: 0, upd: 0;
     }
 },
 _cg7fH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7fH: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg7fo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7fo: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.413402021 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c>_closure" {
     Data.Functor.Product.$fOrdProduct_$c>_closure:
         const Data.Functor.Product.$fOrdProduct_$c>_info;
 },
 Data.Functor.Product.$fOrdProduct_$c>_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg7g6,
                       label: Data.Functor.Product.$fOrdProduct_$c>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7g6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7ga; else goto cg7gb;
       cg7ga: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7gb: // global
           I64[Sp - 40] = block_cg7g3_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7gj; else goto cg7g4;
       ug7gj: // global
           call _cg7g3(R1) args: 0, res: 0, upd: 0;
       cg7g4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7g3() //  [R1]
         { info_tbl: [(cg7g3,
                       label: block_cg7g3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7g3: // global
           I64[Sp - 8] = block_cg7g9_info;
           _sg5sA::P64 = P64[R1 + 7];
           _sg5sB::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5sB::P64;
           P64[Sp + 32] = _sg5sA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7gi; else goto cg7gd;
       ug7gi: // global
           call _cg7g9(R1) args: 0, res: 0, upd: 0;
       cg7gd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7g9() //  [R1]
         { info_tbl: [(cg7g9,
                       label: block_cg7g9_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7g9: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.415604209 UTC

[section ""data" . Data.Functor.Product.$w$c<=_closure" {
     Data.Functor.Product.$w$c<=_closure:
         const Data.Functor.Product.$w$c<=_info;
 },
 Data.Functor.Product.$w$c<=_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7gl: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c<=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sg5sM_entry() //  [R1]
         { info_tbl: [(cg7gt,
                       label: comp_sg5sM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7gt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7gu; else goto cg7gv;
       cg7gu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7gv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7gD,
                       label: Data.Functor.Product.$w$c<=_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7gD: // global
           _sg5sJ::P64 = R6;
           _sg5sI::P64 = R5;
           _sg5sH::P64 = R4;
           _sg5sG::P64 = R3;
           _sg5sF::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg7gE; else goto cg7gF;
       cg7gF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg7gH; else goto cg7gG;
       cg7gH: // global
           HpAlloc = 24;
           goto cg7gE;
       cg7gE: // global
           R1 = Data.Functor.Product.$w$c<=_closure;
           P64[Sp - 40] = _sg5sF::P64;
           P64[Sp - 32] = _sg5sG::P64;
           P64[Sp - 24] = _sg5sH::P64;
           P64[Sp - 16] = _sg5sI::P64;
           P64[Sp - 8] = _sg5sJ::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg7gG: // global
           I64[Hp - 16] = comp_sg5sM_info;
           P64[Hp] = _sg5sH::P64;
           I64[Sp - 24] = block_cg7gw_info;
           R2 = _sg5sF::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cg7gp::P64 = Hp - 16;
           P64[Sp - 48] = _cg7gp::P64;
           P64[Sp - 40] = _sg5sI::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sg5sG::P64;
           P64[Sp - 8] = _sg5sJ::P64;
           P64[Sp] = _cg7gp::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg7gw() //  [R1]
         { info_tbl: [(cg7gw,
                       label: block_cg7gw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7gw: // global
           _cg7gC::P64 = R1 & 7;
           if (_cg7gC::P64 < 3) goto ug7h3; else goto ug7h4;
       ug7h3: // global
           if (_cg7gC::P64 < 2) goto ug7h5; else goto cg7gA;
       ug7h5: // global
           Sp = Sp + 40;
           call _cg7gU() args: 0, res: 0, upd: 0;
       cg7gA: // global
           _sg5sL::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg7gN_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sg5sL::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug7h4: // global
           Sp = Sp + 40;
           call _cg7gB() args: 0, res: 0, upd: 0;
     }
 },
 _cg7gN() //  [R1]
         { info_tbl: [(cg7gN,
                       label: block_cg7gN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7gN: // global
           if (R1 & 7 == 3) goto ug7h6; else goto ug7h7;
       ug7h6: // global
           Sp = Sp + 8;
           call _cg7gB() args: 0, res: 0, upd: 0;
       ug7h7: // global
           Sp = Sp + 8;
           call _cg7gU() args: 0, res: 0, upd: 0;
     }
 },
 _cg7gU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7gU: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg7gB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7gB: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.418143687 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c<=_closure" {
     Data.Functor.Product.$fOrdProduct_$c<=_closure:
         const Data.Functor.Product.$fOrdProduct_$c<=_info;
 },
 Data.Functor.Product.$fOrdProduct_$c<=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg7hj,
                       label: Data.Functor.Product.$fOrdProduct_$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7hj: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7hn; else goto cg7ho;
       cg7hn: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7ho: // global
           I64[Sp - 40] = block_cg7hg_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7hw; else goto cg7hh;
       ug7hw: // global
           call _cg7hg(R1) args: 0, res: 0, upd: 0;
       cg7hh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7hg() //  [R1]
         { info_tbl: [(cg7hg,
                       label: block_cg7hg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7hg: // global
           I64[Sp - 8] = block_cg7hm_info;
           _sg5sV::P64 = P64[R1 + 7];
           _sg5sW::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5sW::P64;
           P64[Sp + 32] = _sg5sV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7hv; else goto cg7hq;
       ug7hv: // global
           call _cg7hm(R1) args: 0, res: 0, upd: 0;
       cg7hq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7hm() //  [R1]
         { info_tbl: [(cg7hm,
                       label: block_cg7hm_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7hm: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c<=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.420540392 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$cmax_closure" {
     Data.Functor.Product.$fOrdProduct_$cmax_closure:
         const Data.Functor.Product.$fOrdProduct_$cmax_info;
 },
 comp_sg5tb_entry() //  [R1]
         { info_tbl: [(cg7hP,
                       label: comp_sg5tb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7hP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7hQ; else goto cg7hR;
       cg7hQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7hR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$cmax_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cg7hS,
                       label: Data.Functor.Product.$fOrdProduct_$cmax_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7hS: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cg7hT; else goto cg7hU;
       cg7hT: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$cmax_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7hU: // global
           I64[Sp - 40] = block_cg7hB_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7ix; else goto cg7hC;
       ug7ix: // global
           call _cg7hB(R1) args: 0, res: 0, upd: 0;
       cg7hC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7hB() //  [R1]
         { info_tbl: [(cg7hB,
                       label: block_cg7hB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7hB: // global
           I64[Sp - 16] = block_cg7hG_info;
           _sg5t5::P64 = R1;
           _sg5t6::P64 = P64[R1 + 7];
           _sg5t7::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _sg5t7::P64;
           P64[Sp] = _sg5t6::P64;
           P64[Sp + 32] = _sg5t5::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ug7iw; else goto cg7hH;
       ug7iw: // global
           call _cg7hG(R1) args: 0, res: 0, upd: 0;
       cg7hH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7hG() //  [R1]
         { info_tbl: [(cg7hG,
                       label: block_cg7hG_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7hG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg7hZ; else goto cg7hY;
       cg7hZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7hY: // global
           _sg5t9::P64 = P64[R1 + 7];
           _sg5ta::P64 = P64[R1 + 15];
           I64[Hp - 16] = comp_sg5tb_info;
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_cg7hW_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_ppp_info;
           _cg7hL::P64 = Hp - 16;
           P64[Sp - 24] = _cg7hL::P64;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = _sg5t9::P64;
           P64[Sp + 16] = _sg5ta::P64;
           P64[Sp + 24] = R1;
           P64[Sp + 40] = _cg7hL::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg7hW() //  [R1]
         { info_tbl: [(cg7hW,
                       label: block_cg7hW_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7hW: // global
           _cg7ip::P64 = R1 & 7;
           if (_cg7ip::P64 < 3) goto ug7ir; else goto ug7is;
       ug7ir: // global
           if (_cg7ip::P64 < 2) goto ug7it; else goto cg7ia;
       ug7it: // global
           Sp = Sp + 24;
           call _cg7ig() args: 0, res: 0, upd: 0;
       cg7ia: // global
           _sg5ta::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cg7i8_info;
           R2 = P64[Sp + 32];
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _sg5ta::P64;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug7is: // global
           Sp = Sp + 48;
           call _cg7io() args: 0, res: 0, upd: 0;
     }
 },
 _cg7i8() //  [R1]
         { info_tbl: [(cg7i8,
                       label: block_cg7i8_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7i8: // global
           if (R1 & 7 == 3) goto ug7iu; else goto ug7iv;
       ug7iu: // global
           Sp = Sp + 32;
           call _cg7io() args: 0, res: 0, upd: 0;
       ug7iv: // global
           Sp = Sp + 8;
           call _cg7ig() args: 0, res: 0, upd: 0;
     }
 },
 _cg7ig() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ig: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg7io() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7io: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.424071295 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$cmin_closure" {
     Data.Functor.Product.$fOrdProduct_$cmin_closure:
         const Data.Functor.Product.$fOrdProduct_$cmin_info;
 },
 comp_sg5tp_entry() //  [R1]
         { info_tbl: [(cg7iU,
                       label: comp_sg5tp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7iU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7iV; else goto cg7iW;
       cg7iV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7iW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$cmin_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cg7iX,
                       label: Data.Functor.Product.$fOrdProduct_$cmin_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7iX: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cg7iY; else goto cg7iZ;
       cg7iY: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$cmin_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7iZ: // global
           I64[Sp - 40] = block_cg7iG_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7jC; else goto cg7iH;
       ug7jC: // global
           call _cg7iG(R1) args: 0, res: 0, upd: 0;
       cg7iH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7iG() //  [R1]
         { info_tbl: [(cg7iG,
                       label: block_cg7iG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7iG: // global
           I64[Sp - 16] = block_cg7iL_info;
           _sg5tj::P64 = R1;
           _sg5tk::P64 = P64[R1 + 7];
           _sg5tl::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _sg5tl::P64;
           P64[Sp] = _sg5tk::P64;
           P64[Sp + 32] = _sg5tj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ug7jB; else goto cg7iM;
       ug7jB: // global
           call _cg7iL(R1) args: 0, res: 0, upd: 0;
       cg7iM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7iL() //  [R1]
         { info_tbl: [(cg7iL,
                       label: block_cg7iL_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7iL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg7j4; else goto cg7j3;
       cg7j4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7j3: // global
           _sg5tn::P64 = P64[R1 + 7];
           _sg5to::P64 = P64[R1 + 15];
           I64[Hp - 16] = comp_sg5tp_info;
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_cg7j1_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_ppp_info;
           _cg7iQ::P64 = Hp - 16;
           P64[Sp - 24] = _cg7iQ::P64;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = _sg5tn::P64;
           P64[Sp + 16] = _sg5to::P64;
           P64[Sp + 24] = R1;
           P64[Sp + 40] = _cg7iQ::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg7j1() //  [R1]
         { info_tbl: [(cg7j1,
                       label: block_cg7j1_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7j1: // global
           _cg7ju::P64 = R1 & 7;
           if (_cg7ju::P64 < 3) goto ug7jw; else goto ug7jx;
       ug7jw: // global
           if (_cg7ju::P64 < 2) goto ug7jy; else goto cg7jf;
       ug7jy: // global
           Sp = Sp + 48;
           call _cg7jl() args: 0, res: 0, upd: 0;
       cg7jf: // global
           _sg5to::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cg7jd_info;
           R2 = P64[Sp + 32];
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _sg5to::P64;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug7jx: // global
           Sp = Sp + 24;
           call _cg7jt() args: 0, res: 0, upd: 0;
     }
 },
 _cg7jd() //  [R1]
         { info_tbl: [(cg7jd,
                       label: block_cg7jd_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7jd: // global
           if (R1 & 7 == 3) goto ug7jz; else goto ug7jA;
       ug7jz: // global
           Sp = Sp + 8;
           call _cg7jt() args: 0, res: 0, upd: 0;
       ug7jA: // global
           Sp = Sp + 32;
           call _cg7jl() args: 0, res: 0, upd: 0;
     }
 },
 _cg7jl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7jl: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg7jt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7jt: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.428061455 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_closure" {
     Data.Functor.Product.$fOrdProduct_closure:
         const Data.Functor.Product.$fOrdProduct_info;
 },
 sat_sg5tC_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7jQ,
                       label: sat_sg5tC_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7jQ: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$cmin_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tB_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7jY,
                       label: sat_sg5tB_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7jY: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$cmax_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tA_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7k6,
                       label: sat_sg5tA_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7k6: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c>=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tz_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7ke,
                       label: sat_sg5tz_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ke: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c>_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5ty_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7km,
                       label: sat_sg5ty_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7km: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c<=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tx_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7ku,
                       label: sat_sg5tx_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ku: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c<_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tw_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7kC,
                       label: sat_sg5tw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7kC: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$ccompare_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tv_entry() //  [R1]
         { info_tbl: [(cg7kJ,
                       label: sat_sg5tv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7kJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7kK; else goto cg7kL;
       cg7kK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7kL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fOrdProduct_$cp1Ord_entry(R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cg7kN,
                       label: Data.Functor.Product.$fOrdProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7kN: // global
           Hp = Hp + 336;
           if (Hp > HpLim) (likely: False) goto cg7kR; else goto cg7kQ;
       cg7kR: // global
           HpAlloc = 336;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7kQ: // global
           I64[Hp - 328] = sat_sg5tC_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           I64[Hp - 296] = sat_sg5tB_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           P64[Hp - 272] = R4;
           I64[Hp - 264] = sat_sg5tA_info;
           P64[Hp - 256] = R2;
           P64[Hp - 248] = R3;
           P64[Hp - 240] = R4;
           I64[Hp - 232] = sat_sg5tz_info;
           P64[Hp - 224] = R2;
           P64[Hp - 216] = R3;
           P64[Hp - 208] = R4;
           I64[Hp - 200] = sat_sg5ty_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           P64[Hp - 176] = R4;
           I64[Hp - 168] = sat_sg5tx_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = sat_sg5tw_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sat_sg5tv_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 104;
           P64[Hp - 48] = Hp - 134;
           P64[Hp - 40] = Hp - 166;
           P64[Hp - 32] = Hp - 198;
           P64[Hp - 24] = Hp - 230;
           P64[Hp - 16] = Hp - 262;
           P64[Hp - 8] = Hp - 294;
           P64[Hp] = Hp - 326;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.433147714 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadPrec_closure" {
     Data.Functor.Product.$fReadProduct_$creadPrec_closure:
         const Data.Functor.Product.$fReadProduct_$creadPrec_info;
         const 0;
 },
 sat_sg5tH_entry() //  [R1]
         { info_tbl: [(cg7l0,
                       label: sat_sg5tH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7l0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7l1; else goto cg7l2;
       cg7l1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7l2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tG_entry() //  [R1]
         { info_tbl: [(cg7l7,
                       label: sat_sg5tG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7l7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7l8; else goto cg7l9;
       cg7l8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7l9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cg7la,
                       label: Data.Functor.Product.$fReadProduct_$creadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7la: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg7le; else goto cg7ld;
       cg7le: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7ld: // global
           I64[Hp - 40] = sat_sg5tH_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sg5tG_info;
           P64[Hp] = R4;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.435482542 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadsPrec_closure" {
     Data.Functor.Product.$fReadProduct_$creadsPrec_closure:
         const Data.Functor.Product.$fReadProduct_$creadsPrec_info;
         const 0;
 },
 sat_sg5tN_entry() //  [R1]
         { info_tbl: [(cg7lr,
                       label: sat_sg5tN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7lr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7ls; else goto cg7lt;
       cg7ls: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7lt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tM_entry() //  [R1]
         { info_tbl: [(cg7ly,
                       label: sat_sg5tM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ly: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7lz; else goto cg7lA;
       cg7lz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7lA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sg5tL_entry() //  [R1]
         { info_tbl: [(cg7lB,
                       label: ds_sg5tL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7lB: // global
           _sg5tL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg7lC; else goto cg7lD;
       cg7lD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg7lF; else goto cg7lE;
       cg7lF: // global
           HpAlloc = 48;
           goto cg7lC;
       cg7lC: // global
           R1 = _sg5tL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7lE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5tL::P64;
           _sg5tI::P64 = P64[_sg5tL::P64 + 16];
           _sg5tJ::P64 = P64[_sg5tL::P64 + 24];
           _sg5tK::P64 = P64[_sg5tL::P64 + 32];
           I64[Hp - 40] = sat_sg5tN_info;
           P64[Hp - 24] = _sg5tK::P64;
           I64[Hp - 16] = sat_sg5tM_info;
           P64[Hp] = _sg5tK::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sg5tJ::P64;
           R2 = _sg5tI::P64;
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tP_entry() //  [R1]
         { info_tbl: [(cg7lP,
                       label: sat_sg5tP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7lP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7lQ; else goto cg7lR;
       cg7lQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7lR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tQ_entry() //  [R1, R2]
         { info_tbl: [(cg7lS,
                       label: sat_sg5tQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7lS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg7lW; else goto cg7lV;
       cg7lW: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7lV: // global
           _sg5tL::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sg5tP_info;
           P64[Hp - 8] = _sg5tL::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cg7lX,
                       label: Data.Functor.Product.$fReadProduct_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7lX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg7m1; else goto cg7m0;
       cg7m1: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7m0: // global
           I64[Hp - 48] = ds_sg5tL_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sg5tQ_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.438371203 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadListPrec_closure" {
     Data.Functor.Product.$fReadProduct_$creadListPrec_closure:
         const Data.Functor.Product.$fReadProduct_$creadListPrec_info;
         const 0;
 },
 sat_sg5tV_entry() //  [R1]
         { info_tbl: [(cg7me,
                       label: sat_sg5tV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7me: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7mf; else goto cg7mg;
       cg7mf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7mg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tU_entry() //  [R1]
         { info_tbl: [(cg7ml,
                       label: sat_sg5tU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ml: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7mm; else goto cg7mn;
       cg7mm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7mn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tW_entry() //  [R1]
         { info_tbl: [(cg7mo,
                       label: sat_sg5tW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7mo: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg7ms; else goto cg7mr;
       cg7ms: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7mr: // global
           _sg5tR::P64 = P64[R1 + 16];
           _sg5tS::P64 = P64[R1 + 24];
           _sg5tT::P64 = P64[R1 + 32];
           I64[Hp - 40] = sat_sg5tV_info;
           P64[Hp - 24] = _sg5tT::P64;
           I64[Hp - 16] = sat_sg5tU_info;
           P64[Hp] = _sg5tT::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sg5tS::P64;
           R2 = _sg5tR::P64;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadListPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cg7mt,
                       label: Data.Functor.Product.$fReadProduct_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7mt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg7mx; else goto cg7mw;
       cg7mx: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7mw: // global
           I64[Hp - 32] = sat_sg5tW_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.440427082 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadList_closure" {
     Data.Functor.Product.$fReadProduct_$creadList_closure:
         const Data.Functor.Product.$fReadProduct_$creadList_info;
         const 0;
 },
 sat_sg5u0_entry() //  [R1]
         { info_tbl: [(cg7mG,
                       label: sat_sg5u0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7mG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7mH; else goto cg7mI;
       cg7mH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7mI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call Data.Functor.Product.$fReadProduct_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadList_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cg7mJ,
                       label: Data.Functor.Product.$fReadProduct_$creadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7mJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg7mN; else goto cg7mM;
       cg7mN: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7mM: // global
           I64[Hp - 32] = sat_sg5u0_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.442431581 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_closure" {
     Data.Functor.Product.$fReadProduct_closure:
         const Data.Functor.Product.$fReadProduct_info;
         const 0;
 },
 sat_sg5u7_entry() //  [R1]
         { info_tbl: [(cg7mW,
                       label: sat_sg5u7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7mW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7mX; else goto cg7mY;
       cg7mX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7mY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5u6_entry() //  [R1]
         { info_tbl: [(cg7n3,
                       label: sat_sg5u6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7n3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7n4; else goto cg7n5;
       cg7n4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7n5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5u5_entry() //  [R1]
         { info_tbl: [(cg7na,
                       label: sat_sg5u5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7na: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7nb; else goto cg7nc;
       cg7nb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7nc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadList_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5u4_entry() //  [R1]
         { info_tbl: [(cg7nh,
                       label: sat_sg5u4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7nh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7ni; else goto cg7nj;
       cg7ni: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7nj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadsPrec_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fReadProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cg7nl,
                       label: Data.Functor.Product.$fReadProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7nl: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cg7np; else goto cg7no;
       cg7np: // global
           HpAlloc = 200;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7no: // global
           I64[Hp - 192] = sat_sg5u7_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           I64[Hp - 152] = sat_sg5u6_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_sg5u5_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sg5u4_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.445420458 UTC

[section ""data" . Data.Functor.Product.$w$cshowsPrec_closure" {
     Data.Functor.Product.$w$cshowsPrec_closure:
         const Data.Functor.Product.$w$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7nr: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cshowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 16, res: 0, upd: 8;
     }
 },
 sp_sg5ue_entry() //  [R1]
         { info_tbl: [(cg7nz,
                       label: sp_sg5ue_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7nz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7nA; else goto cg7nB;
       cg7nA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7nB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sl_sg5uf_entry() //  [R1]
         { info_tbl: [(cg7nG,
                       label: sl_sg5uf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7nG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7nH; else goto cg7nI;
       cg7nH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7nI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5uh_entry() //  [R1]
         { info_tbl: [(cg7nN,
                       label: sat_sg5uh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7nN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg7nO; else goto cg7nP;
       cg7nO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7nP: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5ug_entry() //  [R1]
         { info_tbl: [(cg7nU,
                       label: sat_sg5ug_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7nU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg7nV; else goto cg7nW;
       cg7nV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7nW: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cshowsPrec_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7nX,
                       label: Data.Functor.Product.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7nX: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg7o1; else goto cg7o0;
       cg7o1: // global
           HpAlloc = 128;
           R1 = Data.Functor.Product.$w$cshowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cg7o0: // global
           I64[Hp - 120] = sp_sg5ue_info;
           P64[Hp - 104] = R4;
           I64[Hp - 96] = sl_sg5uf_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sg5uh_info;
           P64[Hp - 56] = R3;
           _cg7nv::P64 = Hp - 120;
           P64[Hp - 48] = _cg7nv::P64;
           _cg7nC::P64 = Hp - 96;
           P64[Hp - 40] = _cg7nC::P64;
           I64[Hp - 32] = sat_sg5ug_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cg7nv::P64;
           P64[Hp] = _cg7nC::P64;
           R6 = R6;
           R5 = R5;
           R4 = Data.Functor.Product.$fRead1Product2_closure;
           R3 = Hp - 72;
           R2 = Hp - 32;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.44798448 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_$cshowsPrec_closure" {
     Data.Functor.Product.$fShowProduct_$cshowsPrec_closure:
         const Data.Functor.Product.$fShowProduct_$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$fShowProduct_$cshowsPrec_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cg7o9,
                       label: Data.Functor.Product.$fShowProduct_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7o9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7od; else goto cg7oe;
       cg7od: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_$cshowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7oe: // global
           I64[Sp - 40] = block_cg7o6_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7om; else goto cg7o7;
       ug7om: // global
           call _cg7o6(R1) args: 0, res: 0, upd: 0;
       cg7o7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7o6() //  [R1]
         { info_tbl: [(cg7o6,
                       label: block_cg7o6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7o6: // global
           I64[Sp] = block_cg7oc_info;
           _sg5uo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sg5uo::I64;
           if (R1 & 7 != 0) goto ug7ol; else goto cg7og;
       ug7ol: // global
           call _cg7oc(R1) args: 0, res: 0, upd: 0;
       cg7og: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7oc() //  [R1]
         { info_tbl: [(cg7oc,
                       label: block_cg7oc_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7oc: // global
           R6 = P64[R1 + 7];
           R5 = I64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cshowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.450240173 UTC

[section ""data" . Data.Functor.Product.$w$cshow_closure" {
     Data.Functor.Product.$w$cshow_closure:
         const Data.Functor.Product.$w$cshow_info;
         const 0;
 },
 sp_sg5ux_entry() //  [R1]
         { info_tbl: [(cg7ov,
                       label: sp_sg5ux_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ov: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7ow; else goto cg7ox;
       cg7ow: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7ox: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sl_sg5uy_entry() //  [R1]
         { info_tbl: [(cg7oC,
                       label: sl_sg5uy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7oC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7oD; else goto cg7oE;
       cg7oD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7oE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5uz_entry() //  [R1]
         { info_tbl: [(cg7oN,
                       label: sat_sg5uz_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7oN: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cg7oO; else goto cg7oP;
       cg7oO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7oP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = P64[R1 + 32];
           P64[Sp - 48] = P64[R1 + 40];
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 sat_sg5uB_entry() //  [R1]
         { info_tbl: [(cg7oR,
                       label: sat_sg5uB_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7oR: // global
           _sg5uB::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cg7oS; else goto cg7oT;
       cg7oT: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg7oV; else goto cg7oU;
       cg7oV: // global
           HpAlloc = 72;
           goto cg7oS;
       cg7oS: // global
           R1 = _sg5uB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7oU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5uB::P64;
           _sg5us::P64 = P64[_sg5uB::P64 + 16];
           _sg5ut::P64 = P64[_sg5uB::P64 + 24];
           _sg5uv::P64 = P64[_sg5uB::P64 + 32];
           _sg5uw::P64 = P64[_sg5uB::P64 + 40];
           _sg5ux::P64 = P64[_sg5uB::P64 + 48];
           _sg5uy::P64 = P64[_sg5uB::P64 + 56];
           I64[Hp - 64] = sat_sg5uz_info;
           P64[Hp - 48] = _sg5ut::P64;
           P64[Hp - 40] = _sg5uw::P64;
           P64[Hp - 32] = _sg5ux::P64;
           P64[Hp - 24] = _sg5uy::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 64;
           R2 = _sg5us::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = _sg5ux::P64;
           P64[Sp - 48] = _sg5uy::P64;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sg5uv::P64;
           P64[Sp - 24] = Hp - 14;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cshow_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7oX,
                       label: Data.Functor.Product.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7oX: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cg7p1; else goto cg7p0;
       cg7p1: // global
           HpAlloc = 136;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$cshow_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7p0: // global
           I64[Hp - 128] = sp_sg5ux_info;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sl_sg5uy_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_sg5uB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = R6;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 80;
           R3 = Hp - 14;
           R2 = Data.Functor.Product.$fRead1Product2_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.452775924 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_$cshow_closure" {
     Data.Functor.Product.$fShowProduct_$cshow_closure:
         const Data.Functor.Product.$fShowProduct_$cshow_info;
         const 0;
 },
 Data.Functor.Product.$fShowProduct_$cshow_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cg7p9,
                       label: Data.Functor.Product.$fShowProduct_$cshow_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7p9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7pa; else goto cg7pb;
       cg7pa: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_$cshow_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7pb: // global
           I64[Sp - 32] = block_cg7p6_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7pf; else goto cg7p7;
       ug7pf: // global
           call _cg7p6(R1) args: 0, res: 0, upd: 0;
       cg7p7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7p6() //  [R1]
         { info_tbl: [(cg7p6,
                       label: block_cg7p6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7p6: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cshow_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.454991919 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_$cshowList_closure" {
     Data.Functor.Product.$fShowProduct_$cshowList_closure:
         const Data.Functor.Product.$fShowProduct_$cshowList_info;
         const 0;
 },
 lvl9_sg5uP_entry() //  [R1]
         { info_tbl: [(cg7po,
                       label: lvl9_sg5uP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7po: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7pp; else goto cg7pq;
       cg7pp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7pq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl10_sg5uQ_entry() //  [R1]
         { info_tbl: [(cg7pv,
                       label: lvl10_sg5uQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7pv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7pw; else goto cg7px;
       cg7pw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7px: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5uV_entry() //  [R1, R2]
         { info_tbl: [(cg7pG,
                       label: sat_sg5uV_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7pG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7pH; else goto cg7pI;
       cg7pH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7pI: // global
           I64[Sp - 40] = block_cg7pD_info;
           _sg5uK::P64 = P64[R1 + 7];
           _sg5uL::P64 = P64[R1 + 15];
           _sg5uP::P64 = P64[R1 + 23];
           _sg5uQ::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5uK::P64;
           P64[Sp - 24] = _sg5uL::P64;
           P64[Sp - 16] = _sg5uP::P64;
           P64[Sp - 8] = _sg5uQ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7pM; else goto cg7pE;
       ug7pM: // global
           call _cg7pD(R1) args: 0, res: 0, upd: 0;
       cg7pE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7pD() //  [R1]
         { info_tbl: [(cg7pD,
                       label: block_cg7pD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7pD: // global
           R6 = 0;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShowProduct_$cshowList_entry() //  [R2, R3,
                                                            R4, R5, R6]
         { info_tbl: [(cg7pN,
                       label: Data.Functor.Product.$fShowProduct_$cshowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7pN: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg7pR; else goto cg7pQ;
       cg7pR: // global
           HpAlloc = 88;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_$cshowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7pQ: // global
           I64[Hp - 80] = lvl9_sg5uP_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl10_sg5uQ_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5uV_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 31;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.457771076 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_closure" {
     Data.Functor.Product.$fShowProduct_closure:
         const Data.Functor.Product.$fShowProduct_info;
         const 0;
 },
 sat_sg5v1_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7q1,
                       label: sat_sg5v1_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7q1: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fShowProduct_$cshowList_entry(R6,
                                                                    R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5v0_entry() //  [R1, R2]
         { info_tbl: [(cg7q9,
                       label: sat_sg5v0_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7q9: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fShowProduct_$cshow_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5uZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7qh,
                       label: sat_sg5uZ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7qh: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fShowProduct_$cshowsPrec_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShowProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cg7ql,
                       label: Data.Functor.Product.$fShowProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ql: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg7qp; else goto cg7qo;
       cg7qp: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7qo: // global
           I64[Hp - 120] = sat_sg5v1_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sg5v0_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sg5uZ_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 118;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.460119348 UTC

[section ""data" . Data.Functor.Product.$fFunctorProduct_$cfmap_closure" {
     Data.Functor.Product.$fFunctorProduct_$cfmap_closure:
         const Data.Functor.Product.$fFunctorProduct_$cfmap_info;
 },
 sat_sg5va_entry() //  [R1]
         { info_tbl: [(cg7qD,
                       label: sat_sg5va_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7qD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7qE; else goto cg7qF;
       cg7qE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7qF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5v9_entry() //  [R1]
         { info_tbl: [(cg7qK,
                       label: sat_sg5v9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7qK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7qL; else goto cg7qM;
       cg7qL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7qM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFunctorProduct_$cfmap_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cg7qN,
                       label: Data.Functor.Product.$fFunctorProduct_$cfmap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7qN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7qP; else goto cg7qQ;
       cg7qP: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFunctorProduct_$cfmap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7qQ: // global
           I64[Sp - 32] = block_cg7qu_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7qU; else goto cg7qv;
       ug7qU: // global
           call _cg7qu(R1) args: 0, res: 0, upd: 0;
       cg7qv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7qu() //  [R1]
         { info_tbl: [(cg7qu,
                       label: block_cg7qu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7qu: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg7qT; else goto cg7qS;
       cg7qT: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7qS: // global
           _sg5v7::P64 = P64[R1 + 7];
           _sg5v8::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5va_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sg5v4::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sg5v4::P64;
           P64[Hp - 64] = _sg5v8::P64;
           I64[Hp - 56] = sat_sg5v9_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg5v4::P64;
           P64[Hp - 24] = _sg5v7::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.462800771 UTC

[section ""data" . Data.Functor.Product.$fFunctorProduct_$c<$_closure" {
     Data.Functor.Product.$fFunctorProduct_$c<$_closure:
         const Data.Functor.Product.$fFunctorProduct_$c<$_info;
 },
 f1_sg5vi_entry() //  [R1]
         { info_tbl: [(cg7r9,
                       label: f1_sg5vi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7r9: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5vl_entry() //  [R1]
         { info_tbl: [(cg7rg,
                       label: sat_sg5vl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7rg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7rh; else goto cg7ri;
       cg7rh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7ri: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5vk_entry() //  [R1]
         { info_tbl: [(cg7rn,
                       label: sat_sg5vk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7rn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7ro; else goto cg7rp;
       cg7ro: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7rp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFunctorProduct_$c<$_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cg7rq,
                       label: Data.Functor.Product.$fFunctorProduct_$c<$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7rq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7rs; else goto cg7rt;
       cg7rs: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFunctorProduct_$c<$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7rt: // global
           I64[Sp - 32] = block_cg7qZ_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7rx; else goto cg7r0;
       ug7rx: // global
           call _cg7qZ(R1) args: 0, res: 0, upd: 0;
       cg7r0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7qZ() //  [R1]
         { info_tbl: [(cg7qZ,
                       label: block_cg7qZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7qZ: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cg7rw; else goto cg7rv;
       cg7rw: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7rv: // global
           _sg5vg::P64 = P64[R1 + 7];
           _sg5vh::P64 = P64[R1 + 15];
           I64[Hp - 112] = f1_sg5vi_info;
           P64[Hp - 104] = P64[Sp + 24];
           I64[Hp - 96] = sat_sg5vl_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sg5vh::P64;
           _cg7r4::P64 = Hp - 111;
           P64[Hp - 64] = _cg7r4::P64;
           I64[Hp - 56] = sat_sg5vk_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg5vg::P64;
           P64[Hp - 24] = _cg7r4::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.466688315 UTC

[section ""data" . Data.Functor.Product.$fFunctorProduct_closure" {
     Data.Functor.Product.$fFunctorProduct_closure:
         const Data.Functor.Product.$fFunctorProduct_info;
 },
 sat_sg5vp_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7rH,
                       label: sat_sg5vp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7rH: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFunctorProduct_$c<$_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5vo_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7rP,
                       label: sat_sg5vo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7rP: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFunctorProduct_$cfmap_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFunctorProduct_entry() //  [R2, R3]
         { info_tbl: [(cg7rT,
                       label: Data.Functor.Product.$fFunctorProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7rT: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg7rX; else goto cg7rW;
       cg7rX: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFunctorProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7rW: // global
           I64[Hp - 64] = sat_sg5vp_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5vo_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.468433295 UTC

[section ""data" . Data.Functor.Product.$w$cfoldMap_closure" {
     Data.Functor.Product.$w$cfoldMap_closure:
         const Data.Functor.Product.$w$cfoldMap_info;
 },
 sat_sg5vx_entry() //  [R1]
         { info_tbl: [(cg7s6,
                       label: sat_sg5vx_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7s6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7s7; else goto cg7s8;
       cg7s7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7s8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5vw_entry() //  [R1]
         { info_tbl: [(cg7sd,
                       label: sat_sg5vw_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7sd: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7se; else goto cg7sf;
       cg7se: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7sf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldMap_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7sg,
                       label: Data.Functor.Product.$w$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7sg: // global
           _sg5vu::P64 = R6;
           _sg5vt::P64 = R5;
           _sg5vs::P64 = R4;
           _sg5vr::P64 = R3;
           _sg5vq::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cg7sh; else goto cg7si;
       cg7si: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cg7sk; else goto cg7sj;
       cg7sk: // global
           HpAlloc = 96;
           goto cg7sh;
       cg7sh: // global
           R6 = _sg5vu::P64;
           R5 = _sg5vt::P64;
           R4 = _sg5vs::P64;
           R3 = _sg5vr::P64;
           R2 = _sg5vq::P64;
           R1 = Data.Functor.Product.$w$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg7sj: // global
           I64[Hp - 88] = sat_sg5vx_info;
           P64[Hp - 72] = _sg5vr::P64;
           P64[Hp - 64] = _sg5vs::P64;
           P64[Hp - 56] = _sg5vt::P64;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = sat_sg5vw_info;
           P64[Hp - 24] = _sg5vq::P64;
           P64[Hp - 16] = _sg5vs::P64;
           P64[Hp - 8] = _sg5vt::P64;
           P64[Hp] = _sg5vu::P64;
           R2 = _sg5vs::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = Hp - 40;
           P64[Sp] = Hp - 88;
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.470337529 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldMap_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldMap_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldMap_info;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldMap_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cg7ss,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ss: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7st; else goto cg7su;
       cg7st: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7su: // global
           I64[Sp - 40] = block_cg7sp_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7sy; else goto cg7sq;
       ug7sy: // global
           call _cg7sp(R1) args: 0, res: 0, upd: 0;
       cg7sq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7sp() //  [R1]
         { info_tbl: [(cg7sp,
                       label: block_cg7sp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7sp: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldMap_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.471803151 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfold_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfold_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfold_info;
 },
 Data.Functor.Product.$fFoldableProduct_$cfold_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cg7sG,
                       label: Data.Functor.Product.$fFoldableProduct_$cfold_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7sG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7sH; else goto cg7sI;
       cg7sH: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfold_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7sI: // global
           I64[Sp - 32] = block_cg7sD_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7sM; else goto cg7sE;
       ug7sM: // global
           call _cg7sD(R1) args: 0, res: 0, upd: 0;
       cg7sE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7sD() //  [R1]
         { info_tbl: [(cg7sD,
                       label: block_cg7sD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7sD: // global
           R6 = P64[R1 + 7];
           R5 = GHC.Base.id_closure+1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$cfoldMap_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.473048286 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct1_closure" {
     Data.Functor.Product.$fFoldableProduct1_closure:
         const Data.Functor.Product.$fFoldableProduct1_info;
 },
 Data.Functor.Product.$fFoldableProduct1_entry() //  [R2]
         { info_tbl: [(cg7sR,
                       label: Data.Functor.Product.$fFoldableProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7sR: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.474750466 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$csum_closure" {
     Data.Functor.Product.$fFoldableProduct_$csum_closure:
         const Data.Functor.Product.$fFoldableProduct_$csum_info;
         const 0;
 },
 $dMonoid_sg5vR_entry() //  [R1]
         { info_tbl: [(cg7t2,
                       label: $dMonoid_sg5vR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7t2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7t3; else goto cg7t4;
       cg7t3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7t4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5vX_entry() //  [R1]
         { info_tbl: [(cg7tj,
                       label: sat_sg5vX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7tj: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7tk; else goto cg7tl;
       cg7tk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7tl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5vW_entry() //  [R1]
         { info_tbl: [(cg7tq,
                       label: sat_sg5vW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7tq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7tr; else goto cg7ts;
       cg7tr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7ts: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5vY_entry() //  [R1, R2]
         { info_tbl: [(cg7tt,
                       label: sat_sg5vY_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7tt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7tu; else goto cg7tv;
       cg7tu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7tv: // global
           I64[Sp - 40] = block_cg7ta_info;
           _sg5vO::P64 = P64[R1 + 7];
           _sg5vP::P64 = P64[R1 + 15];
           _sg5vQ::P64 = P64[R1 + 23];
           _sg5vR::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5vO::P64;
           P64[Sp - 24] = _sg5vP::P64;
           P64[Sp - 16] = _sg5vQ::P64;
           P64[Sp - 8] = _sg5vR::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7tz; else goto cg7tb;
       ug7tz: // global
           call _cg7ta(R1) args: 0, res: 0, upd: 0;
       cg7tb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7ta() //  [R1]
         { info_tbl: [(cg7ta,
                       label: block_cg7ta_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ta: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg7ty; else goto cg7tx;
       cg7ty: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7tx: // global
           _sg5vU::P64 = P64[R1 + 7];
           _sg5vV::P64 = P64[R1 + 15];
           I64[Hp - 72] = sat_sg5vX_info;
           P64[Hp - 56] = P64[Sp + 16];
           _sg5vR::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sg5vR::P64;
           P64[Hp - 40] = _sg5vV::P64;
           I64[Hp - 32] = sat_sg5vW_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sg5vR::P64;
           P64[Hp] = _sg5vU::P64;
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$csum_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cg7tA,
                       label: Data.Functor.Product.$fFoldableProduct_$csum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7tA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg7tE; else goto cg7tD;
       cg7tE: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$csum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7tD: // global
           I64[Hp - 56] = $dMonoid_sg5vR_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5vY_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.4772157 UTC

[section ""cstring" . lvl_rg5nW_bytes" {
     lvl_rg5nW_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.478073827 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct2_closure" {
     Data.Functor.Product.$fFoldableProduct2_closure:
         const Data.Functor.Product.$fFoldableProduct2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct2_entry() //  [R1]
         { info_tbl: [(cg7tN,
                       label: Data.Functor.Product.$fFoldableProduct2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7tN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg7tO; else goto cg7tP;
       cg7tO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7tP: // global
           (_cg7tI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg7tI::I64 == 0) goto cg7tK; else goto cg7tJ;
       cg7tK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg7tJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg7tI::I64;
           I64[Sp - 24] = block_cg7tL_info;
           R2 = lvl_rg5nW_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg7tL() //  [R1]
         { info_tbl: [(cg7tL,
                       label: block_cg7tL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7tL: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.480236859 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cminimum_closure" {
     Data.Functor.Product.$fFoldableProduct_$cminimum_closure:
         const Data.Functor.Product.$fFoldableProduct_$cminimum_info;
         const 0;
 },
 $dMonoid_sg5w3_entry() //  [R1]
         { info_tbl: [(cg7u1,
                       label: $dMonoid_sg5w3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7u1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7u2; else goto cg7u3;
       cg7u2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7u3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5wf_entry() //  [R1, R2]
         { info_tbl: [(cg7uc,
                       label: sat_sg5wf_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7uc: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cg7ud; else goto cg7ue;
       cg7ud: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7ue: // global
           I64[Sp - 40] = block_cg7u9_info;
           _sg5w0::P64 = P64[R1 + 7];
           _sg5w1::P64 = P64[R1 + 15];
           _sg5w2::P64 = P64[R1 + 23];
           _sg5w3::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5w0::P64;
           P64[Sp - 24] = _sg5w1::P64;
           P64[Sp - 16] = _sg5w2::P64;
           P64[Sp - 8] = _sg5w3::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7v6; else goto cg7ua;
       ug7v6: // global
           call _cg7u9(R1) args: 0, res: 0, upd: 0;
       cg7ua: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7u9() //  [R1]
         { info_tbl: [(cg7u9,
                       label: block_cg7u9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7u9: // global
           I64[Sp] = block_cg7uh_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = GHC.Base.Just_closure+1;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg7uh() //  [R1]
         { info_tbl: [(cg7uh,
                       label: block_cg7uh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7uh: // global
           _sg5w0::P64 = P64[Sp + 8];
           _sg5w3::P64 = P64[Sp + 32];
           _sg5w6::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg7up; else goto cg7uE;
       cg7up: // global
           I64[Sp + 32] = block_cg7um_info;
           R2 = _sg5w0::P64;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sg5w3::P64;
           P64[Sp + 16] = GHC.Base.Just_closure+1;
           P64[Sp + 24] = _sg5w6::P64;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cg7uE: // global
           I64[Sp + 16] = block_cg7uC_info;
           R2 = _sg5w0::P64;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = _sg5w3::P64;
           P64[Sp] = GHC.Base.Just_closure+1;
           P64[Sp + 8] = _sg5w6::P64;
           P64[Sp + 32] = P64[R1 + 6];
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg7um() //  [R1]
         { info_tbl: [(cg7um,
                       label: block_cg7um_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7um: // global
           if (R1 & 7 == 1) goto cg7uv; else goto cg7uz;
       cg7uv: // global
           R1 = Data.Functor.Product.$fFoldableProduct2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg7uz: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg7uC() //  [R1]
         { info_tbl: [(cg7uC,
                       label: block_cg7uC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7uC: // global
           if (R1 & 7 == 1) goto ug7v4; else goto cg7uP;
       ug7v4: // global
           Sp = Sp + 16;
           call _cg7uV() args: 0, res: 0, upd: 0;
       cg7uP: // global
           I64[Sp] = block_cg7uN_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           _sg5wd::P64 = P64[R1 + 6];
           P64[Sp - 16] = _sg5wd::P64;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = _sg5wd::P64;
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cg7uN() //  [R1]
         { info_tbl: [(cg7uN,
                       label: block_cg7uN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7uN: // global
           if (R1 & 7 == 1) goto ug7v5; else goto cg7uZ;
       ug7v5: // global
           Sp = Sp + 16;
           call _cg7uV() args: 0, res: 0, upd: 0;
       cg7uZ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg7uV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7uV: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cminimum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg7v9,
                       label: Data.Functor.Product.$fFoldableProduct_$cminimum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7v9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg7vd; else goto cg7vc;
       cg7vd: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cminimum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7vc: // global
           I64[Hp - 56] = $dMonoid_sg5w3_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5wf_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.483065346 UTC

[section ""cstring" . lvl1_rg5nX_bytes" {
     lvl1_rg5nX_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.483878117 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct3_closure" {
     Data.Functor.Product.$fFoldableProduct3_closure:
         const Data.Functor.Product.$fFoldableProduct3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct3_entry() //  [R1]
         { info_tbl: [(cg7vm,
                       label: Data.Functor.Product.$fFoldableProduct3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7vm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg7vn; else goto cg7vo;
       cg7vn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7vo: // global
           (_cg7vh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg7vh::I64 == 0) goto cg7vj; else goto cg7vi;
       cg7vj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg7vi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg7vh::I64;
           I64[Sp - 24] = block_cg7vk_info;
           R2 = lvl1_rg5nX_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg7vk() //  [R1]
         { info_tbl: [(cg7vk,
                       label: block_cg7vk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7vk: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.485953525 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cmaximum_closure" {
     Data.Functor.Product.$fFoldableProduct_$cmaximum_closure:
         const Data.Functor.Product.$fFoldableProduct_$cmaximum_info;
         const 0;
 },
 $dMonoid_sg5wk_entry() //  [R1]
         { info_tbl: [(cg7vA,
                       label: $dMonoid_sg5wk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7vA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7vB; else goto cg7vC;
       cg7vB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7vC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5ww_entry() //  [R1, R2]
         { info_tbl: [(cg7vL,
                       label: sat_sg5ww_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7vL: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cg7vM; else goto cg7vN;
       cg7vM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7vN: // global
           I64[Sp - 40] = block_cg7vI_info;
           _sg5wh::P64 = P64[R1 + 7];
           _sg5wi::P64 = P64[R1 + 15];
           _sg5wj::P64 = P64[R1 + 23];
           _sg5wk::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5wh::P64;
           P64[Sp - 24] = _sg5wi::P64;
           P64[Sp - 16] = _sg5wj::P64;
           P64[Sp - 8] = _sg5wk::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7wF; else goto cg7vJ;
       ug7wF: // global
           call _cg7vI(R1) args: 0, res: 0, upd: 0;
       cg7vJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7vI() //  [R1]
         { info_tbl: [(cg7vI,
                       label: block_cg7vI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7vI: // global
           I64[Sp] = block_cg7vQ_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = GHC.Base.Just_closure+1;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg7vQ() //  [R1]
         { info_tbl: [(cg7vQ,
                       label: block_cg7vQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7vQ: // global
           _sg5wh::P64 = P64[Sp + 8];
           _sg5wk::P64 = P64[Sp + 32];
           _sg5wn::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg7vY; else goto cg7wd;
       cg7vY: // global
           I64[Sp + 32] = block_cg7vV_info;
           R2 = _sg5wh::P64;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sg5wk::P64;
           P64[Sp + 16] = GHC.Base.Just_closure+1;
           P64[Sp + 24] = _sg5wn::P64;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cg7wd: // global
           I64[Sp + 16] = block_cg7wb_info;
           R2 = _sg5wh::P64;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = _sg5wk::P64;
           P64[Sp] = GHC.Base.Just_closure+1;
           P64[Sp + 8] = _sg5wn::P64;
           P64[Sp + 32] = P64[R1 + 6];
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg7vV() //  [R1]
         { info_tbl: [(cg7vV,
                       label: block_cg7vV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7vV: // global
           if (R1 & 7 == 1) goto cg7w4; else goto cg7w8;
       cg7w4: // global
           R1 = Data.Functor.Product.$fFoldableProduct3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg7w8: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg7wb() //  [R1]
         { info_tbl: [(cg7wb,
                       label: block_cg7wb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7wb: // global
           if (R1 & 7 == 1) goto ug7wD; else goto cg7wo;
       ug7wD: // global
           Sp = Sp + 16;
           call _cg7wu() args: 0, res: 0, upd: 0;
       cg7wo: // global
           I64[Sp] = block_cg7wm_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           _sg5wu::P64 = P64[R1 + 6];
           P64[Sp - 16] = _sg5wu::P64;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = _sg5wu::P64;
           Sp = Sp - 24;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cg7wm() //  [R1]
         { info_tbl: [(cg7wm,
                       label: block_cg7wm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7wm: // global
           if (R1 & 7 == 1) goto ug7wE; else goto cg7wy;
       ug7wE: // global
           Sp = Sp + 16;
           call _cg7wu() args: 0, res: 0, upd: 0;
       cg7wy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg7wu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7wu: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cmaximum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg7wI,
                       label: Data.Functor.Product.$fFoldableProduct_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7wI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg7wM; else goto cg7wL;
       cg7wM: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cmaximum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7wL: // global
           I64[Hp - 56] = $dMonoid_sg5wk_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5ww_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.489697839 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$celem_closure" {
     Data.Functor.Product.$fFoldableProduct_$celem_closure:
         const Data.Functor.Product.$fFoldableProduct_$celem_info;
         const 0;
 },
 f1_sg5wB_entry() //  [R1]
         { info_tbl: [(cg7wV,
                       label: f1_sg5wB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7wV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7wW; else goto cg7wX;
       cg7wW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7wX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5wH_entry() //  [R1, R2]
         { info_tbl: [(cg7x6,
                       label: sat_sg5wH_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7x6: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cg7x7; else goto cg7x8;
       cg7x7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7x8: // global
           I64[Sp - 32] = block_cg7x3_info;
           _sg5wx::P64 = P64[R1 + 7];
           _sg5wy::P64 = P64[R1 + 15];
           _sg5wB::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sg5wx::P64;
           P64[Sp - 16] = _sg5wy::P64;
           P64[Sp - 8] = _sg5wB::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7xo; else goto cg7x4;
       ug7xo: // global
           call _cg7x3(R1) args: 0, res: 0, upd: 0;
       cg7x4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7x3() //  [R1]
         { info_tbl: [(cg7x3,
                       label: block_cg7x3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7x3: // global
           I64[Sp] = block_cg7xb_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 8] = P64[R1 + 15];
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg7xb() //  [R1]
         { info_tbl: [(cg7xb,
                       label: block_cg7xb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7xb: // global
           if (R1 & 7 == 1) goto cg7xi; else goto cg7xm;
       cg7xi: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           _sg5wF::P64 = P64[Sp + 8];
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = _sg5wF::P64;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg7xm: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$celem_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cg7xp,
                       label: Data.Functor.Product.$fFoldableProduct_$celem_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7xp: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg7xt; else goto cg7xs;
       cg7xt: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$celem_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7xs: // global
           I64[Hp - 56] = f1_sg5wB_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = sat_sg5wH_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.492055929 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct8_closure" {
     Data.Functor.Product.$fFoldableProduct8_closure:
         const Data.Functor.Product.$fFoldableProduct8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct8_entry() //  [R1]
         { info_tbl: [(cg7xA,
                       label: Data.Functor.Product.$fFoldableProduct8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7xA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7xB; else goto cg7xC;
       cg7xB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7xC: // global
           (_cg7xx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg7xx::I64 == 0) goto cg7xz; else goto cg7xy;
       cg7xz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg7xy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg7xx::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.49365481 UTC

[section ""data" . Data.Functor.Product.$w$cfoldl_closure" {
     Data.Functor.Product.$w$cfoldl_closure:
         const Data.Functor.Product.$w$cfoldl_info;
         const 0;
 },
 f1_sg5wO_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7xM,
                       label: f1_sg5wO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7xM: // global
           _sg5wQ::P64 = R3;
           R3 = R2;
           R2 = _sg5wQ::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5wR_entry() //  [R1]
         { info_tbl: [(cg7xT,
                       label: sat_sg5wR_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7xT: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg7xU; else goto cg7xV;
       cg7xU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7xV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7xW,
                       label: Data.Functor.Product.$w$cfoldl_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7xW: // global
           _sg5wM::P64 = R6;
           _sg5wL::P64 = R5;
           _sg5wK::P64 = R4;
           _sg5wJ::P64 = R3;
           _sg5wI::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cg7xX; else goto cg7xY;
       cg7xY: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg7y0; else goto cg7xZ;
       cg7y0: // global
           HpAlloc = 64;
           goto cg7xX;
       cg7xX: // global
           R6 = _sg5wM::P64;
           R5 = _sg5wL::P64;
           R4 = _sg5wK::P64;
           R3 = _sg5wJ::P64;
           R2 = _sg5wI::P64;
           R1 = Data.Functor.Product.$w$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg7xZ: // global
           I64[Hp - 56] = f1_sg5wO_info;
           P64[Hp - 48] = _sg5wK::P64;
           I64[Hp - 40] = sat_sg5wR_info;
           P64[Hp - 24] = _sg5wI::P64;
           P64[Hp - 16] = _sg5wL::P64;
           P64[Hp - 8] = _sg5wM::P64;
           _cg7xH::P64 = Hp - 54;
           P64[Hp] = _cg7xH::P64;
           R2 = _sg5wJ::P64;
           I64[Sp - 32] = stg_ap_pppp_info;
           P64[Sp - 24] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 16] = _cg7xH::P64;
           P64[Sp - 8] = P64[Sp];
           P64[Sp] = Hp - 40;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.49691836 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldl_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldl_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldl_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldl_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cg7y8,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7y8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7y9; else goto cg7ya;
       cg7y9: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7ya: // global
           I64[Sp - 40] = block_cg7y5_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7ye; else goto cg7y6;
       ug7ye: // global
           call _cg7y5(R1) args: 0, res: 0, upd: 0;
       cg7y6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7y5() //  [R1]
         { info_tbl: [(cg7y5,
                       label: block_cg7y5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7y5: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldl_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.498112439 UTC

[section ""cstring" . lvl2_rg5nY_bytes" {
     lvl2_rg5nY_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.498912205 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct7_closure" {
     Data.Functor.Product.$fFoldableProduct7_closure:
         const Data.Functor.Product.$fFoldableProduct7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct7_entry() //  [R1]
         { info_tbl: [(cg7yn,
                       label: Data.Functor.Product.$fFoldableProduct7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7yn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg7yo; else goto cg7yp;
       cg7yo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7yp: // global
           (_cg7yi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg7yi::I64 == 0) goto cg7yk; else goto cg7yj;
       cg7yk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg7yj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg7yi::I64;
           I64[Sp - 24] = block_cg7yl_info;
           R2 = lvl2_rg5nY_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg7yl() //  [R1]
         { info_tbl: [(cg7yl,
                       label: block_cg7yl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7yl: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.50086135 UTC

[section ""data" . Data.Functor.Product.$w$cfoldl1_closure" {
     Data.Functor.Product.$w$cfoldl1_closure:
         const Data.Functor.Product.$w$cfoldl1_info;
         const 0;
 },
 sat_sg5xb_entry() //  [R1]
         { info_tbl: [(cg7yN,
                       label: sat_sg5xb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7yN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7yO; else goto cg7yP;
       cg7yO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7yP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg7yG_info;
           _sg5x3::P64 = P64[R1 + 16];
           _sg5x7::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sg5x3::P64;
           P64[Sp - 24] = _sg5x7::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7yW; else goto cg7yH;
       ug7yW: // global
           call _cg7yG(R1) args: 0, res: 0, upd: 0;
       cg7yH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg7yG() //  [R1]
         { info_tbl: [(cg7yG,
                       label: block_cg7yG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7yG: // global
           _sg5x7::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg7yK; else goto cg7yL;
       cg7yK: // global
           R1 = _sg5x7::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cg7yL: // global
           R3 = _sg5x7::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 f1_sg5x6_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7yY,
                       label: f1_sg5x6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7yY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg7z2; else goto cg7z1;
       cg7z2: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7z1: // global
           _sg5x3::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sg5xb_info;
           P64[Hp - 32] = _sg5x3::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5xc_entry() //  [R1]
         { info_tbl: [(cg7z7,
                       label: sat_sg5xc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7z7: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg7z8; else goto cg7z9;
       cg7z8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7z9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldl1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7zg,
                       label: Data.Functor.Product.$w$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7zg: // global
           _sg5x5::P64 = R6;
           _sg5x4::P64 = R5;
           _sg5x3::P64 = R4;
           _sg5x2::P64 = R3;
           _sg5x1::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cg7zh; else goto cg7zi;
       cg7zi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg7zk; else goto cg7zj;
       cg7zk: // global
           HpAlloc = 56;
           goto cg7zh;
       cg7zh: // global
           R6 = _sg5x5::P64;
           R5 = _sg5x4::P64;
           R4 = _sg5x3::P64;
           R3 = _sg5x2::P64;
           R2 = _sg5x1::P64;
           R1 = Data.Functor.Product.$w$cfoldl1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7zj: // global
           I64[Hp - 48] = f1_sg5x6_info;
           P64[Hp - 40] = _sg5x3::P64;
           I64[Hp - 32] = sat_sg5xc_info;
           P64[Hp - 16] = _sg5x1::P64;
           P64[Hp - 8] = _sg5x4::P64;
           _cg7yx::P64 = Hp - 46;
           P64[Hp] = _cg7yx::P64;
           I64[Sp - 8] = block_cg7za_info;
           R2 = _sg5x2::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 32] = _cg7yx::P64;
           P64[Sp - 24] = _sg5x5::P64;
           P64[Sp - 16] = Hp - 32;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cg7za() //  [R1]
         { info_tbl: [(cg7za,
                       label: block_cg7za_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7za: // global
           if (R1 & 7 == 1) goto cg7zd; else goto cg7ze;
       cg7zd: // global
           R1 = Data.Functor.Product.$fFoldableProduct7_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg7ze: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.503589884 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldl1_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldl1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg7zy,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7zy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7zz; else goto cg7zA;
       cg7zz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7zA: // global
           I64[Sp - 32] = block_cg7zv_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7zE; else goto cg7zw;
       ug7zE: // global
           call _cg7zv(R1) args: 0, res: 0, upd: 0;
       cg7zw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7zv() //  [R1]
         { info_tbl: [(cg7zv,
                       label: block_cg7zv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7zv: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldl1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.505589814 UTC

[section ""data" . Data.Functor.Product.$w$cfoldr'_closure" {
     Data.Functor.Product.$w$cfoldr'_closure:
         const Data.Functor.Product.$w$cfoldr'_info;
         const 0;
 },
 f1_sg5xs_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg7zQ,
                       label: f1_sg5xs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7zQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7zR; else goto cg7zS;
       cg7zR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7zS: // global
           I64[Sp - 16] = block_cg7zO_info;
           _sg5xu::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sg5xu::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7zO() //  [R1]
         { info_tbl: [(cg7zO,
                       label: block_cg7zO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7zO: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5xx_entry() //  [R1]
         { info_tbl: [(cg7zY,
                       label: sat_sg5xx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7zY: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg7zZ; else goto cg7A0;
       cg7zZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7A0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldr'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7A1,
                       label: Data.Functor.Product.$w$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7A1: // global
           _sg5xq::P64 = R6;
           _sg5xp::P64 = R5;
           _sg5xo::P64 = R4;
           _sg5xn::P64 = R3;
           _sg5xm::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cg7A2; else goto cg7A3;
       cg7A3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg7A5; else goto cg7A4;
       cg7A5: // global
           HpAlloc = 56;
           goto cg7A2;
       cg7A2: // global
           R6 = _sg5xq::P64;
           R5 = _sg5xp::P64;
           R4 = _sg5xo::P64;
           R3 = _sg5xn::P64;
           R2 = _sg5xm::P64;
           R1 = Data.Functor.Product.$w$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg7A4: // global
           I64[Hp - 48] = f1_sg5xs_info;
           P64[Hp - 40] = _sg5xo::P64;
           I64[Hp - 32] = sat_sg5xx_info;
           P64[Hp - 16] = _sg5xm::P64;
           P64[Hp - 8] = _sg5xq::P64;
           _cg7zJ::P64 = Hp - 45;
           P64[Hp] = _cg7zJ::P64;
           R2 = _sg5xn::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 24] = _cg7zJ::P64;
           P64[Sp - 16] = P64[Sp];
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = _sg5xp::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.507707078 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldr'_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldr'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cg7Ad,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Ad: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Ae; else goto cg7Af;
       cg7Ae: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Af: // global
           I64[Sp - 40] = block_cg7Aa_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7Aj; else goto cg7Ab;
       ug7Aj: // global
           call _cg7Aa(R1) args: 0, res: 0, upd: 0;
       cg7Ab: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Aa() //  [R1]
         { info_tbl: [(cg7Aa,
                       label: block_cg7Aa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Aa: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldr'_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.509328638 UTC

[section ""data" . Data.Functor.Product.$w$cfoldr_closure" {
     Data.Functor.Product.$w$cfoldr_closure:
         const Data.Functor.Product.$w$cfoldr_info;
         const 0;
 },
 sat_sg5xM_entry() //  [R1]
         { info_tbl: [(cg7As,
                       label: sat_sg5xM_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7As: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg7At; else goto cg7Au;
       cg7At: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Au: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7Av,
                       label: Data.Functor.Product.$w$cfoldr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Av: // global
           _sg5xK::P64 = R6;
           _sg5xJ::P64 = R5;
           _sg5xI::P64 = R4;
           _sg5xH::P64 = R3;
           _sg5xG::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cg7Aw; else goto cg7Ax;
       cg7Ax: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg7Az; else goto cg7Ay;
       cg7Az: // global
           HpAlloc = 48;
           goto cg7Aw;
       cg7Aw: // global
           R6 = _sg5xK::P64;
           R5 = _sg5xJ::P64;
           R4 = _sg5xI::P64;
           R3 = _sg5xH::P64;
           R2 = _sg5xG::P64;
           R1 = Data.Functor.Product.$w$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg7Ay: // global
           I64[Hp - 40] = sat_sg5xM_info;
           P64[Hp - 24] = _sg5xH::P64;
           P64[Hp - 16] = _sg5xI::P64;
           P64[Hp - 8] = _sg5xJ::P64;
           P64[Hp] = P64[Sp];
           R2 = _sg5xG::P64;
           I64[Sp - 32] = stg_ap_pppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 16] = _sg5xI::P64;
           P64[Sp - 8] = _sg5xK::P64;
           P64[Sp] = Hp - 40;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.5110115 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldr_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldr_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldr_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldr_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cg7AH,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7AH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7AI; else goto cg7AJ;
       cg7AI: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7AJ: // global
           I64[Sp - 40] = block_cg7AE_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7AN; else goto cg7AF;
       ug7AN: // global
           call _cg7AE(R1) args: 0, res: 0, upd: 0;
       cg7AF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7AE() //  [R1]
         { info_tbl: [(cg7AE,
                       label: block_cg7AE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7AE: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldr_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.512772151 UTC

[section ""data" . Data.Functor.Product.$w$cfoldl'_closure" {
     Data.Functor.Product.$w$cfoldl'_closure:
         const Data.Functor.Product.$w$cfoldl'_info;
         const 0;
 },
 f1_sg5y1_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg7AZ,
                       label: f1_sg5y1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7AZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7B0; else goto cg7B1;
       cg7B0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7B1: // global
           I64[Sp - 16] = block_cg7AX_info;
           _sg5y3::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sg5y3::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7AX() //  [R1]
         { info_tbl: [(cg7AX,
                       label: block_cg7AX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7AX: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5y6_entry() //  [R1]
         { info_tbl: [(cg7B7,
                       label: sat_sg5y6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7B7: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg7B8; else goto cg7B9;
       cg7B8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7B9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldl'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7Ba,
                       label: Data.Functor.Product.$w$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Ba: // global
           _sg5xZ::P64 = R6;
           _sg5xY::P64 = R5;
           _sg5xX::P64 = R4;
           _sg5xW::P64 = R3;
           _sg5xV::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Bb; else goto cg7Bc;
       cg7Bc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg7Be; else goto cg7Bd;
       cg7Be: // global
           HpAlloc = 56;
           goto cg7Bb;
       cg7Bb: // global
           R6 = _sg5xZ::P64;
           R5 = _sg5xY::P64;
           R4 = _sg5xX::P64;
           R3 = _sg5xW::P64;
           R2 = _sg5xV::P64;
           R1 = Data.Functor.Product.$w$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg7Bd: // global
           I64[Hp - 48] = f1_sg5y1_info;
           P64[Hp - 40] = _sg5xX::P64;
           I64[Hp - 32] = sat_sg5y6_info;
           P64[Hp - 16] = _sg5xW::P64;
           P64[Hp - 8] = P64[Sp];
           _cg7AS::P64 = Hp - 45;
           P64[Hp] = _cg7AS::P64;
           R2 = _sg5xV::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = _cg7AS::P64;
           P64[Sp - 16] = _sg5xZ::P64;
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = _sg5xY::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.51492283 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldl'_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldl'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cg7Bm,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Bm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Bn; else goto cg7Bo;
       cg7Bn: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Bo: // global
           I64[Sp - 40] = block_cg7Bj_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7Bs; else goto cg7Bk;
       ug7Bs: // global
           call _cg7Bj(R1) args: 0, res: 0, upd: 0;
       cg7Bk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Bj() //  [R1]
         { info_tbl: [(cg7Bj,
                       label: block_cg7Bj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Bj: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldl'_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.516404853 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct5_closure" {
     Data.Functor.Product.$fFoldableProduct5_closure:
         const Data.Functor.Product.$fFoldableProduct5_info;
 },
 Data.Functor.Product.$fFoldableProduct5_entry() //  [R2, R3]
         { info_tbl: [(cg7BA,
                       label: Data.Functor.Product.$fFoldableProduct5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7BA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg7BH; else goto cg7BI;
       cg7BH: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7BI: // global
           I64[Sp - 8] = block_cg7Bx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7BM; else goto cg7By;
       ug7BM: // global
           call _cg7Bx(R1) args: 0, res: 0, upd: 0;
       cg7By: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Bx() //  [R1]
         { info_tbl: [(cg7Bx,
                       label: block_cg7Bx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Bx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg7BL; else goto cg7BK;
       cg7BL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7BK: // global
           _sg5yj::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sg5yj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.518189778 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$clength_closure" {
     Data.Functor.Product.$fFoldableProduct_$clength_closure:
         const Data.Functor.Product.$fFoldableProduct_$clength_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$clength_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cg7BU,
                       label: Data.Functor.Product.$fFoldableProduct_$clength_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7BU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg7BV; else goto cg7BW;
       cg7BV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$clength_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7BW: // global
           I64[Sp - 24] = block_cg7BR_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug7C0; else goto cg7BS;
       ug7C0: // global
           call _cg7BR(R1) args: 0, res: 0, upd: 0;
       cg7BS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7BR() //  [R1]
         { info_tbl: [(cg7BR,
                       label: block_cg7BR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7BR: // global
           R6 = P64[R1 + 7];
           R5 = Data.Functor.Product.$fFoldableProduct4_closure+1;
           R4 = Data.Functor.Product.$fFoldableProduct5_closure+2;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 16] = P64[R1 + 15];
           Sp = Sp + 16;
           call Data.Functor.Product.$w$cfoldl'_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.519366932 UTC

[section ""cstring" . lvl3_rg5nZ_bytes" {
     lvl3_rg5nZ_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.520207819 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct9_closure" {
     Data.Functor.Product.$fFoldableProduct9_closure:
         const Data.Functor.Product.$fFoldableProduct9_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct9_entry() //  [R1]
         { info_tbl: [(cg7C9,
                       label: Data.Functor.Product.$fFoldableProduct9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7C9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg7Ca; else goto cg7Cb;
       cg7Ca: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Cb: // global
           (_cg7C4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg7C4::I64 == 0) goto cg7C6; else goto cg7C5;
       cg7C6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg7C5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg7C4::I64;
           I64[Sp - 24] = block_cg7C7_info;
           R2 = lvl3_rg5nZ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg7C7() //  [R1]
         { info_tbl: [(cg7C7,
                       label: block_cg7C7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7C7: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.522343038 UTC

[section ""data" . Data.Functor.Product.$w$cfoldr1_closure" {
     Data.Functor.Product.$w$cfoldr1_closure:
         const Data.Functor.Product.$w$cfoldr1_info;
         const 0;
 },
 sat_sg5yB_entry() //  [R1]
         { info_tbl: [(cg7Cz,
                       label: sat_sg5yB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Cz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7CA; else goto cg7CB;
       cg7CA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7CB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg7Cs_info;
           _sg5yt::P64 = P64[R1 + 16];
           _sg5yx::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sg5yt::P64;
           P64[Sp - 24] = _sg5yx::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7CI; else goto cg7Ct;
       ug7CI: // global
           call _cg7Cs(R1) args: 0, res: 0, upd: 0;
       cg7Ct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg7Cs() //  [R1]
         { info_tbl: [(cg7Cs,
                       label: block_cg7Cs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Cs: // global
           _sg5yx::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg7Cw; else goto cg7Cx;
       cg7Cw: // global
           R1 = _sg5yx::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cg7Cx: // global
           R3 = P64[R1 + 6];
           R2 = _sg5yx::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 w3_sg5yw_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7CK,
                       label: w3_sg5yw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7CK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg7CO; else goto cg7CN;
       cg7CO: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7CN: // global
           _sg5yt::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sg5yB_info;
           P64[Hp - 32] = _sg5yt::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5yC_entry() //  [R1]
         { info_tbl: [(cg7CT,
                       label: sat_sg5yC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7CT: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg7CU; else goto cg7CV;
       cg7CU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7CV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldr1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7D2,
                       label: Data.Functor.Product.$w$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7D2: // global
           _sg5yv::P64 = R6;
           _sg5yu::P64 = R5;
           _sg5yt::P64 = R4;
           _sg5ys::P64 = R3;
           _sg5yr::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cg7D3; else goto cg7D4;
       cg7D4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg7D6; else goto cg7D5;
       cg7D6: // global
           HpAlloc = 56;
           goto cg7D3;
       cg7D3: // global
           R6 = _sg5yv::P64;
           R5 = _sg5yu::P64;
           R4 = _sg5yt::P64;
           R3 = _sg5ys::P64;
           R2 = _sg5yr::P64;
           R1 = Data.Functor.Product.$w$cfoldr1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7D5: // global
           I64[Hp - 48] = w3_sg5yw_info;
           P64[Hp - 40] = _sg5yt::P64;
           I64[Hp - 32] = sat_sg5yC_info;
           P64[Hp - 16] = _sg5ys::P64;
           P64[Hp - 8] = _sg5yv::P64;
           _cg7Cj::P64 = Hp - 46;
           P64[Hp] = _cg7Cj::P64;
           I64[Sp - 8] = block_cg7CW_info;
           R2 = _sg5yr::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = _cg7Cj::P64;
           P64[Sp - 24] = _sg5yu::P64;
           P64[Sp - 16] = Hp - 32;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cg7CW() //  [R1]
         { info_tbl: [(cg7CW,
                       label: block_cg7CW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7CW: // global
           if (R1 & 7 == 1) goto cg7CZ; else goto cg7D0;
       cg7CZ: // global
           R1 = Data.Functor.Product.$fFoldableProduct9_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg7D0: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.525274485 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldr1_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldr1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg7Dk,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Dk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7Dl; else goto cg7Dm;
       cg7Dl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Dm: // global
           I64[Sp - 32] = block_cg7Dh_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7Dq; else goto cg7Di;
       ug7Dq: // global
           call _cg7Dh(R1) args: 0, res: 0, upd: 0;
       cg7Di: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Dh() //  [R1]
         { info_tbl: [(cg7Dh,
                       label: block_cg7Dh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Dh: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldr1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.526613392 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct6_closure" {
     Data.Functor.Product.$fFoldableProduct6_closure:
         const Data.Functor.Product.$fFoldableProduct6_info;
 },
 Data.Functor.Product.$fFoldableProduct6_entry() //  []
         { info_tbl: [(cg7Dv,
                       label: Data.Functor.Product.$fFoldableProduct6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Dv: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.529174805 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cnull_closure" {
     Data.Functor.Product.$fFoldableProduct_$cnull_closure:
         const Data.Functor.Product.$fFoldableProduct_$cnull_info;
         const 0;
 },
 sat_sg5yU_entry() //  [R1]
         { info_tbl: [(cg7DL,
                       label: sat_sg5yU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7DL: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg7DM; else goto cg7DN;
       cg7DM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7DN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = Data.Functor.Product.$fFoldableProduct6_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.True_closure+2;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cnull_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cg7DO,
                       label: Data.Functor.Product.$fFoldableProduct_$cnull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7DO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7DP; else goto cg7DQ;
       cg7DP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cnull_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7DQ: // global
           I64[Sp - 24] = block_cg7DC_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug7DU; else goto cg7DD;
       ug7DU: // global
           call _cg7DC(R1) args: 0, res: 0, upd: 0;
       cg7DD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7DC() //  [R1]
         { info_tbl: [(cg7DC,
                       label: block_cg7DC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7DC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg7DT; else goto cg7DS;
       cg7DT: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7DS: // global
           _sg5yS::P64 = P64[R1 + 7];
           _sg5yT::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sg5yU_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sg5yT::P64;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp] = Data.Functor.Product.$fFoldableProduct6_closure+2;
           P64[Sp + 8] = _sg5yS::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.531878147 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cproduct_closure" {
     Data.Functor.Product.$fFoldableProduct_$cproduct_closure:
         const Data.Functor.Product.$fFoldableProduct_$cproduct_info;
         const 0;
 },
 $dMonoid_sg5yY_entry() //  [R1]
         { info_tbl: [(cg7E3,
                       label: $dMonoid_sg5yY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7E3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7E4; else goto cg7E5;
       cg7E4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7E5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5z4_entry() //  [R1]
         { info_tbl: [(cg7Ek,
                       label: sat_sg5z4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Ek: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7El; else goto cg7Em;
       cg7El: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Em: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5z3_entry() //  [R1]
         { info_tbl: [(cg7Er,
                       label: sat_sg5z3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Er: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7Es; else goto cg7Et;
       cg7Es: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Et: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5z5_entry() //  [R1, R2]
         { info_tbl: [(cg7Eu,
                       label: sat_sg5z5_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Eu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Ev; else goto cg7Ew;
       cg7Ev: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7Ew: // global
           I64[Sp - 40] = block_cg7Eb_info;
           _sg5yV::P64 = P64[R1 + 7];
           _sg5yW::P64 = P64[R1 + 15];
           _sg5yX::P64 = P64[R1 + 23];
           _sg5yY::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5yV::P64;
           P64[Sp - 24] = _sg5yW::P64;
           P64[Sp - 16] = _sg5yX::P64;
           P64[Sp - 8] = _sg5yY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7EA; else goto cg7Ec;
       ug7EA: // global
           call _cg7Eb(R1) args: 0, res: 0, upd: 0;
       cg7Ec: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Eb() //  [R1]
         { info_tbl: [(cg7Eb,
                       label: block_cg7Eb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Eb: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg7Ez; else goto cg7Ey;
       cg7Ez: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7Ey: // global
           _sg5z1::P64 = P64[R1 + 7];
           _sg5z2::P64 = P64[R1 + 15];
           I64[Hp - 72] = sat_sg5z4_info;
           P64[Hp - 56] = P64[Sp + 16];
           _sg5yY::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sg5yY::P64;
           P64[Hp - 40] = _sg5z2::P64;
           I64[Hp - 32] = sat_sg5z3_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sg5yY::P64;
           P64[Hp] = _sg5z1::P64;
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cproduct_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg7EB,
                       label: Data.Functor.Product.$fFoldableProduct_$cproduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7EB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg7EF; else goto cg7EE;
       cg7EF: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cproduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7EE: // global
           I64[Hp - 56] = $dMonoid_sg5yY_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5z5_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.534835189 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$ctoList_closure" {
     Data.Functor.Product.$fFoldableProduct_$ctoList_closure:
         const Data.Functor.Product.$fFoldableProduct_$ctoList_info;
         const 0;
 },
 sat_sg5zc_entry() //  [R1]
         { info_tbl: [(cg7ET,
                       label: sat_sg5zc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ET: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg7EU; else goto cg7EV;
       cg7EU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7EV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = GHC.Types.:_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$ctoList_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cg7EW,
                       label: Data.Functor.Product.$fFoldableProduct_$ctoList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7EW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7EX; else goto cg7EY;
       cg7EX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$ctoList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7EY: // global
           I64[Sp - 24] = block_cg7EK_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug7F2; else goto cg7EL;
       ug7F2: // global
           call _cg7EK(R1) args: 0, res: 0, upd: 0;
       cg7EL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7EK() //  [R1]
         { info_tbl: [(cg7EK,
                       label: block_cg7EK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7EK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg7F1; else goto cg7F0;
       cg7F1: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7F0: // global
           _sg5za::P64 = P64[R1 + 7];
           _sg5zb::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sg5zc_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sg5zb::P64;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp] = GHC.Types.:_closure+2;
           P64[Sp + 8] = _sg5za::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.538644145 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_closure" {
     Data.Functor.Product.$fFoldableProduct_closure:
         const Data.Functor.Product.$fFoldableProduct_info;
         const 0;
 },
 sat_sg5zu_entry() //  [R1, R2]
         { info_tbl: [(cg7Fc,
                       label: sat_sg5zu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Fc: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cproduct_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zt_entry() //  [R1, R2]
         { info_tbl: [(cg7Fk,
                       label: sat_sg5zt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Fk: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$csum_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zs_entry() //  [R1, R2]
         { info_tbl: [(cg7Fs,
                       label: sat_sg5zs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Fs: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cminimum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zr_entry() //  [R1, R2]
         { info_tbl: [(cg7FA,
                       label: sat_sg5zr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7FA: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cmaximum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zq_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7FI,
                       label: sat_sg5zq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7FI: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$celem_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zp_entry() //  [R1, R2]
         { info_tbl: [(cg7FQ,
                       label: sat_sg5zp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7FQ: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$clength_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zo_entry() //  [R1, R2]
         { info_tbl: [(cg7FY,
                       label: sat_sg5zo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7FY: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cnull_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zn_entry() //  [R1, R2]
         { info_tbl: [(cg7G6,
                       label: sat_sg5zn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7G6: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$ctoList_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zm_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7Ge,
                       label: sat_sg5zm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Ge: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$cfoldl1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zl_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7Gm,
                       label: sat_sg5zl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Gm: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$cfoldr1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg7Gu,
                       label: sat_sg5zk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Gu: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldl'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zj_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg7GC,
                       label: sat_sg5zj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7GC: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldl_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zi_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg7GK,
                       label: sat_sg5zi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7GK: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldr'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zh_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg7GS,
                       label: sat_sg5zh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7GS: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldr_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg7H0,
                       label: sat_sg5zg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7H0: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldMap_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zf_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7H8,
                       label: sat_sg5zf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7H8: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$cfold_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_entry() //  [R2, R3]
         { info_tbl: [(cg7Hc,
                       label: Data.Functor.Product.$fFoldableProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Hc: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cg7Hg; else goto cg7Hf;
       cg7Hg: // global
           HpAlloc = 520;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Hf: // global
           I64[Hp - 512] = sat_sg5zu_info;
           P64[Hp - 504] = R2;
           P64[Hp - 496] = R3;
           I64[Hp - 488] = sat_sg5zt_info;
           P64[Hp - 480] = R2;
           P64[Hp - 472] = R3;
           I64[Hp - 464] = sat_sg5zs_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           I64[Hp - 440] = sat_sg5zr_info;
           P64[Hp - 432] = R2;
           P64[Hp - 424] = R3;
           I64[Hp - 416] = sat_sg5zq_info;
           P64[Hp - 408] = R2;
           P64[Hp - 400] = R3;
           I64[Hp - 392] = sat_sg5zp_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           I64[Hp - 368] = sat_sg5zo_info;
           P64[Hp - 360] = R2;
           P64[Hp - 352] = R3;
           I64[Hp - 344] = sat_sg5zn_info;
           P64[Hp - 336] = R2;
           P64[Hp - 328] = R3;
           I64[Hp - 320] = sat_sg5zm_info;
           P64[Hp - 312] = R2;
           P64[Hp - 304] = R3;
           I64[Hp - 296] = sat_sg5zl_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           I64[Hp - 272] = sat_sg5zk_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_sg5zj_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_sg5zi_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_sg5zh_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sg5zg_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sg5zf_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = Data.Foldable.C:Foldable_con_info;
           P64[Hp - 120] = Hp - 150;
           P64[Hp - 112] = Hp - 173;
           P64[Hp - 104] = Hp - 197;
           P64[Hp - 96] = Hp - 221;
           P64[Hp - 88] = Hp - 245;
           P64[Hp - 80] = Hp - 269;
           P64[Hp - 72] = Hp - 294;
           P64[Hp - 64] = Hp - 318;
           P64[Hp - 56] = Hp - 343;
           P64[Hp - 48] = Hp - 367;
           P64[Hp - 40] = Hp - 391;
           P64[Hp - 32] = Hp - 414;
           P64[Hp - 24] = Hp - 439;
           P64[Hp - 16] = Hp - 463;
           P64[Hp - 8] = Hp - 487;
           P64[Hp] = Hp - 511;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.543656818 UTC

[section ""data" . Data.Functor.Product.$w$ctraverse_closure" {
     Data.Functor.Product.$w$ctraverse_closure:
         const Data.Functor.Product.$w$ctraverse_info;
 },
 sat_sg5zC_entry() //  [R1]
         { info_tbl: [(cg7Hp,
                       label: sat_sg5zC_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Hp: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7Hq; else goto cg7Hr;
       cg7Hq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Hr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5zB_entry() //  [R1]
         { info_tbl: [(cg7Hw,
                       label: sat_sg5zB_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Hw: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7Hx; else goto cg7Hy;
       cg7Hx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Hy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$ctraverse_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7Hz,
                       label: Data.Functor.Product.$w$ctraverse_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Hz: // global
           _sg5zz::P64 = R6;
           _sg5zy::P64 = R5;
           _sg5zx::P64 = R4;
           _sg5zw::P64 = R3;
           _sg5zv::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cg7HA; else goto cg7HB;
       cg7HB: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cg7HD; else goto cg7HC;
       cg7HD: // global
           HpAlloc = 96;
           goto cg7HA;
       cg7HA: // global
           R6 = _sg5zz::P64;
           R5 = _sg5zy::P64;
           R4 = _sg5zx::P64;
           R3 = _sg5zw::P64;
           R2 = _sg5zv::P64;
           R1 = Data.Functor.Product.$w$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg7HC: // global
           I64[Hp - 88] = sat_sg5zC_info;
           P64[Hp - 72] = _sg5zw::P64;
           P64[Hp - 64] = _sg5zx::P64;
           P64[Hp - 56] = _sg5zy::P64;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = sat_sg5zB_info;
           P64[Hp - 24] = _sg5zv::P64;
           P64[Hp - 16] = _sg5zx::P64;
           P64[Hp - 8] = _sg5zy::P64;
           P64[Hp] = _sg5zz::P64;
           R2 = _sg5zx::P64;
           I64[Sp - 24] = stg_ap_ppp_info;
           P64[Sp - 16] = Data.Functor.Product.Pair_closure+2;
           P64[Sp - 8] = Hp - 40;
           P64[Sp] = Hp - 88;
           Sp = Sp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.545869919 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$ctraverse_closure" {
     Data.Functor.Product.$fTraversableProduct_$ctraverse_closure:
         const Data.Functor.Product.$fTraversableProduct_$ctraverse_info;
 },
 Data.Functor.Product.$fTraversableProduct_$ctraverse_entry() //  [R2,
                                                                   R3, R4, R5, R6]
         { info_tbl: [(cg7HL,
                       label: Data.Functor.Product.$fTraversableProduct_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7HL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7HM; else goto cg7HN;
       cg7HM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7HN: // global
           I64[Sp - 40] = block_cg7HI_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7HR; else goto cg7HJ;
       ug7HR: // global
           call _cg7HI(R1) args: 0, res: 0, upd: 0;
       cg7HJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7HI() //  [R1]
         { info_tbl: [(cg7HI,
                       label: block_cg7HI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7HI: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.547452031 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure" {
     Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure:
         const Data.Functor.Product.$fTraversableProduct_$cp2Traversable_info;
         const 0;
 },
 sat_sg5zO_entry() //  [R1]
         { info_tbl: [(cg7I0,
                       label: sat_sg5zO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7I0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7I1; else goto cg7I2;
       cg7I1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7I2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5zN_entry() //  [R1]
         { info_tbl: [(cg7I7,
                       label: sat_sg5zN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7I7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7I8; else goto cg7I9;
       cg7I8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7I9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fTraversableProduct_$cp2Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cg7Ia,
                       label: Data.Functor.Product.$fTraversableProduct_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Ia: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg7Ie; else goto cg7Id;
       cg7Ie: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Id: // global
           I64[Hp - 40] = sat_sg5zO_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5zN_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fFoldableProduct_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.549212123 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$cp1Traversable_closure" {
     Data.Functor.Product.$fTraversableProduct_$cp1Traversable_closure:
         const Data.Functor.Product.$fTraversableProduct_$cp1Traversable_info;
 },
 sat_sg5zS_entry() //  [R1]
         { info_tbl: [(cg7In,
                       label: sat_sg5zS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7In: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Io; else goto cg7Ip;
       cg7Io: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Ip: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5zR_entry() //  [R1]
         { info_tbl: [(cg7Iu,
                       label: sat_sg5zR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Iu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Iv; else goto cg7Iw;
       cg7Iv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Iw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fTraversableProduct_$cp1Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cg7Ix,
                       label: Data.Functor.Product.$fTraversableProduct_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Ix: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg7IB; else goto cg7IA;
       cg7IB: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7IA: // global
           I64[Hp - 40] = sat_sg5zS_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5zR_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fFunctorProduct_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.55091717 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$csequenceA_closure" {
     Data.Functor.Product.$fTraversableProduct_$csequenceA_closure:
         const Data.Functor.Product.$fTraversableProduct_$csequenceA_info;
 },
 Data.Functor.Product.$fTraversableProduct_$csequenceA_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cg7IJ,
                       label: Data.Functor.Product.$fTraversableProduct_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7IJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7IK; else goto cg7IL;
       cg7IK: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$csequenceA_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7IL: // global
           I64[Sp - 32] = block_cg7IG_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7IP; else goto cg7IH;
       ug7IP: // global
           call _cg7IG(R1) args: 0, res: 0, upd: 0;
       cg7IH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7IG() //  [R1]
         { info_tbl: [(cg7IG,
                       label: block_cg7IG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7IG: // global
           R6 = P64[R1 + 7];
           R5 = GHC.Base.id_closure+1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.552500341 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$cmapM_closure" {
     Data.Functor.Product.$fTraversableProduct_$cmapM_closure:
         const Data.Functor.Product.$fTraversableProduct_$cmapM_info;
 },
 Data.Functor.Product.$fTraversableProduct_$cmapM_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cg7IX,
                       label: Data.Functor.Product.$fTraversableProduct_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7IX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7J1; else goto cg7J2;
       cg7J1: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7J2: // global
           I64[Sp - 40] = block_cg7IU_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7J8; else goto cg7IV;
       ug7J8: // global
           call _cg7IU(R1) args: 0, res: 0, upd: 0;
       cg7IV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7IU() //  [R1]
         { info_tbl: [(cg7IU,
                       label: block_cg7IU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7IU: // global
           I64[Sp - 8] = block_cg7J0_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg7J0() //  [R1]
         { info_tbl: [(cg7J0,
                       label: block_cg7J0_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7J0: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 40];
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.554319976 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$csequence_closure" {
     Data.Functor.Product.$fTraversableProduct_$csequence_closure:
         const Data.Functor.Product.$fTraversableProduct_$csequence_info;
 },
 Data.Functor.Product.$fTraversableProduct_$csequence_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cg7Jg,
                       label: Data.Functor.Product.$fTraversableProduct_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Jg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Jk; else goto cg7Jl;
       cg7Jk: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Jl: // global
           I64[Sp - 32] = block_cg7Jd_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7Jr; else goto cg7Je;
       ug7Jr: // global
           call _cg7Jd(R1) args: 0, res: 0, upd: 0;
       cg7Je: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Jd() //  [R1]
         { info_tbl: [(cg7Jd,
                       label: block_cg7Jd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Jd: // global
           I64[Sp - 8] = block_cg7Jj_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Jj() //  [R1]
         { info_tbl: [(cg7Jj,
                       label: block_cg7Jj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Jj: // global
           R6 = P64[Sp + 32];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.556676156 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_closure" {
     Data.Functor.Product.$fTraversableProduct_closure:
         const Data.Functor.Product.$fTraversableProduct_info;
         const 0;
 },
 sat_sg5Ao_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7JB,
                       label: sat_sg5Ao_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7JB: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fTraversableProduct_$csequence_entry(R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5An_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg7JJ,
                       label: sat_sg5An_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7JJ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fTraversableProduct_$cmapM_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Am_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7JR,
                       label: sat_sg5Am_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7JR: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fTraversableProduct_$csequenceA_entry(R5,
                                                                            R4,
                                                                            R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Al_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg7JZ,
                       label: sat_sg5Al_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7JZ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fTraversableProduct_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Ak_entry() //  [R1]
         { info_tbl: [(cg7K6,
                       label: sat_sg5Ak_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7K6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7K7; else goto cg7K8;
       cg7K7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7K8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fTraversableProduct_$cp2Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Aj_entry() //  [R1]
         { info_tbl: [(cg7Kd,
                       label: sat_sg5Aj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Kd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Ke; else goto cg7Kf;
       cg7Ke: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Kf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fTraversableProduct_$cp1Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fTraversableProduct_entry() //  [R2, R3]
         { info_tbl: [(cg7Kh,
                       label: Data.Functor.Product.$fTraversableProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Kh: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cg7Kl; else goto cg7Kk;
       cg7Kl: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Kk: // global
           I64[Hp - 208] = sat_sg5Ao_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sg5An_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sg5Am_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sg5Al_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sg5Ak_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sg5Aj_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.561279354 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$cliftA2_closure" {
     Data.Functor.Product.$fApplicativeProduct_$cliftA2_closure:
         const Data.Functor.Product.$fApplicativeProduct_$cliftA2_info;
 },
 sat_sg5AB_entry() //  [R1]
         { info_tbl: [(cg7KE,
                       label: sat_sg5AB_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7KE: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7KF; else goto cg7KG;
       cg7KF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7KG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5AA_entry() //  [R1]
         { info_tbl: [(cg7KL,
                       label: sat_sg5AA_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7KL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7KM; else goto cg7KN;
       cg7KM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7KN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$cliftA2_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cg7KO,
                       label: Data.Functor.Product.$fApplicativeProduct_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7KO: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7KQ; else goto cg7KR;
       cg7KQ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$cliftA2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7KR: // global
           I64[Sp - 40] = block_cg7Kq_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug7KX; else goto cg7Kr;
       ug7KX: // global
           call _cg7Kq(R1) args: 0, res: 0, upd: 0;
       cg7Kr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Kq() //  [R1]
         { info_tbl: [(cg7Kq,
                       label: block_cg7Kq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Kq: // global
           I64[Sp - 8] = block_cg7Kv_info;
           _sg5Av::P64 = P64[R1 + 7];
           _sg5Aw::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5Aw::P64;
           P64[Sp + 32] = _sg5Av::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7KW; else goto cg7Kw;
       ug7KW: // global
           call _cg7Kv(R1) args: 0, res: 0, upd: 0;
       cg7Kw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Kv() //  [R1]
         { info_tbl: [(cg7Kv,
                       label: block_cg7Kv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Kv: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cg7KV; else goto cg7KU;
       cg7KV: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7KU: // global
           _sg5Ay::P64 = P64[R1 + 7];
           _sg5Az::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sg5AB_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sg5Ar::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sg5Ar::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sg5Az::P64;
           I64[Hp - 64] = sat_sg5AA_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sg5Ar::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sg5Ay::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.564115271 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$c<*>_closure" {
     Data.Functor.Product.$fApplicativeProduct_$c<*>_closure:
         const Data.Functor.Product.$fApplicativeProduct_$c<*>_info;
 },
 sat_sg5AN_entry() //  [R1]
         { info_tbl: [(cg7Lg,
                       label: sat_sg5AN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Lg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Lh; else goto cg7Li;
       cg7Lh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Li: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5AM_entry() //  [R1]
         { info_tbl: [(cg7Ln,
                       label: sat_sg5AM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Ln: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Lo; else goto cg7Lp;
       cg7Lo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Lp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$c<*>_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg7Lq,
                       label: Data.Functor.Product.$fApplicativeProduct_$c<*>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Lq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Ls; else goto cg7Lt;
       cg7Ls: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$c<*>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Lt: // global
           I64[Sp - 32] = block_cg7L2_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7Lz; else goto cg7L3;
       ug7Lz: // global
           call _cg7L2(R1) args: 0, res: 0, upd: 0;
       cg7L3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7L2() //  [R1]
         { info_tbl: [(cg7L2,
                       label: block_cg7L2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7L2: // global
           I64[Sp - 8] = block_cg7L7_info;
           _sg5AH::P64 = P64[R1 + 7];
           _sg5AI::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5AI::P64;
           P64[Sp + 24] = _sg5AH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7Ly; else goto cg7L8;
       ug7Ly: // global
           call _cg7L7(R1) args: 0, res: 0, upd: 0;
       cg7L8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7L7() //  [R1]
         { info_tbl: [(cg7L7,
                       label: block_cg7L7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7L7: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg7Lx; else goto cg7Lw;
       cg7Lx: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7Lw: // global
           _sg5AK::P64 = P64[R1 + 7];
           _sg5AL::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5AN_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5AL::P64;
           I64[Hp - 56] = sat_sg5AM_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5AK::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.566716062 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$cpure_closure" {
     Data.Functor.Product.$fApplicativeProduct_$cpure_closure:
         const Data.Functor.Product.$fApplicativeProduct_$cpure_info;
 },
 sat_sg5AS_entry() //  [R1]
         { info_tbl: [(cg7LI,
                       label: sat_sg5AS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7LI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7LJ; else goto cg7LK;
       cg7LJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7LK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5AR_entry() //  [R1]
         { info_tbl: [(cg7LP,
                       label: sat_sg5AR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7LP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7LQ; else goto cg7LR;
       cg7LQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7LR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$cpure_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg7LT,
                       label: Data.Functor.Product.$fApplicativeProduct_$cpure_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7LT: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg7LX; else goto cg7LW;
       cg7LX: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$cpure_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7LW: // global
           I64[Hp - 80] = sat_sg5AS_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg5AR_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.568588285 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_closure" {
     Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_closure:
         const Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_info;
 },
 sat_sg5AW_entry() //  [R1]
         { info_tbl: [(cg7M6,
                       label: sat_sg5AW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7M6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7M7; else goto cg7M8;
       cg7M7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7M8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5AV_entry() //  [R1]
         { info_tbl: [(cg7Md,
                       label: sat_sg5AV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Md: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Me; else goto cg7Mf;
       cg7Me: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Mf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cg7Mg,
                       label: Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Mg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg7Mk; else goto cg7Mj;
       cg7Mk: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Mj: // global
           I64[Hp - 40] = sat_sg5AW_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5AV_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fFunctorProduct_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.57021848 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct1_closure" {
     Data.Functor.Product.$fApplicativeProduct1_closure:
         const Data.Functor.Product.$fApplicativeProduct1_info;
 },
 Data.Functor.Product.$fApplicativeProduct1_entry() //  [R3]
         { info_tbl: [(cg7Mp,
                       label: Data.Functor.Product.$fApplicativeProduct1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Mp: // global
           R2 = R3;
           call GHC.Base.breakpoint_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.571901772 UTC

[section ""data" . Data.Functor.Product.$w$c*>_closure" {
     Data.Functor.Product.$w$c*>_closure:
         const Data.Functor.Product.$w$c*>_info;
 },
 sat_sg5B8_entry() //  [R1]
         { info_tbl: [(cg7MG,
                       label: sat_sg5B8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7MG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7MH; else goto cg7MI;
       cg7MH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7MI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cg7ME_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg7ME() //  [R1]
         { info_tbl: [(cg7ME,
                       label: block_cg7ME_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ME: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Product.$fApplicativeProduct1_closure+2;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5B9_entry() //  [R1]
         { info_tbl: [(cg7MM,
                       label: sat_sg5B9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7MM: // global
           _sg5B9::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg7MN; else goto cg7MO;
       cg7MO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg7MQ; else goto cg7MP;
       cg7MQ: // global
           HpAlloc = 32;
           goto cg7MN;
       cg7MN: // global
           R1 = _sg5B9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7MP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5B9::P64;
           _sg5AZ::P64 = P64[_sg5B9::P64 + 16];
           _sg5B1::P64 = P64[_sg5B9::P64 + 24];
           _sg5B3::P64 = P64[_sg5B9::P64 + 32];
           I64[Hp - 24] = sat_sg5B8_info;
           P64[Hp - 8] = _sg5AZ::P64;
           P64[Hp] = _sg5B1::P64;
           R2 = _sg5AZ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sg5B3::P64;
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5B5_entry() //  [R1]
         { info_tbl: [(cg7N1,
                       label: sat_sg5B5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7N1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7N2; else goto cg7N3;
       cg7N2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7N3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cg7MZ_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg7MZ() //  [R1]
         { info_tbl: [(cg7MZ,
                       label: block_cg7MZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7MZ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Product.$fApplicativeProduct1_closure+2;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5B6_entry() //  [R1]
         { info_tbl: [(cg7N7,
                       label: sat_sg5B6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7N7: // global
           _sg5B6::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg7N8; else goto cg7N9;
       cg7N9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg7Nb; else goto cg7Na;
       cg7Nb: // global
           HpAlloc = 32;
           goto cg7N8;
       cg7N8: // global
           R1 = _sg5B6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Na: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5B6::P64;
           _sg5AY::P64 = P64[_sg5B6::P64 + 16];
           _sg5B0::P64 = P64[_sg5B6::P64 + 24];
           _sg5B2::P64 = P64[_sg5B6::P64 + 32];
           I64[Hp - 24] = sat_sg5B5_info;
           P64[Hp - 8] = _sg5AY::P64;
           P64[Hp] = _sg5B0::P64;
           R2 = _sg5AY::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sg5B2::P64;
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c*>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7Nc,
                       label: Data.Functor.Product.$w$c*>_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Nc: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg7Ng; else goto cg7Nf;
       cg7Ng: // global
           HpAlloc = 80;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$c*>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg7Nf: // global
           I64[Hp - 72] = sat_sg5B9_info;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = P64[Sp];
           I64[Hp - 32] = sat_sg5B6_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R6;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.574952345 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$c*>_closure" {
     Data.Functor.Product.$fApplicativeProduct_$c*>_closure:
         const Data.Functor.Product.$fApplicativeProduct_$c*>_info;
 },
 Data.Functor.Product.$fApplicativeProduct_$c*>_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cg7No,
                       label: Data.Functor.Product.$fApplicativeProduct_$c*>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7No: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Nz; else goto cg7NA;
       cg7Nz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$c*>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7NA: // global
           I64[Sp - 32] = block_cg7Nl_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7NH; else goto cg7Nm;
       ug7NH: // global
           call _cg7Nl(R1) args: 0, res: 0, upd: 0;
       cg7Nm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Nl() //  [R1]
         { info_tbl: [(cg7Nl,
                       label: block_cg7Nl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Nl: // global
           I64[Sp - 8] = block_cg7Nr_info;
           _sg5Bf::P64 = P64[R1 + 7];
           _sg5Bg::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5Bg::P64;
           P64[Sp + 24] = _sg5Bf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7NG; else goto cg7Ns;
       ug7NG: // global
           call _cg7Nr(R1) args: 0, res: 0, upd: 0;
       cg7Ns: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Nr() //  [R1]
         { info_tbl: [(cg7Nr,
                       label: block_cg7Nr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Nr: // global
           _sg5Bf::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg7Nw_info;
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 8];
           R4 = _sg5Bf::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$c*>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 8, upd: 8;
     }
 },
 _cg7Nw() //  [R1, R2]
         { info_tbl: [(cg7Nw,
                       label: block_cg7Nw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Nw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg7NF; else goto cg7NE;
       cg7NF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cg7NE: // global
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.577382048 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$c<*_closure" {
     Data.Functor.Product.$fApplicativeProduct_$c<*_closure:
         const Data.Functor.Product.$fApplicativeProduct_$c<*_info;
 },
 sat_sg5By_entry() //  [R1]
         { info_tbl: [(cg7O0,
                       label: sat_sg5By_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7O0: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7O1; else goto cg7O2;
       cg7O1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7O2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Base.const_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5Bx_entry() //  [R1]
         { info_tbl: [(cg7O7,
                       label: sat_sg5Bx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7O7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7O8; else goto cg7O9;
       cg7O8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7O9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Base.const_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$c<*_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cg7Oa,
                       label: Data.Functor.Product.$fApplicativeProduct_$c<*_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Oa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Oc; else goto cg7Od;
       cg7Oc: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$c<*_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Od: // global
           I64[Sp - 32] = block_cg7NM_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7Oj; else goto cg7NN;
       ug7Oj: // global
           call _cg7NM(R1) args: 0, res: 0, upd: 0;
       cg7NN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7NM() //  [R1]
         { info_tbl: [(cg7NM,
                       label: block_cg7NM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7NM: // global
           I64[Sp - 8] = block_cg7NR_info;
           _sg5Bs::P64 = P64[R1 + 7];
           _sg5Bt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5Bt::P64;
           P64[Sp + 24] = _sg5Bs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7Oi; else goto cg7NS;
       ug7Oi: // global
           call _cg7NR(R1) args: 0, res: 0, upd: 0;
       cg7NS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7NR() //  [R1]
         { info_tbl: [(cg7NR,
                       label: block_cg7NR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7NR: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg7Oh; else goto cg7Og;
       cg7Oh: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7Og: // global
           _sg5Bv::P64 = P64[R1 + 7];
           _sg5Bw::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5By_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5Bw::P64;
           I64[Hp - 56] = sat_sg5Bx_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5Bv::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.580358375 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_closure" {
     Data.Functor.Product.$fApplicativeProduct_closure:
         const Data.Functor.Product.$fApplicativeProduct_info;
 },
 sat_sg5BG_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7Ot,
                       label: sat_sg5BG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Ot: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fApplicativeProduct_$c<*_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BF_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7OB,
                       label: sat_sg5BF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7OB: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fApplicativeProduct_$c*>_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BE_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg7OJ,
                       label: sat_sg5BE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7OJ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fApplicativeProduct_$cliftA2_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BD_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7OR,
                       label: sat_sg5BD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7OR: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fApplicativeProduct_$c<*>_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BC_entry() //  [R1, R2]
         { info_tbl: [(cg7OZ,
                       label: sat_sg5BC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7OZ: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fApplicativeProduct_$cpure_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BB_entry() //  [R1]
         { info_tbl: [(cg7P6,
                       label: sat_sg5BB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7P6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7P7; else goto cg7P8;
       cg7P7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7P8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_entry() //  [R2, R3]
         { info_tbl: [(cg7Pa,
                       label: Data.Functor.Product.$fApplicativeProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Pa: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cg7Pe; else goto cg7Pd;
       cg7Pe: // global
           HpAlloc = 208;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Pd: // global
           I64[Hp - 200] = sat_sg5BG_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sg5BF_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sg5BE_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sg5BD_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sg5BC_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sg5BB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 103;
           P64[Hp - 24] = Hp - 126;
           P64[Hp - 16] = Hp - 149;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 198;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.583390471 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$c<|>_closure" {
     Data.Functor.Product.$fAlternativeProduct_$c<|>_closure:
         const Data.Functor.Product.$fAlternativeProduct_$c<|>_info;
 },
 sat_sg5BS_entry() //  [R1]
         { info_tbl: [(cg7Px,
                       label: sat_sg5BS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Px: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Py; else goto cg7Pz;
       cg7Py: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Pz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5BR_entry() //  [R1]
         { info_tbl: [(cg7PE,
                       label: sat_sg5BR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7PE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7PF; else goto cg7PG;
       cg7PF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7PG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_$c<|>_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg7PH,
                       label: Data.Functor.Product.$fAlternativeProduct_$c<|>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7PH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7PJ; else goto cg7PK;
       cg7PJ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$c<|>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7PK: // global
           I64[Sp - 32] = block_cg7Pj_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7PQ; else goto cg7Pk;
       ug7PQ: // global
           call _cg7Pj(R1) args: 0, res: 0, upd: 0;
       cg7Pk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Pj() //  [R1]
         { info_tbl: [(cg7Pj,
                       label: block_cg7Pj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Pj: // global
           I64[Sp - 8] = block_cg7Po_info;
           _sg5BM::P64 = P64[R1 + 7];
           _sg5BN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5BN::P64;
           P64[Sp + 24] = _sg5BM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7PP; else goto cg7Pp;
       ug7PP: // global
           call _cg7Po(R1) args: 0, res: 0, upd: 0;
       cg7Pp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Po() //  [R1]
         { info_tbl: [(cg7Po,
                       label: block_cg7Po_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Po: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg7PO; else goto cg7PN;
       cg7PO: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7PN: // global
           _sg5BP::P64 = P64[R1 + 7];
           _sg5BQ::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5BS_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5BQ::P64;
           I64[Hp - 56] = sat_sg5BR_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5BP::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.586060212 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$cempty_closure" {
     Data.Functor.Product.$fAlternativeProduct_$cempty_closure:
         const Data.Functor.Product.$fAlternativeProduct_$cempty_info;
 },
 sat_sg5BW_entry() //  [R1]
         { info_tbl: [(cg7PZ,
                       label: sat_sg5BW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7PZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Q0; else goto cg7Q1;
       cg7Q0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Q1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5BV_entry() //  [R1]
         { info_tbl: [(cg7Q6,
                       label: sat_sg5BV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Q6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Q7; else goto cg7Q8;
       cg7Q7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Q8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_$cempty_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cg7Qa,
                       label: Data.Functor.Product.$fAlternativeProduct_$cempty_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Qa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg7Qe; else goto cg7Qd;
       cg7Qe: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$cempty_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Qd: // global
           I64[Hp - 64] = sat_sg5BW_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5BV_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.587919149 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_closure" {
     Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_closure:
         const Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_info;
 },
 sat_sg5C0_entry() //  [R1]
         { info_tbl: [(cg7Qn,
                       label: sat_sg5C0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Qn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Qo; else goto cg7Qp;
       cg7Qo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Qp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5BZ_entry() //  [R1]
         { info_tbl: [(cg7Qu,
                       label: sat_sg5BZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Qu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Qv; else goto cg7Qw;
       cg7Qv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Qw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cg7Qx,
                       label: Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Qx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg7QB; else goto cg7QA;
       cg7QB: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7QA: // global
           I64[Hp - 40] = sat_sg5C0_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5BZ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fApplicativeProduct_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.589558647 UTC

[section ""data" . poly_some_v_rg5o0_closure" {
     poly_some_v_rg5o0_closure:
         const poly_some_v_rg5o0_info;
         const 0;
         const 0;
         const 0;
 },
 poly_some_v_rg5o0_entry() //  [R1]
         { info_tbl: [(cg7QI,
                       label: poly_some_v_rg5o0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7QI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7QJ; else goto cg7QK;
       cg7QJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7QK: // global
           (_cg7QF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg7QF::I64 == 0) goto cg7QH; else goto cg7QG;
       cg7QH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg7QG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg7QF::I64;
           R1 = poly_some_v_rg5o0_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.590824426 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$csome_closure" {
     Data.Functor.Product.$fAlternativeProduct_$csome_closure:
         const Data.Functor.Product.$fAlternativeProduct_$csome_info;
         const 0;
 },
 Data.Functor.Product.$fAlternativeProduct_$csome_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg7QS,
                       label: Data.Functor.Product.$fAlternativeProduct_$csome_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7QS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg7QT; else goto cg7QU;
       cg7QT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$csome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7QU: // global
           I64[Sp - 8] = block_cg7QP_info;
           R1 = R4;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7QY; else goto cg7QQ;
       ug7QY: // global
           call _cg7QP() args: 0, res: 0, upd: 0;
       cg7QQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7QP() //  []
         { info_tbl: [(cg7QP,
                       label: block_cg7QP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7QP: // global
           R1 = poly_some_v_rg5o0_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.594021339 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_closure" {
     Data.Functor.Product.$fAlternativeProduct_closure:
         const Data.Functor.Product.$fAlternativeProduct_info;
         const 0;
 },
 sat_sg5Cd_entry() //  [R1, R2]
         { info_tbl: [(cg7R8,
                       label: sat_sg5Cd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7R8: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fAlternativeProduct_$csome_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Cc_entry() //  [R1, R2]
         { info_tbl: [(cg7Rg,
                       label: sat_sg5Cc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Rg: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fAlternativeProduct_$csome_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Cb_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7Ro,
                       label: sat_sg5Cb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Ro: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fAlternativeProduct_$c<|>_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Ca_entry() //  [R1]
         { info_tbl: [(cg7Rv,
                       label: sat_sg5Ca_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Rv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Rw; else goto cg7Rx;
       cg7Rw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Rx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fAlternativeProduct_$cempty_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5C9_entry() //  [R1]
         { info_tbl: [(cg7RC,
                       label: sat_sg5C9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7RC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7RD; else goto cg7RE;
       cg7RD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7RE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_entry() //  [R2, R3]
         { info_tbl: [(cg7RG,
                       label: Data.Functor.Product.$fAlternativeProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7RG: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cg7RK; else goto cg7RJ;
       cg7RK: // global
           HpAlloc = 184;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7RJ: // global
           I64[Hp - 176] = sat_sg5Cd_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sg5Cc_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sg5Cb_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sg5Ca_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_sg5C9_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 104;
           P64[Hp - 16] = Hp - 126;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 175;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.597102679 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$c>>=_closure" {
     Data.Functor.Product.$fMonadProduct_$c>>=_closure:
         const Data.Functor.Product.$fMonadProduct_$c>>=_info;
 },
 sat_sg5Cv_entry() //  [R1, R2]
         { info_tbl: [(cg7S5,
                       label: sat_sg5Cv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7S5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg7S6; else goto cg7S7;
       cg7S6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7S7: // global
           I64[Sp - 8] = block_cg7S3_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7S3() //  [R1]
         { info_tbl: [(cg7S3,
                       label: block_cg7S3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7S3: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Cw_entry() //  [R1]
         { info_tbl: [(cg7Sb,
                       label: sat_sg5Cw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Sb: // global
           _sg5Cw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Sc; else goto cg7Sd;
       cg7Sd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg7Sf; else goto cg7Se;
       cg7Sf: // global
           HpAlloc = 16;
           goto cg7Sc;
       cg7Sc: // global
           R1 = _sg5Cw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Se: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Cw::P64;
           _sg5Cf::P64 = P64[_sg5Cw::P64 + 16];
           _sg5Ch::P64 = P64[_sg5Cw::P64 + 24];
           _sg5Ck::P64 = P64[_sg5Cw::P64 + 32];
           I64[Hp - 8] = sat_sg5Cv_info;
           P64[Hp] = _sg5Ch::P64;
           R2 = _sg5Cf::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5Ck::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5Cp_entry() //  [R1, R2]
         { info_tbl: [(cg7Sr,
                       label: sat_sg5Cp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Sr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg7Ss; else goto cg7St;
       cg7Ss: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7St: // global
           I64[Sp - 8] = block_cg7Sp_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Sp() //  [R1]
         { info_tbl: [(cg7Sp,
                       label: block_cg7Sp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Sp: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Cq_entry() //  [R1]
         { info_tbl: [(cg7Sx,
                       label: sat_sg5Cq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Sx: // global
           _sg5Cq::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Sy; else goto cg7Sz;
       cg7Sz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg7SB; else goto cg7SA;
       cg7SB: // global
           HpAlloc = 16;
           goto cg7Sy;
       cg7Sy: // global
           R1 = _sg5Cq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7SA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Cq::P64;
           _sg5Ce::P64 = P64[_sg5Cq::P64 + 16];
           _sg5Ch::P64 = P64[_sg5Cq::P64 + 24];
           _sg5Cj::P64 = P64[_sg5Cq::P64 + 32];
           I64[Hp - 8] = sat_sg5Cp_info;
           P64[Hp] = _sg5Ch::P64;
           R2 = _sg5Ce::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5Cj::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$c>>=_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cg7SC,
                       label: Data.Functor.Product.$fMonadProduct_$c>>=_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7SC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7SE; else goto cg7SF;
       cg7SE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$c>>=_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7SF: // global
           I64[Sp - 32] = block_cg7RP_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7SJ; else goto cg7RQ;
       ug7SJ: // global
           call _cg7RP(R1) args: 0, res: 0, upd: 0;
       cg7RQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7RP() //  [R1]
         { info_tbl: [(cg7RP,
                       label: block_cg7RP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7RP: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg7SI; else goto cg7SH;
       cg7SI: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7SH: // global
           _sg5Cj::P64 = P64[R1 + 7];
           _sg5Ck::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5Cw_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sg5Ch::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sg5Ch::P64;
           P64[Hp - 64] = _sg5Ck::P64;
           I64[Hp - 56] = sat_sg5Cq_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg5Ch::P64;
           P64[Hp - 24] = _sg5Cj::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.600245687 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$cp1Monad_closure" {
     Data.Functor.Product.$fMonadProduct_$cp1Monad_closure:
         const Data.Functor.Product.$fMonadProduct_$cp1Monad_info;
 },
 sat_sg5CA_entry() //  [R1]
         { info_tbl: [(cg7SS,
                       label: sat_sg5CA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7SS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7ST; else goto cg7SU;
       cg7ST: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7SU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Cz_entry() //  [R1]
         { info_tbl: [(cg7SZ,
                       label: sat_sg5Cz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7SZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7T0; else goto cg7T1;
       cg7T0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7T1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$cp1Monad_entry() //  [R2, R3]
         { info_tbl: [(cg7T2,
                       label: Data.Functor.Product.$fMonadProduct_$cp1Monad_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7T2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg7T6; else goto cg7T5;
       cg7T6: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$cp1Monad_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7T5: // global
           I64[Hp - 40] = sat_sg5CA_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5Cz_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fApplicativeProduct_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.602175928 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$creturn_closure" {
     Data.Functor.Product.$fMonadProduct_$creturn_closure:
         const Data.Functor.Product.$fMonadProduct_$creturn_info;
 },
 sat_sg5CH_entry() //  [R1]
         { info_tbl: [(cg7Th,
                       label: sat_sg5CH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Th: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7Ti; else goto cg7Tj;
       cg7Ti: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Tj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cg7Tf_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg7Tf() //  [R1]
         { info_tbl: [(cg7Tf,
                       label: block_cg7Tf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Tf: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5CF_entry() //  [R1]
         { info_tbl: [(cg7Tt,
                       label: sat_sg5CF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Tt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7Tu; else goto cg7Tv;
       cg7Tu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Tv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cg7Tr_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg7Tr() //  [R1]
         { info_tbl: [(cg7Tr,
                       label: block_cg7Tr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Tr: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$creturn_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cg7TA,
                       label: Data.Functor.Product.$fMonadProduct_$creturn_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7TA: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg7TE; else goto cg7TD;
       cg7TE: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$creturn_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7TD: // global
           I64[Hp - 80] = sat_sg5CH_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg5CF_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.604915183 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$c>>_closure" {
     Data.Functor.Product.$fMonadProduct_$c>>_closure:
         const Data.Functor.Product.$fMonadProduct_$c>>_info;
 },
 sat_sg5CZ_entry() //  [R1, R2]
         { info_tbl: [(cg7U0,
                       label: sat_sg5CZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7U0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg7U1; else goto cg7U2;
       cg7U1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7U2: // global
           I64[Sp - 8] = block_cg7TX_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7U6; else goto cg7TY;
       ug7U6: // global
           call _cg7TX(R1) args: 0, res: 0, upd: 0;
       cg7TY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7TX() //  [R1]
         { info_tbl: [(cg7TX,
                       label: block_cg7TX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7TX: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5D0_entry() //  [R1]
         { info_tbl: [(cg7U7,
                       label: sat_sg5D0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7U7: // global
           _sg5D0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg7U8; else goto cg7U9;
       cg7U9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg7Ub; else goto cg7Ua;
       cg7Ub: // global
           HpAlloc = 16;
           goto cg7U8;
       cg7U8: // global
           R1 = _sg5D0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Ua: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5D0::P64;
           _sg5CJ::P64 = P64[_sg5D0::P64 + 16];
           _sg5CL::P64 = P64[_sg5D0::P64 + 24];
           _sg5CO::P64 = P64[_sg5D0::P64 + 32];
           I64[Hp - 8] = sat_sg5CZ_info;
           P64[Hp] = _sg5CL::P64;
           R2 = _sg5CJ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5CO::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5CT_entry() //  [R1, R2]
         { info_tbl: [(cg7Uo,
                       label: sat_sg5CT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Uo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg7Up; else goto cg7Uq;
       cg7Up: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7Uq: // global
           I64[Sp - 8] = block_cg7Ul_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7Uu; else goto cg7Um;
       ug7Uu: // global
           call _cg7Ul(R1) args: 0, res: 0, upd: 0;
       cg7Um: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Ul() //  [R1]
         { info_tbl: [(cg7Ul,
                       label: block_cg7Ul_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Ul: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5CU_entry() //  [R1]
         { info_tbl: [(cg7Uv,
                       label: sat_sg5CU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Uv: // global
           _sg5CU::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg7Uw; else goto cg7Ux;
       cg7Ux: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg7Uz; else goto cg7Uy;
       cg7Uz: // global
           HpAlloc = 16;
           goto cg7Uw;
       cg7Uw: // global
           R1 = _sg5CU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Uy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5CU::P64;
           _sg5CI::P64 = P64[_sg5CU::P64 + 16];
           _sg5CL::P64 = P64[_sg5CU::P64 + 24];
           _sg5CN::P64 = P64[_sg5CU::P64 + 32];
           I64[Hp - 8] = sat_sg5CT_info;
           P64[Hp] = _sg5CL::P64;
           R2 = _sg5CI::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5CN::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$c>>_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(cg7UA,
                       label: Data.Functor.Product.$fMonadProduct_$c>>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7UA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg7UC; else goto cg7UD;
       cg7UC: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$c>>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7UD: // global
           I64[Sp - 32] = block_cg7TJ_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7UH; else goto cg7TK;
       ug7UH: // global
           call _cg7TJ(R1) args: 0, res: 0, upd: 0;
       cg7TK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7TJ() //  [R1]
         { info_tbl: [(cg7TJ,
                       label: block_cg7TJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7TJ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg7UG; else goto cg7UF;
       cg7UG: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7UF: // global
           _sg5CN::P64 = P64[R1 + 7];
           _sg5CO::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5D0_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sg5CL::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sg5CL::P64;
           P64[Hp - 64] = _sg5CO::P64;
           I64[Hp - 56] = sat_sg5CU_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg5CL::P64;
           P64[Hp - 24] = _sg5CN::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.607990565 UTC

[section ""data" . lvl4_rg5o1_closure" {
     lvl4_rg5o1_closure:
         const lvl4_rg5o1_info;
         const 0;
 },
 lvl4_rg5o1_entry() //  [R2]
         { info_tbl: [(cg7UM,
                       label: lvl4_rg5o1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7UM: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.60944594 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_closure" {
     Data.Functor.Product.$fMonadProduct_closure:
         const Data.Functor.Product.$fMonadProduct_info;
         const 0;
 },
 sat_sg5D7_entry() //  [R1, R2]
         { info_tbl: [(cg7UY,
                       label: sat_sg5D7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7UY: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fMonadProduct_$creturn_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5D6_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7V6,
                       label: sat_sg5D6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7V6: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadProduct_$c>>_entry(R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5D5_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7Ve,
                       label: sat_sg5D5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Ve: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadProduct_$c>>=_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5D4_entry() //  [R1]
         { info_tbl: [(cg7Vl,
                       label: sat_sg5D4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Vl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Vm; else goto cg7Vn;
       cg7Vm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Vn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadProduct_$cp1Monad_entry(R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_entry() //  [R2, R3]
         { info_tbl: [(cg7Vp,
                       label: Data.Functor.Product.$fMonadProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Vp: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cg7Vt; else goto cg7Vs;
       cg7Vt: // global
           HpAlloc = 152;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Vs: // global
           I64[Hp - 144] = sat_sg5D7_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_sg5D6_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_sg5D5_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_sg5D4_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 94;
           P64[Hp - 16] = Hp - 118;
           P64[Hp - 8] = Hp - 143;
           P64[Hp] = lvl4_rg5o1_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.611938523 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cmplus_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cmplus_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cmplus_info;
 },
 sat_sg5Dj_entry() //  [R1]
         { info_tbl: [(cg7VM,
                       label: sat_sg5Dj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7VM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7VN; else goto cg7VO;
       cg7VN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7VO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5Di_entry() //  [R1]
         { info_tbl: [(cg7VT,
                       label: sat_sg5Di_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7VT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7VU; else goto cg7VV;
       cg7VU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7VV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cmplus_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg7VW,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cmplus_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7VW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg7VY; else goto cg7VZ;
       cg7VY: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cmplus_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7VZ: // global
           I64[Sp - 32] = block_cg7Vy_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug7W5; else goto cg7Vz;
       ug7W5: // global
           call _cg7Vy(R1) args: 0, res: 0, upd: 0;
       cg7Vz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Vy() //  [R1]
         { info_tbl: [(cg7Vy,
                       label: block_cg7Vy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Vy: // global
           I64[Sp - 8] = block_cg7VD_info;
           _sg5Dd::P64 = P64[R1 + 7];
           _sg5De::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5De::P64;
           P64[Sp + 24] = _sg5Dd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7W4; else goto cg7VE;
       ug7W4: // global
           call _cg7VD(R1) args: 0, res: 0, upd: 0;
       cg7VE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7VD() //  [R1]
         { info_tbl: [(cg7VD,
                       label: block_cg7VD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7VD: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg7W3; else goto cg7W2;
       cg7W3: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg7W2: // global
           _sg5Dg::P64 = P64[R1 + 7];
           _sg5Dh::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5Dj_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5Dh::P64;
           I64[Hp - 56] = sat_sg5Di_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5Dg::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.614429297 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cmzero_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cmzero_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cmzero_info;
 },
 sat_sg5Dn_entry() //  [R1]
         { info_tbl: [(cg7We,
                       label: sat_sg5Dn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7We: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Wf; else goto cg7Wg;
       cg7Wf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Wg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Dm_entry() //  [R1]
         { info_tbl: [(cg7Wl,
                       label: sat_sg5Dm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Wl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Wm; else goto cg7Wn;
       cg7Wm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Wn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cmzero_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cg7Wp,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cmzero_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Wp: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg7Wt; else goto cg7Ws;
       cg7Wt: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cmzero_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Ws: // global
           I64[Hp - 64] = sat_sg5Dn_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5Dm_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.616246063 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_info;
         const 0;
 },
 sat_sg5Dr_entry() //  [R1]
         { info_tbl: [(cg7WC,
                       label: sat_sg5Dr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7WC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7WD; else goto cg7WE;
       cg7WD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7WE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Dq_entry() //  [R1]
         { info_tbl: [(cg7WJ,
                       label: sat_sg5Dq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7WJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7WK; else goto cg7WL;
       cg7WK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7WL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cg7WM,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7WM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg7WQ; else goto cg7WP;
       cg7WQ: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7WP: // global
           I64[Hp - 40] = sat_sg5Dr_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5Dq_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fMonadProduct_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.618120556 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_info;
         const 0;
 },
 sat_sg5Dv_entry() //  [R1]
         { info_tbl: [(cg7WZ,
                       label: sat_sg5Dv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7WZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7X0; else goto cg7X1;
       cg7X0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7X1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Du_entry() //  [R1]
         { info_tbl: [(cg7X6,
                       label: sat_sg5Du_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7X6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7X7; else goto cg7X8;
       cg7X7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7X8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cg7X9,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7X9: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg7Xd; else goto cg7Xc;
       cg7Xd: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Xc: // global
           I64[Hp - 40] = sat_sg5Dv_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5Du_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fAlternativeProduct_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.620232307 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_closure" {
     Data.Functor.Product.$fMonadPlusProduct_closure:
         const Data.Functor.Product.$fMonadPlusProduct_info;
         const 0;
 },
 sat_sg5DB_entry() //  [R1, R2, R3]
         { info_tbl: [(cg7Xn,
                       label: sat_sg5DB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Xn: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadPlusProduct_$cmplus_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5DA_entry() //  [R1]
         { info_tbl: [(cg7Xu,
                       label: sat_sg5DA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Xu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Xv; else goto cg7Xw;
       cg7Xv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Xw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadPlusProduct_$cmzero_entry(R3,
                                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Dz_entry() //  [R1]
         { info_tbl: [(cg7XB,
                       label: sat_sg5Dz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7XB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7XC; else goto cg7XD;
       cg7XC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7XD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_entry(R3,
                                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Dy_entry() //  [R1]
         { info_tbl: [(cg7XI,
                       label: sat_sg5Dy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7XI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7XJ; else goto cg7XK;
       cg7XJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7XK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_entry(R3,
                                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_entry() //  [R2, R3]
         { info_tbl: [(cg7XM,
                       label: Data.Functor.Product.$fMonadPlusProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7XM: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cg7XQ; else goto cg7XP;
       cg7XQ: // global
           HpAlloc = 160;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7XP: // global
           I64[Hp - 152] = sat_sg5DB_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sg5DA_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_sg5Dz_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sg5Dy_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 96;
           P64[Hp - 8] = Hp - 128;
           P64[Hp] = Hp - 150;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.623371775 UTC

[section ""data" . Data.Functor.Product.$fMonadFixProduct_$cmfix_closure" {
     Data.Functor.Product.$fMonadFixProduct_$cmfix_closure:
         const Data.Functor.Product.$fMonadFixProduct_$cmfix_info;
 },
 sat_sg5DP_entry() //  [R1, R2]
         { info_tbl: [(cg7Y6,
                       label: sat_sg5DP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Y6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg7Y7; else goto cg7Y8;
       cg7Y7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7Y8: // global
           I64[Sp - 8] = block_cg7Y4_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Y4() //  [R1]
         { info_tbl: [(cg7Y4,
                       label: block_cg7Y4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Y4: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5DQ_entry() //  [R1]
         { info_tbl: [(cg7Yc,
                       label: sat_sg5DQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Yc: // global
           _sg5DQ::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg7Yd; else goto cg7Ye;
       cg7Ye: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg7Yg; else goto cg7Yf;
       cg7Yg: // global
           HpAlloc = 16;
           goto cg7Yd;
       cg7Yd: // global
           R1 = _sg5DQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Yf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5DQ::P64;
           _sg5DD::P64 = P64[_sg5DQ::P64 + 16];
           _sg5DE::P64 = P64[_sg5DQ::P64 + 24];
           I64[Hp - 8] = sat_sg5DP_info;
           P64[Hp] = _sg5DE::P64;
           R2 = _sg5DD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5DJ_entry() //  [R1, R2]
         { info_tbl: [(cg7Ys,
                       label: sat_sg5DJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Ys: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg7Yt; else goto cg7Yu;
       cg7Yt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg7Yu: // global
           I64[Sp - 8] = block_cg7Yq_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Yq() //  [R1]
         { info_tbl: [(cg7Yq,
                       label: block_cg7Yq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Yq: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5DK_entry() //  [R1]
         { info_tbl: [(cg7Yy,
                       label: sat_sg5DK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Yy: // global
           _sg5DK::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg7Yz; else goto cg7YA;
       cg7YA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg7YC; else goto cg7YB;
       cg7YC: // global
           HpAlloc = 16;
           goto cg7Yz;
       cg7Yz: // global
           R1 = _sg5DK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7YB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5DK::P64;
           _sg5DC::P64 = P64[_sg5DK::P64 + 16];
           _sg5DE::P64 = P64[_sg5DK::P64 + 24];
           I64[Hp - 8] = sat_sg5DJ_info;
           P64[Hp] = _sg5DE::P64;
           R2 = _sg5DC::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadFixProduct_$cmfix_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cg7YE,
                       label: Data.Functor.Product.$fMonadFixProduct_$cmfix_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7YE: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg7YI; else goto cg7YH;
       cg7YI: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadFixProduct_$cmfix_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7YH: // global
           I64[Hp - 80] = sat_sg5DQ_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg5DK_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.627294657 UTC

[section ""data" . Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure" {
     Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure:
         const Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_info;
         const 0;
 },
 sat_sg5DU_entry() //  [R1]
         { info_tbl: [(cg7YR,
                       label: sat_sg5DU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7YR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7YS; else goto cg7YT;
       cg7YS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7YT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5DT_entry() //  [R1]
         { info_tbl: [(cg7YY,
                       label: sat_sg5DT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7YY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7YZ; else goto cg7Z0;
       cg7YZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Z0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cg7Z1,
                       label: Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Z1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg7Z5; else goto cg7Z4;
       cg7Z5: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Z4: // global
           I64[Hp - 40] = sat_sg5DU_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5DT_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fMonadProduct_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.629082741 UTC

[section ""data" . Data.Functor.Product.$fMonadFixProduct_closure" {
     Data.Functor.Product.$fMonadFixProduct_closure:
         const Data.Functor.Product.$fMonadFixProduct_info;
         const 0;
 },
 sat_sg5DY_entry() //  [R1, R2]
         { info_tbl: [(cg7Zf,
                       label: sat_sg5DY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Zf: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fMonadFixProduct_$cmfix_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5DX_entry() //  [R1]
         { info_tbl: [(cg7Zm,
                       label: sat_sg5DX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Zm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg7Zn; else goto cg7Zo;
       cg7Zn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7Zo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_entry(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadFixProduct_entry() //  [R2, R3]
         { info_tbl: [(cg7Zq,
                       label: Data.Functor.Product.$fMonadFixProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Zq: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg7Zu; else goto cg7Zt;
       cg7Zu: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadFixProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg7Zt: // global
           I64[Hp - 72] = sat_sg5DY_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sg5DX_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 71;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.631291329 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cmzipWith_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cmzipWith_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cmzipWith_info;
 },
 sat_sg5Eb_entry() //  [R1]
         { info_tbl: [(cg7ZN,
                       label: sat_sg5Eb_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ZN: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7ZO; else goto cg7ZP;
       cg7ZO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7ZP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5Ea_entry() //  [R1]
         { info_tbl: [(cg7ZU,
                       label: sat_sg5Ea_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ZU: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7ZV; else goto cg7ZW;
       cg7ZV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg7ZW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_$cmzipWith_entry() //  [R2,
                                                                R3, R4, R5, R6]
         { info_tbl: [(cg7ZX,
                       label: Data.Functor.Product.$fMonadZipProduct_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ZX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg7ZZ; else goto cg800;
       cg7ZZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cmzipWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg800: // global
           I64[Sp - 40] = block_cg7Zz_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug806; else goto cg7ZA;
       ug806: // global
           call _cg7Zz(R1) args: 0, res: 0, upd: 0;
       cg7ZA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7Zz() //  [R1]
         { info_tbl: [(cg7Zz,
                       label: block_cg7Zz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7Zz: // global
           I64[Sp - 8] = block_cg7ZE_info;
           _sg5E5::P64 = P64[R1 + 7];
           _sg5E6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5E6::P64;
           P64[Sp + 32] = _sg5E5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug805; else goto cg7ZF;
       ug805: // global
           call _cg7ZE(R1) args: 0, res: 0, upd: 0;
       cg7ZF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg7ZE() //  [R1]
         { info_tbl: [(cg7ZE,
                       label: block_cg7ZE_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7ZE: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cg804; else goto cg803;
       cg804: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg803: // global
           _sg5E8::P64 = P64[R1 + 7];
           _sg5E9::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sg5Eb_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sg5E1::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sg5E1::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sg5E9::P64;
           I64[Hp - 64] = sat_sg5Ea_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sg5E1::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sg5E8::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.633897237 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_info;
         const 0;
 },
 sat_sg5Ef_entry() //  [R1]
         { info_tbl: [(cg80f,
                       label: sat_sg5Ef_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg80f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg80g; else goto cg80h;
       cg80g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg80h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Ee_entry() //  [R1]
         { info_tbl: [(cg80m,
                       label: sat_sg5Ee_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg80m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg80n; else goto cg80o;
       cg80n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg80o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cg80p,
                       label: Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg80p: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg80t; else goto cg80s;
       cg80t: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg80s: // global
           I64[Hp - 40] = sat_sg5Ef_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5Ee_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fMonadProduct_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.635996785 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cmzip_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cmzip_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cmzip_info;
 },
 sat_sg5Er_entry() //  [R1]
         { info_tbl: [(cg80M,
                       label: sat_sg5Er_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg80M: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg80N; else goto cg80O;
       cg80N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg80O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5Eq_entry() //  [R1]
         { info_tbl: [(cg80T,
                       label: sat_sg5Eq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg80T: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg80U; else goto cg80V;
       cg80U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg80V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_$cmzip_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cg80W,
                       label: Data.Functor.Product.$fMonadZipProduct_$cmzip_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg80W: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg80Y; else goto cg80Z;
       cg80Y: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cmzip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg80Z: // global
           I64[Sp - 32] = block_cg80y_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug815; else goto cg80z;
       ug815: // global
           call _cg80y(R1) args: 0, res: 0, upd: 0;
       cg80z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg80y() //  [R1]
         { info_tbl: [(cg80y,
                       label: block_cg80y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg80y: // global
           I64[Sp - 8] = block_cg80D_info;
           _sg5El::P64 = P64[R1 + 7];
           _sg5Em::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5Em::P64;
           P64[Sp + 24] = _sg5El::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug814; else goto cg80E;
       ug814: // global
           call _cg80D(R1) args: 0, res: 0, upd: 0;
       cg80E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg80D() //  [R1]
         { info_tbl: [(cg80D,
                       label: block_cg80D_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg80D: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg813; else goto cg812;
       cg813: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg812: // global
           _sg5Eo::P64 = P64[R1 + 7];
           _sg5Ep::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5Er_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5Ep::P64;
           I64[Hp - 56] = sat_sg5Eq_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5Eo::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.640876509 UTC

[section ""data" . Data.Functor.Product.$w$cmunzip_closure" {
     Data.Functor.Product.$w$cmunzip_closure:
         const Data.Functor.Product.$w$cmunzip_info;
 },
 $dMonad_sg5Ev_entry() //  [R1]
         { info_tbl: [(cg81e,
                       label: $dMonad_sg5Ev_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg81e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg81f; else goto cg81g;
       cg81f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg81g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dMonad1_sg5Ew_entry() //  [R1]
         { info_tbl: [(cg81l,
                       label: $dMonad1_sg5Ew_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg81l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg81m; else goto cg81n;
       cg81m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg81n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sg5F2_entry() //  [R1]
         { info_tbl: [(cg81F,
                       label: lvl9_sg5F2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg81F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg81G; else goto cg81H;
       cg81G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg81H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5F8_entry() //  [R1, R2]
         { info_tbl: [(cg81O,
                       label: sat_sg5F8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg81O: // global
           _sg5F3::P64 = R2;
           _sg5F8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg81P; else goto cg81Q;
       cg81Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg81S; else goto cg81R;
       cg81S: // global
           HpAlloc = 24;
           goto cg81P;
       cg81P: // global
           R2 = _sg5F3::P64;
           R1 = _sg5F8::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg81R: // global
           _sg5F2::P64 = P64[_sg5F8::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sg5F3::P64;
           R2 = _sg5F2::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5F9_entry() //  [R1]
         { info_tbl: [(cg81T,
                       label: sat_sg5F9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg81T: // global
           _sg5F9::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg81U; else goto cg81V;
       cg81V: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg81X; else goto cg81W;
       cg81X: // global
           HpAlloc = 40;
           goto cg81U;
       cg81U: // global
           R1 = _sg5F9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg81W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5F9::P64;
           _sg5Ew::P64 = P64[_sg5F9::P64 + 16];
           _sg5ET::P64 = P64[_sg5F9::P64 + 24];
           I64[Hp - 32] = lvl9_sg5F2_info;
           P64[Hp - 16] = _sg5Ew::P64;
           I64[Hp - 8] = sat_sg5F8_info;
           P64[Hp] = Hp - 32;
           R2 = _sg5Ew::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5ET::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 lvl9_sg5EU_entry() //  [R1]
         { info_tbl: [(cg826,
                       label: lvl9_sg5EU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg826: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg827; else goto cg828;
       cg827: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg828: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5F0_entry() //  [R1, R2]
         { info_tbl: [(cg82f,
                       label: sat_sg5F0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg82f: // global
           _sg5EV::P64 = R2;
           _sg5F0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg82g; else goto cg82h;
       cg82h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg82j; else goto cg82i;
       cg82j: // global
           HpAlloc = 24;
           goto cg82g;
       cg82g: // global
           R2 = _sg5EV::P64;
           R1 = _sg5F0::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg82i: // global
           _sg5EU::P64 = P64[_sg5F0::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sg5EV::P64;
           R2 = _sg5EU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5F1_entry() //  [R1]
         { info_tbl: [(cg82k,
                       label: sat_sg5F1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg82k: // global
           _sg5F1::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg82l; else goto cg82m;
       cg82m: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg82o; else goto cg82n;
       cg82o: // global
           HpAlloc = 40;
           goto cg82l;
       cg82l: // global
           R1 = _sg5F1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg82n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5F1::P64;
           _sg5Ev::P64 = P64[_sg5F1::P64 + 16];
           _sg5ES::P64 = P64[_sg5F1::P64 + 24];
           I64[Hp - 32] = lvl9_sg5EU_info;
           P64[Hp - 16] = _sg5Ev::P64;
           I64[Hp - 8] = sat_sg5F0_info;
           P64[Hp] = Hp - 32;
           R2 = _sg5Ev::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5ES::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5Fa_entry() //  [R1]
         { info_tbl: [(cg82p,
                       label: sat_sg5Fa_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg82p: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg82r; else goto cg82s;
       cg82r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg82s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg81s_info;
           _sg5Ev::P64 = P64[R1 + 24];
           _sg5Ew::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sg5Ev::P64;
           P64[Sp - 24] = _sg5Ew::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug82w; else goto cg81t;
       ug82w: // global
           call _cg81s(R1) args: 0, res: 0, upd: 0;
       cg81t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg81s() //  [R1]
         { info_tbl: [(cg81s,
                       label: block_cg81s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg81s: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg82v; else goto cg82u;
       cg82v: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg82u: // global
           _sg5ES::P64 = P64[R1 + 7];
           _sg5ET::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sg5F9_info;
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = _sg5ET::P64;
           I64[Hp - 48] = sat_sg5F1_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg5ES::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sg5EI_entry() //  [R1]
         { info_tbl: [(cg82O,
                       label: lvl9_sg5EI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg82O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg82P; else goto cg82Q;
       cg82P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg82Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5EO_entry() //  [R1, R2]
         { info_tbl: [(cg82X,
                       label: sat_sg5EO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg82X: // global
           _sg5EJ::P64 = R2;
           _sg5EO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg82Y; else goto cg82Z;
       cg82Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg831; else goto cg830;
       cg831: // global
           HpAlloc = 24;
           goto cg82Y;
       cg82Y: // global
           R2 = _sg5EJ::P64;
           R1 = _sg5EO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg830: // global
           _sg5EI::P64 = P64[_sg5EO::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sg5EJ::P64;
           R2 = _sg5EI::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5EP_entry() //  [R1]
         { info_tbl: [(cg832,
                       label: sat_sg5EP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg832: // global
           _sg5EP::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg833; else goto cg834;
       cg834: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg836; else goto cg835;
       cg836: // global
           HpAlloc = 40;
           goto cg833;
       cg833: // global
           R1 = _sg5EP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg835: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5EP::P64;
           _sg5Ew::P64 = P64[_sg5EP::P64 + 16];
           _sg5Ez::P64 = P64[_sg5EP::P64 + 24];
           I64[Hp - 32] = lvl9_sg5EI_info;
           P64[Hp - 16] = _sg5Ew::P64;
           I64[Hp - 8] = sat_sg5EO_info;
           P64[Hp] = Hp - 32;
           R2 = _sg5Ew::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5Ez::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 lvl9_sg5EA_entry() //  [R1]
         { info_tbl: [(cg83f,
                       label: lvl9_sg5EA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg83f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg83g; else goto cg83h;
       cg83g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg83h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5EG_entry() //  [R1, R2]
         { info_tbl: [(cg83o,
                       label: sat_sg5EG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg83o: // global
           _sg5EB::P64 = R2;
           _sg5EG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg83p; else goto cg83q;
       cg83q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg83s; else goto cg83r;
       cg83s: // global
           HpAlloc = 24;
           goto cg83p;
       cg83p: // global
           R2 = _sg5EB::P64;
           R1 = _sg5EG::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg83r: // global
           _sg5EA::P64 = P64[_sg5EG::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sg5EB::P64;
           R2 = _sg5EA::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5EH_entry() //  [R1]
         { info_tbl: [(cg83t,
                       label: sat_sg5EH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg83t: // global
           _sg5EH::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg83u; else goto cg83v;
       cg83v: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg83x; else goto cg83w;
       cg83x: // global
           HpAlloc = 40;
           goto cg83u;
       cg83u: // global
           R1 = _sg5EH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg83w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5EH::P64;
           _sg5Ev::P64 = P64[_sg5EH::P64 + 16];
           _sg5Ey::P64 = P64[_sg5EH::P64 + 24];
           I64[Hp - 32] = lvl9_sg5EA_info;
           P64[Hp - 16] = _sg5Ev::P64;
           I64[Hp - 8] = sat_sg5EG_info;
           P64[Hp] = Hp - 32;
           R2 = _sg5Ev::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5Ey::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5EQ_entry() //  [R1]
         { info_tbl: [(cg83y,
                       label: sat_sg5EQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg83y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg83A; else goto cg83B;
       cg83A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg83B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg82B_info;
           _sg5Ev::P64 = P64[R1 + 24];
           _sg5Ew::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sg5Ev::P64;
           P64[Sp - 24] = _sg5Ew::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug83F; else goto cg82C;
       ug83F: // global
           call _cg82B(R1) args: 0, res: 0, upd: 0;
       cg82C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg82B() //  [R1]
         { info_tbl: [(cg82B,
                       label: block_cg82B_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg82B: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg83E; else goto cg83D;
       cg83E: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg83D: // global
           _sg5Ey::P64 = P64[R1 + 7];
           _sg5Ez::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sg5EP_info;
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = _sg5Ez::P64;
           I64[Hp - 48] = sat_sg5EH_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg5Ey::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cmunzip_entry() //  [R2, R3, R4]
         { info_tbl: [(cg83G,
                       label: Data.Functor.Product.$w$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg83G: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg83K; else goto cg83J;
       cg83K: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg83J: // global
           I64[Hp - 120] = $dMonad_sg5Ev_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = $dMonad1_sg5Ew_info;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_sg5Fa_info;
           P64[Hp - 56] = R4;
           _cg81a::P64 = Hp - 120;
           P64[Hp - 48] = _cg81a::P64;
           _cg81h::P64 = Hp - 96;
           P64[Hp - 40] = _cg81h::P64;
           I64[Hp - 32] = sat_sg5EQ_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _cg81a::P64;
           P64[Hp] = _cg81h::P64;
           R2 = Hp - 72;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.648039533 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cmunzip_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cmunzip_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cmunzip_info;
 },
 Data.Functor.Product.$fMonadZipProduct_$cmunzip_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cg83S,
                       label: Data.Functor.Product.$fMonadZipProduct_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg83S: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg83T; else goto cg83U;
       cg83T: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg83U: // global
           I64[Sp - 8] = block_cg83P_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Functor.Product.$w$cmunzip_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg83P() //  [R1, R2]
         { info_tbl: [(cg83P,
                       label: block_cg83P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg83P: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg83X; else goto cg83W;
       cg83X: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cg83W: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.649978697 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_closure" {
     Data.Functor.Product.$fMonadZipProduct_closure:
         const Data.Functor.Product.$fMonadZipProduct_info;
         const 0;
 },
 sat_sg5Fm_entry() //  [R1, R2]
         { info_tbl: [(cg847,
                       label: sat_sg5Fm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg847: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fMonadZipProduct_$cmunzip_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Fl_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg84f,
                       label: sat_sg5Fl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg84f: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fMonadZipProduct_$cmzipWith_entry(R6,
                                                                        R5,
                                                                        R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Fk_entry() //  [R1, R2, R3]
         { info_tbl: [(cg84n,
                       label: sat_sg5Fk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg84n: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadZipProduct_$cmzip_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Fj_entry() //  [R1]
         { info_tbl: [(cg84u,
                       label: sat_sg5Fj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg84u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg84v; else goto cg84w;
       cg84v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg84w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_entry(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_entry() //  [R2, R3]
         { info_tbl: [(cg84y,
                       label: Data.Functor.Product.$fMonadZipProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg84y: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cg84C; else goto cg84B;
       cg84C: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg84B: // global
           I64[Hp - 136] = sat_sg5Fm_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sg5Fl_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sg5Fk_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sg5Fj_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 86;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = Hp - 135;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.65218761 UTC

[section ""data" . Data.Functor.Product.$fGeneric1Product_$cto1_closure" {
     Data.Functor.Product.$fGeneric1Product_$cto1_closure:
         const Data.Functor.Product.$fGeneric1Product_$cto1_info;
 },
 Data.Functor.Product.$fGeneric1Product_$cto1_entry() //  [R2]
         { info_tbl: [(cg84J,
                       label: Data.Functor.Product.$fGeneric1Product_$cto1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg84J: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg84N; else goto cg84O;
       cg84N: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGeneric1Product_$cto1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg84O: // global
           I64[Sp - 8] = block_cg84H_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg84H() //  [R1]
         { info_tbl: [(cg84H,
                       label: block_cg84H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg84H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg84R; else goto cg84Q;
       cg84R: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg84Q: // global
           _sg5Fp::P64 = P64[R1 + 7];
           _sg5Fq::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = _sg5Fp::P64;
           P64[Hp] = _sg5Fq::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.653690939 UTC

[section ""data" . Data.Functor.Product.$fGeneric1Product1_closure" {
     Data.Functor.Product.$fGeneric1Product1_closure:
         const Data.Functor.Product.$fGeneric1Product1_info;
 },
 Data.Functor.Product.$fGeneric1Product1_entry() //  [R2]
         { info_tbl: [(cg84Z,
                       label: Data.Functor.Product.$fGeneric1Product1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg84Z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg853; else goto cg854;
       cg853: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGeneric1Product1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg854: // global
           I64[Sp - 8] = block_cg84W_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug858; else goto cg84X;
       ug858: // global
           call _cg84W(R1) args: 0, res: 0, upd: 0;
       cg84X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg84W() //  [R1]
         { info_tbl: [(cg84W,
                       label: block_cg84W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg84W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg857; else goto cg856;
       cg857: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg856: // global
           _sg5Ft::P64 = P64[R1 + 7];
           _sg5Fu::P64 = P64[R1 + 15];
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = _sg5Ft::P64;
           P64[Hp] = _sg5Fu::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.654896173 UTC

[section ""data" . Data.Functor.Product.$fGeneric1Product_closure" {
     Data.Functor.Product.$fGeneric1Product_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Product.$fGeneric1Product1_closure+1;
         const Data.Functor.Product.$fGeneric1Product_$cto1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.656971483 UTC

[section ""data" . Data.Functor.Product.$fGenericProduct_$cto_closure" {
     Data.Functor.Product.$fGenericProduct_$cto_closure:
         const Data.Functor.Product.$fGenericProduct_$cto_info;
 },
 Data.Functor.Product.$fGenericProduct_$cto_entry() //  [R2]
         { info_tbl: [(cg85f,
                       label: Data.Functor.Product.$fGenericProduct_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg85f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg85j; else goto cg85k;
       cg85j: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGenericProduct_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg85k: // global
           I64[Sp - 8] = block_cg85d_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg85d() //  [R1]
         { info_tbl: [(cg85d,
                       label: block_cg85d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg85d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg85n; else goto cg85m;
       cg85n: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg85m: // global
           _sg5Fx::P64 = P64[R1 + 7];
           _sg5Fy::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = _sg5Fx::P64;
           P64[Hp] = _sg5Fy::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.658419253 UTC

[section ""data" . Data.Functor.Product.$fGenericProduct1_closure" {
     Data.Functor.Product.$fGenericProduct1_closure:
         const Data.Functor.Product.$fGenericProduct1_info;
 },
 Data.Functor.Product.$fGenericProduct1_entry() //  [R2]
         { info_tbl: [(cg85v,
                       label: Data.Functor.Product.$fGenericProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg85v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg85z; else goto cg85A;
       cg85z: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGenericProduct1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg85A: // global
           I64[Sp - 8] = block_cg85s_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug85E; else goto cg85t;
       ug85E: // global
           call _cg85s(R1) args: 0, res: 0, upd: 0;
       cg85t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg85s() //  [R1]
         { info_tbl: [(cg85s,
                       label: block_cg85s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg85s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg85D; else goto cg85C;
       cg85D: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg85C: // global
           _sg5FB::P64 = P64[R1 + 7];
           _sg5FC::P64 = P64[R1 + 15];
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = _sg5FB::P64;
           P64[Hp] = _sg5FC::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.659559475 UTC

[section ""data" . Data.Functor.Product.$fGenericProduct_closure" {
     Data.Functor.Product.$fGenericProduct_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Product.$fGenericProduct1_closure+1;
         const Data.Functor.Product.$fGenericProduct_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.660904953 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgfoldl_closure" {
     Data.Functor.Product.$fDataProduct_$cgfoldl_closure:
         const Data.Functor.Product.$fDataProduct_$cgfoldl_info;
 },
 Data.Functor.Product.$fDataProduct_$cgfoldl_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg85G: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgfoldl_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg5FP_entry() //  [R1]
         { info_tbl: [(cg85X,
                       label: sat_sg5FP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg85X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg85Y; else goto cg85Z;
       cg85Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg85Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Product.Pair_closure+2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5FQ_entry() //  [R1]
         { info_tbl: [(cg860,
                       label: sat_sg5FQ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg860: // global
           _sg5FQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg861; else goto cg862;
       cg862: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg864; else goto cg863;
       cg864: // global
           HpAlloc = 24;
           goto cg861;
       cg861: // global
           R1 = _sg5FQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg863: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5FQ::P64;
           _sg5FH::P64 = P64[_sg5FQ::P64 + 16];
           _sg5FJ::P64 = P64[_sg5FQ::P64 + 24];
           _sg5FK::P64 = P64[_sg5FQ::P64 + 32];
           _sg5FN::P64 = P64[_sg5FQ::P64 + 40];
           I64[Hp - 16] = sat_sg5FP_info;
           P64[Hp] = _sg5FK::P64;
           R4 = _sg5FN::P64;
           R3 = Hp - 16;
           R2 = _sg5FH::P64;
           R1 = _sg5FJ::P64;
           Sp = Sp - 16;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgfoldl_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cg865,
                       label: Data.Functor.Product.$fDataProduct_$cgfoldl_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg865: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg866; else goto cg867;
       cg866: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgfoldl_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cg867: // global
           I64[Sp - 8] = block_cg85K_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug86b; else goto cg85L;
       ug86b: // global
           call _cg85K(R1) args: 0, res: 0, upd: 0;
       cg85L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg85K() //  [R1]
         { info_tbl: [(cg85K,
                       label: block_cg85K_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg85K: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg86a; else goto cg869;
       cg86a: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg869: // global
           _sg5FN::P64 = P64[R1 + 7];
           _sg5FO::P64 = P64[R1 + 15];
           I64[Hp - 40] = sat_sg5FQ_info;
           P64[Hp - 24] = P64[Sp + 32];
           _sg5FJ::P64 = P64[Sp + 16];
           P64[Hp - 16] = _sg5FJ::P64;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sg5FN::P64;
           R4 = _sg5FO::P64;
           R3 = Hp - 40;
           R2 = P64[Sp + 8];
           R1 = _sg5FJ::P64;
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.663099608 UTC

[section ""cstring" . Data.Functor.Product.$fDataProduct6_bytes" {
     Data.Functor.Product.$fDataProduct6_bytes:
         I8[] [80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.663843309 UTC

[section ""data" . Data.Functor.Product.$fDataProduct5_closure" {
     Data.Functor.Product.$fDataProduct5_closure:
         const Data.Functor.Product.$fDataProduct5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fDataProduct5_entry() //  [R1]
         { info_tbl: [(cg86i,
                       label: Data.Functor.Product.$fDataProduct5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg86i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg86j; else goto cg86k;
       cg86j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg86k: // global
           (_cg86f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg86f::I64 == 0) goto cg86h; else goto cg86g;
       cg86h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg86g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg86f::I64;
           R2 = Data.Functor.Product.$fDataProduct6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.665590637 UTC

[section ""data" . go61_rg5o2_closure" {
     go61_rg5o2_closure:
         const go61_rg5o2_info;
         const 0;
 },
 go61_rg5o2_entry() //  [R2, R3]
         { info_tbl: [(cg86w,
                       label: go61_rg5o2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg86w: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg86x; else goto ug87a;
       cg86x: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rg5o2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ug87a: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cg86m() args: 0, res: 0, upd: 0;
     }
 },
 _cg86m() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg86m: // global
           _sg5FR::P64 = P64[Sp];
           I64[Sp] = block_cg86p_info;
           R1 = _sg5FR::P64;
           if (R1 & 7 != 0) goto ug87e; else goto cg86q;
       ug87e: // global
           call _cg86p(R1) args: 0, res: 0, upd: 0;
       cg86q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg86p() //  [R1]
         { info_tbl: [(cg86p,
                       label: block_cg86p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg86p: // global
           if (R1 & 7 == 1) goto ug87b; else goto cg86u;
       ug87b: // global
           Sp = Sp + 16;
           call _cg86M() args: 0, res: 0, upd: 0;
       cg86u: // global
           I64[Sp - 8] = block_cg86E_info;
           _sg5FU::P64 = P64[R1 + 6];
           _sg5FV::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sg5FV::P64;
           P64[Sp + 8] = _sg5FU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug87f; else goto cg86G;
       ug87f: // global
           call _cg86E(R1) args: 0, res: 0, upd: 0;
       cg86G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg86E() //  [R1]
         { info_tbl: [(cg86E,
                       label: block_cg86E_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg86E: // global
           if (R1 & 7 == 1) goto ug87c; else goto cg86R;
       ug87c: // global
           Sp = Sp + 24;
           call _cg86M() args: 0, res: 0, upd: 0;
       cg86R: // global
           I64[Sp - 8] = block_cg86P_info;
           _sg5FX::P64 = P64[R1 + 6];
           _sg5FY::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sg5FY::P64;
           P64[Sp + 16] = _sg5FX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug87i; else goto cg86S;
       ug87i: // global
           call _cg86P(R1) args: 0, res: 0, upd: 0;
       cg86S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg86M() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg86M: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg86P() //  [R1]
         { info_tbl: [(cg86P,
                       label: block_cg86P_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg86P: // global
           I64[Sp] = block_cg86W_info;
           R3 = Data.Functor.Product.$fRead1Product2_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg86W() //  [R1]
         { info_tbl: [(cg86W,
                       label: block_cg86W_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg86W: // global
           if (R1 & 7 == 1) goto cg873; else goto cg877;
       cg873: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cg86m() args: 0, res: 0, upd: 0;
       cg877: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.667826283 UTC

[section ""data" . $cPair1_rg5o3_closure" {
     $cPair1_rg5o3_closure:
         const Data.Data.AlgConstr_con_info;
         const $cPair2_rg5o4_closure;
         const 0;
 },
 section ""data" . Data.Functor.Product.$fDataProduct4_closure" {
     Data.Functor.Product.$fDataProduct4_closure:
         const :_con_info;
         const Data.Functor.Product.$cPair_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Product.$fDataProduct3_closure" {
     Data.Functor.Product.$fDataProduct3_closure:
         const Data.Data.AlgRep_con_info;
         const Data.Functor.Product.$fDataProduct4_closure+2;
         const 0;
 },
 section ""data" . Data.Functor.Product.$tProduct_closure" {
     Data.Functor.Product.$tProduct_closure:
         const Data.Data.DataType_con_info;
         const Data.Functor.Product.$fDataProduct5_closure;
         const Data.Functor.Product.$fDataProduct3_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Product.$cPair_closure" {
     Data.Functor.Product.$cPair_closure:
         const Data.Data.Constr_con_info;
         const $cPair1_rg5o3_closure+1;
         const Data.Functor.Product.$fRead1Product2_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Product.$tProduct_closure+1;
         const 0;
 },
 section ""data" . $cPair2_rg5o4_closure" {
     $cPair2_rg5o4_closure:
         const $cPair2_rg5o4_info;
         const 0;
         const 0;
         const 0;
 },
 $cPair2_rg5o4_entry() //  [R1]
         { info_tbl: [(cg87r,
                       label: $cPair2_rg5o4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg87r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg87s; else goto cg87t;
       cg87s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg87t: // global
           (_cg87o::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg87o::I64 == 0) goto cg87q; else goto cg87p;
       cg87q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg87p: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg87o::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = Data.Functor.Product.$fDataProduct4_closure+2;
           Sp = Sp - 16;
           call go61_rg5o2_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.669033907 UTC

[section ""cstring" . Data.Functor.Product.$trModule4_bytes" {
     Data.Functor.Product.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.669751733 UTC

[section ""data" . Data.Functor.Product.$trModule3_closure" {
     Data.Functor.Product.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.670356626 UTC

[section ""cstring" . Data.Functor.Product.$trModule2_bytes" {
     Data.Functor.Product.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.670919955 UTC

[section ""data" . Data.Functor.Product.$trModule1_closure" {
     Data.Functor.Product.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.671503279 UTC

[section ""data" . Data.Functor.Product.$trModule_closure" {
     Data.Functor.Product.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Product.$trModule3_closure+1;
         const Data.Functor.Product.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.672158951 UTC

[section ""data" . $krep_rg5o5_closure" {
     $krep_rg5o5_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.672761691 UTC

[section ""data" . $krep1_rg5o6_closure" {
     $krep1_rg5o6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rg5o5_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.673442483 UTC

[section ""data" . $krep2_rg5o7_closure" {
     $krep2_rg5o7_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rg5o6_closure+4;
         const $krep1_rg5o6_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.674016181 UTC

[section ""data" . Data.Functor.Product.$fDataProduct8_closure" {
     Data.Functor.Product.$fDataProduct8_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rg5o6_closure+4;
         const $krep2_rg5o7_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.67464999 UTC

[section ""data" . $krep3_rg5o8_closure" {
     $krep3_rg5o8_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.675234749 UTC

[section ""data" . $krep4_rg5o9_closure" {
     $krep4_rg5o9_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.675857814 UTC

[section ""data" . $krep5_rg5oa_closure" {
     $krep5_rg5oa_closure:
         const GHC.Types.KindRepVar_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.676466998 UTC

[section ""data" . $krep6_rg5ob_closure" {
     $krep6_rg5ob_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rg5o9_closure+2;
         const $krep5_rg5oa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.677070592 UTC

[section ""data" . $krep7_rg5oc_closure" {
     $krep7_rg5oc_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep3_rg5o8_closure+2;
         const $krep5_rg5oa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.677852648 UTC

[section ""data" . Data.Functor.Product.$fDataProduct9_closure" {
     Data.Functor.Product.$fDataProduct9_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$fDataProduct6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.678644845 UTC

[section ""data" . Data.Functor.Product.$tcProduct_closure" {
     Data.Functor.Product.$tcProduct_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Product.$trModule_closure+1;
         const Data.Functor.Product.$fDataProduct9_closure+1;
         const Data.Functor.Product.$fDataProduct8_closure+4;
         const 9904636435990105341;
         const 16069493191308336164;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.679539799 UTC

[section ""data" . $krep8_rg5od_closure" {
     $krep8_rg5od_closure:
         const :_con_info;
         const $krep5_rg5oa_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.680296756 UTC

[section ""data" . $krep9_rg5oe_closure" {
     $krep9_rg5oe_closure:
         const :_con_info;
         const $krep3_rg5o8_closure+2;
         const $krep8_rg5od_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.680933614 UTC

[section ""data" . $krep10_rg5of_closure" {
     $krep10_rg5of_closure:
         const :_con_info;
         const $krep4_rg5o9_closure+2;
         const $krep9_rg5oe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.681638469 UTC

[section ""data" . $krep11_rg5og_closure" {
     $krep11_rg5og_closure:
         const :_con_info;
         const $krep_rg5o5_closure+2;
         const $krep10_rg5of_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.682309298 UTC

[section ""data" . $krep12_rg5oh_closure" {
     $krep12_rg5oh_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Product.$tcProduct_closure+1;
         const $krep11_rg5og_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.682979748 UTC

[section ""data" . $krep13_rg5oi_closure" {
     $krep13_rg5oi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rg5oc_closure+3;
         const $krep12_rg5oh_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.683678935 UTC

[section ""data" . Data.Functor.Product.$tc'Pair1_closure" {
     Data.Functor.Product.$tc'Pair1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rg5ob_closure+3;
         const $krep13_rg5oi_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.685698899 UTC

[section ""cstring" . Data.Functor.Product.$tc'Pair3_bytes" {
     Data.Functor.Product.$tc'Pair3_bytes:
         I8[] [39,80,97,105,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.686295201 UTC

[section ""data" . Data.Functor.Product.$tc'Pair2_closure" {
     Data.Functor.Product.$tc'Pair2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$tc'Pair3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.686902458 UTC

[section ""data" . Data.Functor.Product.$tc'Pair_closure" {
     Data.Functor.Product.$tc'Pair_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Product.$trModule_closure+1;
         const Data.Functor.Product.$tc'Pair2_closure+1;
         const Data.Functor.Product.$tc'Pair1_closure+4;
         const 11374113252541295849;
         const 18011678063065699923;
         const 4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.688275601 UTC

[section ""data" . Data.Functor.Product.$w$cp1Data_closure" {
     Data.Functor.Product.$w$cp1Data_closure:
         const Data.Functor.Product.$w$cp1Data_info;
         const 0;
 },
 Data.Functor.Product.$w$cp1Data_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg87H,
                       label: Data.Functor.Product.$w$cp1Data_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg87H: // global
           _sg5G9::P64 = R5;
           _sg5G8::P64 = R4;
           _sg5G7::P64 = R3;
           _sg5G6::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cg87L; else goto cg87M;
       cg87M: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg87O; else goto cg87N;
       cg87O: // global
           HpAlloc = 40;
           goto cg87L;
       cg87L: // global
           R5 = _sg5G9::P64;
           R4 = _sg5G8::P64;
           R3 = _sg5G7::P64;
           R2 = _sg5G6::P64;
           R1 = Data.Functor.Product.$w$cp1Data_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg87N: // global
           I64[Hp - 32] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 24] = _sg5G9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 32] = block_cg87A_info;
           R6 = 1;
           R5 = Data.Functor.Product.$fDataProduct9_closure+1;
           R4 = Data.Functor.Product.$trModule_closure+1;
           R3 = 16069493191308336164;
           R2 = 9904636435990105341;
           P64[Sp - 48] = Data.Functor.Product.$fDataProduct8_closure+4;
           P64[Sp - 40] = Hp - 14;
           P64[Sp - 24] = _sg5G6::P64;
           P64[Sp - 16] = _sg5G7::P64;
           P64[Sp - 8] = _sg5G8::P64;
           Sp = Sp - 48;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 8;
     }
 },
 _cg87A() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg87A,
                       label: block_cg87A_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg87A: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cg87B() args: 0, res: 0, upd: 0;
     }
 },
 _cg87B() //  []
         { info_tbl: [(cg87B,
                       label: block_cg87B_info
                       rep:StackRep [True, False, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg87B: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg87R; else goto cg87Q;
       cg87R: // global
           HpAlloc = 48;
           I64[Sp] = block_cg87B_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cg87Q: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 40] = block_cg87F_info;
           R3 = P64[Sp + 56];
           R2 = Hp - 38;
           Sp = Sp + 40;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg87F() //  [R1]
         { info_tbl: [(cg87F,
                       label: block_cg87F_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg87F: // global
           I64[Sp] = block_cg87K_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg87K() //  [R1]
         { info_tbl: [(cg87K,
                       label: block_cg87K_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg87K: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.690439922 UTC

[section ""data" . Data.Functor.Product.$fDataProduct7_closure" {
     Data.Functor.Product.$fDataProduct7_closure:
         const Data.Functor.Product.$fDataProduct7_info;
         const 0;
 },
 Data.Functor.Product.$fDataProduct7_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg883,
                       label: Data.Functor.Product.$fDataProduct7_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg883: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Product.$w$cp1Data_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.69126155 UTC

[section ""data" . Data.Functor.Product.$fDataProduct1_closure" {
     Data.Functor.Product.$fDataProduct1_closure:
         const (,)_con_info;
         const Data.Functor.Product.Pair_closure+2;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.694543068 UTC

[section ""data" . Data.Functor.Product.$w$cgmapMp_closure" {
     Data.Functor.Product.$w$cgmapMp_closure:
         const Data.Functor.Product.$w$cgmapMp_info;
 },
 lvl9_sg5Gw_entry() //  [R1]
         { info_tbl: [(cg88e,
                       label: lvl9_sg5Gw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg88e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg88f; else goto cg88g;
       cg88f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg88g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5H1_entry() //  [R1, R2]
         { info_tbl: [(cg88t,
                       label: sat_sg5H1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg88t: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg88u; else goto cg88v;
       cg88u: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg88v: // global
           I64[Sp - 24] = block_cg88q_info;
           _sg5Gw::P64 = P64[R1 + 7];
           _sg5Gx::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sg5Gw::P64;
           P64[Sp - 8] = _sg5Gx::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug88N; else goto cg88r;
       ug88N: // global
           call _cg88q(R1) args: 0, res: 0, upd: 0;
       cg88r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg88q() //  [R1]
         { info_tbl: [(cg88q,
                       label: block_cg88q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg88q: // global
           I64[Sp - 8] = block_cg88y_info;
           _sg5GY::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sg5GY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug88M; else goto cg88A;
       ug88M: // global
           call _cg88y(R1) args: 0, res: 0, upd: 0;
       cg88A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg88y() //  [R1]
         { info_tbl: [(cg88y,
                       label: block_cg88y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg88y: // global
           if (R1 & 7 == 1) goto cg88G; else goto cg88K;
       cg88G: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg88K: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5GR_entry() //  [R1]
         { info_tbl: [(cg89j,
                       label: sat_sg5GR_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg89j: // global
           _sg5GR::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg89k; else goto cg89l;
       cg89l: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg89n; else goto cg89m;
       cg89n: // global
           HpAlloc = 56;
           goto cg89k;
       cg89k: // global
           R1 = _sg5GR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg89m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5GR::P64;
           _sg5Gx::P64 = P64[_sg5GR::P64 + 16];
           _sg5GE::P64 = P64[_sg5GR::P64 + 24];
           _sg5GI::P64 = P64[_sg5GR::P64 + 32];
           _sg5GJ::P64 = P64[_sg5GR::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5GI::P64;
           P64[Hp - 24] = _sg5GE::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sg5GJ::P64;
           R2 = _sg5Gx::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5GN_entry() //  [R1, R2]
         { info_tbl: [(cg89z,
                       label: sat_sg5GN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg89z: // global
           _sg5GK::P64 = R2;
           _sg5GN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg89A; else goto cg89B;
       cg89B: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg89D; else goto cg89C;
       cg89D: // global
           HpAlloc = 56;
           goto cg89A;
       cg89A: // global
           R2 = _sg5GK::P64;
           R1 = _sg5GN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg89C: // global
           _sg5Gx::P64 = P64[_sg5GN::P64 + 7];
           _sg5GI::P64 = P64[_sg5GN::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5GI::P64;
           P64[Hp - 24] = _sg5GK::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sg5Gx::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5GO_entry() //  [R1]
         { info_tbl: [(cg89E,
                       label: sat_sg5GO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg89E: // global
           _sg5GO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg89F; else goto cg89G;
       cg89G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg89I; else goto cg89H;
       cg89I: // global
           HpAlloc = 24;
           goto cg89F;
       cg89F: // global
           R1 = _sg5GO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg89H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5GO::P64;
           _sg5Gx::P64 = P64[_sg5GO::P64 + 16];
           _sg5GF::P64 = P64[_sg5GO::P64 + 24];
           _sg5GI::P64 = P64[_sg5GO::P64 + 32];
           I64[Hp - 16] = sat_sg5GN_info;
           P64[Hp - 8] = _sg5Gx::P64;
           P64[Hp] = _sg5GI::P64;
           R2 = _sg5Gx::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5GF::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5GS_entry() //  [R1, R2]
         { info_tbl: [(cg89J,
                       label: sat_sg5GS_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg89J: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg89K; else goto cg89L;
       cg89K: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg89L: // global
           I64[Sp - 40] = block_cg898_info;
           _sg5Gt::P64 = P64[R1 + 7];
           _sg5Gx::P64 = P64[R1 + 15];
           _sg5GE::P64 = P64[R1 + 23];
           _sg5GF::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5Gt::P64;
           P64[Sp - 24] = _sg5Gx::P64;
           P64[Sp - 16] = _sg5GE::P64;
           P64[Sp - 8] = _sg5GF::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug89P; else goto cg899;
       ug89P: // global
           call _cg898(R1) args: 0, res: 0, upd: 0;
       cg899: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg898() //  [R1]
         { info_tbl: [(cg898,
                       label: block_cg898_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg898: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg89O; else goto cg89N;
       cg89O: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg89N: // global
           _sg5GI::P64 = P64[R1 + 7];
           _sg5GJ::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sg5GR_info;
           _sg5Gx::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sg5Gx::P64;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _sg5GI::P64;
           P64[Hp - 40] = _sg5GJ::P64;
           I64[Hp - 32] = sat_sg5GO_info;
           P64[Hp - 16] = _sg5Gx::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sg5GI::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sg5GB_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg89Q,
                       label: k1_sg5GB_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg89Q: // global
           _sg5GE::P64 = R4;
           _sg5GD::P64 = R3;
           _sg5GC::P64 = R2;
           _sg5GB::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg89R; else goto cg89S;
       cg89S: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg89U; else goto cg89T;
       cg89U: // global
           HpAlloc = 80;
           goto cg89R;
       cg89R: // global
           R4 = _sg5GE::P64;
           R3 = _sg5GD::P64;
           R2 = _sg5GC::P64;
           R1 = _sg5GB::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg89T: // global
           _sg5Gt::P64 = P64[_sg5GB::P64 + 5];
           _sg5Gu::P64 = P64[_sg5GB::P64 + 13];
           _sg5Gx::P64 = P64[_sg5GB::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sg5Gu::P64;
           P64[Hp - 48] = _sg5GC::P64;
           P64[Hp - 40] = _sg5GE::P64;
           I64[Hp - 32] = sat_sg5GS_info;
           P64[Hp - 24] = _sg5Gt::P64;
           P64[Hp - 16] = _sg5Gx::P64;
           P64[Hp - 8] = _sg5GE::P64;
           P64[Hp] = Hp - 72;
           R2 = _sg5Gx::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg5GD::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5GT_entry() //  [R1]
         { info_tbl: [(cg8a3,
                       label: sat_sg5GT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8a3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg8a4; else goto cg8a5;
       cg8a4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8a5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Product.$fDataProduct1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5GU_entry() //  [R1]
         { info_tbl: [(cg8a6,
                       label: sat_sg5GU_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8a6: // global
           _sg5GU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg8a7; else goto cg8a8;
       cg8a8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8aa; else goto cg8a9;
       cg8aa: // global
           HpAlloc = 24;
           goto cg8a7;
       cg8a7: // global
           R1 = _sg5GU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8a9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5GU::P64;
           _sg5Gr::P64 = P64[_sg5GU::P64 + 16];
           _sg5Gx::P64 = P64[_sg5GU::P64 + 24];
           _sg5Gz::P64 = P64[_sg5GU::P64 + 32];
           _sg5GB::P64 = P64[_sg5GU::P64 + 40];
           I64[Hp - 16] = sat_sg5GT_info;
           P64[Hp] = _sg5Gx::P64;
           R4 = _sg5Gz::P64;
           R3 = Hp - 16;
           R2 = _sg5Gr::P64;
           R1 = _sg5GB::P64;
           Sp = Sp - 16;
           call k1_sg5GB_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5GV_entry() //  [R1]
         { info_tbl: [(cg8ab,
                       label: sat_sg5GV_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8ab: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cg8ac; else goto cg8ad;
       cg8ac: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8ad: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cg88S_info;
           _sg5Gr::P64 = P64[R1 + 16];
           _sg5Gs::P64 = P64[R1 + 24];
           _sg5Gt::P64 = P64[R1 + 32];
           _sg5Gu::P64 = P64[R1 + 40];
           _sg5Gx::P64 = P64[R1 + 56];
           R1 = P64[R1 + 48];
           P64[Sp - 56] = _sg5Gr::P64;
           P64[Sp - 48] = _sg5Gs::P64;
           P64[Sp - 40] = _sg5Gt::P64;
           P64[Sp - 32] = _sg5Gu::P64;
           P64[Sp - 24] = _sg5Gx::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ug8ah; else goto cg88T;
       ug8ah: // global
           call _cg88S(R1) args: 0, res: 0, upd: 0;
       cg88T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg88S() //  [R1]
         { info_tbl: [(cg88S,
                       label: block_cg88S_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg88S: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg8ag; else goto cg8af;
       cg8ag: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg8af: // global
           _sg5Gz::P64 = P64[R1 + 7];
           _sg5GA::P64 = P64[R1 + 15];
           I64[Hp - 72] = k1_sg5GB_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = P64[Sp + 32];
           _sg5Gx::P64 = P64[Sp + 40];
           P64[Hp - 48] = _sg5Gx::P64;
           I64[Hp - 40] = sat_sg5GU_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sg5Gx::P64;
           P64[Hp - 8] = _sg5Gz::P64;
           _cg88X::P64 = Hp - 69;
           P64[Hp] = _cg88X::P64;
           R4 = _sg5GA::P64;
           R3 = Hp - 40;
           R2 = P64[Sp + 16];
           R1 = _cg88X::P64;
           Sp = Sp + 48;
           call k1_sg5GB_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cgmapMp_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8ai,
                       label: Data.Functor.Product.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8ai: // global
           _sg5Gv::P64 = R6;
           _sg5Gu::P64 = R5;
           _sg5Gt::P64 = R4;
           _sg5Gs::P64 = R3;
           _sg5Gr::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg8aj; else goto cg8ak;
       cg8ak: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8am; else goto cg8al;
       cg8am: // global
           HpAlloc = 24;
           goto cg8aj;
       cg8aj: // global
           R6 = _sg5Gv::P64;
           R5 = _sg5Gu::P64;
           R4 = _sg5Gt::P64;
           R3 = _sg5Gs::P64;
           R2 = _sg5Gr::P64;
           R1 = Data.Functor.Product.$w$cgmapMp_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8al: // global
           I64[Hp - 16] = lvl9_sg5Gw_info;
           P64[Hp] = _sg5Gt::P64;
           I64[Sp - 56] = block_cg88h_info;
           R2 = _sg5Gt::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sg5Gr::P64;
           P64[Sp - 32] = _sg5Gs::P64;
           P64[Sp - 24] = _sg5Gt::P64;
           P64[Sp - 16] = _sg5Gu::P64;
           P64[Sp - 8] = _sg5Gv::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg88h() //  [R1]
         { info_tbl: [(cg88h,
                       label: block_cg88h_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg88h: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg8ap; else goto cg8ao;
       cg8ap: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8ao: // global
           I64[Hp - 80] = sat_sg5H1_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sg5GV_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.701619796 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapMp_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapMp_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapMp_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapMp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8ar: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapMp_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapMp_entry() //  [R6]
         { info_tbl: [(cg8av,
                       label: Data.Functor.Product.$fDataProduct_$cgmapMp_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8av: // global
           _sg5H6::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sg5H6::P64;
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cgmapMp_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.703763742 UTC

[section ""data" . Data.Functor.Product.$w$cgmapM_closure" {
     Data.Functor.Product.$w$cgmapM_closure:
         const Data.Functor.Product.$w$cgmapM_info;
 },
 sat_sg5Hp_entry() //  [R1, R2]
         { info_tbl: [(cg8aT,
                       label: sat_sg5Hp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8aT: // global
           _sg5Hn::P64 = R2;
           _sg5Hp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg8aU; else goto cg8aV;
       cg8aV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg8aX; else goto cg8aW;
       cg8aX: // global
           HpAlloc = 32;
           goto cg8aU;
       cg8aU: // global
           R2 = _sg5Hn::P64;
           R1 = _sg5Hp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8aW: // global
           _sg5Hd::P64 = P64[_sg5Hp::P64 + 7];
           _sg5Hm::P64 = P64[_sg5Hp::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sg5Hm::P64;
           P64[Hp] = _sg5Hn::P64;
           R2 = _sg5Hd::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5Hq_entry() //  [R1, R2]
         { info_tbl: [(cg8aY,
                       label: sat_sg5Hq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8aY: // global
           _sg5Hm::P64 = R2;
           _sg5Hq::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg8aZ; else goto cg8b0;
       cg8b0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8b2; else goto cg8b1;
       cg8b2: // global
           HpAlloc = 24;
           goto cg8aZ;
       cg8aZ: // global
           R2 = _sg5Hm::P64;
           R1 = _sg5Hq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8b1: // global
           _sg5Hd::P64 = P64[_sg5Hq::P64 + 7];
           _sg5Hl::P64 = P64[_sg5Hq::P64 + 15];
           I64[Hp - 16] = sat_sg5Hp_info;
           P64[Hp - 8] = _sg5Hd::P64;
           P64[Hp] = _sg5Hm::P64;
           R2 = _sg5Hd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg5Hl::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sg5Hh_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg8b3,
                       label: k1_sg5Hh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8b3: // global
           _sg5Hk::P64 = R4;
           _sg5Hj::P64 = R3;
           _sg5Hi::P64 = R2;
           _sg5Hh::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg8b4; else goto cg8b5;
       cg8b5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg8b7; else goto cg8b6;
       cg8b7: // global
           HpAlloc = 64;
           goto cg8b4;
       cg8b4: // global
           R4 = _sg5Hk::P64;
           R3 = _sg5Hj::P64;
           R2 = _sg5Hi::P64;
           R1 = _sg5Hh::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8b6: // global
           _sg5Hd::P64 = P64[_sg5Hh::P64 + 5];
           _sg5He::P64 = P64[_sg5Hh::P64 + 13];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sg5He::P64;
           P64[Hp - 32] = _sg5Hi::P64;
           P64[Hp - 24] = _sg5Hk::P64;
           I64[Hp - 16] = sat_sg5Hq_info;
           P64[Hp - 8] = _sg5Hd::P64;
           P64[Hp] = Hp - 56;
           R2 = _sg5Hd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg5Hj::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5Hr_entry() //  [R1]
         { info_tbl: [(cg8bg,
                       label: sat_sg5Hr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8bg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg8bh; else goto cg8bi;
       cg8bh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8bi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Product.Pair_closure+2;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5Hs_entry() //  [R1]
         { info_tbl: [(cg8bj,
                       label: sat_sg5Hs_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8bj: // global
           _sg5Hs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg8bk; else goto cg8bl;
       cg8bl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8bn; else goto cg8bm;
       cg8bn: // global
           HpAlloc = 24;
           goto cg8bk;
       cg8bk: // global
           R1 = _sg5Hs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8bm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Hs::P64;
           _sg5Hb::P64 = P64[_sg5Hs::P64 + 16];
           _sg5Hd::P64 = P64[_sg5Hs::P64 + 24];
           _sg5Hf::P64 = P64[_sg5Hs::P64 + 32];
           _sg5Hh::P64 = P64[_sg5Hs::P64 + 40];
           I64[Hp - 16] = sat_sg5Hr_info;
           P64[Hp] = _sg5Hd::P64;
           R4 = _sg5Hf::P64;
           R3 = Hp - 16;
           R2 = _sg5Hb::P64;
           R1 = _sg5Hh::P64;
           Sp = Sp - 16;
           call k1_sg5Hh_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cgmapM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8bo,
                       label: Data.Functor.Product.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8bo: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg8bs; else goto cg8br;
       cg8bs: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$cgmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg8br: // global
           I64[Hp - 64] = k1_sg5Hh_info;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           I64[Hp - 40] = sat_sg5Hs_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R6;
           _cg8aC::P64 = Hp - 61;
           P64[Hp] = _cg8aC::P64;
           R4 = P64[Sp];
           _sg5Hc::P64 = R3;
           R3 = Hp - 40;
           R2 = _sg5Hc::P64;
           R1 = _cg8aC::P64;
           Sp = Sp + 8;
           call k1_sg5Hh_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.707201366 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapM_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapM_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapM_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapM_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8bu: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapM_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2,
                                                                 R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapM_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cg8bB,
                       label: Data.Functor.Product.$fDataProduct_$cgmapM_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8bB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg8bC; else goto cg8bD;
       cg8bC: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgmapM_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cg8bD: // global
           I64[Sp - 8] = block_cg8by_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8bH; else goto cg8bz;
       ug8bH: // global
           call _cg8by(R1) args: 0, res: 0, upd: 0;
       cg8bz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8by() //  [R1]
         { info_tbl: [(cg8by,
                       label: block_cg8by_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8by: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cgmapM_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.709238419 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapQi_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapQi_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapQi_info;
         const 0;
 },
 Data.Functor.Product.$fDataProduct_$cgmapQi_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8bJ: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapQi_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapQi_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cg8bQ,
                       label: Data.Functor.Product.$fDataProduct_$cgmapQi_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8bQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8bU; else goto cg8bV;
       cg8bU: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgmapQi_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cg8bV: // global
           I64[Sp - 8] = block_cg8bN_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8c9; else goto cg8bO;
       ug8c9: // global
           call _cg8bN(R1) args: 0, res: 0, upd: 0;
       cg8bO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8bN() //  [R1]
         { info_tbl: [(cg8bN,
                       label: block_cg8bN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8bN: // global
           I64[Sp - 8] = block_cg8bT_info;
           _sg5HP::P64 = P64[R1 + 7];
           _sg5HQ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sg5HQ::P64;
           P64[Sp + 16] = _sg5HP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8c8; else goto cg8bX;
       ug8c8: // global
           call _cg8bT(R1) args: 0, res: 0, upd: 0;
       cg8bX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8bT() //  [R1]
         { info_tbl: [(cg8bT,
                       label: block_cg8bT_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8bT: // global
           _sg5HM::P64 = P64[Sp + 32];
           _sg5HT::I64 = I64[R1 + 7];
           if (_sg5HT::I64 != 0) goto ug8c7; else goto cg8c5;
       ug8c7: // global
           if (_sg5HT::I64 != 1) goto cg8c4; else goto cg8c6;
       cg8c4: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg8c6: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           R1 = _sg5HM::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8c5: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 40];
           R1 = _sg5HM::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.711803229 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapQr_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapQr_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapQr_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapQr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8cb: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapQr_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg5I9_entry() //  [R1]
         { info_tbl: [(cg8cp,
                       label: sat_sg5I9_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8cp: // global
           _sg5I9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg8cq; else goto cg8cr;
       cg8cr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg8ct; else goto cg8cs;
       cg8ct: // global
           HpAlloc = 40;
           goto cg8cq;
       cg8cq: // global
           R1 = _sg5I9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8cs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5I9::P64;
           _sg5HZ::P64 = P64[_sg5I9::P64 + 16];
           _sg5I0::P64 = P64[_sg5I9::P64 + 24];
           _sg5I1::P64 = P64[_sg5I9::P64 + 32];
           _sg5I2::P64 = P64[_sg5I9::P64 + 40];
           _sg5I6::P64 = P64[_sg5I9::P64 + 48];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg5I2::P64;
           P64[Hp - 8] = _sg5HZ::P64;
           P64[Hp] = _sg5I6::P64;
           R3 = _sg5I1::P64;
           R2 = Hp - 32;
           R1 = _sg5I0::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapQr_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cg8cu,
                       label: Data.Functor.Product.$fDataProduct_$cgmapQr_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8cu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg8cw; else goto cg8cx;
       cg8cw: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgmapQr_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cg8cx: // global
           I64[Sp - 8] = block_cg8cf_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8cB; else goto cg8cg;
       ug8cB: // global
           call _cg8cf(R1) args: 0, res: 0, upd: 0;
       cg8cg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8cf() //  [R1]
         { info_tbl: [(cg8cf,
                       label: block_cg8cf_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8cf: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cg8cA; else goto cg8cz;
       cg8cA: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8cz: // global
           _sg5I5::P64 = P64[R1 + 7];
           _sg5I6::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_sg5I9_info;
           P64[Hp - 72] = P64[Sp + 8];
           _sg5I0::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sg5I0::P64;
           P64[Hp - 56] = P64[Sp + 24];
           _sg5I2::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sg5I2::P64;
           P64[Hp - 40] = _sg5I6::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg5I2::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sg5I5::P64;
           R3 = Hp - 88;
           R2 = Hp - 32;
           R1 = _sg5I0::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.714695974 UTC

[section ""data" . Data.Functor.Product.$fDataProduct2_closure" {
     Data.Functor.Product.$fDataProduct2_closure:
         const Data.Functor.Product.$fDataProduct2_info;
 },
 Data.Functor.Product.$fDataProduct2_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8cD: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct2_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg5Io_entry() //  [R1]
         { info_tbl: [(cg8cS,
                       label: sat_sg5Io_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8cS: // global
           _sg5Io::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg8cT; else goto cg8cU;
       cg8cU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg8cW; else goto cg8cV;
       cg8cW: // global
           HpAlloc = 40;
           goto cg8cT;
       cg8cT: // global
           R1 = _sg5Io::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8cV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Io::P64;
           _sg5Ie::P64 = P64[_sg5Io::P64 + 16];
           _sg5Ig::P64 = P64[_sg5Io::P64 + 24];
           _sg5Ih::P64 = P64[_sg5Io::P64 + 32];
           _sg5Ii::P64 = P64[_sg5Io::P64 + 40];
           _sg5Il::P64 = P64[_sg5Io::P64 + 48];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg5Ii::P64;
           P64[Hp - 8] = _sg5Ie::P64;
           P64[Hp] = _sg5Il::P64;
           R3 = Hp - 32;
           R2 = _sg5Ih::P64;
           R1 = _sg5Ig::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct2_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg8cX,
                       label: Data.Functor.Product.$fDataProduct2_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8cX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg8cY; else goto cg8cZ;
       cg8cY: // global
           R1 = Data.Functor.Product.$fDataProduct2_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cg8cZ: // global
           I64[Sp - 8] = block_cg8cH_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8d3; else goto cg8cI;
       ug8d3: // global
           call _cg8cH(R1) args: 0, res: 0, upd: 0;
       cg8cI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8cH() //  [R1]
         { info_tbl: [(cg8cH,
                       label: block_cg8cH_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8cH: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cg8d2; else goto cg8d1;
       cg8d2: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8d1: // global
           _sg5Il::P64 = P64[R1 + 7];
           _sg5Im::P64 = P64[R1 + 15];
           I64[Hp - 88] = stg_ap_3_upd_info;
           _sg5Ii::P64 = P64[Sp + 32];
           P64[Hp - 72] = _sg5Ii::P64;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sg5Im::P64;
           I64[Hp - 48] = sat_sg5Io_info;
           P64[Hp - 32] = P64[Sp + 40];
           _sg5Ig::P64 = P64[Sp + 16];
           P64[Hp - 24] = _sg5Ig::P64;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sg5Ii::P64;
           P64[Hp] = _sg5Il::P64;
           R3 = Hp - 88;
           R2 = Hp - 48;
           R1 = _sg5Ig::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.720616567 UTC

[section ""data" . Data.Functor.Product.$w$cgmapMo_closure" {
     Data.Functor.Product.$w$cgmapMo_closure:
         const Data.Functor.Product.$w$cgmapMo_info;
 },
 lvl9_sg5Iv_entry() //  [R1]
         { info_tbl: [(cg8dc,
                       label: lvl9_sg5Iv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8dc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8dd; else goto cg8de;
       cg8dd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8de: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5J3_entry() //  [R1, R2]
         { info_tbl: [(cg8dr,
                       label: sat_sg5J3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8dr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg8ds; else goto cg8dt;
       cg8ds: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8dt: // global
           I64[Sp - 24] = block_cg8do_info;
           _sg5Iv::P64 = P64[R1 + 7];
           _sg5Iw::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sg5Iv::P64;
           P64[Sp - 8] = _sg5Iw::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug8dL; else goto cg8dp;
       ug8dL: // global
           call _cg8do(R1) args: 0, res: 0, upd: 0;
       cg8dp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8do() //  [R1]
         { info_tbl: [(cg8do,
                       label: block_cg8do_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8do: // global
           I64[Sp - 8] = block_cg8dw_info;
           _sg5J0::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sg5J0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8dK; else goto cg8dy;
       ug8dK: // global
           call _cg8dw(R1) args: 0, res: 0, upd: 0;
       cg8dy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8dw() //  [R1]
         { info_tbl: [(cg8dw,
                       label: block_cg8dw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8dw: // global
           if (R1 & 7 == 1) goto cg8dE; else goto cg8dI;
       cg8dE: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg8dI: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5IR_entry() //  [R1]
         { info_tbl: [(cg8em,
                       label: sat_sg5IR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8em: // global
           _sg5IR::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg8en; else goto cg8eo;
       cg8eo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg8eq; else goto cg8ep;
       cg8eq: // global
           HpAlloc = 56;
           goto cg8en;
       cg8en: // global
           R1 = _sg5IR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8ep: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5IR::P64;
           _sg5Iw::P64 = P64[_sg5IR::P64 + 16];
           _sg5ID::P64 = P64[_sg5IR::P64 + 24];
           _sg5IH::P64 = P64[_sg5IR::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5IH::P64;
           P64[Hp - 24] = _sg5ID::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sg5Iw::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5IN_entry() //  [R1, R2]
         { info_tbl: [(cg8eC,
                       label: sat_sg5IN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8eC: // global
           _sg5IK::P64 = R2;
           _sg5IN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg8eD; else goto cg8eE;
       cg8eE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg8eG; else goto cg8eF;
       cg8eG: // global
           HpAlloc = 56;
           goto cg8eD;
       cg8eD: // global
           R2 = _sg5IK::P64;
           R1 = _sg5IN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8eF: // global
           _sg5Iw::P64 = P64[_sg5IN::P64 + 7];
           _sg5IH::P64 = P64[_sg5IN::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5IH::P64;
           P64[Hp - 24] = _sg5IK::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sg5Iw::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5IO_entry() //  [R1]
         { info_tbl: [(cg8eH,
                       label: sat_sg5IO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8eH: // global
           _sg5IO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg8eI; else goto cg8eJ;
       cg8eJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8eL; else goto cg8eK;
       cg8eL: // global
           HpAlloc = 24;
           goto cg8eI;
       cg8eI: // global
           R1 = _sg5IO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8eK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5IO::P64;
           _sg5Iw::P64 = P64[_sg5IO::P64 + 16];
           _sg5IE::P64 = P64[_sg5IO::P64 + 24];
           _sg5IH::P64 = P64[_sg5IO::P64 + 32];
           I64[Hp - 16] = sat_sg5IN_info;
           P64[Hp - 8] = _sg5Iw::P64;
           P64[Hp] = _sg5IH::P64;
           R2 = _sg5Iw::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5IE::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5IU_entry() //  [R1, R2]
         { info_tbl: [(cg8eM,
                       label: sat_sg5IU_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8eM: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg8eN; else goto cg8eO;
       cg8eN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8eO: // global
           I64[Sp - 40] = block_cg8e6_info;
           _sg5Is::P64 = P64[R1 + 7];
           _sg5Iw::P64 = P64[R1 + 15];
           _sg5ID::P64 = P64[R1 + 23];
           _sg5IE::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5Is::P64;
           P64[Sp - 24] = _sg5Iw::P64;
           P64[Sp - 16] = _sg5ID::P64;
           P64[Sp - 8] = _sg5IE::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8f5; else goto cg8e7;
       ug8f5: // global
           call _cg8e6(R1) args: 0, res: 0, upd: 0;
       cg8e7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8e6() //  [R1]
         { info_tbl: [(cg8e6,
                       label: block_cg8e6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8e6: // global
           I64[Sp - 8] = block_cg8eb_info;
           _sg5IH::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sg5IH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8f4; else goto cg8ec;
       ug8f4: // global
           call _cg8eb(R1) args: 0, res: 0, upd: 0;
       cg8ec: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8eb() //  [R1]
         { info_tbl: [(cg8eb,
                       label: block_cg8eb_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8eb: // global
           _sg5Iw::P64 = P64[Sp + 24];
           _sg5ID::P64 = P64[Sp + 32];
           _sg5IH::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cg8eR; else goto cg8eV;
       cg8eR: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg8eU; else goto cg8eT;
       cg8eU: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8eT: // global
           I64[Hp - 72] = sat_sg5IR_info;
           P64[Hp - 56] = _sg5Iw::P64;
           P64[Hp - 48] = _sg5ID::P64;
           P64[Hp - 40] = _sg5IH::P64;
           I64[Hp - 32] = sat_sg5IO_info;
           P64[Hp - 16] = _sg5Iw::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sg5IH::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cg8eV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg8f0; else goto cg8eZ;
       cg8f0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8eZ: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5IH::P64;
           P64[Hp - 24] = _sg5ID::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sg5Iw::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 k1_sg5IA_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg8f6,
                       label: k1_sg5IA_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8f6: // global
           _sg5ID::P64 = R4;
           _sg5IC::P64 = R3;
           _sg5IB::P64 = R2;
           _sg5IA::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cg8f7; else goto cg8f8;
       cg8f8: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg8fa; else goto cg8f9;
       cg8fa: // global
           HpAlloc = 80;
           goto cg8f7;
       cg8f7: // global
           R4 = _sg5ID::P64;
           R3 = _sg5IC::P64;
           R2 = _sg5IB::P64;
           R1 = _sg5IA::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8f9: // global
           _sg5Is::P64 = P64[_sg5IA::P64 + 5];
           _sg5It::P64 = P64[_sg5IA::P64 + 13];
           _sg5Iw::P64 = P64[_sg5IA::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sg5It::P64;
           P64[Hp - 48] = _sg5IB::P64;
           P64[Hp - 40] = _sg5ID::P64;
           I64[Hp - 32] = sat_sg5IU_info;
           P64[Hp - 24] = _sg5Is::P64;
           P64[Hp - 16] = _sg5Iw::P64;
           P64[Hp - 8] = _sg5ID::P64;
           P64[Hp] = Hp - 72;
           R2 = _sg5Iw::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg5IC::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5IV_entry() //  [R1]
         { info_tbl: [(cg8fj,
                       label: sat_sg5IV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8fj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg8fk; else goto cg8fl;
       cg8fk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8fl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Product.$fDataProduct1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5IW_entry() //  [R1]
         { info_tbl: [(cg8fm,
                       label: sat_sg5IW_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8fm: // global
           _sg5IW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg8fn; else goto cg8fo;
       cg8fo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8fq; else goto cg8fp;
       cg8fq: // global
           HpAlloc = 24;
           goto cg8fn;
       cg8fn: // global
           R1 = _sg5IW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8fp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5IW::P64;
           _sg5Iq::P64 = P64[_sg5IW::P64 + 16];
           _sg5Iw::P64 = P64[_sg5IW::P64 + 24];
           _sg5Iy::P64 = P64[_sg5IW::P64 + 32];
           _sg5IA::P64 = P64[_sg5IW::P64 + 40];
           I64[Hp - 16] = sat_sg5IV_info;
           P64[Hp] = _sg5Iw::P64;
           R4 = _sg5Iy::P64;
           R3 = Hp - 16;
           R2 = _sg5Iq::P64;
           R1 = _sg5IA::P64;
           Sp = Sp - 16;
           call k1_sg5IA_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5IX_entry() //  [R1]
         { info_tbl: [(cg8fr,
                       label: sat_sg5IX_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8fr: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cg8fs; else goto cg8ft;
       cg8fs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8ft: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cg8dQ_info;
           _sg5Iq::P64 = P64[R1 + 16];
           _sg5Ir::P64 = P64[R1 + 24];
           _sg5Is::P64 = P64[R1 + 32];
           _sg5It::P64 = P64[R1 + 40];
           _sg5Iw::P64 = P64[R1 + 56];
           R1 = P64[R1 + 48];
           P64[Sp - 56] = _sg5Iq::P64;
           P64[Sp - 48] = _sg5Ir::P64;
           P64[Sp - 40] = _sg5Is::P64;
           P64[Sp - 32] = _sg5It::P64;
           P64[Sp - 24] = _sg5Iw::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ug8fx; else goto cg8dR;
       ug8fx: // global
           call _cg8dQ(R1) args: 0, res: 0, upd: 0;
       cg8dR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg8dQ() //  [R1]
         { info_tbl: [(cg8dQ,
                       label: block_cg8dQ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8dQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg8fw; else goto cg8fv;
       cg8fw: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg8fv: // global
           _sg5Iy::P64 = P64[R1 + 7];
           _sg5Iz::P64 = P64[R1 + 15];
           I64[Hp - 72] = k1_sg5IA_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = P64[Sp + 32];
           _sg5Iw::P64 = P64[Sp + 40];
           P64[Hp - 48] = _sg5Iw::P64;
           I64[Hp - 40] = sat_sg5IW_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sg5Iw::P64;
           P64[Hp - 8] = _sg5Iy::P64;
           _cg8dV::P64 = Hp - 69;
           P64[Hp] = _cg8dV::P64;
           R4 = _sg5Iz::P64;
           R3 = Hp - 40;
           R2 = P64[Sp + 16];
           R1 = _cg8dV::P64;
           Sp = Sp + 48;
           call k1_sg5IA_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cgmapMo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8fy,
                       label: Data.Functor.Product.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8fy: // global
           _sg5Iu::P64 = R6;
           _sg5It::P64 = R5;
           _sg5Is::P64 = R4;
           _sg5Ir::P64 = R3;
           _sg5Iq::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg8fz; else goto cg8fA;
       cg8fA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8fC; else goto cg8fB;
       cg8fC: // global
           HpAlloc = 24;
           goto cg8fz;
       cg8fz: // global
           R6 = _sg5Iu::P64;
           R5 = _sg5It::P64;
           R4 = _sg5Is::P64;
           R3 = _sg5Ir::P64;
           R2 = _sg5Iq::P64;
           R1 = Data.Functor.Product.$w$cgmapMo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8fB: // global
           I64[Hp - 16] = lvl9_sg5Iv_info;
           P64[Hp] = _sg5Is::P64;
           I64[Sp - 56] = block_cg8df_info;
           R2 = _sg5Is::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sg5Iq::P64;
           P64[Sp - 32] = _sg5Ir::P64;
           P64[Sp - 24] = _sg5Is::P64;
           P64[Sp - 16] = _sg5It::P64;
           P64[Sp - 8] = _sg5Iu::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg8df() //  [R1]
         { info_tbl: [(cg8df,
                       label: block_cg8df_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8df: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg8fF; else goto cg8fE;
       cg8fF: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8fE: // global
           I64[Hp - 80] = sat_sg5J3_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sg5IX_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.727840927 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapMo_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapMo_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapMo_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapMo_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8fH: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapMo_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapMo_entry() //  [R6]
         { info_tbl: [(cg8fL,
                       label: Data.Functor.Product.$fDataProduct_$cgmapMo_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8fL: // global
           _sg5J8::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sg5J8::P64;
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cgmapMo_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.729110959 UTC

[section ""data" . lvl5_rg5oj_closure" {
     lvl5_rg5oj_closure:
         const lvl5_rg5oj_info;
         const 0;
 },
 lvl5_rg5oj_entry() //  [R2]
         { info_tbl: [(cg8fV,
                       label: lvl5_rg5oj_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8fV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg8fW; else goto cg8fX;
       cg8fW: // global
           R2 = R2;
           R1 = lvl5_rg5oj_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8fX: // global
           I64[Sp - 8] = block_cg8fS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8g1; else goto cg8fT;
       ug8g1: // global
           call _cg8fS() args: 0, res: 0, upd: 0;
       cg8fT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8fS() //  []
         { info_tbl: [(cg8fS,
                       label: block_cg8fS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8fS: // global
           R1 = Data.Functor.Product.$cPair_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.730327273 UTC

[section ""data" . lvl6_rg5ok_closure" {
     lvl6_rg5ok_closure:
         const lvl6_rg5ok_info;
         const 0;
 },
 lvl6_rg5ok_entry() //  []
         { info_tbl: [(cg8g6,
                       label: lvl6_rg5ok_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8g6: // global
           R1 = Data.Functor.Product.$tProduct_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.731208673 UTC

[section ""data" . lvl7_rg5ol_closure" {
     lvl7_rg5ol_closure:
         const lvl7_rg5ol_info;
 },
 lvl7_rg5ol_entry() //  []
         { info_tbl: [(cg8gd,
                       label: lvl7_rg5ol_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8gd: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.732024549 UTC

[section ""data" . lvl8_rg5om_closure" {
     lvl8_rg5om_closure:
         const lvl8_rg5om_info;
 },
 lvl8_rg5om_entry() //  []
         { info_tbl: [(cg8gk,
                       label: lvl8_rg5om_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8gk: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.735909667 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_closure" {
     Data.Functor.Product.$fDataProduct_closure:
         const Data.Functor.Product.$fDataProduct_info;
         const 0;
 },
 sat_sg5K2_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg8gw,
                       label: sat_sg5K2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8gw: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$w$cgmapMo_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5JY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg8gE,
                       label: sat_sg5JY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8gE: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$w$cgmapMp_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5JU_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg8gM,
                       label: sat_sg5JU_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8gM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg8gN; else goto cg8gO;
       cg8gN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8gO: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Product.$fDataProduct_$cgmapM_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg5JT_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg8gU,
                       label: sat_sg5JT_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8gU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg8gV; else goto cg8gW;
       cg8gV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8gW: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Product.$fDataProduct_$cgmapQi_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg5JS_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8h5,
                       label: sat_sg5JS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8h5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg8hc; else goto cg8hd;
       cg8hc: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8hd: // global
           I64[Sp - 32] = block_cg8h2_info;
           _sg5Jq::P64 = P64[R1 + 6];
           _sg5Jr::P64 = P64[R1 + 14];
           R1 = R3;
           P64[Sp - 24] = _sg5Jq::P64;
           P64[Sp - 16] = _sg5Jr::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug8hh; else goto cg8h3;
       ug8hh: // global
           call _cg8h2(R1) args: 0, res: 0, upd: 0;
       cg8h3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8h2() //  [R1]
         { info_tbl: [(cg8h2,
                       label: block_cg8h2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8h2: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg8hg; else goto cg8hf;
       cg8hg: // global
           HpAlloc = 128;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8hf: // global
           _sg5JN::P64 = P64[R1 + 7];
           _sg5JO::P64 = P64[R1 + 15];
           I64[Hp - 120] = stg_ap_3_upd_info;
           _sg5JK::P64 = P64[Sp + 24];
           P64[Hp - 104] = _sg5JK::P64;
           P64[Hp - 96] = P64[Sp + 16];
           P64[Hp - 88] = _sg5JO::P64;
           I64[Hp - 80] = :_con_info;
           P64[Hp - 72] = Hp - 120;
           P64[Hp - 64] = GHC.Types.[]_closure+1;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sg5JK::P64;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg5JN::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 78;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5JJ_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg8hn,
                       label: sat_sg5JJ_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8hn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8ho; else goto cg8hp;
       cg8ho: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8hp: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Product.$fDataProduct_$cgmapQr_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg5JI_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg8hv,
                       label: sat_sg5JI_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8hv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8hw; else goto cg8hx;
       cg8hw: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8hx: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Product.$fDataProduct2_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg5JH_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8hG,
                       label: sat_sg5JH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8hG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg8hM; else goto cg8hN;
       cg8hM: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8hN: // global
           I64[Sp - 32] = block_cg8hD_info;
           _sg5Jq::P64 = P64[R1 + 6];
           _sg5Jr::P64 = P64[R1 + 14];
           R1 = R3;
           P64[Sp - 24] = _sg5Jq::P64;
           P64[Sp - 16] = _sg5Jr::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug8hR; else goto cg8hE;
       ug8hR: // global
           call _cg8hD(R1) args: 0, res: 0, upd: 0;
       cg8hE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8hD() //  [R1]
         { info_tbl: [(cg8hD,
                       label: block_cg8hD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8hD: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg8hQ; else goto cg8hP;
       cg8hQ: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8hP: // global
           _sg5JD::P64 = P64[R1 + 7];
           _sg5JE::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           _sg5JA::P64 = P64[Sp + 24];
           P64[Hp - 80] = _sg5JA::P64;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sg5JE::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sg5JA::P64;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg5JD::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Jx_entry() //  [R1]
         { info_tbl: [(cg8i5,
                       label: sat_sg5Jx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8i5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8i6; else goto cg8i7;
       cg8i6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8i7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Product.Pair_closure+2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Jy_entry() //  [R1]
         { info_tbl: [(cg8i8,
                       label: sat_sg5Jy_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8i8: // global
           _sg5Jy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg8i9; else goto cg8ia;
       cg8ia: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8ic; else goto cg8ib;
       cg8ic: // global
           HpAlloc = 24;
           goto cg8i9;
       cg8i9: // global
           R1 = _sg5Jy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8ib: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Jy::P64;
           _sg5Jq::P64 = P64[_sg5Jy::P64 + 16];
           _sg5Ju::P64 = P64[_sg5Jy::P64 + 24];
           _sg5Jv::P64 = P64[_sg5Jy::P64 + 32];
           I64[Hp - 16] = sat_sg5Jx_info;
           P64[Hp] = _sg5Jv::P64;
           R3 = Hp - 16;
           R2 = _sg5Jq::P64;
           R1 = _sg5Ju::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Jz_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg8id,
                       label: sat_sg5Jz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8id: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg8ih; else goto cg8ig;
       cg8ih: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8ig: // global
           _sg5Jq::P64 = P64[R1 + 5];
           _sg5Jr::P64 = P64[R1 + 13];
           I64[Hp - 32] = sat_sg5Jy_info;
           P64[Hp - 16] = _sg5Jq::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 32;
           _sg5Ju::P64 = R2;
           R2 = _sg5Jr::P64;
           R1 = _sg5Ju::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Jt_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg8in,
                       label: sat_sg5Jt_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8in: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg8io; else goto cg8ip;
       cg8io: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8ip: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Product.$fDataProduct_$cgfoldl_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg5Js_entry() //  [R1]
         { info_tbl: [(cg8iu,
                       label: sat_sg5Js_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8iu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8iv; else goto cg8iw;
       cg8iv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8iw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$w$cp1Data_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8iy,
                       label: Data.Functor.Product.$fDataProduct_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8iy: // global
           Hp = Hp + 576;
           if (Hp > HpLim) (likely: False) goto cg8iC; else goto cg8iB;
       cg8iC: // global
           HpAlloc = 576;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fDataProduct_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg8iB: // global
           I64[Hp - 568] = sat_sg5K2_info;
           P64[Hp - 560] = R6;
           _sg5Jr::P64 = P64[Sp];
           P64[Hp - 552] = _sg5Jr::P64;
           I64[Hp - 544] = sat_sg5JY_info;
           P64[Hp - 536] = R6;
           P64[Hp - 528] = _sg5Jr::P64;
           I64[Hp - 520] = sat_sg5JU_info;
           P64[Hp - 512] = R2;
           P64[Hp - 504] = R3;
           P64[Hp - 496] = R4;
           P64[Hp - 488] = R5;
           P64[Hp - 480] = R6;
           P64[Hp - 472] = _sg5Jr::P64;
           I64[Hp - 464] = sat_sg5JT_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           P64[Hp - 440] = R4;
           P64[Hp - 432] = R5;
           P64[Hp - 424] = R6;
           P64[Hp - 416] = _sg5Jr::P64;
           I64[Hp - 408] = sat_sg5JS_info;
           P64[Hp - 400] = R6;
           P64[Hp - 392] = _sg5Jr::P64;
           I64[Hp - 384] = sat_sg5JJ_info;
           P64[Hp - 376] = R2;
           P64[Hp - 368] = R3;
           P64[Hp - 360] = R4;
           P64[Hp - 352] = R5;
           P64[Hp - 344] = R6;
           P64[Hp - 336] = _sg5Jr::P64;
           I64[Hp - 328] = sat_sg5JI_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           P64[Hp - 296] = R5;
           P64[Hp - 288] = R6;
           P64[Hp - 280] = _sg5Jr::P64;
           I64[Hp - 272] = sat_sg5JH_info;
           P64[Hp - 264] = R6;
           P64[Hp - 256] = _sg5Jr::P64;
           I64[Hp - 248] = sat_sg5Jz_info;
           P64[Hp - 240] = R6;
           P64[Hp - 232] = _sg5Jr::P64;
           I64[Hp - 224] = sat_sg5Jt_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           P64[Hp - 200] = R4;
           P64[Hp - 192] = R5;
           P64[Hp - 184] = R6;
           P64[Hp - 176] = _sg5Jr::P64;
           I64[Hp - 168] = sat_sg5Js_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           P64[Hp - 136] = R4;
           P64[Hp - 128] = R5;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 168;
           P64[Hp - 104] = Hp - 221;
           P64[Hp - 96] = Hp - 245;
           P64[Hp - 88] = lvl5_rg5oj_closure+1;
           P64[Hp - 80] = lvl6_rg5ok_closure+1;
           P64[Hp - 72] = lvl7_rg5ol_closure+2;
           P64[Hp - 64] = lvl8_rg5om_closure+2;
           P64[Hp - 56] = Hp - 270;
           P64[Hp - 48] = Hp - 324;
           P64[Hp - 40] = Hp - 380;
           P64[Hp - 32] = Hp - 406;
           P64[Hp - 24] = Hp - 461;
           P64[Hp - 16] = Hp - 517;
           P64[Hp - 8] = Hp - 541;
           P64[Hp] = Hp - 565;
           R1 = Hp - 119;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.743306442 UTC

[section ""data" . Data.Functor.Product.Pair_closure" {
     Data.Functor.Product.Pair_closure:
         const Data.Functor.Product.Pair_info;
 },
 Data.Functor.Product.Pair_entry() //  [R2, R3]
         { info_tbl: [(cg8iI,
                       label: Data.Functor.Product.Pair_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8iI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8iM; else goto cg8iL;
       cg8iM: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.Pair_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8iL: // global
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.744276606 UTC

[Data.Functor.Product.Pair_con_entry() //  [R1]
         { info_tbl: [(cg8iN,
                       label: Data.Functor.Product.Pair_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,80,114,111,100,117,99,116,46,80,97,105,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8iN: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.745059716 UTC

[section ""relreadonly" . Sg5Oh_srt" {
     Sg5Oh_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Product.$fRead1Product1_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadList_closure;
         const Data.Functor.Product.$fRead1Product_closure;
         const Data.Functor.Product.$fRead1Product2_closure;
         const Data.Functor.Product.$w$cliftShowsPrec_closure;
         const Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure;
         const Data.Functor.Product.$fShow1Product_$cliftShowList_closure;
         const Data.Functor.Product.$fShow1Product_closure;
         const Data.Functor.Product.$fReadProduct_$creadPrec_closure;
         const Data.Functor.Product.$fReadProduct_$creadsPrec_closure;
         const Data.Functor.Product.$fReadProduct_$creadListPrec_closure;
         const Data.Functor.Product.$fReadProduct_$creadList_closure;
         const Data.Functor.Product.$fReadProduct_closure;
         const Data.Functor.Product.$w$cshowsPrec_closure;
         const Data.Functor.Product.$fShowProduct_$cshowsPrec_closure;
         const Data.Functor.Product.$w$cshow_closure;
         const Data.Functor.Product.$fShowProduct_$cshow_closure;
         const Data.Functor.Product.$fShowProduct_$cshowList_closure;
         const Data.Functor.Product.$fShowProduct_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Functor.Product.$fFoldableProduct_$csum_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Functor.Product.$fFoldableProduct2_closure;
         const Data.Functor.Product.$fFoldableProduct_$cminimum_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Product.$fFoldableProduct3_closure;
         const Data.Functor.Product.$fFoldableProduct_$cmaximum_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Functor.Product.$fFoldableProduct_$celem_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Functor.Product.$fFoldableProduct8_closure;
         const Data.Functor.Product.$w$cfoldl_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldl_closure;
         const Data.Functor.Product.$w$cfoldl1_closure;
         const Data.Functor.Product.$fFoldableProduct7_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure;
         const Data.Functor.Product.$w$cfoldr'_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure;
         const Data.Functor.Product.$w$cfoldr_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldr_closure;
         const Data.Functor.Product.$w$cfoldl'_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure;
         const Data.Functor.Product.$fFoldableProduct_$clength_closure;
         const Data.Functor.Product.$w$cfoldr1_closure;
         const Data.Functor.Product.$fFoldableProduct9_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure;
         const Data.Functor.Product.$fFoldableProduct_$cnull_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Functor.Product.$fFoldableProduct_$cproduct_closure;
         const Data.Functor.Product.$fFoldableProduct_$ctoList_closure;
         const Data.Functor.Product.$fFoldableProduct_closure;
         const Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure;
         const Data.Functor.Product.$fTraversableProduct_closure;
         const poly_some_v_rg5o0_closure;
         const Data.Functor.Product.$fAlternativeProduct_$csome_closure;
         const Data.Functor.Product.$fAlternativeProduct_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Product.$fMonadProduct_closure;
         const lvl4_rg5o1_closure;
         const Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure;
         const Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure;
         const Data.Functor.Product.$fMonadPlusProduct_closure;
         const Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure;
         const Data.Functor.Product.$fMonadFixProduct_closure;
         const Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure;
         const Data.Functor.Product.$fMonadZipProduct_closure;
         const GHC.List.badHead_closure;
         const go61_rg5o2_closure;
         const Data.Functor.Product.$fRead1Product2_closure;
         const Data.Data.mkConstr1_closure;
         const Data.Functor.Product.$fDataProduct4_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Functor.Product.$w$cp1Data_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Functor.Product.$fDataProduct_$cgmapQi_closure;
         const Data.Functor.Product.$cPair_closure;
         const lvl5_rg5oj_closure;
         const Data.Functor.Product.$tProduct_closure;
         const Data.Functor.Product.$fDataProduct_closure;
         const lvl6_rg5ok_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.747734161 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:55.749457753 UTC

[section ""data" . Data.Functor.Product.$fEq1Product_$cliftEq_closure" {
     Data.Functor.Product.$fEq1Product_$cliftEq_closure:
         const Data.Functor.Product.$fEq1Product_$cliftEq_info;
 },
 Data.Functor.Product.$fEq1Product_$cliftEq_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cg8iW,
                       label: Data.Functor.Product.$fEq1Product_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8iW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg8j0; else goto cg8j1;
       cg8j0: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEq1Product_$cliftEq_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8j1: // global
           I64[Sp - 40] = block_cg8iT_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8jl; else goto cg8iU;
       ug8jl: // global
           call _cg8iT(R1) args: 0, res: 0, upd: 0;
       cg8iU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8iT() //  [R1]
         { info_tbl: [(cg8iT,
                       label: block_cg8iT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8iT: // global
           I64[Sp - 8] = block_cg8iZ_info;
           _sg5ou::P64 = P64[R1 + 7];
           _sg5ov::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5ov::P64;
           P64[Sp + 32] = _sg5ou::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8jk; else goto cg8j3;
       ug8jk: // global
           call _cg8iZ(R1) args: 0, res: 0, upd: 0;
       cg8j3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8iZ() //  [R1]
         { info_tbl: [(cg8iZ,
                       label: block_cg8iZ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8iZ: // global
           I64[Sp] = block_cg8j7_info;
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           _sg5oy::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp + 40] = _sg5oy::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8j7() //  [R1]
         { info_tbl: [(cg8j7,
                       label: block_cg8j7_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8j7: // global
           if (R1 & 7 == 1) goto cg8je; else goto cg8ji;
       cg8je: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg8ji: // global
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           R1 = P64[Sp + 24];
           Sp = Sp + 48;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.759455884 UTC

[section ""data" . Data.Functor.Product.$fEq1Product_closure" {
     Data.Functor.Product.$fEq1Product_closure:
         const Data.Functor.Product.$fEq1Product_info;
 },
 Data.Functor.Product.$fEq1Product_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8jJ,
                       label: Data.Functor.Product.$fEq1Product_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8jJ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Product.$fEq1Product_$cliftEq_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.763553406 UTC

[section ""data" . Data.Functor.Product.$w$cliftCompare_closure" {
     Data.Functor.Product.$w$cliftCompare_closure:
         const Data.Functor.Product.$w$cliftCompare_info;
 },
 Data.Functor.Product.$w$cliftCompare_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8jR: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cliftCompare_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cliftCompare_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cg8k2,
                       label: Data.Functor.Product.$w$cliftCompare_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8k2: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg8k3; else goto cg8k4;
       cg8k3: // global
           R1 = Data.Functor.Product.$w$cliftCompare_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg8k4: // global
           I64[Sp - 24] = block_cg8jV_info;
           R2 = R2;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = R4;
           P64[Sp - 40] = R5;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = R3;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg8jV() //  [R1]
         { info_tbl: [(cg8jV,
                       label: block_cg8jV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8jV: // global
           _cg8k1::P64 = R1 & 7;
           if (_cg8k1::P64 < 3) goto ug8ke; else goto cg8k0;
       ug8ke: // global
           if (_cg8k1::P64 < 2) goto cg8jY; else goto cg8jZ;
       cg8jY: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg8jZ: // global
           R2 = P64[Sp + 24];
           _sg5oC::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           _sg5oE::P64 = P64[Sp + 16];
           P64[Sp + 16] = _sg5oC::P64;
           P64[Sp + 24] = _sg5oE::P64;
           Sp = Sp + 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
       cg8k0: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.77171377 UTC

[section ""data" . Data.Functor.Product.$fOrd1Product_$cliftCompare_closure" {
     Data.Functor.Product.$fOrd1Product_$cliftCompare_closure:
         const Data.Functor.Product.$fOrd1Product_$cliftCompare_info;
 },
 Data.Functor.Product.$fOrd1Product_$cliftCompare_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cg8kA,
                       label: Data.Functor.Product.$fOrd1Product_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8kA: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg8kE; else goto cg8kF;
       cg8kE: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrd1Product_$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8kF: // global
           I64[Sp - 40] = block_cg8kx_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8kN; else goto cg8ky;
       ug8kN: // global
           call _cg8kx(R1) args: 0, res: 0, upd: 0;
       cg8ky: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8kx() //  [R1]
         { info_tbl: [(cg8kx,
                       label: block_cg8kx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8kx: // global
           I64[Sp - 8] = block_cg8kD_info;
           _sg5oO::P64 = P64[R1 + 7];
           _sg5oP::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5oP::P64;
           P64[Sp + 32] = _sg5oO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8kM; else goto cg8kH;
       ug8kM: // global
           call _cg8kD(R1) args: 0, res: 0, upd: 0;
       cg8kH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8kD() //  [R1]
         { info_tbl: [(cg8kD,
                       label: block_cg8kD_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8kD: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cliftCompare_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.781069828 UTC

[section ""data" . Data.Functor.Product.$w$cp1Ord1_closure" {
     Data.Functor.Product.$w$cp1Ord1_closure:
         const Data.Functor.Product.$w$cp1Ord1_info;
 },
 Data.Functor.Product.$w$cp1Ord1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8l4: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cp1Ord1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cp1Ord1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8le,
                       label: Data.Functor.Product.$w$cp1Ord1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8le: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg8lf; else goto cg8lg;
       cg8lf: // global
           R1 = Data.Functor.Product.$w$cp1Ord1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg8lg: // global
           I64[Sp - 24] = block_cg8l8_info;
           R2 = R2;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = R4;
           P64[Sp - 40] = R5;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = R3;
           Sp = Sp - 56;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg8l8() //  [R1]
         { info_tbl: [(cg8l8,
                       label: block_cg8l8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8l8: // global
           if (R1 & 7 == 1) goto cg8lb; else goto cg8lc;
       cg8lb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg8lc: // global
           R2 = P64[Sp + 24];
           _sg5oV::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           _sg5oX::P64 = P64[Sp + 16];
           P64[Sp + 16] = _sg5oV::P64;
           P64[Sp + 24] = _sg5oX::P64;
           Sp = Sp + 8;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.789018908 UTC

[section ""data" . Data.Functor.Product.$fOrd1Product1_closure" {
     Data.Functor.Product.$fOrd1Product1_closure:
         const Data.Functor.Product.$fOrd1Product1_info;
 },
 Data.Functor.Product.$fOrd1Product1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cg8lI,
                       label: Data.Functor.Product.$fOrd1Product1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8lI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg8lM; else goto cg8lN;
       cg8lM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrd1Product1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8lN: // global
           I64[Sp - 40] = block_cg8lF_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8lV; else goto cg8lG;
       ug8lV: // global
           call _cg8lF(R1) args: 0, res: 0, upd: 0;
       cg8lG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8lF() //  [R1]
         { info_tbl: [(cg8lF,
                       label: block_cg8lF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8lF: // global
           I64[Sp - 8] = block_cg8lL_info;
           _sg5p7::P64 = P64[R1 + 7];
           _sg5p8::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5p8::P64;
           P64[Sp + 32] = _sg5p7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8lU; else goto cg8lP;
       ug8lU: // global
           call _cg8lL(R1) args: 0, res: 0, upd: 0;
       cg8lP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8lL() //  [R1]
         { info_tbl: [(cg8lL,
                       label: block_cg8lL_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8lL: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cp1Ord1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.79774811 UTC

[section ""data" . Data.Functor.Product.$fOrd1Product_closure" {
     Data.Functor.Product.$fOrd1Product_closure:
         const Data.Functor.Product.$fOrd1Product_info;
 },
 sat_sg5pf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg8mk,
                       label: sat_sg5pf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8mk: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fOrd1Product_$cliftCompare_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pe_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg8ms,
                       label: sat_sg5pe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8ms: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fOrd1Product1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fOrd1Product_entry() //  [R2, R3]
         { info_tbl: [(cg8mw,
                       label: Data.Functor.Product.$fOrd1Product_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8mw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg8mA; else goto cg8mz;
       cg8mA: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrd1Product_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8mz: // global
           I64[Hp - 64] = sat_sg5pf_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5pe_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 37;
           P64[Hp] = Hp - 61;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.80583373 UTC

[section ""cstring" . Data.Functor.Product.$fRead1Product3_bytes" {
     Data.Functor.Product.$fRead1Product3_bytes:
         I8[] [80,97,105,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.807771579 UTC

[section ""data" . Data.Functor.Product.$fRead1Product2_closure" {
     Data.Functor.Product.$fRead1Product2_closure:
         const Data.Functor.Product.$fRead1Product2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fRead1Product2_entry() //  [R1]
         { info_tbl: [(cg8mV,
                       label: Data.Functor.Product.$fRead1Product2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8mV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8mW; else goto cg8mX;
       cg8mW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8mX: // global
           (_cg8mS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg8mS::I64 == 0) goto cg8mU; else goto cg8mT;
       cg8mU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg8mT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg8mS::I64;
           R2 = Data.Functor.Product.$fRead1Product3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.812467284 UTC

[section ""data" . Data.Functor.Product.$fRead1Product1_closure" {
     Data.Functor.Product.$fRead1Product1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Product.$fRead1Product2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.814327534 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_lvl3_closure" {
     Data.Functor.Product.$fRead1Product_lvl3_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.81801853 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadPrec_info;
         const 0;
 },
 reader_sg5pk_entry() //  [R1]
         { info_tbl: [(cg8nf,
                       label: reader_sg5pk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8nf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8ng; else goto cg8nh;
       cg8ng: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8nh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 reader1_sg5pl_entry() //  [R1]
         { info_tbl: [(cg8nm,
                       label: reader1_sg5pl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8nm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8nn; else goto cg8no;
       cg8nn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8no: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5pu_entry() //  [R1, R2]
         { info_tbl: [(cg8nO,
                       label: sat_sg5pu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8nO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8nS; else goto cg8nR;
       cg8nS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8nR: // global
           _sg5po::P64 = P64[R1 + 7];
           _sg5pr::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = _sg5pr::P64;
           P64[Hp] = R2;
           R2 = Hp - 15;
           R1 = _sg5po::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pv_entry() //  [R1, R2]
         { info_tbl: [(cg8nT,
                       label: sat_sg5pv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8nT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8nX; else goto cg8nW;
       cg8nX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8nW: // global
           _sg5pl::P64 = P64[R1 + 7];
           _sg5po::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sg5pu_info;
           P64[Hp - 8] = _sg5po::P64;
           P64[Hp] = R2;
           R3 = Hp - 15;
           R2 = Data.Functor.Product.$fRead1Product_lvl3_closure+1;
           R1 = _sg5pl::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pw_entry() //  [R1, R2]
         { info_tbl: [(cg8nY,
                       label: sat_sg5pw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8nY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8o2; else goto cg8o1;
       cg8o2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8o1: // global
           _sg5pk::P64 = P64[R1 + 7];
           _sg5pl::P64 = P64[R1 + 15];
           _sg5po::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_sg5pv_info;
           P64[Hp - 8] = _sg5pl::P64;
           P64[Hp] = _sg5po::P64;
           R3 = Hp - 15;
           R2 = Data.Functor.Product.$fRead1Product_lvl3_closure+1;
           R1 = _sg5pk::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wlvl_sg5pm_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8o6,
                       label: $wlvl_sg5pm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8o6: // global
           _sg5po::P64 = R3;
           _sg5pn::I64 = R2;
           _sg5pm::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cg8o7; else goto cg8o8;
       cg8o8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg8oa; else goto cg8o9;
       cg8oa: // global
           HpAlloc = 32;
           goto cg8o7;
       cg8o7: // global
           R3 = _sg5po::P64;
           R2 = _sg5pn::I64;
           R1 = _sg5pm::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8o9: // global
           if (%MO_S_Gt_W64(_sg5pn::I64, 10)) goto cg8o4; else goto cg8o5;
       cg8o4: // global
           Hp = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg8o5: // global
           _sg5pk::P64 = P64[_sg5pm::P64 + 6];
           _sg5pl::P64 = P64[_sg5pm::P64 + 14];
           I64[Hp - 24] = sat_sg5pw_info;
           P64[Hp - 16] = _sg5pk::P64;
           P64[Hp - 8] = _sg5pl::P64;
           P64[Hp] = _sg5po::P64;
           I64[Sp - 8] = block_cg8ob_info;
           R3 = Hp - 23;
           R2 = Data.Functor.Product.$fRead1Product1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg8ob() //  [R1]
         { info_tbl: [(cg8ob,
                       label: block_cg8ob_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8ob: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg8og; else goto cg8of;
       cg8og: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8of: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl9_sg5pz_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8op,
                       label: lvl9_sg5pz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8op: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg8oq; else goto cg8or;
       cg8oq: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8or: // global
           I64[Sp - 24] = block_cg8om_info;
           _sg5pm::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sg5pm::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug8ov; else goto cg8on;
       ug8ov: // global
           call _cg8om(R1) args: 0, res: 0, upd: 0;
       cg8on: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8om() //  [R1]
         { info_tbl: [(cg8om,
                       label: block_cg8om_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8om: // global
           R3 = P64[Sp + 16];
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call $wlvl_sg5pm_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pG_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8oB,
                       label: sat_sg5pG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8oB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cg8oE,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8oE: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cg8oI; else goto cg8oH;
       cg8oI: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8oH: // global
           I64[Hp - 128] = reader_sg5pk_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R4;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = reader1_sg5pl_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = $wlvl_sg5pm_info;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 88;
           I64[Hp - 24] = lvl9_sg5pz_info;
           P64[Hp - 16] = Hp - 46;
           I64[Hp - 8] = sat_sg5pG_info;
           P64[Hp] = Hp - 22;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.847792383 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadsPrec_info;
         const 0;
 },
 sat_sg5pR_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8pN,
                       label: sat_sg5pR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8pN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg8pO; else goto cg8pP;
       cg8pO: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8pP: // global
           I64[Sp - 8] = block_cg8pK_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg8pK() //  [R1]
         { info_tbl: [(cg8pK,
                       label: block_cg8pK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8pK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg8pS; else goto cg8pR;
       cg8pS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8pR: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5pM_entry() //  [R1, R2]
         { info_tbl: [(cg8pY,
                       label: sat_sg5pM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8pY: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sg5pL_entry() //  [R1]
         { info_tbl: [(cg8q1,
                       label: ds_sg5pL_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8q1: // global
           _sg5pL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg8q2; else goto cg8q3;
       cg8q3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg8q5; else goto cg8q4;
       cg8q5: // global
           HpAlloc = 32;
           goto cg8q2;
       cg8q2: // global
           R1 = _sg5pL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8q4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5pL::P64;
           _sg5pH::P64 = P64[_sg5pL::P64 + 16];
           _sg5pI::P64 = P64[_sg5pL::P64 + 24];
           _sg5pJ::P64 = P64[_sg5pL::P64 + 32];
           _sg5pK::P64 = P64[_sg5pL::P64 + 40];
           I64[Hp - 24] = sat_sg5pR_info;
           P64[Hp - 16] = _sg5pK::P64;
           I64[Hp - 8] = sat_sg5pM_info;
           P64[Hp] = _sg5pJ::P64;
           R5 = Hp - 22;
           R4 = Hp - 7;
           R3 = _sg5pI::P64;
           R2 = _sg5pH::P64;
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5pT_entry() //  [R1]
         { info_tbl: [(cg8qf,
                       label: sat_sg5pT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8qf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8qg; else goto cg8qh;
       cg8qg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8qh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5pU_entry() //  [R1, R2]
         { info_tbl: [(cg8qi,
                       label: sat_sg5pU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8qi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg8qm; else goto cg8ql;
       cg8qm: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8ql: // global
           _sg5pL::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sg5pT_info;
           P64[Hp - 8] = _sg5pL::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadsPrec_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cg8qn,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8qn: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg8qr; else goto cg8qq;
       cg8qr: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8qq: // global
           I64[Hp - 56] = ds_sg5pL_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = sat_sg5pU_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.872778941 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadListPrec_info;
         const 0;
 },
 sat_sg5pZ_entry() //  [R1]
         { info_tbl: [(cg8r2,
                       label: sat_sg5pZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8r2: // global
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadListPrec_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cg8r5,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8r5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg8r9; else goto cg8r8;
       cg8r9: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8r8: // global
           I64[Hp - 40] = sat_sg5pZ_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.879516396 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_closure" {
     Data.Functor.Product.$fRead1Product_closure:
         const Data.Functor.Product.$fRead1Product_info;
         const 0;
 },
 sat_sg5q5_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8rq,
                       label: sat_sg5q5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8rq: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fRead1Product_$cliftReadListPrec_entry(R5,
                                                                             R4,
                                                                             R3,
                                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5q4_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8ry,
                       label: sat_sg5q4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8ry: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5q3_entry() //  [R1]
         { info_tbl: [(cg8rF,
                       label: sat_sg5q3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8rF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8rG; else goto cg8rH;
       cg8rG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8rH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_$cliftReadList_entry(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5q2_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8rN,
                       label: sat_sg5q2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8rN: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fRead1Product_$cliftReadsPrec_entry(R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_entry() //  [R2, R3]
         { info_tbl: [(cg8rR,
                       label: Data.Functor.Product.$fRead1Product_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8rR: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cg8rV; else goto cg8rU;
       cg8rV: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8rU: // global
           I64[Hp - 136] = sat_sg5q5_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sg5q4_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sg5q3_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sg5q2_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 54;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 134;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadList_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadList_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadList_info;
         const 0;
 },
 sat_sg5q8_entry() //  [R1]
         { info_tbl: [(cg8s4,
                       label: sat_sg5q8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8s4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8s5; else goto cg8s6;
       cg8s5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8s6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_entry(R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadList_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cg8s7,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8s7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg8sb; else goto cg8sa;
       cg8sb: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8sa: // global
           I64[Hp - 24] = sat_sg5q8_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.897069773 UTC

[section ""data" . Data.Functor.Product.$w$cliftShowsPrec_closure" {
     Data.Functor.Product.$w$cliftShowsPrec_closure:
         const Data.Functor.Product.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8sH: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5qh_entry() //  [R1]
         { info_tbl: [(cg8sP,
                       label: sat_sg5qh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8sP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg8sQ; else goto cg8sR;
       cg8sQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8sR: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5qg_entry() //  [R1]
         { info_tbl: [(cg8sW,
                       label: sat_sg5qg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8sW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg8sX; else goto cg8sY;
       cg8sX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8sY: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg8sZ,
                       label: Data.Functor.Product.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, True, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8sZ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg8t3; else goto cg8t2;
       cg8t3: // global
           HpAlloc = 80;
           R1 = Data.Functor.Product.$w$cliftShowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg8t2: // global
           I64[Hp - 72] = sat_sg5qh_info;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sg5qg_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sg5qd::I64 = R6;
           R6 = P64[Sp];
           R5 = _sg5qd::I64;
           R4 = Data.Functor.Product.$fRead1Product2_closure;
           R3 = Hp - 72;
           R2 = Hp - 32;
           Sp = Sp + 8;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.907786105 UTC

[section ""data" . Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure" {
     Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure:
         const Data.Functor.Product.$fShow1Product_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$fShow1Product_$cliftShowsPrec_entry() //  [R2,
                                                                  R3, R4, R5, R6]
         { info_tbl: [(cg8tt,
                       label: Data.Functor.Product.$fShow1Product_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8tt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8tx; else goto cg8ty;
       cg8tx: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg8ty: // global
           I64[Sp - 40] = block_cg8tq_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8tG; else goto cg8tr;
       ug8tG: // global
           call _cg8tq(R1) args: 0, res: 0, upd: 0;
       cg8tr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8tq() //  [R1]
         { info_tbl: [(cg8tq,
                       label: block_cg8tq_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8tq: // global
           I64[Sp] = block_cg8tw_info;
           _sg5qp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sg5qp::I64;
           if (R1 & 7 != 0) goto ug8tF; else goto cg8tA;
       ug8tF: // global
           call _cg8tw(R1) args: 0, res: 0, upd: 0;
       cg8tA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8tw() //  [R1]
         { info_tbl: [(cg8tw,
                       label: block_cg8tw_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8tw: // global
           R6 = I64[Sp + 40];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.916145377 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct4_closure" {
     Data.Functor.Product.$fFoldableProduct4_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.918730379 UTC

[section ""data" . Data.Functor.Product.$fShow1Product_$cliftShowList_closure" {
     Data.Functor.Product.$fShow1Product_$cliftShowList_closure:
         const Data.Functor.Product.$fShow1Product_$cliftShowList_info;
         const 0;
 },
 sat_sg5qD_entry() //  [R1, R2]
         { info_tbl: [(cg8u9,
                       label: sat_sg5qD_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8u9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8ua; else goto cg8ub;
       cg8ua: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8ub: // global
           I64[Sp - 40] = block_cg8u6_info;
           _sg5qt::P64 = P64[R1 + 7];
           _sg5qu::P64 = P64[R1 + 15];
           _sg5qv::P64 = P64[R1 + 23];
           _sg5qw::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5qt::P64;
           P64[Sp - 24] = _sg5qu::P64;
           P64[Sp - 16] = _sg5qv::P64;
           P64[Sp - 8] = _sg5qw::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8uf; else goto cg8u7;
       ug8uf: // global
           call _cg8u6(R1) args: 0, res: 0, upd: 0;
       cg8u7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8u6() //  [R1]
         { info_tbl: [(cg8u6,
                       label: block_cg8u6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8u6: // global
           R6 = 0;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShow1Product_$cliftShowList_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cg8ug,
                       label: Data.Functor.Product.$fShow1Product_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8ug: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg8uk; else goto cg8uj;
       cg8uk: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShow1Product_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg8uj: // global
           I64[Hp - 32] = sat_sg5qD_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 31;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.928687364 UTC

[section ""data" . Data.Functor.Product.$fShow1Product_closure" {
     Data.Functor.Product.$fShow1Product_closure:
         const Data.Functor.Product.$fShow1Product_info;
         const 0;
 },
 sat_sg5qH_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg8uI,
                       label: sat_sg5qH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8uI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg8uJ; else goto cg8uK;
       cg8uJ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8uK: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Product.$fShow1Product_$cliftShowList_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_sg5qG_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg8uQ,
                       label: sat_sg5qG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8uQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg8uR; else goto cg8uS;
       cg8uR: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8uS: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Product.$fShow1Product_$cliftShowsPrec_entry(R6,
                                                                          R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShow1Product_entry() //  [R2, R3]
         { info_tbl: [(cg8uU,
                       label: Data.Functor.Product.$fShow1Product_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8uU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg8uY; else goto cg8uX;
       cg8uY: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShow1Product_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8uX: // global
           I64[Hp - 64] = sat_sg5qH_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5qG_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 36;
           P64[Hp] = Hp - 60;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.938275425 UTC

[section ""data" . Data.Functor.Product.$w$c==_closure" {
     Data.Functor.Product.$w$c==_closure:
         const Data.Functor.Product.$w$c==_info;
 },
 Data.Functor.Product.$w$c==_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8vf: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c==_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 24, res: 0, upd: 8;
     }
 },
 eq_sg5qP_entry() //  [R1]
         { info_tbl: [(cg8vn,
                       label: eq_sg5qP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8vn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8vo; else goto cg8vp;
       cg8vo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8vp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c==_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8vw,
                       label: Data.Functor.Product.$w$c==_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8vw: // global
           _sg5qM::P64 = R6;
           _sg5qL::P64 = R5;
           _sg5qK::P64 = R4;
           _sg5qJ::P64 = R3;
           _sg5qI::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cg8vx; else goto cg8vy;
       cg8vy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8vA; else goto cg8vz;
       cg8vA: // global
           HpAlloc = 24;
           goto cg8vx;
       cg8vx: // global
           R1 = Data.Functor.Product.$w$c==_closure;
           P64[Sp - 40] = _sg5qI::P64;
           P64[Sp - 32] = _sg5qJ::P64;
           P64[Sp - 24] = _sg5qK::P64;
           P64[Sp - 16] = _sg5qL::P64;
           P64[Sp - 8] = _sg5qM::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg8vz: // global
           I64[Hp - 16] = eq_sg5qP_info;
           P64[Hp] = _sg5qK::P64;
           I64[Sp - 24] = block_cg8vq_info;
           R4 = P64[Sp];
           R3 = _sg5qL::P64;
           _cg8vj::P64 = Hp - 16;
           R2 = _cg8vj::P64;
           R1 = _sg5qI::P64;
           P64[Sp - 16] = _sg5qJ::P64;
           P64[Sp - 8] = _sg5qM::P64;
           P64[Sp] = _cg8vj::P64;
           Sp = Sp - 24;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8vq() //  [R1]
         { info_tbl: [(cg8vq,
                       label: block_cg8vq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8vq: // global
           if (R1 & 7 == 1) goto cg8vt; else goto cg8vu;
       cg8vt: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg8vu: // global
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.948209778 UTC

[section ""data" . Data.Functor.Product.$fEqProduct_$c==_closure" {
     Data.Functor.Product.$fEqProduct_$c==_closure:
         const Data.Functor.Product.$fEqProduct_$c==_info;
 },
 Data.Functor.Product.$fEqProduct_$c==_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg8w5,
                       label: Data.Functor.Product.$fEqProduct_$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8w5: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg8w9; else goto cg8wa;
       cg8w9: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEqProduct_$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8wa: // global
           I64[Sp - 40] = block_cg8w2_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8wi; else goto cg8w3;
       ug8wi: // global
           call _cg8w2(R1) args: 0, res: 0, upd: 0;
       cg8w3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8w2() //  [R1]
         { info_tbl: [(cg8w2,
                       label: block_cg8w2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8w2: // global
           I64[Sp - 8] = block_cg8w8_info;
           _sg5qX::P64 = P64[R1 + 7];
           _sg5qY::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5qY::P64;
           P64[Sp + 32] = _sg5qX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8wh; else goto cg8wc;
       ug8wh: // global
           call _cg8w8(R1) args: 0, res: 0, upd: 0;
       cg8wc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8w8() //  [R1]
         { info_tbl: [(cg8w8,
                       label: block_cg8w8_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8w8: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c==_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.958550999 UTC

[section ""data" . Data.Functor.Product.$fEqProduct_$c/=_closure" {
     Data.Functor.Product.$fEqProduct_$c/=_closure:
         const Data.Functor.Product.$fEqProduct_$c/=_info;
 },
 eq_sg5rd_entry() //  [R1]
         { info_tbl: [(cg8wQ,
                       label: eq_sg5rd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8wQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8wR; else goto cg8wS;
       cg8wR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8wS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fEqProduct_$c/=_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg8wT,
                       label: Data.Functor.Product.$fEqProduct_$c/=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8wT: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg8wU; else goto cg8wV;
       cg8wU: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEqProduct_$c/=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8wV: // global
           I64[Sp - 40] = block_cg8wC_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8xr; else goto cg8wD;
       ug8xr: // global
           call _cg8wC(R1) args: 0, res: 0, upd: 0;
       cg8wD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8wC() //  [R1]
         { info_tbl: [(cg8wC,
                       label: block_cg8wC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8wC: // global
           I64[Sp - 8] = block_cg8wH_info;
           _sg5r8::P64 = P64[R1 + 7];
           _sg5r9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5r9::P64;
           P64[Sp + 32] = _sg5r8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8xq; else goto cg8wI;
       ug8xq: // global
           call _cg8wH(R1) args: 0, res: 0, upd: 0;
       cg8wI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8wH() //  [R1]
         { info_tbl: [(cg8wH,
                       label: block_cg8wH_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8wH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8x0; else goto cg8wZ;
       cg8x0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8wZ: // global
           _sg5rb::P64 = P64[R1 + 7];
           _sg5rc::P64 = P64[R1 + 15];
           I64[Hp - 16] = eq_sg5rd_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_cg8wX_info;
           R4 = _sg5rb::P64;
           R3 = P64[Sp + 40];
           _cg8wM::P64 = Hp - 16;
           R2 = _cg8wM::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 32] = _sg5rc::P64;
           P64[Sp + 40] = _cg8wM::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8wX() //  [R1]
         { info_tbl: [(cg8wX,
                       label: block_cg8wX_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8wX: // global
           if (R1 & 7 == 1) goto ug8xo; else goto cg8xb;
       ug8xo: // global
           Sp = Sp + 48;
           call _cg8xh() args: 0, res: 0, upd: 0;
       cg8xb: // global
           _cg8wM::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cg8x9_info;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 8];
           R2 = _cg8wM::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8x9() //  [R1]
         { info_tbl: [(cg8x9,
                       label: block_cg8x9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8x9: // global
           if (R1 & 7 == 1) goto ug8xp; else goto cg8xl;
       ug8xp: // global
           Sp = Sp + 8;
           call _cg8xh() args: 0, res: 0, upd: 0;
       cg8xl: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg8xh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8xh: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.97347586 UTC

[section ""data" . Data.Functor.Product.$fEqProduct_closure" {
     Data.Functor.Product.$fEqProduct_closure:
         const Data.Functor.Product.$fEqProduct_info;
 },
 sat_sg5rk_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8y9,
                       label: sat_sg5rk_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8y9: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fEqProduct_$c/=_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5rj_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8yh,
                       label: sat_sg5rj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8yh: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fEqProduct_$c==_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fEqProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cg8yl,
                       label: Data.Functor.Product.$fEqProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8yl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg8yp; else goto cg8yo;
       cg8yp: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEqProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8yo: // global
           I64[Hp - 80] = sat_sg5rk_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg5rj_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 78;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.982616011 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$ccompare_closure" {
     Data.Functor.Product.$fOrdProduct_$ccompare_closure:
         const Data.Functor.Product.$fOrdProduct_$ccompare_info;
 },
 w_sg5rw_entry() //  [R1]
         { info_tbl: [(cg8yV,
                       label: w_sg5rw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8yV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8yW; else goto cg8yX;
       cg8yW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8yX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$ccompare_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cg8yY,
                       label: Data.Functor.Product.$fOrdProduct_$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8yY: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cg8yZ; else goto cg8z0;
       cg8yZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8z0: // global
           I64[Sp - 40] = block_cg8yH_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8zn; else goto cg8yI;
       ug8zn: // global
           call _cg8yH(R1) args: 0, res: 0, upd: 0;
       cg8yI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8yH() //  [R1]
         { info_tbl: [(cg8yH,
                       label: block_cg8yH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8yH: // global
           I64[Sp - 8] = block_cg8yM_info;
           _sg5rr::P64 = P64[R1 + 7];
           _sg5rs::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5rs::P64;
           P64[Sp + 32] = _sg5rr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8zm; else goto cg8yN;
       ug8zm: // global
           call _cg8yM(R1) args: 0, res: 0, upd: 0;
       cg8yN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8yM() //  [R1]
         { info_tbl: [(cg8yM,
                       label: block_cg8yM_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8yM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8z5; else goto cg8z4;
       cg8z5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8z4: // global
           _sg5ru::P64 = P64[R1 + 7];
           _sg5rv::P64 = P64[R1 + 15];
           I64[Hp - 16] = w_sg5rw_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_cg8z2_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           _cg8yR::P64 = Hp - 16;
           P64[Sp - 24] = _cg8yR::P64;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = _sg5ru::P64;
           P64[Sp + 32] = _sg5rv::P64;
           P64[Sp + 40] = _cg8yR::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg8z2() //  [R1]
         { info_tbl: [(cg8z2,
                       label: block_cg8z2_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8z2: // global
           _cg8zk::P64 = R1 & 7;
           if (_cg8zk::P64 < 3) goto ug8zl; else goto cg8zj;
       ug8zl: // global
           if (_cg8zk::P64 < 2) goto cg8zb; else goto cg8zf;
       cg8zb: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg8zf: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_ppp_info;
           P64[Sp + 24] = P64[Sp + 40];
           _sg5rv::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 8];
           P64[Sp + 40] = _sg5rv::P64;
           Sp = Sp + 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
       cg8zj: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:55.995775336 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$cp1Ord_closure" {
     Data.Functor.Product.$fOrdProduct_$cp1Ord_closure:
         const Data.Functor.Product.$fOrdProduct_$cp1Ord_info;
 },
 sat_sg5rD_entry() //  [R1]
         { info_tbl: [(cg8zX,
                       label: sat_sg5rD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8zX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8zY; else goto cg8zZ;
       cg8zY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8zZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5rC_entry() //  [R1]
         { info_tbl: [(cg8A4,
                       label: sat_sg5rC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8A4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8A5; else goto cg8A6;
       cg8A5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8A6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5rB_entry() //  [R1]
         { info_tbl: [(cg8Ab,
                       label: sat_sg5rB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Ab: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Ac; else goto cg8Ad;
       cg8Ac: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Ad: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$cp1Ord_entry() //  [R2, R3, R4]
         { info_tbl: [(cg8Ae,
                       label: Data.Functor.Product.$fOrdProduct_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Ae: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg8Ai; else goto cg8Ah;
       cg8Ai: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$cp1Ord_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8Ah: // global
           I64[Hp - 64] = sat_sg5rD_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sg5rC_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5rB_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fEqProduct_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.006172405 UTC

[section ""data" . Data.Functor.Product.$w$c<_closure" {
     Data.Functor.Product.$w$c<_closure:
         const Data.Functor.Product.$w$c<_info;
 },
 Data.Functor.Product.$w$c<_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8AA: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c<_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sg5rL_entry() //  [R1]
         { info_tbl: [(cg8AI,
                       label: comp_sg5rL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8AI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8AJ; else goto cg8AK;
       cg8AJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8AK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8AS,
                       label: Data.Functor.Product.$w$c<_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8AS: // global
           _sg5rI::P64 = R6;
           _sg5rH::P64 = R5;
           _sg5rG::P64 = R4;
           _sg5rF::P64 = R3;
           _sg5rE::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg8AT; else goto cg8AU;
       cg8AU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8AW; else goto cg8AV;
       cg8AW: // global
           HpAlloc = 24;
           goto cg8AT;
       cg8AT: // global
           R1 = Data.Functor.Product.$w$c<_closure;
           P64[Sp - 40] = _sg5rE::P64;
           P64[Sp - 32] = _sg5rF::P64;
           P64[Sp - 24] = _sg5rG::P64;
           P64[Sp - 16] = _sg5rH::P64;
           P64[Sp - 8] = _sg5rI::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg8AV: // global
           I64[Hp - 16] = comp_sg5rL_info;
           P64[Hp] = _sg5rG::P64;
           I64[Sp - 24] = block_cg8AL_info;
           R2 = _sg5rE::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cg8AE::P64 = Hp - 16;
           P64[Sp - 48] = _cg8AE::P64;
           P64[Sp - 40] = _sg5rH::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sg5rF::P64;
           P64[Sp - 8] = _sg5rI::P64;
           P64[Sp] = _cg8AE::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg8AL() //  [R1]
         { info_tbl: [(cg8AL,
                       label: block_cg8AL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8AL: // global
           _cg8AR::P64 = R1 & 7;
           if (_cg8AR::P64 < 3) goto ug8Bi; else goto ug8Bj;
       ug8Bi: // global
           if (_cg8AR::P64 < 2) goto ug8Bk; else goto cg8AP;
       ug8Bk: // global
           Sp = Sp + 40;
           call _cg8Bd() args: 0, res: 0, upd: 0;
       cg8AP: // global
           _sg5rK::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg8B2_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sg5rK::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug8Bj: // global
           Sp = Sp + 40;
           call _cg8AQ() args: 0, res: 0, upd: 0;
     }
 },
 _cg8B2() //  [R1]
         { info_tbl: [(cg8B2,
                       label: block_cg8B2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8B2: // global
           if (R1 & 7 == 1) goto ug8Bl; else goto ug8Bm;
       ug8Bl: // global
           Sp = Sp + 8;
           call _cg8Bd() args: 0, res: 0, upd: 0;
       ug8Bm: // global
           Sp = Sp + 8;
           call _cg8AQ() args: 0, res: 0, upd: 0;
     }
 },
 _cg8Bd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Bd: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg8AQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8AQ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.020781464 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c<_closure" {
     Data.Functor.Product.$fOrdProduct_$c<_closure:
         const Data.Functor.Product.$fOrdProduct_$c<_info;
 },
 Data.Functor.Product.$fOrdProduct_$c<_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg8C0,
                       label: Data.Functor.Product.$fOrdProduct_$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8C0: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg8C4; else goto cg8C5;
       cg8C4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8C5: // global
           I64[Sp - 40] = block_cg8BX_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8Cd; else goto cg8BY;
       ug8Cd: // global
           call _cg8BX(R1) args: 0, res: 0, upd: 0;
       cg8BY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8BX() //  [R1]
         { info_tbl: [(cg8BX,
                       label: block_cg8BX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8BX: // global
           I64[Sp - 8] = block_cg8C3_info;
           _sg5rU::P64 = P64[R1 + 7];
           _sg5rV::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5rV::P64;
           P64[Sp + 32] = _sg5rU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8Cc; else goto cg8C7;
       ug8Cc: // global
           call _cg8C3(R1) args: 0, res: 0, upd: 0;
       cg8C7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8C3() //  [R1]
         { info_tbl: [(cg8C3,
                       label: block_cg8C3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8C3: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c<_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.029542525 UTC

[section ""data" . Data.Functor.Product.$w$c>=_closure" {
     Data.Functor.Product.$w$c>=_closure:
         const Data.Functor.Product.$w$c>=_info;
 },
 Data.Functor.Product.$w$c>=_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Cu: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c>=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sg5s6_entry() //  [R1]
         { info_tbl: [(cg8CC,
                       label: comp_sg5s6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8CC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8CD; else goto cg8CE;
       cg8CD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8CE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c>=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8CM,
                       label: Data.Functor.Product.$w$c>=_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8CM: // global
           _sg5s3::P64 = R6;
           _sg5s2::P64 = R5;
           _sg5s1::P64 = R4;
           _sg5s0::P64 = R3;
           _sg5rZ::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg8CN; else goto cg8CO;
       cg8CO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8CQ; else goto cg8CP;
       cg8CQ: // global
           HpAlloc = 24;
           goto cg8CN;
       cg8CN: // global
           R1 = Data.Functor.Product.$w$c>=_closure;
           P64[Sp - 40] = _sg5rZ::P64;
           P64[Sp - 32] = _sg5s0::P64;
           P64[Sp - 24] = _sg5s1::P64;
           P64[Sp - 16] = _sg5s2::P64;
           P64[Sp - 8] = _sg5s3::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg8CP: // global
           I64[Hp - 16] = comp_sg5s6_info;
           P64[Hp] = _sg5s1::P64;
           I64[Sp - 24] = block_cg8CF_info;
           R2 = _sg5rZ::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cg8Cy::P64 = Hp - 16;
           P64[Sp - 48] = _cg8Cy::P64;
           P64[Sp - 40] = _sg5s2::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sg5s0::P64;
           P64[Sp - 8] = _sg5s3::P64;
           P64[Sp] = _cg8Cy::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg8CF() //  [R1]
         { info_tbl: [(cg8CF,
                       label: block_cg8CF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8CF: // global
           _cg8CL::P64 = R1 & 7;
           if (_cg8CL::P64 < 3) goto ug8Dc; else goto ug8Dd;
       ug8Dc: // global
           if (_cg8CL::P64 < 2) goto ug8De; else goto cg8CJ;
       ug8De: // global
           Sp = Sp + 40;
           call _cg8D7() args: 0, res: 0, upd: 0;
       cg8CJ: // global
           _sg5s5::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg8CW_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sg5s5::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug8Dd: // global
           Sp = Sp + 40;
           call _cg8CK() args: 0, res: 0, upd: 0;
     }
 },
 _cg8CW() //  [R1]
         { info_tbl: [(cg8CW,
                       label: block_cg8CW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8CW: // global
           if (R1 & 7 == 1) goto ug8Df; else goto ug8Dg;
       ug8Df: // global
           Sp = Sp + 8;
           call _cg8D7() args: 0, res: 0, upd: 0;
       ug8Dg: // global
           Sp = Sp + 8;
           call _cg8CK() args: 0, res: 0, upd: 0;
     }
 },
 _cg8D7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8D7: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg8CK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8CK: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.043792692 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c>=_closure" {
     Data.Functor.Product.$fOrdProduct_$c>=_closure:
         const Data.Functor.Product.$fOrdProduct_$c>=_info;
 },
 Data.Functor.Product.$fOrdProduct_$c>=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg8DU,
                       label: Data.Functor.Product.$fOrdProduct_$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8DU: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg8DY; else goto cg8DZ;
       cg8DY: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8DZ: // global
           I64[Sp - 40] = block_cg8DR_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8E7; else goto cg8DS;
       ug8E7: // global
           call _cg8DR(R1) args: 0, res: 0, upd: 0;
       cg8DS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8DR() //  [R1]
         { info_tbl: [(cg8DR,
                       label: block_cg8DR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8DR: // global
           I64[Sp - 8] = block_cg8DX_info;
           _sg5sf::P64 = P64[R1 + 7];
           _sg5sg::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5sg::P64;
           P64[Sp + 32] = _sg5sf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8E6; else goto cg8E1;
       ug8E6: // global
           call _cg8DX(R1) args: 0, res: 0, upd: 0;
       cg8E1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8DX() //  [R1]
         { info_tbl: [(cg8DX,
                       label: block_cg8DX_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8DX: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c>=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.052586945 UTC

[section ""data" . Data.Functor.Product.$w$c>_closure" {
     Data.Functor.Product.$w$c>_closure:
         const Data.Functor.Product.$w$c>_info;
 },
 Data.Functor.Product.$w$c>_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Eo: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sg5sr_entry() //  [R1]
         { info_tbl: [(cg8Ew,
                       label: comp_sg5sr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Ew: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Ex; else goto cg8Ey;
       cg8Ex: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Ey: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8EG,
                       label: Data.Functor.Product.$w$c>_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8EG: // global
           _sg5so::P64 = R6;
           _sg5sn::P64 = R5;
           _sg5sm::P64 = R4;
           _sg5sl::P64 = R3;
           _sg5sk::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg8EH; else goto cg8EI;
       cg8EI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8EK; else goto cg8EJ;
       cg8EK: // global
           HpAlloc = 24;
           goto cg8EH;
       cg8EH: // global
           R1 = Data.Functor.Product.$w$c>_closure;
           P64[Sp - 40] = _sg5sk::P64;
           P64[Sp - 32] = _sg5sl::P64;
           P64[Sp - 24] = _sg5sm::P64;
           P64[Sp - 16] = _sg5sn::P64;
           P64[Sp - 8] = _sg5so::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg8EJ: // global
           I64[Hp - 16] = comp_sg5sr_info;
           P64[Hp] = _sg5sm::P64;
           I64[Sp - 24] = block_cg8Ez_info;
           R2 = _sg5sk::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cg8Es::P64 = Hp - 16;
           P64[Sp - 48] = _cg8Es::P64;
           P64[Sp - 40] = _sg5sn::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sg5sl::P64;
           P64[Sp - 8] = _sg5so::P64;
           P64[Sp] = _cg8Es::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg8Ez() //  [R1]
         { info_tbl: [(cg8Ez,
                       label: block_cg8Ez_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Ez: // global
           _cg8EF::P64 = R1 & 7;
           if (_cg8EF::P64 < 3) goto ug8F6; else goto ug8F7;
       ug8F6: // global
           if (_cg8EF::P64 < 2) goto ug8F8; else goto cg8ED;
       ug8F8: // global
           Sp = Sp + 40;
           call _cg8EX() args: 0, res: 0, upd: 0;
       cg8ED: // global
           _sg5sq::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg8EQ_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sg5sq::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug8F7: // global
           Sp = Sp + 40;
           call _cg8EE() args: 0, res: 0, upd: 0;
     }
 },
 _cg8EQ() //  [R1]
         { info_tbl: [(cg8EQ,
                       label: block_cg8EQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8EQ: // global
           if (R1 & 7 == 3) goto ug8F9; else goto ug8Fa;
       ug8F9: // global
           Sp = Sp + 8;
           call _cg8EE() args: 0, res: 0, upd: 0;
       ug8Fa: // global
           Sp = Sp + 8;
           call _cg8EX() args: 0, res: 0, upd: 0;
     }
 },
 _cg8EX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8EX: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg8EE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8EE: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.066534135 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c>_closure" {
     Data.Functor.Product.$fOrdProduct_$c>_closure:
         const Data.Functor.Product.$fOrdProduct_$c>_info;
 },
 Data.Functor.Product.$fOrdProduct_$c>_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cg8FO,
                       label: Data.Functor.Product.$fOrdProduct_$c>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8FO: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg8FS; else goto cg8FT;
       cg8FS: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8FT: // global
           I64[Sp - 40] = block_cg8FL_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8G1; else goto cg8FM;
       ug8G1: // global
           call _cg8FL(R1) args: 0, res: 0, upd: 0;
       cg8FM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8FL() //  [R1]
         { info_tbl: [(cg8FL,
                       label: block_cg8FL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8FL: // global
           I64[Sp - 8] = block_cg8FR_info;
           _sg5sA::P64 = P64[R1 + 7];
           _sg5sB::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5sB::P64;
           P64[Sp + 32] = _sg5sA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8G0; else goto cg8FV;
       ug8G0: // global
           call _cg8FR(R1) args: 0, res: 0, upd: 0;
       cg8FV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8FR() //  [R1]
         { info_tbl: [(cg8FR,
                       label: block_cg8FR_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8FR: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.075912808 UTC

[section ""data" . Data.Functor.Product.$w$c<=_closure" {
     Data.Functor.Product.$w$c<=_closure:
         const Data.Functor.Product.$w$c<=_info;
 },
 Data.Functor.Product.$w$c<=_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Gi: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c<=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sg5sM_entry() //  [R1]
         { info_tbl: [(cg8Gq,
                       label: comp_sg5sM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Gq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Gr; else goto cg8Gs;
       cg8Gr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Gs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8GA,
                       label: Data.Functor.Product.$w$c<=_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8GA: // global
           _sg5sJ::P64 = R6;
           _sg5sI::P64 = R5;
           _sg5sH::P64 = R4;
           _sg5sG::P64 = R3;
           _sg5sF::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cg8GB; else goto cg8GC;
       cg8GC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8GE; else goto cg8GD;
       cg8GE: // global
           HpAlloc = 24;
           goto cg8GB;
       cg8GB: // global
           R1 = Data.Functor.Product.$w$c<=_closure;
           P64[Sp - 40] = _sg5sF::P64;
           P64[Sp - 32] = _sg5sG::P64;
           P64[Sp - 24] = _sg5sH::P64;
           P64[Sp - 16] = _sg5sI::P64;
           P64[Sp - 8] = _sg5sJ::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg8GD: // global
           I64[Hp - 16] = comp_sg5sM_info;
           P64[Hp] = _sg5sH::P64;
           I64[Sp - 24] = block_cg8Gt_info;
           R2 = _sg5sF::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cg8Gm::P64 = Hp - 16;
           P64[Sp - 48] = _cg8Gm::P64;
           P64[Sp - 40] = _sg5sI::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sg5sG::P64;
           P64[Sp - 8] = _sg5sJ::P64;
           P64[Sp] = _cg8Gm::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg8Gt() //  [R1]
         { info_tbl: [(cg8Gt,
                       label: block_cg8Gt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Gt: // global
           _cg8Gz::P64 = R1 & 7;
           if (_cg8Gz::P64 < 3) goto ug8H0; else goto ug8H1;
       ug8H0: // global
           if (_cg8Gz::P64 < 2) goto ug8H2; else goto cg8Gx;
       ug8H2: // global
           Sp = Sp + 40;
           call _cg8GR() args: 0, res: 0, upd: 0;
       cg8Gx: // global
           _sg5sL::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg8GK_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sg5sL::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug8H1: // global
           Sp = Sp + 40;
           call _cg8Gy() args: 0, res: 0, upd: 0;
     }
 },
 _cg8GK() //  [R1]
         { info_tbl: [(cg8GK,
                       label: block_cg8GK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8GK: // global
           if (R1 & 7 == 3) goto ug8H3; else goto ug8H4;
       ug8H3: // global
           Sp = Sp + 8;
           call _cg8Gy() args: 0, res: 0, upd: 0;
       ug8H4: // global
           Sp = Sp + 8;
           call _cg8GR() args: 0, res: 0, upd: 0;
     }
 },
 _cg8GR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8GR: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg8Gy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Gy: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.092928133 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c<=_closure" {
     Data.Functor.Product.$fOrdProduct_$c<=_closure:
         const Data.Functor.Product.$fOrdProduct_$c<=_info;
 },
 Data.Functor.Product.$fOrdProduct_$c<=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cg8HI,
                       label: Data.Functor.Product.$fOrdProduct_$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8HI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg8HM; else goto cg8HN;
       cg8HM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8HN: // global
           I64[Sp - 40] = block_cg8HF_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8HV; else goto cg8HG;
       ug8HV: // global
           call _cg8HF(R1) args: 0, res: 0, upd: 0;
       cg8HG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8HF() //  [R1]
         { info_tbl: [(cg8HF,
                       label: block_cg8HF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8HF: // global
           I64[Sp - 8] = block_cg8HL_info;
           _sg5sV::P64 = P64[R1 + 7];
           _sg5sW::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5sW::P64;
           P64[Sp + 32] = _sg5sV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8HU; else goto cg8HP;
       ug8HU: // global
           call _cg8HL(R1) args: 0, res: 0, upd: 0;
       cg8HP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8HL() //  [R1]
         { info_tbl: [(cg8HL,
                       label: block_cg8HL_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8HL: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c<=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.102109172 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$cmax_closure" {
     Data.Functor.Product.$fOrdProduct_$cmax_closure:
         const Data.Functor.Product.$fOrdProduct_$cmax_info;
 },
 comp_sg5tb_entry() //  [R1]
         { info_tbl: [(cg8It,
                       label: comp_sg5tb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8It: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Iu; else goto cg8Iv;
       cg8Iu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Iv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$cmax_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cg8Iw,
                       label: Data.Functor.Product.$fOrdProduct_$cmax_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Iw: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cg8Ix; else goto cg8Iy;
       cg8Ix: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$cmax_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8Iy: // global
           I64[Sp - 40] = block_cg8If_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8Jb; else goto cg8Ig;
       ug8Jb: // global
           call _cg8If(R1) args: 0, res: 0, upd: 0;
       cg8Ig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8If() //  [R1]
         { info_tbl: [(cg8If,
                       label: block_cg8If_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8If: // global
           I64[Sp - 16] = block_cg8Ik_info;
           _sg5t5::P64 = R1;
           _sg5t6::P64 = P64[R1 + 7];
           _sg5t7::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _sg5t7::P64;
           P64[Sp] = _sg5t6::P64;
           P64[Sp + 32] = _sg5t5::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ug8Ja; else goto cg8Il;
       ug8Ja: // global
           call _cg8Ik(R1) args: 0, res: 0, upd: 0;
       cg8Il: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8Ik() //  [R1]
         { info_tbl: [(cg8Ik,
                       label: block_cg8Ik_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Ik: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8ID; else goto cg8IC;
       cg8ID: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8IC: // global
           _sg5t9::P64 = P64[R1 + 7];
           _sg5ta::P64 = P64[R1 + 15];
           I64[Hp - 16] = comp_sg5tb_info;
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_cg8IA_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_ppp_info;
           _cg8Ip::P64 = Hp - 16;
           P64[Sp - 24] = _cg8Ip::P64;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = _sg5t9::P64;
           P64[Sp + 16] = _sg5ta::P64;
           P64[Sp + 24] = R1;
           P64[Sp + 40] = _cg8Ip::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg8IA() //  [R1]
         { info_tbl: [(cg8IA,
                       label: block_cg8IA_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8IA: // global
           _cg8J3::P64 = R1 & 7;
           if (_cg8J3::P64 < 3) goto ug8J5; else goto ug8J6;
       ug8J5: // global
           if (_cg8J3::P64 < 2) goto ug8J7; else goto cg8IO;
       ug8J7: // global
           Sp = Sp + 24;
           call _cg8IU() args: 0, res: 0, upd: 0;
       cg8IO: // global
           _sg5ta::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cg8IM_info;
           R2 = P64[Sp + 32];
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _sg5ta::P64;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug8J6: // global
           Sp = Sp + 48;
           call _cg8J2() args: 0, res: 0, upd: 0;
     }
 },
 _cg8IM() //  [R1]
         { info_tbl: [(cg8IM,
                       label: block_cg8IM_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8IM: // global
           if (R1 & 7 == 3) goto ug8J8; else goto ug8J9;
       ug8J8: // global
           Sp = Sp + 32;
           call _cg8J2() args: 0, res: 0, upd: 0;
       ug8J9: // global
           Sp = Sp + 8;
           call _cg8IU() args: 0, res: 0, upd: 0;
     }
 },
 _cg8IU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8IU: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg8J2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8J2: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.119520378 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$cmin_closure" {
     Data.Functor.Product.$fOrdProduct_$cmin_closure:
         const Data.Functor.Product.$fOrdProduct_$cmin_info;
 },
 comp_sg5tp_entry() //  [R1]
         { info_tbl: [(cg8Ka,
                       label: comp_sg5tp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Ka: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Kb; else goto cg8Kc;
       cg8Kb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Kc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$cmin_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cg8Kd,
                       label: Data.Functor.Product.$fOrdProduct_$cmin_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Kd: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cg8Ke; else goto cg8Kf;
       cg8Ke: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$cmin_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8Kf: // global
           I64[Sp - 40] = block_cg8JW_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8KS; else goto cg8JX;
       ug8KS: // global
           call _cg8JW(R1) args: 0, res: 0, upd: 0;
       cg8JX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8JW() //  [R1]
         { info_tbl: [(cg8JW,
                       label: block_cg8JW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8JW: // global
           I64[Sp - 16] = block_cg8K1_info;
           _sg5tj::P64 = R1;
           _sg5tk::P64 = P64[R1 + 7];
           _sg5tl::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _sg5tl::P64;
           P64[Sp] = _sg5tk::P64;
           P64[Sp + 32] = _sg5tj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ug8KR; else goto cg8K2;
       ug8KR: // global
           call _cg8K1(R1) args: 0, res: 0, upd: 0;
       cg8K2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8K1() //  [R1]
         { info_tbl: [(cg8K1,
                       label: block_cg8K1_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8K1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg8Kk; else goto cg8Kj;
       cg8Kk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8Kj: // global
           _sg5tn::P64 = P64[R1 + 7];
           _sg5to::P64 = P64[R1 + 15];
           I64[Hp - 16] = comp_sg5tp_info;
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_cg8Kh_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_ppp_info;
           _cg8K6::P64 = Hp - 16;
           P64[Sp - 24] = _cg8K6::P64;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = _sg5tn::P64;
           P64[Sp + 16] = _sg5to::P64;
           P64[Sp + 24] = R1;
           P64[Sp + 40] = _cg8K6::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg8Kh() //  [R1]
         { info_tbl: [(cg8Kh,
                       label: block_cg8Kh_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Kh: // global
           _cg8KK::P64 = R1 & 7;
           if (_cg8KK::P64 < 3) goto ug8KM; else goto ug8KN;
       ug8KM: // global
           if (_cg8KK::P64 < 2) goto ug8KO; else goto cg8Kv;
       ug8KO: // global
           Sp = Sp + 48;
           call _cg8KB() args: 0, res: 0, upd: 0;
       cg8Kv: // global
           _sg5to::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cg8Kt_info;
           R2 = P64[Sp + 32];
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _sg5to::P64;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ug8KN: // global
           Sp = Sp + 24;
           call _cg8KJ() args: 0, res: 0, upd: 0;
     }
 },
 _cg8Kt() //  [R1]
         { info_tbl: [(cg8Kt,
                       label: block_cg8Kt_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Kt: // global
           if (R1 & 7 == 3) goto ug8KP; else goto ug8KQ;
       ug8KP: // global
           Sp = Sp + 8;
           call _cg8KJ() args: 0, res: 0, upd: 0;
       ug8KQ: // global
           Sp = Sp + 32;
           call _cg8KB() args: 0, res: 0, upd: 0;
     }
 },
 _cg8KB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8KB: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg8KJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8KJ: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.138148878 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_closure" {
     Data.Functor.Product.$fOrdProduct_closure:
         const Data.Functor.Product.$fOrdProduct_info;
 },
 sat_sg5tC_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8LI,
                       label: sat_sg5tC_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8LI: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$cmin_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tB_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8LQ,
                       label: sat_sg5tB_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8LQ: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$cmax_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tA_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8LY,
                       label: sat_sg5tA_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8LY: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c>=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tz_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8M6,
                       label: sat_sg5tz_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8M6: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c>_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5ty_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8Me,
                       label: sat_sg5ty_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Me: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c<=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tx_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8Mm,
                       label: sat_sg5tx_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Mm: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c<_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tw_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8Mu,
                       label: sat_sg5tw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Mu: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$ccompare_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5tv_entry() //  [R1]
         { info_tbl: [(cg8MB,
                       label: sat_sg5tv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8MB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8MC; else goto cg8MD;
       cg8MC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8MD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fOrdProduct_$cp1Ord_entry(R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cg8MF,
                       label: Data.Functor.Product.$fOrdProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8MF: // global
           Hp = Hp + 336;
           if (Hp > HpLim) (likely: False) goto cg8MJ; else goto cg8MI;
       cg8MJ: // global
           HpAlloc = 336;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8MI: // global
           I64[Hp - 328] = sat_sg5tC_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           I64[Hp - 296] = sat_sg5tB_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           P64[Hp - 272] = R4;
           I64[Hp - 264] = sat_sg5tA_info;
           P64[Hp - 256] = R2;
           P64[Hp - 248] = R3;
           P64[Hp - 240] = R4;
           I64[Hp - 232] = sat_sg5tz_info;
           P64[Hp - 224] = R2;
           P64[Hp - 216] = R3;
           P64[Hp - 208] = R4;
           I64[Hp - 200] = sat_sg5ty_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           P64[Hp - 176] = R4;
           I64[Hp - 168] = sat_sg5tx_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = sat_sg5tw_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sat_sg5tv_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 104;
           P64[Hp - 48] = Hp - 134;
           P64[Hp - 40] = Hp - 166;
           P64[Hp - 32] = Hp - 198;
           P64[Hp - 24] = Hp - 230;
           P64[Hp - 16] = Hp - 262;
           P64[Hp - 8] = Hp - 294;
           P64[Hp] = Hp - 326;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.158446711 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadPrec_closure" {
     Data.Functor.Product.$fReadProduct_$creadPrec_closure:
         const Data.Functor.Product.$fReadProduct_$creadPrec_info;
         const 0;
 },
 sat_sg5tH_entry() //  [R1]
         { info_tbl: [(cg8Nu,
                       label: sat_sg5tH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Nu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Nv; else goto cg8Nw;
       cg8Nv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Nw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tG_entry() //  [R1]
         { info_tbl: [(cg8NB,
                       label: sat_sg5tG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8NB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8NC; else goto cg8ND;
       cg8NC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8ND: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cg8NE,
                       label: Data.Functor.Product.$fReadProduct_$creadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8NE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg8NI; else goto cg8NH;
       cg8NI: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8NH: // global
           I64[Hp - 40] = sat_sg5tH_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sg5tG_info;
           P64[Hp] = R4;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.1676022 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadsPrec_closure" {
     Data.Functor.Product.$fReadProduct_$creadsPrec_closure:
         const Data.Functor.Product.$fReadProduct_$creadsPrec_info;
         const 0;
 },
 sat_sg5tN_entry() //  [R1]
         { info_tbl: [(cg8O7,
                       label: sat_sg5tN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8O7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8O8; else goto cg8O9;
       cg8O8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8O9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tM_entry() //  [R1]
         { info_tbl: [(cg8Oe,
                       label: sat_sg5tM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Oe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Of; else goto cg8Og;
       cg8Of: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Og: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sg5tL_entry() //  [R1]
         { info_tbl: [(cg8Oh,
                       label: ds_sg5tL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Oh: // global
           _sg5tL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Oi; else goto cg8Oj;
       cg8Oj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg8Ol; else goto cg8Ok;
       cg8Ol: // global
           HpAlloc = 48;
           goto cg8Oi;
       cg8Oi: // global
           R1 = _sg5tL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Ok: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5tL::P64;
           _sg5tI::P64 = P64[_sg5tL::P64 + 16];
           _sg5tJ::P64 = P64[_sg5tL::P64 + 24];
           _sg5tK::P64 = P64[_sg5tL::P64 + 32];
           I64[Hp - 40] = sat_sg5tN_info;
           P64[Hp - 24] = _sg5tK::P64;
           I64[Hp - 16] = sat_sg5tM_info;
           P64[Hp] = _sg5tK::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sg5tJ::P64;
           R2 = _sg5tI::P64;
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tP_entry() //  [R1]
         { info_tbl: [(cg8Ov,
                       label: sat_sg5tP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Ov: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Ow; else goto cg8Ox;
       cg8Ow: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Ox: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tQ_entry() //  [R1, R2]
         { info_tbl: [(cg8Oy,
                       label: sat_sg5tQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Oy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg8OC; else goto cg8OB;
       cg8OC: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8OB: // global
           _sg5tL::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sg5tP_info;
           P64[Hp - 8] = _sg5tL::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cg8OD,
                       label: Data.Functor.Product.$fReadProduct_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8OD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg8OH; else goto cg8OG;
       cg8OH: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8OG: // global
           I64[Hp - 48] = ds_sg5tL_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sg5tQ_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.182527267 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadListPrec_closure" {
     Data.Functor.Product.$fReadProduct_$creadListPrec_closure:
         const Data.Functor.Product.$fReadProduct_$creadListPrec_info;
         const 0;
 },
 sat_sg5tV_entry() //  [R1]
         { info_tbl: [(cg8Pj,
                       label: sat_sg5tV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Pj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Pk; else goto cg8Pl;
       cg8Pk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Pl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tU_entry() //  [R1]
         { info_tbl: [(cg8Pq,
                       label: sat_sg5tU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Pq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Pr; else goto cg8Ps;
       cg8Pr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Ps: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5tW_entry() //  [R1]
         { info_tbl: [(cg8Pt,
                       label: sat_sg5tW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Pt: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg8Px; else goto cg8Pw;
       cg8Px: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Pw: // global
           _sg5tR::P64 = P64[R1 + 16];
           _sg5tS::P64 = P64[R1 + 24];
           _sg5tT::P64 = P64[R1 + 32];
           I64[Hp - 40] = sat_sg5tV_info;
           P64[Hp - 24] = _sg5tT::P64;
           I64[Hp - 16] = sat_sg5tU_info;
           P64[Hp] = _sg5tT::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sg5tS::P64;
           R2 = _sg5tR::P64;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadListPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cg8Py,
                       label: Data.Functor.Product.$fReadProduct_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Py: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg8PC; else goto cg8PB;
       cg8PC: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8PB: // global
           I64[Hp - 32] = sat_sg5tW_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.194253233 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadList_closure" {
     Data.Functor.Product.$fReadProduct_$creadList_closure:
         const Data.Functor.Product.$fReadProduct_$creadList_info;
         const 0;
 },
 sat_sg5u0_entry() //  [R1]
         { info_tbl: [(cg8Q0,
                       label: sat_sg5u0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Q0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8Q1; else goto cg8Q2;
       cg8Q1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Q2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call Data.Functor.Product.$fReadProduct_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadList_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cg8Q3,
                       label: Data.Functor.Product.$fReadProduct_$creadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Q3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg8Q7; else goto cg8Q6;
       cg8Q7: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8Q6: // global
           I64[Hp - 32] = sat_sg5u0_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.202495949 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_closure" {
     Data.Functor.Product.$fReadProduct_closure:
         const Data.Functor.Product.$fReadProduct_info;
         const 0;
 },
 sat_sg5u7_entry() //  [R1]
         { info_tbl: [(cg8Qo,
                       label: sat_sg5u7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Qo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Qp; else goto cg8Qq;
       cg8Qp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Qq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5u6_entry() //  [R1]
         { info_tbl: [(cg8Qv,
                       label: sat_sg5u6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Qv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Qw; else goto cg8Qx;
       cg8Qw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Qx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5u5_entry() //  [R1]
         { info_tbl: [(cg8QC,
                       label: sat_sg5u5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8QC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8QD; else goto cg8QE;
       cg8QD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8QE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadList_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5u4_entry() //  [R1]
         { info_tbl: [(cg8QJ,
                       label: sat_sg5u4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8QJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8QK; else goto cg8QL;
       cg8QK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8QL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadsPrec_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fReadProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cg8QN,
                       label: Data.Functor.Product.$fReadProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8QN: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cg8QR; else goto cg8QQ;
       cg8QR: // global
           HpAlloc = 200;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8QQ: // global
           I64[Hp - 192] = sat_sg5u7_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           I64[Hp - 152] = sat_sg5u6_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_sg5u5_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sg5u4_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.224412188 UTC

[section ""data" . Data.Functor.Product.$w$cshowsPrec_closure" {
     Data.Functor.Product.$w$cshowsPrec_closure:
         const Data.Functor.Product.$w$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Ri: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cshowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 16, res: 0, upd: 8;
     }
 },
 sp_sg5ue_entry() //  [R1]
         { info_tbl: [(cg8Rq,
                       label: sp_sg5ue_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Rq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Rr; else goto cg8Rs;
       cg8Rr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Rs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sl_sg5uf_entry() //  [R1]
         { info_tbl: [(cg8Rx,
                       label: sl_sg5uf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Rx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Ry; else goto cg8Rz;
       cg8Ry: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Rz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5uh_entry() //  [R1]
         { info_tbl: [(cg8RE,
                       label: sat_sg5uh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8RE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg8RF; else goto cg8RG;
       cg8RF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8RG: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5ug_entry() //  [R1]
         { info_tbl: [(cg8RL,
                       label: sat_sg5ug_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8RL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg8RM; else goto cg8RN;
       cg8RM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8RN: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cshowsPrec_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8RO,
                       label: Data.Functor.Product.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8RO: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg8RS; else goto cg8RR;
       cg8RS: // global
           HpAlloc = 128;
           R1 = Data.Functor.Product.$w$cshowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cg8RR: // global
           I64[Hp - 120] = sp_sg5ue_info;
           P64[Hp - 104] = R4;
           I64[Hp - 96] = sl_sg5uf_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sg5uh_info;
           P64[Hp - 56] = R3;
           _cg8Rm::P64 = Hp - 120;
           P64[Hp - 48] = _cg8Rm::P64;
           _cg8Rt::P64 = Hp - 96;
           P64[Hp - 40] = _cg8Rt::P64;
           I64[Hp - 32] = sat_sg5ug_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cg8Rm::P64;
           P64[Hp] = _cg8Rt::P64;
           R6 = R6;
           R5 = R5;
           R4 = Data.Functor.Product.$fRead1Product2_closure;
           R3 = Hp - 72;
           R2 = Hp - 32;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.247436537 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_$cshowsPrec_closure" {
     Data.Functor.Product.$fShowProduct_$cshowsPrec_closure:
         const Data.Functor.Product.$fShowProduct_$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$fShowProduct_$cshowsPrec_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cg8Sq,
                       label: Data.Functor.Product.$fShowProduct_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Sq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8Su; else goto cg8Sv;
       cg8Su: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_$cshowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8Sv: // global
           I64[Sp - 40] = block_cg8Sn_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8SD; else goto cg8So;
       ug8SD: // global
           call _cg8Sn(R1) args: 0, res: 0, upd: 0;
       cg8So: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8Sn() //  [R1]
         { info_tbl: [(cg8Sn,
                       label: block_cg8Sn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Sn: // global
           I64[Sp] = block_cg8St_info;
           _sg5uo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sg5uo::I64;
           if (R1 & 7 != 0) goto ug8SC; else goto cg8Sx;
       ug8SC: // global
           call _cg8St(R1) args: 0, res: 0, upd: 0;
       cg8Sx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8St() //  [R1]
         { info_tbl: [(cg8St,
                       label: block_cg8St_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8St: // global
           R6 = P64[R1 + 7];
           R5 = I64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cshowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.26113155 UTC

[section ""data" . Data.Functor.Product.$w$cshow_closure" {
     Data.Functor.Product.$w$cshow_closure:
         const Data.Functor.Product.$w$cshow_info;
         const 0;
 },
 sp_sg5ux_entry() //  [R1]
         { info_tbl: [(cg8T0,
                       label: sp_sg5ux_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8T0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8T1; else goto cg8T2;
       cg8T1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8T2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sl_sg5uy_entry() //  [R1]
         { info_tbl: [(cg8T7,
                       label: sl_sg5uy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8T7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8T8; else goto cg8T9;
       cg8T8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8T9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5uz_entry() //  [R1]
         { info_tbl: [(cg8Ti,
                       label: sat_sg5uz_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Ti: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cg8Tj; else goto cg8Tk;
       cg8Tj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Tk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = P64[R1 + 32];
           P64[Sp - 48] = P64[R1 + 40];
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 sat_sg5uB_entry() //  [R1]
         { info_tbl: [(cg8Tm,
                       label: sat_sg5uB_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Tm: // global
           _sg5uB::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cg8Tn; else goto cg8To;
       cg8To: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg8Tq; else goto cg8Tp;
       cg8Tq: // global
           HpAlloc = 72;
           goto cg8Tn;
       cg8Tn: // global
           R1 = _sg5uB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Tp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5uB::P64;
           _sg5us::P64 = P64[_sg5uB::P64 + 16];
           _sg5ut::P64 = P64[_sg5uB::P64 + 24];
           _sg5uv::P64 = P64[_sg5uB::P64 + 32];
           _sg5uw::P64 = P64[_sg5uB::P64 + 40];
           _sg5ux::P64 = P64[_sg5uB::P64 + 48];
           _sg5uy::P64 = P64[_sg5uB::P64 + 56];
           I64[Hp - 64] = sat_sg5uz_info;
           P64[Hp - 48] = _sg5ut::P64;
           P64[Hp - 40] = _sg5uw::P64;
           P64[Hp - 32] = _sg5ux::P64;
           P64[Hp - 24] = _sg5uy::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 64;
           R2 = _sg5us::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = _sg5ux::P64;
           P64[Sp - 48] = _sg5uy::P64;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sg5uv::P64;
           P64[Sp - 24] = Hp - 14;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cshow_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8Ts,
                       label: Data.Functor.Product.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Ts: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cg8Tw; else goto cg8Tv;
       cg8Tw: // global
           HpAlloc = 136;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$cshow_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8Tv: // global
           I64[Hp - 128] = sp_sg5ux_info;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sl_sg5uy_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_sg5uB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = R6;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 80;
           R3 = Hp - 14;
           R2 = Data.Functor.Product.$fRead1Product2_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.277221462 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_$cshow_closure" {
     Data.Functor.Product.$fShowProduct_$cshow_closure:
         const Data.Functor.Product.$fShowProduct_$cshow_info;
         const 0;
 },
 Data.Functor.Product.$fShowProduct_$cshow_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cg8U6,
                       label: Data.Functor.Product.$fShowProduct_$cshow_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8U6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg8U7; else goto cg8U8;
       cg8U7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_$cshow_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8U8: // global
           I64[Sp - 32] = block_cg8U3_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug8Uc; else goto cg8U4;
       ug8Uc: // global
           call _cg8U3(R1) args: 0, res: 0, upd: 0;
       cg8U4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8U3() //  [R1]
         { info_tbl: [(cg8U3,
                       label: block_cg8U3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8U3: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cshow_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.284002538 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_$cshowList_closure" {
     Data.Functor.Product.$fShowProduct_$cshowList_closure:
         const Data.Functor.Product.$fShowProduct_$cshowList_info;
         const 0;
 },
 lvl9_sg5uP_entry() //  [R1]
         { info_tbl: [(cg8Uu,
                       label: lvl9_sg5uP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Uu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Uv; else goto cg8Uw;
       cg8Uv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Uw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl10_sg5uQ_entry() //  [R1]
         { info_tbl: [(cg8UB,
                       label: lvl10_sg5uQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8UB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg8UC; else goto cg8UD;
       cg8UC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8UD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5uV_entry() //  [R1, R2]
         { info_tbl: [(cg8UM,
                       label: sat_sg5uV_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8UM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8UN; else goto cg8UO;
       cg8UN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg8UO: // global
           I64[Sp - 40] = block_cg8UJ_info;
           _sg5uK::P64 = P64[R1 + 7];
           _sg5uL::P64 = P64[R1 + 15];
           _sg5uP::P64 = P64[R1 + 23];
           _sg5uQ::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5uK::P64;
           P64[Sp - 24] = _sg5uL::P64;
           P64[Sp - 16] = _sg5uP::P64;
           P64[Sp - 8] = _sg5uQ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8US; else goto cg8UK;
       ug8US: // global
           call _cg8UJ(R1) args: 0, res: 0, upd: 0;
       cg8UK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8UJ() //  [R1]
         { info_tbl: [(cg8UJ,
                       label: block_cg8UJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8UJ: // global
           R6 = 0;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShowProduct_$cshowList_entry() //  [R2, R3,
                                                            R4, R5, R6]
         { info_tbl: [(cg8UT,
                       label: Data.Functor.Product.$fShowProduct_$cshowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8UT: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg8UX; else goto cg8UW;
       cg8UX: // global
           HpAlloc = 88;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_$cshowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8UW: // global
           I64[Hp - 80] = lvl9_sg5uP_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl10_sg5uQ_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5uV_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 31;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.297154822 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_closure" {
     Data.Functor.Product.$fShowProduct_closure:
         const Data.Functor.Product.$fShowProduct_info;
         const 0;
 },
 sat_sg5v1_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8Vv,
                       label: sat_sg5v1_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Vv: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fShowProduct_$cshowList_entry(R6,
                                                                    R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5v0_entry() //  [R1, R2]
         { info_tbl: [(cg8VD,
                       label: sat_sg5v0_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8VD: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fShowProduct_$cshow_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5uZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8VL,
                       label: sat_sg5uZ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8VL: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fShowProduct_$cshowsPrec_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShowProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cg8VP,
                       label: Data.Functor.Product.$fShowProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8VP: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg8VT; else goto cg8VS;
       cg8VT: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8VS: // global
           I64[Hp - 120] = sat_sg5v1_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sg5v0_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sg5uZ_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 118;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.308220818 UTC

[section ""data" . Data.Functor.Product.$fFunctorProduct_$cfmap_closure" {
     Data.Functor.Product.$fFunctorProduct_$cfmap_closure:
         const Data.Functor.Product.$fFunctorProduct_$cfmap_info;
 },
 sat_sg5va_entry() //  [R1]
         { info_tbl: [(cg8Wo,
                       label: sat_sg5va_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Wo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8Wp; else goto cg8Wq;
       cg8Wp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Wq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5v9_entry() //  [R1]
         { info_tbl: [(cg8Wv,
                       label: sat_sg5v9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Wv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8Ww; else goto cg8Wx;
       cg8Ww: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Wx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFunctorProduct_$cfmap_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cg8Wy,
                       label: Data.Functor.Product.$fFunctorProduct_$cfmap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Wy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg8WA; else goto cg8WB;
       cg8WA: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFunctorProduct_$cfmap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8WB: // global
           I64[Sp - 32] = block_cg8Wf_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug8WF; else goto cg8Wg;
       ug8WF: // global
           call _cg8Wf(R1) args: 0, res: 0, upd: 0;
       cg8Wg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8Wf() //  [R1]
         { info_tbl: [(cg8Wf,
                       label: block_cg8Wf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Wf: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg8WE; else goto cg8WD;
       cg8WE: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8WD: // global
           _sg5v7::P64 = P64[R1 + 7];
           _sg5v8::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5va_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sg5v4::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sg5v4::P64;
           P64[Hp - 64] = _sg5v8::P64;
           I64[Hp - 56] = sat_sg5v9_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg5v4::P64;
           P64[Hp - 24] = _sg5v7::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.319634806 UTC

[section ""data" . Data.Functor.Product.$fFunctorProduct_$c<$_closure" {
     Data.Functor.Product.$fFunctorProduct_$c<$_closure:
         const Data.Functor.Product.$fFunctorProduct_$c<$_info;
 },
 f1_sg5vi_entry() //  [R1]
         { info_tbl: [(cg8Xk,
                       label: f1_sg5vi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Xk: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5vl_entry() //  [R1]
         { info_tbl: [(cg8Xr,
                       label: sat_sg5vl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Xr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8Xs; else goto cg8Xt;
       cg8Xs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Xt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5vk_entry() //  [R1]
         { info_tbl: [(cg8Xy,
                       label: sat_sg5vk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Xy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8Xz; else goto cg8XA;
       cg8Xz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8XA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFunctorProduct_$c<$_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cg8XB,
                       label: Data.Functor.Product.$fFunctorProduct_$c<$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8XB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg8XD; else goto cg8XE;
       cg8XD: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFunctorProduct_$c<$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8XE: // global
           I64[Sp - 32] = block_cg8Xa_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug8XI; else goto cg8Xb;
       ug8XI: // global
           call _cg8Xa(R1) args: 0, res: 0, upd: 0;
       cg8Xb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8Xa() //  [R1]
         { info_tbl: [(cg8Xa,
                       label: block_cg8Xa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Xa: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cg8XH; else goto cg8XG;
       cg8XH: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg8XG: // global
           _sg5vg::P64 = P64[R1 + 7];
           _sg5vh::P64 = P64[R1 + 15];
           I64[Hp - 112] = f1_sg5vi_info;
           P64[Hp - 104] = P64[Sp + 24];
           I64[Hp - 96] = sat_sg5vl_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sg5vh::P64;
           _cg8Xf::P64 = Hp - 111;
           P64[Hp - 64] = _cg8Xf::P64;
           I64[Hp - 56] = sat_sg5vk_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg5vg::P64;
           P64[Hp - 24] = _cg8Xf::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.332982389 UTC

[section ""data" . Data.Functor.Product.$fFunctorProduct_closure" {
     Data.Functor.Product.$fFunctorProduct_closure:
         const Data.Functor.Product.$fFunctorProduct_info;
 },
 sat_sg5vp_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8Ym,
                       label: sat_sg5vp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Ym: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFunctorProduct_$c<$_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5vo_entry() //  [R1, R2, R3]
         { info_tbl: [(cg8Yu,
                       label: sat_sg5vo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Yu: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFunctorProduct_$cfmap_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFunctorProduct_entry() //  [R2, R3]
         { info_tbl: [(cg8Yy,
                       label: Data.Functor.Product.$fFunctorProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Yy: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg8YC; else goto cg8YB;
       cg8YC: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFunctorProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8YB: // global
           I64[Hp - 64] = sat_sg5vp_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5vo_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.340961904 UTC

[section ""data" . Data.Functor.Product.$w$cfoldMap_closure" {
     Data.Functor.Product.$w$cfoldMap_closure:
         const Data.Functor.Product.$w$cfoldMap_info;
 },
 sat_sg5vx_entry() //  [R1]
         { info_tbl: [(cg8YY,
                       label: sat_sg5vx_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8YY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg8YZ; else goto cg8Z0;
       cg8YZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Z0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5vw_entry() //  [R1]
         { info_tbl: [(cg8Z5,
                       label: sat_sg5vw_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Z5: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg8Z6; else goto cg8Z7;
       cg8Z6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg8Z7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldMap_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg8Z8,
                       label: Data.Functor.Product.$w$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Z8: // global
           _sg5vu::P64 = R6;
           _sg5vt::P64 = R5;
           _sg5vs::P64 = R4;
           _sg5vr::P64 = R3;
           _sg5vq::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cg8Z9; else goto cg8Za;
       cg8Za: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cg8Zc; else goto cg8Zb;
       cg8Zc: // global
           HpAlloc = 96;
           goto cg8Z9;
       cg8Z9: // global
           R6 = _sg5vu::P64;
           R5 = _sg5vt::P64;
           R4 = _sg5vs::P64;
           R3 = _sg5vr::P64;
           R2 = _sg5vq::P64;
           R1 = Data.Functor.Product.$w$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg8Zb: // global
           I64[Hp - 88] = sat_sg5vx_info;
           P64[Hp - 72] = _sg5vr::P64;
           P64[Hp - 64] = _sg5vs::P64;
           P64[Hp - 56] = _sg5vt::P64;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = sat_sg5vw_info;
           P64[Hp - 24] = _sg5vq::P64;
           P64[Hp - 16] = _sg5vs::P64;
           P64[Hp - 8] = _sg5vt::P64;
           P64[Hp] = _sg5vu::P64;
           R2 = _sg5vs::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = Hp - 40;
           P64[Sp] = Hp - 88;
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.350111536 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldMap_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldMap_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldMap_info;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldMap_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cg8ZG,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8ZG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8ZH; else goto cg8ZI;
       cg8ZH: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8ZI: // global
           I64[Sp - 40] = block_cg8ZD_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug8ZM; else goto cg8ZE;
       ug8ZM: // global
           call _cg8ZD(R1) args: 0, res: 0, upd: 0;
       cg8ZE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8ZD() //  [R1]
         { info_tbl: [(cg8ZD,
                       label: block_cg8ZD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8ZD: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldMap_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.357453328 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfold_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfold_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfold_info;
 },
 Data.Functor.Product.$fFoldableProduct_$cfold_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cg904,
                       label: Data.Functor.Product.$fFoldableProduct_$cfold_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg904: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg905; else goto cg906;
       cg905: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfold_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg906: // global
           I64[Sp - 32] = block_cg901_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug90a; else goto cg902;
       ug90a: // global
           call _cg901(R1) args: 0, res: 0, upd: 0;
       cg902: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg901() //  [R1]
         { info_tbl: [(cg901,
                       label: block_cg901_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg901: // global
           R6 = P64[R1 + 7];
           R5 = GHC.Base.id_closure+1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$cfoldMap_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.363276818 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct1_closure" {
     Data.Functor.Product.$fFoldableProduct1_closure:
         const Data.Functor.Product.$fFoldableProduct1_info;
 },
 Data.Functor.Product.$fFoldableProduct1_entry() //  [R2]
         { info_tbl: [(cg90p,
                       label: Data.Functor.Product.$fFoldableProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg90p: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.368022424 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$csum_closure" {
     Data.Functor.Product.$fFoldableProduct_$csum_closure:
         const Data.Functor.Product.$fFoldableProduct_$csum_info;
         const 0;
 },
 $dMonoid_sg5vR_entry() //  [R1]
         { info_tbl: [(cg90E,
                       label: $dMonoid_sg5vR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg90E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg90F; else goto cg90G;
       cg90F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg90G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5vX_entry() //  [R1]
         { info_tbl: [(cg90V,
                       label: sat_sg5vX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg90V: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg90W; else goto cg90X;
       cg90W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg90X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5vW_entry() //  [R1]
         { info_tbl: [(cg912,
                       label: sat_sg5vW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg912: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg913; else goto cg914;
       cg913: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg914: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5vY_entry() //  [R1, R2]
         { info_tbl: [(cg915,
                       label: sat_sg5vY_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg915: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg916; else goto cg917;
       cg916: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg917: // global
           I64[Sp - 40] = block_cg90M_info;
           _sg5vO::P64 = P64[R1 + 7];
           _sg5vP::P64 = P64[R1 + 15];
           _sg5vQ::P64 = P64[R1 + 23];
           _sg5vR::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5vO::P64;
           P64[Sp - 24] = _sg5vP::P64;
           P64[Sp - 16] = _sg5vQ::P64;
           P64[Sp - 8] = _sg5vR::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug91b; else goto cg90N;
       ug91b: // global
           call _cg90M(R1) args: 0, res: 0, upd: 0;
       cg90N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg90M() //  [R1]
         { info_tbl: [(cg90M,
                       label: block_cg90M_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg90M: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg91a; else goto cg919;
       cg91a: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg919: // global
           _sg5vU::P64 = P64[R1 + 7];
           _sg5vV::P64 = P64[R1 + 15];
           I64[Hp - 72] = sat_sg5vX_info;
           P64[Hp - 56] = P64[Sp + 16];
           _sg5vR::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sg5vR::P64;
           P64[Hp - 40] = _sg5vV::P64;
           I64[Hp - 32] = sat_sg5vW_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sg5vR::P64;
           P64[Hp] = _sg5vU::P64;
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$csum_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cg91c,
                       label: Data.Functor.Product.$fFoldableProduct_$csum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg91c: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg91g; else goto cg91f;
       cg91g: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$csum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg91f: // global
           I64[Hp - 56] = $dMonoid_sg5vR_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5vY_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.383570353 UTC

[section ""cstring" . lvl_rg5nW_bytes" {
     lvl_rg5nW_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.385732025 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct2_closure" {
     Data.Functor.Product.$fFoldableProduct2_closure:
         const Data.Functor.Product.$fFoldableProduct2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct2_entry() //  [R1]
         { info_tbl: [(cg91Y,
                       label: Data.Functor.Product.$fFoldableProduct2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg91Y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg91Z; else goto cg920;
       cg91Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg920: // global
           (_cg91T::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg91T::I64 == 0) goto cg91V; else goto cg91U;
       cg91V: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg91U: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg91T::I64;
           I64[Sp - 24] = block_cg91W_info;
           R2 = lvl_rg5nW_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg91W() //  [R1]
         { info_tbl: [(cg91W,
                       label: block_cg91W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg91W: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.393091533 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cminimum_closure" {
     Data.Functor.Product.$fFoldableProduct_$cminimum_closure:
         const Data.Functor.Product.$fFoldableProduct_$cminimum_info;
         const 0;
 },
 $dMonoid_sg5w3_entry() //  [R1]
         { info_tbl: [(cg92m,
                       label: $dMonoid_sg5w3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg92m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg92n; else goto cg92o;
       cg92n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg92o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5wf_entry() //  [R1, R2]
         { info_tbl: [(cg92x,
                       label: sat_sg5wf_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg92x: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cg92y; else goto cg92z;
       cg92y: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg92z: // global
           I64[Sp - 40] = block_cg92u_info;
           _sg5w0::P64 = P64[R1 + 7];
           _sg5w1::P64 = P64[R1 + 15];
           _sg5w2::P64 = P64[R1 + 23];
           _sg5w3::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5w0::P64;
           P64[Sp - 24] = _sg5w1::P64;
           P64[Sp - 16] = _sg5w2::P64;
           P64[Sp - 8] = _sg5w3::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug93r; else goto cg92v;
       ug93r: // global
           call _cg92u(R1) args: 0, res: 0, upd: 0;
       cg92v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg92u() //  [R1]
         { info_tbl: [(cg92u,
                       label: block_cg92u_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg92u: // global
           I64[Sp] = block_cg92C_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = GHC.Base.Just_closure+1;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg92C() //  [R1]
         { info_tbl: [(cg92C,
                       label: block_cg92C_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg92C: // global
           _sg5w0::P64 = P64[Sp + 8];
           _sg5w3::P64 = P64[Sp + 32];
           _sg5w6::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg92K; else goto cg92Z;
       cg92K: // global
           I64[Sp + 32] = block_cg92H_info;
           R2 = _sg5w0::P64;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sg5w3::P64;
           P64[Sp + 16] = GHC.Base.Just_closure+1;
           P64[Sp + 24] = _sg5w6::P64;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cg92Z: // global
           I64[Sp + 16] = block_cg92X_info;
           R2 = _sg5w0::P64;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = _sg5w3::P64;
           P64[Sp] = GHC.Base.Just_closure+1;
           P64[Sp + 8] = _sg5w6::P64;
           P64[Sp + 32] = P64[R1 + 6];
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg92H() //  [R1]
         { info_tbl: [(cg92H,
                       label: block_cg92H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg92H: // global
           if (R1 & 7 == 1) goto cg92Q; else goto cg92U;
       cg92Q: // global
           R1 = Data.Functor.Product.$fFoldableProduct2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg92U: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg92X() //  [R1]
         { info_tbl: [(cg92X,
                       label: block_cg92X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg92X: // global
           if (R1 & 7 == 1) goto ug93p; else goto cg93a;
       ug93p: // global
           Sp = Sp + 16;
           call _cg93g() args: 0, res: 0, upd: 0;
       cg93a: // global
           I64[Sp] = block_cg938_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           _sg5wd::P64 = P64[R1 + 6];
           P64[Sp - 16] = _sg5wd::P64;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = _sg5wd::P64;
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cg938() //  [R1]
         { info_tbl: [(cg938,
                       label: block_cg938_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg938: // global
           if (R1 & 7 == 1) goto ug93q; else goto cg93k;
       ug93q: // global
           Sp = Sp + 16;
           call _cg93g() args: 0, res: 0, upd: 0;
       cg93k: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg93g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg93g: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cminimum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg93u,
                       label: Data.Functor.Product.$fFoldableProduct_$cminimum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg93u: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg93y; else goto cg93x;
       cg93y: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cminimum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg93x: // global
           I64[Hp - 56] = $dMonoid_sg5w3_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5wf_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.414103027 UTC

[section ""cstring" . lvl1_rg5nX_bytes" {
     lvl1_rg5nX_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.416257985 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct3_closure" {
     Data.Functor.Product.$fFoldableProduct3_closure:
         const Data.Functor.Product.$fFoldableProduct3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct3_entry() //  [R1]
         { info_tbl: [(cg94r,
                       label: Data.Functor.Product.$fFoldableProduct3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg94r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg94s; else goto cg94t;
       cg94s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg94t: // global
           (_cg94m::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg94m::I64 == 0) goto cg94o; else goto cg94n;
       cg94o: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg94n: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg94m::I64;
           I64[Sp - 24] = block_cg94p_info;
           R2 = lvl1_rg5nX_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg94p() //  [R1]
         { info_tbl: [(cg94p,
                       label: block_cg94p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg94p: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.423496031 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cmaximum_closure" {
     Data.Functor.Product.$fFoldableProduct_$cmaximum_closure:
         const Data.Functor.Product.$fFoldableProduct_$cmaximum_info;
         const 0;
 },
 $dMonoid_sg5wk_entry() //  [R1]
         { info_tbl: [(cg94P,
                       label: $dMonoid_sg5wk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg94P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg94Q; else goto cg94R;
       cg94Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg94R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5ww_entry() //  [R1, R2]
         { info_tbl: [(cg950,
                       label: sat_sg5ww_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg950: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cg951; else goto cg952;
       cg951: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg952: // global
           I64[Sp - 40] = block_cg94X_info;
           _sg5wh::P64 = P64[R1 + 7];
           _sg5wi::P64 = P64[R1 + 15];
           _sg5wj::P64 = P64[R1 + 23];
           _sg5wk::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5wh::P64;
           P64[Sp - 24] = _sg5wi::P64;
           P64[Sp - 16] = _sg5wj::P64;
           P64[Sp - 8] = _sg5wk::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug95U; else goto cg94Y;
       ug95U: // global
           call _cg94X(R1) args: 0, res: 0, upd: 0;
       cg94Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg94X() //  [R1]
         { info_tbl: [(cg94X,
                       label: block_cg94X_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg94X: // global
           I64[Sp] = block_cg955_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = GHC.Base.Just_closure+1;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg955() //  [R1]
         { info_tbl: [(cg955,
                       label: block_cg955_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg955: // global
           _sg5wh::P64 = P64[Sp + 8];
           _sg5wk::P64 = P64[Sp + 32];
           _sg5wn::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg95d; else goto cg95s;
       cg95d: // global
           I64[Sp + 32] = block_cg95a_info;
           R2 = _sg5wh::P64;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sg5wk::P64;
           P64[Sp + 16] = GHC.Base.Just_closure+1;
           P64[Sp + 24] = _sg5wn::P64;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cg95s: // global
           I64[Sp + 16] = block_cg95q_info;
           R2 = _sg5wh::P64;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = _sg5wk::P64;
           P64[Sp] = GHC.Base.Just_closure+1;
           P64[Sp + 8] = _sg5wn::P64;
           P64[Sp + 32] = P64[R1 + 6];
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg95a() //  [R1]
         { info_tbl: [(cg95a,
                       label: block_cg95a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg95a: // global
           if (R1 & 7 == 1) goto cg95j; else goto cg95n;
       cg95j: // global
           R1 = Data.Functor.Product.$fFoldableProduct3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg95n: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg95q() //  [R1]
         { info_tbl: [(cg95q,
                       label: block_cg95q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg95q: // global
           if (R1 & 7 == 1) goto ug95S; else goto cg95D;
       ug95S: // global
           Sp = Sp + 16;
           call _cg95J() args: 0, res: 0, upd: 0;
       cg95D: // global
           I64[Sp] = block_cg95B_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           _sg5wu::P64 = P64[R1 + 6];
           P64[Sp - 16] = _sg5wu::P64;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = _sg5wu::P64;
           Sp = Sp - 24;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cg95B() //  [R1]
         { info_tbl: [(cg95B,
                       label: block_cg95B_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg95B: // global
           if (R1 & 7 == 1) goto ug95T; else goto cg95N;
       ug95T: // global
           Sp = Sp + 16;
           call _cg95J() args: 0, res: 0, upd: 0;
       cg95N: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cg95J() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg95J: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cmaximum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg95X,
                       label: Data.Functor.Product.$fFoldableProduct_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg95X: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg961; else goto cg960;
       cg961: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cmaximum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg960: // global
           I64[Hp - 56] = $dMonoid_sg5wk_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5ww_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.444836158 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$celem_closure" {
     Data.Functor.Product.$fFoldableProduct_$celem_closure:
         const Data.Functor.Product.$fFoldableProduct_$celem_info;
         const 0;
 },
 f1_sg5wB_entry() //  [R1]
         { info_tbl: [(cg96T,
                       label: f1_sg5wB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg96T: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg96U; else goto cg96V;
       cg96U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg96V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5wH_entry() //  [R1, R2]
         { info_tbl: [(cg974,
                       label: sat_sg5wH_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg974: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cg975; else goto cg976;
       cg975: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg976: // global
           I64[Sp - 32] = block_cg971_info;
           _sg5wx::P64 = P64[R1 + 7];
           _sg5wy::P64 = P64[R1 + 15];
           _sg5wB::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sg5wx::P64;
           P64[Sp - 16] = _sg5wy::P64;
           P64[Sp - 8] = _sg5wB::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug97m; else goto cg972;
       ug97m: // global
           call _cg971(R1) args: 0, res: 0, upd: 0;
       cg972: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg971() //  [R1]
         { info_tbl: [(cg971,
                       label: block_cg971_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg971: // global
           I64[Sp] = block_cg979_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 8] = P64[R1 + 15];
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cg979() //  [R1]
         { info_tbl: [(cg979,
                       label: block_cg979_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg979: // global
           if (R1 & 7 == 1) goto cg97g; else goto cg97k;
       cg97g: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           _sg5wF::P64 = P64[Sp + 8];
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = _sg5wF::P64;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cg97k: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$celem_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cg97n,
                       label: Data.Functor.Product.$fFoldableProduct_$celem_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg97n: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg97r; else goto cg97q;
       cg97r: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$celem_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg97q: // global
           I64[Hp - 56] = f1_sg5wB_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = sat_sg5wH_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.458727044 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct8_closure" {
     Data.Functor.Product.$fFoldableProduct8_closure:
         const Data.Functor.Product.$fFoldableProduct8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct8_entry() //  [R1]
         { info_tbl: [(cg981,
                       label: Data.Functor.Product.$fFoldableProduct8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg981: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg982; else goto cg983;
       cg982: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg983: // global
           (_cg97Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg97Y::I64 == 0) goto cg980; else goto cg97Z;
       cg980: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg97Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg97Y::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.463731444 UTC

[section ""data" . Data.Functor.Product.$w$cfoldl_closure" {
     Data.Functor.Product.$w$cfoldl_closure:
         const Data.Functor.Product.$w$cfoldl_info;
         const 0;
 },
 f1_sg5wO_entry() //  [R1, R2, R3]
         { info_tbl: [(cg98k,
                       label: f1_sg5wO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg98k: // global
           _sg5wQ::P64 = R3;
           R3 = R2;
           R2 = _sg5wQ::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5wR_entry() //  [R1]
         { info_tbl: [(cg98r,
                       label: sat_sg5wR_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg98r: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg98s; else goto cg98t;
       cg98s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg98t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg98u,
                       label: Data.Functor.Product.$w$cfoldl_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg98u: // global
           _sg5wM::P64 = R6;
           _sg5wL::P64 = R5;
           _sg5wK::P64 = R4;
           _sg5wJ::P64 = R3;
           _sg5wI::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cg98v; else goto cg98w;
       cg98w: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg98y; else goto cg98x;
       cg98y: // global
           HpAlloc = 64;
           goto cg98v;
       cg98v: // global
           R6 = _sg5wM::P64;
           R5 = _sg5wL::P64;
           R4 = _sg5wK::P64;
           R3 = _sg5wJ::P64;
           R2 = _sg5wI::P64;
           R1 = Data.Functor.Product.$w$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg98x: // global
           I64[Hp - 56] = f1_sg5wO_info;
           P64[Hp - 48] = _sg5wK::P64;
           I64[Hp - 40] = sat_sg5wR_info;
           P64[Hp - 24] = _sg5wI::P64;
           P64[Hp - 16] = _sg5wL::P64;
           P64[Hp - 8] = _sg5wM::P64;
           _cg98f::P64 = Hp - 54;
           P64[Hp] = _cg98f::P64;
           R2 = _sg5wJ::P64;
           I64[Sp - 32] = stg_ap_pppp_info;
           P64[Sp - 24] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 16] = _cg98f::P64;
           P64[Sp - 8] = P64[Sp];
           P64[Sp] = Hp - 40;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.4741632 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldl_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldl_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldl_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldl_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cg98X,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg98X: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg98Y; else goto cg98Z;
       cg98Y: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg98Z: // global
           I64[Sp - 40] = block_cg98U_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug993; else goto cg98V;
       ug993: // global
           call _cg98U(R1) args: 0, res: 0, upd: 0;
       cg98V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg98U() //  [R1]
         { info_tbl: [(cg98U,
                       label: block_cg98U_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg98U: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldl_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.480262981 UTC

[section ""cstring" . lvl2_rg5nY_bytes" {
     lvl2_rg5nY_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.482407637 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct7_closure" {
     Data.Functor.Product.$fFoldableProduct7_closure:
         const Data.Functor.Product.$fFoldableProduct7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct7_entry() //  [R1]
         { info_tbl: [(cg99n,
                       label: Data.Functor.Product.$fFoldableProduct7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg99n: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg99o; else goto cg99p;
       cg99o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg99p: // global
           (_cg99i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg99i::I64 == 0) goto cg99k; else goto cg99j;
       cg99k: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg99j: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg99i::I64;
           I64[Sp - 24] = block_cg99l_info;
           R2 = lvl2_rg5nY_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg99l() //  [R1]
         { info_tbl: [(cg99l,
                       label: block_cg99l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg99l: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.489420546 UTC

[section ""data" . Data.Functor.Product.$w$cfoldl1_closure" {
     Data.Functor.Product.$w$cfoldl1_closure:
         const Data.Functor.Product.$w$cfoldl1_info;
         const 0;
 },
 sat_sg5xb_entry() //  [R1]
         { info_tbl: [(cg99X,
                       label: sat_sg5xb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg99X: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg99Y; else goto cg99Z;
       cg99Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg99Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg99Q_info;
           _sg5x3::P64 = P64[R1 + 16];
           _sg5x7::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sg5x3::P64;
           P64[Sp - 24] = _sg5x7::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9a6; else goto cg99R;
       ug9a6: // global
           call _cg99Q(R1) args: 0, res: 0, upd: 0;
       cg99R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg99Q() //  [R1]
         { info_tbl: [(cg99Q,
                       label: block_cg99Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg99Q: // global
           _sg5x7::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg99U; else goto cg99V;
       cg99U: // global
           R1 = _sg5x7::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cg99V: // global
           R3 = _sg5x7::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 f1_sg5x6_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9a8,
                       label: f1_sg5x6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9a8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg9ac; else goto cg9ab;
       cg9ac: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9ab: // global
           _sg5x3::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sg5xb_info;
           P64[Hp - 32] = _sg5x3::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5xc_entry() //  [R1]
         { info_tbl: [(cg9ah,
                       label: sat_sg5xc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ah: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg9ai; else goto cg9aj;
       cg9ai: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9aj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldl1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg9aq,
                       label: Data.Functor.Product.$w$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9aq: // global
           _sg5x5::P64 = R6;
           _sg5x4::P64 = R5;
           _sg5x3::P64 = R4;
           _sg5x2::P64 = R3;
           _sg5x1::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cg9ar; else goto cg9as;
       cg9as: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg9au; else goto cg9at;
       cg9au: // global
           HpAlloc = 56;
           goto cg9ar;
       cg9ar: // global
           R6 = _sg5x5::P64;
           R5 = _sg5x4::P64;
           R4 = _sg5x3::P64;
           R3 = _sg5x2::P64;
           R2 = _sg5x1::P64;
           R1 = Data.Functor.Product.$w$cfoldl1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9at: // global
           I64[Hp - 48] = f1_sg5x6_info;
           P64[Hp - 40] = _sg5x3::P64;
           I64[Hp - 32] = sat_sg5xc_info;
           P64[Hp - 16] = _sg5x1::P64;
           P64[Hp - 8] = _sg5x4::P64;
           _cg99H::P64 = Hp - 46;
           P64[Hp] = _cg99H::P64;
           I64[Sp - 8] = block_cg9ak_info;
           R2 = _sg5x2::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 32] = _cg99H::P64;
           P64[Sp - 24] = _sg5x5::P64;
           P64[Sp - 16] = Hp - 32;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cg9ak() //  [R1]
         { info_tbl: [(cg9ak,
                       label: block_cg9ak_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ak: // global
           if (R1 & 7 == 1) goto cg9an; else goto cg9ao;
       cg9an: // global
           R1 = Data.Functor.Product.$fFoldableProduct7_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg9ao: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.506235615 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldl1_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldl1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg9be,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9be: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg9bf; else goto cg9bg;
       cg9bf: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9bg: // global
           I64[Sp - 32] = block_cg9bb_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug9bk; else goto cg9bc;
       ug9bk: // global
           call _cg9bb(R1) args: 0, res: 0, upd: 0;
       cg9bc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9bb() //  [R1]
         { info_tbl: [(cg9bb,
                       label: block_cg9bb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9bb: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldl1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.513126824 UTC

[section ""data" . Data.Functor.Product.$w$cfoldr'_closure" {
     Data.Functor.Product.$w$cfoldr'_closure:
         const Data.Functor.Product.$w$cfoldr'_info;
         const 0;
 },
 f1_sg5xs_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg9bF,
                       label: f1_sg5xs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9bF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9bG; else goto cg9bH;
       cg9bG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9bH: // global
           I64[Sp - 16] = block_cg9bD_info;
           _sg5xu::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sg5xu::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9bD() //  [R1]
         { info_tbl: [(cg9bD,
                       label: block_cg9bD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9bD: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5xx_entry() //  [R1]
         { info_tbl: [(cg9bN,
                       label: sat_sg5xx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9bN: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg9bO; else goto cg9bP;
       cg9bO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9bP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldr'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg9bQ,
                       label: Data.Functor.Product.$w$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9bQ: // global
           _sg5xq::P64 = R6;
           _sg5xp::P64 = R5;
           _sg5xo::P64 = R4;
           _sg5xn::P64 = R3;
           _sg5xm::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cg9bR; else goto cg9bS;
       cg9bS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg9bU; else goto cg9bT;
       cg9bU: // global
           HpAlloc = 56;
           goto cg9bR;
       cg9bR: // global
           R6 = _sg5xq::P64;
           R5 = _sg5xp::P64;
           R4 = _sg5xo::P64;
           R3 = _sg5xn::P64;
           R2 = _sg5xm::P64;
           R1 = Data.Functor.Product.$w$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg9bT: // global
           I64[Hp - 48] = f1_sg5xs_info;
           P64[Hp - 40] = _sg5xo::P64;
           I64[Hp - 32] = sat_sg5xx_info;
           P64[Hp - 16] = _sg5xm::P64;
           P64[Hp - 8] = _sg5xq::P64;
           _cg9by::P64 = Hp - 45;
           P64[Hp] = _cg9by::P64;
           R2 = _sg5xn::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 24] = _cg9by::P64;
           P64[Sp - 16] = P64[Sp];
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = _sg5xp::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.52454792 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldr'_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldr'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cg9cm,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9cm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9cn; else goto cg9co;
       cg9cn: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9co: // global
           I64[Sp - 40] = block_cg9cj_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9cs; else goto cg9ck;
       ug9cs: // global
           call _cg9cj(R1) args: 0, res: 0, upd: 0;
       cg9ck: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9cj() //  [R1]
         { info_tbl: [(cg9cj,
                       label: block_cg9cj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9cj: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldr'_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.531629244 UTC

[section ""data" . Data.Functor.Product.$w$cfoldr_closure" {
     Data.Functor.Product.$w$cfoldr_closure:
         const Data.Functor.Product.$w$cfoldr_info;
         const 0;
 },
 sat_sg5xM_entry() //  [R1]
         { info_tbl: [(cg9cL,
                       label: sat_sg5xM_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9cL: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg9cM; else goto cg9cN;
       cg9cM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9cN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg9cO,
                       label: Data.Functor.Product.$w$cfoldr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9cO: // global
           _sg5xK::P64 = R6;
           _sg5xJ::P64 = R5;
           _sg5xI::P64 = R4;
           _sg5xH::P64 = R3;
           _sg5xG::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cg9cP; else goto cg9cQ;
       cg9cQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg9cS; else goto cg9cR;
       cg9cS: // global
           HpAlloc = 48;
           goto cg9cP;
       cg9cP: // global
           R6 = _sg5xK::P64;
           R5 = _sg5xJ::P64;
           R4 = _sg5xI::P64;
           R3 = _sg5xH::P64;
           R2 = _sg5xG::P64;
           R1 = Data.Functor.Product.$w$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg9cR: // global
           I64[Hp - 40] = sat_sg5xM_info;
           P64[Hp - 24] = _sg5xH::P64;
           P64[Hp - 16] = _sg5xI::P64;
           P64[Hp - 8] = _sg5xJ::P64;
           P64[Hp] = P64[Sp];
           R2 = _sg5xG::P64;
           I64[Sp - 32] = stg_ap_pppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 16] = _sg5xI::P64;
           P64[Sp - 8] = _sg5xK::P64;
           P64[Sp] = Hp - 40;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.539522362 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldr_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldr_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldr_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldr_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cg9de,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9de: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9df; else goto cg9dg;
       cg9df: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9dg: // global
           I64[Sp - 40] = block_cg9db_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9dk; else goto cg9dc;
       ug9dk: // global
           call _cg9db(R1) args: 0, res: 0, upd: 0;
       cg9dc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9db() //  [R1]
         { info_tbl: [(cg9db,
                       label: block_cg9db_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9db: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldr_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.547259921 UTC

[section ""data" . Data.Functor.Product.$w$cfoldl'_closure" {
     Data.Functor.Product.$w$cfoldl'_closure:
         const Data.Functor.Product.$w$cfoldl'_info;
         const 0;
 },
 f1_sg5y1_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg9dG,
                       label: f1_sg5y1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9dG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9dH; else goto cg9dI;
       cg9dH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9dI: // global
           I64[Sp - 16] = block_cg9dE_info;
           _sg5y3::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sg5y3::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9dE() //  [R1]
         { info_tbl: [(cg9dE,
                       label: block_cg9dE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9dE: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5y6_entry() //  [R1]
         { info_tbl: [(cg9dO,
                       label: sat_sg5y6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9dO: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg9dP; else goto cg9dQ;
       cg9dP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9dQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldl'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg9dR,
                       label: Data.Functor.Product.$w$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9dR: // global
           _sg5xZ::P64 = R6;
           _sg5xY::P64 = R5;
           _sg5xX::P64 = R4;
           _sg5xW::P64 = R3;
           _sg5xV::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cg9dS; else goto cg9dT;
       cg9dT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg9dV; else goto cg9dU;
       cg9dV: // global
           HpAlloc = 56;
           goto cg9dS;
       cg9dS: // global
           R6 = _sg5xZ::P64;
           R5 = _sg5xY::P64;
           R4 = _sg5xX::P64;
           R3 = _sg5xW::P64;
           R2 = _sg5xV::P64;
           R1 = Data.Functor.Product.$w$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg9dU: // global
           I64[Hp - 48] = f1_sg5y1_info;
           P64[Hp - 40] = _sg5xX::P64;
           I64[Hp - 32] = sat_sg5y6_info;
           P64[Hp - 16] = _sg5xW::P64;
           P64[Hp - 8] = P64[Sp];
           _cg9dz::P64 = Hp - 45;
           P64[Hp] = _cg9dz::P64;
           R2 = _sg5xV::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = _cg9dz::P64;
           P64[Sp - 16] = _sg5xZ::P64;
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = _sg5xY::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.558514908 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldl'_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldl'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cg9en,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9en: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9eo; else goto cg9ep;
       cg9eo: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9ep: // global
           I64[Sp - 40] = block_cg9ek_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9et; else goto cg9el;
       ug9et: // global
           call _cg9ek(R1) args: 0, res: 0, upd: 0;
       cg9el: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9ek() //  [R1]
         { info_tbl: [(cg9ek,
                       label: block_cg9ek_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ek: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldl'_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.566451798 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct5_closure" {
     Data.Functor.Product.$fFoldableProduct5_closure:
         const Data.Functor.Product.$fFoldableProduct5_info;
 },
 Data.Functor.Product.$fFoldableProduct5_entry() //  [R2, R3]
         { info_tbl: [(cg9eL,
                       label: Data.Functor.Product.$fFoldableProduct5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9eL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg9eS; else goto cg9eT;
       cg9eS: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9eT: // global
           I64[Sp - 8] = block_cg9eI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug9eX; else goto cg9eJ;
       ug9eX: // global
           call _cg9eI(R1) args: 0, res: 0, upd: 0;
       cg9eJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9eI() //  [R1]
         { info_tbl: [(cg9eI,
                       label: block_cg9eI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9eI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg9eW; else goto cg9eV;
       cg9eW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9eV: // global
           _sg5yj::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sg5yj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.572770208 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$clength_closure" {
     Data.Functor.Product.$fFoldableProduct_$clength_closure:
         const Data.Functor.Product.$fFoldableProduct_$clength_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$clength_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cg9fg,
                       label: Data.Functor.Product.$fFoldableProduct_$clength_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9fg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg9fh; else goto cg9fi;
       cg9fh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$clength_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9fi: // global
           I64[Sp - 24] = block_cg9fd_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug9fm; else goto cg9fe;
       ug9fm: // global
           call _cg9fd(R1) args: 0, res: 0, upd: 0;
       cg9fe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9fd() //  [R1]
         { info_tbl: [(cg9fd,
                       label: block_cg9fd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9fd: // global
           R6 = P64[R1 + 7];
           R5 = Data.Functor.Product.$fFoldableProduct4_closure+1;
           R4 = Data.Functor.Product.$fFoldableProduct5_closure+2;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 16] = P64[R1 + 15];
           Sp = Sp + 16;
           call Data.Functor.Product.$w$cfoldl'_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.578971797 UTC

[section ""cstring" . lvl3_rg5nZ_bytes" {
     lvl3_rg5nZ_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.581190116 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct9_closure" {
     Data.Functor.Product.$fFoldableProduct9_closure:
         const Data.Functor.Product.$fFoldableProduct9_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct9_entry() //  [R1]
         { info_tbl: [(cg9fG,
                       label: Data.Functor.Product.$fFoldableProduct9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9fG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cg9fH; else goto cg9fI;
       cg9fH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9fI: // global
           (_cg9fB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg9fB::I64 == 0) goto cg9fD; else goto cg9fC;
       cg9fD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg9fC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg9fB::I64;
           I64[Sp - 24] = block_cg9fE_info;
           R2 = lvl3_rg5nZ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg9fE() //  [R1]
         { info_tbl: [(cg9fE,
                       label: block_cg9fE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9fE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.58838032 UTC

[section ""data" . Data.Functor.Product.$w$cfoldr1_closure" {
     Data.Functor.Product.$w$cfoldr1_closure:
         const Data.Functor.Product.$w$cfoldr1_info;
         const 0;
 },
 sat_sg5yB_entry() //  [R1]
         { info_tbl: [(cg9gg,
                       label: sat_sg5yB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9gg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9gh; else goto cg9gi;
       cg9gh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9gi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg9g9_info;
           _sg5yt::P64 = P64[R1 + 16];
           _sg5yx::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sg5yt::P64;
           P64[Sp - 24] = _sg5yx::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9gp; else goto cg9ga;
       ug9gp: // global
           call _cg9g9(R1) args: 0, res: 0, upd: 0;
       cg9ga: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg9g9() //  [R1]
         { info_tbl: [(cg9g9,
                       label: block_cg9g9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9g9: // global
           _sg5yx::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cg9gd; else goto cg9ge;
       cg9gd: // global
           R1 = _sg5yx::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cg9ge: // global
           R3 = P64[R1 + 6];
           R2 = _sg5yx::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 w3_sg5yw_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9gr,
                       label: w3_sg5yw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9gr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg9gv; else goto cg9gu;
       cg9gv: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9gu: // global
           _sg5yt::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sg5yB_info;
           P64[Hp - 32] = _sg5yt::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5yC_entry() //  [R1]
         { info_tbl: [(cg9gA,
                       label: sat_sg5yC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9gA: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg9gB; else goto cg9gC;
       cg9gB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9gC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldr1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg9gJ,
                       label: Data.Functor.Product.$w$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9gJ: // global
           _sg5yv::P64 = R6;
           _sg5yu::P64 = R5;
           _sg5yt::P64 = R4;
           _sg5ys::P64 = R3;
           _sg5yr::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cg9gK; else goto cg9gL;
       cg9gL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cg9gN; else goto cg9gM;
       cg9gN: // global
           HpAlloc = 56;
           goto cg9gK;
       cg9gK: // global
           R6 = _sg5yv::P64;
           R5 = _sg5yu::P64;
           R4 = _sg5yt::P64;
           R3 = _sg5ys::P64;
           R2 = _sg5yr::P64;
           R1 = Data.Functor.Product.$w$cfoldr1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9gM: // global
           I64[Hp - 48] = w3_sg5yw_info;
           P64[Hp - 40] = _sg5yt::P64;
           I64[Hp - 32] = sat_sg5yC_info;
           P64[Hp - 16] = _sg5ys::P64;
           P64[Hp - 8] = _sg5yv::P64;
           _cg9g0::P64 = Hp - 46;
           P64[Hp] = _cg9g0::P64;
           I64[Sp - 8] = block_cg9gD_info;
           R2 = _sg5yr::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = _cg9g0::P64;
           P64[Sp - 24] = _sg5yu::P64;
           P64[Sp - 16] = Hp - 32;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cg9gD() //  [R1]
         { info_tbl: [(cg9gD,
                       label: block_cg9gD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9gD: // global
           if (R1 & 7 == 1) goto cg9gG; else goto cg9gH;
       cg9gG: // global
           R1 = Data.Functor.Product.$fFoldableProduct9_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cg9gH: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.604941175 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldr1_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldr1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg9hx,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9hx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg9hy; else goto cg9hz;
       cg9hy: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9hz: // global
           I64[Sp - 32] = block_cg9hu_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug9hD; else goto cg9hv;
       ug9hD: // global
           call _cg9hu(R1) args: 0, res: 0, upd: 0;
       cg9hv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9hu() //  [R1]
         { info_tbl: [(cg9hu,
                       label: block_cg9hu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9hu: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldr1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.611633131 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct6_closure" {
     Data.Functor.Product.$fFoldableProduct6_closure:
         const Data.Functor.Product.$fFoldableProduct6_info;
 },
 Data.Functor.Product.$fFoldableProduct6_entry() //  []
         { info_tbl: [(cg9hR,
                       label: Data.Functor.Product.$fFoldableProduct6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9hR: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.617082052 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cnull_closure" {
     Data.Functor.Product.$fFoldableProduct_$cnull_closure:
         const Data.Functor.Product.$fFoldableProduct_$cnull_info;
         const 0;
 },
 sat_sg5yU_entry() //  [R1]
         { info_tbl: [(cg9ic,
                       label: sat_sg5yU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ic: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg9id; else goto cg9ie;
       cg9id: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9ie: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = Data.Functor.Product.$fFoldableProduct6_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.True_closure+2;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cnull_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cg9if,
                       label: Data.Functor.Product.$fFoldableProduct_$cnull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9if: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9ig; else goto cg9ih;
       cg9ig: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cnull_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9ih: // global
           I64[Sp - 24] = block_cg9i3_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug9il; else goto cg9i4;
       ug9il: // global
           call _cg9i3(R1) args: 0, res: 0, upd: 0;
       cg9i4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9i3() //  [R1]
         { info_tbl: [(cg9i3,
                       label: block_cg9i3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9i3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg9ik; else goto cg9ij;
       cg9ik: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9ij: // global
           _sg5yS::P64 = P64[R1 + 7];
           _sg5yT::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sg5yU_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sg5yT::P64;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp] = Data.Functor.Product.$fFoldableProduct6_closure+2;
           P64[Sp + 8] = _sg5yS::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.63217001 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cproduct_closure" {
     Data.Functor.Product.$fFoldableProduct_$cproduct_closure:
         const Data.Functor.Product.$fFoldableProduct_$cproduct_info;
         const 0;
 },
 $dMonoid_sg5yY_entry() //  [R1]
         { info_tbl: [(cg9iK,
                       label: $dMonoid_sg5yY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9iK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9iL; else goto cg9iM;
       cg9iL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9iM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5z4_entry() //  [R1]
         { info_tbl: [(cg9j1,
                       label: sat_sg5z4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9j1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9j2; else goto cg9j3;
       cg9j2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9j3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5z3_entry() //  [R1]
         { info_tbl: [(cg9j8,
                       label: sat_sg5z3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9j8: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9j9; else goto cg9ja;
       cg9j9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9ja: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5z5_entry() //  [R1, R2]
         { info_tbl: [(cg9jb,
                       label: sat_sg5z5_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9jb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9jc; else goto cg9jd;
       cg9jc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg9jd: // global
           I64[Sp - 40] = block_cg9iS_info;
           _sg5yV::P64 = P64[R1 + 7];
           _sg5yW::P64 = P64[R1 + 15];
           _sg5yX::P64 = P64[R1 + 23];
           _sg5yY::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5yV::P64;
           P64[Sp - 24] = _sg5yW::P64;
           P64[Sp - 16] = _sg5yX::P64;
           P64[Sp - 8] = _sg5yY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9jh; else goto cg9iT;
       ug9jh: // global
           call _cg9iS(R1) args: 0, res: 0, upd: 0;
       cg9iT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9iS() //  [R1]
         { info_tbl: [(cg9iS,
                       label: block_cg9iS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9iS: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg9jg; else goto cg9jf;
       cg9jg: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9jf: // global
           _sg5z1::P64 = P64[R1 + 7];
           _sg5z2::P64 = P64[R1 + 15];
           I64[Hp - 72] = sat_sg5z4_info;
           P64[Hp - 56] = P64[Sp + 16];
           _sg5yY::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sg5yY::P64;
           P64[Hp - 40] = _sg5z2::P64;
           I64[Hp - 32] = sat_sg5z3_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sg5yY::P64;
           P64[Hp] = _sg5z1::P64;
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cproduct_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg9ji,
                       label: Data.Functor.Product.$fFoldableProduct_$cproduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ji: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cg9jm; else goto cg9jl;
       cg9jm: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cproduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9jl: // global
           I64[Hp - 56] = $dMonoid_sg5yY_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sg5z5_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.648549989 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$ctoList_closure" {
     Data.Functor.Product.$fFoldableProduct_$ctoList_closure:
         const Data.Functor.Product.$fFoldableProduct_$ctoList_info;
         const 0;
 },
 sat_sg5zc_entry() //  [R1]
         { info_tbl: [(cg9k8,
                       label: sat_sg5zc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9k8: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg9k9; else goto cg9ka;
       cg9k9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9ka: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = GHC.Types.:_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$ctoList_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cg9kb,
                       label: Data.Functor.Product.$fFoldableProduct_$ctoList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9kb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9kc; else goto cg9kd;
       cg9kc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$ctoList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9kd: // global
           I64[Sp - 24] = block_cg9jZ_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ug9kh; else goto cg9k0;
       ug9kh: // global
           call _cg9jZ(R1) args: 0, res: 0, upd: 0;
       cg9k0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9jZ() //  [R1]
         { info_tbl: [(cg9jZ,
                       label: block_cg9jZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9jZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg9kg; else goto cg9kf;
       cg9kg: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9kf: // global
           _sg5za::P64 = P64[R1 + 7];
           _sg5zb::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sg5zc_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sg5zb::P64;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp] = GHC.Types.:_closure+2;
           P64[Sp + 8] = _sg5za::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.66061893 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_closure" {
     Data.Functor.Product.$fFoldableProduct_closure:
         const Data.Functor.Product.$fFoldableProduct_info;
         const 0;
 },
 sat_sg5zu_entry() //  [R1, R2]
         { info_tbl: [(cg9kH,
                       label: sat_sg5zu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9kH: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cproduct_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zt_entry() //  [R1, R2]
         { info_tbl: [(cg9kP,
                       label: sat_sg5zt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9kP: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$csum_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zs_entry() //  [R1, R2]
         { info_tbl: [(cg9kX,
                       label: sat_sg5zs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9kX: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cminimum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zr_entry() //  [R1, R2]
         { info_tbl: [(cg9l5,
                       label: sat_sg5zr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9l5: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cmaximum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zq_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9ld,
                       label: sat_sg5zq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ld: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$celem_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zp_entry() //  [R1, R2]
         { info_tbl: [(cg9ll,
                       label: sat_sg5zp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ll: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$clength_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zo_entry() //  [R1, R2]
         { info_tbl: [(cg9lt,
                       label: sat_sg5zo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9lt: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cnull_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zn_entry() //  [R1, R2]
         { info_tbl: [(cg9lB,
                       label: sat_sg5zn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9lB: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$ctoList_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zm_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9lJ,
                       label: sat_sg5zm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9lJ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$cfoldl1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zl_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9lR,
                       label: sat_sg5zl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9lR: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$cfoldr1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg9lZ,
                       label: sat_sg5zk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9lZ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldl'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zj_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg9m7,
                       label: sat_sg5zj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9m7: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldl_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zi_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg9mf,
                       label: sat_sg5zi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9mf: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldr'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zh_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg9mn,
                       label: sat_sg5zh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9mn: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldr_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg9mv,
                       label: sat_sg5zg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9mv: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldMap_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5zf_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9mD,
                       label: sat_sg5zf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9mD: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$cfold_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_entry() //  [R2, R3]
         { info_tbl: [(cg9mH,
                       label: Data.Functor.Product.$fFoldableProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9mH: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cg9mL; else goto cg9mK;
       cg9mL: // global
           HpAlloc = 520;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9mK: // global
           I64[Hp - 512] = sat_sg5zu_info;
           P64[Hp - 504] = R2;
           P64[Hp - 496] = R3;
           I64[Hp - 488] = sat_sg5zt_info;
           P64[Hp - 480] = R2;
           P64[Hp - 472] = R3;
           I64[Hp - 464] = sat_sg5zs_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           I64[Hp - 440] = sat_sg5zr_info;
           P64[Hp - 432] = R2;
           P64[Hp - 424] = R3;
           I64[Hp - 416] = sat_sg5zq_info;
           P64[Hp - 408] = R2;
           P64[Hp - 400] = R3;
           I64[Hp - 392] = sat_sg5zp_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           I64[Hp - 368] = sat_sg5zo_info;
           P64[Hp - 360] = R2;
           P64[Hp - 352] = R3;
           I64[Hp - 344] = sat_sg5zn_info;
           P64[Hp - 336] = R2;
           P64[Hp - 328] = R3;
           I64[Hp - 320] = sat_sg5zm_info;
           P64[Hp - 312] = R2;
           P64[Hp - 304] = R3;
           I64[Hp - 296] = sat_sg5zl_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           I64[Hp - 272] = sat_sg5zk_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_sg5zj_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_sg5zi_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_sg5zh_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sg5zg_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sg5zf_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = Data.Foldable.C:Foldable_con_info;
           P64[Hp - 120] = Hp - 150;
           P64[Hp - 112] = Hp - 173;
           P64[Hp - 104] = Hp - 197;
           P64[Hp - 96] = Hp - 221;
           P64[Hp - 88] = Hp - 245;
           P64[Hp - 80] = Hp - 269;
           P64[Hp - 72] = Hp - 294;
           P64[Hp - 64] = Hp - 318;
           P64[Hp - 56] = Hp - 343;
           P64[Hp - 48] = Hp - 367;
           P64[Hp - 40] = Hp - 391;
           P64[Hp - 32] = Hp - 414;
           P64[Hp - 24] = Hp - 439;
           P64[Hp - 16] = Hp - 463;
           P64[Hp - 8] = Hp - 487;
           P64[Hp] = Hp - 511;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.695665678 UTC

[section ""data" . Data.Functor.Product.$w$ctraverse_closure" {
     Data.Functor.Product.$w$ctraverse_closure:
         const Data.Functor.Product.$w$ctraverse_info;
 },
 sat_sg5zC_entry() //  [R1]
         { info_tbl: [(cg9o1,
                       label: sat_sg5zC_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9o1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9o2; else goto cg9o3;
       cg9o2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9o3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5zB_entry() //  [R1]
         { info_tbl: [(cg9o8,
                       label: sat_sg5zB_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9o8: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9o9; else goto cg9oa;
       cg9o9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9oa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$ctraverse_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg9ob,
                       label: Data.Functor.Product.$w$ctraverse_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ob: // global
           _sg5zz::P64 = R6;
           _sg5zy::P64 = R5;
           _sg5zx::P64 = R4;
           _sg5zw::P64 = R3;
           _sg5zv::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cg9oc; else goto cg9od;
       cg9od: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cg9of; else goto cg9oe;
       cg9of: // global
           HpAlloc = 96;
           goto cg9oc;
       cg9oc: // global
           R6 = _sg5zz::P64;
           R5 = _sg5zy::P64;
           R4 = _sg5zx::P64;
           R3 = _sg5zw::P64;
           R2 = _sg5zv::P64;
           R1 = Data.Functor.Product.$w$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg9oe: // global
           I64[Hp - 88] = sat_sg5zC_info;
           P64[Hp - 72] = _sg5zw::P64;
           P64[Hp - 64] = _sg5zx::P64;
           P64[Hp - 56] = _sg5zy::P64;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = sat_sg5zB_info;
           P64[Hp - 24] = _sg5zv::P64;
           P64[Hp - 16] = _sg5zx::P64;
           P64[Hp - 8] = _sg5zy::P64;
           P64[Hp] = _sg5zz::P64;
           R2 = _sg5zx::P64;
           I64[Sp - 24] = stg_ap_ppp_info;
           P64[Sp - 16] = Data.Functor.Product.Pair_closure+2;
           P64[Sp - 8] = Hp - 40;
           P64[Sp] = Hp - 88;
           Sp = Sp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.705052538 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$ctraverse_closure" {
     Data.Functor.Product.$fTraversableProduct_$ctraverse_closure:
         const Data.Functor.Product.$fTraversableProduct_$ctraverse_info;
 },
 Data.Functor.Product.$fTraversableProduct_$ctraverse_entry() //  [R2,
                                                                   R3, R4, R5, R6]
         { info_tbl: [(cg9oJ,
                       label: Data.Functor.Product.$fTraversableProduct_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9oJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9oK; else goto cg9oL;
       cg9oK: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9oL: // global
           I64[Sp - 40] = block_cg9oG_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9oP; else goto cg9oH;
       ug9oP: // global
           call _cg9oG(R1) args: 0, res: 0, upd: 0;
       cg9oH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9oG() //  [R1]
         { info_tbl: [(cg9oG,
                       label: block_cg9oG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9oG: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.713215732 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure" {
     Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure:
         const Data.Functor.Product.$fTraversableProduct_$cp2Traversable_info;
         const 0;
 },
 sat_sg5zO_entry() //  [R1]
         { info_tbl: [(cg9p8,
                       label: sat_sg5zO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9p8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9p9; else goto cg9pa;
       cg9p9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9pa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5zN_entry() //  [R1]
         { info_tbl: [(cg9pf,
                       label: sat_sg5zN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9pf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9pg; else goto cg9ph;
       cg9pg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9ph: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fTraversableProduct_$cp2Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cg9pi,
                       label: Data.Functor.Product.$fTraversableProduct_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9pi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg9pm; else goto cg9pl;
       cg9pm: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9pl: // global
           I64[Hp - 40] = sat_sg5zO_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5zN_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fFoldableProduct_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.72206553 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$cp1Traversable_closure" {
     Data.Functor.Product.$fTraversableProduct_$cp1Traversable_closure:
         const Data.Functor.Product.$fTraversableProduct_$cp1Traversable_info;
 },
 sat_sg5zS_entry() //  [R1]
         { info_tbl: [(cg9pH,
                       label: sat_sg5zS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9pH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9pI; else goto cg9pJ;
       cg9pI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9pJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5zR_entry() //  [R1]
         { info_tbl: [(cg9pO,
                       label: sat_sg5zR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9pO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9pP; else goto cg9pQ;
       cg9pP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9pQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fTraversableProduct_$cp1Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cg9pR,
                       label: Data.Functor.Product.$fTraversableProduct_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9pR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg9pV; else goto cg9pU;
       cg9pV: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9pU: // global
           I64[Hp - 40] = sat_sg5zS_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5zR_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fFunctorProduct_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.730448082 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$csequenceA_closure" {
     Data.Functor.Product.$fTraversableProduct_$csequenceA_closure:
         const Data.Functor.Product.$fTraversableProduct_$csequenceA_info;
 },
 Data.Functor.Product.$fTraversableProduct_$csequenceA_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cg9qf,
                       label: Data.Functor.Product.$fTraversableProduct_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9qf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg9qg; else goto cg9qh;
       cg9qg: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$csequenceA_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9qh: // global
           I64[Sp - 32] = block_cg9qc_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug9ql; else goto cg9qd;
       ug9ql: // global
           call _cg9qc(R1) args: 0, res: 0, upd: 0;
       cg9qd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9qc() //  [R1]
         { info_tbl: [(cg9qc,
                       label: block_cg9qc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9qc: // global
           R6 = P64[R1 + 7];
           R5 = GHC.Base.id_closure+1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.737418438 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$cmapM_closure" {
     Data.Functor.Product.$fTraversableProduct_$cmapM_closure:
         const Data.Functor.Product.$fTraversableProduct_$cmapM_info;
 },
 Data.Functor.Product.$fTraversableProduct_$cmapM_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cg9qD,
                       label: Data.Functor.Product.$fTraversableProduct_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9qD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9qH; else goto cg9qI;
       cg9qH: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9qI: // global
           I64[Sp - 40] = block_cg9qA_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9qO; else goto cg9qB;
       ug9qO: // global
           call _cg9qA(R1) args: 0, res: 0, upd: 0;
       cg9qB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9qA() //  [R1]
         { info_tbl: [(cg9qA,
                       label: block_cg9qA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9qA: // global
           I64[Sp - 8] = block_cg9qG_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg9qG() //  [R1]
         { info_tbl: [(cg9qG,
                       label: block_cg9qG_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9qG: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 40];
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.74654897 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$csequence_closure" {
     Data.Functor.Product.$fTraversableProduct_$csequence_closure:
         const Data.Functor.Product.$fTraversableProduct_$csequence_info;
 },
 Data.Functor.Product.$fTraversableProduct_$csequence_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cg9rb,
                       label: Data.Functor.Product.$fTraversableProduct_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9rb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9rf; else goto cg9rg;
       cg9rf: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9rg: // global
           I64[Sp - 32] = block_cg9r8_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug9rm; else goto cg9r9;
       ug9rm: // global
           call _cg9r8(R1) args: 0, res: 0, upd: 0;
       cg9r9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9r8() //  [R1]
         { info_tbl: [(cg9r8,
                       label: block_cg9r8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9r8: // global
           I64[Sp - 8] = block_cg9re_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg9re() //  [R1]
         { info_tbl: [(cg9re,
                       label: block_cg9re_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9re: // global
           R6 = P64[Sp + 32];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.755143689 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_closure" {
     Data.Functor.Product.$fTraversableProduct_closure:
         const Data.Functor.Product.$fTraversableProduct_info;
         const 0;
 },
 sat_sg5Ao_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9rL,
                       label: sat_sg5Ao_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9rL: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fTraversableProduct_$csequence_entry(R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5An_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg9rT,
                       label: sat_sg5An_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9rT: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fTraversableProduct_$cmapM_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Am_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9s1,
                       label: sat_sg5Am_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9s1: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fTraversableProduct_$csequenceA_entry(R5,
                                                                            R4,
                                                                            R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Al_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg9s9,
                       label: sat_sg5Al_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9s9: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fTraversableProduct_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Ak_entry() //  [R1]
         { info_tbl: [(cg9sg,
                       label: sat_sg5Ak_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9sg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9sh; else goto cg9si;
       cg9sh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9si: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fTraversableProduct_$cp2Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Aj_entry() //  [R1]
         { info_tbl: [(cg9sn,
                       label: sat_sg5Aj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9sn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9so; else goto cg9sp;
       cg9so: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9sp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fTraversableProduct_$cp1Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fTraversableProduct_entry() //  [R2, R3]
         { info_tbl: [(cg9sr,
                       label: Data.Functor.Product.$fTraversableProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9sr: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cg9sv; else goto cg9su;
       cg9sv: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9su: // global
           I64[Hp - 208] = sat_sg5Ao_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sg5An_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sg5Am_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sg5Al_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sg5Ak_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sg5Aj_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.77317716 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$cliftA2_closure" {
     Data.Functor.Product.$fApplicativeProduct_$cliftA2_closure:
         const Data.Functor.Product.$fApplicativeProduct_$cliftA2_info;
 },
 sat_sg5AB_entry() //  [R1]
         { info_tbl: [(cg9tj,
                       label: sat_sg5AB_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9tj: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9tk; else goto cg9tl;
       cg9tk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9tl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5AA_entry() //  [R1]
         { info_tbl: [(cg9tq,
                       label: sat_sg5AA_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9tq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9tr; else goto cg9ts;
       cg9tr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9ts: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$cliftA2_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cg9tt,
                       label: Data.Functor.Product.$fApplicativeProduct_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9tt: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9tv; else goto cg9tw;
       cg9tv: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$cliftA2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9tw: // global
           I64[Sp - 40] = block_cg9t5_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9tC; else goto cg9t6;
       ug9tC: // global
           call _cg9t5(R1) args: 0, res: 0, upd: 0;
       cg9t6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9t5() //  [R1]
         { info_tbl: [(cg9t5,
                       label: block_cg9t5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9t5: // global
           I64[Sp - 8] = block_cg9ta_info;
           _sg5Av::P64 = P64[R1 + 7];
           _sg5Aw::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5Aw::P64;
           P64[Sp + 32] = _sg5Av::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug9tB; else goto cg9tb;
       ug9tB: // global
           call _cg9ta(R1) args: 0, res: 0, upd: 0;
       cg9tb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9ta() //  [R1]
         { info_tbl: [(cg9ta,
                       label: block_cg9ta_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ta: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cg9tA; else goto cg9tz;
       cg9tA: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9tz: // global
           _sg5Ay::P64 = P64[R1 + 7];
           _sg5Az::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sg5AB_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sg5Ar::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sg5Ar::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sg5Az::P64;
           I64[Hp - 64] = sat_sg5AA_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sg5Ar::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sg5Ay::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.787833942 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$c<*>_closure" {
     Data.Functor.Product.$fApplicativeProduct_$c<*>_closure:
         const Data.Functor.Product.$fApplicativeProduct_$c<*>_info;
 },
 sat_sg5AN_entry() //  [R1]
         { info_tbl: [(cg9ut,
                       label: sat_sg5AN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ut: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9uu; else goto cg9uv;
       cg9uu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9uv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5AM_entry() //  [R1]
         { info_tbl: [(cg9uA,
                       label: sat_sg5AM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9uA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9uB; else goto cg9uC;
       cg9uB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9uC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$c<*>_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg9uD,
                       label: Data.Functor.Product.$fApplicativeProduct_$c<*>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9uD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9uF; else goto cg9uG;
       cg9uF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$c<*>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9uG: // global
           I64[Sp - 32] = block_cg9uf_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug9uM; else goto cg9ug;
       ug9uM: // global
           call _cg9uf(R1) args: 0, res: 0, upd: 0;
       cg9ug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9uf() //  [R1]
         { info_tbl: [(cg9uf,
                       label: block_cg9uf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9uf: // global
           I64[Sp - 8] = block_cg9uk_info;
           _sg5AH::P64 = P64[R1 + 7];
           _sg5AI::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5AI::P64;
           P64[Sp + 24] = _sg5AH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug9uL; else goto cg9ul;
       ug9uL: // global
           call _cg9uk(R1) args: 0, res: 0, upd: 0;
       cg9ul: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9uk() //  [R1]
         { info_tbl: [(cg9uk,
                       label: block_cg9uk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9uk: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg9uK; else goto cg9uJ;
       cg9uK: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9uJ: // global
           _sg5AK::P64 = P64[R1 + 7];
           _sg5AL::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5AN_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5AL::P64;
           I64[Hp - 56] = sat_sg5AM_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5AK::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.802314917 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$cpure_closure" {
     Data.Functor.Product.$fApplicativeProduct_$cpure_closure:
         const Data.Functor.Product.$fApplicativeProduct_$cpure_info;
 },
 sat_sg5AS_entry() //  [R1]
         { info_tbl: [(cg9vr,
                       label: sat_sg5AS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9vr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg9vs; else goto cg9vt;
       cg9vs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9vt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5AR_entry() //  [R1]
         { info_tbl: [(cg9vy,
                       label: sat_sg5AR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9vy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg9vz; else goto cg9vA;
       cg9vz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9vA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$cpure_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg9vC,
                       label: Data.Functor.Product.$fApplicativeProduct_$cpure_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9vC: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg9vG; else goto cg9vF;
       cg9vG: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$cpure_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9vF: // global
           I64[Hp - 80] = sat_sg5AS_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg5AR_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.811203188 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_closure" {
     Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_closure:
         const Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_info;
 },
 sat_sg5AW_entry() //  [R1]
         { info_tbl: [(cg9w6,
                       label: sat_sg5AW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9w6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9w7; else goto cg9w8;
       cg9w7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9w8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5AV_entry() //  [R1]
         { info_tbl: [(cg9wd,
                       label: sat_sg5AV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9wd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9we; else goto cg9wf;
       cg9we: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9wf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cg9wg,
                       label: Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9wg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg9wk; else goto cg9wj;
       cg9wk: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9wj: // global
           I64[Hp - 40] = sat_sg5AW_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5AV_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fFunctorProduct_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.819424742 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct1_closure" {
     Data.Functor.Product.$fApplicativeProduct1_closure:
         const Data.Functor.Product.$fApplicativeProduct1_info;
 },
 Data.Functor.Product.$fApplicativeProduct1_entry() //  [R3]
         { info_tbl: [(cg9wB,
                       label: Data.Functor.Product.$fApplicativeProduct1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9wB: // global
           R2 = R3;
           call GHC.Base.breakpoint_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.824365806 UTC

[section ""data" . Data.Functor.Product.$w$c*>_closure" {
     Data.Functor.Product.$w$c*>_closure:
         const Data.Functor.Product.$w$c*>_info;
 },
 sat_sg5B8_entry() //  [R1]
         { info_tbl: [(cg9wW,
                       label: sat_sg5B8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9wW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9wX; else goto cg9wY;
       cg9wX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9wY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cg9wU_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg9wU() //  [R1]
         { info_tbl: [(cg9wU,
                       label: block_cg9wU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9wU: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Product.$fApplicativeProduct1_closure+2;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5B9_entry() //  [R1]
         { info_tbl: [(cg9x2,
                       label: sat_sg5B9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9x2: // global
           _sg5B9::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg9x3; else goto cg9x4;
       cg9x4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg9x6; else goto cg9x5;
       cg9x6: // global
           HpAlloc = 32;
           goto cg9x3;
       cg9x3: // global
           R1 = _sg5B9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9x5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5B9::P64;
           _sg5AZ::P64 = P64[_sg5B9::P64 + 16];
           _sg5B1::P64 = P64[_sg5B9::P64 + 24];
           _sg5B3::P64 = P64[_sg5B9::P64 + 32];
           I64[Hp - 24] = sat_sg5B8_info;
           P64[Hp - 8] = _sg5AZ::P64;
           P64[Hp] = _sg5B1::P64;
           R2 = _sg5AZ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sg5B3::P64;
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5B5_entry() //  [R1]
         { info_tbl: [(cg9xh,
                       label: sat_sg5B5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9xh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9xi; else goto cg9xj;
       cg9xi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9xj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cg9xf_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg9xf() //  [R1]
         { info_tbl: [(cg9xf,
                       label: block_cg9xf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9xf: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Product.$fApplicativeProduct1_closure+2;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5B6_entry() //  [R1]
         { info_tbl: [(cg9xn,
                       label: sat_sg5B6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9xn: // global
           _sg5B6::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg9xo; else goto cg9xp;
       cg9xp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg9xr; else goto cg9xq;
       cg9xr: // global
           HpAlloc = 32;
           goto cg9xo;
       cg9xo: // global
           R1 = _sg5B6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9xq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5B6::P64;
           _sg5AY::P64 = P64[_sg5B6::P64 + 16];
           _sg5B0::P64 = P64[_sg5B6::P64 + 24];
           _sg5B2::P64 = P64[_sg5B6::P64 + 32];
           I64[Hp - 24] = sat_sg5B5_info;
           P64[Hp - 8] = _sg5AY::P64;
           P64[Hp] = _sg5B0::P64;
           R2 = _sg5AY::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sg5B2::P64;
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c*>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg9xs,
                       label: Data.Functor.Product.$w$c*>_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9xs: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg9xw; else goto cg9xv;
       cg9xw: // global
           HpAlloc = 80;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$c*>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cg9xv: // global
           I64[Hp - 72] = sat_sg5B9_info;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = P64[Sp];
           I64[Hp - 32] = sat_sg5B6_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R6;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.843373237 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$c*>_closure" {
     Data.Functor.Product.$fApplicativeProduct_$c*>_closure:
         const Data.Functor.Product.$fApplicativeProduct_$c*>_info;
 },
 Data.Functor.Product.$fApplicativeProduct_$c*>_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cg9ya,
                       label: Data.Functor.Product.$fApplicativeProduct_$c*>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ya: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9yl; else goto cg9ym;
       cg9yl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$c*>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9ym: // global
           I64[Sp - 32] = block_cg9y7_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug9yt; else goto cg9y8;
       ug9yt: // global
           call _cg9y7(R1) args: 0, res: 0, upd: 0;
       cg9y8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9y7() //  [R1]
         { info_tbl: [(cg9y7,
                       label: block_cg9y7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9y7: // global
           I64[Sp - 8] = block_cg9yd_info;
           _sg5Bf::P64 = P64[R1 + 7];
           _sg5Bg::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5Bg::P64;
           P64[Sp + 24] = _sg5Bf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug9ys; else goto cg9ye;
       ug9ys: // global
           call _cg9yd(R1) args: 0, res: 0, upd: 0;
       cg9ye: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9yd() //  [R1]
         { info_tbl: [(cg9yd,
                       label: block_cg9yd_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9yd: // global
           _sg5Bf::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg9yi_info;
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 8];
           R4 = _sg5Bf::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$c*>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 8, upd: 8;
     }
 },
 _cg9yi() //  [R1, R2]
         { info_tbl: [(cg9yi,
                       label: block_cg9yi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9yi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg9yr; else goto cg9yq;
       cg9yr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cg9yq: // global
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.854680759 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$c<*_closure" {
     Data.Functor.Product.$fApplicativeProduct_$c<*_closure:
         const Data.Functor.Product.$fApplicativeProduct_$c<*_info;
 },
 sat_sg5By_entry() //  [R1]
         { info_tbl: [(cg9z4,
                       label: sat_sg5By_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9z4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9z5; else goto cg9z6;
       cg9z5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9z6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Base.const_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5Bx_entry() //  [R1]
         { info_tbl: [(cg9zb,
                       label: sat_sg5Bx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9zb: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9zc; else goto cg9zd;
       cg9zc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9zd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Base.const_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$c<*_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cg9ze,
                       label: Data.Functor.Product.$fApplicativeProduct_$c<*_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ze: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9zg; else goto cg9zh;
       cg9zg: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$c<*_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9zh: // global
           I64[Sp - 32] = block_cg9yQ_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug9zn; else goto cg9yR;
       ug9zn: // global
           call _cg9yQ(R1) args: 0, res: 0, upd: 0;
       cg9yR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9yQ() //  [R1]
         { info_tbl: [(cg9yQ,
                       label: block_cg9yQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9yQ: // global
           I64[Sp - 8] = block_cg9yV_info;
           _sg5Bs::P64 = P64[R1 + 7];
           _sg5Bt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5Bt::P64;
           P64[Sp + 24] = _sg5Bs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug9zm; else goto cg9yW;
       ug9zm: // global
           call _cg9yV(R1) args: 0, res: 0, upd: 0;
       cg9yW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9yV() //  [R1]
         { info_tbl: [(cg9yV,
                       label: block_cg9yV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9yV: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg9zl; else goto cg9zk;
       cg9zl: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9zk: // global
           _sg5Bv::P64 = P64[R1 + 7];
           _sg5Bw::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5By_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5Bw::P64;
           I64[Hp - 56] = sat_sg5Bx_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5Bv::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.86927752 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_closure" {
     Data.Functor.Product.$fApplicativeProduct_closure:
         const Data.Functor.Product.$fApplicativeProduct_info;
 },
 sat_sg5BG_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9A3,
                       label: sat_sg5BG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9A3: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fApplicativeProduct_$c<*_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BF_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9Ab,
                       label: sat_sg5BF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Ab: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fApplicativeProduct_$c*>_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BE_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg9Aj,
                       label: sat_sg5BE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Aj: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fApplicativeProduct_$cliftA2_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BD_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9Ar,
                       label: sat_sg5BD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Ar: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fApplicativeProduct_$c<*>_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BC_entry() //  [R1, R2]
         { info_tbl: [(cg9Az,
                       label: sat_sg5BC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Az: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fApplicativeProduct_$cpure_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5BB_entry() //  [R1]
         { info_tbl: [(cg9AG,
                       label: sat_sg5BB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9AG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9AH; else goto cg9AI;
       cg9AH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9AI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_entry() //  [R2, R3]
         { info_tbl: [(cg9AK,
                       label: Data.Functor.Product.$fApplicativeProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9AK: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cg9AO; else goto cg9AN;
       cg9AO: // global
           HpAlloc = 208;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9AN: // global
           I64[Hp - 200] = sat_sg5BG_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sg5BF_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sg5BE_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sg5BD_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sg5BC_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sg5BB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 103;
           P64[Hp - 24] = Hp - 126;
           P64[Hp - 16] = Hp - 149;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 198;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.88643541 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$c<|>_closure" {
     Data.Functor.Product.$fAlternativeProduct_$c<|>_closure:
         const Data.Functor.Product.$fAlternativeProduct_$c<|>_info;
 },
 sat_sg5BS_entry() //  [R1]
         { info_tbl: [(cg9BB,
                       label: sat_sg5BS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9BB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9BC; else goto cg9BD;
       cg9BC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9BD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5BR_entry() //  [R1]
         { info_tbl: [(cg9BI,
                       label: sat_sg5BR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9BI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9BJ; else goto cg9BK;
       cg9BJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9BK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_$c<|>_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg9BL,
                       label: Data.Functor.Product.$fAlternativeProduct_$c<|>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9BL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9BN; else goto cg9BO;
       cg9BN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$c<|>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9BO: // global
           I64[Sp - 32] = block_cg9Bn_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug9BU; else goto cg9Bo;
       ug9BU: // global
           call _cg9Bn(R1) args: 0, res: 0, upd: 0;
       cg9Bo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9Bn() //  [R1]
         { info_tbl: [(cg9Bn,
                       label: block_cg9Bn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Bn: // global
           I64[Sp - 8] = block_cg9Bs_info;
           _sg5BM::P64 = P64[R1 + 7];
           _sg5BN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5BN::P64;
           P64[Sp + 24] = _sg5BM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug9BT; else goto cg9Bt;
       ug9BT: // global
           call _cg9Bs(R1) args: 0, res: 0, upd: 0;
       cg9Bt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9Bs() //  [R1]
         { info_tbl: [(cg9Bs,
                       label: block_cg9Bs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Bs: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg9BS; else goto cg9BR;
       cg9BS: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9BR: // global
           _sg5BP::P64 = P64[R1 + 7];
           _sg5BQ::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5BS_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5BQ::P64;
           I64[Hp - 56] = sat_sg5BR_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5BP::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.900687747 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$cempty_closure" {
     Data.Functor.Product.$fAlternativeProduct_$cempty_closure:
         const Data.Functor.Product.$fAlternativeProduct_$cempty_info;
 },
 sat_sg5BW_entry() //  [R1]
         { info_tbl: [(cg9Cz,
                       label: sat_sg5BW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Cz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9CA; else goto cg9CB;
       cg9CA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9CB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5BV_entry() //  [R1]
         { info_tbl: [(cg9CG,
                       label: sat_sg5BV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9CG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9CH; else goto cg9CI;
       cg9CH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9CI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_$cempty_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cg9CK,
                       label: Data.Functor.Product.$fAlternativeProduct_$cempty_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9CK: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg9CO; else goto cg9CN;
       cg9CO: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$cempty_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9CN: // global
           I64[Hp - 64] = sat_sg5BW_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5BV_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.909665213 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_closure" {
     Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_closure:
         const Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_info;
 },
 sat_sg5C0_entry() //  [R1]
         { info_tbl: [(cg9Dc,
                       label: sat_sg5C0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Dc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9Dd; else goto cg9De;
       cg9Dd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9De: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5BZ_entry() //  [R1]
         { info_tbl: [(cg9Dj,
                       label: sat_sg5BZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Dj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9Dk; else goto cg9Dl;
       cg9Dk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Dl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cg9Dm,
                       label: Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Dm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg9Dq; else goto cg9Dp;
       cg9Dq: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9Dp: // global
           I64[Hp - 40] = sat_sg5C0_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5BZ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fApplicativeProduct_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.91925984 UTC

[section ""data" . poly_some_v_rg5o0_closure" {
     poly_some_v_rg5o0_closure:
         const poly_some_v_rg5o0_info;
         const 0;
         const 0;
         const 0;
 },
 poly_some_v_rg5o0_entry() //  [R1]
         { info_tbl: [(cg9DJ,
                       label: poly_some_v_rg5o0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9DJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9DK; else goto cg9DL;
       cg9DK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9DL: // global
           (_cg9DG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cg9DG::I64 == 0) goto cg9DI; else goto cg9DH;
       cg9DI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cg9DH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cg9DG::I64;
           R1 = poly_some_v_rg5o0_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.923895964 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$csome_closure" {
     Data.Functor.Product.$fAlternativeProduct_$csome_closure:
         const Data.Functor.Product.$fAlternativeProduct_$csome_info;
         const 0;
 },
 Data.Functor.Product.$fAlternativeProduct_$csome_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cg9E1,
                       label: Data.Functor.Product.$fAlternativeProduct_$csome_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9E1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg9E2; else goto cg9E3;
       cg9E2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$csome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9E3: // global
           I64[Sp - 8] = block_cg9DY_info;
           R1 = R4;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug9E7; else goto cg9DZ;
       ug9E7: // global
           call _cg9DY() args: 0, res: 0, upd: 0;
       cg9DZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9DY() //  []
         { info_tbl: [(cg9DY,
                       label: block_cg9DY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9DY: // global
           R1 = poly_some_v_rg5o0_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.930844748 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_closure" {
     Data.Functor.Product.$fAlternativeProduct_closure:
         const Data.Functor.Product.$fAlternativeProduct_info;
         const 0;
 },
 sat_sg5Cd_entry() //  [R1, R2]
         { info_tbl: [(cg9Er,
                       label: sat_sg5Cd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Er: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fAlternativeProduct_$csome_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Cc_entry() //  [R1, R2]
         { info_tbl: [(cg9Ez,
                       label: sat_sg5Cc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Ez: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fAlternativeProduct_$csome_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Cb_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9EH,
                       label: sat_sg5Cb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9EH: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fAlternativeProduct_$c<|>_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Ca_entry() //  [R1]
         { info_tbl: [(cg9EO,
                       label: sat_sg5Ca_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9EO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9EP; else goto cg9EQ;
       cg9EP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9EQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fAlternativeProduct_$cempty_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5C9_entry() //  [R1]
         { info_tbl: [(cg9EV,
                       label: sat_sg5C9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9EV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9EW; else goto cg9EX;
       cg9EW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9EX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_entry() //  [R2, R3]
         { info_tbl: [(cg9EZ,
                       label: Data.Functor.Product.$fAlternativeProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9EZ: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cg9F3; else goto cg9F2;
       cg9F3: // global
           HpAlloc = 184;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9F2: // global
           I64[Hp - 176] = sat_sg5Cd_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sg5Cc_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sg5Cb_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sg5Ca_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_sg5C9_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 104;
           P64[Hp - 16] = Hp - 126;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 175;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.946969842 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$c>>=_closure" {
     Data.Functor.Product.$fMonadProduct_$c>>=_closure:
         const Data.Functor.Product.$fMonadProduct_$c>>=_info;
 },
 sat_sg5Cv_entry() //  [R1, R2]
         { info_tbl: [(cg9FP,
                       label: sat_sg5Cv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9FP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg9FQ; else goto cg9FR;
       cg9FQ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg9FR: // global
           I64[Sp - 8] = block_cg9FN_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9FN() //  [R1]
         { info_tbl: [(cg9FN,
                       label: block_cg9FN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9FN: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Cw_entry() //  [R1]
         { info_tbl: [(cg9FV,
                       label: sat_sg5Cw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9FV: // global
           _sg5Cw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg9FW; else goto cg9FX;
       cg9FX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg9FZ; else goto cg9FY;
       cg9FZ: // global
           HpAlloc = 16;
           goto cg9FW;
       cg9FW: // global
           R1 = _sg5Cw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9FY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Cw::P64;
           _sg5Cf::P64 = P64[_sg5Cw::P64 + 16];
           _sg5Ch::P64 = P64[_sg5Cw::P64 + 24];
           _sg5Ck::P64 = P64[_sg5Cw::P64 + 32];
           I64[Hp - 8] = sat_sg5Cv_info;
           P64[Hp] = _sg5Ch::P64;
           R2 = _sg5Cf::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5Ck::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5Cp_entry() //  [R1, R2]
         { info_tbl: [(cg9Gb,
                       label: sat_sg5Cp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Gb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg9Gc; else goto cg9Gd;
       cg9Gc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg9Gd: // global
           I64[Sp - 8] = block_cg9G9_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9G9() //  [R1]
         { info_tbl: [(cg9G9,
                       label: block_cg9G9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9G9: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Cq_entry() //  [R1]
         { info_tbl: [(cg9Gh,
                       label: sat_sg5Cq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Gh: // global
           _sg5Cq::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg9Gi; else goto cg9Gj;
       cg9Gj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg9Gl; else goto cg9Gk;
       cg9Gl: // global
           HpAlloc = 16;
           goto cg9Gi;
       cg9Gi: // global
           R1 = _sg5Cq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Gk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Cq::P64;
           _sg5Ce::P64 = P64[_sg5Cq::P64 + 16];
           _sg5Ch::P64 = P64[_sg5Cq::P64 + 24];
           _sg5Cj::P64 = P64[_sg5Cq::P64 + 32];
           I64[Hp - 8] = sat_sg5Cp_info;
           P64[Hp] = _sg5Ch::P64;
           R2 = _sg5Ce::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5Cj::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$c>>=_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cg9Gm,
                       label: Data.Functor.Product.$fMonadProduct_$c>>=_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Gm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg9Go; else goto cg9Gp;
       cg9Go: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$c>>=_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9Gp: // global
           I64[Sp - 32] = block_cg9Fz_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug9Gt; else goto cg9FA;
       ug9Gt: // global
           call _cg9Fz(R1) args: 0, res: 0, upd: 0;
       cg9FA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9Fz() //  [R1]
         { info_tbl: [(cg9Fz,
                       label: block_cg9Fz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Fz: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg9Gs; else goto cg9Gr;
       cg9Gs: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9Gr: // global
           _sg5Cj::P64 = P64[R1 + 7];
           _sg5Ck::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5Cw_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sg5Ch::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sg5Ch::P64;
           P64[Hp - 64] = _sg5Ck::P64;
           I64[Hp - 56] = sat_sg5Cq_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg5Ch::P64;
           P64[Hp - 24] = _sg5Cj::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.967043468 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$cp1Monad_closure" {
     Data.Functor.Product.$fMonadProduct_$cp1Monad_closure:
         const Data.Functor.Product.$fMonadProduct_$cp1Monad_info;
 },
 sat_sg5CA_entry() //  [R1]
         { info_tbl: [(cg9He,
                       label: sat_sg5CA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9He: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9Hf; else goto cg9Hg;
       cg9Hf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Hg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Cz_entry() //  [R1]
         { info_tbl: [(cg9Hl,
                       label: sat_sg5Cz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Hl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9Hm; else goto cg9Hn;
       cg9Hm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Hn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$cp1Monad_entry() //  [R2, R3]
         { info_tbl: [(cg9Ho,
                       label: Data.Functor.Product.$fMonadProduct_$cp1Monad_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Ho: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg9Hs; else goto cg9Hr;
       cg9Hs: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$cp1Monad_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9Hr: // global
           I64[Hp - 40] = sat_sg5CA_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5Cz_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fApplicativeProduct_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.976354672 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$creturn_closure" {
     Data.Functor.Product.$fMonadProduct_$creturn_closure:
         const Data.Functor.Product.$fMonadProduct_$creturn_info;
 },
 sat_sg5CH_entry() //  [R1]
         { info_tbl: [(cg9HP,
                       label: sat_sg5CH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9HP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg9HQ; else goto cg9HR;
       cg9HQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9HR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cg9HN_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg9HN() //  [R1]
         { info_tbl: [(cg9HN,
                       label: block_cg9HN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9HN: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5CF_entry() //  [R1]
         { info_tbl: [(cg9I1,
                       label: sat_sg5CF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9I1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg9I2; else goto cg9I3;
       cg9I2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9I3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cg9HZ_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg9HZ() //  [R1]
         { info_tbl: [(cg9HZ,
                       label: block_cg9HZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9HZ: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$creturn_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cg9I8,
                       label: Data.Functor.Product.$fMonadProduct_$creturn_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9I8: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg9Ic; else goto cg9Ib;
       cg9Ic: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$creturn_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9Ib: // global
           I64[Hp - 80] = sat_sg5CH_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg5CF_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:56.99006143 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$c>>_closure" {
     Data.Functor.Product.$fMonadProduct_$c>>_closure:
         const Data.Functor.Product.$fMonadProduct_$c>>_info;
 },
 sat_sg5CZ_entry() //  [R1, R2]
         { info_tbl: [(cg9IV,
                       label: sat_sg5CZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9IV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg9IW; else goto cg9IX;
       cg9IW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg9IX: // global
           I64[Sp - 8] = block_cg9IS_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug9J1; else goto cg9IT;
       ug9J1: // global
           call _cg9IS(R1) args: 0, res: 0, upd: 0;
       cg9IT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9IS() //  [R1]
         { info_tbl: [(cg9IS,
                       label: block_cg9IS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9IS: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5D0_entry() //  [R1]
         { info_tbl: [(cg9J2,
                       label: sat_sg5D0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9J2: // global
           _sg5D0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg9J3; else goto cg9J4;
       cg9J4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg9J6; else goto cg9J5;
       cg9J6: // global
           HpAlloc = 16;
           goto cg9J3;
       cg9J3: // global
           R1 = _sg5D0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9J5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5D0::P64;
           _sg5CJ::P64 = P64[_sg5D0::P64 + 16];
           _sg5CL::P64 = P64[_sg5D0::P64 + 24];
           _sg5CO::P64 = P64[_sg5D0::P64 + 32];
           I64[Hp - 8] = sat_sg5CZ_info;
           P64[Hp] = _sg5CL::P64;
           R2 = _sg5CJ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5CO::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5CT_entry() //  [R1, R2]
         { info_tbl: [(cg9Jj,
                       label: sat_sg5CT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Jj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg9Jk; else goto cg9Jl;
       cg9Jk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg9Jl: // global
           I64[Sp - 8] = block_cg9Jg_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug9Jp; else goto cg9Jh;
       ug9Jp: // global
           call _cg9Jg(R1) args: 0, res: 0, upd: 0;
       cg9Jh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9Jg() //  [R1]
         { info_tbl: [(cg9Jg,
                       label: block_cg9Jg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Jg: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5CU_entry() //  [R1]
         { info_tbl: [(cg9Jq,
                       label: sat_sg5CU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Jq: // global
           _sg5CU::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg9Jr; else goto cg9Js;
       cg9Js: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg9Ju; else goto cg9Jt;
       cg9Ju: // global
           HpAlloc = 16;
           goto cg9Jr;
       cg9Jr: // global
           R1 = _sg5CU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Jt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5CU::P64;
           _sg5CI::P64 = P64[_sg5CU::P64 + 16];
           _sg5CL::P64 = P64[_sg5CU::P64 + 24];
           _sg5CN::P64 = P64[_sg5CU::P64 + 32];
           I64[Hp - 8] = sat_sg5CT_info;
           P64[Hp] = _sg5CL::P64;
           R2 = _sg5CI::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5CN::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$c>>_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(cg9Jv,
                       label: Data.Functor.Product.$fMonadProduct_$c>>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Jv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg9Jx; else goto cg9Jy;
       cg9Jx: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$c>>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9Jy: // global
           I64[Sp - 32] = block_cg9IE_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug9JC; else goto cg9IF;
       ug9JC: // global
           call _cg9IE(R1) args: 0, res: 0, upd: 0;
       cg9IF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9IE() //  [R1]
         { info_tbl: [(cg9IE,
                       label: block_cg9IE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9IE: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg9JB; else goto cg9JA;
       cg9JB: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9JA: // global
           _sg5CN::P64 = P64[R1 + 7];
           _sg5CO::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5D0_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sg5CL::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sg5CL::P64;
           P64[Hp - 64] = _sg5CO::P64;
           I64[Hp - 56] = sat_sg5CU_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sg5CL::P64;
           P64[Hp - 24] = _sg5CN::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.010042066 UTC

[section ""data" . lvl4_rg5o1_closure" {
     lvl4_rg5o1_closure:
         const lvl4_rg5o1_info;
         const 0;
 },
 lvl4_rg5o1_entry() //  [R2]
         { info_tbl: [(cg9Kl,
                       label: lvl4_rg5o1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Kl: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.014307775 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_closure" {
     Data.Functor.Product.$fMonadProduct_closure:
         const Data.Functor.Product.$fMonadProduct_info;
         const 0;
 },
 sat_sg5D7_entry() //  [R1, R2]
         { info_tbl: [(cg9KB,
                       label: sat_sg5D7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9KB: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fMonadProduct_$creturn_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5D6_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9KJ,
                       label: sat_sg5D6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9KJ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadProduct_$c>>_entry(R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5D5_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9KR,
                       label: sat_sg5D5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9KR: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadProduct_$c>>=_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5D4_entry() //  [R1]
         { info_tbl: [(cg9KY,
                       label: sat_sg5D4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9KY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9KZ; else goto cg9L0;
       cg9KZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9L0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadProduct_$cp1Monad_entry(R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_entry() //  [R2, R3]
         { info_tbl: [(cg9L2,
                       label: Data.Functor.Product.$fMonadProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9L2: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cg9L6; else goto cg9L5;
       cg9L6: // global
           HpAlloc = 152;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9L5: // global
           I64[Hp - 144] = sat_sg5D7_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_sg5D6_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_sg5D5_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_sg5D4_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 94;
           P64[Hp - 16] = Hp - 118;
           P64[Hp - 8] = Hp - 143;
           P64[Hp] = lvl4_rg5o1_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.027015432 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cmplus_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cmplus_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cmplus_info;
 },
 sat_sg5Dj_entry() //  [R1]
         { info_tbl: [(cg9LL,
                       label: sat_sg5Dj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9LL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9LM; else goto cg9LN;
       cg9LM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9LN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5Di_entry() //  [R1]
         { info_tbl: [(cg9LS,
                       label: sat_sg5Di_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9LS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9LT; else goto cg9LU;
       cg9LT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9LU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cmplus_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cg9LV,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cmplus_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9LV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9LX; else goto cg9LY;
       cg9LX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cmplus_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9LY: // global
           I64[Sp - 32] = block_cg9Lx_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug9M4; else goto cg9Ly;
       ug9M4: // global
           call _cg9Lx(R1) args: 0, res: 0, upd: 0;
       cg9Ly: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9Lx() //  [R1]
         { info_tbl: [(cg9Lx,
                       label: block_cg9Lx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Lx: // global
           I64[Sp - 8] = block_cg9LC_info;
           _sg5Dd::P64 = P64[R1 + 7];
           _sg5De::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5De::P64;
           P64[Sp + 24] = _sg5Dd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug9M3; else goto cg9LD;
       ug9M3: // global
           call _cg9LC(R1) args: 0, res: 0, upd: 0;
       cg9LD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9LC() //  [R1]
         { info_tbl: [(cg9LC,
                       label: block_cg9LC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9LC: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg9M2; else goto cg9M1;
       cg9M2: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9M1: // global
           _sg5Dg::P64 = P64[R1 + 7];
           _sg5Dh::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5Dj_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5Dh::P64;
           I64[Hp - 56] = sat_sg5Di_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5Dg::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.041149834 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cmzero_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cmzero_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cmzero_info;
 },
 sat_sg5Dn_entry() //  [R1]
         { info_tbl: [(cg9MJ,
                       label: sat_sg5Dn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9MJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9MK; else goto cg9ML;
       cg9MK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9ML: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Dm_entry() //  [R1]
         { info_tbl: [(cg9MQ,
                       label: sat_sg5Dm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9MQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9MR; else goto cg9MS;
       cg9MR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9MS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cmzero_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cg9MU,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cmzero_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9MU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cg9MY; else goto cg9MX;
       cg9MY: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cmzero_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9MX: // global
           I64[Hp - 64] = sat_sg5Dn_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sg5Dm_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.049750736 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_info;
         const 0;
 },
 sat_sg5Dr_entry() //  [R1]
         { info_tbl: [(cg9Nm,
                       label: sat_sg5Dr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Nm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9Nn; else goto cg9No;
       cg9Nn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9No: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Dq_entry() //  [R1]
         { info_tbl: [(cg9Nt,
                       label: sat_sg5Dq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Nt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9Nu; else goto cg9Nv;
       cg9Nu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Nv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cg9Nw,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Nw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg9NA; else goto cg9Nz;
       cg9NA: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9Nz: // global
           I64[Hp - 40] = sat_sg5Dr_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5Dq_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fMonadProduct_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.058329217 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_info;
         const 0;
 },
 sat_sg5Dv_entry() //  [R1]
         { info_tbl: [(cg9NV,
                       label: sat_sg5Dv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9NV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9NW; else goto cg9NX;
       cg9NW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9NX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Du_entry() //  [R1]
         { info_tbl: [(cg9O2,
                       label: sat_sg5Du_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9O2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9O3; else goto cg9O4;
       cg9O3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9O4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cg9O5,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9O5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg9O9; else goto cg9O8;
       cg9O9: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9O8: // global
           I64[Hp - 40] = sat_sg5Dv_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5Du_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fAlternativeProduct_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.067933062 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_closure" {
     Data.Functor.Product.$fMonadPlusProduct_closure:
         const Data.Functor.Product.$fMonadPlusProduct_info;
         const 0;
 },
 sat_sg5DB_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9Ov,
                       label: sat_sg5DB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Ov: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadPlusProduct_$cmplus_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5DA_entry() //  [R1]
         { info_tbl: [(cg9OC,
                       label: sat_sg5DA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9OC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9OD; else goto cg9OE;
       cg9OD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9OE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadPlusProduct_$cmzero_entry(R3,
                                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Dz_entry() //  [R1]
         { info_tbl: [(cg9OJ,
                       label: sat_sg5Dz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9OJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9OK; else goto cg9OL;
       cg9OK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9OL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_entry(R3,
                                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Dy_entry() //  [R1]
         { info_tbl: [(cg9OQ,
                       label: sat_sg5Dy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9OQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9OR; else goto cg9OS;
       cg9OR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9OS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_entry(R3,
                                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_entry() //  [R2, R3]
         { info_tbl: [(cg9OU,
                       label: Data.Functor.Product.$fMonadPlusProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9OU: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cg9OY; else goto cg9OX;
       cg9OY: // global
           HpAlloc = 160;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9OX: // global
           I64[Hp - 152] = sat_sg5DB_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sg5DA_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_sg5Dz_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sg5Dy_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 96;
           P64[Hp - 8] = Hp - 128;
           P64[Hp] = Hp - 150;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.081224723 UTC

[section ""data" . Data.Functor.Product.$fMonadFixProduct_$cmfix_closure" {
     Data.Functor.Product.$fMonadFixProduct_$cmfix_closure:
         const Data.Functor.Product.$fMonadFixProduct_$cmfix_info;
 },
 sat_sg5DP_entry() //  [R1, R2]
         { info_tbl: [(cg9PC,
                       label: sat_sg5DP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9PC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg9PD; else goto cg9PE;
       cg9PD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg9PE: // global
           I64[Sp - 8] = block_cg9PA_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9PA() //  [R1]
         { info_tbl: [(cg9PA,
                       label: block_cg9PA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9PA: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5DQ_entry() //  [R1]
         { info_tbl: [(cg9PI,
                       label: sat_sg5DQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9PI: // global
           _sg5DQ::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg9PJ; else goto cg9PK;
       cg9PK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg9PM; else goto cg9PL;
       cg9PM: // global
           HpAlloc = 16;
           goto cg9PJ;
       cg9PJ: // global
           R1 = _sg5DQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9PL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5DQ::P64;
           _sg5DD::P64 = P64[_sg5DQ::P64 + 16];
           _sg5DE::P64 = P64[_sg5DQ::P64 + 24];
           I64[Hp - 8] = sat_sg5DP_info;
           P64[Hp] = _sg5DE::P64;
           R2 = _sg5DD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5DJ_entry() //  [R1, R2]
         { info_tbl: [(cg9PY,
                       label: sat_sg5DJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9PY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg9PZ; else goto cg9Q0;
       cg9PZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg9Q0: // global
           I64[Sp - 8] = block_cg9PW_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9PW() //  [R1]
         { info_tbl: [(cg9PW,
                       label: block_cg9PW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9PW: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5DK_entry() //  [R1]
         { info_tbl: [(cg9Q4,
                       label: sat_sg5DK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Q4: // global
           _sg5DK::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cg9Q5; else goto cg9Q6;
       cg9Q6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cg9Q8; else goto cg9Q7;
       cg9Q8: // global
           HpAlloc = 16;
           goto cg9Q5;
       cg9Q5: // global
           R1 = _sg5DK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Q7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5DK::P64;
           _sg5DC::P64 = P64[_sg5DK::P64 + 16];
           _sg5DE::P64 = P64[_sg5DK::P64 + 24];
           I64[Hp - 8] = sat_sg5DJ_info;
           P64[Hp] = _sg5DE::P64;
           R2 = _sg5DC::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadFixProduct_$cmfix_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cg9Qa,
                       label: Data.Functor.Product.$fMonadFixProduct_$cmfix_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Qa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg9Qe; else goto cg9Qd;
       cg9Qe: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadFixProduct_$cmfix_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9Qd: // global
           I64[Hp - 80] = sat_sg5DQ_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sg5DK_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.098393532 UTC

[section ""data" . Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure" {
     Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure:
         const Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_info;
         const 0;
 },
 sat_sg5DU_entry() //  [R1]
         { info_tbl: [(cg9QS,
                       label: sat_sg5DU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9QS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9QT; else goto cg9QU;
       cg9QT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9QU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5DT_entry() //  [R1]
         { info_tbl: [(cg9QZ,
                       label: sat_sg5DT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9QZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9R0; else goto cg9R1;
       cg9R0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9R1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cg9R2,
                       label: Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9R2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg9R6; else goto cg9R5;
       cg9R6: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9R5: // global
           I64[Hp - 40] = sat_sg5DU_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5DT_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fMonadProduct_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.106997195 UTC

[section ""data" . Data.Functor.Product.$fMonadFixProduct_closure" {
     Data.Functor.Product.$fMonadFixProduct_closure:
         const Data.Functor.Product.$fMonadFixProduct_info;
         const 0;
 },
 sat_sg5DY_entry() //  [R1, R2]
         { info_tbl: [(cg9Rs,
                       label: sat_sg5DY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Rs: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fMonadFixProduct_$cmfix_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5DX_entry() //  [R1]
         { info_tbl: [(cg9Rz,
                       label: sat_sg5DX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Rz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9RA; else goto cg9RB;
       cg9RA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9RB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_entry(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadFixProduct_entry() //  [R2, R3]
         { info_tbl: [(cg9RD,
                       label: Data.Functor.Product.$fMonadFixProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9RD: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cg9RH; else goto cg9RG;
       cg9RH: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadFixProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9RG: // global
           I64[Hp - 72] = sat_sg5DY_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sg5DX_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 71;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.115588913 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cmzipWith_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cmzipWith_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cmzipWith_info;
 },
 sat_sg5Eb_entry() //  [R1]
         { info_tbl: [(cg9Se,
                       label: sat_sg5Eb_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Se: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9Sf; else goto cg9Sg;
       cg9Sf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Sg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5Ea_entry() //  [R1]
         { info_tbl: [(cg9Sl,
                       label: sat_sg5Ea_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Sl: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9Sm; else goto cg9Sn;
       cg9Sm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Sn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_$cmzipWith_entry() //  [R2,
                                                                R3, R4, R5, R6]
         { info_tbl: [(cg9So,
                       label: Data.Functor.Product.$fMonadZipProduct_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9So: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9Sq; else goto cg9Sr;
       cg9Sq: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cmzipWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9Sr: // global
           I64[Sp - 40] = block_cg9S0_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9Sx; else goto cg9S1;
       ug9Sx: // global
           call _cg9S0(R1) args: 0, res: 0, upd: 0;
       cg9S1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9S0() //  [R1]
         { info_tbl: [(cg9S0,
                       label: block_cg9S0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9S0: // global
           I64[Sp - 8] = block_cg9S5_info;
           _sg5E5::P64 = P64[R1 + 7];
           _sg5E6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sg5E6::P64;
           P64[Sp + 32] = _sg5E5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug9Sw; else goto cg9S6;
       ug9Sw: // global
           call _cg9S5(R1) args: 0, res: 0, upd: 0;
       cg9S6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9S5() //  [R1]
         { info_tbl: [(cg9S5,
                       label: block_cg9S5_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9S5: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cg9Sv; else goto cg9Su;
       cg9Sv: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9Su: // global
           _sg5E8::P64 = P64[R1 + 7];
           _sg5E9::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sg5Eb_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sg5E1::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sg5E1::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sg5E9::P64;
           I64[Hp - 64] = sat_sg5Ea_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sg5E1::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sg5E8::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.13035644 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_info;
         const 0;
 },
 sat_sg5Ef_entry() //  [R1]
         { info_tbl: [(cg9Te,
                       label: sat_sg5Ef_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Te: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9Tf; else goto cg9Tg;
       cg9Tf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Tg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Ee_entry() //  [R1]
         { info_tbl: [(cg9Tl,
                       label: sat_sg5Ee_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Tl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9Tm; else goto cg9Tn;
       cg9Tm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Tn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cg9To,
                       label: Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9To: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cg9Ts; else goto cg9Tr;
       cg9Ts: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9Tr: // global
           I64[Hp - 40] = sat_sg5Ef_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sg5Ee_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fMonadProduct_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.139177038 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cmzip_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cmzip_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cmzip_info;
 },
 sat_sg5Er_entry() //  [R1]
         { info_tbl: [(cg9TX,
                       label: sat_sg5Er_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9TX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9TY; else goto cg9TZ;
       cg9TY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9TZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sg5Eq_entry() //  [R1]
         { info_tbl: [(cg9U4,
                       label: sat_sg5Eq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9U4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cg9U5; else goto cg9U6;
       cg9U5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9U6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_$cmzip_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cg9U7,
                       label: Data.Functor.Product.$fMonadZipProduct_$cmzip_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9U7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9U9; else goto cg9Ua;
       cg9U9: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cmzip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9Ua: // global
           I64[Sp - 32] = block_cg9TJ_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug9Ug; else goto cg9TK;
       ug9Ug: // global
           call _cg9TJ(R1) args: 0, res: 0, upd: 0;
       cg9TK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9TJ() //  [R1]
         { info_tbl: [(cg9TJ,
                       label: block_cg9TJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9TJ: // global
           I64[Sp - 8] = block_cg9TO_info;
           _sg5El::P64 = P64[R1 + 7];
           _sg5Em::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sg5Em::P64;
           P64[Sp + 24] = _sg5El::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug9Uf; else goto cg9TP;
       ug9Uf: // global
           call _cg9TO(R1) args: 0, res: 0, upd: 0;
       cg9TP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg9TO() //  [R1]
         { info_tbl: [(cg9TO,
                       label: block_cg9TO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9TO: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cg9Ue; else goto cg9Ud;
       cg9Ue: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9Ud: // global
           _sg5Eo::P64 = P64[R1 + 7];
           _sg5Ep::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sg5Er_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sg5Ep::P64;
           I64[Hp - 56] = sat_sg5Eq_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sg5Eo::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.156912116 UTC

[section ""data" . Data.Functor.Product.$w$cmunzip_closure" {
     Data.Functor.Product.$w$cmunzip_closure:
         const Data.Functor.Product.$w$cmunzip_info;
 },
 $dMonad_sg5Ev_entry() //  [R1]
         { info_tbl: [(cg9UV,
                       label: $dMonad_sg5Ev_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9UV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9UW; else goto cg9UX;
       cg9UW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9UX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dMonad1_sg5Ew_entry() //  [R1]
         { info_tbl: [(cg9V2,
                       label: $dMonad1_sg5Ew_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9V2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9V3; else goto cg9V4;
       cg9V3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9V4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sg5F2_entry() //  [R1]
         { info_tbl: [(cg9Vm,
                       label: lvl9_sg5F2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Vm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9Vn; else goto cg9Vo;
       cg9Vn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Vo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5F8_entry() //  [R1, R2]
         { info_tbl: [(cg9Vv,
                       label: sat_sg5F8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Vv: // global
           _sg5F3::P64 = R2;
           _sg5F8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg9Vw; else goto cg9Vx;
       cg9Vx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg9Vz; else goto cg9Vy;
       cg9Vz: // global
           HpAlloc = 24;
           goto cg9Vw;
       cg9Vw: // global
           R2 = _sg5F3::P64;
           R1 = _sg5F8::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg9Vy: // global
           _sg5F2::P64 = P64[_sg5F8::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sg5F3::P64;
           R2 = _sg5F2::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5F9_entry() //  [R1]
         { info_tbl: [(cg9VA,
                       label: sat_sg5F9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9VA: // global
           _sg5F9::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg9VB; else goto cg9VC;
       cg9VC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg9VE; else goto cg9VD;
       cg9VE: // global
           HpAlloc = 40;
           goto cg9VB;
       cg9VB: // global
           R1 = _sg5F9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9VD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5F9::P64;
           _sg5Ew::P64 = P64[_sg5F9::P64 + 16];
           _sg5ET::P64 = P64[_sg5F9::P64 + 24];
           I64[Hp - 32] = lvl9_sg5F2_info;
           P64[Hp - 16] = _sg5Ew::P64;
           I64[Hp - 8] = sat_sg5F8_info;
           P64[Hp] = Hp - 32;
           R2 = _sg5Ew::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5ET::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 lvl9_sg5EU_entry() //  [R1]
         { info_tbl: [(cg9VN,
                       label: lvl9_sg5EU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9VN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9VO; else goto cg9VP;
       cg9VO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9VP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5F0_entry() //  [R1, R2]
         { info_tbl: [(cg9VW,
                       label: sat_sg5F0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9VW: // global
           _sg5EV::P64 = R2;
           _sg5F0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg9VX; else goto cg9VY;
       cg9VY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg9W0; else goto cg9VZ;
       cg9W0: // global
           HpAlloc = 24;
           goto cg9VX;
       cg9VX: // global
           R2 = _sg5EV::P64;
           R1 = _sg5F0::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg9VZ: // global
           _sg5EU::P64 = P64[_sg5F0::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sg5EV::P64;
           R2 = _sg5EU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5F1_entry() //  [R1]
         { info_tbl: [(cg9W1,
                       label: sat_sg5F1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9W1: // global
           _sg5F1::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg9W2; else goto cg9W3;
       cg9W3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg9W5; else goto cg9W4;
       cg9W5: // global
           HpAlloc = 40;
           goto cg9W2;
       cg9W2: // global
           R1 = _sg5F1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9W4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5F1::P64;
           _sg5Ev::P64 = P64[_sg5F1::P64 + 16];
           _sg5ES::P64 = P64[_sg5F1::P64 + 24];
           I64[Hp - 32] = lvl9_sg5EU_info;
           P64[Hp - 16] = _sg5Ev::P64;
           I64[Hp - 8] = sat_sg5F0_info;
           P64[Hp] = Hp - 32;
           R2 = _sg5Ev::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5ES::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5Fa_entry() //  [R1]
         { info_tbl: [(cg9W6,
                       label: sat_sg5Fa_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9W6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9W8; else goto cg9W9;
       cg9W8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9W9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg9V9_info;
           _sg5Ev::P64 = P64[R1 + 24];
           _sg5Ew::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sg5Ev::P64;
           P64[Sp - 24] = _sg5Ew::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9Wd; else goto cg9Va;
       ug9Wd: // global
           call _cg9V9(R1) args: 0, res: 0, upd: 0;
       cg9Va: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg9V9() //  [R1]
         { info_tbl: [(cg9V9,
                       label: block_cg9V9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9V9: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg9Wc; else goto cg9Wb;
       cg9Wc: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg9Wb: // global
           _sg5ES::P64 = P64[R1 + 7];
           _sg5ET::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sg5F9_info;
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = _sg5ET::P64;
           I64[Hp - 48] = sat_sg5F1_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg5ES::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sg5EI_entry() //  [R1]
         { info_tbl: [(cg9Wv,
                       label: lvl9_sg5EI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Wv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9Ww; else goto cg9Wx;
       cg9Ww: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Wx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5EO_entry() //  [R1, R2]
         { info_tbl: [(cg9WE,
                       label: sat_sg5EO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9WE: // global
           _sg5EJ::P64 = R2;
           _sg5EO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg9WF; else goto cg9WG;
       cg9WG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg9WI; else goto cg9WH;
       cg9WI: // global
           HpAlloc = 24;
           goto cg9WF;
       cg9WF: // global
           R2 = _sg5EJ::P64;
           R1 = _sg5EO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg9WH: // global
           _sg5EI::P64 = P64[_sg5EO::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sg5EJ::P64;
           R2 = _sg5EI::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5EP_entry() //  [R1]
         { info_tbl: [(cg9WJ,
                       label: sat_sg5EP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9WJ: // global
           _sg5EP::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg9WK; else goto cg9WL;
       cg9WL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg9WN; else goto cg9WM;
       cg9WN: // global
           HpAlloc = 40;
           goto cg9WK;
       cg9WK: // global
           R1 = _sg5EP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9WM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5EP::P64;
           _sg5Ew::P64 = P64[_sg5EP::P64 + 16];
           _sg5Ez::P64 = P64[_sg5EP::P64 + 24];
           I64[Hp - 32] = lvl9_sg5EI_info;
           P64[Hp - 16] = _sg5Ew::P64;
           I64[Hp - 8] = sat_sg5EO_info;
           P64[Hp] = Hp - 32;
           R2 = _sg5Ew::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5Ez::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 lvl9_sg5EA_entry() //  [R1]
         { info_tbl: [(cg9WW,
                       label: lvl9_sg5EA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9WW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9WX; else goto cg9WY;
       cg9WX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9WY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5EG_entry() //  [R1, R2]
         { info_tbl: [(cg9X5,
                       label: sat_sg5EG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9X5: // global
           _sg5EB::P64 = R2;
           _sg5EG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cg9X6; else goto cg9X7;
       cg9X7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg9X9; else goto cg9X8;
       cg9X9: // global
           HpAlloc = 24;
           goto cg9X6;
       cg9X6: // global
           R2 = _sg5EB::P64;
           R1 = _sg5EG::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg9X8: // global
           _sg5EA::P64 = P64[_sg5EG::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sg5EB::P64;
           R2 = _sg5EA::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5EH_entry() //  [R1]
         { info_tbl: [(cg9Xa,
                       label: sat_sg5EH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Xa: // global
           _sg5EH::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cg9Xb; else goto cg9Xc;
       cg9Xc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cg9Xe; else goto cg9Xd;
       cg9Xe: // global
           HpAlloc = 40;
           goto cg9Xb;
       cg9Xb: // global
           R1 = _sg5EH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Xd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5EH::P64;
           _sg5Ev::P64 = P64[_sg5EH::P64 + 16];
           _sg5Ey::P64 = P64[_sg5EH::P64 + 24];
           I64[Hp - 32] = lvl9_sg5EA_info;
           P64[Hp - 16] = _sg5Ev::P64;
           I64[Hp - 8] = sat_sg5EG_info;
           P64[Hp] = Hp - 32;
           R2 = _sg5Ev::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5Ey::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5EQ_entry() //  [R1]
         { info_tbl: [(cg9Xf,
                       label: sat_sg5EQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Xf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9Xh; else goto cg9Xi;
       cg9Xh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9Xi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg9Wi_info;
           _sg5Ev::P64 = P64[R1 + 24];
           _sg5Ew::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sg5Ev::P64;
           P64[Sp - 24] = _sg5Ew::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9Xm; else goto cg9Wj;
       ug9Xm: // global
           call _cg9Wi(R1) args: 0, res: 0, upd: 0;
       cg9Wj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cg9Wi() //  [R1]
         { info_tbl: [(cg9Wi,
                       label: block_cg9Wi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Wi: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cg9Xl; else goto cg9Xk;
       cg9Xl: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cg9Xk: // global
           _sg5Ey::P64 = P64[R1 + 7];
           _sg5Ez::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sg5EP_info;
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = _sg5Ez::P64;
           I64[Hp - 48] = sat_sg5EH_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg5Ey::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cmunzip_entry() //  [R2, R3, R4]
         { info_tbl: [(cg9Xn,
                       label: Data.Functor.Product.$w$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Xn: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cg9Xr; else goto cg9Xq;
       cg9Xr: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9Xq: // global
           I64[Hp - 120] = $dMonad_sg5Ev_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = $dMonad1_sg5Ew_info;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_sg5Fa_info;
           P64[Hp - 56] = R4;
           _cg9UR::P64 = Hp - 120;
           P64[Hp - 48] = _cg9UR::P64;
           _cg9UY::P64 = Hp - 96;
           P64[Hp - 40] = _cg9UY::P64;
           I64[Hp - 32] = sat_sg5EQ_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _cg9UR::P64;
           P64[Hp] = _cg9UY::P64;
           R2 = Hp - 72;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.200933489 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cmunzip_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cmunzip_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cmunzip_info;
 },
 Data.Functor.Product.$fMonadZipProduct_$cmunzip_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cg9Za,
                       label: Data.Functor.Product.$fMonadZipProduct_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Za: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg9Zb; else goto cg9Zc;
       cg9Zb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9Zc: // global
           I64[Sp - 8] = block_cg9Z7_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Functor.Product.$w$cmunzip_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg9Z7() //  [R1, R2]
         { info_tbl: [(cg9Z7,
                       label: block_cg9Z7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Z7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cg9Zf; else goto cg9Ze;
       cg9Zf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cg9Ze: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.207529915 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_closure" {
     Data.Functor.Product.$fMonadZipProduct_closure:
         const Data.Functor.Product.$fMonadZipProduct_info;
         const 0;
 },
 sat_sg5Fm_entry() //  [R1, R2]
         { info_tbl: [(cg9Zy,
                       label: sat_sg5Fm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9Zy: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fMonadZipProduct_$cmunzip_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Fl_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cg9ZG,
                       label: sat_sg5Fl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ZG: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fMonadZipProduct_$cmzipWith_entry(R6,
                                                                        R5,
                                                                        R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Fk_entry() //  [R1, R2, R3]
         { info_tbl: [(cg9ZO,
                       label: sat_sg5Fk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ZO: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadZipProduct_$cmzip_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Fj_entry() //  [R1]
         { info_tbl: [(cg9ZV,
                       label: sat_sg5Fj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ZV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg9ZW; else goto cg9ZX;
       cg9ZW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9ZX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_entry(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_entry() //  [R2, R3]
         { info_tbl: [(cg9ZZ,
                       label: Data.Functor.Product.$fMonadZipProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9ZZ: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cga03; else goto cga02;
       cga03: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cga02: // global
           I64[Hp - 136] = sat_sg5Fm_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sg5Fl_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sg5Fk_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sg5Fj_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 86;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = Hp - 135;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.220117894 UTC

[section ""data" . Data.Functor.Product.$fGeneric1Product_$cto1_closure" {
     Data.Functor.Product.$fGeneric1Product_$cto1_closure:
         const Data.Functor.Product.$fGeneric1Product_$cto1_info;
 },
 Data.Functor.Product.$fGeneric1Product_$cto1_entry() //  [R2]
         { info_tbl: [(cga0w,
                       label: Data.Functor.Product.$fGeneric1Product_$cto1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga0w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cga0A; else goto cga0B;
       cga0A: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGeneric1Product_$cto1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cga0B: // global
           I64[Sp - 8] = block_cga0u_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cga0u() //  [R1]
         { info_tbl: [(cga0u,
                       label: block_cga0u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga0u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cga0E; else goto cga0D;
       cga0E: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cga0D: // global
           _sg5Fp::P64 = P64[R1 + 7];
           _sg5Fq::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = _sg5Fp::P64;
           P64[Hp] = _sg5Fq::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.226681188 UTC

[section ""data" . Data.Functor.Product.$fGeneric1Product1_closure" {
     Data.Functor.Product.$fGeneric1Product1_closure:
         const Data.Functor.Product.$fGeneric1Product1_info;
 },
 Data.Functor.Product.$fGeneric1Product1_entry() //  [R2]
         { info_tbl: [(cga0V,
                       label: Data.Functor.Product.$fGeneric1Product1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga0V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cga0Z; else goto cga10;
       cga0Z: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGeneric1Product1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cga10: // global
           I64[Sp - 8] = block_cga0S_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uga14; else goto cga0T;
       uga14: // global
           call _cga0S(R1) args: 0, res: 0, upd: 0;
       cga0T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cga0S() //  [R1]
         { info_tbl: [(cga0S,
                       label: block_cga0S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga0S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cga13; else goto cga12;
       cga13: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cga12: // global
           _sg5Ft::P64 = P64[R1 + 7];
           _sg5Fu::P64 = P64[R1 + 15];
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = _sg5Ft::P64;
           P64[Hp] = _sg5Fu::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.23251737 UTC

[section ""data" . Data.Functor.Product.$fGeneric1Product_closure" {
     Data.Functor.Product.$fGeneric1Product_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Product.$fGeneric1Product1_closure+1;
         const Data.Functor.Product.$fGeneric1Product_$cto1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.234944088 UTC

[section ""data" . Data.Functor.Product.$fGenericProduct_$cto_closure" {
     Data.Functor.Product.$fGenericProduct_$cto_closure:
         const Data.Functor.Product.$fGenericProduct_$cto_info;
 },
 Data.Functor.Product.$fGenericProduct_$cto_entry() //  [R2]
         { info_tbl: [(cga1m,
                       label: Data.Functor.Product.$fGenericProduct_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga1m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cga1q; else goto cga1r;
       cga1q: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGenericProduct_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cga1r: // global
           I64[Sp - 8] = block_cga1k_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cga1k() //  [R1]
         { info_tbl: [(cga1k,
                       label: block_cga1k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga1k: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cga1u; else goto cga1t;
       cga1u: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cga1t: // global
           _sg5Fx::P64 = P64[R1 + 7];
           _sg5Fy::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = _sg5Fx::P64;
           P64[Hp] = _sg5Fy::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.241290297 UTC

[section ""data" . Data.Functor.Product.$fGenericProduct1_closure" {
     Data.Functor.Product.$fGenericProduct1_closure:
         const Data.Functor.Product.$fGenericProduct1_info;
 },
 Data.Functor.Product.$fGenericProduct1_entry() //  [R2]
         { info_tbl: [(cga1L,
                       label: Data.Functor.Product.$fGenericProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga1L: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cga1P; else goto cga1Q;
       cga1P: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGenericProduct1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cga1Q: // global
           I64[Sp - 8] = block_cga1I_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uga1U; else goto cga1J;
       uga1U: // global
           call _cga1I(R1) args: 0, res: 0, upd: 0;
       cga1J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cga1I() //  [R1]
         { info_tbl: [(cga1I,
                       label: block_cga1I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga1I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cga1T; else goto cga1S;
       cga1T: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cga1S: // global
           _sg5FB::P64 = P64[R1 + 7];
           _sg5FC::P64 = P64[R1 + 15];
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = _sg5FB::P64;
           P64[Hp] = _sg5FC::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.247627294 UTC

[section ""data" . Data.Functor.Product.$fGenericProduct_closure" {
     Data.Functor.Product.$fGenericProduct_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Product.$fGenericProduct1_closure+1;
         const Data.Functor.Product.$fGenericProduct_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.251332894 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgfoldl_closure" {
     Data.Functor.Product.$fDataProduct_$cgfoldl_closure:
         const Data.Functor.Product.$fDataProduct_$cgfoldl_info;
 },
 Data.Functor.Product.$fDataProduct_$cgfoldl_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga27: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgfoldl_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg5FP_entry() //  [R1]
         { info_tbl: [(cga2o,
                       label: sat_sg5FP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga2o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cga2p; else goto cga2q;
       cga2p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cga2q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Product.Pair_closure+2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5FQ_entry() //  [R1]
         { info_tbl: [(cga2r,
                       label: sat_sg5FQ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga2r: // global
           _sg5FQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cga2s; else goto cga2t;
       cga2t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cga2v; else goto cga2u;
       cga2v: // global
           HpAlloc = 24;
           goto cga2s;
       cga2s: // global
           R1 = _sg5FQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cga2u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5FQ::P64;
           _sg5FH::P64 = P64[_sg5FQ::P64 + 16];
           _sg5FJ::P64 = P64[_sg5FQ::P64 + 24];
           _sg5FK::P64 = P64[_sg5FQ::P64 + 32];
           _sg5FN::P64 = P64[_sg5FQ::P64 + 40];
           I64[Hp - 16] = sat_sg5FP_info;
           P64[Hp] = _sg5FK::P64;
           R4 = _sg5FN::P64;
           R3 = Hp - 16;
           R2 = _sg5FH::P64;
           R1 = _sg5FJ::P64;
           Sp = Sp - 16;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgfoldl_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cga2w,
                       label: Data.Functor.Product.$fDataProduct_$cgfoldl_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga2w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cga2x; else goto cga2y;
       cga2x: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgfoldl_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cga2y: // global
           I64[Sp - 8] = block_cga2b_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uga2C; else goto cga2c;
       uga2C: // global
           call _cga2b(R1) args: 0, res: 0, upd: 0;
       cga2c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cga2b() //  [R1]
         { info_tbl: [(cga2b,
                       label: block_cga2b_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga2b: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cga2B; else goto cga2A;
       cga2B: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cga2A: // global
           _sg5FN::P64 = P64[R1 + 7];
           _sg5FO::P64 = P64[R1 + 15];
           I64[Hp - 40] = sat_sg5FQ_info;
           P64[Hp - 24] = P64[Sp + 32];
           _sg5FJ::P64 = P64[Sp + 16];
           P64[Hp - 16] = _sg5FJ::P64;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sg5FN::P64;
           R4 = _sg5FO::P64;
           R3 = Hp - 40;
           R2 = P64[Sp + 8];
           R1 = _sg5FJ::P64;
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.262881452 UTC

[section ""cstring" . Data.Functor.Product.$fDataProduct6_bytes" {
     Data.Functor.Product.$fDataProduct6_bytes:
         I8[] [80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.265141508 UTC

[section ""data" . Data.Functor.Product.$fDataProduct5_closure" {
     Data.Functor.Product.$fDataProduct5_closure:
         const Data.Functor.Product.$fDataProduct5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fDataProduct5_entry() //  [R1]
         { info_tbl: [(cga35,
                       label: Data.Functor.Product.$fDataProduct5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga35: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cga36; else goto cga37;
       cga36: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cga37: // global
           (_cga32::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cga32::I64 == 0) goto cga34; else goto cga33;
       cga34: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cga33: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cga32::I64;
           R2 = Data.Functor.Product.$fDataProduct6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.270638255 UTC

[section ""data" . go61_rg5o2_closure" {
     go61_rg5o2_closure:
         const go61_rg5o2_info;
         const 0;
 },
 go61_rg5o2_entry() //  [R2, R3]
         { info_tbl: [(cga3q,
                       label: go61_rg5o2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga3q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cga3r; else goto uga44;
       cga3r: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rg5o2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uga44: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cga3g() args: 0, res: 0, upd: 0;
     }
 },
 _cga3g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga3g: // global
           _sg5FR::P64 = P64[Sp];
           I64[Sp] = block_cga3j_info;
           R1 = _sg5FR::P64;
           if (R1 & 7 != 0) goto uga48; else goto cga3k;
       uga48: // global
           call _cga3j(R1) args: 0, res: 0, upd: 0;
       cga3k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cga3j() //  [R1]
         { info_tbl: [(cga3j,
                       label: block_cga3j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga3j: // global
           if (R1 & 7 == 1) goto uga45; else goto cga3o;
       uga45: // global
           Sp = Sp + 16;
           call _cga3G() args: 0, res: 0, upd: 0;
       cga3o: // global
           I64[Sp - 8] = block_cga3y_info;
           _sg5FU::P64 = P64[R1 + 6];
           _sg5FV::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sg5FV::P64;
           P64[Sp + 8] = _sg5FU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uga49; else goto cga3A;
       uga49: // global
           call _cga3y(R1) args: 0, res: 0, upd: 0;
       cga3A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cga3y() //  [R1]
         { info_tbl: [(cga3y,
                       label: block_cga3y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga3y: // global
           if (R1 & 7 == 1) goto uga46; else goto cga3L;
       uga46: // global
           Sp = Sp + 24;
           call _cga3G() args: 0, res: 0, upd: 0;
       cga3L: // global
           I64[Sp - 8] = block_cga3J_info;
           _sg5FX::P64 = P64[R1 + 6];
           _sg5FY::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sg5FY::P64;
           P64[Sp + 16] = _sg5FX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uga4c; else goto cga3M;
       uga4c: // global
           call _cga3J(R1) args: 0, res: 0, upd: 0;
       cga3M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cga3G() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga3G: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cga3J() //  [R1]
         { info_tbl: [(cga3J,
                       label: block_cga3J_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga3J: // global
           I64[Sp] = block_cga3Q_info;
           R3 = Data.Functor.Product.$fRead1Product2_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cga3Q() //  [R1]
         { info_tbl: [(cga3Q,
                       label: block_cga3Q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga3Q: // global
           if (R1 & 7 == 1) goto cga3X; else goto cga41;
       cga3X: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cga3g() args: 0, res: 0, upd: 0;
       cga41: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.284807512 UTC

[section ""data" . $cPair1_rg5o3_closure" {
     $cPair1_rg5o3_closure:
         const Data.Data.AlgConstr_con_info;
         const $cPair2_rg5o4_closure;
         const 0;
 },
 section ""data" . Data.Functor.Product.$fDataProduct4_closure" {
     Data.Functor.Product.$fDataProduct4_closure:
         const :_con_info;
         const Data.Functor.Product.$cPair_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Product.$fDataProduct3_closure" {
     Data.Functor.Product.$fDataProduct3_closure:
         const Data.Data.AlgRep_con_info;
         const Data.Functor.Product.$fDataProduct4_closure+2;
         const 0;
 },
 section ""data" . Data.Functor.Product.$tProduct_closure" {
     Data.Functor.Product.$tProduct_closure:
         const Data.Data.DataType_con_info;
         const Data.Functor.Product.$fDataProduct5_closure;
         const Data.Functor.Product.$fDataProduct3_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Product.$cPair_closure" {
     Data.Functor.Product.$cPair_closure:
         const Data.Data.Constr_con_info;
         const $cPair1_rg5o3_closure+1;
         const Data.Functor.Product.$fRead1Product2_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Product.$tProduct_closure+1;
         const 0;
 },
 section ""data" . $cPair2_rg5o4_closure" {
     $cPair2_rg5o4_closure:
         const $cPair2_rg5o4_info;
         const 0;
         const 0;
         const 0;
 },
 $cPair2_rg5o4_entry() //  [R1]
         { info_tbl: [(cga4T,
                       label: $cPair2_rg5o4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga4T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cga4U; else goto cga4V;
       cga4U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cga4V: // global
           (_cga4Q::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cga4Q::I64 == 0) goto cga4S; else goto cga4R;
       cga4S: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cga4R: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cga4Q::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = Data.Functor.Product.$fDataProduct4_closure+2;
           Sp = Sp - 16;
           call go61_rg5o2_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.292622752 UTC

[section ""cstring" . Data.Functor.Product.$trModule4_bytes" {
     Data.Functor.Product.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.294449967 UTC

[section ""data" . Data.Functor.Product.$trModule3_closure" {
     Data.Functor.Product.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.296337963 UTC

[section ""cstring" . Data.Functor.Product.$trModule2_bytes" {
     Data.Functor.Product.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.29906009 UTC

[section ""data" . Data.Functor.Product.$trModule1_closure" {
     Data.Functor.Product.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.300766352 UTC

[section ""data" . Data.Functor.Product.$trModule_closure" {
     Data.Functor.Product.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Product.$trModule3_closure+1;
         const Data.Functor.Product.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.302564166 UTC

[section ""data" . $krep_rg5o5_closure" {
     $krep_rg5o5_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.304189369 UTC

[section ""data" . $krep1_rg5o6_closure" {
     $krep1_rg5o6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rg5o5_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.306016608 UTC

[section ""data" . $krep2_rg5o7_closure" {
     $krep2_rg5o7_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rg5o6_closure+4;
         const $krep1_rg5o6_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.307824226 UTC

[section ""data" . Data.Functor.Product.$fDataProduct8_closure" {
     Data.Functor.Product.$fDataProduct8_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rg5o6_closure+4;
         const $krep2_rg5o7_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.309637394 UTC

[section ""data" . $krep3_rg5o8_closure" {
     $krep3_rg5o8_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.311420957 UTC

[section ""data" . $krep4_rg5o9_closure" {
     $krep4_rg5o9_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.31311935 UTC

[section ""data" . $krep5_rg5oa_closure" {
     $krep5_rg5oa_closure:
         const GHC.Types.KindRepVar_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.31490497 UTC

[section ""data" . $krep6_rg5ob_closure" {
     $krep6_rg5ob_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rg5o9_closure+2;
         const $krep5_rg5oa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.316732519 UTC

[section ""data" . $krep7_rg5oc_closure" {
     $krep7_rg5oc_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep3_rg5o8_closure+2;
         const $krep5_rg5oa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.319145375 UTC

[section ""data" . Data.Functor.Product.$fDataProduct9_closure" {
     Data.Functor.Product.$fDataProduct9_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$fDataProduct6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.321031591 UTC

[section ""data" . Data.Functor.Product.$tcProduct_closure" {
     Data.Functor.Product.$tcProduct_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Product.$trModule_closure+1;
         const Data.Functor.Product.$fDataProduct9_closure+1;
         const Data.Functor.Product.$fDataProduct8_closure+4;
         const 9904636435990105341;
         const 16069493191308336164;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.323620436 UTC

[section ""data" . $krep8_rg5od_closure" {
     $krep8_rg5od_closure:
         const :_con_info;
         const $krep5_rg5oa_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.325484245 UTC

[section ""data" . $krep9_rg5oe_closure" {
     $krep9_rg5oe_closure:
         const :_con_info;
         const $krep3_rg5o8_closure+2;
         const $krep8_rg5od_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.327124859 UTC

[section ""data" . $krep10_rg5of_closure" {
     $krep10_rg5of_closure:
         const :_con_info;
         const $krep4_rg5o9_closure+2;
         const $krep9_rg5oe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.328919084 UTC

[section ""data" . $krep11_rg5og_closure" {
     $krep11_rg5og_closure:
         const :_con_info;
         const $krep_rg5o5_closure+2;
         const $krep10_rg5of_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.330754101 UTC

[section ""data" . $krep12_rg5oh_closure" {
     $krep12_rg5oh_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Product.$tcProduct_closure+1;
         const $krep11_rg5og_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.332501038 UTC

[section ""data" . $krep13_rg5oi_closure" {
     $krep13_rg5oi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rg5oc_closure+3;
         const $krep12_rg5oh_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.334151081 UTC

[section ""data" . Data.Functor.Product.$tc'Pair1_closure" {
     Data.Functor.Product.$tc'Pair1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rg5ob_closure+3;
         const $krep13_rg5oi_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.335969735 UTC

[section ""cstring" . Data.Functor.Product.$tc'Pair3_bytes" {
     Data.Functor.Product.$tc'Pair3_bytes:
         I8[] [39,80,97,105,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.338317837 UTC

[section ""data" . Data.Functor.Product.$tc'Pair2_closure" {
     Data.Functor.Product.$tc'Pair2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$tc'Pair3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.340143288 UTC

[section ""data" . Data.Functor.Product.$tc'Pair_closure" {
     Data.Functor.Product.$tc'Pair_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Product.$trModule_closure+1;
         const Data.Functor.Product.$tc'Pair2_closure+1;
         const Data.Functor.Product.$tc'Pair1_closure+4;
         const 11374113252541295849;
         const 18011678063065699923;
         const 4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.342932421 UTC

[section ""data" . Data.Functor.Product.$w$cp1Data_closure" {
     Data.Functor.Product.$w$cp1Data_closure:
         const Data.Functor.Product.$w$cp1Data_info;
         const 0;
 },
 Data.Functor.Product.$w$cp1Data_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cga5L,
                       label: Data.Functor.Product.$w$cp1Data_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga5L: // global
           _sg5G9::P64 = R5;
           _sg5G8::P64 = R4;
           _sg5G7::P64 = R3;
           _sg5G6::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cga5P; else goto cga5Q;
       cga5Q: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cga5S; else goto cga5R;
       cga5S: // global
           HpAlloc = 40;
           goto cga5P;
       cga5P: // global
           R5 = _sg5G9::P64;
           R4 = _sg5G8::P64;
           R3 = _sg5G7::P64;
           R2 = _sg5G6::P64;
           R1 = Data.Functor.Product.$w$cp1Data_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cga5R: // global
           I64[Hp - 32] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 24] = _sg5G9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 32] = block_cga5E_info;
           R6 = 1;
           R5 = Data.Functor.Product.$fDataProduct9_closure+1;
           R4 = Data.Functor.Product.$trModule_closure+1;
           R3 = 16069493191308336164;
           R2 = 9904636435990105341;
           P64[Sp - 48] = Data.Functor.Product.$fDataProduct8_closure+4;
           P64[Sp - 40] = Hp - 14;
           P64[Sp - 24] = _sg5G6::P64;
           P64[Sp - 16] = _sg5G7::P64;
           P64[Sp - 8] = _sg5G8::P64;
           Sp = Sp - 48;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 8;
     }
 },
 _cga5E() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cga5E,
                       label: block_cga5E_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga5E: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cga5F() args: 0, res: 0, upd: 0;
     }
 },
 _cga5F() //  []
         { info_tbl: [(cga5F,
                       label: block_cga5F_info
                       rep:StackRep [True, False, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga5F: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cga5V; else goto cga5U;
       cga5V: // global
           HpAlloc = 48;
           I64[Sp] = block_cga5F_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cga5U: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 40] = block_cga5J_info;
           R3 = P64[Sp + 56];
           R2 = Hp - 38;
           Sp = Sp + 40;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cga5J() //  [R1]
         { info_tbl: [(cga5J,
                       label: block_cga5J_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga5J: // global
           I64[Sp] = block_cga5O_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cga5O() //  [R1]
         { info_tbl: [(cga5O,
                       label: block_cga5O_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga5O: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.356078424 UTC

[section ""data" . Data.Functor.Product.$fDataProduct7_closure" {
     Data.Functor.Product.$fDataProduct7_closure:
         const Data.Functor.Product.$fDataProduct7_info;
         const 0;
 },
 Data.Functor.Product.$fDataProduct7_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cga6v,
                       label: Data.Functor.Product.$fDataProduct7_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga6v: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Product.$w$cp1Data_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.360369742 UTC

[section ""data" . Data.Functor.Product.$fDataProduct1_closure" {
     Data.Functor.Product.$fDataProduct1_closure:
         const (,)_con_info;
         const Data.Functor.Product.Pair_closure+2;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.364970457 UTC

[section ""data" . Data.Functor.Product.$w$cgmapMp_closure" {
     Data.Functor.Product.$w$cgmapMp_closure:
         const Data.Functor.Product.$w$cgmapMp_info;
 },
 lvl9_sg5Gw_entry() //  [R1]
         { info_tbl: [(cga6L,
                       label: lvl9_sg5Gw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga6L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cga6M; else goto cga6N;
       cga6M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cga6N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5H1_entry() //  [R1, R2]
         { info_tbl: [(cga70,
                       label: sat_sg5H1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga70: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cga71; else goto cga72;
       cga71: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cga72: // global
           I64[Sp - 24] = block_cga6X_info;
           _sg5Gw::P64 = P64[R1 + 7];
           _sg5Gx::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sg5Gw::P64;
           P64[Sp - 8] = _sg5Gx::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uga7k; else goto cga6Y;
       uga7k: // global
           call _cga6X(R1) args: 0, res: 0, upd: 0;
       cga6Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cga6X() //  [R1]
         { info_tbl: [(cga6X,
                       label: block_cga6X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga6X: // global
           I64[Sp - 8] = block_cga75_info;
           _sg5GY::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sg5GY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uga7j; else goto cga77;
       uga7j: // global
           call _cga75(R1) args: 0, res: 0, upd: 0;
       cga77: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cga75() //  [R1]
         { info_tbl: [(cga75,
                       label: block_cga75_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga75: // global
           if (R1 & 7 == 1) goto cga7d; else goto cga7h;
       cga7d: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cga7h: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5GR_entry() //  [R1]
         { info_tbl: [(cga7Q,
                       label: sat_sg5GR_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga7Q: // global
           _sg5GR::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cga7R; else goto cga7S;
       cga7S: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cga7U; else goto cga7T;
       cga7U: // global
           HpAlloc = 56;
           goto cga7R;
       cga7R: // global
           R1 = _sg5GR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cga7T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5GR::P64;
           _sg5Gx::P64 = P64[_sg5GR::P64 + 16];
           _sg5GE::P64 = P64[_sg5GR::P64 + 24];
           _sg5GI::P64 = P64[_sg5GR::P64 + 32];
           _sg5GJ::P64 = P64[_sg5GR::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5GI::P64;
           P64[Hp - 24] = _sg5GE::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sg5GJ::P64;
           R2 = _sg5Gx::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5GN_entry() //  [R1, R2]
         { info_tbl: [(cga86,
                       label: sat_sg5GN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga86: // global
           _sg5GK::P64 = R2;
           _sg5GN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cga87; else goto cga88;
       cga88: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cga8a; else goto cga89;
       cga8a: // global
           HpAlloc = 56;
           goto cga87;
       cga87: // global
           R2 = _sg5GK::P64;
           R1 = _sg5GN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cga89: // global
           _sg5Gx::P64 = P64[_sg5GN::P64 + 7];
           _sg5GI::P64 = P64[_sg5GN::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5GI::P64;
           P64[Hp - 24] = _sg5GK::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sg5Gx::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5GO_entry() //  [R1]
         { info_tbl: [(cga8b,
                       label: sat_sg5GO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga8b: // global
           _sg5GO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cga8c; else goto cga8d;
       cga8d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cga8f; else goto cga8e;
       cga8f: // global
           HpAlloc = 24;
           goto cga8c;
       cga8c: // global
           R1 = _sg5GO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cga8e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5GO::P64;
           _sg5Gx::P64 = P64[_sg5GO::P64 + 16];
           _sg5GF::P64 = P64[_sg5GO::P64 + 24];
           _sg5GI::P64 = P64[_sg5GO::P64 + 32];
           I64[Hp - 16] = sat_sg5GN_info;
           P64[Hp - 8] = _sg5Gx::P64;
           P64[Hp] = _sg5GI::P64;
           R2 = _sg5Gx::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5GF::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5GS_entry() //  [R1, R2]
         { info_tbl: [(cga8g,
                       label: sat_sg5GS_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga8g: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cga8h; else goto cga8i;
       cga8h: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cga8i: // global
           I64[Sp - 40] = block_cga7F_info;
           _sg5Gt::P64 = P64[R1 + 7];
           _sg5Gx::P64 = P64[R1 + 15];
           _sg5GE::P64 = P64[R1 + 23];
           _sg5GF::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5Gt::P64;
           P64[Sp - 24] = _sg5Gx::P64;
           P64[Sp - 16] = _sg5GE::P64;
           P64[Sp - 8] = _sg5GF::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uga8m; else goto cga7G;
       uga8m: // global
           call _cga7F(R1) args: 0, res: 0, upd: 0;
       cga7G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cga7F() //  [R1]
         { info_tbl: [(cga7F,
                       label: block_cga7F_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga7F: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cga8l; else goto cga8k;
       cga8l: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cga8k: // global
           _sg5GI::P64 = P64[R1 + 7];
           _sg5GJ::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sg5GR_info;
           _sg5Gx::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sg5Gx::P64;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _sg5GI::P64;
           P64[Hp - 40] = _sg5GJ::P64;
           I64[Hp - 32] = sat_sg5GO_info;
           P64[Hp - 16] = _sg5Gx::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sg5GI::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sg5GB_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cga8n,
                       label: k1_sg5GB_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga8n: // global
           _sg5GE::P64 = R4;
           _sg5GD::P64 = R3;
           _sg5GC::P64 = R2;
           _sg5GB::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cga8o; else goto cga8p;
       cga8p: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cga8r; else goto cga8q;
       cga8r: // global
           HpAlloc = 80;
           goto cga8o;
       cga8o: // global
           R4 = _sg5GE::P64;
           R3 = _sg5GD::P64;
           R2 = _sg5GC::P64;
           R1 = _sg5GB::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cga8q: // global
           _sg5Gt::P64 = P64[_sg5GB::P64 + 5];
           _sg5Gu::P64 = P64[_sg5GB::P64 + 13];
           _sg5Gx::P64 = P64[_sg5GB::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sg5Gu::P64;
           P64[Hp - 48] = _sg5GC::P64;
           P64[Hp - 40] = _sg5GE::P64;
           I64[Hp - 32] = sat_sg5GS_info;
           P64[Hp - 24] = _sg5Gt::P64;
           P64[Hp - 16] = _sg5Gx::P64;
           P64[Hp - 8] = _sg5GE::P64;
           P64[Hp] = Hp - 72;
           R2 = _sg5Gx::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg5GD::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5GT_entry() //  [R1]
         { info_tbl: [(cga8A,
                       label: sat_sg5GT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga8A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cga8B; else goto cga8C;
       cga8B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cga8C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Product.$fDataProduct1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5GU_entry() //  [R1]
         { info_tbl: [(cga8D,
                       label: sat_sg5GU_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga8D: // global
           _sg5GU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cga8E; else goto cga8F;
       cga8F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cga8H; else goto cga8G;
       cga8H: // global
           HpAlloc = 24;
           goto cga8E;
       cga8E: // global
           R1 = _sg5GU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cga8G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5GU::P64;
           _sg5Gr::P64 = P64[_sg5GU::P64 + 16];
           _sg5Gx::P64 = P64[_sg5GU::P64 + 24];
           _sg5Gz::P64 = P64[_sg5GU::P64 + 32];
           _sg5GB::P64 = P64[_sg5GU::P64 + 40];
           I64[Hp - 16] = sat_sg5GT_info;
           P64[Hp] = _sg5Gx::P64;
           R4 = _sg5Gz::P64;
           R3 = Hp - 16;
           R2 = _sg5Gr::P64;
           R1 = _sg5GB::P64;
           Sp = Sp - 16;
           call k1_sg5GB_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5GV_entry() //  [R1]
         { info_tbl: [(cga8I,
                       label: sat_sg5GV_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga8I: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cga8J; else goto cga8K;
       cga8J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cga8K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cga7p_info;
           _sg5Gr::P64 = P64[R1 + 16];
           _sg5Gs::P64 = P64[R1 + 24];
           _sg5Gt::P64 = P64[R1 + 32];
           _sg5Gu::P64 = P64[R1 + 40];
           _sg5Gx::P64 = P64[R1 + 56];
           R1 = P64[R1 + 48];
           P64[Sp - 56] = _sg5Gr::P64;
           P64[Sp - 48] = _sg5Gs::P64;
           P64[Sp - 40] = _sg5Gt::P64;
           P64[Sp - 32] = _sg5Gu::P64;
           P64[Sp - 24] = _sg5Gx::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto uga8O; else goto cga7q;
       uga8O: // global
           call _cga7p(R1) args: 0, res: 0, upd: 0;
       cga7q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cga7p() //  [R1]
         { info_tbl: [(cga7p,
                       label: block_cga7p_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga7p: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cga8N; else goto cga8M;
       cga8N: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cga8M: // global
           _sg5Gz::P64 = P64[R1 + 7];
           _sg5GA::P64 = P64[R1 + 15];
           I64[Hp - 72] = k1_sg5GB_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = P64[Sp + 32];
           _sg5Gx::P64 = P64[Sp + 40];
           P64[Hp - 48] = _sg5Gx::P64;
           I64[Hp - 40] = sat_sg5GU_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sg5Gx::P64;
           P64[Hp - 8] = _sg5Gz::P64;
           _cga7u::P64 = Hp - 69;
           P64[Hp] = _cga7u::P64;
           R4 = _sg5GA::P64;
           R3 = Hp - 40;
           R2 = P64[Sp + 16];
           R1 = _cga7u::P64;
           Sp = Sp + 48;
           call k1_sg5GB_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cgmapMp_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cga8P,
                       label: Data.Functor.Product.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga8P: // global
           _sg5Gv::P64 = R6;
           _sg5Gu::P64 = R5;
           _sg5Gt::P64 = R4;
           _sg5Gs::P64 = R3;
           _sg5Gr::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cga8Q; else goto cga8R;
       cga8R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cga8T; else goto cga8S;
       cga8T: // global
           HpAlloc = 24;
           goto cga8Q;
       cga8Q: // global
           R6 = _sg5Gv::P64;
           R5 = _sg5Gu::P64;
           R4 = _sg5Gt::P64;
           R3 = _sg5Gs::P64;
           R2 = _sg5Gr::P64;
           R1 = Data.Functor.Product.$w$cgmapMp_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cga8S: // global
           I64[Hp - 16] = lvl9_sg5Gw_info;
           P64[Hp] = _sg5Gt::P64;
           I64[Sp - 56] = block_cga6O_info;
           R2 = _sg5Gt::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sg5Gr::P64;
           P64[Sp - 32] = _sg5Gs::P64;
           P64[Sp - 24] = _sg5Gt::P64;
           P64[Sp - 16] = _sg5Gu::P64;
           P64[Sp - 8] = _sg5Gv::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cga6O() //  [R1]
         { info_tbl: [(cga6O,
                       label: block_cga6O_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cga6O: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cga8W; else goto cga8V;
       cga8W: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cga8V: // global
           I64[Hp - 80] = sat_sg5H1_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sg5GV_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.405695358 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapMp_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapMp_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapMp_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapMp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaaq: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapMp_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapMp_entry() //  [R6]
         { info_tbl: [(cgaau,
                       label: Data.Functor.Product.$fDataProduct_$cgmapMp_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaau: // global
           _sg5H6::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sg5H6::P64;
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cgmapMp_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.411541065 UTC

[section ""data" . Data.Functor.Product.$w$cgmapM_closure" {
     Data.Functor.Product.$w$cgmapM_closure:
         const Data.Functor.Product.$w$cgmapM_info;
 },
 sat_sg5Hp_entry() //  [R1, R2]
         { info_tbl: [(cgaaY,
                       label: sat_sg5Hp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaaY: // global
           _sg5Hn::P64 = R2;
           _sg5Hp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgaaZ; else goto cgab0;
       cgab0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgab2; else goto cgab1;
       cgab2: // global
           HpAlloc = 32;
           goto cgaaZ;
       cgaaZ: // global
           R2 = _sg5Hn::P64;
           R1 = _sg5Hp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgab1: // global
           _sg5Hd::P64 = P64[_sg5Hp::P64 + 7];
           _sg5Hm::P64 = P64[_sg5Hp::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sg5Hm::P64;
           P64[Hp] = _sg5Hn::P64;
           R2 = _sg5Hd::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5Hq_entry() //  [R1, R2]
         { info_tbl: [(cgab3,
                       label: sat_sg5Hq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgab3: // global
           _sg5Hm::P64 = R2;
           _sg5Hq::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgab4; else goto cgab5;
       cgab5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgab7; else goto cgab6;
       cgab7: // global
           HpAlloc = 24;
           goto cgab4;
       cgab4: // global
           R2 = _sg5Hm::P64;
           R1 = _sg5Hq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgab6: // global
           _sg5Hd::P64 = P64[_sg5Hq::P64 + 7];
           _sg5Hl::P64 = P64[_sg5Hq::P64 + 15];
           I64[Hp - 16] = sat_sg5Hp_info;
           P64[Hp - 8] = _sg5Hd::P64;
           P64[Hp] = _sg5Hm::P64;
           R2 = _sg5Hd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg5Hl::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sg5Hh_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgab8,
                       label: k1_sg5Hh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgab8: // global
           _sg5Hk::P64 = R4;
           _sg5Hj::P64 = R3;
           _sg5Hi::P64 = R2;
           _sg5Hh::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgab9; else goto cgaba;
       cgaba: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgabc; else goto cgabb;
       cgabc: // global
           HpAlloc = 64;
           goto cgab9;
       cgab9: // global
           R4 = _sg5Hk::P64;
           R3 = _sg5Hj::P64;
           R2 = _sg5Hi::P64;
           R1 = _sg5Hh::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgabb: // global
           _sg5Hd::P64 = P64[_sg5Hh::P64 + 5];
           _sg5He::P64 = P64[_sg5Hh::P64 + 13];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sg5He::P64;
           P64[Hp - 32] = _sg5Hi::P64;
           P64[Hp - 24] = _sg5Hk::P64;
           I64[Hp - 16] = sat_sg5Hq_info;
           P64[Hp - 8] = _sg5Hd::P64;
           P64[Hp] = Hp - 56;
           R2 = _sg5Hd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg5Hj::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5Hr_entry() //  [R1]
         { info_tbl: [(cgabl,
                       label: sat_sg5Hr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgabl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgabm; else goto cgabn;
       cgabm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgabn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Product.Pair_closure+2;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5Hs_entry() //  [R1]
         { info_tbl: [(cgabo,
                       label: sat_sg5Hs_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgabo: // global
           _sg5Hs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgabp; else goto cgabq;
       cgabq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgabs; else goto cgabr;
       cgabs: // global
           HpAlloc = 24;
           goto cgabp;
       cgabp: // global
           R1 = _sg5Hs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgabr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Hs::P64;
           _sg5Hb::P64 = P64[_sg5Hs::P64 + 16];
           _sg5Hd::P64 = P64[_sg5Hs::P64 + 24];
           _sg5Hf::P64 = P64[_sg5Hs::P64 + 32];
           _sg5Hh::P64 = P64[_sg5Hs::P64 + 40];
           I64[Hp - 16] = sat_sg5Hr_info;
           P64[Hp] = _sg5Hd::P64;
           R4 = _sg5Hf::P64;
           R3 = Hp - 16;
           R2 = _sg5Hb::P64;
           R1 = _sg5Hh::P64;
           Sp = Sp - 16;
           call k1_sg5Hh_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cgmapM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgabt,
                       label: Data.Functor.Product.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgabt: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgabx; else goto cgabw;
       cgabx: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$cgmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgabw: // global
           I64[Hp - 64] = k1_sg5Hh_info;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           I64[Hp - 40] = sat_sg5Hs_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R6;
           _cgaaH::P64 = Hp - 61;
           P64[Hp] = _cgaaH::P64;
           R4 = P64[Sp];
           _sg5Hc::P64 = R3;
           R3 = Hp - 40;
           R2 = _sg5Hc::P64;
           R1 = _cgaaH::P64;
           Sp = Sp + 8;
           call k1_sg5Hh_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.427986254 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapM_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapM_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapM_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapM_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgac1: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapM_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2,
                                                                 R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapM_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cgac8,
                       label: Data.Functor.Product.$fDataProduct_$cgmapM_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgac8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgac9; else goto cgaca;
       cgac9: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgmapM_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cgaca: // global
           I64[Sp - 8] = block_cgac5_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugace; else goto cgac6;
       ugace: // global
           call _cgac5(R1) args: 0, res: 0, upd: 0;
       cgac6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgac5() //  [R1]
         { info_tbl: [(cgac5,
                       label: block_cgac5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgac5: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cgmapM_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.436651093 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapQi_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapQi_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapQi_info;
         const 0;
 },
 Data.Functor.Product.$fDataProduct_$cgmapQi_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgacs: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapQi_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapQi_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cgacz,
                       label: Data.Functor.Product.$fDataProduct_$cgmapQi_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgacz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgacD; else goto cgacE;
       cgacD: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgmapQi_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cgacE: // global
           I64[Sp - 8] = block_cgacw_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugacS; else goto cgacx;
       ugacS: // global
           call _cgacw(R1) args: 0, res: 0, upd: 0;
       cgacx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgacw() //  [R1]
         { info_tbl: [(cgacw,
                       label: block_cgacw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgacw: // global
           I64[Sp - 8] = block_cgacC_info;
           _sg5HP::P64 = P64[R1 + 7];
           _sg5HQ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sg5HQ::P64;
           P64[Sp + 16] = _sg5HP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugacR; else goto cgacG;
       ugacR: // global
           call _cgacC(R1) args: 0, res: 0, upd: 0;
       cgacG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgacC() //  [R1]
         { info_tbl: [(cgacC,
                       label: block_cgacC_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgacC: // global
           _sg5HM::P64 = P64[Sp + 32];
           _sg5HT::I64 = I64[R1 + 7];
           if (_sg5HT::I64 != 0) goto ugacQ; else goto cgacO;
       ugacQ: // global
           if (_sg5HT::I64 != 1) goto cgacN; else goto cgacP;
       cgacN: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgacP: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           R1 = _sg5HM::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgacO: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 40];
           R1 = _sg5HM::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.446686973 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapQr_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapQr_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapQr_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapQr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgad9: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapQr_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg5I9_entry() //  [R1]
         { info_tbl: [(cgadn,
                       label: sat_sg5I9_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgadn: // global
           _sg5I9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgado; else goto cgadp;
       cgadp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgadr; else goto cgadq;
       cgadr: // global
           HpAlloc = 40;
           goto cgado;
       cgado: // global
           R1 = _sg5I9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgadq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5I9::P64;
           _sg5HZ::P64 = P64[_sg5I9::P64 + 16];
           _sg5I0::P64 = P64[_sg5I9::P64 + 24];
           _sg5I1::P64 = P64[_sg5I9::P64 + 32];
           _sg5I2::P64 = P64[_sg5I9::P64 + 40];
           _sg5I6::P64 = P64[_sg5I9::P64 + 48];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg5I2::P64;
           P64[Hp - 8] = _sg5HZ::P64;
           P64[Hp] = _sg5I6::P64;
           R3 = _sg5I1::P64;
           R2 = Hp - 32;
           R1 = _sg5I0::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapQr_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cgads,
                       label: Data.Functor.Product.$fDataProduct_$cgmapQr_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgads: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgadu; else goto cgadv;
       cgadu: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgmapQr_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cgadv: // global
           I64[Sp - 8] = block_cgadd_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugadz; else goto cgade;
       ugadz: // global
           call _cgadd(R1) args: 0, res: 0, upd: 0;
       cgade: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgadd() //  [R1]
         { info_tbl: [(cgadd,
                       label: block_cgadd_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgadd: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgady; else goto cgadx;
       cgady: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgadx: // global
           _sg5I5::P64 = P64[R1 + 7];
           _sg5I6::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_sg5I9_info;
           P64[Hp - 72] = P64[Sp + 8];
           _sg5I0::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sg5I0::P64;
           P64[Hp - 56] = P64[Sp + 24];
           _sg5I2::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sg5I2::P64;
           P64[Hp - 40] = _sg5I6::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg5I2::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sg5I5::P64;
           R3 = Hp - 88;
           R2 = Hp - 32;
           R1 = _sg5I0::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.457975298 UTC

[section ""data" . Data.Functor.Product.$fDataProduct2_closure" {
     Data.Functor.Product.$fDataProduct2_closure:
         const Data.Functor.Product.$fDataProduct2_info;
 },
 Data.Functor.Product.$fDataProduct2_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgadT: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct2_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg5Io_entry() //  [R1]
         { info_tbl: [(cgae8,
                       label: sat_sg5Io_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgae8: // global
           _sg5Io::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgae9; else goto cgaea;
       cgaea: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgaec; else goto cgaeb;
       cgaec: // global
           HpAlloc = 40;
           goto cgae9;
       cgae9: // global
           R1 = _sg5Io::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaeb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Io::P64;
           _sg5Ie::P64 = P64[_sg5Io::P64 + 16];
           _sg5Ig::P64 = P64[_sg5Io::P64 + 24];
           _sg5Ih::P64 = P64[_sg5Io::P64 + 32];
           _sg5Ii::P64 = P64[_sg5Io::P64 + 40];
           _sg5Il::P64 = P64[_sg5Io::P64 + 48];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sg5Ii::P64;
           P64[Hp - 8] = _sg5Ie::P64;
           P64[Hp] = _sg5Il::P64;
           R3 = Hp - 32;
           R2 = _sg5Ih::P64;
           R1 = _sg5Ig::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct2_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cgaed,
                       label: Data.Functor.Product.$fDataProduct2_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaed: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgaee; else goto cgaef;
       cgaee: // global
           R1 = Data.Functor.Product.$fDataProduct2_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cgaef: // global
           I64[Sp - 8] = block_cgadX_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugaej; else goto cgadY;
       ugaej: // global
           call _cgadX(R1) args: 0, res: 0, upd: 0;
       cgadY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgadX() //  [R1]
         { info_tbl: [(cgadX,
                       label: block_cgadX_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgadX: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgaei; else goto cgaeh;
       cgaei: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgaeh: // global
           _sg5Il::P64 = P64[R1 + 7];
           _sg5Im::P64 = P64[R1 + 15];
           I64[Hp - 88] = stg_ap_3_upd_info;
           _sg5Ii::P64 = P64[Sp + 32];
           P64[Hp - 72] = _sg5Ii::P64;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sg5Im::P64;
           I64[Hp - 48] = sat_sg5Io_info;
           P64[Hp - 32] = P64[Sp + 40];
           _sg5Ig::P64 = P64[Sp + 16];
           P64[Hp - 24] = _sg5Ig::P64;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sg5Ii::P64;
           P64[Hp] = _sg5Il::P64;
           R3 = Hp - 88;
           R2 = Hp - 48;
           R1 = _sg5Ig::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.471906665 UTC

[section ""data" . Data.Functor.Product.$w$cgmapMo_closure" {
     Data.Functor.Product.$w$cgmapMo_closure:
         const Data.Functor.Product.$w$cgmapMo_info;
 },
 lvl9_sg5Iv_entry() //  [R1]
         { info_tbl: [(cgaeK,
                       label: lvl9_sg5Iv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaeK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgaeL; else goto cgaeM;
       cgaeL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaeM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5J3_entry() //  [R1, R2]
         { info_tbl: [(cgaeZ,
                       label: sat_sg5J3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaeZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgaf0; else goto cgaf1;
       cgaf0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgaf1: // global
           I64[Sp - 24] = block_cgaeW_info;
           _sg5Iv::P64 = P64[R1 + 7];
           _sg5Iw::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sg5Iv::P64;
           P64[Sp - 8] = _sg5Iw::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugafj; else goto cgaeX;
       ugafj: // global
           call _cgaeW(R1) args: 0, res: 0, upd: 0;
       cgaeX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaeW() //  [R1]
         { info_tbl: [(cgaeW,
                       label: block_cgaeW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaeW: // global
           I64[Sp - 8] = block_cgaf4_info;
           _sg5J0::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sg5J0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugafi; else goto cgaf6;
       ugafi: // global
           call _cgaf4(R1) args: 0, res: 0, upd: 0;
       cgaf6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaf4() //  [R1]
         { info_tbl: [(cgaf4,
                       label: block_cgaf4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaf4: // global
           if (R1 & 7 == 1) goto cgafc; else goto cgafg;
       cgafc: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgafg: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5IR_entry() //  [R1]
         { info_tbl: [(cgafU,
                       label: sat_sg5IR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgafU: // global
           _sg5IR::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgafV; else goto cgafW;
       cgafW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgafY; else goto cgafX;
       cgafY: // global
           HpAlloc = 56;
           goto cgafV;
       cgafV: // global
           R1 = _sg5IR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgafX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5IR::P64;
           _sg5Iw::P64 = P64[_sg5IR::P64 + 16];
           _sg5ID::P64 = P64[_sg5IR::P64 + 24];
           _sg5IH::P64 = P64[_sg5IR::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5IH::P64;
           P64[Hp - 24] = _sg5ID::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sg5Iw::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5IN_entry() //  [R1, R2]
         { info_tbl: [(cgaga,
                       label: sat_sg5IN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaga: // global
           _sg5IK::P64 = R2;
           _sg5IN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgagb; else goto cgagc;
       cgagc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgage; else goto cgagd;
       cgage: // global
           HpAlloc = 56;
           goto cgagb;
       cgagb: // global
           R2 = _sg5IK::P64;
           R1 = _sg5IN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgagd: // global
           _sg5Iw::P64 = P64[_sg5IN::P64 + 7];
           _sg5IH::P64 = P64[_sg5IN::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5IH::P64;
           P64[Hp - 24] = _sg5IK::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sg5Iw::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sg5IO_entry() //  [R1]
         { info_tbl: [(cgagf,
                       label: sat_sg5IO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgagf: // global
           _sg5IO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgagg; else goto cgagh;
       cgagh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgagj; else goto cgagi;
       cgagj: // global
           HpAlloc = 24;
           goto cgagg;
       cgagg: // global
           R1 = _sg5IO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgagi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5IO::P64;
           _sg5Iw::P64 = P64[_sg5IO::P64 + 16];
           _sg5IE::P64 = P64[_sg5IO::P64 + 24];
           _sg5IH::P64 = P64[_sg5IO::P64 + 32];
           I64[Hp - 16] = sat_sg5IN_info;
           P64[Hp - 8] = _sg5Iw::P64;
           P64[Hp] = _sg5IH::P64;
           R2 = _sg5Iw::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sg5IE::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sg5IU_entry() //  [R1, R2]
         { info_tbl: [(cgagk,
                       label: sat_sg5IU_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgagk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgagl; else goto cgagm;
       cgagl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgagm: // global
           I64[Sp - 40] = block_cgafE_info;
           _sg5Is::P64 = P64[R1 + 7];
           _sg5Iw::P64 = P64[R1 + 15];
           _sg5ID::P64 = P64[R1 + 23];
           _sg5IE::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sg5Is::P64;
           P64[Sp - 24] = _sg5Iw::P64;
           P64[Sp - 16] = _sg5ID::P64;
           P64[Sp - 8] = _sg5IE::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugagD; else goto cgafF;
       ugagD: // global
           call _cgafE(R1) args: 0, res: 0, upd: 0;
       cgafF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgafE() //  [R1]
         { info_tbl: [(cgafE,
                       label: block_cgafE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgafE: // global
           I64[Sp - 8] = block_cgafJ_info;
           _sg5IH::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sg5IH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugagC; else goto cgafK;
       ugagC: // global
           call _cgafJ(R1) args: 0, res: 0, upd: 0;
       cgafK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgafJ() //  [R1]
         { info_tbl: [(cgafJ,
                       label: block_cgafJ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgafJ: // global
           _sg5Iw::P64 = P64[Sp + 24];
           _sg5ID::P64 = P64[Sp + 32];
           _sg5IH::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgagp; else goto cgagt;
       cgagp: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgags; else goto cgagr;
       cgags: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgagr: // global
           I64[Hp - 72] = sat_sg5IR_info;
           P64[Hp - 56] = _sg5Iw::P64;
           P64[Hp - 48] = _sg5ID::P64;
           P64[Hp - 40] = _sg5IH::P64;
           I64[Hp - 32] = sat_sg5IO_info;
           P64[Hp - 16] = _sg5Iw::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sg5IH::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cgagt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgagy; else goto cgagx;
       cgagy: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgagx: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sg5IH::P64;
           P64[Hp - 24] = _sg5ID::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sg5Iw::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 k1_sg5IA_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgagE,
                       label: k1_sg5IA_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgagE: // global
           _sg5ID::P64 = R4;
           _sg5IC::P64 = R3;
           _sg5IB::P64 = R2;
           _sg5IA::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgagF; else goto cgagG;
       cgagG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgagI; else goto cgagH;
       cgagI: // global
           HpAlloc = 80;
           goto cgagF;
       cgagF: // global
           R4 = _sg5ID::P64;
           R3 = _sg5IC::P64;
           R2 = _sg5IB::P64;
           R1 = _sg5IA::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgagH: // global
           _sg5Is::P64 = P64[_sg5IA::P64 + 5];
           _sg5It::P64 = P64[_sg5IA::P64 + 13];
           _sg5Iw::P64 = P64[_sg5IA::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sg5It::P64;
           P64[Hp - 48] = _sg5IB::P64;
           P64[Hp - 40] = _sg5ID::P64;
           I64[Hp - 32] = sat_sg5IU_info;
           P64[Hp - 24] = _sg5Is::P64;
           P64[Hp - 16] = _sg5Iw::P64;
           P64[Hp - 8] = _sg5ID::P64;
           P64[Hp] = Hp - 72;
           R2 = _sg5Iw::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sg5IC::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sg5IV_entry() //  [R1]
         { info_tbl: [(cgagR,
                       label: sat_sg5IV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgagR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgagS; else goto cgagT;
       cgagS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgagT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Product.$fDataProduct1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sg5IW_entry() //  [R1]
         { info_tbl: [(cgagU,
                       label: sat_sg5IW_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgagU: // global
           _sg5IW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgagV; else goto cgagW;
       cgagW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgagY; else goto cgagX;
       cgagY: // global
           HpAlloc = 24;
           goto cgagV;
       cgagV: // global
           R1 = _sg5IW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgagX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5IW::P64;
           _sg5Iq::P64 = P64[_sg5IW::P64 + 16];
           _sg5Iw::P64 = P64[_sg5IW::P64 + 24];
           _sg5Iy::P64 = P64[_sg5IW::P64 + 32];
           _sg5IA::P64 = P64[_sg5IW::P64 + 40];
           I64[Hp - 16] = sat_sg5IV_info;
           P64[Hp] = _sg5Iw::P64;
           R4 = _sg5Iy::P64;
           R3 = Hp - 16;
           R2 = _sg5Iq::P64;
           R1 = _sg5IA::P64;
           Sp = Sp - 16;
           call k1_sg5IA_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5IX_entry() //  [R1]
         { info_tbl: [(cgagZ,
                       label: sat_sg5IX_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgagZ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cgah0; else goto cgah1;
       cgah0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgah1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cgafo_info;
           _sg5Iq::P64 = P64[R1 + 16];
           _sg5Ir::P64 = P64[R1 + 24];
           _sg5Is::P64 = P64[R1 + 32];
           _sg5It::P64 = P64[R1 + 40];
           _sg5Iw::P64 = P64[R1 + 56];
           R1 = P64[R1 + 48];
           P64[Sp - 56] = _sg5Iq::P64;
           P64[Sp - 48] = _sg5Ir::P64;
           P64[Sp - 40] = _sg5Is::P64;
           P64[Sp - 32] = _sg5It::P64;
           P64[Sp - 24] = _sg5Iw::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ugah5; else goto cgafp;
       ugah5: // global
           call _cgafo(R1) args: 0, res: 0, upd: 0;
       cgafp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgafo() //  [R1]
         { info_tbl: [(cgafo,
                       label: block_cgafo_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgafo: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgah4; else goto cgah3;
       cgah4: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cgah3: // global
           _sg5Iy::P64 = P64[R1 + 7];
           _sg5Iz::P64 = P64[R1 + 15];
           I64[Hp - 72] = k1_sg5IA_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = P64[Sp + 32];
           _sg5Iw::P64 = P64[Sp + 40];
           P64[Hp - 48] = _sg5Iw::P64;
           I64[Hp - 40] = sat_sg5IW_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sg5Iw::P64;
           P64[Hp - 8] = _sg5Iy::P64;
           _cgaft::P64 = Hp - 69;
           P64[Hp] = _cgaft::P64;
           R4 = _sg5Iz::P64;
           R3 = Hp - 40;
           R2 = P64[Sp + 16];
           R1 = _cgaft::P64;
           Sp = Sp + 48;
           call k1_sg5IA_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cgmapMo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgah6,
                       label: Data.Functor.Product.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgah6: // global
           _sg5Iu::P64 = R6;
           _sg5It::P64 = R5;
           _sg5Is::P64 = R4;
           _sg5Ir::P64 = R3;
           _sg5Iq::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgah7; else goto cgah8;
       cgah8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgaha; else goto cgah9;
       cgaha: // global
           HpAlloc = 24;
           goto cgah7;
       cgah7: // global
           R6 = _sg5Iu::P64;
           R5 = _sg5It::P64;
           R4 = _sg5Is::P64;
           R3 = _sg5Ir::P64;
           R2 = _sg5Iq::P64;
           R1 = Data.Functor.Product.$w$cgmapMo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgah9: // global
           I64[Hp - 16] = lvl9_sg5Iv_info;
           P64[Hp] = _sg5Is::P64;
           I64[Sp - 56] = block_cgaeN_info;
           R2 = _sg5Is::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sg5Iq::P64;
           P64[Sp - 32] = _sg5Ir::P64;
           P64[Sp - 24] = _sg5Is::P64;
           P64[Sp - 16] = _sg5It::P64;
           P64[Sp - 8] = _sg5Iu::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgaeN() //  [R1]
         { info_tbl: [(cgaeN,
                       label: block_cgaeN_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaeN: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgahd; else goto cgahc;
       cgahd: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgahc: // global
           I64[Hp - 80] = sat_sg5J3_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sg5IX_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.513539509 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapMo_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapMo_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapMo_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapMo_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaiO: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapMo_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapMo_entry() //  [R6]
         { info_tbl: [(cgaiS,
                       label: Data.Functor.Product.$fDataProduct_$cgmapMo_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaiS: // global
           _sg5J8::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sg5J8::P64;
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cgmapMo_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.519875765 UTC

[section ""data" . lvl5_rg5oj_closure" {
     lvl5_rg5oj_closure:
         const lvl5_rg5oj_info;
         const 0;
 },
 lvl5_rg5oj_entry() //  [R2]
         { info_tbl: [(cgaj8,
                       label: lvl5_rg5oj_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaj8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgaj9; else goto cgaja;
       cgaj9: // global
           R2 = R2;
           R1 = lvl5_rg5oj_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgaja: // global
           I64[Sp - 8] = block_cgaj5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugaje; else goto cgaj6;
       ugaje: // global
           call _cgaj5() args: 0, res: 0, upd: 0;
       cgaj6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaj5() //  []
         { info_tbl: [(cgaj5,
                       label: block_cgaj5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaj5: // global
           R1 = Data.Functor.Product.$cPair_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.525345519 UTC

[section ""data" . lvl6_rg5ok_closure" {
     lvl6_rg5ok_closure:
         const lvl6_rg5ok_info;
         const 0;
 },
 lvl6_rg5ok_entry() //  []
         { info_tbl: [(cgajt,
                       label: lvl6_rg5ok_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgajt: // global
           R1 = Data.Functor.Product.$tProduct_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.528779049 UTC

[section ""data" . lvl7_rg5ol_closure" {
     lvl7_rg5ol_closure:
         const lvl7_rg5ol_info;
 },
 lvl7_rg5ol_entry() //  []
         { info_tbl: [(cgajF,
                       label: lvl7_rg5ol_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgajF: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.532260851 UTC

[section ""data" . lvl8_rg5om_closure" {
     lvl8_rg5om_closure:
         const lvl8_rg5om_info;
 },
 lvl8_rg5om_entry() //  []
         { info_tbl: [(cgajR,
                       label: lvl8_rg5om_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgajR: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.539070359 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_closure" {
     Data.Functor.Product.$fDataProduct_closure:
         const Data.Functor.Product.$fDataProduct_info;
         const 0;
 },
 sat_sg5K2_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgak8,
                       label: sat_sg5K2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgak8: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$w$cgmapMo_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5JY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgakg,
                       label: sat_sg5JY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgakg: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$w$cgmapMp_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5JU_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgako,
                       label: sat_sg5JU_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgako: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgakp; else goto cgakq;
       cgakp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgakq: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Product.$fDataProduct_$cgmapM_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg5JT_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgakw,
                       label: sat_sg5JT_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgakw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgakx; else goto cgaky;
       cgakx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaky: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Product.$fDataProduct_$cgmapQi_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg5JS_entry() //  [R1, R2, R3]
         { info_tbl: [(cgakH,
                       label: sat_sg5JS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgakH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgakO; else goto cgakP;
       cgakO: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgakP: // global
           I64[Sp - 32] = block_cgakE_info;
           _sg5Jq::P64 = P64[R1 + 6];
           _sg5Jr::P64 = P64[R1 + 14];
           R1 = R3;
           P64[Sp - 24] = _sg5Jq::P64;
           P64[Sp - 16] = _sg5Jr::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugakT; else goto cgakF;
       ugakT: // global
           call _cgakE(R1) args: 0, res: 0, upd: 0;
       cgakF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgakE() //  [R1]
         { info_tbl: [(cgakE,
                       label: block_cgakE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgakE: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgakS; else goto cgakR;
       cgakS: // global
           HpAlloc = 128;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgakR: // global
           _sg5JN::P64 = P64[R1 + 7];
           _sg5JO::P64 = P64[R1 + 15];
           I64[Hp - 120] = stg_ap_3_upd_info;
           _sg5JK::P64 = P64[Sp + 24];
           P64[Hp - 104] = _sg5JK::P64;
           P64[Hp - 96] = P64[Sp + 16];
           P64[Hp - 88] = _sg5JO::P64;
           I64[Hp - 80] = :_con_info;
           P64[Hp - 72] = Hp - 120;
           P64[Hp - 64] = GHC.Types.[]_closure+1;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sg5JK::P64;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg5JN::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 78;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5JJ_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgakZ,
                       label: sat_sg5JJ_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgakZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgal0; else goto cgal1;
       cgal0: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgal1: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Product.$fDataProduct_$cgmapQr_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg5JI_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgal7,
                       label: sat_sg5JI_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgal7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgal8; else goto cgal9;
       cgal8: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgal9: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Product.$fDataProduct2_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sg5JH_entry() //  [R1, R2, R3]
         { info_tbl: [(cgali,
                       label: sat_sg5JH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgali: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgalo; else goto cgalp;
       cgalo: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgalp: // global
           I64[Sp - 32] = block_cgalf_info;
           _sg5Jq::P64 = P64[R1 + 6];
           _sg5Jr::P64 = P64[R1 + 14];
           R1 = R3;
           P64[Sp - 24] = _sg5Jq::P64;
           P64[Sp - 16] = _sg5Jr::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugalt; else goto cgalg;
       ugalt: // global
           call _cgalf(R1) args: 0, res: 0, upd: 0;
       cgalg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgalf() //  [R1]
         { info_tbl: [(cgalf,
                       label: block_cgalf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgalf: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgals; else goto cgalr;
       cgals: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgalr: // global
           _sg5JD::P64 = P64[R1 + 7];
           _sg5JE::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           _sg5JA::P64 = P64[Sp + 24];
           P64[Hp - 80] = _sg5JA::P64;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sg5JE::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sg5JA::P64;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sg5JD::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Jx_entry() //  [R1]
         { info_tbl: [(cgalH,
                       label: sat_sg5Jx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgalH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgalI; else goto cgalJ;
       cgalI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgalJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Product.Pair_closure+2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Jy_entry() //  [R1]
         { info_tbl: [(cgalK,
                       label: sat_sg5Jy_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgalK: // global
           _sg5Jy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgalL; else goto cgalM;
       cgalM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgalO; else goto cgalN;
       cgalO: // global
           HpAlloc = 24;
           goto cgalL;
       cgalL: // global
           R1 = _sg5Jy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgalN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sg5Jy::P64;
           _sg5Jq::P64 = P64[_sg5Jy::P64 + 16];
           _sg5Ju::P64 = P64[_sg5Jy::P64 + 24];
           _sg5Jv::P64 = P64[_sg5Jy::P64 + 32];
           I64[Hp - 16] = sat_sg5Jx_info;
           P64[Hp] = _sg5Jv::P64;
           R3 = Hp - 16;
           R2 = _sg5Jq::P64;
           R1 = _sg5Ju::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sg5Jz_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgalP,
                       label: sat_sg5Jz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgalP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgalT; else goto cgalS;
       cgalT: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgalS: // global
           _sg5Jq::P64 = P64[R1 + 5];
           _sg5Jr::P64 = P64[R1 + 13];
           I64[Hp - 32] = sat_sg5Jy_info;
           P64[Hp - 16] = _sg5Jq::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 32;
           _sg5Ju::P64 = R2;
           R2 = _sg5Jr::P64;
           R1 = _sg5Ju::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sg5Jt_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgalZ,
                       label: sat_sg5Jt_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgalZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgam0; else goto cgam1;
       cgam0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgam1: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Product.$fDataProduct_$cgfoldl_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sg5Js_entry() //  [R1]
         { info_tbl: [(cgam6,
                       label: sat_sg5Js_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgam6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgam7; else goto cgam8;
       cgam7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgam8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$w$cp1Data_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgama,
                       label: Data.Functor.Product.$fDataProduct_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgama: // global
           Hp = Hp + 576;
           if (Hp > HpLim) (likely: False) goto cgame; else goto cgamd;
       cgame: // global
           HpAlloc = 576;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fDataProduct_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgamd: // global
           I64[Hp - 568] = sat_sg5K2_info;
           P64[Hp - 560] = R6;
           _sg5Jr::P64 = P64[Sp];
           P64[Hp - 552] = _sg5Jr::P64;
           I64[Hp - 544] = sat_sg5JY_info;
           P64[Hp - 536] = R6;
           P64[Hp - 528] = _sg5Jr::P64;
           I64[Hp - 520] = sat_sg5JU_info;
           P64[Hp - 512] = R2;
           P64[Hp - 504] = R3;
           P64[Hp - 496] = R4;
           P64[Hp - 488] = R5;
           P64[Hp - 480] = R6;
           P64[Hp - 472] = _sg5Jr::P64;
           I64[Hp - 464] = sat_sg5JT_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           P64[Hp - 440] = R4;
           P64[Hp - 432] = R5;
           P64[Hp - 424] = R6;
           P64[Hp - 416] = _sg5Jr::P64;
           I64[Hp - 408] = sat_sg5JS_info;
           P64[Hp - 400] = R6;
           P64[Hp - 392] = _sg5Jr::P64;
           I64[Hp - 384] = sat_sg5JJ_info;
           P64[Hp - 376] = R2;
           P64[Hp - 368] = R3;
           P64[Hp - 360] = R4;
           P64[Hp - 352] = R5;
           P64[Hp - 344] = R6;
           P64[Hp - 336] = _sg5Jr::P64;
           I64[Hp - 328] = sat_sg5JI_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           P64[Hp - 296] = R5;
           P64[Hp - 288] = R6;
           P64[Hp - 280] = _sg5Jr::P64;
           I64[Hp - 272] = sat_sg5JH_info;
           P64[Hp - 264] = R6;
           P64[Hp - 256] = _sg5Jr::P64;
           I64[Hp - 248] = sat_sg5Jz_info;
           P64[Hp - 240] = R6;
           P64[Hp - 232] = _sg5Jr::P64;
           I64[Hp - 224] = sat_sg5Jt_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           P64[Hp - 200] = R4;
           P64[Hp - 192] = R5;
           P64[Hp - 184] = R6;
           P64[Hp - 176] = _sg5Jr::P64;
           I64[Hp - 168] = sat_sg5Js_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           P64[Hp - 136] = R4;
           P64[Hp - 128] = R5;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 168;
           P64[Hp - 104] = Hp - 221;
           P64[Hp - 96] = Hp - 245;
           P64[Hp - 88] = lvl5_rg5oj_closure+1;
           P64[Hp - 80] = lvl6_rg5ok_closure+1;
           P64[Hp - 72] = lvl7_rg5ol_closure+2;
           P64[Hp - 64] = lvl8_rg5om_closure+2;
           P64[Hp - 56] = Hp - 270;
           P64[Hp - 48] = Hp - 324;
           P64[Hp - 40] = Hp - 380;
           P64[Hp - 32] = Hp - 406;
           P64[Hp - 24] = Hp - 461;
           P64[Hp - 16] = Hp - 517;
           P64[Hp - 8] = Hp - 541;
           P64[Hp] = Hp - 565;
           R1 = Hp - 119;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.58074151 UTC

[section ""data" . Data.Functor.Product.Pair_closure" {
     Data.Functor.Product.Pair_closure:
         const Data.Functor.Product.Pair_info;
 },
 Data.Functor.Product.Pair_entry() //  [R2, R3]
         { info_tbl: [(cganL,
                       label: Data.Functor.Product.Pair_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cganL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cganP; else goto cganO;
       cganP: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.Pair_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cganO: // global
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.585007298 UTC

[Data.Functor.Product.Pair_con_entry() //  [R1]
         { info_tbl: [(cganV,
                       label: Data.Functor.Product.Pair_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,80,114,111,100,117,99,116,46,80,97,105,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cganV: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:57.588549346 UTC

[section ""relreadonly" . Sg5Oh_srt" {
     Sg5Oh_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Product.$fRead1Product1_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadList_closure;
         const Data.Functor.Product.$fRead1Product_closure;
         const Data.Functor.Product.$fRead1Product2_closure;
         const Data.Functor.Product.$w$cliftShowsPrec_closure;
         const Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure;
         const Data.Functor.Product.$fShow1Product_$cliftShowList_closure;
         const Data.Functor.Product.$fShow1Product_closure;
         const Data.Functor.Product.$fReadProduct_$creadPrec_closure;
         const Data.Functor.Product.$fReadProduct_$creadsPrec_closure;
         const Data.Functor.Product.$fReadProduct_$creadListPrec_closure;
         const Data.Functor.Product.$fReadProduct_$creadList_closure;
         const Data.Functor.Product.$fReadProduct_closure;
         const Data.Functor.Product.$w$cshowsPrec_closure;
         const Data.Functor.Product.$fShowProduct_$cshowsPrec_closure;
         const Data.Functor.Product.$w$cshow_closure;
         const Data.Functor.Product.$fShowProduct_$cshow_closure;
         const Data.Functor.Product.$fShowProduct_$cshowList_closure;
         const Data.Functor.Product.$fShowProduct_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Functor.Product.$fFoldableProduct_$csum_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Functor.Product.$fFoldableProduct2_closure;
         const Data.Functor.Product.$fFoldableProduct_$cminimum_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Product.$fFoldableProduct3_closure;
         const Data.Functor.Product.$fFoldableProduct_$cmaximum_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Functor.Product.$fFoldableProduct_$celem_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Functor.Product.$fFoldableProduct8_closure;
         const Data.Functor.Product.$w$cfoldl_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldl_closure;
         const Data.Functor.Product.$w$cfoldl1_closure;
         const Data.Functor.Product.$fFoldableProduct7_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure;
         const Data.Functor.Product.$w$cfoldr'_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure;
         const Data.Functor.Product.$w$cfoldr_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldr_closure;
         const Data.Functor.Product.$w$cfoldl'_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure;
         const Data.Functor.Product.$fFoldableProduct_$clength_closure;
         const Data.Functor.Product.$w$cfoldr1_closure;
         const Data.Functor.Product.$fFoldableProduct9_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure;
         const Data.Functor.Product.$fFoldableProduct_$cnull_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Functor.Product.$fFoldableProduct_$cproduct_closure;
         const Data.Functor.Product.$fFoldableProduct_$ctoList_closure;
         const Data.Functor.Product.$fFoldableProduct_closure;
         const Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure;
         const Data.Functor.Product.$fTraversableProduct_closure;
         const poly_some_v_rg5o0_closure;
         const Data.Functor.Product.$fAlternativeProduct_$csome_closure;
         const Data.Functor.Product.$fAlternativeProduct_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Product.$fMonadProduct_closure;
         const lvl4_rg5o1_closure;
         const Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure;
         const Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure;
         const Data.Functor.Product.$fMonadPlusProduct_closure;
         const Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure;
         const Data.Functor.Product.$fMonadFixProduct_closure;
         const Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure;
         const Data.Functor.Product.$fMonadZipProduct_closure;
         const GHC.List.badHead_closure;
         const go61_rg5o2_closure;
         const Data.Functor.Product.$fRead1Product2_closure;
         const Data.Data.mkConstr1_closure;
         const Data.Functor.Product.$fDataProduct4_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Functor.Product.$w$cp1Data_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Functor.Product.$fDataProduct_$cgmapQi_closure;
         const Data.Functor.Product.$cPair_closure;
         const lvl5_rg5oj_closure;
         const Data.Functor.Product.$tProduct_closure;
         const Data.Functor.Product.$fDataProduct_closure;
         const lvl6_rg5ok_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:03.951115401 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:03.952916539 UTC

[section ""data" . Data.Functor.Product.$fEq1Product_$cliftEq_closure" {
     Data.Functor.Product.$fEq1Product_$cliftEq_closure:
         const Data.Functor.Product.$fEq1Product_$cliftEq_info;
 },
 Data.Functor.Product.$fEq1Product_$cliftEq_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cgaJO,
                       label: Data.Functor.Product.$fEq1Product_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaJO: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgaJS; else goto cgaJT;
       cgaJS: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEq1Product_$cliftEq_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaJT: // global
           I64[Sp - 40] = block_cgaJL_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugaKd; else goto cgaJM;
       ugaKd: // global
           call _cgaJL(R1) args: 0, res: 0, upd: 0;
       cgaJM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaJL() //  [R1]
         { info_tbl: [(cgaJL,
                       label: block_cgaJL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaJL: // global
           I64[Sp - 8] = block_cgaJR_info;
           _sgao8::P64 = P64[R1 + 7];
           _sgao9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sgao9::P64;
           P64[Sp + 32] = _sgao8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugaKc; else goto cgaJV;
       ugaKc: // global
           call _cgaJR(R1) args: 0, res: 0, upd: 0;
       cgaJV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaJR() //  [R1]
         { info_tbl: [(cgaJR,
                       label: block_cgaJR_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaJR: // global
           I64[Sp] = block_cgaJZ_info;
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           _sgaoc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp + 40] = _sgaoc::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaJZ() //  [R1]
         { info_tbl: [(cgaJZ,
                       label: block_cgaJZ_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaJZ: // global
           if (R1 & 7 == 1) goto cgaK6; else goto cgaKa;
       cgaK6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgaKa: // global
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           R1 = P64[Sp + 24];
           Sp = Sp + 48;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:03.962495804 UTC

[section ""data" . Data.Functor.Product.$fEq1Product_closure" {
     Data.Functor.Product.$fEq1Product_closure:
         const Data.Functor.Product.$fEq1Product_info;
 },
 Data.Functor.Product.$fEq1Product_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgaKF,
                       label: Data.Functor.Product.$fEq1Product_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaKF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Product.$fEq1Product_$cliftEq_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:03.966324491 UTC

[section ""data" . Data.Functor.Product.$w$cliftCompare_closure" {
     Data.Functor.Product.$w$cliftCompare_closure:
         const Data.Functor.Product.$w$cliftCompare_info;
 },
 Data.Functor.Product.$w$cliftCompare_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaKN: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cliftCompare_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cliftCompare_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cgaKY,
                       label: Data.Functor.Product.$w$cliftCompare_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaKY: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgaKZ; else goto cgaL0;
       cgaKZ: // global
           R1 = Data.Functor.Product.$w$cliftCompare_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cgaL0: // global
           I64[Sp - 24] = block_cgaKR_info;
           R2 = R2;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = R4;
           P64[Sp - 40] = R5;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = R3;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgaKR() //  [R1]
         { info_tbl: [(cgaKR,
                       label: block_cgaKR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaKR: // global
           _cgaKX::P64 = R1 & 7;
           if (_cgaKX::P64 < 3) goto ugaLa; else goto cgaKW;
       ugaLa: // global
           if (_cgaKX::P64 < 2) goto cgaKU; else goto cgaKV;
       cgaKU: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgaKV: // global
           R2 = P64[Sp + 24];
           _sgaog::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           _sgaoi::P64 = P64[Sp + 16];
           P64[Sp + 16] = _sgaog::P64;
           P64[Sp + 24] = _sgaoi::P64;
           Sp = Sp + 8;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
       cgaKW: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:03.974307485 UTC

[section ""data" . Data.Functor.Product.$fOrd1Product_$cliftCompare_closure" {
     Data.Functor.Product.$fOrd1Product_$cliftCompare_closure:
         const Data.Functor.Product.$fOrd1Product_$cliftCompare_info;
 },
 Data.Functor.Product.$fOrd1Product_$cliftCompare_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cgaLB,
                       label: Data.Functor.Product.$fOrd1Product_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaLB: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgaLF; else goto cgaLG;
       cgaLF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrd1Product_$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaLG: // global
           I64[Sp - 40] = block_cgaLy_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugaLO; else goto cgaLz;
       ugaLO: // global
           call _cgaLy(R1) args: 0, res: 0, upd: 0;
       cgaLz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaLy() //  [R1]
         { info_tbl: [(cgaLy,
                       label: block_cgaLy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaLy: // global
           I64[Sp - 8] = block_cgaLE_info;
           _sgaos::P64 = P64[R1 + 7];
           _sgaot::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sgaot::P64;
           P64[Sp + 32] = _sgaos::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugaLN; else goto cgaLI;
       ugaLN: // global
           call _cgaLE(R1) args: 0, res: 0, upd: 0;
       cgaLI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaLE() //  [R1]
         { info_tbl: [(cgaLE,
                       label: block_cgaLE_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaLE: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cliftCompare_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:03.982465783 UTC

[section ""data" . Data.Functor.Product.$w$cp1Ord1_closure" {
     Data.Functor.Product.$w$cp1Ord1_closure:
         const Data.Functor.Product.$w$cp1Ord1_info;
 },
 Data.Functor.Product.$w$cp1Ord1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaM7: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cp1Ord1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cp1Ord1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgaMh,
                       label: Data.Functor.Product.$w$cp1Ord1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaMh: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgaMi; else goto cgaMj;
       cgaMi: // global
           R1 = Data.Functor.Product.$w$cp1Ord1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cgaMj: // global
           I64[Sp - 24] = block_cgaMb_info;
           R2 = R2;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = R4;
           P64[Sp - 40] = R5;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = R3;
           Sp = Sp - 56;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgaMb() //  [R1]
         { info_tbl: [(cgaMb,
                       label: block_cgaMb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaMb: // global
           if (R1 & 7 == 1) goto cgaMe; else goto cgaMf;
       cgaMe: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgaMf: // global
           R2 = P64[Sp + 24];
           _sgaoz::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           _sgaoB::P64 = P64[Sp + 16];
           P64[Sp + 16] = _sgaoz::P64;
           P64[Sp + 24] = _sgaoB::P64;
           Sp = Sp + 8;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:03.992171433 UTC

[section ""data" . Data.Functor.Product.$fOrd1Product1_closure" {
     Data.Functor.Product.$fOrd1Product1_closure:
         const Data.Functor.Product.$fOrd1Product1_info;
 },
 Data.Functor.Product.$fOrd1Product1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cgaMP,
                       label: Data.Functor.Product.$fOrd1Product1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaMP: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgaMT; else goto cgaMU;
       cgaMT: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrd1Product1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaMU: // global
           I64[Sp - 40] = block_cgaMM_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugaN2; else goto cgaMN;
       ugaN2: // global
           call _cgaMM(R1) args: 0, res: 0, upd: 0;
       cgaMN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaMM() //  [R1]
         { info_tbl: [(cgaMM,
                       label: block_cgaMM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaMM: // global
           I64[Sp - 8] = block_cgaMS_info;
           _sgaoL::P64 = P64[R1 + 7];
           _sgaoM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sgaoM::P64;
           P64[Sp + 32] = _sgaoL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugaN1; else goto cgaMW;
       ugaN1: // global
           call _cgaMS(R1) args: 0, res: 0, upd: 0;
       cgaMW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaMS() //  [R1]
         { info_tbl: [(cgaMS,
                       label: block_cgaMS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaMS: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cp1Ord1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.000055129 UTC

[section ""data" . Data.Functor.Product.$fOrd1Product_closure" {
     Data.Functor.Product.$fOrd1Product_closure:
         const Data.Functor.Product.$fOrd1Product_info;
 },
 sat_sgaoT_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgaNt,
                       label: sat_sgaoT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaNt: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fOrd1Product_$cliftCompare_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaoS_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgaNB,
                       label: sat_sgaoS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaNB: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fOrd1Product1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fOrd1Product_entry() //  [R2, R3]
         { info_tbl: [(cgaNF,
                       label: Data.Functor.Product.$fOrd1Product_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaNF: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgaNJ; else goto cgaNI;
       cgaNJ: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrd1Product_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaNI: // global
           I64[Hp - 64] = sat_sgaoT_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgaoS_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 37;
           P64[Hp] = Hp - 61;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.00685489 UTC

[section ""cstring" . Data.Functor.Product.$fRead1Product3_bytes" {
     Data.Functor.Product.$fRead1Product3_bytes:
         I8[] [80,97,105,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.008785559 UTC

[section ""data" . Data.Functor.Product.$fRead1Product2_closure" {
     Data.Functor.Product.$fRead1Product2_closure:
         const Data.Functor.Product.$fRead1Product2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fRead1Product2_entry() //  [R1]
         { info_tbl: [(cgaO7,
                       label: Data.Functor.Product.$fRead1Product2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaO7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgaO8; else goto cgaO9;
       cgaO8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaO9: // global
           (_cgaO4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgaO4::I64 == 0) goto cgaO6; else goto cgaO5;
       cgaO6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgaO5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgaO4::I64;
           R2 = Data.Functor.Product.$fRead1Product3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.012711749 UTC

[section ""data" . Data.Functor.Product.$fRead1Product1_closure" {
     Data.Functor.Product.$fRead1Product1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Product.$fRead1Product2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.014712598 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_lvl3_closure" {
     Data.Functor.Product.$fRead1Product_lvl3_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.018325226 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadPrec_info;
         const 0;
 },
 reader_sgaoY_entry() //  [R1]
         { info_tbl: [(cgaOs,
                       label: reader_sgaoY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaOs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgaOt; else goto cgaOu;
       cgaOt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaOu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 reader1_sgaoZ_entry() //  [R1]
         { info_tbl: [(cgaOz,
                       label: reader1_sgaoZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaOz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgaOA; else goto cgaOB;
       cgaOA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaOB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgap8_entry() //  [R1, R2]
         { info_tbl: [(cgaP1,
                       label: sat_sgap8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaP1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgaP5; else goto cgaP4;
       cgaP5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgaP4: // global
           _sgap2::P64 = P64[R1 + 7];
           _sgap5::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = _sgap5::P64;
           P64[Hp] = R2;
           R2 = Hp - 15;
           R1 = _sgap2::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgap9_entry() //  [R1, R2]
         { info_tbl: [(cgaP6,
                       label: sat_sgap9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaP6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgaPa; else goto cgaP9;
       cgaPa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgaP9: // global
           _sgaoZ::P64 = P64[R1 + 7];
           _sgap2::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sgap8_info;
           P64[Hp - 8] = _sgap2::P64;
           P64[Hp] = R2;
           R3 = Hp - 15;
           R2 = Data.Functor.Product.$fRead1Product_lvl3_closure+1;
           R1 = _sgaoZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgapa_entry() //  [R1, R2]
         { info_tbl: [(cgaPb,
                       label: sat_sgapa_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaPb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgaPf; else goto cgaPe;
       cgaPf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgaPe: // global
           _sgaoY::P64 = P64[R1 + 7];
           _sgaoZ::P64 = P64[R1 + 15];
           _sgap2::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_sgap9_info;
           P64[Hp - 8] = _sgaoZ::P64;
           P64[Hp] = _sgap2::P64;
           R3 = Hp - 15;
           R2 = Data.Functor.Product.$fRead1Product_lvl3_closure+1;
           R1 = _sgaoY::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wlvl_sgap0_entry() //  [R1, R2, R3]
         { info_tbl: [(cgaPj,
                       label: $wlvl_sgap0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaPj: // global
           _sgap2::P64 = R3;
           _sgap1::I64 = R2;
           _sgap0::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cgaPk; else goto cgaPl;
       cgaPl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgaPn; else goto cgaPm;
       cgaPn: // global
           HpAlloc = 32;
           goto cgaPk;
       cgaPk: // global
           R3 = _sgap2::P64;
           R2 = _sgap1::I64;
           R1 = _sgap0::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaPm: // global
           if (%MO_S_Gt_W64(_sgap1::I64, 10)) goto cgaPh; else goto cgaPi;
       cgaPh: // global
           Hp = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgaPi: // global
           _sgaoY::P64 = P64[_sgap0::P64 + 6];
           _sgaoZ::P64 = P64[_sgap0::P64 + 14];
           I64[Hp - 24] = sat_sgapa_info;
           P64[Hp - 16] = _sgaoY::P64;
           P64[Hp - 8] = _sgaoZ::P64;
           P64[Hp] = _sgap2::P64;
           I64[Sp - 8] = block_cgaPo_info;
           R3 = Hp - 23;
           R2 = Data.Functor.Product.$fRead1Product1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgaPo() //  [R1]
         { info_tbl: [(cgaPo,
                       label: block_cgaPo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaPo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgaPt; else goto cgaPs;
       cgaPt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgaPs: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl9_sgapd_entry() //  [R1, R2, R3]
         { info_tbl: [(cgaPC,
                       label: lvl9_sgapd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaPC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgaPD; else goto cgaPE;
       cgaPD: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaPE: // global
           I64[Sp - 24] = block_cgaPz_info;
           _sgap0::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sgap0::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugaPI; else goto cgaPA;
       ugaPI: // global
           call _cgaPz(R1) args: 0, res: 0, upd: 0;
       cgaPA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaPz() //  [R1]
         { info_tbl: [(cgaPz,
                       label: block_cgaPz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaPz: // global
           R3 = P64[Sp + 16];
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call $wlvl_sgap0_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgapk_entry() //  [R1, R2, R3]
         { info_tbl: [(cgaPO,
                       label: sat_sgapk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaPO: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgaPR,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaPR: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cgaPV; else goto cgaPU;
       cgaPV: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaPU: // global
           I64[Hp - 128] = reader_sgaoY_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R4;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = reader1_sgaoZ_info;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = $wlvl_sgap0_info;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 88;
           I64[Hp - 24] = lvl9_sgapd_info;
           P64[Hp - 16] = Hp - 46;
           I64[Hp - 8] = sat_sgapk_info;
           P64[Hp] = Hp - 22;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.044244282 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadsPrec_info;
         const 0;
 },
 sat_sgapv_entry() //  [R1, R2, R3]
         { info_tbl: [(cgaRi,
                       label: sat_sgapv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaRi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgaRj; else goto cgaRk;
       cgaRj: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaRk: // global
           I64[Sp - 8] = block_cgaRf_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgaRf() //  [R1]
         { info_tbl: [(cgaRf,
                       label: block_cgaRf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaRf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgaRn; else goto cgaRm;
       cgaRn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgaRm: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgapq_entry() //  [R1, R2]
         { info_tbl: [(cgaRt,
                       label: sat_sgapq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaRt: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sgapp_entry() //  [R1]
         { info_tbl: [(cgaRw,
                       label: ds_sgapp_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaRw: // global
           _sgapp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgaRx; else goto cgaRy;
       cgaRy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgaRA; else goto cgaRz;
       cgaRA: // global
           HpAlloc = 32;
           goto cgaRx;
       cgaRx: // global
           R1 = _sgapp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaRz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgapp::P64;
           _sgapl::P64 = P64[_sgapp::P64 + 16];
           _sgapm::P64 = P64[_sgapp::P64 + 24];
           _sgapn::P64 = P64[_sgapp::P64 + 32];
           _sgapo::P64 = P64[_sgapp::P64 + 40];
           I64[Hp - 24] = sat_sgapv_info;
           P64[Hp - 16] = _sgapo::P64;
           I64[Hp - 8] = sat_sgapq_info;
           P64[Hp] = _sgapn::P64;
           R5 = Hp - 22;
           R4 = Hp - 7;
           R3 = _sgapm::P64;
           R2 = _sgapl::P64;
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgapx_entry() //  [R1]
         { info_tbl: [(cgaRK,
                       label: sat_sgapx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaRK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgaRL; else goto cgaRM;
       cgaRL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaRM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgapy_entry() //  [R1, R2]
         { info_tbl: [(cgaRN,
                       label: sat_sgapy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaRN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgaRR; else goto cgaRQ;
       cgaRR: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgaRQ: // global
           _sgapp::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgapx_info;
           P64[Hp - 8] = _sgapp::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadsPrec_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cgaRS,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaRS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgaRW; else goto cgaRV;
       cgaRW: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaRV: // global
           I64[Hp - 56] = ds_sgapp_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = sat_sgapy_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.060046883 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadListPrec_info;
         const 0;
 },
 sat_sgapD_entry() //  [R1]
         { info_tbl: [(cgaSI,
                       label: sat_sgapD_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaSI: // global
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadListPrec_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cgaSL,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaSL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgaSP; else goto cgaSO;
       cgaSP: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaSO: // global
           I64[Hp - 40] = sat_sgapD_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.06688035 UTC

[section ""data" . Data.Functor.Product.$fRead1Product_closure" {
     Data.Functor.Product.$fRead1Product_closure:
         const Data.Functor.Product.$fRead1Product_info;
         const 0;
 },
 sat_sgapJ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgaT7,
                       label: sat_sgapJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaT7: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fRead1Product_$cliftReadListPrec_entry(R5,
                                                                             R4,
                                                                             R3,
                                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgapI_entry() //  [R1, R2, R3]
         { info_tbl: [(cgaTf,
                       label: sat_sgapI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaTf: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgapH_entry() //  [R1]
         { info_tbl: [(cgaTm,
                       label: sat_sgapH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaTm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgaTn; else goto cgaTo;
       cgaTn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaTo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_$cliftReadList_entry(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgapG_entry() //  [R1, R2, R3]
         { info_tbl: [(cgaTu,
                       label: sat_sgapG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaTu: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fRead1Product_$cliftReadsPrec_entry(R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fRead1Product_entry() //  [R2, R3]
         { info_tbl: [(cgaTy,
                       label: Data.Functor.Product.$fRead1Product_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaTy: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgaTC; else goto cgaTB;
       cgaTC: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaTB: // global
           I64[Hp - 136] = sat_sgapJ_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sgapI_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sgapH_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sgapG_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 54;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 134;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Product.$fRead1Product_$cliftReadList_closure" {
     Data.Functor.Product.$fRead1Product_$cliftReadList_closure:
         const Data.Functor.Product.$fRead1Product_$cliftReadList_info;
         const 0;
 },
 sat_sgapM_entry() //  [R1]
         { info_tbl: [(cgaTL,
                       label: sat_sgapM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaTL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgaTM; else goto cgaTN;
       cgaTM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaTN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_entry(R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fRead1Product_$cliftReadList_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cgaTO,
                       label: Data.Functor.Product.$fRead1Product_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaTO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgaTS; else goto cgaTR;
       cgaTS: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fRead1Product_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaTR: // global
           I64[Hp - 24] = sat_sgapM_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.08431087 UTC

[section ""data" . Data.Functor.Product.$w$cliftShowsPrec_closure" {
     Data.Functor.Product.$w$cliftShowsPrec_closure:
         const Data.Functor.Product.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaUx: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgapV_entry() //  [R1]
         { info_tbl: [(cgaUF,
                       label: sat_sgapV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaUF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgaUG; else goto cgaUH;
       cgaUG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaUH: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgapU_entry() //  [R1]
         { info_tbl: [(cgaUM,
                       label: sat_sgapU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaUM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgaUN; else goto cgaUO;
       cgaUN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaUO: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cgaUP,
                       label: Data.Functor.Product.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, True, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaUP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgaUT; else goto cgaUS;
       cgaUT: // global
           HpAlloc = 80;
           R1 = Data.Functor.Product.$w$cliftShowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cgaUS: // global
           I64[Hp - 72] = sat_sgapV_info;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sgapU_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sgapR::I64 = R6;
           R6 = P64[Sp];
           R5 = _sgapR::I64;
           R4 = Data.Functor.Product.$fRead1Product2_closure;
           R3 = Hp - 72;
           R2 = Hp - 32;
           Sp = Sp + 8;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.094159045 UTC

[section ""data" . Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure" {
     Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure:
         const Data.Functor.Product.$fShow1Product_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$fShow1Product_$cliftShowsPrec_entry() //  [R2,
                                                                  R3, R4, R5, R6]
         { info_tbl: [(cgaVn,
                       label: Data.Functor.Product.$fShow1Product_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaVn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgaVr; else goto cgaVs;
       cgaVr: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgaVs: // global
           I64[Sp - 40] = block_cgaVk_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugaVA; else goto cgaVl;
       ugaVA: // global
           call _cgaVk(R1) args: 0, res: 0, upd: 0;
       cgaVl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaVk() //  [R1]
         { info_tbl: [(cgaVk,
                       label: block_cgaVk_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaVk: // global
           I64[Sp] = block_cgaVq_info;
           _sgaq3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sgaq3::I64;
           if (R1 & 7 != 0) goto ugaVz; else goto cgaVu;
       ugaVz: // global
           call _cgaVq(R1) args: 0, res: 0, upd: 0;
       cgaVu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaVq() //  [R1]
         { info_tbl: [(cgaVq,
                       label: block_cgaVq_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaVq: // global
           R6 = I64[Sp + 40];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.101646158 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct4_closure" {
     Data.Functor.Product.$fFoldableProduct4_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.104073067 UTC

[section ""data" . Data.Functor.Product.$fShow1Product_$cliftShowList_closure" {
     Data.Functor.Product.$fShow1Product_$cliftShowList_closure:
         const Data.Functor.Product.$fShow1Product_$cliftShowList_info;
         const 0;
 },
 sat_sgaqh_entry() //  [R1, R2]
         { info_tbl: [(cgaW5,
                       label: sat_sgaqh_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaW5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgaW6; else goto cgaW7;
       cgaW6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgaW7: // global
           I64[Sp - 40] = block_cgaW2_info;
           _sgaq7::P64 = P64[R1 + 7];
           _sgaq8::P64 = P64[R1 + 15];
           _sgaq9::P64 = P64[R1 + 23];
           _sgaqa::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgaq7::P64;
           P64[Sp - 24] = _sgaq8::P64;
           P64[Sp - 16] = _sgaq9::P64;
           P64[Sp - 8] = _sgaqa::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugaWb; else goto cgaW3;
       ugaWb: // global
           call _cgaW2(R1) args: 0, res: 0, upd: 0;
       cgaW3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaW2() //  [R1]
         { info_tbl: [(cgaW2,
                       label: block_cgaW2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaW2: // global
           R6 = 0;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShow1Product_$cliftShowList_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cgaWc,
                       label: Data.Functor.Product.$fShow1Product_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaWc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgaWg; else goto cgaWf;
       cgaWg: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShow1Product_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgaWf: // global
           I64[Hp - 32] = sat_sgaqh_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 31;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.113645582 UTC

[section ""data" . Data.Functor.Product.$fShow1Product_closure" {
     Data.Functor.Product.$fShow1Product_closure:
         const Data.Functor.Product.$fShow1Product_info;
         const 0;
 },
 sat_sgaql_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgaWG,
                       label: sat_sgaql_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaWG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgaWH; else goto cgaWI;
       cgaWH: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaWI: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Product.$fShow1Product_$cliftShowList_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_sgaqk_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgaWO,
                       label: sat_sgaqk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaWO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgaWP; else goto cgaWQ;
       cgaWP: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaWQ: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Product.$fShow1Product_$cliftShowsPrec_entry(R6,
                                                                          R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShow1Product_entry() //  [R2, R3]
         { info_tbl: [(cgaWS,
                       label: Data.Functor.Product.$fShow1Product_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaWS: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgaWW; else goto cgaWV;
       cgaWW: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShow1Product_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaWV: // global
           I64[Hp - 64] = sat_sgaql_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgaqk_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 36;
           P64[Hp] = Hp - 60;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.122798308 UTC

[section ""data" . Data.Functor.Product.$w$c==_closure" {
     Data.Functor.Product.$w$c==_closure:
         const Data.Functor.Product.$w$c==_info;
 },
 Data.Functor.Product.$w$c==_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaXg: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c==_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 24, res: 0, upd: 8;
     }
 },
 eq_sgaqt_entry() //  [R1]
         { info_tbl: [(cgaXo,
                       label: eq_sgaqt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaXo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgaXp; else goto cgaXq;
       cgaXp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaXq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c==_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgaXx,
                       label: Data.Functor.Product.$w$c==_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaXx: // global
           _sgaqq::P64 = R6;
           _sgaqp::P64 = R5;
           _sgaqo::P64 = R4;
           _sgaqn::P64 = R3;
           _sgaqm::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgaXy; else goto cgaXz;
       cgaXz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgaXB; else goto cgaXA;
       cgaXB: // global
           HpAlloc = 24;
           goto cgaXy;
       cgaXy: // global
           R1 = Data.Functor.Product.$w$c==_closure;
           P64[Sp - 40] = _sgaqm::P64;
           P64[Sp - 32] = _sgaqn::P64;
           P64[Sp - 24] = _sgaqo::P64;
           P64[Sp - 16] = _sgaqp::P64;
           P64[Sp - 8] = _sgaqq::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cgaXA: // global
           I64[Hp - 16] = eq_sgaqt_info;
           P64[Hp] = _sgaqo::P64;
           I64[Sp - 24] = block_cgaXr_info;
           R4 = P64[Sp];
           R3 = _sgaqp::P64;
           _cgaXk::P64 = Hp - 16;
           R2 = _cgaXk::P64;
           R1 = _sgaqm::P64;
           P64[Sp - 16] = _sgaqn::P64;
           P64[Sp - 8] = _sgaqq::P64;
           P64[Sp] = _cgaXk::P64;
           Sp = Sp - 24;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaXr() //  [R1]
         { info_tbl: [(cgaXr,
                       label: block_cgaXr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaXr: // global
           if (R1 & 7 == 1) goto cgaXu; else goto cgaXv;
       cgaXu: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgaXv: // global
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.132523123 UTC

[section ""data" . Data.Functor.Product.$fEqProduct_$c==_closure" {
     Data.Functor.Product.$fEqProduct_$c==_closure:
         const Data.Functor.Product.$fEqProduct_$c==_info;
 },
 Data.Functor.Product.$fEqProduct_$c==_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgaYa,
                       label: Data.Functor.Product.$fEqProduct_$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaYa: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgaYe; else goto cgaYf;
       cgaYe: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEqProduct_$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaYf: // global
           I64[Sp - 40] = block_cgaY7_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugaYn; else goto cgaY8;
       ugaYn: // global
           call _cgaY7(R1) args: 0, res: 0, upd: 0;
       cgaY8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaY7() //  [R1]
         { info_tbl: [(cgaY7,
                       label: block_cgaY7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaY7: // global
           I64[Sp - 8] = block_cgaYd_info;
           _sgaqB::P64 = P64[R1 + 7];
           _sgaqC::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sgaqC::P64;
           P64[Sp + 32] = _sgaqB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugaYm; else goto cgaYh;
       ugaYm: // global
           call _cgaYd(R1) args: 0, res: 0, upd: 0;
       cgaYh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaYd() //  [R1]
         { info_tbl: [(cgaYd,
                       label: block_cgaYd_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaYd: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c==_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.141207098 UTC

[section ""data" . Data.Functor.Product.$fEqProduct_$c/=_closure" {
     Data.Functor.Product.$fEqProduct_$c/=_closure:
         const Data.Functor.Product.$fEqProduct_$c/=_info;
 },
 eq_sgaqR_entry() //  [R1]
         { info_tbl: [(cgaYX,
                       label: eq_sgaqR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaYX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgaYY; else goto cgaYZ;
       cgaYY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaYZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fEqProduct_$c/=_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgaZ0,
                       label: Data.Functor.Product.$fEqProduct_$c/=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaZ0: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgaZ1; else goto cgaZ2;
       cgaZ1: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEqProduct_$c/=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgaZ2: // global
           I64[Sp - 40] = block_cgaYJ_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugaZy; else goto cgaYK;
       ugaZy: // global
           call _cgaYJ(R1) args: 0, res: 0, upd: 0;
       cgaYK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaYJ() //  [R1]
         { info_tbl: [(cgaYJ,
                       label: block_cgaYJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaYJ: // global
           I64[Sp - 8] = block_cgaYO_info;
           _sgaqM::P64 = P64[R1 + 7];
           _sgaqN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sgaqN::P64;
           P64[Sp + 32] = _sgaqM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugaZx; else goto cgaYP;
       ugaZx: // global
           call _cgaYO(R1) args: 0, res: 0, upd: 0;
       cgaYP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaYO() //  [R1]
         { info_tbl: [(cgaYO,
                       label: block_cgaYO_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaYO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgaZ7; else goto cgaZ6;
       cgaZ7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgaZ6: // global
           _sgaqP::P64 = P64[R1 + 7];
           _sgaqQ::P64 = P64[R1 + 15];
           I64[Hp - 16] = eq_sgaqR_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_cgaZ4_info;
           R4 = _sgaqP::P64;
           R3 = P64[Sp + 40];
           _cgaYT::P64 = Hp - 16;
           R2 = _cgaYT::P64;
           R1 = P64[Sp + 16];
           P64[Sp + 32] = _sgaqQ::P64;
           P64[Sp + 40] = _cgaYT::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaZ4() //  [R1]
         { info_tbl: [(cgaZ4,
                       label: block_cgaZ4_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaZ4: // global
           if (R1 & 7 == 1) goto ugaZv; else goto cgaZi;
       ugaZv: // global
           Sp = Sp + 48;
           call _cgaZo() args: 0, res: 0, upd: 0;
       cgaZi: // global
           _cgaYT::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cgaZg_info;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 8];
           R2 = _cgaYT::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgaZg() //  [R1]
         { info_tbl: [(cgaZg,
                       label: block_cgaZg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaZg: // global
           if (R1 & 7 == 1) goto ugaZw; else goto cgaZs;
       ugaZw: // global
           Sp = Sp + 8;
           call _cgaZo() args: 0, res: 0, upd: 0;
       cgaZs: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgaZo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaZo: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.156851621 UTC

[section ""data" . Data.Functor.Product.$fEqProduct_closure" {
     Data.Functor.Product.$fEqProduct_closure:
         const Data.Functor.Product.$fEqProduct_info;
 },
 sat_sgaqY_entry() //  [R1, R2, R3]
         { info_tbl: [(cgb0o,
                       label: sat_sgaqY_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb0o: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fEqProduct_$c/=_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaqX_entry() //  [R1, R2, R3]
         { info_tbl: [(cgb0w,
                       label: sat_sgaqX_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb0w: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fEqProduct_$c==_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fEqProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cgb0A,
                       label: Data.Functor.Product.$fEqProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb0A: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgb0E; else goto cgb0D;
       cgb0E: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fEqProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgb0D: // global
           I64[Hp - 80] = sat_sgaqY_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sgaqX_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 78;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.165931769 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$ccompare_closure" {
     Data.Functor.Product.$fOrdProduct_$ccompare_closure:
         const Data.Functor.Product.$fOrdProduct_$ccompare_info;
 },
 w_sgara_entry() //  [R1]
         { info_tbl: [(cgb1d,
                       label: w_sgara_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb1d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgb1e; else goto cgb1f;
       cgb1e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgb1f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$ccompare_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cgb1g,
                       label: Data.Functor.Product.$fOrdProduct_$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb1g: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cgb1h; else goto cgb1i;
       cgb1h: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgb1i: // global
           I64[Sp - 40] = block_cgb0Z_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugb1F; else goto cgb10;
       ugb1F: // global
           call _cgb0Z(R1) args: 0, res: 0, upd: 0;
       cgb10: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgb0Z() //  [R1]
         { info_tbl: [(cgb0Z,
                       label: block_cgb0Z_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb0Z: // global
           I64[Sp - 8] = block_cgb14_info;
           _sgar5::P64 = P64[R1 + 7];
           _sgar6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sgar6::P64;
           P64[Sp + 32] = _sgar5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugb1E; else goto cgb15;
       ugb1E: // global
           call _cgb14(R1) args: 0, res: 0, upd: 0;
       cgb15: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgb14() //  [R1]
         { info_tbl: [(cgb14,
                       label: block_cgb14_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb14: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgb1n; else goto cgb1m;
       cgb1n: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgb1m: // global
           _sgar8::P64 = P64[R1 + 7];
           _sgar9::P64 = P64[R1 + 15];
           I64[Hp - 16] = w_sgara_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_cgb1k_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           _cgb19::P64 = Hp - 16;
           P64[Sp - 24] = _cgb19::P64;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = _sgar8::P64;
           P64[Sp + 32] = _sgar9::P64;
           P64[Sp + 40] = _cgb19::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgb1k() //  [R1]
         { info_tbl: [(cgb1k,
                       label: block_cgb1k_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb1k: // global
           _cgb1C::P64 = R1 & 7;
           if (_cgb1C::P64 < 3) goto ugb1D; else goto cgb1B;
       ugb1D: // global
           if (_cgb1C::P64 < 2) goto cgb1t; else goto cgb1x;
       cgb1t: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgb1x: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_ppp_info;
           P64[Sp + 24] = P64[Sp + 40];
           _sgar9::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 8];
           P64[Sp + 40] = _sgar9::P64;
           Sp = Sp + 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
       cgb1B: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.179088911 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$cp1Ord_closure" {
     Data.Functor.Product.$fOrdProduct_$cp1Ord_closure:
         const Data.Functor.Product.$fOrdProduct_$cp1Ord_info;
 },
 sat_sgarh_entry() //  [R1]
         { info_tbl: [(cgb2o,
                       label: sat_sgarh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb2o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgb2p; else goto cgb2q;
       cgb2p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgb2q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgarg_entry() //  [R1]
         { info_tbl: [(cgb2v,
                       label: sat_sgarg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb2v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgb2w; else goto cgb2x;
       cgb2w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgb2x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgarf_entry() //  [R1]
         { info_tbl: [(cgb2C,
                       label: sat_sgarf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb2C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgb2D; else goto cgb2E;
       cgb2D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgb2E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$cp1Ord_entry() //  [R2, R3, R4]
         { info_tbl: [(cgb2F,
                       label: Data.Functor.Product.$fOrdProduct_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb2F: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgb2J; else goto cgb2I;
       cgb2J: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$cp1Ord_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgb2I: // global
           I64[Hp - 64] = sat_sgarh_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sgarg_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgarf_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fEqProduct_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.189688056 UTC

[section ""data" . Data.Functor.Product.$w$c<_closure" {
     Data.Functor.Product.$w$c<_closure:
         const Data.Functor.Product.$w$c<_info;
 },
 Data.Functor.Product.$w$c<_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb37: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c<_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sgarp_entry() //  [R1]
         { info_tbl: [(cgb3f,
                       label: comp_sgarp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb3f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgb3g; else goto cgb3h;
       cgb3g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgb3h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgb3p,
                       label: Data.Functor.Product.$w$c<_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb3p: // global
           _sgarm::P64 = R6;
           _sgarl::P64 = R5;
           _sgark::P64 = R4;
           _sgarj::P64 = R3;
           _sgari::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgb3q; else goto cgb3r;
       cgb3r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgb3t; else goto cgb3s;
       cgb3t: // global
           HpAlloc = 24;
           goto cgb3q;
       cgb3q: // global
           R1 = Data.Functor.Product.$w$c<_closure;
           P64[Sp - 40] = _sgari::P64;
           P64[Sp - 32] = _sgarj::P64;
           P64[Sp - 24] = _sgark::P64;
           P64[Sp - 16] = _sgarl::P64;
           P64[Sp - 8] = _sgarm::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cgb3s: // global
           I64[Hp - 16] = comp_sgarp_info;
           P64[Hp] = _sgark::P64;
           I64[Sp - 24] = block_cgb3i_info;
           R2 = _sgari::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cgb3b::P64 = Hp - 16;
           P64[Sp - 48] = _cgb3b::P64;
           P64[Sp - 40] = _sgarl::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sgarj::P64;
           P64[Sp - 8] = _sgarm::P64;
           P64[Sp] = _cgb3b::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgb3i() //  [R1]
         { info_tbl: [(cgb3i,
                       label: block_cgb3i_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb3i: // global
           _cgb3o::P64 = R1 & 7;
           if (_cgb3o::P64 < 3) goto ugb3P; else goto ugb3Q;
       ugb3P: // global
           if (_cgb3o::P64 < 2) goto ugb3R; else goto cgb3m;
       ugb3R: // global
           Sp = Sp + 40;
           call _cgb3K() args: 0, res: 0, upd: 0;
       cgb3m: // global
           _sgaro::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cgb3z_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sgaro::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ugb3Q: // global
           Sp = Sp + 40;
           call _cgb3n() args: 0, res: 0, upd: 0;
     }
 },
 _cgb3z() //  [R1]
         { info_tbl: [(cgb3z,
                       label: block_cgb3z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb3z: // global
           if (R1 & 7 == 1) goto ugb3S; else goto ugb3T;
       ugb3S: // global
           Sp = Sp + 8;
           call _cgb3K() args: 0, res: 0, upd: 0;
       ugb3T: // global
           Sp = Sp + 8;
           call _cgb3n() args: 0, res: 0, upd: 0;
     }
 },
 _cgb3K() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb3K: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgb3n() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb3n: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.203938682 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c<_closure" {
     Data.Functor.Product.$fOrdProduct_$c<_closure:
         const Data.Functor.Product.$fOrdProduct_$c<_info;
 },
 Data.Functor.Product.$fOrdProduct_$c<_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgb4F,
                       label: Data.Functor.Product.$fOrdProduct_$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb4F: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgb4J; else goto cgb4K;
       cgb4J: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgb4K: // global
           I64[Sp - 40] = block_cgb4C_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugb4S; else goto cgb4D;
       ugb4S: // global
           call _cgb4C(R1) args: 0, res: 0, upd: 0;
       cgb4D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgb4C() //  [R1]
         { info_tbl: [(cgb4C,
                       label: block_cgb4C_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb4C: // global
           I64[Sp - 8] = block_cgb4I_info;
           _sgary::P64 = P64[R1 + 7];
           _sgarz::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sgarz::P64;
           P64[Sp + 32] = _sgary::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugb4R; else goto cgb4M;
       ugb4R: // global
           call _cgb4I(R1) args: 0, res: 0, upd: 0;
       cgb4M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgb4I() //  [R1]
         { info_tbl: [(cgb4I,
                       label: block_cgb4I_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb4I: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c<_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.212603866 UTC

[section ""data" . Data.Functor.Product.$w$c>=_closure" {
     Data.Functor.Product.$w$c>=_closure:
         const Data.Functor.Product.$w$c>=_info;
 },
 Data.Functor.Product.$w$c>=_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb5b: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c>=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sgarK_entry() //  [R1]
         { info_tbl: [(cgb5j,
                       label: comp_sgarK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb5j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgb5k; else goto cgb5l;
       cgb5k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgb5l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c>=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgb5t,
                       label: Data.Functor.Product.$w$c>=_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb5t: // global
           _sgarH::P64 = R6;
           _sgarG::P64 = R5;
           _sgarF::P64 = R4;
           _sgarE::P64 = R3;
           _sgarD::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgb5u; else goto cgb5v;
       cgb5v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgb5x; else goto cgb5w;
       cgb5x: // global
           HpAlloc = 24;
           goto cgb5u;
       cgb5u: // global
           R1 = Data.Functor.Product.$w$c>=_closure;
           P64[Sp - 40] = _sgarD::P64;
           P64[Sp - 32] = _sgarE::P64;
           P64[Sp - 24] = _sgarF::P64;
           P64[Sp - 16] = _sgarG::P64;
           P64[Sp - 8] = _sgarH::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cgb5w: // global
           I64[Hp - 16] = comp_sgarK_info;
           P64[Hp] = _sgarF::P64;
           I64[Sp - 24] = block_cgb5m_info;
           R2 = _sgarD::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cgb5f::P64 = Hp - 16;
           P64[Sp - 48] = _cgb5f::P64;
           P64[Sp - 40] = _sgarG::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sgarE::P64;
           P64[Sp - 8] = _sgarH::P64;
           P64[Sp] = _cgb5f::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgb5m() //  [R1]
         { info_tbl: [(cgb5m,
                       label: block_cgb5m_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb5m: // global
           _cgb5s::P64 = R1 & 7;
           if (_cgb5s::P64 < 3) goto ugb5T; else goto ugb5U;
       ugb5T: // global
           if (_cgb5s::P64 < 2) goto ugb5V; else goto cgb5q;
       ugb5V: // global
           Sp = Sp + 40;
           call _cgb5O() args: 0, res: 0, upd: 0;
       cgb5q: // global
           _sgarJ::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cgb5D_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sgarJ::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ugb5U: // global
           Sp = Sp + 40;
           call _cgb5r() args: 0, res: 0, upd: 0;
     }
 },
 _cgb5D() //  [R1]
         { info_tbl: [(cgb5D,
                       label: block_cgb5D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb5D: // global
           if (R1 & 7 == 1) goto ugb5W; else goto ugb5X;
       ugb5W: // global
           Sp = Sp + 8;
           call _cgb5O() args: 0, res: 0, upd: 0;
       ugb5X: // global
           Sp = Sp + 8;
           call _cgb5r() args: 0, res: 0, upd: 0;
     }
 },
 _cgb5O() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb5O: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgb5r() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb5r: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.226380084 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c>=_closure" {
     Data.Functor.Product.$fOrdProduct_$c>=_closure:
         const Data.Functor.Product.$fOrdProduct_$c>=_info;
 },
 Data.Functor.Product.$fOrdProduct_$c>=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cgb6J,
                       label: Data.Functor.Product.$fOrdProduct_$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb6J: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgb6N; else goto cgb6O;
       cgb6N: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgb6O: // global
           I64[Sp - 40] = block_cgb6G_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugb6W; else goto cgb6H;
       ugb6W: // global
           call _cgb6G(R1) args: 0, res: 0, upd: 0;
       cgb6H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgb6G() //  [R1]
         { info_tbl: [(cgb6G,
                       label: block_cgb6G_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb6G: // global
           I64[Sp - 8] = block_cgb6M_info;
           _sgarT::P64 = P64[R1 + 7];
           _sgarU::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sgarU::P64;
           P64[Sp + 32] = _sgarT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugb6V; else goto cgb6Q;
       ugb6V: // global
           call _cgb6M(R1) args: 0, res: 0, upd: 0;
       cgb6Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgb6M() //  [R1]
         { info_tbl: [(cgb6M,
                       label: block_cgb6M_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb6M: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c>=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.238920923 UTC

[section ""data" . Data.Functor.Product.$w$c>_closure" {
     Data.Functor.Product.$w$c>_closure:
         const Data.Functor.Product.$w$c>_info;
 },
 Data.Functor.Product.$w$c>_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb7f: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sgas5_entry() //  [R1]
         { info_tbl: [(cgb7n,
                       label: comp_sgas5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb7n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgb7o; else goto cgb7p;
       cgb7o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgb7p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgb7x,
                       label: Data.Functor.Product.$w$c>_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb7x: // global
           _sgas2::P64 = R6;
           _sgas1::P64 = R5;
           _sgas0::P64 = R4;
           _sgarZ::P64 = R3;
           _sgarY::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgb7y; else goto cgb7z;
       cgb7z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgb7B; else goto cgb7A;
       cgb7B: // global
           HpAlloc = 24;
           goto cgb7y;
       cgb7y: // global
           R1 = Data.Functor.Product.$w$c>_closure;
           P64[Sp - 40] = _sgarY::P64;
           P64[Sp - 32] = _sgarZ::P64;
           P64[Sp - 24] = _sgas0::P64;
           P64[Sp - 16] = _sgas1::P64;
           P64[Sp - 8] = _sgas2::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cgb7A: // global
           I64[Hp - 16] = comp_sgas5_info;
           P64[Hp] = _sgas0::P64;
           I64[Sp - 24] = block_cgb7q_info;
           R2 = _sgarY::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cgb7j::P64 = Hp - 16;
           P64[Sp - 48] = _cgb7j::P64;
           P64[Sp - 40] = _sgas1::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sgarZ::P64;
           P64[Sp - 8] = _sgas2::P64;
           P64[Sp] = _cgb7j::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgb7q() //  [R1]
         { info_tbl: [(cgb7q,
                       label: block_cgb7q_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb7q: // global
           _cgb7w::P64 = R1 & 7;
           if (_cgb7w::P64 < 3) goto ugb7X; else goto ugb7Y;
       ugb7X: // global
           if (_cgb7w::P64 < 2) goto ugb7Z; else goto cgb7u;
       ugb7Z: // global
           Sp = Sp + 40;
           call _cgb7O() args: 0, res: 0, upd: 0;
       cgb7u: // global
           _sgas4::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cgb7H_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sgas4::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ugb7Y: // global
           Sp = Sp + 40;
           call _cgb7v() args: 0, res: 0, upd: 0;
     }
 },
 _cgb7H() //  [R1]
         { info_tbl: [(cgb7H,
                       label: block_cgb7H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb7H: // global
           if (R1 & 7 == 3) goto ugb80; else goto ugb81;
       ugb80: // global
           Sp = Sp + 8;
           call _cgb7v() args: 0, res: 0, upd: 0;
       ugb81: // global
           Sp = Sp + 8;
           call _cgb7O() args: 0, res: 0, upd: 0;
     }
 },
 _cgb7O() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb7O: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgb7v() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb7v: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.25377985 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c>_closure" {
     Data.Functor.Product.$fOrdProduct_$c>_closure:
         const Data.Functor.Product.$fOrdProduct_$c>_info;
 },
 Data.Functor.Product.$fOrdProduct_$c>_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgb8N,
                       label: Data.Functor.Product.$fOrdProduct_$c>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb8N: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgb8R; else goto cgb8S;
       cgb8R: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgb8S: // global
           I64[Sp - 40] = block_cgb8K_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugb90; else goto cgb8L;
       ugb90: // global
           call _cgb8K(R1) args: 0, res: 0, upd: 0;
       cgb8L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgb8K() //  [R1]
         { info_tbl: [(cgb8K,
                       label: block_cgb8K_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb8K: // global
           I64[Sp - 8] = block_cgb8Q_info;
           _sgase::P64 = P64[R1 + 7];
           _sgasf::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sgasf::P64;
           P64[Sp + 32] = _sgase::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugb8Z; else goto cgb8U;
       ugb8Z: // global
           call _cgb8Q(R1) args: 0, res: 0, upd: 0;
       cgb8U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgb8Q() //  [R1]
         { info_tbl: [(cgb8Q,
                       label: block_cgb8Q_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb8Q: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.262567135 UTC

[section ""data" . Data.Functor.Product.$w$c<=_closure" {
     Data.Functor.Product.$w$c<=_closure:
         const Data.Functor.Product.$w$c<=_info;
 },
 Data.Functor.Product.$w$c<=_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb9j: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$c<=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 24, res: 0, upd: 8;
     }
 },
 comp_sgasq_entry() //  [R1]
         { info_tbl: [(cgb9r,
                       label: comp_sgasq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb9r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgb9s; else goto cgb9t;
       cgb9s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgb9t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgb9B,
                       label: Data.Functor.Product.$w$c<=_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb9B: // global
           _sgasn::P64 = R6;
           _sgasm::P64 = R5;
           _sgasl::P64 = R4;
           _sgask::P64 = R3;
           _sgasj::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgb9C; else goto cgb9D;
       cgb9D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgb9F; else goto cgb9E;
       cgb9F: // global
           HpAlloc = 24;
           goto cgb9C;
       cgb9C: // global
           R1 = Data.Functor.Product.$w$c<=_closure;
           P64[Sp - 40] = _sgasj::P64;
           P64[Sp - 32] = _sgask::P64;
           P64[Sp - 24] = _sgasl::P64;
           P64[Sp - 16] = _sgasm::P64;
           P64[Sp - 8] = _sgasn::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cgb9E: // global
           I64[Hp - 16] = comp_sgasq_info;
           P64[Hp] = _sgasl::P64;
           I64[Sp - 24] = block_cgb9u_info;
           R2 = _sgasj::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           _cgb9n::P64 = Hp - 16;
           P64[Sp - 48] = _cgb9n::P64;
           P64[Sp - 40] = _sgasm::P64;
           P64[Sp - 32] = P64[Sp];
           P64[Sp - 16] = _sgask::P64;
           P64[Sp - 8] = _sgasn::P64;
           P64[Sp] = _cgb9n::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgb9u() //  [R1]
         { info_tbl: [(cgb9u,
                       label: block_cgb9u_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb9u: // global
           _cgb9A::P64 = R1 & 7;
           if (_cgb9A::P64 < 3) goto ugba1; else goto ugba2;
       ugba1: // global
           if (_cgb9A::P64 < 2) goto ugba3; else goto cgb9y;
       ugba3: // global
           Sp = Sp + 40;
           call _cgb9S() args: 0, res: 0, upd: 0;
       cgb9y: // global
           _sgasp::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cgb9L_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = _sgasp::P64;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ugba2: // global
           Sp = Sp + 40;
           call _cgb9z() args: 0, res: 0, upd: 0;
     }
 },
 _cgb9L() //  [R1]
         { info_tbl: [(cgb9L,
                       label: block_cgb9L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb9L: // global
           if (R1 & 7 == 3) goto ugba4; else goto ugba5;
       ugba4: // global
           Sp = Sp + 8;
           call _cgb9z() args: 0, res: 0, upd: 0;
       ugba5: // global
           Sp = Sp + 8;
           call _cgb9S() args: 0, res: 0, upd: 0;
     }
 },
 _cgb9S() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb9S: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgb9z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb9z: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.277626346 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$c<=_closure" {
     Data.Functor.Product.$fOrdProduct_$c<=_closure:
         const Data.Functor.Product.$fOrdProduct_$c<=_info;
 },
 Data.Functor.Product.$fOrdProduct_$c<=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cgbaR,
                       label: Data.Functor.Product.$fOrdProduct_$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbaR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgbaV; else goto cgbaW;
       cgbaV: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbaW: // global
           I64[Sp - 40] = block_cgbaO_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbb4; else goto cgbaP;
       ugbb4: // global
           call _cgbaO(R1) args: 0, res: 0, upd: 0;
       cgbaP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbaO() //  [R1]
         { info_tbl: [(cgbaO,
                       label: block_cgbaO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbaO: // global
           I64[Sp - 8] = block_cgbaU_info;
           _sgasz::P64 = P64[R1 + 7];
           _sgasA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sgasA::P64;
           P64[Sp + 32] = _sgasz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugbb3; else goto cgbaY;
       ugbb3: // global
           call _cgbaU(R1) args: 0, res: 0, upd: 0;
       cgbaY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbaU() //  [R1]
         { info_tbl: [(cgbaU,
                       label: block_cgbaU_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbaU: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$c<=_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.286939234 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$cmax_closure" {
     Data.Functor.Product.$fOrdProduct_$cmax_closure:
         const Data.Functor.Product.$fOrdProduct_$cmax_info;
 },
 comp_sgasP_entry() //  [R1]
         { info_tbl: [(cgbbE,
                       label: comp_sgasP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbbE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbbF; else goto cgbbG;
       cgbbF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbbG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$cmax_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cgbbH,
                       label: Data.Functor.Product.$fOrdProduct_$cmax_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbbH: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cgbbI; else goto cgbbJ;
       cgbbI: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$cmax_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbbJ: // global
           I64[Sp - 40] = block_cgbbq_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbcm; else goto cgbbr;
       ugbcm: // global
           call _cgbbq(R1) args: 0, res: 0, upd: 0;
       cgbbr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbbq() //  [R1]
         { info_tbl: [(cgbbq,
                       label: block_cgbbq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbbq: // global
           I64[Sp - 16] = block_cgbbv_info;
           _sgasJ::P64 = R1;
           _sgasK::P64 = P64[R1 + 7];
           _sgasL::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _sgasL::P64;
           P64[Sp] = _sgasK::P64;
           P64[Sp + 32] = _sgasJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugbcl; else goto cgbbw;
       ugbcl: // global
           call _cgbbv(R1) args: 0, res: 0, upd: 0;
       cgbbw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbbv() //  [R1]
         { info_tbl: [(cgbbv,
                       label: block_cgbbv_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbbv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgbbO; else goto cgbbN;
       cgbbO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgbbN: // global
           _sgasN::P64 = P64[R1 + 7];
           _sgasO::P64 = P64[R1 + 15];
           I64[Hp - 16] = comp_sgasP_info;
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_cgbbL_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_ppp_info;
           _cgbbA::P64 = Hp - 16;
           P64[Sp - 24] = _cgbbA::P64;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = _sgasN::P64;
           P64[Sp + 16] = _sgasO::P64;
           P64[Sp + 24] = R1;
           P64[Sp + 40] = _cgbbA::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgbbL() //  [R1]
         { info_tbl: [(cgbbL,
                       label: block_cgbbL_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbbL: // global
           _cgbce::P64 = R1 & 7;
           if (_cgbce::P64 < 3) goto ugbcg; else goto ugbch;
       ugbcg: // global
           if (_cgbce::P64 < 2) goto ugbci; else goto cgbbZ;
       ugbci: // global
           Sp = Sp + 24;
           call _cgbc5() args: 0, res: 0, upd: 0;
       cgbbZ: // global
           _sgasO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cgbbX_info;
           R2 = P64[Sp + 32];
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _sgasO::P64;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ugbch: // global
           Sp = Sp + 48;
           call _cgbcd() args: 0, res: 0, upd: 0;
     }
 },
 _cgbbX() //  [R1]
         { info_tbl: [(cgbbX,
                       label: block_cgbbX_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbbX: // global
           if (R1 & 7 == 3) goto ugbcj; else goto ugbck;
       ugbcj: // global
           Sp = Sp + 32;
           call _cgbcd() args: 0, res: 0, upd: 0;
       ugbck: // global
           Sp = Sp + 8;
           call _cgbc5() args: 0, res: 0, upd: 0;
     }
 },
 _cgbc5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbc5: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgbcd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbcd: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.30313175 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_$cmin_closure" {
     Data.Functor.Product.$fOrdProduct_$cmin_closure:
         const Data.Functor.Product.$fOrdProduct_$cmin_info;
 },
 comp_sgat3_entry() //  [R1]
         { info_tbl: [(cgbdt,
                       label: comp_sgat3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbdt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbdu; else goto cgbdv;
       cgbdu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbdv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_$cmin_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cgbdw,
                       label: Data.Functor.Product.$fOrdProduct_$cmin_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbdw: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cgbdx; else goto cgbdy;
       cgbdx: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_$cmin_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbdy: // global
           I64[Sp - 40] = block_cgbdf_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbeb; else goto cgbdg;
       ugbeb: // global
           call _cgbdf(R1) args: 0, res: 0, upd: 0;
       cgbdg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbdf() //  [R1]
         { info_tbl: [(cgbdf,
                       label: block_cgbdf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbdf: // global
           I64[Sp - 16] = block_cgbdk_info;
           _sgasX::P64 = R1;
           _sgasY::P64 = P64[R1 + 7];
           _sgasZ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _sgasZ::P64;
           P64[Sp] = _sgasY::P64;
           P64[Sp + 32] = _sgasX::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugbea; else goto cgbdl;
       ugbea: // global
           call _cgbdk(R1) args: 0, res: 0, upd: 0;
       cgbdl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbdk() //  [R1]
         { info_tbl: [(cgbdk,
                       label: block_cgbdk_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbdk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgbdD; else goto cgbdC;
       cgbdD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgbdC: // global
           _sgat1::P64 = P64[R1 + 7];
           _sgat2::P64 = P64[R1 + 15];
           I64[Hp - 16] = comp_sgat3_info;
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_cgbdA_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_ppp_info;
           _cgbdp::P64 = Hp - 16;
           P64[Sp - 24] = _cgbdp::P64;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = _sgat1::P64;
           P64[Sp + 16] = _sgat2::P64;
           P64[Sp + 24] = R1;
           P64[Sp + 40] = _cgbdp::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgbdA() //  [R1]
         { info_tbl: [(cgbdA,
                       label: block_cgbdA_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbdA: // global
           _cgbe3::P64 = R1 & 7;
           if (_cgbe3::P64 < 3) goto ugbe5; else goto ugbe6;
       ugbe5: // global
           if (_cgbe3::P64 < 2) goto ugbe7; else goto cgbdO;
       ugbe7: // global
           Sp = Sp + 48;
           call _cgbdU() args: 0, res: 0, upd: 0;
       cgbdO: // global
           _sgat2::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cgbdM_info;
           R2 = P64[Sp + 32];
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = _sgat2::P64;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
       ugbe6: // global
           Sp = Sp + 24;
           call _cgbe2() args: 0, res: 0, upd: 0;
     }
 },
 _cgbdM() //  [R1]
         { info_tbl: [(cgbdM,
                       label: block_cgbdM_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbdM: // global
           if (R1 & 7 == 3) goto ugbe8; else goto ugbe9;
       ugbe8: // global
           Sp = Sp + 8;
           call _cgbe2() args: 0, res: 0, upd: 0;
       ugbe9: // global
           Sp = Sp + 32;
           call _cgbdU() args: 0, res: 0, upd: 0;
     }
 },
 _cgbdU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbdU: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgbe2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbe2: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.319946335 UTC

[section ""data" . Data.Functor.Product.$fOrdProduct_closure" {
     Data.Functor.Product.$fOrdProduct_closure:
         const Data.Functor.Product.$fOrdProduct_info;
 },
 sat_sgatg_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbf9,
                       label: sat_sgatg_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbf9: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$cmin_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgatf_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbfh,
                       label: sat_sgatf_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbfh: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$cmax_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgate_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbfp,
                       label: sat_sgate_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbfp: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c>=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgatd_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbfx,
                       label: sat_sgatd_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbfx: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c>_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgatc_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbfF,
                       label: sat_sgatc_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbfF: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c<=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgatb_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbfN,
                       label: sat_sgatb_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbfN: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$c<_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgata_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbfV,
                       label: sat_sgata_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbfV: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fOrdProduct_$ccompare_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgat9_entry() //  [R1]
         { info_tbl: [(cgbg2,
                       label: sat_sgat9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbg2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbg3; else goto cgbg4;
       cgbg3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbg4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fOrdProduct_$cp1Ord_entry(R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fOrdProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cgbg6,
                       label: Data.Functor.Product.$fOrdProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbg6: // global
           Hp = Hp + 336;
           if (Hp > HpLim) (likely: False) goto cgbga; else goto cgbg9;
       cgbga: // global
           HpAlloc = 336;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fOrdProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbg9: // global
           I64[Hp - 328] = sat_sgatg_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           I64[Hp - 296] = sat_sgatf_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           P64[Hp - 272] = R4;
           I64[Hp - 264] = sat_sgate_info;
           P64[Hp - 256] = R2;
           P64[Hp - 248] = R3;
           P64[Hp - 240] = R4;
           I64[Hp - 232] = sat_sgatd_info;
           P64[Hp - 224] = R2;
           P64[Hp - 216] = R3;
           P64[Hp - 208] = R4;
           I64[Hp - 200] = sat_sgatc_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           P64[Hp - 176] = R4;
           I64[Hp - 168] = sat_sgatb_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = sat_sgata_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sat_sgat9_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 104;
           P64[Hp - 48] = Hp - 134;
           P64[Hp - 40] = Hp - 166;
           P64[Hp - 32] = Hp - 198;
           P64[Hp - 24] = Hp - 230;
           P64[Hp - 16] = Hp - 262;
           P64[Hp - 8] = Hp - 294;
           P64[Hp] = Hp - 326;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.339528954 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadPrec_closure" {
     Data.Functor.Product.$fReadProduct_$creadPrec_closure:
         const Data.Functor.Product.$fReadProduct_$creadPrec_info;
         const 0;
 },
 sat_sgatl_entry() //  [R1]
         { info_tbl: [(cgbh5,
                       label: sat_sgatl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbh5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbh6; else goto cgbh7;
       cgbh6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbh7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgatk_entry() //  [R1]
         { info_tbl: [(cgbhc,
                       label: sat_sgatk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbhc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbhd; else goto cgbhe;
       cgbhd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbhe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgbhf,
                       label: Data.Functor.Product.$fReadProduct_$creadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbhf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgbhj; else goto cgbhi;
       cgbhj: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbhi: // global
           I64[Hp - 40] = sat_sgatl_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgatk_info;
           P64[Hp] = R4;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.348078919 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadsPrec_closure" {
     Data.Functor.Product.$fReadProduct_$creadsPrec_closure:
         const Data.Functor.Product.$fReadProduct_$creadsPrec_info;
         const 0;
 },
 sat_sgatr_entry() //  [R1]
         { info_tbl: [(cgbhM,
                       label: sat_sgatr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbhM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbhN; else goto cgbhO;
       cgbhN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbhO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgatq_entry() //  [R1]
         { info_tbl: [(cgbhT,
                       label: sat_sgatq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbhT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbhU; else goto cgbhV;
       cgbhU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbhV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sgatp_entry() //  [R1]
         { info_tbl: [(cgbhW,
                       label: ds_sgatp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbhW: // global
           _sgatp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgbhX; else goto cgbhY;
       cgbhY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgbi0; else goto cgbhZ;
       cgbi0: // global
           HpAlloc = 48;
           goto cgbhX;
       cgbhX: // global
           R1 = _sgatp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbhZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgatp::P64;
           _sgatm::P64 = P64[_sgatp::P64 + 16];
           _sgatn::P64 = P64[_sgatp::P64 + 24];
           _sgato::P64 = P64[_sgatp::P64 + 32];
           I64[Hp - 40] = sat_sgatr_info;
           P64[Hp - 24] = _sgato::P64;
           I64[Hp - 16] = sat_sgatq_info;
           P64[Hp] = _sgato::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sgatn::P64;
           R2 = _sgatm::P64;
           Sp = Sp - 16;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgatt_entry() //  [R1]
         { info_tbl: [(cgbia,
                       label: sat_sgatt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbia: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbib; else goto cgbic;
       cgbib: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbic: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgatu_entry() //  [R1, R2]
         { info_tbl: [(cgbid,
                       label: sat_sgatu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbid: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgbih; else goto cgbig;
       cgbih: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgbig: // global
           _sgatp::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgatt_info;
           P64[Hp - 8] = _sgatp::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cgbii,
                       label: Data.Functor.Product.$fReadProduct_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbii: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgbim; else goto cgbil;
       cgbim: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbil: // global
           I64[Hp - 48] = ds_sgatp_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sgatu_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.362947399 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadListPrec_closure" {
     Data.Functor.Product.$fReadProduct_$creadListPrec_closure:
         const Data.Functor.Product.$fReadProduct_$creadListPrec_info;
         const 0;
 },
 sat_sgatz_entry() //  [R1]
         { info_tbl: [(cgbj9,
                       label: sat_sgatz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbj9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbja; else goto cgbjb;
       cgbja: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbjb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaty_entry() //  [R1]
         { info_tbl: [(cgbjg,
                       label: sat_sgaty_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbjg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbjh; else goto cgbji;
       cgbjh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbji: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgatA_entry() //  [R1]
         { info_tbl: [(cgbjj,
                       label: sat_sgatA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbjj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgbjn; else goto cgbjm;
       cgbjn: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbjm: // global
           _sgatv::P64 = P64[R1 + 16];
           _sgatw::P64 = P64[R1 + 24];
           _sgatx::P64 = P64[R1 + 32];
           I64[Hp - 40] = sat_sgatz_info;
           P64[Hp - 24] = _sgatx::P64;
           I64[Hp - 16] = sat_sgaty_info;
           P64[Hp] = _sgatx::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sgatw::P64;
           R2 = _sgatv::P64;
           call Data.Functor.Product.$fRead1Product_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadListPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cgbjo,
                       label: Data.Functor.Product.$fReadProduct_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbjo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgbjs; else goto cgbjr;
       cgbjs: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbjr: // global
           I64[Hp - 32] = sat_sgatA_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.374183587 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_$creadList_closure" {
     Data.Functor.Product.$fReadProduct_$creadList_closure:
         const Data.Functor.Product.$fReadProduct_$creadList_info;
         const 0;
 },
 sat_sgatE_entry() //  [R1]
         { info_tbl: [(cgbjV,
                       label: sat_sgatE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbjV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbjW; else goto cgbjX;
       cgbjW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbjX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call Data.Functor.Product.$fReadProduct_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fReadProduct_$creadList_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgbjY,
                       label: Data.Functor.Product.$fReadProduct_$creadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbjY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgbk2; else goto cgbk1;
       cgbk2: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_$creadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbk1: // global
           I64[Hp - 32] = sat_sgatE_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.381182084 UTC

[section ""data" . Data.Functor.Product.$fReadProduct_closure" {
     Data.Functor.Product.$fReadProduct_closure:
         const Data.Functor.Product.$fReadProduct_info;
         const 0;
 },
 sat_sgatL_entry() //  [R1]
         { info_tbl: [(cgbkq,
                       label: sat_sgatL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbkq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbkr; else goto cgbks;
       cgbkr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbks: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgatK_entry() //  [R1]
         { info_tbl: [(cgbkx,
                       label: sat_sgatK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbkx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbky; else goto cgbkz;
       cgbky: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbkz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgatJ_entry() //  [R1]
         { info_tbl: [(cgbkE,
                       label: sat_sgatJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbkE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbkF; else goto cgbkG;
       cgbkF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbkG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadList_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgatI_entry() //  [R1]
         { info_tbl: [(cgbkL,
                       label: sat_sgatI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbkL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbkM; else goto cgbkN;
       cgbkM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbkN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fReadProduct_$creadsPrec_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fReadProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cgbkP,
                       label: Data.Functor.Product.$fReadProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbkP: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cgbkT; else goto cgbkS;
       cgbkT: // global
           HpAlloc = 200;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fReadProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbkS: // global
           I64[Hp - 192] = sat_sgatL_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           I64[Hp - 152] = sat_sgatK_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_sgatJ_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sgatI_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.394348437 UTC

[section ""data" . Data.Functor.Product.$w$cshowsPrec_closure" {
     Data.Functor.Product.$w$cshowsPrec_closure:
         const Data.Functor.Product.$w$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgblt: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$w$cshowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 16, res: 0, upd: 8;
     }
 },
 sp_sgatS_entry() //  [R1]
         { info_tbl: [(cgblB,
                       label: sp_sgatS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgblB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgblC; else goto cgblD;
       cgblC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgblD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sl_sgatT_entry() //  [R1]
         { info_tbl: [(cgblI,
                       label: sl_sgatT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgblI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgblJ; else goto cgblK;
       cgblJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgblK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgatV_entry() //  [R1]
         { info_tbl: [(cgblP,
                       label: sat_sgatV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgblP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgblQ; else goto cgblR;
       cgblQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgblR: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgatU_entry() //  [R1]
         { info_tbl: [(cgblW,
                       label: sat_sgatU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgblW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgblX; else goto cgblY;
       cgblX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgblY: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$w$cshowsPrec_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgblZ,
                       label: Data.Functor.Product.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgblZ: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgbm3; else goto cgbm2;
       cgbm3: // global
           HpAlloc = 128;
           R1 = Data.Functor.Product.$w$cshowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cgbm2: // global
           I64[Hp - 120] = sp_sgatS_info;
           P64[Hp - 104] = R4;
           I64[Hp - 96] = sl_sgatT_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sgatV_info;
           P64[Hp - 56] = R3;
           _cgblx::P64 = Hp - 120;
           P64[Hp - 48] = _cgblx::P64;
           _cgblE::P64 = Hp - 96;
           P64[Hp - 40] = _cgblE::P64;
           I64[Hp - 32] = sat_sgatU_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cgblx::P64;
           P64[Hp] = _cgblE::P64;
           R6 = R6;
           R5 = R5;
           R4 = Data.Functor.Product.$fRead1Product2_closure;
           R3 = Hp - 72;
           R2 = Hp - 32;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.408159782 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_$cshowsPrec_closure" {
     Data.Functor.Product.$fShowProduct_$cshowsPrec_closure:
         const Data.Functor.Product.$fShowProduct_$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Product.$fShowProduct_$cshowsPrec_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cgbmJ,
                       label: Data.Functor.Product.$fShowProduct_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbmJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbmN; else goto cgbmO;
       cgbmN: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_$cshowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbmO: // global
           I64[Sp - 40] = block_cgbmG_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbmW; else goto cgbmH;
       ugbmW: // global
           call _cgbmG(R1) args: 0, res: 0, upd: 0;
       cgbmH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbmG() //  [R1]
         { info_tbl: [(cgbmG,
                       label: block_cgbmG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbmG: // global
           I64[Sp] = block_cgbmM_info;
           _sgau2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _sgau2::I64;
           if (R1 & 7 != 0) goto ugbmV; else goto cgbmQ;
       ugbmV: // global
           call _cgbmM(R1) args: 0, res: 0, upd: 0;
       cgbmQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbmM() //  [R1]
         { info_tbl: [(cgbmM,
                       label: block_cgbmM_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbmM: // global
           R6 = P64[R1 + 7];
           R5 = I64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cshowsPrec_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.418047471 UTC

[section ""data" . Data.Functor.Product.$w$cshow_closure" {
     Data.Functor.Product.$w$cshow_closure:
         const Data.Functor.Product.$w$cshow_info;
         const 0;
 },
 sp_sgaub_entry() //  [R1]
         { info_tbl: [(cgbnl,
                       label: sp_sgaub_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbnl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbnm; else goto cgbnn;
       cgbnm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbnn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sl_sgauc_entry() //  [R1]
         { info_tbl: [(cgbns,
                       label: sl_sgauc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbns: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbnt; else goto cgbnu;
       cgbnt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbnu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaud_entry() //  [R1]
         { info_tbl: [(cgbnD,
                       label: sat_sgaud_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbnD: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cgbnE; else goto cgbnF;
       cgbnE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbnF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = P64[R1 + 32];
           P64[Sp - 48] = P64[R1 + 40];
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 sat_sgauf_entry() //  [R1]
         { info_tbl: [(cgbnH,
                       label: sat_sgauf_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbnH: // global
           _sgauf::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cgbnI; else goto cgbnJ;
       cgbnJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgbnL; else goto cgbnK;
       cgbnL: // global
           HpAlloc = 72;
           goto cgbnI;
       cgbnI: // global
           R1 = _sgauf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbnK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgauf::P64;
           _sgau6::P64 = P64[_sgauf::P64 + 16];
           _sgau7::P64 = P64[_sgauf::P64 + 24];
           _sgau9::P64 = P64[_sgauf::P64 + 32];
           _sgaua::P64 = P64[_sgauf::P64 + 40];
           _sgaub::P64 = P64[_sgauf::P64 + 48];
           _sgauc::P64 = P64[_sgauf::P64 + 56];
           I64[Hp - 64] = sat_sgaud_info;
           P64[Hp - 48] = _sgau7::P64;
           P64[Hp - 40] = _sgaua::P64;
           P64[Hp - 32] = _sgaub::P64;
           P64[Hp - 24] = _sgauc::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 64;
           R2 = _sgau6::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = _sgaub::P64;
           P64[Sp - 48] = _sgauc::P64;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sgau9::P64;
           P64[Sp - 24] = Hp - 14;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cshow_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgbnN,
                       label: Data.Functor.Product.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbnN: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cgbnR; else goto cgbnQ;
       cgbnR: // global
           HpAlloc = 136;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$cshow_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbnQ: // global
           I64[Hp - 128] = sp_sgaub_info;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sl_sgauc_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_sgauf_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = R6;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 80;
           R3 = Hp - 14;
           R2 = Data.Functor.Product.$fRead1Product2_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.432019556 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_$cshow_closure" {
     Data.Functor.Product.$fShowProduct_$cshow_closure:
         const Data.Functor.Product.$fShowProduct_$cshow_info;
         const 0;
 },
 Data.Functor.Product.$fShowProduct_$cshow_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cgboJ,
                       label: Data.Functor.Product.$fShowProduct_$cshow_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgboJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgboK; else goto cgboL;
       cgboK: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_$cshow_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgboL: // global
           I64[Sp - 32] = block_cgboG_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugboP; else goto cgboH;
       ugboP: // global
           call _cgboG(R1) args: 0, res: 0, upd: 0;
       cgboH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgboG() //  [R1]
         { info_tbl: [(cgboG,
                       label: block_cgboG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgboG: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cshow_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.438757694 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_$cshowList_closure" {
     Data.Functor.Product.$fShowProduct_$cshowList_closure:
         const Data.Functor.Product.$fShowProduct_$cshowList_info;
         const 0;
 },
 lvl9_sgaut_entry() //  [R1]
         { info_tbl: [(cgbp8,
                       label: lvl9_sgaut_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbp8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbp9; else goto cgbpa;
       cgbp9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbpa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl10_sgauu_entry() //  [R1]
         { info_tbl: [(cgbpf,
                       label: lvl10_sgauu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbpf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbpg; else goto cgbph;
       cgbpg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbph: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgauz_entry() //  [R1, R2]
         { info_tbl: [(cgbpq,
                       label: sat_sgauz_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbpq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbpr; else goto cgbps;
       cgbpr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgbps: // global
           I64[Sp - 40] = block_cgbpn_info;
           _sgauo::P64 = P64[R1 + 7];
           _sgaup::P64 = P64[R1 + 15];
           _sgaut::P64 = P64[R1 + 23];
           _sgauu::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgauo::P64;
           P64[Sp - 24] = _sgaup::P64;
           P64[Sp - 16] = _sgaut::P64;
           P64[Sp - 8] = _sgauu::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbpw; else goto cgbpo;
       ugbpw: // global
           call _cgbpn(R1) args: 0, res: 0, upd: 0;
       cgbpo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbpn() //  [R1]
         { info_tbl: [(cgbpn,
                       label: block_cgbpn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbpn: // global
           R6 = 0;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShowProduct_$cshowList_entry() //  [R2, R3,
                                                            R4, R5, R6]
         { info_tbl: [(cgbpx,
                       label: Data.Functor.Product.$fShowProduct_$cshowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbpx: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgbpB; else goto cgbpA;
       cgbpB: // global
           HpAlloc = 88;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_$cshowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbpA: // global
           I64[Hp - 80] = lvl9_sgaut_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl10_sgauu_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sgauz_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 31;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.451357607 UTC

[section ""data" . Data.Functor.Product.$fShowProduct_closure" {
     Data.Functor.Product.$fShowProduct_closure:
         const Data.Functor.Product.$fShowProduct_info;
         const 0;
 },
 sat_sgauF_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbqf,
                       label: sat_sgauF_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbqf: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fShowProduct_$cshowList_entry(R6,
                                                                    R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgauE_entry() //  [R1, R2]
         { info_tbl: [(cgbqn,
                       label: sat_sgauE_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbqn: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fShowProduct_$cshow_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgauD_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbqv,
                       label: sat_sgauD_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbqv: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fShowProduct_$cshowsPrec_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fShowProduct_entry() //  [R2, R3, R4]
         { info_tbl: [(cgbqz,
                       label: Data.Functor.Product.$fShowProduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbqz: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgbqD; else goto cgbqC;
       cgbqD: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fShowProduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbqC: // global
           I64[Hp - 120] = sat_sgauF_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sgauE_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sgauD_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 118;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.462263792 UTC

[section ""data" . Data.Functor.Product.$fFunctorProduct_$cfmap_closure" {
     Data.Functor.Product.$fFunctorProduct_$cfmap_closure:
         const Data.Functor.Product.$fFunctorProduct_$cfmap_info;
 },
 sat_sgauO_entry() //  [R1]
         { info_tbl: [(cgbrc,
                       label: sat_sgauO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbrc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbrd; else goto cgbre;
       cgbrd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbre: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgauN_entry() //  [R1]
         { info_tbl: [(cgbrj,
                       label: sat_sgauN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbrj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbrk; else goto cgbrl;
       cgbrk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbrl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFunctorProduct_$cfmap_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cgbrm,
                       label: Data.Functor.Product.$fFunctorProduct_$cfmap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbrm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgbro; else goto cgbrp;
       cgbro: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFunctorProduct_$cfmap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbrp: // global
           I64[Sp - 32] = block_cgbr3_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugbrt; else goto cgbr4;
       ugbrt: // global
           call _cgbr3(R1) args: 0, res: 0, upd: 0;
       cgbr4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbr3() //  [R1]
         { info_tbl: [(cgbr3,
                       label: block_cgbr3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbr3: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgbrs; else goto cgbrr;
       cgbrs: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgbrr: // global
           _sgauL::P64 = P64[R1 + 7];
           _sgauM::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgauO_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sgauI::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sgauI::P64;
           P64[Hp - 64] = _sgauM::P64;
           I64[Hp - 56] = sat_sgauN_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgauI::P64;
           P64[Hp - 24] = _sgauL::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.473236441 UTC

[section ""data" . Data.Functor.Product.$fFunctorProduct_$c<$_closure" {
     Data.Functor.Product.$fFunctorProduct_$c<$_closure:
         const Data.Functor.Product.$fFunctorProduct_$c<$_info;
 },
 f1_sgauW_entry() //  [R1]
         { info_tbl: [(cgbsg,
                       label: f1_sgauW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbsg: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgauZ_entry() //  [R1]
         { info_tbl: [(cgbsn,
                       label: sat_sgauZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbsn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbso; else goto cgbsp;
       cgbso: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbsp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgauY_entry() //  [R1]
         { info_tbl: [(cgbsu,
                       label: sat_sgauY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbsu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbsv; else goto cgbsw;
       cgbsv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbsw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFunctorProduct_$c<$_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgbsx,
                       label: Data.Functor.Product.$fFunctorProduct_$c<$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbsx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgbsz; else goto cgbsA;
       cgbsz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFunctorProduct_$c<$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbsA: // global
           I64[Sp - 32] = block_cgbs6_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugbsE; else goto cgbs7;
       ugbsE: // global
           call _cgbs6(R1) args: 0, res: 0, upd: 0;
       cgbs7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbs6() //  [R1]
         { info_tbl: [(cgbs6,
                       label: block_cgbs6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbs6: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cgbsD; else goto cgbsC;
       cgbsD: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgbsC: // global
           _sgauU::P64 = P64[R1 + 7];
           _sgauV::P64 = P64[R1 + 15];
           I64[Hp - 112] = f1_sgauW_info;
           P64[Hp - 104] = P64[Sp + 24];
           I64[Hp - 96] = sat_sgauZ_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sgauV::P64;
           _cgbsb::P64 = Hp - 111;
           P64[Hp - 64] = _cgbsb::P64;
           I64[Hp - 56] = sat_sgauY_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgauU::P64;
           P64[Hp - 24] = _cgbsb::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.485751082 UTC

[section ""data" . Data.Functor.Product.$fFunctorProduct_closure" {
     Data.Functor.Product.$fFunctorProduct_closure:
         const Data.Functor.Product.$fFunctorProduct_info;
 },
 sat_sgav3_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbtr,
                       label: sat_sgav3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbtr: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFunctorProduct_$c<$_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgav2_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbtz,
                       label: sat_sgav2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbtz: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFunctorProduct_$cfmap_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFunctorProduct_entry() //  [R2, R3]
         { info_tbl: [(cgbtD,
                       label: Data.Functor.Product.$fFunctorProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbtD: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgbtH; else goto cgbtG;
       cgbtH: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFunctorProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbtG: // global
           I64[Hp - 64] = sat_sgav3_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgav2_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.493453689 UTC

[section ""data" . Data.Functor.Product.$w$cfoldMap_closure" {
     Data.Functor.Product.$w$cfoldMap_closure:
         const Data.Functor.Product.$w$cfoldMap_info;
 },
 sat_sgavb_entry() //  [R1]
         { info_tbl: [(cgbu6,
                       label: sat_sgavb_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbu6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgbu7; else goto cgbu8;
       cgbu7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbu8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sgava_entry() //  [R1]
         { info_tbl: [(cgbud,
                       label: sat_sgava_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbud: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgbue; else goto cgbuf;
       cgbue: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbuf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldMap_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgbug,
                       label: Data.Functor.Product.$w$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbug: // global
           _sgav8::P64 = R6;
           _sgav7::P64 = R5;
           _sgav6::P64 = R4;
           _sgav5::P64 = R3;
           _sgav4::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgbuh; else goto cgbui;
       cgbui: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgbuk; else goto cgbuj;
       cgbuk: // global
           HpAlloc = 96;
           goto cgbuh;
       cgbuh: // global
           R6 = _sgav8::P64;
           R5 = _sgav7::P64;
           R4 = _sgav6::P64;
           R3 = _sgav5::P64;
           R2 = _sgav4::P64;
           R1 = Data.Functor.Product.$w$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgbuj: // global
           I64[Hp - 88] = sat_sgavb_info;
           P64[Hp - 72] = _sgav5::P64;
           P64[Hp - 64] = _sgav6::P64;
           P64[Hp - 56] = _sgav7::P64;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = sat_sgava_info;
           P64[Hp - 24] = _sgav4::P64;
           P64[Hp - 16] = _sgav6::P64;
           P64[Hp - 8] = _sgav7::P64;
           P64[Hp] = _sgav8::P64;
           R2 = _sgav6::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = Hp - 40;
           P64[Sp] = Hp - 88;
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.503015923 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldMap_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldMap_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldMap_info;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldMap_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cgbuV,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbuV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbuW; else goto cgbuX;
       cgbuW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbuX: // global
           I64[Sp - 40] = block_cgbuS_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbv1; else goto cgbuT;
       ugbv1: // global
           call _cgbuS(R1) args: 0, res: 0, upd: 0;
       cgbuT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbuS() //  [R1]
         { info_tbl: [(cgbuS,
                       label: block_cgbuS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbuS: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldMap_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.509142489 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfold_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfold_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfold_info;
 },
 Data.Functor.Product.$fFoldableProduct_$cfold_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cgbvk,
                       label: Data.Functor.Product.$fFoldableProduct_$cfold_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbvk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgbvl; else goto cgbvm;
       cgbvl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfold_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbvm: // global
           I64[Sp - 32] = block_cgbvh_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugbvq; else goto cgbvi;
       ugbvq: // global
           call _cgbvh(R1) args: 0, res: 0, upd: 0;
       cgbvi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbvh() //  [R1]
         { info_tbl: [(cgbvh,
                       label: block_cgbvh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbvh: // global
           R6 = P64[R1 + 7];
           R5 = GHC.Base.id_closure+1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$cfoldMap_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.515303398 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct1_closure" {
     Data.Functor.Product.$fFoldableProduct1_closure:
         const Data.Functor.Product.$fFoldableProduct1_info;
 },
 Data.Functor.Product.$fFoldableProduct1_entry() //  [R2]
         { info_tbl: [(cgbvH,
                       label: Data.Functor.Product.$fFoldableProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbvH: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.519765094 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$csum_closure" {
     Data.Functor.Product.$fFoldableProduct_$csum_closure:
         const Data.Functor.Product.$fFoldableProduct_$csum_info;
         const 0;
 },
 $dMonoid_sgavv_entry() //  [R1]
         { info_tbl: [(cgbvW,
                       label: $dMonoid_sgavv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbvW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbvX; else goto cgbvY;
       cgbvX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbvY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgavB_entry() //  [R1]
         { info_tbl: [(cgbwd,
                       label: sat_sgavB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbwd: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgbwe; else goto cgbwf;
       cgbwe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbwf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sgavA_entry() //  [R1]
         { info_tbl: [(cgbwk,
                       label: sat_sgavA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbwk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgbwl; else goto cgbwm;
       cgbwl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbwm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sgavC_entry() //  [R1, R2]
         { info_tbl: [(cgbwn,
                       label: sat_sgavC_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbwn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbwo; else goto cgbwp;
       cgbwo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgbwp: // global
           I64[Sp - 40] = block_cgbw4_info;
           _sgavs::P64 = P64[R1 + 7];
           _sgavt::P64 = P64[R1 + 15];
           _sgavu::P64 = P64[R1 + 23];
           _sgavv::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgavs::P64;
           P64[Sp - 24] = _sgavt::P64;
           P64[Sp - 16] = _sgavu::P64;
           P64[Sp - 8] = _sgavv::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbwt; else goto cgbw5;
       ugbwt: // global
           call _cgbw4(R1) args: 0, res: 0, upd: 0;
       cgbw5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbw4() //  [R1]
         { info_tbl: [(cgbw4,
                       label: block_cgbw4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbw4: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgbws; else goto cgbwr;
       cgbws: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgbwr: // global
           _sgavy::P64 = P64[R1 + 7];
           _sgavz::P64 = P64[R1 + 15];
           I64[Hp - 72] = sat_sgavB_info;
           P64[Hp - 56] = P64[Sp + 16];
           _sgavv::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sgavv::P64;
           P64[Hp - 40] = _sgavz::P64;
           I64[Hp - 32] = sat_sgavA_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sgavv::P64;
           P64[Hp] = _sgavy::P64;
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$csum_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cgbwu,
                       label: Data.Functor.Product.$fFoldableProduct_$csum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbwu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgbwy; else goto cgbwx;
       cgbwy: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$csum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbwx: // global
           I64[Hp - 56] = $dMonoid_sgavv_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sgavC_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.534542558 UTC

[section ""cstring" . lvl_rg5nW_bytes" {
     lvl_rg5nW_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.537154674 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct2_closure" {
     Data.Functor.Product.$fFoldableProduct2_closure:
         const Data.Functor.Product.$fFoldableProduct2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct2_entry() //  [R1]
         { info_tbl: [(cgbxt,
                       label: Data.Functor.Product.$fFoldableProduct2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbxt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgbxu; else goto cgbxv;
       cgbxu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbxv: // global
           (_cgbxo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgbxo::I64 == 0) goto cgbxq; else goto cgbxp;
       cgbxq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgbxp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgbxo::I64;
           I64[Sp - 24] = block_cgbxr_info;
           R2 = lvl_rg5nW_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgbxr() //  [R1]
         { info_tbl: [(cgbxr,
                       label: block_cgbxr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbxr: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.544296745 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cminimum_closure" {
     Data.Functor.Product.$fFoldableProduct_$cminimum_closure:
         const Data.Functor.Product.$fFoldableProduct_$cminimum_info;
         const 0;
 },
 $dMonoid_sgavH_entry() //  [R1]
         { info_tbl: [(cgbxT,
                       label: $dMonoid_sgavH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbxT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbxU; else goto cgbxV;
       cgbxU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbxV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgavT_entry() //  [R1, R2]
         { info_tbl: [(cgby4,
                       label: sat_sgavT_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgby4: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cgby5; else goto cgby6;
       cgby5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgby6: // global
           I64[Sp - 40] = block_cgby1_info;
           _sgavE::P64 = P64[R1 + 7];
           _sgavF::P64 = P64[R1 + 15];
           _sgavG::P64 = P64[R1 + 23];
           _sgavH::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgavE::P64;
           P64[Sp - 24] = _sgavF::P64;
           P64[Sp - 16] = _sgavG::P64;
           P64[Sp - 8] = _sgavH::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbyY; else goto cgby2;
       ugbyY: // global
           call _cgby1(R1) args: 0, res: 0, upd: 0;
       cgby2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgby1() //  [R1]
         { info_tbl: [(cgby1,
                       label: block_cgby1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgby1: // global
           I64[Sp] = block_cgby9_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = GHC.Base.Just_closure+1;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgby9() //  [R1]
         { info_tbl: [(cgby9,
                       label: block_cgby9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgby9: // global
           _sgavE::P64 = P64[Sp + 8];
           _sgavH::P64 = P64[Sp + 32];
           _sgavK::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cgbyh; else goto cgbyw;
       cgbyh: // global
           I64[Sp + 32] = block_cgbye_info;
           R2 = _sgavE::P64;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sgavH::P64;
           P64[Sp + 16] = GHC.Base.Just_closure+1;
           P64[Sp + 24] = _sgavK::P64;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cgbyw: // global
           I64[Sp + 16] = block_cgbyu_info;
           R2 = _sgavE::P64;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = _sgavH::P64;
           P64[Sp] = GHC.Base.Just_closure+1;
           P64[Sp + 8] = _sgavK::P64;
           P64[Sp + 32] = P64[R1 + 6];
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgbye() //  [R1]
         { info_tbl: [(cgbye,
                       label: block_cgbye_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbye: // global
           if (R1 & 7 == 1) goto cgbyn; else goto cgbyr;
       cgbyn: // global
           R1 = Data.Functor.Product.$fFoldableProduct2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgbyr: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgbyu() //  [R1]
         { info_tbl: [(cgbyu,
                       label: block_cgbyu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbyu: // global
           if (R1 & 7 == 1) goto ugbyW; else goto cgbyH;
       ugbyW: // global
           Sp = Sp + 16;
           call _cgbyN() args: 0, res: 0, upd: 0;
       cgbyH: // global
           I64[Sp] = block_cgbyF_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           _sgavR::P64 = P64[R1 + 6];
           P64[Sp - 16] = _sgavR::P64;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = _sgavR::P64;
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cgbyF() //  [R1]
         { info_tbl: [(cgbyF,
                       label: block_cgbyF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbyF: // global
           if (R1 & 7 == 1) goto ugbyX; else goto cgbyR;
       ugbyX: // global
           Sp = Sp + 16;
           call _cgbyN() args: 0, res: 0, upd: 0;
       cgbyR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgbyN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbyN: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cminimum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgbz1,
                       label: Data.Functor.Product.$fFoldableProduct_$cminimum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbz1: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgbz5; else goto cgbz4;
       cgbz5: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cminimum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbz4: // global
           I64[Hp - 56] = $dMonoid_sgavH_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sgavT_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.563388331 UTC

[section ""cstring" . lvl1_rg5nX_bytes" {
     lvl1_rg5nX_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.565497131 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct3_closure" {
     Data.Functor.Product.$fFoldableProduct3_closure:
         const Data.Functor.Product.$fFoldableProduct3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct3_entry() //  [R1]
         { info_tbl: [(cgbAg,
                       label: Data.Functor.Product.$fFoldableProduct3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbAg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgbAh; else goto cgbAi;
       cgbAh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbAi: // global
           (_cgbAb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgbAb::I64 == 0) goto cgbAd; else goto cgbAc;
       cgbAd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgbAc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgbAb::I64;
           I64[Sp - 24] = block_cgbAe_info;
           R2 = lvl1_rg5nX_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgbAe() //  [R1]
         { info_tbl: [(cgbAe,
                       label: block_cgbAe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbAe: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.572282176 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cmaximum_closure" {
     Data.Functor.Product.$fFoldableProduct_$cmaximum_closure:
         const Data.Functor.Product.$fFoldableProduct_$cmaximum_info;
         const 0;
 },
 $dMonoid_sgavY_entry() //  [R1]
         { info_tbl: [(cgbAG,
                       label: $dMonoid_sgavY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbAG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbAH; else goto cgbAI;
       cgbAH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbAI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgawa_entry() //  [R1, R2]
         { info_tbl: [(cgbAR,
                       label: sat_sgawa_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbAR: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cgbAS; else goto cgbAT;
       cgbAS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgbAT: // global
           I64[Sp - 40] = block_cgbAO_info;
           _sgavV::P64 = P64[R1 + 7];
           _sgavW::P64 = P64[R1 + 15];
           _sgavX::P64 = P64[R1 + 23];
           _sgavY::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgavV::P64;
           P64[Sp - 24] = _sgavW::P64;
           P64[Sp - 16] = _sgavX::P64;
           P64[Sp - 8] = _sgavY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbBL; else goto cgbAP;
       ugbBL: // global
           call _cgbAO(R1) args: 0, res: 0, upd: 0;
       cgbAP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbAO() //  [R1]
         { info_tbl: [(cgbAO,
                       label: block_cgbAO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbAO: // global
           I64[Sp] = block_cgbAW_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = GHC.Base.Just_closure+1;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgbAW() //  [R1]
         { info_tbl: [(cgbAW,
                       label: block_cgbAW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbAW: // global
           _sgavV::P64 = P64[Sp + 8];
           _sgavY::P64 = P64[Sp + 32];
           _sgaw1::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cgbB4; else goto cgbBj;
       cgbB4: // global
           I64[Sp + 32] = block_cgbB1_info;
           R2 = _sgavV::P64;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = _sgavY::P64;
           P64[Sp + 16] = GHC.Base.Just_closure+1;
           P64[Sp + 24] = _sgaw1::P64;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
       cgbBj: // global
           I64[Sp + 16] = block_cgbBh_info;
           R2 = _sgavV::P64;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = _sgavY::P64;
           P64[Sp] = GHC.Base.Just_closure+1;
           P64[Sp + 8] = _sgaw1::P64;
           P64[Sp + 32] = P64[R1 + 6];
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgbB1() //  [R1]
         { info_tbl: [(cgbB1,
                       label: block_cgbB1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbB1: // global
           if (R1 & 7 == 1) goto cgbBa; else goto cgbBe;
       cgbBa: // global
           R1 = Data.Functor.Product.$fFoldableProduct3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgbBe: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgbBh() //  [R1]
         { info_tbl: [(cgbBh,
                       label: block_cgbBh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbBh: // global
           if (R1 & 7 == 1) goto ugbBJ; else goto cgbBu;
       ugbBJ: // global
           Sp = Sp + 16;
           call _cgbBA() args: 0, res: 0, upd: 0;
       cgbBu: // global
           I64[Sp] = block_cgbBs_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           _sgaw8::P64 = P64[R1 + 6];
           P64[Sp - 16] = _sgaw8::P64;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = _sgaw8::P64;
           Sp = Sp - 24;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cgbBs() //  [R1]
         { info_tbl: [(cgbBs,
                       label: block_cgbBs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbBs: // global
           if (R1 & 7 == 1) goto ugbBK; else goto cgbBE;
       ugbBK: // global
           Sp = Sp + 16;
           call _cgbBA() args: 0, res: 0, upd: 0;
       cgbBE: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgbBA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbBA: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cmaximum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgbBO,
                       label: Data.Functor.Product.$fFoldableProduct_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbBO: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgbBS; else goto cgbBR;
       cgbBS: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cmaximum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbBR: // global
           I64[Hp - 56] = $dMonoid_sgavY_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sgawa_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.592369758 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$celem_closure" {
     Data.Functor.Product.$fFoldableProduct_$celem_closure:
         const Data.Functor.Product.$fFoldableProduct_$celem_info;
         const 0;
 },
 f1_sgawf_entry() //  [R1]
         { info_tbl: [(cgbD2,
                       label: f1_sgawf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbD2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgbD3; else goto cgbD4;
       cgbD3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbD4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgawl_entry() //  [R1, R2]
         { info_tbl: [(cgbDd,
                       label: sat_sgawl_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbDd: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cgbDe; else goto cgbDf;
       cgbDe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgbDf: // global
           I64[Sp - 32] = block_cgbDa_info;
           _sgawb::P64 = P64[R1 + 7];
           _sgawc::P64 = P64[R1 + 15];
           _sgawf::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 24] = _sgawb::P64;
           P64[Sp - 16] = _sgawc::P64;
           P64[Sp - 8] = _sgawf::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugbDv; else goto cgbDb;
       ugbDv: // global
           call _cgbDa(R1) args: 0, res: 0, upd: 0;
       cgbDb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbDa() //  [R1]
         { info_tbl: [(cgbDa,
                       label: block_cgbDa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbDa: // global
           I64[Sp] = block_cgbDi_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 8] = P64[R1 + 15];
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgbDi() //  [R1]
         { info_tbl: [(cgbDi,
                       label: block_cgbDi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbDi: // global
           if (R1 & 7 == 1) goto cgbDp; else goto cgbDt;
       cgbDp: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_ppp_info;
           _sgawj::P64 = P64[Sp + 8];
           P64[Sp + 8] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = _sgawj::P64;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
       cgbDt: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$celem_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cgbDw,
                       label: Data.Functor.Product.$fFoldableProduct_$celem_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbDw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgbDA; else goto cgbDz;
       cgbDA: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$celem_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbDz: // global
           I64[Hp - 56] = f1_sgawf_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = sat_sgawl_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.604898695 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct8_closure" {
     Data.Functor.Product.$fFoldableProduct8_closure:
         const Data.Functor.Product.$fFoldableProduct8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct8_entry() //  [R1]
         { info_tbl: [(cgbEl,
                       label: Data.Functor.Product.$fFoldableProduct8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbEl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbEm; else goto cgbEn;
       cgbEm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbEn: // global
           (_cgbEi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgbEi::I64 == 0) goto cgbEk; else goto cgbEj;
       cgbEk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgbEj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgbEi::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.609859226 UTC

[section ""data" . Data.Functor.Product.$w$cfoldl_closure" {
     Data.Functor.Product.$w$cfoldl_closure:
         const Data.Functor.Product.$w$cfoldl_info;
         const 0;
 },
 f1_sgaws_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbEF,
                       label: f1_sgaws_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbEF: // global
           _sgawu::P64 = R3;
           R3 = R2;
           R2 = _sgawu::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgawv_entry() //  [R1]
         { info_tbl: [(cgbEM,
                       label: sat_sgawv_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbEM: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgbEN; else goto cgbEO;
       cgbEN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbEO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgbEP,
                       label: Data.Functor.Product.$w$cfoldl_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbEP: // global
           _sgawq::P64 = R6;
           _sgawp::P64 = R5;
           _sgawo::P64 = R4;
           _sgawn::P64 = R3;
           _sgawm::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgbEQ; else goto cgbER;
       cgbER: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgbET; else goto cgbES;
       cgbET: // global
           HpAlloc = 64;
           goto cgbEQ;
       cgbEQ: // global
           R6 = _sgawq::P64;
           R5 = _sgawp::P64;
           R4 = _sgawo::P64;
           R3 = _sgawn::P64;
           R2 = _sgawm::P64;
           R1 = Data.Functor.Product.$w$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgbES: // global
           I64[Hp - 56] = f1_sgaws_info;
           P64[Hp - 48] = _sgawo::P64;
           I64[Hp - 40] = sat_sgawv_info;
           P64[Hp - 24] = _sgawm::P64;
           P64[Hp - 16] = _sgawp::P64;
           P64[Hp - 8] = _sgawq::P64;
           _cgbEA::P64 = Hp - 54;
           P64[Hp] = _cgbEA::P64;
           R2 = _sgawn::P64;
           I64[Sp - 32] = stg_ap_pppp_info;
           P64[Sp - 24] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 16] = _cgbEA::P64;
           P64[Sp - 8] = P64[Sp];
           P64[Sp] = Hp - 40;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.618959435 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldl_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldl_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldl_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldl_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cgbFp,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbFp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbFq; else goto cgbFr;
       cgbFq: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbFr: // global
           I64[Sp - 40] = block_cgbFm_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbFv; else goto cgbFn;
       ugbFv: // global
           call _cgbFm(R1) args: 0, res: 0, upd: 0;
       cgbFn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbFm() //  [R1]
         { info_tbl: [(cgbFm,
                       label: block_cgbFm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbFm: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldl_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.624752123 UTC

[section ""cstring" . lvl2_rg5nY_bytes" {
     lvl2_rg5nY_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.626983249 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct7_closure" {
     Data.Functor.Product.$fFoldableProduct7_closure:
         const Data.Functor.Product.$fFoldableProduct7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct7_entry() //  [R1]
         { info_tbl: [(cgbFQ,
                       label: Data.Functor.Product.$fFoldableProduct7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbFQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgbFR; else goto cgbFS;
       cgbFR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbFS: // global
           (_cgbFL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgbFL::I64 == 0) goto cgbFN; else goto cgbFM;
       cgbFN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgbFM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgbFL::I64;
           I64[Sp - 24] = block_cgbFO_info;
           R2 = lvl2_rg5nY_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgbFO() //  [R1]
         { info_tbl: [(cgbFO,
                       label: block_cgbFO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbFO: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.633977745 UTC

[section ""data" . Data.Functor.Product.$w$cfoldl1_closure" {
     Data.Functor.Product.$w$cfoldl1_closure:
         const Data.Functor.Product.$w$cfoldl1_info;
         const 0;
 },
 sat_sgawP_entry() //  [R1]
         { info_tbl: [(cgbGs,
                       label: sat_sgawP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbGs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbGt; else goto cgbGu;
       cgbGt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbGu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgbGl_info;
           _sgawH::P64 = P64[R1 + 16];
           _sgawL::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sgawH::P64;
           P64[Sp - 24] = _sgawL::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbGB; else goto cgbGm;
       ugbGB: // global
           call _cgbGl(R1) args: 0, res: 0, upd: 0;
       cgbGm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgbGl() //  [R1]
         { info_tbl: [(cgbGl,
                       label: block_cgbGl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbGl: // global
           _sgawL::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cgbGp; else goto cgbGq;
       cgbGp: // global
           R1 = _sgawL::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cgbGq: // global
           R3 = _sgawL::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 f1_sgawK_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbGD,
                       label: f1_sgawK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbGD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgbGH; else goto cgbGG;
       cgbGH: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbGG: // global
           _sgawH::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sgawP_info;
           P64[Hp - 32] = _sgawH::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgawQ_entry() //  [R1]
         { info_tbl: [(cgbGM,
                       label: sat_sgawQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbGM: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgbGN; else goto cgbGO;
       cgbGN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbGO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldl1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgbGV,
                       label: Data.Functor.Product.$w$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbGV: // global
           _sgawJ::P64 = R6;
           _sgawI::P64 = R5;
           _sgawH::P64 = R4;
           _sgawG::P64 = R3;
           _sgawF::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgbGW; else goto cgbGX;
       cgbGX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgbGZ; else goto cgbGY;
       cgbGZ: // global
           HpAlloc = 56;
           goto cgbGW;
       cgbGW: // global
           R6 = _sgawJ::P64;
           R5 = _sgawI::P64;
           R4 = _sgawH::P64;
           R3 = _sgawG::P64;
           R2 = _sgawF::P64;
           R1 = Data.Functor.Product.$w$cfoldl1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbGY: // global
           I64[Hp - 48] = f1_sgawK_info;
           P64[Hp - 40] = _sgawH::P64;
           I64[Hp - 32] = sat_sgawQ_info;
           P64[Hp - 16] = _sgawF::P64;
           P64[Hp - 8] = _sgawI::P64;
           _cgbGc::P64 = Hp - 46;
           P64[Hp] = _cgbGc::P64;
           I64[Sp - 8] = block_cgbGP_info;
           R2 = _sgawG::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 32] = _cgbGc::P64;
           P64[Sp - 24] = _sgawJ::P64;
           P64[Sp - 16] = Hp - 32;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cgbGP() //  [R1]
         { info_tbl: [(cgbGP,
                       label: block_cgbGP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbGP: // global
           if (R1 & 7 == 1) goto cgbGS; else goto cgbGT;
       cgbGS: // global
           R1 = Data.Functor.Product.$fFoldableProduct7_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgbGT: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.648834915 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldl1_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldl1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cgbHX,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbHX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgbHY; else goto cgbHZ;
       cgbHY: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbHZ: // global
           I64[Sp - 32] = block_cgbHU_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugbI3; else goto cgbHV;
       ugbI3: // global
           call _cgbHU(R1) args: 0, res: 0, upd: 0;
       cgbHV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbHU() //  [R1]
         { info_tbl: [(cgbHU,
                       label: block_cgbHU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbHU: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldl1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.65582795 UTC

[section ""data" . Data.Functor.Product.$w$cfoldr'_closure" {
     Data.Functor.Product.$w$cfoldr'_closure:
         const Data.Functor.Product.$w$cfoldr'_info;
         const 0;
 },
 f1_sgax6_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgbIp,
                       label: f1_sgax6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbIp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbIq; else goto cgbIr;
       cgbIq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbIr: // global
           I64[Sp - 16] = block_cgbIn_info;
           _sgax8::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sgax8::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbIn() //  [R1]
         { info_tbl: [(cgbIn,
                       label: block_cgbIn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbIn: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaxb_entry() //  [R1]
         { info_tbl: [(cgbIx,
                       label: sat_sgaxb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbIx: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgbIy; else goto cgbIz;
       cgbIy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbIz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldr'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgbIA,
                       label: Data.Functor.Product.$w$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbIA: // global
           _sgax4::P64 = R6;
           _sgax3::P64 = R5;
           _sgax2::P64 = R4;
           _sgax1::P64 = R3;
           _sgax0::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgbIB; else goto cgbIC;
       cgbIC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgbIE; else goto cgbID;
       cgbIE: // global
           HpAlloc = 56;
           goto cgbIB;
       cgbIB: // global
           R6 = _sgax4::P64;
           R5 = _sgax3::P64;
           R4 = _sgax2::P64;
           R3 = _sgax1::P64;
           R2 = _sgax0::P64;
           R1 = Data.Functor.Product.$w$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgbID: // global
           I64[Hp - 48] = f1_sgax6_info;
           P64[Hp - 40] = _sgax2::P64;
           I64[Hp - 32] = sat_sgaxb_info;
           P64[Hp - 16] = _sgax0::P64;
           P64[Hp - 8] = _sgax4::P64;
           _cgbIi::P64 = Hp - 45;
           P64[Hp] = _cgbIi::P64;
           R2 = _sgax1::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct8_closure;
           P64[Sp - 24] = _cgbIi::P64;
           P64[Sp - 16] = P64[Sp];
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = _sgax3::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.667175289 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldr'_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldr'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cgbJg,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbJg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbJh; else goto cgbJi;
       cgbJh: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbJi: // global
           I64[Sp - 40] = block_cgbJd_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbJm; else goto cgbJe;
       ugbJm: // global
           call _cgbJd(R1) args: 0, res: 0, upd: 0;
       cgbJe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbJd() //  [R1]
         { info_tbl: [(cgbJd,
                       label: block_cgbJd_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbJd: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldr'_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.673609451 UTC

[section ""data" . Data.Functor.Product.$w$cfoldr_closure" {
     Data.Functor.Product.$w$cfoldr_closure:
         const Data.Functor.Product.$w$cfoldr_info;
         const 0;
 },
 sat_sgaxq_entry() //  [R1]
         { info_tbl: [(cgbJG,
                       label: sat_sgaxq_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbJG: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgbJH; else goto cgbJI;
       cgbJH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbJI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgbJJ,
                       label: Data.Functor.Product.$w$cfoldr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbJJ: // global
           _sgaxo::P64 = R6;
           _sgaxn::P64 = R5;
           _sgaxm::P64 = R4;
           _sgaxl::P64 = R3;
           _sgaxk::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgbJK; else goto cgbJL;
       cgbJL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgbJN; else goto cgbJM;
       cgbJN: // global
           HpAlloc = 48;
           goto cgbJK;
       cgbJK: // global
           R6 = _sgaxo::P64;
           R5 = _sgaxn::P64;
           R4 = _sgaxm::P64;
           R3 = _sgaxl::P64;
           R2 = _sgaxk::P64;
           R1 = Data.Functor.Product.$w$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgbJM: // global
           I64[Hp - 40] = sat_sgaxq_info;
           P64[Hp - 24] = _sgaxl::P64;
           P64[Hp - 16] = _sgaxm::P64;
           P64[Hp - 8] = _sgaxn::P64;
           P64[Hp] = P64[Sp];
           R2 = _sgaxk::P64;
           I64[Sp - 32] = stg_ap_pppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 16] = _sgaxm::P64;
           P64[Sp - 8] = _sgaxo::P64;
           P64[Sp] = Hp - 40;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.680620422 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldr_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldr_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldr_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldr_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cgbKf,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbKf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbKg; else goto cgbKh;
       cgbKg: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbKh: // global
           I64[Sp - 40] = block_cgbKc_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbKl; else goto cgbKd;
       ugbKl: // global
           call _cgbKc(R1) args: 0, res: 0, upd: 0;
       cgbKd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbKc() //  [R1]
         { info_tbl: [(cgbKc,
                       label: block_cgbKc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbKc: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldr_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.687770774 UTC

[section ""data" . Data.Functor.Product.$w$cfoldl'_closure" {
     Data.Functor.Product.$w$cfoldl'_closure:
         const Data.Functor.Product.$w$cfoldl'_info;
         const 0;
 },
 f1_sgaxF_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgbKI,
                       label: f1_sgaxF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbKI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbKJ; else goto cgbKK;
       cgbKJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbKK: // global
           I64[Sp - 16] = block_cgbKG_info;
           _sgaxH::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sgaxH::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbKG() //  [R1]
         { info_tbl: [(cgbKG,
                       label: block_cgbKG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbKG: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaxK_entry() //  [R1]
         { info_tbl: [(cgbKQ,
                       label: sat_sgaxK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbKQ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgbKR; else goto cgbKS;
       cgbKR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbKS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldl'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgbKT,
                       label: Data.Functor.Product.$w$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbKT: // global
           _sgaxD::P64 = R6;
           _sgaxC::P64 = R5;
           _sgaxB::P64 = R4;
           _sgaxA::P64 = R3;
           _sgaxz::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgbKU; else goto cgbKV;
       cgbKV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgbKX; else goto cgbKW;
       cgbKX: // global
           HpAlloc = 56;
           goto cgbKU;
       cgbKU: // global
           R6 = _sgaxD::P64;
           R5 = _sgaxC::P64;
           R4 = _sgaxB::P64;
           R3 = _sgaxA::P64;
           R2 = _sgaxz::P64;
           R1 = Data.Functor.Product.$w$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgbKW: // global
           I64[Hp - 48] = f1_sgaxF_info;
           P64[Hp - 40] = _sgaxB::P64;
           I64[Hp - 32] = sat_sgaxK_info;
           P64[Hp - 16] = _sgaxA::P64;
           P64[Hp - 8] = P64[Sp];
           _cgbKB::P64 = Hp - 45;
           P64[Hp] = _cgbKB::P64;
           R2 = _sgaxz::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = _cgbKB::P64;
           P64[Sp - 16] = _sgaxD::P64;
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = _sgaxC::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.698377816 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldl'_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldl'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cgbLz,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbLz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbLA; else goto cgbLB;
       cgbLA: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbLB: // global
           I64[Sp - 40] = block_cgbLw_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbLF; else goto cgbLx;
       ugbLF: // global
           call _cgbLw(R1) args: 0, res: 0, upd: 0;
       cgbLx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbLw() //  [R1]
         { info_tbl: [(cgbLw,
                       label: block_cgbLw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbLw: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldl'_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.705188284 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct5_closure" {
     Data.Functor.Product.$fFoldableProduct5_closure:
         const Data.Functor.Product.$fFoldableProduct5_info;
 },
 Data.Functor.Product.$fFoldableProduct5_entry() //  [R2, R3]
         { info_tbl: [(cgbLY,
                       label: Data.Functor.Product.$fFoldableProduct5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbLY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgbM5; else goto cgbM6;
       cgbM5: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbM6: // global
           I64[Sp - 8] = block_cgbLV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugbMa; else goto cgbLW;
       ugbMa: // global
           call _cgbLV(R1) args: 0, res: 0, upd: 0;
       cgbLW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbLV() //  [R1]
         { info_tbl: [(cgbLV,
                       label: block_cgbLV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbLV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgbM9; else goto cgbM8;
       cgbM9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgbM8: // global
           _sgaxX::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sgaxX::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.711436161 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$clength_closure" {
     Data.Functor.Product.$fFoldableProduct_$clength_closure:
         const Data.Functor.Product.$fFoldableProduct_$clength_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$clength_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cgbMv,
                       label: Data.Functor.Product.$fFoldableProduct_$clength_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbMv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgbMw; else goto cgbMx;
       cgbMw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$clength_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbMx: // global
           I64[Sp - 24] = block_cgbMs_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugbMB; else goto cgbMt;
       ugbMB: // global
           call _cgbMs(R1) args: 0, res: 0, upd: 0;
       cgbMt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbMs() //  [R1]
         { info_tbl: [(cgbMs,
                       label: block_cgbMs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbMs: // global
           R6 = P64[R1 + 7];
           R5 = Data.Functor.Product.$fFoldableProduct4_closure+1;
           R4 = Data.Functor.Product.$fFoldableProduct5_closure+2;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 16] = P64[R1 + 15];
           Sp = Sp + 16;
           call Data.Functor.Product.$w$cfoldl'_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.717124411 UTC

[section ""cstring" . lvl3_rg5nZ_bytes" {
     lvl3_rg5nZ_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.719388621 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct9_closure" {
     Data.Functor.Product.$fFoldableProduct9_closure:
         const Data.Functor.Product.$fFoldableProduct9_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct9_entry() //  [R1]
         { info_tbl: [(cgbMW,
                       label: Data.Functor.Product.$fFoldableProduct9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbMW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgbMX; else goto cgbMY;
       cgbMX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbMY: // global
           (_cgbMR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgbMR::I64 == 0) goto cgbMT; else goto cgbMS;
       cgbMT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgbMS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgbMR::I64;
           I64[Sp - 24] = block_cgbMU_info;
           R2 = lvl3_rg5nZ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgbMU() //  [R1]
         { info_tbl: [(cgbMU,
                       label: block_cgbMU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbMU: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.726107528 UTC

[section ""data" . Data.Functor.Product.$w$cfoldr1_closure" {
     Data.Functor.Product.$w$cfoldr1_closure:
         const Data.Functor.Product.$w$cfoldr1_info;
         const 0;
 },
 sat_sgayf_entry() //  [R1]
         { info_tbl: [(cgbNy,
                       label: sat_sgayf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbNy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbNz; else goto cgbNA;
       cgbNz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbNA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgbNr_info;
           _sgay7::P64 = P64[R1 + 16];
           _sgayb::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sgay7::P64;
           P64[Sp - 24] = _sgayb::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbNH; else goto cgbNs;
       ugbNH: // global
           call _cgbNr(R1) args: 0, res: 0, upd: 0;
       cgbNs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgbNr() //  [R1]
         { info_tbl: [(cgbNr,
                       label: block_cgbNr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbNr: // global
           _sgayb::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cgbNv; else goto cgbNw;
       cgbNv: // global
           R1 = _sgayb::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cgbNw: // global
           R3 = P64[R1 + 6];
           R2 = _sgayb::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 w3_sgaya_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbNJ,
                       label: w3_sgaya_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbNJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgbNN; else goto cgbNM;
       cgbNN: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbNM: // global
           _sgay7::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sgayf_info;
           P64[Hp - 32] = _sgay7::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgayg_entry() //  [R1]
         { info_tbl: [(cgbNS,
                       label: sat_sgayg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbNS: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgbNT; else goto cgbNU;
       cgbNT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbNU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cfoldr1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgbO1,
                       label: Data.Functor.Product.$w$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbO1: // global
           _sgay9::P64 = R6;
           _sgay8::P64 = R5;
           _sgay7::P64 = R4;
           _sgay6::P64 = R3;
           _sgay5::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgbO2; else goto cgbO3;
       cgbO3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgbO5; else goto cgbO4;
       cgbO5: // global
           HpAlloc = 56;
           goto cgbO2;
       cgbO2: // global
           R6 = _sgay9::P64;
           R5 = _sgay8::P64;
           R4 = _sgay7::P64;
           R3 = _sgay6::P64;
           R2 = _sgay5::P64;
           R1 = Data.Functor.Product.$w$cfoldr1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbO4: // global
           I64[Hp - 48] = w3_sgaya_info;
           P64[Hp - 40] = _sgay7::P64;
           I64[Hp - 32] = sat_sgayg_info;
           P64[Hp - 16] = _sgay6::P64;
           P64[Hp - 8] = _sgay9::P64;
           _cgbNi::P64 = Hp - 46;
           P64[Hp] = _cgbNi::P64;
           I64[Sp - 8] = block_cgbNV_info;
           R2 = _sgay5::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = _cgbNi::P64;
           P64[Sp - 24] = _sgay8::P64;
           P64[Sp - 16] = Hp - 32;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cgbNV() //  [R1]
         { info_tbl: [(cgbNV,
                       label: block_cgbNV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbNV: // global
           if (R1 & 7 == 1) goto cgbNY; else goto cgbNZ;
       cgbNY: // global
           R1 = Data.Functor.Product.$fFoldableProduct9_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgbNZ: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.741888599 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure" {
     Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure:
         const Data.Functor.Product.$fFoldableProduct_$cfoldr1_info;
         const 0;
 },
 Data.Functor.Product.$fFoldableProduct_$cfoldr1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cgbP3,
                       label: Data.Functor.Product.$fFoldableProduct_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbP3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgbP4; else goto cgbP5;
       cgbP4: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbP5: // global
           I64[Sp - 32] = block_cgbP0_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugbP9; else goto cgbP1;
       ugbP9: // global
           call _cgbP0(R1) args: 0, res: 0, upd: 0;
       cgbP1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbP0() //  [R1]
         { info_tbl: [(cgbP0,
                       label: block_cgbP0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbP0: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cfoldr1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.747707054 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct6_closure" {
     Data.Functor.Product.$fFoldableProduct6_closure:
         const Data.Functor.Product.$fFoldableProduct6_info;
 },
 Data.Functor.Product.$fFoldableProduct6_entry() //  []
         { info_tbl: [(cgbPo,
                       label: Data.Functor.Product.$fFoldableProduct6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbPo: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.751456338 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cnull_closure" {
     Data.Functor.Product.$fFoldableProduct_$cnull_closure:
         const Data.Functor.Product.$fFoldableProduct_$cnull_info;
         const 0;
 },
 sat_sgayy_entry() //  [R1]
         { info_tbl: [(cgbPK,
                       label: sat_sgayy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbPK: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgbPL; else goto cgbPM;
       cgbPL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbPM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = Data.Functor.Product.$fFoldableProduct6_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.True_closure+2;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cnull_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgbPN,
                       label: Data.Functor.Product.$fFoldableProduct_$cnull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbPN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbPO; else goto cgbPP;
       cgbPO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cnull_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbPP: // global
           I64[Sp - 24] = block_cgbPB_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugbPT; else goto cgbPC;
       ugbPT: // global
           call _cgbPB(R1) args: 0, res: 0, upd: 0;
       cgbPC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbPB() //  [R1]
         { info_tbl: [(cgbPB,
                       label: block_cgbPB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbPB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgbPS; else goto cgbPR;
       cgbPS: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgbPR: // global
           _sgayw::P64 = P64[R1 + 7];
           _sgayx::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sgayy_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sgayx::P64;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp] = Data.Functor.Product.$fFoldableProduct6_closure+2;
           P64[Sp + 8] = _sgayw::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.760913425 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$cproduct_closure" {
     Data.Functor.Product.$fFoldableProduct_$cproduct_closure:
         const Data.Functor.Product.$fFoldableProduct_$cproduct_info;
         const 0;
 },
 $dMonoid_sgayC_entry() //  [R1]
         { info_tbl: [(cgbQt,
                       label: $dMonoid_sgayC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbQt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbQu; else goto cgbQv;
       cgbQu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbQv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgayI_entry() //  [R1]
         { info_tbl: [(cgbQK,
                       label: sat_sgayI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbQK: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgbQL; else goto cgbQM;
       cgbQL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbQM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sgayH_entry() //  [R1]
         { info_tbl: [(cgbQR,
                       label: sat_sgayH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbQR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgbQS; else goto cgbQT;
       cgbQS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbQT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = Data.Functor.Product.$fFoldableProduct1_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sgayJ_entry() //  [R1, R2]
         { info_tbl: [(cgbQU,
                       label: sat_sgayJ_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbQU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbQV; else goto cgbQW;
       cgbQV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgbQW: // global
           I64[Sp - 40] = block_cgbQB_info;
           _sgayz::P64 = P64[R1 + 7];
           _sgayA::P64 = P64[R1 + 15];
           _sgayB::P64 = P64[R1 + 23];
           _sgayC::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgayz::P64;
           P64[Sp - 24] = _sgayA::P64;
           P64[Sp - 16] = _sgayB::P64;
           P64[Sp - 8] = _sgayC::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbR0; else goto cgbQC;
       ugbR0: // global
           call _cgbQB(R1) args: 0, res: 0, upd: 0;
       cgbQC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbQB() //  [R1]
         { info_tbl: [(cgbQB,
                       label: block_cgbQB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbQB: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgbQZ; else goto cgbQY;
       cgbQZ: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgbQY: // global
           _sgayF::P64 = P64[R1 + 7];
           _sgayG::P64 = P64[R1 + 15];
           I64[Hp - 72] = sat_sgayI_info;
           P64[Hp - 56] = P64[Sp + 16];
           _sgayC::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sgayC::P64;
           P64[Hp - 40] = _sgayG::P64;
           I64[Hp - 32] = sat_sgayH_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sgayC::P64;
           P64[Hp] = _sgayF::P64;
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$cproduct_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgbR1,
                       label: Data.Functor.Product.$fFoldableProduct_$cproduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbR1: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgbR5; else goto cgbR4;
       cgbR5: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$cproduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbR4: // global
           I64[Hp - 56] = $dMonoid_sgayC_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sgayJ_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.776189716 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_$ctoList_closure" {
     Data.Functor.Product.$fFoldableProduct_$ctoList_closure:
         const Data.Functor.Product.$fFoldableProduct_$ctoList_info;
         const 0;
 },
 sat_sgayQ_entry() //  [R1]
         { info_tbl: [(cgbS4,
                       label: sat_sgayQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbS4: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgbS5; else goto cgbS6;
       cgbS5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbS6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 40] = GHC.Types.:_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 56;
           call Data.Foldable.foldMap_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fFoldableProduct_$ctoList_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cgbS7,
                       label: Data.Functor.Product.$fFoldableProduct_$ctoList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbS7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbS8; else goto cgbS9;
       cgbS8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_$ctoList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbS9: // global
           I64[Sp - 24] = block_cgbRV_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugbSd; else goto cgbRW;
       ugbSd: // global
           call _cgbRV(R1) args: 0, res: 0, upd: 0;
       cgbRW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbRV() //  [R1]
         { info_tbl: [(cgbRV,
                       label: block_cgbRV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbRV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgbSc; else goto cgbSb;
       cgbSc: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgbSb: // global
           _sgayO::P64 = P64[R1 + 7];
           _sgayP::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sgayQ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sgayP::P64;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp] = GHC.Types.:_closure+2;
           P64[Sp + 8] = _sgayO::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp - 16;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.78745613 UTC

[section ""data" . Data.Functor.Product.$fFoldableProduct_closure" {
     Data.Functor.Product.$fFoldableProduct_closure:
         const Data.Functor.Product.$fFoldableProduct_info;
         const 0;
 },
 sat_sgaz8_entry() //  [R1, R2]
         { info_tbl: [(cgbSQ,
                       label: sat_sgaz8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbSQ: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cproduct_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaz7_entry() //  [R1, R2]
         { info_tbl: [(cgbSY,
                       label: sat_sgaz7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbSY: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$csum_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaz6_entry() //  [R1, R2]
         { info_tbl: [(cgbT6,
                       label: sat_sgaz6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbT6: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cminimum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaz5_entry() //  [R1, R2]
         { info_tbl: [(cgbTe,
                       label: sat_sgaz5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbTe: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cmaximum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaz4_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbTm,
                       label: sat_sgaz4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbTm: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$celem_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaz3_entry() //  [R1, R2]
         { info_tbl: [(cgbTu,
                       label: sat_sgaz3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbTu: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$clength_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaz2_entry() //  [R1, R2]
         { info_tbl: [(cgbTC,
                       label: sat_sgaz2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbTC: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$cnull_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaz1_entry() //  [R1, R2]
         { info_tbl: [(cgbTK,
                       label: sat_sgaz1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbTK: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fFoldableProduct_$ctoList_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaz0_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbTS,
                       label: sat_sgaz0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbTS: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$cfoldl1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgayZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbU0,
                       label: sat_sgayZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbU0: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$cfoldr1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgayY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgbU8,
                       label: sat_sgayY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbU8: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldl'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgayX_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgbUg,
                       label: sat_sgayX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbUg: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldl_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgayW_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgbUo,
                       label: sat_sgayW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbUo: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldr'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgayV_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgbUw,
                       label: sat_sgayV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbUw: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldr_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgayU_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgbUE,
                       label: sat_sgayU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbUE: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fFoldableProduct_$cfoldMap_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgayT_entry() //  [R1, R2, R3]
         { info_tbl: [(cgbUM,
                       label: sat_sgayT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbUM: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fFoldableProduct_$cfold_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fFoldableProduct_entry() //  [R2, R3]
         { info_tbl: [(cgbUQ,
                       label: Data.Functor.Product.$fFoldableProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbUQ: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cgbUU; else goto cgbUT;
       cgbUU: // global
           HpAlloc = 520;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fFoldableProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbUT: // global
           I64[Hp - 512] = sat_sgaz8_info;
           P64[Hp - 504] = R2;
           P64[Hp - 496] = R3;
           I64[Hp - 488] = sat_sgaz7_info;
           P64[Hp - 480] = R2;
           P64[Hp - 472] = R3;
           I64[Hp - 464] = sat_sgaz6_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           I64[Hp - 440] = sat_sgaz5_info;
           P64[Hp - 432] = R2;
           P64[Hp - 424] = R3;
           I64[Hp - 416] = sat_sgaz4_info;
           P64[Hp - 408] = R2;
           P64[Hp - 400] = R3;
           I64[Hp - 392] = sat_sgaz3_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           I64[Hp - 368] = sat_sgaz2_info;
           P64[Hp - 360] = R2;
           P64[Hp - 352] = R3;
           I64[Hp - 344] = sat_sgaz1_info;
           P64[Hp - 336] = R2;
           P64[Hp - 328] = R3;
           I64[Hp - 320] = sat_sgaz0_info;
           P64[Hp - 312] = R2;
           P64[Hp - 304] = R3;
           I64[Hp - 296] = sat_sgayZ_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           I64[Hp - 272] = sat_sgayY_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_sgayX_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_sgayW_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_sgayV_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sgayU_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sgayT_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = Data.Foldable.C:Foldable_con_info;
           P64[Hp - 120] = Hp - 150;
           P64[Hp - 112] = Hp - 173;
           P64[Hp - 104] = Hp - 197;
           P64[Hp - 96] = Hp - 221;
           P64[Hp - 88] = Hp - 245;
           P64[Hp - 80] = Hp - 269;
           P64[Hp - 72] = Hp - 294;
           P64[Hp - 64] = Hp - 318;
           P64[Hp - 56] = Hp - 343;
           P64[Hp - 48] = Hp - 367;
           P64[Hp - 40] = Hp - 391;
           P64[Hp - 32] = Hp - 414;
           P64[Hp - 24] = Hp - 439;
           P64[Hp - 16] = Hp - 463;
           P64[Hp - 8] = Hp - 487;
           P64[Hp] = Hp - 511;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.819342106 UTC

[section ""data" . Data.Functor.Product.$w$ctraverse_closure" {
     Data.Functor.Product.$w$ctraverse_closure:
         const Data.Functor.Product.$w$ctraverse_info;
 },
 sat_sgazg_entry() //  [R1]
         { info_tbl: [(cgbWr,
                       label: sat_sgazg_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbWr: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgbWs; else goto cgbWt;
       cgbWs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbWt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sgazf_entry() //  [R1]
         { info_tbl: [(cgbWy,
                       label: sat_sgazf_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbWy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgbWz; else goto cgbWA;
       cgbWz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbWA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$ctraverse_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgbWB,
                       label: Data.Functor.Product.$w$ctraverse_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbWB: // global
           _sgazd::P64 = R6;
           _sgazc::P64 = R5;
           _sgazb::P64 = R4;
           _sgaza::P64 = R3;
           _sgaz9::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgbWC; else goto cgbWD;
       cgbWD: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgbWF; else goto cgbWE;
       cgbWF: // global
           HpAlloc = 96;
           goto cgbWC;
       cgbWC: // global
           R6 = _sgazd::P64;
           R5 = _sgazc::P64;
           R4 = _sgazb::P64;
           R3 = _sgaza::P64;
           R2 = _sgaz9::P64;
           R1 = Data.Functor.Product.$w$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgbWE: // global
           I64[Hp - 88] = sat_sgazg_info;
           P64[Hp - 72] = _sgaza::P64;
           P64[Hp - 64] = _sgazb::P64;
           P64[Hp - 56] = _sgazc::P64;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = sat_sgazf_info;
           P64[Hp - 24] = _sgaz9::P64;
           P64[Hp - 16] = _sgazb::P64;
           P64[Hp - 8] = _sgazc::P64;
           P64[Hp] = _sgazd::P64;
           R2 = _sgazb::P64;
           I64[Sp - 24] = stg_ap_ppp_info;
           P64[Sp - 16] = Data.Functor.Product.Pair_closure+2;
           P64[Sp - 8] = Hp - 40;
           P64[Sp] = Hp - 88;
           Sp = Sp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.828914821 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$ctraverse_closure" {
     Data.Functor.Product.$fTraversableProduct_$ctraverse_closure:
         const Data.Functor.Product.$fTraversableProduct_$ctraverse_info;
 },
 Data.Functor.Product.$fTraversableProduct_$ctraverse_entry() //  [R2,
                                                                   R3, R4, R5, R6]
         { info_tbl: [(cgbXh,
                       label: Data.Functor.Product.$fTraversableProduct_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbXh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbXi; else goto cgbXj;
       cgbXi: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbXj: // global
           I64[Sp - 40] = block_cgbXe_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbXn; else goto cgbXf;
       ugbXn: // global
           call _cgbXe(R1) args: 0, res: 0, upd: 0;
       cgbXf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbXe() //  [R1]
         { info_tbl: [(cgbXe,
                       label: block_cgbXe_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbXe: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.834971106 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure" {
     Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure:
         const Data.Functor.Product.$fTraversableProduct_$cp2Traversable_info;
         const 0;
 },
 sat_sgazs_entry() //  [R1]
         { info_tbl: [(cgbXH,
                       label: sat_sgazs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbXH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbXI; else goto cgbXJ;
       cgbXI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbXJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgazr_entry() //  [R1]
         { info_tbl: [(cgbXO,
                       label: sat_sgazr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbXO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbXP; else goto cgbXQ;
       cgbXP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbXQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fTraversableProduct_$cp2Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgbXR,
                       label: Data.Functor.Product.$fTraversableProduct_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbXR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgbXV; else goto cgbXU;
       cgbXV: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbXU: // global
           I64[Hp - 40] = sat_sgazs_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgazr_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fFoldableProduct_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.8427606 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$cp1Traversable_closure" {
     Data.Functor.Product.$fTraversableProduct_$cp1Traversable_closure:
         const Data.Functor.Product.$fTraversableProduct_$cp1Traversable_info;
 },
 sat_sgazw_entry() //  [R1]
         { info_tbl: [(cgbYk,
                       label: sat_sgazw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbYk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbYl; else goto cgbYm;
       cgbYl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbYm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgazv_entry() //  [R1]
         { info_tbl: [(cgbYr,
                       label: sat_sgazv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbYr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbYs; else goto cgbYt;
       cgbYs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbYt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fTraversableProduct_$cp1Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgbYu,
                       label: Data.Functor.Product.$fTraversableProduct_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbYu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgbYy; else goto cgbYx;
       cgbYy: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbYx: // global
           I64[Hp - 40] = sat_sgazw_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgazv_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fFunctorProduct_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.850388655 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$csequenceA_closure" {
     Data.Functor.Product.$fTraversableProduct_$csequenceA_closure:
         const Data.Functor.Product.$fTraversableProduct_$csequenceA_info;
 },
 Data.Functor.Product.$fTraversableProduct_$csequenceA_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cgbYW,
                       label: Data.Functor.Product.$fTraversableProduct_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbYW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgbYX; else goto cgbYY;
       cgbYX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$csequenceA_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbYY: // global
           I64[Sp - 32] = block_cgbYT_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugbZ2; else goto cgbYU;
       ugbZ2: // global
           call _cgbYT(R1) args: 0, res: 0, upd: 0;
       cgbYU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbYT() //  [R1]
         { info_tbl: [(cgbYT,
                       label: block_cgbYT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbYT: // global
           R6 = P64[R1 + 7];
           R5 = GHC.Base.id_closure+1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.856727295 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$cmapM_closure" {
     Data.Functor.Product.$fTraversableProduct_$cmapM_closure:
         const Data.Functor.Product.$fTraversableProduct_$cmapM_info;
 },
 Data.Functor.Product.$fTraversableProduct_$cmapM_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cgbZm,
                       label: Data.Functor.Product.$fTraversableProduct_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbZm: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgbZq; else goto cgbZr;
       cgbZq: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgbZr: // global
           I64[Sp - 40] = block_cgbZj_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugbZx; else goto cgbZk;
       ugbZx: // global
           call _cgbZj(R1) args: 0, res: 0, upd: 0;
       cgbZk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbZj() //  [R1]
         { info_tbl: [(cgbZj,
                       label: block_cgbZj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbZj: // global
           I64[Sp - 8] = block_cgbZp_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgbZp() //  [R1]
         { info_tbl: [(cgbZp,
                       label: block_cgbZp_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbZp: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 40];
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.865040725 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_$csequence_closure" {
     Data.Functor.Product.$fTraversableProduct_$csequence_closure:
         const Data.Functor.Product.$fTraversableProduct_$csequence_info;
 },
 Data.Functor.Product.$fTraversableProduct_$csequence_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cgbZW,
                       label: Data.Functor.Product.$fTraversableProduct_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbZW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgc00; else goto cgc01;
       cgc00: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgc01: // global
           I64[Sp - 32] = block_cgbZT_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugc07; else goto cgbZU;
       ugc07: // global
           call _cgbZT(R1) args: 0, res: 0, upd: 0;
       cgbZU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbZT() //  [R1]
         { info_tbl: [(cgbZT,
                       label: block_cgbZT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbZT: // global
           I64[Sp - 8] = block_cgbZZ_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgbZZ() //  [R1]
         { info_tbl: [(cgbZZ,
                       label: block_cgbZZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbZZ: // global
           R6 = P64[Sp + 32];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$ctraverse_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.873551495 UTC

[section ""data" . Data.Functor.Product.$fTraversableProduct_closure" {
     Data.Functor.Product.$fTraversableProduct_closure:
         const Data.Functor.Product.$fTraversableProduct_info;
         const 0;
 },
 sat_sgaA2_entry() //  [R1, R2, R3]
         { info_tbl: [(cgc0z,
                       label: sat_sgaA2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc0z: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fTraversableProduct_$csequence_entry(R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaA1_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgc0H,
                       label: sat_sgaA1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc0H: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fTraversableProduct_$cmapM_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaA0_entry() //  [R1, R2, R3]
         { info_tbl: [(cgc0P,
                       label: sat_sgaA0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc0P: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fTraversableProduct_$csequenceA_entry(R5,
                                                                            R4,
                                                                            R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgazZ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgc0X,
                       label: sat_sgazZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc0X: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fTraversableProduct_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgazY_entry() //  [R1]
         { info_tbl: [(cgc14,
                       label: sat_sgazY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc14: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgc15; else goto cgc16;
       cgc15: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc16: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fTraversableProduct_$cp2Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgazX_entry() //  [R1]
         { info_tbl: [(cgc1b,
                       label: sat_sgazX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc1b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgc1c; else goto cgc1d;
       cgc1c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc1d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fTraversableProduct_$cp1Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fTraversableProduct_entry() //  [R2, R3]
         { info_tbl: [(cgc1f,
                       label: Data.Functor.Product.$fTraversableProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc1f: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cgc1j; else goto cgc1i;
       cgc1j: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fTraversableProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgc1i: // global
           I64[Hp - 208] = sat_sgaA2_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sgaA1_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sgaA0_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sgazZ_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sgazY_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sgazX_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.889564835 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$cliftA2_closure" {
     Data.Functor.Product.$fApplicativeProduct_$cliftA2_closure:
         const Data.Functor.Product.$fApplicativeProduct_$cliftA2_info;
 },
 sat_sgaAf_entry() //  [R1]
         { info_tbl: [(cgc2g,
                       label: sat_sgaAf_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc2g: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgc2h; else goto cgc2i;
       cgc2h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc2i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sgaAe_entry() //  [R1]
         { info_tbl: [(cgc2n,
                       label: sat_sgaAe_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc2n: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgc2o; else goto cgc2p;
       cgc2o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc2p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$cliftA2_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cgc2q,
                       label: Data.Functor.Product.$fApplicativeProduct_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc2q: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgc2s; else goto cgc2t;
       cgc2s: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$cliftA2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgc2t: // global
           I64[Sp - 40] = block_cgc22_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugc2z; else goto cgc23;
       ugc2z: // global
           call _cgc22(R1) args: 0, res: 0, upd: 0;
       cgc23: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgc22() //  [R1]
         { info_tbl: [(cgc22,
                       label: block_cgc22_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc22: // global
           I64[Sp - 8] = block_cgc27_info;
           _sgaA9::P64 = P64[R1 + 7];
           _sgaAa::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sgaAa::P64;
           P64[Sp + 32] = _sgaA9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugc2y; else goto cgc28;
       ugc2y: // global
           call _cgc27(R1) args: 0, res: 0, upd: 0;
       cgc28: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgc27() //  [R1]
         { info_tbl: [(cgc27,
                       label: block_cgc27_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc27: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cgc2x; else goto cgc2w;
       cgc2x: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgc2w: // global
           _sgaAc::P64 = P64[R1 + 7];
           _sgaAd::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sgaAf_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sgaA5::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sgaA5::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sgaAd::P64;
           I64[Hp - 64] = sat_sgaAe_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sgaA5::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sgaAc::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.903212878 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$c<*>_closure" {
     Data.Functor.Product.$fApplicativeProduct_$c<*>_closure:
         const Data.Functor.Product.$fApplicativeProduct_$c<*>_info;
 },
 sat_sgaAr_entry() //  [R1]
         { info_tbl: [(cgc3z,
                       label: sat_sgaAr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc3z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgc3A; else goto cgc3B;
       cgc3A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc3B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgaAq_entry() //  [R1]
         { info_tbl: [(cgc3G,
                       label: sat_sgaAq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc3G: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgc3H; else goto cgc3I;
       cgc3H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc3I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$c<*>_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cgc3J,
                       label: Data.Functor.Product.$fApplicativeProduct_$c<*>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc3J: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgc3L; else goto cgc3M;
       cgc3L: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$c<*>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgc3M: // global
           I64[Sp - 32] = block_cgc3l_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugc3S; else goto cgc3m;
       ugc3S: // global
           call _cgc3l(R1) args: 0, res: 0, upd: 0;
       cgc3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgc3l() //  [R1]
         { info_tbl: [(cgc3l,
                       label: block_cgc3l_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc3l: // global
           I64[Sp - 8] = block_cgc3q_info;
           _sgaAl::P64 = P64[R1 + 7];
           _sgaAm::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sgaAm::P64;
           P64[Sp + 24] = _sgaAl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugc3R; else goto cgc3r;
       ugc3R: // global
           call _cgc3q(R1) args: 0, res: 0, upd: 0;
       cgc3r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgc3q() //  [R1]
         { info_tbl: [(cgc3q,
                       label: block_cgc3q_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc3q: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgc3Q; else goto cgc3P;
       cgc3Q: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgc3P: // global
           _sgaAo::P64 = P64[R1 + 7];
           _sgaAp::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgaAr_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sgaAp::P64;
           I64[Hp - 56] = sat_sgaAq_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sgaAo::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.915721319 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$cpure_closure" {
     Data.Functor.Product.$fApplicativeProduct_$cpure_closure:
         const Data.Functor.Product.$fApplicativeProduct_$cpure_info;
 },
 sat_sgaAw_entry() //  [R1]
         { info_tbl: [(cgc4G,
                       label: sat_sgaAw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc4G: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgc4H; else goto cgc4I;
       cgc4H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc4I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgaAv_entry() //  [R1]
         { info_tbl: [(cgc4N,
                       label: sat_sgaAv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc4N: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgc4O; else goto cgc4P;
       cgc4O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc4P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$cpure_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgc4R,
                       label: Data.Functor.Product.$fApplicativeProduct_$cpure_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc4R: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgc4V; else goto cgc4U;
       cgc4V: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$cpure_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgc4U: // global
           I64[Hp - 80] = sat_sgaAw_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sgaAv_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.924296973 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_closure" {
     Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_closure:
         const Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_info;
 },
 sat_sgaAA_entry() //  [R1]
         { info_tbl: [(cgc5s,
                       label: sat_sgaAA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc5s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgc5t; else goto cgc5u;
       cgc5t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc5u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaAz_entry() //  [R1]
         { info_tbl: [(cgc5z,
                       label: sat_sgaAz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc5z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgc5A; else goto cgc5B;
       cgc5A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc5B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgc5C,
                       label: Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc5C: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgc5G; else goto cgc5F;
       cgc5G: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgc5F: // global
           I64[Hp - 40] = sat_sgaAA_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgaAz_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fFunctorProduct_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.931832883 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct1_closure" {
     Data.Functor.Product.$fApplicativeProduct1_closure:
         const Data.Functor.Product.$fApplicativeProduct1_info;
 },
 Data.Functor.Product.$fApplicativeProduct1_entry() //  [R3]
         { info_tbl: [(cgc61,
                       label: Data.Functor.Product.$fApplicativeProduct1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc61: // global
           R2 = R3;
           call GHC.Base.breakpoint_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.936120224 UTC

[section ""data" . Data.Functor.Product.$w$c*>_closure" {
     Data.Functor.Product.$w$c*>_closure:
         const Data.Functor.Product.$w$c*>_info;
 },
 sat_sgaAM_entry() //  [R1]
         { info_tbl: [(cgc6m,
                       label: sat_sgaAM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc6m: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgc6n; else goto cgc6o;
       cgc6n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc6o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgc6k_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgc6k() //  [R1]
         { info_tbl: [(cgc6k,
                       label: block_cgc6k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc6k: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Product.$fApplicativeProduct1_closure+2;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgaAN_entry() //  [R1]
         { info_tbl: [(cgc6s,
                       label: sat_sgaAN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc6s: // global
           _sgaAN::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgc6t; else goto cgc6u;
       cgc6u: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgc6w; else goto cgc6v;
       cgc6w: // global
           HpAlloc = 32;
           goto cgc6t;
       cgc6t: // global
           R1 = _sgaAN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc6v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaAN::P64;
           _sgaAD::P64 = P64[_sgaAN::P64 + 16];
           _sgaAF::P64 = P64[_sgaAN::P64 + 24];
           _sgaAH::P64 = P64[_sgaAN::P64 + 32];
           I64[Hp - 24] = sat_sgaAM_info;
           P64[Hp - 8] = _sgaAD::P64;
           P64[Hp] = _sgaAF::P64;
           R2 = _sgaAD::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgaAH::P64;
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgaAJ_entry() //  [R1]
         { info_tbl: [(cgc6H,
                       label: sat_sgaAJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc6H: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgc6I; else goto cgc6J;
       cgc6I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc6J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgc6F_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgc6F() //  [R1]
         { info_tbl: [(cgc6F,
                       label: block_cgc6F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc6F: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Product.$fApplicativeProduct1_closure+2;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgaAK_entry() //  [R1]
         { info_tbl: [(cgc6N,
                       label: sat_sgaAK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc6N: // global
           _sgaAK::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgc6O; else goto cgc6P;
       cgc6P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgc6R; else goto cgc6Q;
       cgc6R: // global
           HpAlloc = 32;
           goto cgc6O;
       cgc6O: // global
           R1 = _sgaAK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc6Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaAK::P64;
           _sgaAC::P64 = P64[_sgaAK::P64 + 16];
           _sgaAE::P64 = P64[_sgaAK::P64 + 24];
           _sgaAG::P64 = P64[_sgaAK::P64 + 32];
           I64[Hp - 24] = sat_sgaAJ_info;
           P64[Hp - 8] = _sgaAC::P64;
           P64[Hp] = _sgaAE::P64;
           R2 = _sgaAC::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgaAG::P64;
           Sp = Sp - 40;
           call GHC.Base.<*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$c*>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgc6S,
                       label: Data.Functor.Product.$w$c*>_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc6S: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgc6W; else goto cgc6V;
       cgc6W: // global
           HpAlloc = 80;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$c*>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgc6V: // global
           I64[Hp - 72] = sat_sgaAN_info;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = P64[Sp];
           I64[Hp - 32] = sat_sgaAK_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R6;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.952558877 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$c*>_closure" {
     Data.Functor.Product.$fApplicativeProduct_$c*>_closure:
         const Data.Functor.Product.$fApplicativeProduct_$c*>_info;
 },
 Data.Functor.Product.$fApplicativeProduct_$c*>_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cgc7Q,
                       label: Data.Functor.Product.$fApplicativeProduct_$c*>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc7Q: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgc81; else goto cgc82;
       cgc81: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$c*>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgc82: // global
           I64[Sp - 32] = block_cgc7N_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugc89; else goto cgc7O;
       ugc89: // global
           call _cgc7N(R1) args: 0, res: 0, upd: 0;
       cgc7O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgc7N() //  [R1]
         { info_tbl: [(cgc7N,
                       label: block_cgc7N_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc7N: // global
           I64[Sp - 8] = block_cgc7T_info;
           _sgaAT::P64 = P64[R1 + 7];
           _sgaAU::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sgaAU::P64;
           P64[Sp + 24] = _sgaAT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugc88; else goto cgc7U;
       ugc88: // global
           call _cgc7T(R1) args: 0, res: 0, upd: 0;
       cgc7U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgc7T() //  [R1]
         { info_tbl: [(cgc7T,
                       label: block_cgc7T_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc7T: // global
           _sgaAT::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cgc7Y_info;
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 8];
           R4 = _sgaAT::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Functor.Product.$w$c*>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 8, upd: 8;
     }
 },
 _cgc7Y() //  [R1, R2]
         { info_tbl: [(cgc7Y,
                       label: block_cgc7Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc7Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgc87; else goto cgc86;
       cgc87: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgc86: // global
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.963057948 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_$c<*_closure" {
     Data.Functor.Product.$fApplicativeProduct_$c<*_closure:
         const Data.Functor.Product.$fApplicativeProduct_$c<*_info;
 },
 sat_sgaBc_entry() //  [R1]
         { info_tbl: [(cgc8O,
                       label: sat_sgaBc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc8O: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgc8P; else goto cgc8Q;
       cgc8P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc8Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Base.const_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sgaBb_entry() //  [R1]
         { info_tbl: [(cgc8V,
                       label: sat_sgaBb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc8V: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgc8W; else goto cgc8X;
       cgc8W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc8X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Base.const_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_$c<*_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cgc8Y,
                       label: Data.Functor.Product.$fApplicativeProduct_$c<*_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc8Y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgc90; else goto cgc91;
       cgc90: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_$c<*_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgc91: // global
           I64[Sp - 32] = block_cgc8A_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugc97; else goto cgc8B;
       ugc97: // global
           call _cgc8A(R1) args: 0, res: 0, upd: 0;
       cgc8B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgc8A() //  [R1]
         { info_tbl: [(cgc8A,
                       label: block_cgc8A_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc8A: // global
           I64[Sp - 8] = block_cgc8F_info;
           _sgaB6::P64 = P64[R1 + 7];
           _sgaB7::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sgaB7::P64;
           P64[Sp + 24] = _sgaB6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugc96; else goto cgc8G;
       ugc96: // global
           call _cgc8F(R1) args: 0, res: 0, upd: 0;
       cgc8G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgc8F() //  [R1]
         { info_tbl: [(cgc8F,
                       label: block_cgc8F_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc8F: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgc95; else goto cgc94;
       cgc95: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgc94: // global
           _sgaB9::P64 = P64[R1 + 7];
           _sgaBa::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgaBc_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sgaBa::P64;
           I64[Hp - 56] = sat_sgaBb_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sgaB9::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.976003278 UTC

[section ""data" . Data.Functor.Product.$fApplicativeProduct_closure" {
     Data.Functor.Product.$fApplicativeProduct_closure:
         const Data.Functor.Product.$fApplicativeProduct_info;
 },
 sat_sgaBk_entry() //  [R1, R2, R3]
         { info_tbl: [(cgca0,
                       label: sat_sgaBk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgca0: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fApplicativeProduct_$c<*_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaBj_entry() //  [R1, R2, R3]
         { info_tbl: [(cgca8,
                       label: sat_sgaBj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgca8: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fApplicativeProduct_$c*>_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaBi_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgcag,
                       label: sat_sgaBi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcag: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fApplicativeProduct_$cliftA2_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaBh_entry() //  [R1, R2, R3]
         { info_tbl: [(cgcao,
                       label: sat_sgaBh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcao: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fApplicativeProduct_$c<*>_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaBg_entry() //  [R1, R2]
         { info_tbl: [(cgcaw,
                       label: sat_sgaBg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcaw: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fApplicativeProduct_$cpure_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaBf_entry() //  [R1]
         { info_tbl: [(cgcaD,
                       label: sat_sgaBf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcaD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcaE; else goto cgcaF;
       cgcaE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcaF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fApplicativeProduct_$cp1Applicative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fApplicativeProduct_entry() //  [R2, R3]
         { info_tbl: [(cgcaH,
                       label: Data.Functor.Product.$fApplicativeProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcaH: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cgcaL; else goto cgcaK;
       cgcaL: // global
           HpAlloc = 208;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fApplicativeProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcaK: // global
           I64[Hp - 200] = sat_sgaBk_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sgaBj_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sgaBi_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sgaBh_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sgaBg_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sgaBf_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 103;
           P64[Hp - 24] = Hp - 126;
           P64[Hp - 16] = Hp - 149;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 198;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:04.991698315 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$c<|>_closure" {
     Data.Functor.Product.$fAlternativeProduct_$c<|>_closure:
         const Data.Functor.Product.$fAlternativeProduct_$c<|>_info;
 },
 sat_sgaBw_entry() //  [R1]
         { info_tbl: [(cgcbG,
                       label: sat_sgaBw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcbG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgcbH; else goto cgcbI;
       cgcbH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcbI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgaBv_entry() //  [R1]
         { info_tbl: [(cgcbN,
                       label: sat_sgaBv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcbN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgcbO; else goto cgcbP;
       cgcbO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcbP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_$c<|>_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cgcbQ,
                       label: Data.Functor.Product.$fAlternativeProduct_$c<|>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcbQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgcbS; else goto cgcbT;
       cgcbS: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$c<|>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcbT: // global
           I64[Sp - 32] = block_cgcbs_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugcbZ; else goto cgcbt;
       ugcbZ: // global
           call _cgcbs(R1) args: 0, res: 0, upd: 0;
       cgcbt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcbs() //  [R1]
         { info_tbl: [(cgcbs,
                       label: block_cgcbs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcbs: // global
           I64[Sp - 8] = block_cgcbx_info;
           _sgaBq::P64 = P64[R1 + 7];
           _sgaBr::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sgaBr::P64;
           P64[Sp + 24] = _sgaBq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcbY; else goto cgcby;
       ugcbY: // global
           call _cgcbx(R1) args: 0, res: 0, upd: 0;
       cgcby: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcbx() //  [R1]
         { info_tbl: [(cgcbx,
                       label: block_cgcbx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcbx: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgcbX; else goto cgcbW;
       cgcbX: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcbW: // global
           _sgaBt::P64 = P64[R1 + 7];
           _sgaBu::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgaBw_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sgaBu::P64;
           I64[Hp - 56] = sat_sgaBv_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sgaBt::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.004094078 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$cempty_closure" {
     Data.Functor.Product.$fAlternativeProduct_$cempty_closure:
         const Data.Functor.Product.$fAlternativeProduct_$cempty_info;
 },
 sat_sgaBA_entry() //  [R1]
         { info_tbl: [(cgccN,
                       label: sat_sgaBA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgccN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgccO; else goto cgccP;
       cgccO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgccP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaBz_entry() //  [R1]
         { info_tbl: [(cgccU,
                       label: sat_sgaBz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgccU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgccV; else goto cgccW;
       cgccV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgccW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_$cempty_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cgccY,
                       label: Data.Functor.Product.$fAlternativeProduct_$cempty_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgccY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgcd2; else goto cgcd1;
       cgcd2: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$cempty_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcd1: // global
           I64[Hp - 64] = sat_sgaBA_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgaBz_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.011715276 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_closure" {
     Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_closure:
         const Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_info;
 },
 sat_sgaBE_entry() //  [R1]
         { info_tbl: [(cgcdv,
                       label: sat_sgaBE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcdv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcdw; else goto cgcdx;
       cgcdw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcdx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaBD_entry() //  [R1]
         { info_tbl: [(cgcdC,
                       label: sat_sgaBD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcdC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcdD; else goto cgcdE;
       cgcdD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcdE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgcdF,
                       label: Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcdF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgcdJ; else goto cgcdI;
       cgcdJ: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcdI: // global
           I64[Hp - 40] = sat_sgaBE_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgaBD_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fApplicativeProduct_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.019153169 UTC

[section ""data" . poly_some_v_rg5o0_closure" {
     poly_some_v_rg5o0_closure:
         const poly_some_v_rg5o0_info;
         const 0;
         const 0;
         const 0;
 },
 poly_some_v_rg5o0_entry() //  [R1]
         { info_tbl: [(cgce6,
                       label: poly_some_v_rg5o0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgce6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgce7; else goto cgce8;
       cgce7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgce8: // global
           (_cgce3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgce3::I64 == 0) goto cgce5; else goto cgce4;
       cgce5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgce4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgce3::I64;
           R1 = poly_some_v_rg5o0_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.023829715 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_$csome_closure" {
     Data.Functor.Product.$fAlternativeProduct_$csome_closure:
         const Data.Functor.Product.$fAlternativeProduct_$csome_info;
         const 0;
 },
 Data.Functor.Product.$fAlternativeProduct_$csome_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgcep,
                       label: Data.Functor.Product.$fAlternativeProduct_$csome_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcep: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgceq; else goto cgcer;
       cgceq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_$csome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcer: // global
           I64[Sp - 8] = block_cgcem_info;
           R1 = R4;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcev; else goto cgcen;
       ugcev: // global
           call _cgcem() args: 0, res: 0, upd: 0;
       cgcen: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcem() //  []
         { info_tbl: [(cgcem,
                       label: block_cgcem_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcem: // global
           R1 = poly_some_v_rg5o0_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.030420645 UTC

[section ""data" . Data.Functor.Product.$fAlternativeProduct_closure" {
     Data.Functor.Product.$fAlternativeProduct_closure:
         const Data.Functor.Product.$fAlternativeProduct_info;
         const 0;
 },
 sat_sgaBR_entry() //  [R1, R2]
         { info_tbl: [(cgceQ,
                       label: sat_sgaBR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgceQ: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fAlternativeProduct_$csome_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaBQ_entry() //  [R1, R2]
         { info_tbl: [(cgceY,
                       label: sat_sgaBQ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgceY: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fAlternativeProduct_$csome_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaBP_entry() //  [R1, R2, R3]
         { info_tbl: [(cgcf6,
                       label: sat_sgaBP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcf6: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fAlternativeProduct_$c<|>_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaBO_entry() //  [R1]
         { info_tbl: [(cgcfd,
                       label: sat_sgaBO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcfd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcfe; else goto cgcff;
       cgcfe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcff: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fAlternativeProduct_$cempty_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaBN_entry() //  [R1]
         { info_tbl: [(cgcfk,
                       label: sat_sgaBN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcfk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcfl; else goto cgcfm;
       cgcfl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcfm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fAlternativeProduct_$cp1Alternative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fAlternativeProduct_entry() //  [R2, R3]
         { info_tbl: [(cgcfo,
                       label: Data.Functor.Product.$fAlternativeProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcfo: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cgcfs; else goto cgcfr;
       cgcfs: // global
           HpAlloc = 184;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fAlternativeProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcfr: // global
           I64[Hp - 176] = sat_sgaBR_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sgaBQ_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sgaBP_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sgaBO_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_sgaBN_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 104;
           P64[Hp - 16] = Hp - 126;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 175;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.044319565 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$c>>=_closure" {
     Data.Functor.Product.$fMonadProduct_$c>>=_closure:
         const Data.Functor.Product.$fMonadProduct_$c>>=_info;
 },
 sat_sgaC9_entry() //  [R1, R2]
         { info_tbl: [(cgcgm,
                       label: sat_sgaC9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcgm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcgn; else goto cgcgo;
       cgcgn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcgo: // global
           I64[Sp - 8] = block_cgcgk_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcgk() //  [R1]
         { info_tbl: [(cgcgk,
                       label: block_cgcgk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcgk: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaCa_entry() //  [R1]
         { info_tbl: [(cgcgs,
                       label: sat_sgaCa_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcgs: // global
           _sgaCa::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgcgt; else goto cgcgu;
       cgcgu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgcgw; else goto cgcgv;
       cgcgw: // global
           HpAlloc = 16;
           goto cgcgt;
       cgcgt: // global
           R1 = _sgaCa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcgv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaCa::P64;
           _sgaBT::P64 = P64[_sgaCa::P64 + 16];
           _sgaBV::P64 = P64[_sgaCa::P64 + 24];
           _sgaBY::P64 = P64[_sgaCa::P64 + 32];
           I64[Hp - 8] = sat_sgaC9_info;
           P64[Hp] = _sgaBV::P64;
           R2 = _sgaBT::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgaBY::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgaC3_entry() //  [R1, R2]
         { info_tbl: [(cgcgI,
                       label: sat_sgaC3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcgI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcgJ; else goto cgcgK;
       cgcgJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcgK: // global
           I64[Sp - 8] = block_cgcgG_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcgG() //  [R1]
         { info_tbl: [(cgcgG,
                       label: block_cgcgG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcgG: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaC4_entry() //  [R1]
         { info_tbl: [(cgcgO,
                       label: sat_sgaC4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcgO: // global
           _sgaC4::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgcgP; else goto cgcgQ;
       cgcgQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgcgS; else goto cgcgR;
       cgcgS: // global
           HpAlloc = 16;
           goto cgcgP;
       cgcgP: // global
           R1 = _sgaC4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcgR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaC4::P64;
           _sgaBS::P64 = P64[_sgaC4::P64 + 16];
           _sgaBV::P64 = P64[_sgaC4::P64 + 24];
           _sgaBX::P64 = P64[_sgaC4::P64 + 32];
           I64[Hp - 8] = sat_sgaC3_info;
           P64[Hp] = _sgaBV::P64;
           R2 = _sgaBS::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgaBX::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$c>>=_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cgcgT,
                       label: Data.Functor.Product.$fMonadProduct_$c>>=_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcgT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgcgV; else goto cgcgW;
       cgcgV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$c>>=_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcgW: // global
           I64[Sp - 32] = block_cgcg6_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugch0; else goto cgcg7;
       ugch0: // global
           call _cgcg6(R1) args: 0, res: 0, upd: 0;
       cgcg7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcg6() //  [R1]
         { info_tbl: [(cgcg6,
                       label: block_cgcg6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcg6: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgcgZ; else goto cgcgY;
       cgcgZ: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcgY: // global
           _sgaBX::P64 = P64[R1 + 7];
           _sgaBY::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgaCa_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sgaBV::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sgaBV::P64;
           P64[Hp - 64] = _sgaBY::P64;
           I64[Hp - 56] = sat_sgaC4_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgaBV::P64;
           P64[Hp - 24] = _sgaBX::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.062644369 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$cp1Monad_closure" {
     Data.Functor.Product.$fMonadProduct_$cp1Monad_closure:
         const Data.Functor.Product.$fMonadProduct_$cp1Monad_info;
 },
 sat_sgaCe_entry() //  [R1]
         { info_tbl: [(cgchX,
                       label: sat_sgaCe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgchX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgchY; else goto cgchZ;
       cgchY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgchZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaCd_entry() //  [R1]
         { info_tbl: [(cgci4,
                       label: sat_sgaCd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgci4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgci5; else goto cgci6;
       cgci5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgci6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$cp1Monad_entry() //  [R2, R3]
         { info_tbl: [(cgci7,
                       label: Data.Functor.Product.$fMonadProduct_$cp1Monad_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgci7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgcib; else goto cgcia;
       cgcib: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$cp1Monad_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcia: // global
           I64[Hp - 40] = sat_sgaCe_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgaCd_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fApplicativeProduct_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.070649748 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$creturn_closure" {
     Data.Functor.Product.$fMonadProduct_$creturn_closure:
         const Data.Functor.Product.$fMonadProduct_$creturn_info;
 },
 sat_sgaCl_entry() //  [R1]
         { info_tbl: [(cgciC,
                       label: sat_sgaCl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgciC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgciD; else goto cgciE;
       cgciD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgciE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgciA_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgciA() //  [R1]
         { info_tbl: [(cgciA,
                       label: block_cgciA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgciA: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgaCj_entry() //  [R1]
         { info_tbl: [(cgciO,
                       label: sat_sgaCj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgciO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgciP; else goto cgciQ;
       cgciP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgciQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgciM_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgciM() //  [R1]
         { info_tbl: [(cgciM,
                       label: block_cgciM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgciM: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$creturn_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cgciV,
                       label: Data.Functor.Product.$fMonadProduct_$creturn_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgciV: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgciZ; else goto cgciY;
       cgciZ: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$creturn_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgciY: // global
           I64[Hp - 80] = sat_sgaCl_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sgaCj_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.082756334 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_$c>>_closure" {
     Data.Functor.Product.$fMonadProduct_$c>>_closure:
         const Data.Functor.Product.$fMonadProduct_$c>>_info;
 },
 sat_sgaCD_entry() //  [R1, R2]
         { info_tbl: [(cgcjR,
                       label: sat_sgaCD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcjR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcjS; else goto cgcjT;
       cgcjS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcjT: // global
           I64[Sp - 8] = block_cgcjO_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcjX; else goto cgcjP;
       ugcjX: // global
           call _cgcjO(R1) args: 0, res: 0, upd: 0;
       cgcjP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcjO() //  [R1]
         { info_tbl: [(cgcjO,
                       label: block_cgcjO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcjO: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaCE_entry() //  [R1]
         { info_tbl: [(cgcjY,
                       label: sat_sgaCE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcjY: // global
           _sgaCE::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgcjZ; else goto cgck0;
       cgck0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgck2; else goto cgck1;
       cgck2: // global
           HpAlloc = 16;
           goto cgcjZ;
       cgcjZ: // global
           R1 = _sgaCE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgck1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaCE::P64;
           _sgaCn::P64 = P64[_sgaCE::P64 + 16];
           _sgaCp::P64 = P64[_sgaCE::P64 + 24];
           _sgaCs::P64 = P64[_sgaCE::P64 + 32];
           I64[Hp - 8] = sat_sgaCD_info;
           P64[Hp] = _sgaCp::P64;
           R2 = _sgaCn::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgaCs::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgaCx_entry() //  [R1, R2]
         { info_tbl: [(cgckf,
                       label: sat_sgaCx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgckf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgckg; else goto cgckh;
       cgckg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgckh: // global
           I64[Sp - 8] = block_cgckc_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugckl; else goto cgckd;
       ugckl: // global
           call _cgckc(R1) args: 0, res: 0, upd: 0;
       cgckd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgckc() //  [R1]
         { info_tbl: [(cgckc,
                       label: block_cgckc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgckc: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaCy_entry() //  [R1]
         { info_tbl: [(cgckm,
                       label: sat_sgaCy_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgckm: // global
           _sgaCy::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgckn; else goto cgcko;
       cgcko: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgckq; else goto cgckp;
       cgckq: // global
           HpAlloc = 16;
           goto cgckn;
       cgckn: // global
           R1 = _sgaCy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgckp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaCy::P64;
           _sgaCm::P64 = P64[_sgaCy::P64 + 16];
           _sgaCp::P64 = P64[_sgaCy::P64 + 24];
           _sgaCr::P64 = P64[_sgaCy::P64 + 32];
           I64[Hp - 8] = sat_sgaCx_info;
           P64[Hp] = _sgaCp::P64;
           R2 = _sgaCm::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgaCr::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_$c>>_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(cgckr,
                       label: Data.Functor.Product.$fMonadProduct_$c>>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgckr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgckt; else goto cgcku;
       cgckt: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_$c>>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcku: // global
           I64[Sp - 32] = block_cgcjA_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugcky; else goto cgcjB;
       ugcky: // global
           call _cgcjA(R1) args: 0, res: 0, upd: 0;
       cgcjB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcjA() //  [R1]
         { info_tbl: [(cgcjA,
                       label: block_cgcjA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcjA: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgckx; else goto cgckw;
       cgckx: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgckw: // global
           _sgaCr::P64 = P64[R1 + 7];
           _sgaCs::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgaCE_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sgaCp::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sgaCp::P64;
           P64[Hp - 64] = _sgaCs::P64;
           I64[Hp - 56] = sat_sgaCy_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgaCp::P64;
           P64[Hp - 24] = _sgaCr::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.10016036 UTC

[section ""data" . lvl4_rg5o1_closure" {
     lvl4_rg5o1_closure:
         const lvl4_rg5o1_info;
         const 0;
 },
 lvl4_rg5o1_entry() //  [R2]
         { info_tbl: [(cgclt,
                       label: lvl4_rg5o1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgclt: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.104716524 UTC

[section ""data" . Data.Functor.Product.$fMonadProduct_closure" {
     Data.Functor.Product.$fMonadProduct_closure:
         const Data.Functor.Product.$fMonadProduct_info;
         const 0;
 },
 sat_sgaCL_entry() //  [R1, R2]
         { info_tbl: [(cgclJ,
                       label: sat_sgaCL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgclJ: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fMonadProduct_$creturn_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaCK_entry() //  [R1, R2, R3]
         { info_tbl: [(cgclR,
                       label: sat_sgaCK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgclR: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadProduct_$c>>_entry(R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaCJ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgclZ,
                       label: sat_sgaCJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgclZ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadProduct_$c>>=_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaCI_entry() //  [R1]
         { info_tbl: [(cgcm6,
                       label: sat_sgaCI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcm6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcm7; else goto cgcm8;
       cgcm7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcm8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadProduct_$cp1Monad_entry(R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadProduct_entry() //  [R2, R3]
         { info_tbl: [(cgcma,
                       label: Data.Functor.Product.$fMonadProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcma: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cgcme; else goto cgcmd;
       cgcme: // global
           HpAlloc = 152;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcmd: // global
           I64[Hp - 144] = sat_sgaCL_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_sgaCK_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_sgaCJ_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_sgaCI_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 94;
           P64[Hp - 16] = Hp - 118;
           P64[Hp - 8] = Hp - 143;
           P64[Hp] = lvl4_rg5o1_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.116368147 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cmplus_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cmplus_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cmplus_info;
 },
 sat_sgaCX_entry() //  [R1]
         { info_tbl: [(cgcn0,
                       label: sat_sgaCX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcn0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgcn1; else goto cgcn2;
       cgcn1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcn2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgaCW_entry() //  [R1]
         { info_tbl: [(cgcn7,
                       label: sat_sgaCW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcn7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgcn8; else goto cgcn9;
       cgcn8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcn9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cmplus_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cgcna,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cmplus_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcna: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgcnc; else goto cgcnd;
       cgcnc: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cmplus_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcnd: // global
           I64[Sp - 32] = block_cgcmM_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugcnj; else goto cgcmN;
       ugcnj: // global
           call _cgcmM(R1) args: 0, res: 0, upd: 0;
       cgcmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcmM() //  [R1]
         { info_tbl: [(cgcmM,
                       label: block_cgcmM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcmM: // global
           I64[Sp - 8] = block_cgcmR_info;
           _sgaCR::P64 = P64[R1 + 7];
           _sgaCS::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sgaCS::P64;
           P64[Sp + 24] = _sgaCR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcni; else goto cgcmS;
       ugcni: // global
           call _cgcmR(R1) args: 0, res: 0, upd: 0;
       cgcmS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcmR() //  [R1]
         { info_tbl: [(cgcmR,
                       label: block_cgcmR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcmR: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgcnh; else goto cgcng;
       cgcnh: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcng: // global
           _sgaCU::P64 = P64[R1 + 7];
           _sgaCV::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgaCX_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sgaCV::P64;
           I64[Hp - 56] = sat_sgaCW_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sgaCU::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.128849309 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cmzero_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cmzero_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cmzero_info;
 },
 sat_sgaD1_entry() //  [R1]
         { info_tbl: [(cgco7,
                       label: sat_sgaD1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgco7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgco8; else goto cgco9;
       cgco8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgco9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaD0_entry() //  [R1]
         { info_tbl: [(cgcoe,
                       label: sat_sgaD0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcoe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcof; else goto cgcog;
       cgcof: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcog: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cmzero_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cgcoi,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cmzero_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcoi: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgcom; else goto cgcol;
       cgcom: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cmzero_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcol: // global
           I64[Hp - 64] = sat_sgaD1_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgaD0_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.136783467 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_info;
         const 0;
 },
 sat_sgaD5_entry() //  [R1]
         { info_tbl: [(cgcoP,
                       label: sat_sgaD5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcoP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcoQ; else goto cgcoR;
       cgcoQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcoR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaD4_entry() //  [R1]
         { info_tbl: [(cgcoW,
                       label: sat_sgaD4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcoW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcoX; else goto cgcoY;
       cgcoX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcoY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cgcoZ,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcoZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgcp3; else goto cgcp2;
       cgcp3: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcp2: // global
           I64[Hp - 40] = sat_sgaD5_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgaD4_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fMonadProduct_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.14588575 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure" {
     Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure:
         const Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_info;
         const 0;
 },
 sat_sgaD9_entry() //  [R1]
         { info_tbl: [(cgcps,
                       label: sat_sgaD9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcps: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcpt; else goto cgcpu;
       cgcpt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcpu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaD8_entry() //  [R1]
         { info_tbl: [(cgcpz,
                       label: sat_sgaD8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcpz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcpA; else goto cgcpB;
       cgcpA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcpB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cgcpC,
                       label: Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcpC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgcpG; else goto cgcpF;
       cgcpG: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcpF: // global
           I64[Hp - 40] = sat_sgaD9_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgaD8_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fAlternativeProduct_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.154158875 UTC

[section ""data" . Data.Functor.Product.$fMonadPlusProduct_closure" {
     Data.Functor.Product.$fMonadPlusProduct_closure:
         const Data.Functor.Product.$fMonadPlusProduct_info;
         const 0;
 },
 sat_sgaDf_entry() //  [R1, R2, R3]
         { info_tbl: [(cgcq6,
                       label: sat_sgaDf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcq6: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadPlusProduct_$cmplus_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaDe_entry() //  [R1]
         { info_tbl: [(cgcqd,
                       label: sat_sgaDe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcqd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcqe; else goto cgcqf;
       cgcqe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcqf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadPlusProduct_$cmzero_entry(R3,
                                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaDd_entry() //  [R1]
         { info_tbl: [(cgcqk,
                       label: sat_sgaDd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcqk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcql; else goto cgcqm;
       cgcql: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcqm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_entry(R3,
                                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaDc_entry() //  [R1]
         { info_tbl: [(cgcqr,
                       label: sat_sgaDc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcqr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcqs; else goto cgcqt;
       cgcqs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcqt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_entry(R3,
                                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadPlusProduct_entry() //  [R2, R3]
         { info_tbl: [(cgcqv,
                       label: Data.Functor.Product.$fMonadPlusProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcqv: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cgcqz; else goto cgcqy;
       cgcqz: // global
           HpAlloc = 160;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadPlusProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcqy: // global
           I64[Hp - 152] = sat_sgaDf_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sgaDe_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_sgaDd_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sgaDc_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 96;
           P64[Hp - 8] = Hp - 128;
           P64[Hp] = Hp - 150;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.166561148 UTC

[section ""data" . Data.Functor.Product.$fMonadFixProduct_$cmfix_closure" {
     Data.Functor.Product.$fMonadFixProduct_$cmfix_closure:
         const Data.Functor.Product.$fMonadFixProduct_$cmfix_info;
 },
 sat_sgaDt_entry() //  [R1, R2]
         { info_tbl: [(cgcrl,
                       label: sat_sgaDt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcrl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcrm; else goto cgcrn;
       cgcrm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcrn: // global
           I64[Sp - 8] = block_cgcrj_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcrj() //  [R1]
         { info_tbl: [(cgcrj,
                       label: block_cgcrj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcrj: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaDu_entry() //  [R1]
         { info_tbl: [(cgcrr,
                       label: sat_sgaDu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcrr: // global
           _sgaDu::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgcrs; else goto cgcrt;
       cgcrt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgcrv; else goto cgcru;
       cgcrv: // global
           HpAlloc = 16;
           goto cgcrs;
       cgcrs: // global
           R1 = _sgaDu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcru: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaDu::P64;
           _sgaDh::P64 = P64[_sgaDu::P64 + 16];
           _sgaDi::P64 = P64[_sgaDu::P64 + 24];
           I64[Hp - 8] = sat_sgaDt_info;
           P64[Hp] = _sgaDi::P64;
           R2 = _sgaDh::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgaDn_entry() //  [R1, R2]
         { info_tbl: [(cgcrH,
                       label: sat_sgaDn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcrH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcrI; else goto cgcrJ;
       cgcrI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcrJ: // global
           I64[Sp - 8] = block_cgcrF_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcrF() //  [R1]
         { info_tbl: [(cgcrF,
                       label: block_cgcrF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcrF: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaDo_entry() //  [R1]
         { info_tbl: [(cgcrN,
                       label: sat_sgaDo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcrN: // global
           _sgaDo::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgcrO; else goto cgcrP;
       cgcrP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgcrR; else goto cgcrQ;
       cgcrR: // global
           HpAlloc = 16;
           goto cgcrO;
       cgcrO: // global
           R1 = _sgaDo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcrQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaDo::P64;
           _sgaDg::P64 = P64[_sgaDo::P64 + 16];
           _sgaDi::P64 = P64[_sgaDo::P64 + 24];
           I64[Hp - 8] = sat_sgaDn_info;
           P64[Hp] = _sgaDi::P64;
           R2 = _sgaDg::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadFixProduct_$cmfix_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgcrT,
                       label: Data.Functor.Product.$fMonadFixProduct_$cmfix_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcrT: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgcrX; else goto cgcrW;
       cgcrX: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadFixProduct_$cmfix_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcrW: // global
           I64[Hp - 80] = sat_sgaDu_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sgaDo_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.182647203 UTC

[section ""data" . Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure" {
     Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure:
         const Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_info;
         const 0;
 },
 sat_sgaDy_entry() //  [R1]
         { info_tbl: [(cgcsM,
                       label: sat_sgaDy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcsM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcsN; else goto cgcsO;
       cgcsN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcsO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaDx_entry() //  [R1]
         { info_tbl: [(cgcsT,
                       label: sat_sgaDx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcsT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcsU; else goto cgcsV;
       cgcsU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcsV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cgcsW,
                       label: Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcsW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgct0; else goto cgcsZ;
       cgct0: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcsZ: // global
           I64[Hp - 40] = sat_sgaDy_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgaDx_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fMonadProduct_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.190540179 UTC

[section ""data" . Data.Functor.Product.$fMonadFixProduct_closure" {
     Data.Functor.Product.$fMonadFixProduct_closure:
         const Data.Functor.Product.$fMonadFixProduct_info;
         const 0;
 },
 sat_sgaDC_entry() //  [R1, R2]
         { info_tbl: [(cgctq,
                       label: sat_sgaDC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgctq: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fMonadFixProduct_$cmfix_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaDB_entry() //  [R1]
         { info_tbl: [(cgctx,
                       label: sat_sgaDB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgctx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcty; else goto cgctz;
       cgcty: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgctz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_entry(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadFixProduct_entry() //  [R2, R3]
         { info_tbl: [(cgctB,
                       label: Data.Functor.Product.$fMonadFixProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgctB: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgctF; else goto cgctE;
       cgctF: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadFixProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgctE: // global
           I64[Hp - 72] = sat_sgaDC_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sgaDB_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 71;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.199048466 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cmzipWith_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cmzipWith_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cmzipWith_info;
 },
 sat_sgaDP_entry() //  [R1]
         { info_tbl: [(cgcug,
                       label: sat_sgaDP_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcug: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgcuh; else goto cgcui;
       cgcuh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcui: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sgaDO_entry() //  [R1]
         { info_tbl: [(cgcun,
                       label: sat_sgaDO_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcun: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgcuo; else goto cgcup;
       cgcuo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcup: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_$cmzipWith_entry() //  [R2,
                                                                R3, R4, R5, R6]
         { info_tbl: [(cgcuq,
                       label: Data.Functor.Product.$fMonadZipProduct_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcuq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgcus; else goto cgcut;
       cgcus: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cmzipWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcut: // global
           I64[Sp - 40] = block_cgcu2_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugcuz; else goto cgcu3;
       ugcuz: // global
           call _cgcu2(R1) args: 0, res: 0, upd: 0;
       cgcu3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcu2() //  [R1]
         { info_tbl: [(cgcu2,
                       label: block_cgcu2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcu2: // global
           I64[Sp - 8] = block_cgcu7_info;
           _sgaDJ::P64 = P64[R1 + 7];
           _sgaDK::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sgaDK::P64;
           P64[Sp + 32] = _sgaDJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcuy; else goto cgcu8;
       ugcuy: // global
           call _cgcu7(R1) args: 0, res: 0, upd: 0;
       cgcu8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcu7() //  [R1]
         { info_tbl: [(cgcu7,
                       label: block_cgcu7_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcu7: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cgcux; else goto cgcuw;
       cgcux: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcuw: // global
           _sgaDM::P64 = P64[R1 + 7];
           _sgaDN::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sgaDP_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sgaDF::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sgaDF::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sgaDN::P64;
           I64[Hp - 64] = sat_sgaDO_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sgaDF::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sgaDM::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.211638875 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_info;
         const 0;
 },
 sat_sgaDT_entry() //  [R1]
         { info_tbl: [(cgcvp,
                       label: sat_sgaDT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcvp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcvq; else goto cgcvr;
       cgcvq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcvr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaDS_entry() //  [R1]
         { info_tbl: [(cgcvw,
                       label: sat_sgaDS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcvw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcvx; else goto cgcvy;
       cgcvx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcvy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cgcvz,
                       label: Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcvz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgcvD; else goto cgcvC;
       cgcvD: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcvC: // global
           I64[Hp - 40] = sat_sgaDT_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgaDS_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Product.$fMonadProduct_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.219695552 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cmzip_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cmzip_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cmzip_info;
 },
 sat_sgaE5_entry() //  [R1]
         { info_tbl: [(cgcwc,
                       label: sat_sgaE5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcwc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgcwd; else goto cgcwe;
       cgcwd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcwe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sgaE4_entry() //  [R1]
         { info_tbl: [(cgcwj,
                       label: sat_sgaE4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcwj: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgcwk; else goto cgcwl;
       cgcwk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcwl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_$cmzip_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cgcwm,
                       label: Data.Functor.Product.$fMonadZipProduct_$cmzip_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcwm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgcwo; else goto cgcwp;
       cgcwo: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cmzip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcwp: // global
           I64[Sp - 32] = block_cgcvY_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugcwv; else goto cgcvZ;
       ugcwv: // global
           call _cgcvY(R1) args: 0, res: 0, upd: 0;
       cgcvZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcvY() //  [R1]
         { info_tbl: [(cgcvY,
                       label: block_cgcvY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcvY: // global
           I64[Sp - 8] = block_cgcw3_info;
           _sgaDZ::P64 = P64[R1 + 7];
           _sgaE0::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sgaE0::P64;
           P64[Sp + 24] = _sgaDZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcwu; else goto cgcw4;
       ugcwu: // global
           call _cgcw3(R1) args: 0, res: 0, upd: 0;
       cgcw4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcw3() //  [R1]
         { info_tbl: [(cgcw3,
                       label: block_cgcw3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcw3: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgcwt; else goto cgcws;
       cgcwt: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcws: // global
           _sgaE2::P64 = P64[R1 + 7];
           _sgaE3::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgaE5_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sgaE3::P64;
           I64[Hp - 56] = sat_sgaE4_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sgaE2::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.235283202 UTC

[section ""data" . Data.Functor.Product.$w$cmunzip_closure" {
     Data.Functor.Product.$w$cmunzip_closure:
         const Data.Functor.Product.$w$cmunzip_info;
 },
 $dMonad_sgaE9_entry() //  [R1]
         { info_tbl: [(cgcxn,
                       label: $dMonad_sgaE9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcxn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcxo; else goto cgcxp;
       cgcxo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcxp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dMonad1_sgaEa_entry() //  [R1]
         { info_tbl: [(cgcxu,
                       label: $dMonad1_sgaEa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcxu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcxv; else goto cgcxw;
       cgcxv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcxw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sgaEG_entry() //  [R1]
         { info_tbl: [(cgcxO,
                       label: lvl9_sgaEG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcxO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcxP; else goto cgcxQ;
       cgcxP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcxQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaEM_entry() //  [R1, R2]
         { info_tbl: [(cgcxX,
                       label: sat_sgaEM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcxX: // global
           _sgaEH::P64 = R2;
           _sgaEM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgcxY; else goto cgcxZ;
       cgcxZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcy1; else goto cgcy0;
       cgcy1: // global
           HpAlloc = 24;
           goto cgcxY;
       cgcxY: // global
           R2 = _sgaEH::P64;
           R1 = _sgaEM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcy0: // global
           _sgaEG::P64 = P64[_sgaEM::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sgaEH::P64;
           R2 = _sgaEG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgaEN_entry() //  [R1]
         { info_tbl: [(cgcy2,
                       label: sat_sgaEN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcy2: // global
           _sgaEN::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgcy3; else goto cgcy4;
       cgcy4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgcy6; else goto cgcy5;
       cgcy6: // global
           HpAlloc = 40;
           goto cgcy3;
       cgcy3: // global
           R1 = _sgaEN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcy5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaEN::P64;
           _sgaEa::P64 = P64[_sgaEN::P64 + 16];
           _sgaEx::P64 = P64[_sgaEN::P64 + 24];
           I64[Hp - 32] = lvl9_sgaEG_info;
           P64[Hp - 16] = _sgaEa::P64;
           I64[Hp - 8] = sat_sgaEM_info;
           P64[Hp] = Hp - 32;
           R2 = _sgaEa::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgaEx::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 lvl9_sgaEy_entry() //  [R1]
         { info_tbl: [(cgcyf,
                       label: lvl9_sgaEy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcyf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcyg; else goto cgcyh;
       cgcyg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcyh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaEE_entry() //  [R1, R2]
         { info_tbl: [(cgcyo,
                       label: sat_sgaEE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcyo: // global
           _sgaEz::P64 = R2;
           _sgaEE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgcyp; else goto cgcyq;
       cgcyq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcys; else goto cgcyr;
       cgcys: // global
           HpAlloc = 24;
           goto cgcyp;
       cgcyp: // global
           R2 = _sgaEz::P64;
           R1 = _sgaEE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcyr: // global
           _sgaEy::P64 = P64[_sgaEE::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sgaEz::P64;
           R2 = _sgaEy::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgaEF_entry() //  [R1]
         { info_tbl: [(cgcyt,
                       label: sat_sgaEF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcyt: // global
           _sgaEF::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgcyu; else goto cgcyv;
       cgcyv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgcyx; else goto cgcyw;
       cgcyx: // global
           HpAlloc = 40;
           goto cgcyu;
       cgcyu: // global
           R1 = _sgaEF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcyw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaEF::P64;
           _sgaE9::P64 = P64[_sgaEF::P64 + 16];
           _sgaEw::P64 = P64[_sgaEF::P64 + 24];
           I64[Hp - 32] = lvl9_sgaEy_info;
           P64[Hp - 16] = _sgaE9::P64;
           I64[Hp - 8] = sat_sgaEE_info;
           P64[Hp] = Hp - 32;
           R2 = _sgaE9::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgaEw::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgaEO_entry() //  [R1]
         { info_tbl: [(cgcyy,
                       label: sat_sgaEO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcyy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgcyA; else goto cgcyB;
       cgcyA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcyB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgcxB_info;
           _sgaE9::P64 = P64[R1 + 24];
           _sgaEa::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sgaE9::P64;
           P64[Sp - 24] = _sgaEa::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugcyF; else goto cgcxC;
       ugcyF: // global
           call _cgcxB(R1) args: 0, res: 0, upd: 0;
       cgcxC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgcxB() //  [R1]
         { info_tbl: [(cgcxB,
                       label: block_cgcxB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcxB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgcyE; else goto cgcyD;
       cgcyE: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cgcyD: // global
           _sgaEw::P64 = P64[R1 + 7];
           _sgaEx::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sgaEN_info;
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = _sgaEx::P64;
           I64[Hp - 48] = sat_sgaEF_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgaEw::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sgaEm_entry() //  [R1]
         { info_tbl: [(cgcyX,
                       label: lvl9_sgaEm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcyX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcyY; else goto cgcyZ;
       cgcyY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcyZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaEs_entry() //  [R1, R2]
         { info_tbl: [(cgcz6,
                       label: sat_sgaEs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcz6: // global
           _sgaEn::P64 = R2;
           _sgaEs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgcz7; else goto cgcz8;
       cgcz8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcza; else goto cgcz9;
       cgcza: // global
           HpAlloc = 24;
           goto cgcz7;
       cgcz7: // global
           R2 = _sgaEn::P64;
           R1 = _sgaEs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcz9: // global
           _sgaEm::P64 = P64[_sgaEs::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sgaEn::P64;
           R2 = _sgaEm::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgaEt_entry() //  [R1]
         { info_tbl: [(cgczb,
                       label: sat_sgaEt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgczb: // global
           _sgaEt::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgczc; else goto cgczd;
       cgczd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgczf; else goto cgcze;
       cgczf: // global
           HpAlloc = 40;
           goto cgczc;
       cgczc: // global
           R1 = _sgaEt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcze: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaEt::P64;
           _sgaEa::P64 = P64[_sgaEt::P64 + 16];
           _sgaEd::P64 = P64[_sgaEt::P64 + 24];
           I64[Hp - 32] = lvl9_sgaEm_info;
           P64[Hp - 16] = _sgaEa::P64;
           I64[Hp - 8] = sat_sgaEs_info;
           P64[Hp] = Hp - 32;
           R2 = _sgaEa::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgaEd::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 lvl9_sgaEe_entry() //  [R1]
         { info_tbl: [(cgczo,
                       label: lvl9_sgaEe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgczo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgczp; else goto cgczq;
       cgczp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgczq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaEk_entry() //  [R1, R2]
         { info_tbl: [(cgczx,
                       label: sat_sgaEk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgczx: // global
           _sgaEf::P64 = R2;
           _sgaEk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgczy; else goto cgczz;
       cgczz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgczB; else goto cgczA;
       cgczB: // global
           HpAlloc = 24;
           goto cgczy;
       cgczy: // global
           R2 = _sgaEf::P64;
           R1 = _sgaEk::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgczA: // global
           _sgaEe::P64 = P64[_sgaEk::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sgaEf::P64;
           R2 = _sgaEe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgaEl_entry() //  [R1]
         { info_tbl: [(cgczC,
                       label: sat_sgaEl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgczC: // global
           _sgaEl::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgczD; else goto cgczE;
       cgczE: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgczG; else goto cgczF;
       cgczG: // global
           HpAlloc = 40;
           goto cgczD;
       cgczD: // global
           R1 = _sgaEl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgczF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaEl::P64;
           _sgaE9::P64 = P64[_sgaEl::P64 + 16];
           _sgaEc::P64 = P64[_sgaEl::P64 + 24];
           I64[Hp - 32] = lvl9_sgaEe_info;
           P64[Hp - 16] = _sgaE9::P64;
           I64[Hp - 8] = sat_sgaEk_info;
           P64[Hp] = Hp - 32;
           R2 = _sgaE9::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgaEc::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgaEu_entry() //  [R1]
         { info_tbl: [(cgczH,
                       label: sat_sgaEu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgczH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgczJ; else goto cgczK;
       cgczJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgczK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgcyK_info;
           _sgaE9::P64 = P64[R1 + 24];
           _sgaEa::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sgaE9::P64;
           P64[Sp - 24] = _sgaEa::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugczO; else goto cgcyL;
       ugczO: // global
           call _cgcyK(R1) args: 0, res: 0, upd: 0;
       cgcyL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgcyK() //  [R1]
         { info_tbl: [(cgcyK,
                       label: block_cgcyK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcyK: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgczN; else goto cgczM;
       cgczN: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cgczM: // global
           _sgaEc::P64 = P64[R1 + 7];
           _sgaEd::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sgaEt_info;
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = _sgaEd::P64;
           I64[Hp - 48] = sat_sgaEl_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgaEc::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cmunzip_entry() //  [R2, R3, R4]
         { info_tbl: [(cgczP,
                       label: Data.Functor.Product.$w$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgczP: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgczT; else goto cgczS;
       cgczT: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgczS: // global
           I64[Hp - 120] = $dMonad_sgaE9_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = $dMonad1_sgaEa_info;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_sgaEO_info;
           P64[Hp - 56] = R4;
           _cgcxj::P64 = Hp - 120;
           P64[Hp - 48] = _cgcxj::P64;
           _cgcxq::P64 = Hp - 96;
           P64[Hp - 40] = _cgcxq::P64;
           I64[Hp - 32] = sat_sgaEu_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _cgcxj::P64;
           P64[Hp] = _cgcxq::P64;
           R2 = Hp - 72;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.294126975 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_$cmunzip_closure" {
     Data.Functor.Product.$fMonadZipProduct_$cmunzip_closure:
         const Data.Functor.Product.$fMonadZipProduct_$cmunzip_info;
 },
 Data.Functor.Product.$fMonadZipProduct_$cmunzip_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cgcCk,
                       label: Data.Functor.Product.$fMonadZipProduct_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcCk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcCl; else goto cgcCm;
       cgcCl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcCm: // global
           I64[Sp - 8] = block_cgcCh_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Functor.Product.$w$cmunzip_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgcCh() //  [R1, R2]
         { info_tbl: [(cgcCh,
                       label: block_cgcCh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcCh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcCp; else goto cgcCo;
       cgcCp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgcCo: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.300390551 UTC

[section ""data" . Data.Functor.Product.$fMonadZipProduct_closure" {
     Data.Functor.Product.$fMonadZipProduct_closure:
         const Data.Functor.Product.$fMonadZipProduct_info;
         const 0;
 },
 sat_sgaF0_entry() //  [R1, R2]
         { info_tbl: [(cgcCK,
                       label: sat_sgaF0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcCK: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Product.$fMonadZipProduct_$cmunzip_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaEZ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgcCS,
                       label: sat_sgaEZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcCS: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$fMonadZipProduct_$cmzipWith_entry(R6,
                                                                        R5,
                                                                        R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaEY_entry() //  [R1, R2, R3]
         { info_tbl: [(cgcD0,
                       label: sat_sgaEY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcD0: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Product.$fMonadZipProduct_$cmzip_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaEX_entry() //  [R1]
         { info_tbl: [(cgcD7,
                       label: sat_sgaEX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcD7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcD8; else goto cgcD9;
       cgcD8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcD9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_entry(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fMonadZipProduct_entry() //  [R2, R3]
         { info_tbl: [(cgcDb,
                       label: Data.Functor.Product.$fMonadZipProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcDb: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgcDf; else goto cgcDe;
       cgcDf: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fMonadZipProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcDe: // global
           I64[Hp - 136] = sat_sgaF0_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sgaEZ_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sgaEY_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sgaEX_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 86;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = Hp - 135;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.311799349 UTC

[section ""data" . Data.Functor.Product.$fGeneric1Product_$cto1_closure" {
     Data.Functor.Product.$fGeneric1Product_$cto1_closure:
         const Data.Functor.Product.$fGeneric1Product_$cto1_info;
 },
 Data.Functor.Product.$fGeneric1Product_$cto1_entry() //  [R2]
         { info_tbl: [(cgcDO,
                       label: Data.Functor.Product.$fGeneric1Product_$cto1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcDO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcDS; else goto cgcDT;
       cgcDS: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGeneric1Product_$cto1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcDT: // global
           I64[Sp - 8] = block_cgcDM_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcDM() //  [R1]
         { info_tbl: [(cgcDM,
                       label: block_cgcDM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcDM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcDW; else goto cgcDV;
       cgcDW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcDV: // global
           _sgaF3::P64 = P64[R1 + 7];
           _sgaF4::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = _sgaF3::P64;
           P64[Hp] = _sgaF4::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.317331873 UTC

[section ""data" . Data.Functor.Product.$fGeneric1Product1_closure" {
     Data.Functor.Product.$fGeneric1Product1_closure:
         const Data.Functor.Product.$fGeneric1Product1_info;
 },
 Data.Functor.Product.$fGeneric1Product1_entry() //  [R2]
         { info_tbl: [(cgcEf,
                       label: Data.Functor.Product.$fGeneric1Product1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcEf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcEj; else goto cgcEk;
       cgcEj: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGeneric1Product1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcEk: // global
           I64[Sp - 8] = block_cgcEc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcEo; else goto cgcEd;
       ugcEo: // global
           call _cgcEc(R1) args: 0, res: 0, upd: 0;
       cgcEd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcEc() //  [R1]
         { info_tbl: [(cgcEc,
                       label: block_cgcEc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcEc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcEn; else goto cgcEm;
       cgcEn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcEm: // global
           _sgaF7::P64 = P64[R1 + 7];
           _sgaF8::P64 = P64[R1 + 15];
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = _sgaF7::P64;
           P64[Hp] = _sgaF8::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.323650036 UTC

[section ""data" . Data.Functor.Product.$fGeneric1Product_closure" {
     Data.Functor.Product.$fGeneric1Product_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Product.$fGeneric1Product1_closure+1;
         const Data.Functor.Product.$fGeneric1Product_$cto1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.325582729 UTC

[section ""data" . Data.Functor.Product.$fGenericProduct_$cto_closure" {
     Data.Functor.Product.$fGenericProduct_$cto_closure:
         const Data.Functor.Product.$fGenericProduct_$cto_info;
 },
 Data.Functor.Product.$fGenericProduct_$cto_entry() //  [R2]
         { info_tbl: [(cgcEI,
                       label: Data.Functor.Product.$fGenericProduct_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcEI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcEM; else goto cgcEN;
       cgcEM: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGenericProduct_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcEN: // global
           I64[Sp - 8] = block_cgcEG_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcEG() //  [R1]
         { info_tbl: [(cgcEG,
                       label: block_cgcEG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcEG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcEQ; else goto cgcEP;
       cgcEQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcEP: // global
           _sgaFb::P64 = P64[R1 + 7];
           _sgaFc::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = _sgaFb::P64;
           P64[Hp] = _sgaFc::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.331077841 UTC

[section ""data" . Data.Functor.Product.$fGenericProduct1_closure" {
     Data.Functor.Product.$fGenericProduct1_closure:
         const Data.Functor.Product.$fGenericProduct1_info;
 },
 Data.Functor.Product.$fGenericProduct1_entry() //  [R2]
         { info_tbl: [(cgcF9,
                       label: Data.Functor.Product.$fGenericProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcF9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcFd; else goto cgcFe;
       cgcFd: // global
           R2 = R2;
           R1 = Data.Functor.Product.$fGenericProduct1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcFe: // global
           I64[Sp - 8] = block_cgcF6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcFi; else goto cgcF7;
       ugcFi: // global
           call _cgcF6(R1) args: 0, res: 0, upd: 0;
       cgcF7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcF6() //  [R1]
         { info_tbl: [(cgcF6,
                       label: block_cgcF6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcF6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcFh; else goto cgcFg;
       cgcFh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcFg: // global
           _sgaFf::P64 = P64[R1 + 7];
           _sgaFg::P64 = P64[R1 + 15];
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = _sgaFf::P64;
           P64[Hp] = _sgaFg::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.336582503 UTC

[section ""data" . Data.Functor.Product.$fGenericProduct_closure" {
     Data.Functor.Product.$fGenericProduct_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Product.$fGenericProduct1_closure+1;
         const Data.Functor.Product.$fGenericProduct_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.339188373 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgfoldl_closure" {
     Data.Functor.Product.$fDataProduct_$cgfoldl_closure:
         const Data.Functor.Product.$fDataProduct_$cgfoldl_info;
 },
 Data.Functor.Product.$fDataProduct_$cgfoldl_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcFx: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgfoldl_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_sgaFt_entry() //  [R1]
         { info_tbl: [(cgcFO,
                       label: sat_sgaFt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcFO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcFP; else goto cgcFQ;
       cgcFP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcFQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Product.Pair_closure+2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaFu_entry() //  [R1]
         { info_tbl: [(cgcFR,
                       label: sat_sgaFu_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcFR: // global
           _sgaFu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgcFS; else goto cgcFT;
       cgcFT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcFV; else goto cgcFU;
       cgcFV: // global
           HpAlloc = 24;
           goto cgcFS;
       cgcFS: // global
           R1 = _sgaFu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcFU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaFu::P64;
           _sgaFl::P64 = P64[_sgaFu::P64 + 16];
           _sgaFn::P64 = P64[_sgaFu::P64 + 24];
           _sgaFo::P64 = P64[_sgaFu::P64 + 32];
           _sgaFr::P64 = P64[_sgaFu::P64 + 40];
           I64[Hp - 16] = sat_sgaFt_info;
           P64[Hp] = _sgaFo::P64;
           R4 = _sgaFr::P64;
           R3 = Hp - 16;
           R2 = _sgaFl::P64;
           R1 = _sgaFn::P64;
           Sp = Sp - 16;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgfoldl_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cgcFW,
                       label: Data.Functor.Product.$fDataProduct_$cgfoldl_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcFW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcFX; else goto cgcFY;
       cgcFX: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgfoldl_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cgcFY: // global
           I64[Sp - 8] = block_cgcFB_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcG2; else goto cgcFC;
       ugcG2: // global
           call _cgcFB(R1) args: 0, res: 0, upd: 0;
       cgcFC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcFB() //  [R1]
         { info_tbl: [(cgcFB,
                       label: block_cgcFB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcFB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgcG1; else goto cgcG0;
       cgcG1: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcG0: // global
           _sgaFr::P64 = P64[R1 + 7];
           _sgaFs::P64 = P64[R1 + 15];
           I64[Hp - 40] = sat_sgaFu_info;
           P64[Hp - 24] = P64[Sp + 32];
           _sgaFn::P64 = P64[Sp + 16];
           P64[Hp - 16] = _sgaFn::P64;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sgaFr::P64;
           R4 = _sgaFs::P64;
           R3 = Hp - 40;
           R2 = P64[Sp + 8];
           R1 = _sgaFn::P64;
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.350560819 UTC

[section ""cstring" . Data.Functor.Product.$fDataProduct6_bytes" {
     Data.Functor.Product.$fDataProduct6_bytes:
         I8[] [80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.352570123 UTC

[section ""data" . Data.Functor.Product.$fDataProduct5_closure" {
     Data.Functor.Product.$fDataProduct5_closure:
         const Data.Functor.Product.$fDataProduct5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Product.$fDataProduct5_entry() //  [R1]
         { info_tbl: [(cgcGA,
                       label: Data.Functor.Product.$fDataProduct5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcGA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcGB; else goto cgcGC;
       cgcGB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcGC: // global
           (_cgcGx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgcGx::I64 == 0) goto cgcGz; else goto cgcGy;
       cgcGz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgcGy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgcGx::I64;
           R2 = Data.Functor.Product.$fDataProduct6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.357636364 UTC

[section ""data" . go61_rg5o2_closure" {
     go61_rg5o2_closure:
         const go61_rg5o2_info;
         const 0;
 },
 go61_rg5o2_entry() //  [R2, R3]
         { info_tbl: [(cgcGW,
                       label: go61_rg5o2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcGW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgcGX; else goto ugcHA;
       cgcGX: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rg5o2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ugcHA: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cgcGM() args: 0, res: 0, upd: 0;
     }
 },
 _cgcGM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcGM: // global
           _sgaFv::P64 = P64[Sp];
           I64[Sp] = block_cgcGP_info;
           R1 = _sgaFv::P64;
           if (R1 & 7 != 0) goto ugcHE; else goto cgcGQ;
       ugcHE: // global
           call _cgcGP(R1) args: 0, res: 0, upd: 0;
       cgcGQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcGP() //  [R1]
         { info_tbl: [(cgcGP,
                       label: block_cgcGP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcGP: // global
           if (R1 & 7 == 1) goto ugcHB; else goto cgcGU;
       ugcHB: // global
           Sp = Sp + 16;
           call _cgcHc() args: 0, res: 0, upd: 0;
       cgcGU: // global
           I64[Sp - 8] = block_cgcH4_info;
           _sgaFy::P64 = P64[R1 + 6];
           _sgaFz::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sgaFz::P64;
           P64[Sp + 8] = _sgaFy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcHF; else goto cgcH6;
       ugcHF: // global
           call _cgcH4(R1) args: 0, res: 0, upd: 0;
       cgcH6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcH4() //  [R1]
         { info_tbl: [(cgcH4,
                       label: block_cgcH4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcH4: // global
           if (R1 & 7 == 1) goto ugcHC; else goto cgcHh;
       ugcHC: // global
           Sp = Sp + 24;
           call _cgcHc() args: 0, res: 0, upd: 0;
       cgcHh: // global
           I64[Sp - 8] = block_cgcHf_info;
           _sgaFB::P64 = P64[R1 + 6];
           _sgaFC::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgaFC::P64;
           P64[Sp + 16] = _sgaFB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcHI; else goto cgcHi;
       ugcHI: // global
           call _cgcHf(R1) args: 0, res: 0, upd: 0;
       cgcHi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcHc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcHc: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgcHf() //  [R1]
         { info_tbl: [(cgcHf,
                       label: block_cgcHf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcHf: // global
           I64[Sp] = block_cgcHm_info;
           R3 = Data.Functor.Product.$fRead1Product2_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgcHm() //  [R1]
         { info_tbl: [(cgcHm,
                       label: block_cgcHm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcHm: // global
           if (R1 & 7 == 1) goto cgcHt; else goto cgcHx;
       cgcHt: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cgcGM() args: 0, res: 0, upd: 0;
       cgcHx: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.371079443 UTC

[section ""data" . $cPair1_rg5o3_closure" {
     $cPair1_rg5o3_closure:
         const Data.Data.AlgConstr_con_info;
         const $cPair2_rg5o4_closure;
         const 0;
 },
 section ""data" . Data.Functor.Product.$fDataProduct4_closure" {
     Data.Functor.Product.$fDataProduct4_closure:
         const :_con_info;
         const Data.Functor.Product.$cPair_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Product.$fDataProduct3_closure" {
     Data.Functor.Product.$fDataProduct3_closure:
         const Data.Data.AlgRep_con_info;
         const Data.Functor.Product.$fDataProduct4_closure+2;
         const 0;
 },
 section ""data" . Data.Functor.Product.$tProduct_closure" {
     Data.Functor.Product.$tProduct_closure:
         const Data.Data.DataType_con_info;
         const Data.Functor.Product.$fDataProduct5_closure;
         const Data.Functor.Product.$fDataProduct3_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Product.$cPair_closure" {
     Data.Functor.Product.$cPair_closure:
         const Data.Data.Constr_con_info;
         const $cPair1_rg5o3_closure+1;
         const Data.Functor.Product.$fRead1Product2_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Product.$tProduct_closure+1;
         const 0;
 },
 section ""data" . $cPair2_rg5o4_closure" {
     $cPair2_rg5o4_closure:
         const $cPair2_rg5o4_info;
         const 0;
         const 0;
         const 0;
 },
 $cPair2_rg5o4_entry() //  [R1]
         { info_tbl: [(cgcIt,
                       label: $cPair2_rg5o4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcIt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcIu; else goto cgcIv;
       cgcIu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcIv: // global
           (_cgcIq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgcIq::I64 == 0) goto cgcIs; else goto cgcIr;
       cgcIs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgcIr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgcIq::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = Data.Functor.Product.$fDataProduct4_closure+2;
           Sp = Sp - 16;
           call go61_rg5o2_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.378727407 UTC

[section ""cstring" . Data.Functor.Product.$trModule4_bytes" {
     Data.Functor.Product.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.380468503 UTC

[section ""data" . Data.Functor.Product.$trModule3_closure" {
     Data.Functor.Product.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.382243991 UTC

[section ""cstring" . Data.Functor.Product.$trModule2_bytes" {
     Data.Functor.Product.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.383934563 UTC

[section ""data" . Data.Functor.Product.$trModule1_closure" {
     Data.Functor.Product.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.385859049 UTC

[section ""data" . Data.Functor.Product.$trModule_closure" {
     Data.Functor.Product.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Product.$trModule3_closure+1;
         const Data.Functor.Product.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.387532425 UTC

[section ""data" . $krep_rg5o5_closure" {
     $krep_rg5o5_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.389676328 UTC

[section ""data" . $krep1_rg5o6_closure" {
     $krep1_rg5o6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rg5o5_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.391529264 UTC

[section ""data" . $krep2_rg5o7_closure" {
     $krep2_rg5o7_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rg5o6_closure+4;
         const $krep1_rg5o6_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.393232688 UTC

[section ""data" . Data.Functor.Product.$fDataProduct8_closure" {
     Data.Functor.Product.$fDataProduct8_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rg5o6_closure+4;
         const $krep2_rg5o7_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.394931007 UTC

[section ""data" . $krep3_rg5o8_closure" {
     $krep3_rg5o8_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.396603547 UTC

[section ""data" . $krep4_rg5o9_closure" {
     $krep4_rg5o9_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.398578419 UTC

[section ""data" . $krep5_rg5oa_closure" {
     $krep5_rg5oa_closure:
         const GHC.Types.KindRepVar_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.400115572 UTC

[section ""data" . $krep6_rg5ob_closure" {
     $krep6_rg5ob_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rg5o9_closure+2;
         const $krep5_rg5oa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.401719799 UTC

[section ""data" . $krep7_rg5oc_closure" {
     $krep7_rg5oc_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep3_rg5o8_closure+2;
         const $krep5_rg5oa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.403379047 UTC

[section ""data" . Data.Functor.Product.$fDataProduct9_closure" {
     Data.Functor.Product.$fDataProduct9_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$fDataProduct6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.405085831 UTC

[section ""data" . Data.Functor.Product.$tcProduct_closure" {
     Data.Functor.Product.$tcProduct_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Product.$trModule_closure+1;
         const Data.Functor.Product.$fDataProduct9_closure+1;
         const Data.Functor.Product.$fDataProduct8_closure+4;
         const 9904636435990105341;
         const 16069493191308336164;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.406908435 UTC

[section ""data" . $krep8_rg5od_closure" {
     $krep8_rg5od_closure:
         const :_con_info;
         const $krep5_rg5oa_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.408596741 UTC

[section ""data" . $krep9_rg5oe_closure" {
     $krep9_rg5oe_closure:
         const :_con_info;
         const $krep3_rg5o8_closure+2;
         const $krep8_rg5od_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.410335209 UTC

[section ""data" . $krep10_rg5of_closure" {
     $krep10_rg5of_closure:
         const :_con_info;
         const $krep4_rg5o9_closure+2;
         const $krep9_rg5oe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.41199563 UTC

[section ""data" . $krep11_rg5og_closure" {
     $krep11_rg5og_closure:
         const :_con_info;
         const $krep_rg5o5_closure+2;
         const $krep10_rg5of_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.4136297 UTC

[section ""data" . $krep12_rg5oh_closure" {
     $krep12_rg5oh_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Product.$tcProduct_closure+1;
         const $krep11_rg5og_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.415903545 UTC

[section ""data" . $krep13_rg5oi_closure" {
     $krep13_rg5oi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rg5oc_closure+3;
         const $krep12_rg5oh_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.417611385 UTC

[section ""data" . Data.Functor.Product.$tc'Pair1_closure" {
     Data.Functor.Product.$tc'Pair1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rg5ob_closure+3;
         const $krep13_rg5oi_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.419283067 UTC

[section ""cstring" . Data.Functor.Product.$tc'Pair3_bytes" {
     Data.Functor.Product.$tc'Pair3_bytes:
         I8[] [39,80,97,105,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.420959919 UTC

[section ""data" . Data.Functor.Product.$tc'Pair2_closure" {
     Data.Functor.Product.$tc'Pair2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Product.$tc'Pair3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.422925135 UTC

[section ""data" . Data.Functor.Product.$tc'Pair_closure" {
     Data.Functor.Product.$tc'Pair_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Product.$trModule_closure+1;
         const Data.Functor.Product.$tc'Pair2_closure+1;
         const Data.Functor.Product.$tc'Pair1_closure+4;
         const 11374113252541295849;
         const 18011678063065699923;
         const 4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.425436834 UTC

[section ""data" . Data.Functor.Product.$w$cp1Data_closure" {
     Data.Functor.Product.$w$cp1Data_closure:
         const Data.Functor.Product.$w$cp1Data_info;
         const 0;
 },
 Data.Functor.Product.$w$cp1Data_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgcJm,
                       label: Data.Functor.Product.$w$cp1Data_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcJm: // global
           _sgaFN::P64 = R5;
           _sgaFM::P64 = R4;
           _sgaFL::P64 = R3;
           _sgaFK::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cgcJq; else goto cgcJr;
       cgcJr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgcJt; else goto cgcJs;
       cgcJt: // global
           HpAlloc = 40;
           goto cgcJq;
       cgcJq: // global
           R5 = _sgaFN::P64;
           R4 = _sgaFM::P64;
           R3 = _sgaFL::P64;
           R2 = _sgaFK::P64;
           R1 = Data.Functor.Product.$w$cp1Data_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcJs: // global
           I64[Hp - 32] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 24] = _sgaFN::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp - 32] = block_cgcJf_info;
           R6 = 1;
           R5 = Data.Functor.Product.$fDataProduct9_closure+1;
           R4 = Data.Functor.Product.$trModule_closure+1;
           R3 = 16069493191308336164;
           R2 = 9904636435990105341;
           P64[Sp - 48] = Data.Functor.Product.$fDataProduct8_closure+4;
           P64[Sp - 40] = Hp - 14;
           P64[Sp - 24] = _sgaFK::P64;
           P64[Sp - 16] = _sgaFL::P64;
           P64[Sp - 8] = _sgaFM::P64;
           Sp = Sp - 48;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 8;
     }
 },
 _cgcJf() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgcJf,
                       label: block_cgcJf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcJf: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cgcJg() args: 0, res: 0, upd: 0;
     }
 },
 _cgcJg() //  []
         { info_tbl: [(cgcJg,
                       label: block_cgcJg_info
                       rep:StackRep [True, False, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcJg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgcJw; else goto cgcJv;
       cgcJw: // global
           HpAlloc = 48;
           I64[Sp] = block_cgcJg_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cgcJv: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 40] = block_cgcJk_info;
           R3 = P64[Sp + 56];
           R2 = Hp - 38;
           Sp = Sp + 40;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgcJk() //  [R1]
         { info_tbl: [(cgcJk,
                       label: block_cgcJk_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcJk: // global
           I64[Sp] = block_cgcJp_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgcJp() //  [R1]
         { info_tbl: [(cgcJp,
                       label: block_cgcJp_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcJp: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.436743521 UTC

[section ""data" . Data.Functor.Product.$fDataProduct7_closure" {
     Data.Functor.Product.$fDataProduct7_closure:
         const Data.Functor.Product.$fDataProduct7_info;
         const 0;
 },
 Data.Functor.Product.$fDataProduct7_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgcKg,
                       label: Data.Functor.Product.$fDataProduct7_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcKg: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Product.$w$cp1Data_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.440914235 UTC

[section ""data" . Data.Functor.Product.$fDataProduct1_closure" {
     Data.Functor.Product.$fDataProduct1_closure:
         const (,)_con_info;
         const Data.Functor.Product.Pair_closure+2;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.445411088 UTC

[section ""data" . Data.Functor.Product.$w$cgmapMp_closure" {
     Data.Functor.Product.$w$cgmapMp_closure:
         const Data.Functor.Product.$w$cgmapMp_info;
 },
 lvl9_sgaGa_entry() //  [R1]
         { info_tbl: [(cgcKw,
                       label: lvl9_sgaGa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcKw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcKx; else goto cgcKy;
       cgcKx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcKy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaGF_entry() //  [R1, R2]
         { info_tbl: [(cgcKL,
                       label: sat_sgaGF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcKL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgcKM; else goto cgcKN;
       cgcKM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcKN: // global
           I64[Sp - 24] = block_cgcKI_info;
           _sgaGa::P64 = P64[R1 + 7];
           _sgaGb::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sgaGa::P64;
           P64[Sp - 8] = _sgaGb::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugcL5; else goto cgcKJ;
       ugcL5: // global
           call _cgcKI(R1) args: 0, res: 0, upd: 0;
       cgcKJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcKI() //  [R1]
         { info_tbl: [(cgcKI,
                       label: block_cgcKI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcKI: // global
           I64[Sp - 8] = block_cgcKQ_info;
           _sgaGC::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgaGC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcL4; else goto cgcKS;
       ugcL4: // global
           call _cgcKQ(R1) args: 0, res: 0, upd: 0;
       cgcKS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcKQ() //  [R1]
         { info_tbl: [(cgcKQ,
                       label: block_cgcKQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcKQ: // global
           if (R1 & 7 == 1) goto cgcKY; else goto cgcL2;
       cgcKY: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgcL2: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgaGv_entry() //  [R1]
         { info_tbl: [(cgcLB,
                       label: sat_sgaGv_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcLB: // global
           _sgaGv::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgcLC; else goto cgcLD;
       cgcLD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgcLF; else goto cgcLE;
       cgcLF: // global
           HpAlloc = 56;
           goto cgcLC;
       cgcLC: // global
           R1 = _sgaGv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcLE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaGv::P64;
           _sgaGb::P64 = P64[_sgaGv::P64 + 16];
           _sgaGi::P64 = P64[_sgaGv::P64 + 24];
           _sgaGm::P64 = P64[_sgaGv::P64 + 32];
           _sgaGn::P64 = P64[_sgaGv::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgaGm::P64;
           P64[Hp - 24] = _sgaGi::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sgaGn::P64;
           R2 = _sgaGb::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgaGr_entry() //  [R1, R2]
         { info_tbl: [(cgcLR,
                       label: sat_sgaGr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcLR: // global
           _sgaGo::P64 = R2;
           _sgaGr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgcLS; else goto cgcLT;
       cgcLT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgcLV; else goto cgcLU;
       cgcLV: // global
           HpAlloc = 56;
           goto cgcLS;
       cgcLS: // global
           R2 = _sgaGo::P64;
           R1 = _sgaGr::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcLU: // global
           _sgaGb::P64 = P64[_sgaGr::P64 + 7];
           _sgaGm::P64 = P64[_sgaGr::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgaGm::P64;
           P64[Hp - 24] = _sgaGo::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgaGb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgaGs_entry() //  [R1]
         { info_tbl: [(cgcLW,
                       label: sat_sgaGs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcLW: // global
           _sgaGs::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgcLX; else goto cgcLY;
       cgcLY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcM0; else goto cgcLZ;
       cgcM0: // global
           HpAlloc = 24;
           goto cgcLX;
       cgcLX: // global
           R1 = _sgaGs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcLZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaGs::P64;
           _sgaGb::P64 = P64[_sgaGs::P64 + 16];
           _sgaGj::P64 = P64[_sgaGs::P64 + 24];
           _sgaGm::P64 = P64[_sgaGs::P64 + 32];
           I64[Hp - 16] = sat_sgaGr_info;
           P64[Hp - 8] = _sgaGb::P64;
           P64[Hp] = _sgaGm::P64;
           R2 = _sgaGb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgaGj::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgaGw_entry() //  [R1, R2]
         { info_tbl: [(cgcM1,
                       label: sat_sgaGw_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcM1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgcM2; else goto cgcM3;
       cgcM2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcM3: // global
           I64[Sp - 40] = block_cgcLq_info;
           _sgaG7::P64 = P64[R1 + 7];
           _sgaGb::P64 = P64[R1 + 15];
           _sgaGi::P64 = P64[R1 + 23];
           _sgaGj::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgaG7::P64;
           P64[Sp - 24] = _sgaGb::P64;
           P64[Sp - 16] = _sgaGi::P64;
           P64[Sp - 8] = _sgaGj::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugcM7; else goto cgcLr;
       ugcM7: // global
           call _cgcLq(R1) args: 0, res: 0, upd: 0;
       cgcLr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcLq() //  [R1]
         { info_tbl: [(cgcLq,
                       label: block_cgcLq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcLq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgcM6; else goto cgcM5;
       cgcM6: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcM5: // global
           _sgaGm::P64 = P64[R1 + 7];
           _sgaGn::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sgaGv_info;
           _sgaGb::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sgaGb::P64;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _sgaGm::P64;
           P64[Hp - 40] = _sgaGn::P64;
           I64[Hp - 32] = sat_sgaGs_info;
           P64[Hp - 16] = _sgaGb::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sgaGm::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sgaGf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgcM8,
                       label: k1_sgaGf_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcM8: // global
           _sgaGi::P64 = R4;
           _sgaGh::P64 = R3;
           _sgaGg::P64 = R2;
           _sgaGf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgcM9; else goto cgcMa;
       cgcMa: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgcMc; else goto cgcMb;
       cgcMc: // global
           HpAlloc = 80;
           goto cgcM9;
       cgcM9: // global
           R4 = _sgaGi::P64;
           R3 = _sgaGh::P64;
           R2 = _sgaGg::P64;
           R1 = _sgaGf::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcMb: // global
           _sgaG7::P64 = P64[_sgaGf::P64 + 5];
           _sgaG8::P64 = P64[_sgaGf::P64 + 13];
           _sgaGb::P64 = P64[_sgaGf::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sgaG8::P64;
           P64[Hp - 48] = _sgaGg::P64;
           P64[Hp - 40] = _sgaGi::P64;
           I64[Hp - 32] = sat_sgaGw_info;
           P64[Hp - 24] = _sgaG7::P64;
           P64[Hp - 16] = _sgaGb::P64;
           P64[Hp - 8] = _sgaGi::P64;
           P64[Hp] = Hp - 72;
           R2 = _sgaGb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgaGh::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgaGx_entry() //  [R1]
         { info_tbl: [(cgcMl,
                       label: sat_sgaGx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcMl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgcMm; else goto cgcMn;
       cgcMm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcMn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Product.$fDataProduct1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgaGy_entry() //  [R1]
         { info_tbl: [(cgcMo,
                       label: sat_sgaGy_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcMo: // global
           _sgaGy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgcMp; else goto cgcMq;
       cgcMq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcMs; else goto cgcMr;
       cgcMs: // global
           HpAlloc = 24;
           goto cgcMp;
       cgcMp: // global
           R1 = _sgaGy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcMr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaGy::P64;
           _sgaG5::P64 = P64[_sgaGy::P64 + 16];
           _sgaGb::P64 = P64[_sgaGy::P64 + 24];
           _sgaGd::P64 = P64[_sgaGy::P64 + 32];
           _sgaGf::P64 = P64[_sgaGy::P64 + 40];
           I64[Hp - 16] = sat_sgaGx_info;
           P64[Hp] = _sgaGb::P64;
           R4 = _sgaGd::P64;
           R3 = Hp - 16;
           R2 = _sgaG5::P64;
           R1 = _sgaGf::P64;
           Sp = Sp - 16;
           call k1_sgaGf_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaGz_entry() //  [R1]
         { info_tbl: [(cgcMt,
                       label: sat_sgaGz_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcMt: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cgcMu; else goto cgcMv;
       cgcMu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcMv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cgcLa_info;
           _sgaG5::P64 = P64[R1 + 16];
           _sgaG6::P64 = P64[R1 + 24];
           _sgaG7::P64 = P64[R1 + 32];
           _sgaG8::P64 = P64[R1 + 40];
           _sgaGb::P64 = P64[R1 + 56];
           R1 = P64[R1 + 48];
           P64[Sp - 56] = _sgaG5::P64;
           P64[Sp - 48] = _sgaG6::P64;
           P64[Sp - 40] = _sgaG7::P64;
           P64[Sp - 32] = _sgaG8::P64;
           P64[Sp - 24] = _sgaGb::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ugcMz; else goto cgcLb;
       ugcMz: // global
           call _cgcLa(R1) args: 0, res: 0, upd: 0;
       cgcLb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgcLa() //  [R1]
         { info_tbl: [(cgcLa,
                       label: block_cgcLa_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcLa: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgcMy; else goto cgcMx;
       cgcMy: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cgcMx: // global
           _sgaGd::P64 = P64[R1 + 7];
           _sgaGe::P64 = P64[R1 + 15];
           I64[Hp - 72] = k1_sgaGf_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = P64[Sp + 32];
           _sgaGb::P64 = P64[Sp + 40];
           P64[Hp - 48] = _sgaGb::P64;
           I64[Hp - 40] = sat_sgaGy_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sgaGb::P64;
           P64[Hp - 8] = _sgaGd::P64;
           _cgcLf::P64 = Hp - 69;
           P64[Hp] = _cgcLf::P64;
           R4 = _sgaGe::P64;
           R3 = Hp - 40;
           R2 = P64[Sp + 16];
           R1 = _cgcLf::P64;
           Sp = Sp + 48;
           call k1_sgaGf_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cgmapMp_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgcMA,
                       label: Data.Functor.Product.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcMA: // global
           _sgaG9::P64 = R6;
           _sgaG8::P64 = R5;
           _sgaG7::P64 = R4;
           _sgaG6::P64 = R3;
           _sgaG5::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgcMB; else goto cgcMC;
       cgcMC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcME; else goto cgcMD;
       cgcME: // global
           HpAlloc = 24;
           goto cgcMB;
       cgcMB: // global
           R6 = _sgaG9::P64;
           R5 = _sgaG8::P64;
           R4 = _sgaG7::P64;
           R3 = _sgaG6::P64;
           R2 = _sgaG5::P64;
           R1 = Data.Functor.Product.$w$cgmapMp_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcMD: // global
           I64[Hp - 16] = lvl9_sgaGa_info;
           P64[Hp] = _sgaG7::P64;
           I64[Sp - 56] = block_cgcKz_info;
           R2 = _sgaG7::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sgaG5::P64;
           P64[Sp - 32] = _sgaG6::P64;
           P64[Sp - 24] = _sgaG7::P64;
           P64[Sp - 16] = _sgaG8::P64;
           P64[Sp - 8] = _sgaG9::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgcKz() //  [R1]
         { info_tbl: [(cgcKz,
                       label: block_cgcKz_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcKz: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgcMH; else goto cgcMG;
       cgcMH: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcMG: // global
           I64[Hp - 80] = sat_sgaGF_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sgaGz_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.483553119 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapMp_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapMp_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapMp_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapMp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcOM: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapMp_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapMp_entry() //  [R6]
         { info_tbl: [(cgcOQ,
                       label: Data.Functor.Product.$fDataProduct_$cgmapMp_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcOQ: // global
           _sgaGK::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sgaGK::P64;
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cgmapMp_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.48910431 UTC

[section ""data" . Data.Functor.Product.$w$cgmapM_closure" {
     Data.Functor.Product.$w$cgmapM_closure:
         const Data.Functor.Product.$w$cgmapM_info;
 },
 sat_sgaH3_entry() //  [R1, R2]
         { info_tbl: [(cgcPk,
                       label: sat_sgaH3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcPk: // global
           _sgaH1::P64 = R2;
           _sgaH3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgcPl; else goto cgcPm;
       cgcPm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgcPo; else goto cgcPn;
       cgcPo: // global
           HpAlloc = 32;
           goto cgcPl;
       cgcPl: // global
           R2 = _sgaH1::P64;
           R1 = _sgaH3::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcPn: // global
           _sgaGR::P64 = P64[_sgaH3::P64 + 7];
           _sgaH0::P64 = P64[_sgaH3::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgaH0::P64;
           P64[Hp] = _sgaH1::P64;
           R2 = _sgaGR::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgaH4_entry() //  [R1, R2]
         { info_tbl: [(cgcPp,
                       label: sat_sgaH4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcPp: // global
           _sgaH0::P64 = R2;
           _sgaH4::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgcPq; else goto cgcPr;
       cgcPr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcPt; else goto cgcPs;
       cgcPt: // global
           HpAlloc = 24;
           goto cgcPq;
       cgcPq: // global
           R2 = _sgaH0::P64;
           R1 = _sgaH4::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcPs: // global
           _sgaGR::P64 = P64[_sgaH4::P64 + 7];
           _sgaGZ::P64 = P64[_sgaH4::P64 + 15];
           I64[Hp - 16] = sat_sgaH3_info;
           P64[Hp - 8] = _sgaGR::P64;
           P64[Hp] = _sgaH0::P64;
           R2 = _sgaGR::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgaGZ::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 k1_sgaGV_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgcPu,
                       label: k1_sgaGV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcPu: // global
           _sgaGY::P64 = R4;
           _sgaGX::P64 = R3;
           _sgaGW::P64 = R2;
           _sgaGV::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgcPv; else goto cgcPw;
       cgcPw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgcPy; else goto cgcPx;
       cgcPy: // global
           HpAlloc = 64;
           goto cgcPv;
       cgcPv: // global
           R4 = _sgaGY::P64;
           R3 = _sgaGX::P64;
           R2 = _sgaGW::P64;
           R1 = _sgaGV::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcPx: // global
           _sgaGR::P64 = P64[_sgaGV::P64 + 5];
           _sgaGS::P64 = P64[_sgaGV::P64 + 13];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sgaGS::P64;
           P64[Hp - 32] = _sgaGW::P64;
           P64[Hp - 24] = _sgaGY::P64;
           I64[Hp - 16] = sat_sgaH4_info;
           P64[Hp - 8] = _sgaGR::P64;
           P64[Hp] = Hp - 56;
           R2 = _sgaGR::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgaGX::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgaH5_entry() //  [R1]
         { info_tbl: [(cgcPH,
                       label: sat_sgaH5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcPH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgcPI; else goto cgcPJ;
       cgcPI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcPJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Product.Pair_closure+2;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgaH6_entry() //  [R1]
         { info_tbl: [(cgcPK,
                       label: sat_sgaH6_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcPK: // global
           _sgaH6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgcPL; else goto cgcPM;
       cgcPM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcPO; else goto cgcPN;
       cgcPO: // global
           HpAlloc = 24;
           goto cgcPL;
       cgcPL: // global
           R1 = _sgaH6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcPN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaH6::P64;
           _sgaGP::P64 = P64[_sgaH6::P64 + 16];
           _sgaGR::P64 = P64[_sgaH6::P64 + 24];
           _sgaGT::P64 = P64[_sgaH6::P64 + 32];
           _sgaGV::P64 = P64[_sgaH6::P64 + 40];
           I64[Hp - 16] = sat_sgaH5_info;
           P64[Hp] = _sgaGR::P64;
           R4 = _sgaGT::P64;
           R3 = Hp - 16;
           R2 = _sgaGP::P64;
           R1 = _sgaGV::P64;
           Sp = Sp - 16;
           call k1_sgaGV_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cgmapM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgcPP,
                       label: Data.Functor.Product.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcPP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgcPT; else goto cgcPS;
       cgcPT: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$w$cgmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgcPS: // global
           I64[Hp - 64] = k1_sgaGV_info;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           I64[Hp - 40] = sat_sgaH6_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R6;
           _cgcP3::P64 = Hp - 61;
           P64[Hp] = _cgcP3::P64;
           R4 = P64[Sp];
           _sgaGQ::P64 = R3;
           R3 = Hp - 40;
           R2 = _sgaGQ::P64;
           R1 = _cgcP3::P64;
           Sp = Sp + 8;
           call k1_sgaGV_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.505682409 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapM_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapM_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapM_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapM_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcQB: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapM_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2,
                                                                 R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapM_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cgcQI,
                       label: Data.Functor.Product.$fDataProduct_$cgmapM_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcQI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcQJ; else goto cgcQK;
       cgcQJ: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgmapM_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cgcQK: // global
           I64[Sp - 8] = block_cgcQF_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcQO; else goto cgcQG;
       ugcQO: // global
           call _cgcQF(R1) args: 0, res: 0, upd: 0;
       cgcQG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcQF() //  [R1]
         { info_tbl: [(cgcQF,
                       label: block_cgcQF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcQF: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cgmapM_entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.513258521 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapQi_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapQi_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapQi_info;
         const 0;
 },
 Data.Functor.Product.$fDataProduct_$cgmapQi_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcR3: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapQi_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapQi_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cgcRa,
                       label: Data.Functor.Product.$fDataProduct_$cgmapQi_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcRa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcRe; else goto cgcRf;
       cgcRe: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgmapQi_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cgcRf: // global
           I64[Sp - 8] = block_cgcR7_info;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcRt; else goto cgcR8;
       ugcRt: // global
           call _cgcR7(R1) args: 0, res: 0, upd: 0;
       cgcR8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcR7() //  [R1]
         { info_tbl: [(cgcR7,
                       label: block_cgcR7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcR7: // global
           I64[Sp - 8] = block_cgcRd_info;
           _sgaHt::P64 = P64[R1 + 7];
           _sgaHu::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgaHu::P64;
           P64[Sp + 16] = _sgaHt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcRs; else goto cgcRh;
       ugcRs: // global
           call _cgcRd(R1) args: 0, res: 0, upd: 0;
       cgcRh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcRd() //  [R1]
         { info_tbl: [(cgcRd,
                       label: block_cgcRd_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcRd: // global
           _sgaHq::P64 = P64[Sp + 32];
           _sgaHx::I64 = I64[R1 + 7];
           if (_sgaHx::I64 != 0) goto ugcRr; else goto cgcRp;
       ugcRr: // global
           if (_sgaHx::I64 != 1) goto cgcRo; else goto cgcRq;
       cgcRo: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 48;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgcRq: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           R1 = _sgaHq::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcRp: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 40];
           R1 = _sgaHq::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.523292365 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapQr_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapQr_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapQr_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapQr_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcRM: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapQr_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 48, res: 0, upd: 8;
     }
 },
 sat_sgaHN_entry() //  [R1]
         { info_tbl: [(cgcS0,
                       label: sat_sgaHN_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcS0: // global
           _sgaHN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgcS1; else goto cgcS2;
       cgcS2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgcS4; else goto cgcS3;
       cgcS4: // global
           HpAlloc = 40;
           goto cgcS1;
       cgcS1: // global
           R1 = _sgaHN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcS3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaHN::P64;
           _sgaHD::P64 = P64[_sgaHN::P64 + 16];
           _sgaHE::P64 = P64[_sgaHN::P64 + 24];
           _sgaHF::P64 = P64[_sgaHN::P64 + 32];
           _sgaHG::P64 = P64[_sgaHN::P64 + 40];
           _sgaHK::P64 = P64[_sgaHN::P64 + 48];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sgaHG::P64;
           P64[Hp - 8] = _sgaHD::P64;
           P64[Hp] = _sgaHK::P64;
           R3 = _sgaHF::P64;
           R2 = Hp - 32;
           R1 = _sgaHE::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapQr_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cgcS5,
                       label: Data.Functor.Product.$fDataProduct_$cgmapQr_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcS5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcS7; else goto cgcS8;
       cgcS7: // global
           R1 = Data.Functor.Product.$fDataProduct_$cgmapQr_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cgcS8: // global
           I64[Sp - 8] = block_cgcRQ_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcSc; else goto cgcRR;
       ugcSc: // global
           call _cgcRQ(R1) args: 0, res: 0, upd: 0;
       cgcRR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcRQ() //  [R1]
         { info_tbl: [(cgcRQ,
                       label: block_cgcRQ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcRQ: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgcSb; else goto cgcSa;
       cgcSb: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcSa: // global
           _sgaHJ::P64 = P64[R1 + 7];
           _sgaHK::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_sgaHN_info;
           P64[Hp - 72] = P64[Sp + 8];
           _sgaHE::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sgaHE::P64;
           P64[Hp - 56] = P64[Sp + 24];
           _sgaHG::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sgaHG::P64;
           P64[Hp - 40] = _sgaHK::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sgaHG::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sgaHJ::P64;
           R3 = Hp - 88;
           R2 = Hp - 32;
           R1 = _sgaHE::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.533830609 UTC

[section ""data" . Data.Functor.Product.$fDataProduct2_closure" {
     Data.Functor.Product.$fDataProduct2_closure:
         const Data.Functor.Product.$fDataProduct2_info;
 },
 Data.Functor.Product.$fDataProduct2_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcSB: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct2_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 48, res: 0, upd: 8;
     }
 },
 sat_sgaI2_entry() //  [R1]
         { info_tbl: [(cgcSQ,
                       label: sat_sgaI2_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcSQ: // global
           _sgaI2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgcSR; else goto cgcSS;
       cgcSS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgcSU; else goto cgcST;
       cgcSU: // global
           HpAlloc = 40;
           goto cgcSR;
       cgcSR: // global
           R1 = _sgaI2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcST: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaI2::P64;
           _sgaHS::P64 = P64[_sgaI2::P64 + 16];
           _sgaHU::P64 = P64[_sgaI2::P64 + 24];
           _sgaHV::P64 = P64[_sgaI2::P64 + 32];
           _sgaHW::P64 = P64[_sgaI2::P64 + 40];
           _sgaHZ::P64 = P64[_sgaI2::P64 + 48];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sgaHW::P64;
           P64[Hp - 8] = _sgaHS::P64;
           P64[Hp] = _sgaHZ::P64;
           R3 = Hp - 32;
           R2 = _sgaHV::P64;
           R1 = _sgaHU::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct2_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cgcSV,
                       label: Data.Functor.Product.$fDataProduct2_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcSV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcSW; else goto cgcSX;
       cgcSW: // global
           R1 = Data.Functor.Product.$fDataProduct2_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cgcSX: // global
           I64[Sp - 8] = block_cgcSF_info;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = R6;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcT1; else goto cgcSG;
       ugcT1: // global
           call _cgcSF(R1) args: 0, res: 0, upd: 0;
       cgcSG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcSF() //  [R1]
         { info_tbl: [(cgcSF,
                       label: block_cgcSF_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcSF: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgcT0; else goto cgcSZ;
       cgcT0: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcSZ: // global
           _sgaHZ::P64 = P64[R1 + 7];
           _sgaI0::P64 = P64[R1 + 15];
           I64[Hp - 88] = stg_ap_3_upd_info;
           _sgaHW::P64 = P64[Sp + 32];
           P64[Hp - 72] = _sgaHW::P64;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sgaI0::P64;
           I64[Hp - 48] = sat_sgaI2_info;
           P64[Hp - 32] = P64[Sp + 40];
           _sgaHU::P64 = P64[Sp + 16];
           P64[Hp - 24] = _sgaHU::P64;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sgaHW::P64;
           P64[Hp] = _sgaHZ::P64;
           R3 = Hp - 88;
           R2 = Hp - 48;
           R1 = _sgaHU::P64;
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.546860846 UTC

[section ""data" . Data.Functor.Product.$w$cgmapMo_closure" {
     Data.Functor.Product.$w$cgmapMo_closure:
         const Data.Functor.Product.$w$cgmapMo_info;
 },
 lvl9_sgaI9_entry() //  [R1]
         { info_tbl: [(cgcTx,
                       label: lvl9_sgaI9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcTx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgcTy; else goto cgcTz;
       cgcTy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcTz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaIH_entry() //  [R1, R2]
         { info_tbl: [(cgcTM,
                       label: sat_sgaIH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcTM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgcTN; else goto cgcTO;
       cgcTN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcTO: // global
           I64[Sp - 24] = block_cgcTJ_info;
           _sgaI9::P64 = P64[R1 + 7];
           _sgaIa::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sgaI9::P64;
           P64[Sp - 8] = _sgaIa::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugcU6; else goto cgcTK;
       ugcU6: // global
           call _cgcTJ(R1) args: 0, res: 0, upd: 0;
       cgcTK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcTJ() //  [R1]
         { info_tbl: [(cgcTJ,
                       label: block_cgcTJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcTJ: // global
           I64[Sp - 8] = block_cgcTR_info;
           _sgaIE::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgaIE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcU5; else goto cgcTT;
       ugcU5: // global
           call _cgcTR(R1) args: 0, res: 0, upd: 0;
       cgcTT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcTR() //  [R1]
         { info_tbl: [(cgcTR,
                       label: block_cgcTR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcTR: // global
           if (R1 & 7 == 1) goto cgcTZ; else goto cgcU3;
       cgcTZ: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgcU3: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgaIv_entry() //  [R1]
         { info_tbl: [(cgcUH,
                       label: sat_sgaIv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcUH: // global
           _sgaIv::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgcUI; else goto cgcUJ;
       cgcUJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgcUL; else goto cgcUK;
       cgcUL: // global
           HpAlloc = 56;
           goto cgcUI;
       cgcUI: // global
           R1 = _sgaIv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcUK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaIv::P64;
           _sgaIa::P64 = P64[_sgaIv::P64 + 16];
           _sgaIh::P64 = P64[_sgaIv::P64 + 24];
           _sgaIl::P64 = P64[_sgaIv::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgaIl::P64;
           P64[Hp - 24] = _sgaIh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sgaIa::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgaIr_entry() //  [R1, R2]
         { info_tbl: [(cgcUX,
                       label: sat_sgaIr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcUX: // global
           _sgaIo::P64 = R2;
           _sgaIr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgcUY; else goto cgcUZ;
       cgcUZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgcV1; else goto cgcV0;
       cgcV1: // global
           HpAlloc = 56;
           goto cgcUY;
       cgcUY: // global
           R2 = _sgaIo::P64;
           R1 = _sgaIr::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcV0: // global
           _sgaIa::P64 = P64[_sgaIr::P64 + 7];
           _sgaIl::P64 = P64[_sgaIr::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgaIl::P64;
           P64[Hp - 24] = _sgaIo::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgaIa::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgaIs_entry() //  [R1]
         { info_tbl: [(cgcV2,
                       label: sat_sgaIs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcV2: // global
           _sgaIs::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgcV3; else goto cgcV4;
       cgcV4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcV6; else goto cgcV5;
       cgcV6: // global
           HpAlloc = 24;
           goto cgcV3;
       cgcV3: // global
           R1 = _sgaIs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcV5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaIs::P64;
           _sgaIa::P64 = P64[_sgaIs::P64 + 16];
           _sgaIi::P64 = P64[_sgaIs::P64 + 24];
           _sgaIl::P64 = P64[_sgaIs::P64 + 32];
           I64[Hp - 16] = sat_sgaIr_info;
           P64[Hp - 8] = _sgaIa::P64;
           P64[Hp] = _sgaIl::P64;
           R2 = _sgaIa::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgaIi::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgaIy_entry() //  [R1, R2]
         { info_tbl: [(cgcV7,
                       label: sat_sgaIy_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcV7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgcV8; else goto cgcV9;
       cgcV8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcV9: // global
           I64[Sp - 40] = block_cgcUr_info;
           _sgaI6::P64 = P64[R1 + 7];
           _sgaIa::P64 = P64[R1 + 15];
           _sgaIh::P64 = P64[R1 + 23];
           _sgaIi::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgaI6::P64;
           P64[Sp - 24] = _sgaIa::P64;
           P64[Sp - 16] = _sgaIh::P64;
           P64[Sp - 8] = _sgaIi::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugcVq; else goto cgcUs;
       ugcVq: // global
           call _cgcUr(R1) args: 0, res: 0, upd: 0;
       cgcUs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcUr() //  [R1]
         { info_tbl: [(cgcUr,
                       label: block_cgcUr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcUr: // global
           I64[Sp - 8] = block_cgcUw_info;
           _sgaIl::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgaIl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcVp; else goto cgcUx;
       ugcVp: // global
           call _cgcUw(R1) args: 0, res: 0, upd: 0;
       cgcUx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcUw() //  [R1]
         { info_tbl: [(cgcUw,
                       label: block_cgcUw_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcUw: // global
           _sgaIa::P64 = P64[Sp + 24];
           _sgaIh::P64 = P64[Sp + 32];
           _sgaIl::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgcVc; else goto cgcVg;
       cgcVc: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgcVf; else goto cgcVe;
       cgcVf: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcVe: // global
           I64[Hp - 72] = sat_sgaIv_info;
           P64[Hp - 56] = _sgaIa::P64;
           P64[Hp - 48] = _sgaIh::P64;
           P64[Hp - 40] = _sgaIl::P64;
           I64[Hp - 32] = sat_sgaIs_info;
           P64[Hp - 16] = _sgaIa::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sgaIl::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cgcVg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgcVl; else goto cgcVk;
       cgcVl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcVk: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgaIl::P64;
           P64[Hp - 24] = _sgaIh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgaIa::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 k1_sgaIe_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgcVr,
                       label: k1_sgaIe_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcVr: // global
           _sgaIh::P64 = R4;
           _sgaIg::P64 = R3;
           _sgaIf::P64 = R2;
           _sgaIe::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgcVs; else goto cgcVt;
       cgcVt: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgcVv; else goto cgcVu;
       cgcVv: // global
           HpAlloc = 80;
           goto cgcVs;
       cgcVs: // global
           R4 = _sgaIh::P64;
           R3 = _sgaIg::P64;
           R2 = _sgaIf::P64;
           R1 = _sgaIe::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcVu: // global
           _sgaI6::P64 = P64[_sgaIe::P64 + 5];
           _sgaI7::P64 = P64[_sgaIe::P64 + 13];
           _sgaIa::P64 = P64[_sgaIe::P64 + 21];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = _sgaI7::P64;
           P64[Hp - 48] = _sgaIf::P64;
           P64[Hp - 40] = _sgaIh::P64;
           I64[Hp - 32] = sat_sgaIy_info;
           P64[Hp - 24] = _sgaI6::P64;
           P64[Hp - 16] = _sgaIa::P64;
           P64[Hp - 8] = _sgaIh::P64;
           P64[Hp] = Hp - 72;
           R2 = _sgaIa::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgaIg::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgaIz_entry() //  [R1]
         { info_tbl: [(cgcVE,
                       label: sat_sgaIz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcVE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgcVF; else goto cgcVG;
       cgcVF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcVG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Product.$fDataProduct1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgaIA_entry() //  [R1]
         { info_tbl: [(cgcVH,
                       label: sat_sgaIA_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcVH: // global
           _sgaIA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgcVI; else goto cgcVJ;
       cgcVJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcVL; else goto cgcVK;
       cgcVL: // global
           HpAlloc = 24;
           goto cgcVI;
       cgcVI: // global
           R1 = _sgaIA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcVK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaIA::P64;
           _sgaI4::P64 = P64[_sgaIA::P64 + 16];
           _sgaIa::P64 = P64[_sgaIA::P64 + 24];
           _sgaIc::P64 = P64[_sgaIA::P64 + 32];
           _sgaIe::P64 = P64[_sgaIA::P64 + 40];
           I64[Hp - 16] = sat_sgaIz_info;
           P64[Hp] = _sgaIa::P64;
           R4 = _sgaIc::P64;
           R3 = Hp - 16;
           R2 = _sgaI4::P64;
           R1 = _sgaIe::P64;
           Sp = Sp - 16;
           call k1_sgaIe_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaIB_entry() //  [R1]
         { info_tbl: [(cgcVM,
                       label: sat_sgaIB_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcVM: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cgcVN; else goto cgcVO;
       cgcVN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgcVO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cgcUb_info;
           _sgaI4::P64 = P64[R1 + 16];
           _sgaI5::P64 = P64[R1 + 24];
           _sgaI6::P64 = P64[R1 + 32];
           _sgaI7::P64 = P64[R1 + 40];
           _sgaIa::P64 = P64[R1 + 56];
           R1 = P64[R1 + 48];
           P64[Sp - 56] = _sgaI4::P64;
           P64[Sp - 48] = _sgaI5::P64;
           P64[Sp - 40] = _sgaI6::P64;
           P64[Sp - 32] = _sgaI7::P64;
           P64[Sp - 24] = _sgaIa::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ugcVS; else goto cgcUc;
       ugcVS: // global
           call _cgcUb(R1) args: 0, res: 0, upd: 0;
       cgcUc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgcUb() //  [R1]
         { info_tbl: [(cgcUb,
                       label: block_cgcUb_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcUb: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgcVR; else goto cgcVQ;
       cgcVR: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cgcVQ: // global
           _sgaIc::P64 = P64[R1 + 7];
           _sgaId::P64 = P64[R1 + 15];
           I64[Hp - 72] = k1_sgaIe_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = P64[Sp + 32];
           _sgaIa::P64 = P64[Sp + 40];
           P64[Hp - 48] = _sgaIa::P64;
           I64[Hp - 40] = sat_sgaIA_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sgaIa::P64;
           P64[Hp - 8] = _sgaIc::P64;
           _cgcUg::P64 = Hp - 69;
           P64[Hp] = _cgcUg::P64;
           R4 = _sgaId::P64;
           R3 = Hp - 40;
           R2 = P64[Sp + 16];
           R1 = _cgcUg::P64;
           Sp = Sp + 48;
           call k1_sgaIe_entry(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$w$cgmapMo_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgcVT,
                       label: Data.Functor.Product.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcVT: // global
           _sgaI8::P64 = R6;
           _sgaI7::P64 = R5;
           _sgaI6::P64 = R4;
           _sgaI5::P64 = R3;
           _sgaI4::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgcVU; else goto cgcVV;
       cgcVV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgcVX; else goto cgcVW;
       cgcVX: // global
           HpAlloc = 24;
           goto cgcVU;
       cgcVU: // global
           R6 = _sgaI8::P64;
           R5 = _sgaI7::P64;
           R4 = _sgaI6::P64;
           R3 = _sgaI5::P64;
           R2 = _sgaI4::P64;
           R1 = Data.Functor.Product.$w$cgmapMo_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcVW: // global
           I64[Hp - 16] = lvl9_sgaI9_info;
           P64[Hp] = _sgaI6::P64;
           I64[Sp - 56] = block_cgcTA_info;
           R2 = _sgaI6::P64;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = _sgaI4::P64;
           P64[Sp - 32] = _sgaI5::P64;
           P64[Sp - 24] = _sgaI6::P64;
           P64[Sp - 16] = _sgaI7::P64;
           P64[Sp - 8] = _sgaI8::P64;
           Sp = Sp - 56;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgcTA() //  [R1]
         { info_tbl: [(cgcTA,
                       label: block_cgcTA_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcTA: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgcW0; else goto cgcVZ;
       cgcW0: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcVZ: // global
           I64[Hp - 80] = sat_sgaIH_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = R1;
           I64[Hp - 56] = sat_sgaIB_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 56;
           P64[Sp + 48] = Hp - 79;
           Sp = Sp + 32;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.586866534 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_$cgmapMo_closure" {
     Data.Functor.Product.$fDataProduct_$cgmapMo_closure:
         const Data.Functor.Product.$fDataProduct_$cgmapMo_info;
 },
 Data.Functor.Product.$fDataProduct_$cgmapMo_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcYk: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Product.$fDataProduct_$cgmapMo_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Product.$fDataProduct_$cgmapMo_entry() //  [R6]
         { info_tbl: [(cgcYo,
                       label: Data.Functor.Product.$fDataProduct_$cgmapMo_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcYo: // global
           _sgaIM::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _sgaIM::P64;
           Sp = Sp + 32;
           call Data.Functor.Product.$w$cgmapMo_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.59294752 UTC

[section ""data" . lvl5_rg5oj_closure" {
     lvl5_rg5oj_closure:
         const lvl5_rg5oj_info;
         const 0;
 },
 lvl5_rg5oj_entry() //  [R2]
         { info_tbl: [(cgcYE,
                       label: lvl5_rg5oj_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcYE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgcYF; else goto cgcYG;
       cgcYF: // global
           R2 = R2;
           R1 = lvl5_rg5oj_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcYG: // global
           I64[Sp - 8] = block_cgcYB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugcYK; else goto cgcYC;
       ugcYK: // global
           call _cgcYB() args: 0, res: 0, upd: 0;
       cgcYC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgcYB() //  []
         { info_tbl: [(cgcYB,
                       label: block_cgcYB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcYB: // global
           R1 = Data.Functor.Product.$cPair_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.598241795 UTC

[section ""data" . lvl6_rg5ok_closure" {
     lvl6_rg5ok_closure:
         const lvl6_rg5ok_info;
         const 0;
 },
 lvl6_rg5ok_entry() //  []
         { info_tbl: [(cgcZ0,
                       label: lvl6_rg5ok_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcZ0: // global
           R1 = Data.Functor.Product.$tProduct_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.601719757 UTC

[section ""data" . lvl7_rg5ol_closure" {
     lvl7_rg5ol_closure:
         const lvl7_rg5ol_info;
 },
 lvl7_rg5ol_entry() //  []
         { info_tbl: [(cgcZc,
                       label: lvl7_rg5ol_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcZc: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.604881432 UTC

[section ""data" . lvl8_rg5om_closure" {
     lvl8_rg5om_closure:
         const lvl8_rg5om_info;
 },
 lvl8_rg5om_entry() //  []
         { info_tbl: [(cgcZp,
                       label: lvl8_rg5om_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcZp: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.611178641 UTC

[section ""data" . Data.Functor.Product.$fDataProduct_closure" {
     Data.Functor.Product.$fDataProduct_closure:
         const Data.Functor.Product.$fDataProduct_info;
         const 0;
 },
 sat_sgaJG_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgcZH,
                       label: sat_sgaJG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcZH: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$w$cgmapMo_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaJC_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgcZP,
                       label: sat_sgaJC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcZP: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Product.$w$cgmapMp_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaJy_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgcZX,
                       label: sat_sgaJy_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcZX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgcZY; else goto cgcZZ;
       cgcZY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcZZ: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Product.$fDataProduct_$cgmapM_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sgaJx_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgd05,
                       label: sat_sgaJx_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd05: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgd06; else goto cgd07;
       cgd06: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgd07: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Product.$fDataProduct_$cgmapQi_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sgaJw_entry() //  [R1, R2, R3]
         { info_tbl: [(cgd0g,
                       label: sat_sgaJw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd0g: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgd0n; else goto cgd0o;
       cgd0n: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgd0o: // global
           I64[Sp - 32] = block_cgd0d_info;
           _sgaJ4::P64 = P64[R1 + 6];
           _sgaJ5::P64 = P64[R1 + 14];
           R1 = R3;
           P64[Sp - 24] = _sgaJ4::P64;
           P64[Sp - 16] = _sgaJ5::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugd0s; else goto cgd0e;
       ugd0s: // global
           call _cgd0d(R1) args: 0, res: 0, upd: 0;
       cgd0e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgd0d() //  [R1]
         { info_tbl: [(cgd0d,
                       label: block_cgd0d_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd0d: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgd0r; else goto cgd0q;
       cgd0r: // global
           HpAlloc = 128;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgd0q: // global
           _sgaJr::P64 = P64[R1 + 7];
           _sgaJs::P64 = P64[R1 + 15];
           I64[Hp - 120] = stg_ap_3_upd_info;
           _sgaJo::P64 = P64[Sp + 24];
           P64[Hp - 104] = _sgaJo::P64;
           P64[Hp - 96] = P64[Sp + 16];
           P64[Hp - 88] = _sgaJs::P64;
           I64[Hp - 80] = :_con_info;
           P64[Hp - 72] = Hp - 120;
           P64[Hp - 64] = GHC.Types.[]_closure+1;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sgaJo::P64;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgaJr::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 78;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaJn_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgd0y,
                       label: sat_sgaJn_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd0y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgd0z; else goto cgd0A;
       cgd0z: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgd0A: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Product.$fDataProduct_$cgmapQr_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sgaJm_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgd0G,
                       label: sat_sgaJm_info
                       rep:HeapRep 6 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd0G: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgd0H; else goto cgd0I;
       cgd0H: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgd0I: // global
           R6 = P64[R1 + 36];
           _B1::P64 = R5;
           R5 = P64[R1 + 28];
           _B2::P64 = R4;
           R4 = P64[R1 + 20];
           _B3::P64 = R3;
           R3 = P64[R1 + 12];
           _B4::P64 = R2;
           R2 = P64[R1 + 4];
           P64[Sp - 40] = P64[R1 + 44];
           P64[Sp - 32] = _B4::P64;
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 40;
           call Data.Functor.Product.$fDataProduct2_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sgaJl_entry() //  [R1, R2, R3]
         { info_tbl: [(cgd0R,
                       label: sat_sgaJl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd0R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgd0X; else goto cgd0Y;
       cgd0X: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgd0Y: // global
           I64[Sp - 32] = block_cgd0O_info;
           _sgaJ4::P64 = P64[R1 + 6];
           _sgaJ5::P64 = P64[R1 + 14];
           R1 = R3;
           P64[Sp - 24] = _sgaJ4::P64;
           P64[Sp - 16] = _sgaJ5::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugd12; else goto cgd0P;
       ugd12: // global
           call _cgd0O(R1) args: 0, res: 0, upd: 0;
       cgd0P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgd0O() //  [R1]
         { info_tbl: [(cgd0O,
                       label: block_cgd0O_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd0O: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgd11; else goto cgd10;
       cgd11: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgd10: // global
           _sgaJh::P64 = P64[R1 + 7];
           _sgaJi::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           _sgaJe::P64 = P64[Sp + 24];
           P64[Hp - 80] = _sgaJe::P64;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sgaJi::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _sgaJe::P64;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgaJh::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaJb_entry() //  [R1]
         { info_tbl: [(cgd1g,
                       label: sat_sgaJb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd1g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgd1h; else goto cgd1i;
       cgd1h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgd1i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Product.Pair_closure+2;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaJc_entry() //  [R1]
         { info_tbl: [(cgd1j,
                       label: sat_sgaJc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd1j: // global
           _sgaJc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgd1k; else goto cgd1l;
       cgd1l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgd1n; else goto cgd1m;
       cgd1n: // global
           HpAlloc = 24;
           goto cgd1k;
       cgd1k: // global
           R1 = _sgaJc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgd1m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgaJc::P64;
           _sgaJ4::P64 = P64[_sgaJc::P64 + 16];
           _sgaJ8::P64 = P64[_sgaJc::P64 + 24];
           _sgaJ9::P64 = P64[_sgaJc::P64 + 32];
           I64[Hp - 16] = sat_sgaJb_info;
           P64[Hp] = _sgaJ9::P64;
           R3 = Hp - 16;
           R2 = _sgaJ4::P64;
           R1 = _sgaJ8::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgaJd_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgd1o,
                       label: sat_sgaJd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd1o: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgd1s; else goto cgd1r;
       cgd1s: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgd1r: // global
           _sgaJ4::P64 = P64[R1 + 5];
           _sgaJ5::P64 = P64[R1 + 13];
           I64[Hp - 32] = sat_sgaJc_info;
           P64[Hp - 16] = _sgaJ4::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 32;
           _sgaJ8::P64 = R2;
           R2 = _sgaJ5::P64;
           R1 = _sgaJ8::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgaJ7_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgd1y,
                       label: sat_sgaJ7_info
                       rep:HeapRep 6 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd1y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgd1z; else goto cgd1A;
       cgd1z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgd1A: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 32] = P64[R1 + 45];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 32;
           call Data.Functor.Product.$fDataProduct_$cgfoldl_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sgaJ6_entry() //  [R1]
         { info_tbl: [(cgd1F,
                       label: sat_sgaJ6_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd1F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgd1G; else goto cgd1H;
       cgd1G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgd1H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Product.$w$cp1Data_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Product.$fDataProduct_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgd1J,
                       label: Data.Functor.Product.$fDataProduct_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd1J: // global
           Hp = Hp + 576;
           if (Hp > HpLim) (likely: False) goto cgd1N; else goto cgd1M;
       cgd1N: // global
           HpAlloc = 576;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.$fDataProduct_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgd1M: // global
           I64[Hp - 568] = sat_sgaJG_info;
           P64[Hp - 560] = R6;
           _sgaJ5::P64 = P64[Sp];
           P64[Hp - 552] = _sgaJ5::P64;
           I64[Hp - 544] = sat_sgaJC_info;
           P64[Hp - 536] = R6;
           P64[Hp - 528] = _sgaJ5::P64;
           I64[Hp - 520] = sat_sgaJy_info;
           P64[Hp - 512] = R2;
           P64[Hp - 504] = R3;
           P64[Hp - 496] = R4;
           P64[Hp - 488] = R5;
           P64[Hp - 480] = R6;
           P64[Hp - 472] = _sgaJ5::P64;
           I64[Hp - 464] = sat_sgaJx_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           P64[Hp - 440] = R4;
           P64[Hp - 432] = R5;
           P64[Hp - 424] = R6;
           P64[Hp - 416] = _sgaJ5::P64;
           I64[Hp - 408] = sat_sgaJw_info;
           P64[Hp - 400] = R6;
           P64[Hp - 392] = _sgaJ5::P64;
           I64[Hp - 384] = sat_sgaJn_info;
           P64[Hp - 376] = R2;
           P64[Hp - 368] = R3;
           P64[Hp - 360] = R4;
           P64[Hp - 352] = R5;
           P64[Hp - 344] = R6;
           P64[Hp - 336] = _sgaJ5::P64;
           I64[Hp - 328] = sat_sgaJm_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           P64[Hp - 296] = R5;
           P64[Hp - 288] = R6;
           P64[Hp - 280] = _sgaJ5::P64;
           I64[Hp - 272] = sat_sgaJl_info;
           P64[Hp - 264] = R6;
           P64[Hp - 256] = _sgaJ5::P64;
           I64[Hp - 248] = sat_sgaJd_info;
           P64[Hp - 240] = R6;
           P64[Hp - 232] = _sgaJ5::P64;
           I64[Hp - 224] = sat_sgaJ7_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           P64[Hp - 200] = R4;
           P64[Hp - 192] = R5;
           P64[Hp - 184] = R6;
           P64[Hp - 176] = _sgaJ5::P64;
           I64[Hp - 168] = sat_sgaJ6_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           P64[Hp - 136] = R4;
           P64[Hp - 128] = R5;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 168;
           P64[Hp - 104] = Hp - 221;
           P64[Hp - 96] = Hp - 245;
           P64[Hp - 88] = lvl5_rg5oj_closure+1;
           P64[Hp - 80] = lvl6_rg5ok_closure+1;
           P64[Hp - 72] = lvl7_rg5ol_closure+2;
           P64[Hp - 64] = lvl8_rg5om_closure+2;
           P64[Hp - 56] = Hp - 270;
           P64[Hp - 48] = Hp - 324;
           P64[Hp - 40] = Hp - 380;
           P64[Hp - 32] = Hp - 406;
           P64[Hp - 24] = Hp - 461;
           P64[Hp - 16] = Hp - 517;
           P64[Hp - 8] = Hp - 541;
           P64[Hp] = Hp - 565;
           R1 = Hp - 119;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.650548649 UTC

[section ""data" . Data.Functor.Product.Pair_closure" {
     Data.Functor.Product.Pair_closure:
         const Data.Functor.Product.Pair_info;
 },
 Data.Functor.Product.Pair_entry() //  [R2, R3]
         { info_tbl: [(cgd3Q,
                       label: Data.Functor.Product.Pair_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd3Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgd3U; else goto cgd3T;
       cgd3U: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Product.Pair_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgd3T: // global
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.65439717 UTC

[Data.Functor.Product.Pair_con_entry() //  [R1]
         { info_tbl: [(cgd41,
                       label: Data.Functor.Product.Pair_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,80,114,111,100,117,99,116,46,80,97,105,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgd41: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:05.657842588 UTC

[section ""relreadonly" . SgaPW_srt" {
     SgaPW_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Product.$fRead1Product1_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadPrec_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadListPrec_closure;
         const Data.Functor.Product.$fRead1Product_$cliftReadList_closure;
         const Data.Functor.Product.$fRead1Product_closure;
         const Data.Functor.Product.$fRead1Product2_closure;
         const Data.Functor.Product.$w$cliftShowsPrec_closure;
         const Data.Functor.Product.$fShow1Product_$cliftShowsPrec_closure;
         const Data.Functor.Product.$fShow1Product_$cliftShowList_closure;
         const Data.Functor.Product.$fShow1Product_closure;
         const Data.Functor.Product.$fReadProduct_$creadPrec_closure;
         const Data.Functor.Product.$fReadProduct_$creadsPrec_closure;
         const Data.Functor.Product.$fReadProduct_$creadListPrec_closure;
         const Data.Functor.Product.$fReadProduct_$creadList_closure;
         const Data.Functor.Product.$fReadProduct_closure;
         const Data.Functor.Product.$w$cshowsPrec_closure;
         const Data.Functor.Product.$fShowProduct_$cshowsPrec_closure;
         const Data.Functor.Product.$w$cshow_closure;
         const Data.Functor.Product.$fShowProduct_$cshow_closure;
         const Data.Functor.Product.$fShowProduct_$cshowList_closure;
         const Data.Functor.Product.$fShowProduct_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Functor.Product.$fFoldableProduct_$csum_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Functor.Product.$fFoldableProduct2_closure;
         const Data.Functor.Product.$fFoldableProduct_$cminimum_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Product.$fFoldableProduct3_closure;
         const Data.Functor.Product.$fFoldableProduct_$cmaximum_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Functor.Product.$fFoldableProduct_$celem_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Functor.Product.$fFoldableProduct8_closure;
         const Data.Functor.Product.$w$cfoldl_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldl_closure;
         const Data.Functor.Product.$w$cfoldl1_closure;
         const Data.Functor.Product.$fFoldableProduct7_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldl1_closure;
         const Data.Functor.Product.$w$cfoldr'_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldr'_closure;
         const Data.Functor.Product.$w$cfoldr_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldr_closure;
         const Data.Functor.Product.$w$cfoldl'_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldl'_closure;
         const Data.Functor.Product.$fFoldableProduct_$clength_closure;
         const Data.Functor.Product.$w$cfoldr1_closure;
         const Data.Functor.Product.$fFoldableProduct9_closure;
         const Data.Functor.Product.$fFoldableProduct_$cfoldr1_closure;
         const Data.Functor.Product.$fFoldableProduct_$cnull_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Functor.Product.$fFoldableProduct_$cproduct_closure;
         const Data.Functor.Product.$fFoldableProduct_$ctoList_closure;
         const Data.Functor.Product.$fFoldableProduct_closure;
         const Data.Functor.Product.$fTraversableProduct_$cp2Traversable_closure;
         const Data.Functor.Product.$fTraversableProduct_closure;
         const poly_some_v_rg5o0_closure;
         const Data.Functor.Product.$fAlternativeProduct_$csome_closure;
         const Data.Functor.Product.$fAlternativeProduct_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Product.$fMonadProduct_closure;
         const lvl4_rg5o1_closure;
         const Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus_closure;
         const Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus_closure;
         const Data.Functor.Product.$fMonadPlusProduct_closure;
         const Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix_closure;
         const Data.Functor.Product.$fMonadFixProduct_closure;
         const Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip_closure;
         const Data.Functor.Product.$fMonadZipProduct_closure;
         const GHC.List.badHead_closure;
         const go61_rg5o2_closure;
         const Data.Functor.Product.$fRead1Product2_closure;
         const Data.Data.mkConstr1_closure;
         const Data.Functor.Product.$fDataProduct4_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Functor.Product.$w$cp1Data_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Functor.Product.$fDataProduct_$cgmapQi_closure;
         const Data.Functor.Product.$cPair_closure;
         const lvl5_rg5oj_closure;
         const Data.Functor.Product.$tProduct_closure;
         const Data.Functor.Product.$fDataProduct_closure;
         const lvl6_rg5ok_closure;
 }]

