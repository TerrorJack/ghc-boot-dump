
==================== Output Cmm ====================
2018-03-16 16:02:20.466130219 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:20.466824285 UTC

[section ""data" . Data.Functor.Const.$fReadConst3_closure" {
     Data.Functor.Const.$fReadConst3_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.467454566 UTC

[section ""cstring" . Data.Functor.Const.$fReadConst5_bytes" {
     Data.Functor.Const.$fReadConst5_bytes:
         I8[] [67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.468470932 UTC

[section ""data" . Data.Functor.Const.$fReadConst4_closure" {
     Data.Functor.Const.$fReadConst4_closure:
         const Data.Functor.Const.$fReadConst4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fReadConst4_entry() //  [R1]
         { info_tbl: [(c755w,
                       label: Data.Functor.Const.$fReadConst4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c755w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c755x; else goto c755y;
       c755x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c755y: // global
           (_c755t::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c755t::I64 == 0) goto c755v; else goto c755u;
       c755v: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c755u: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c755t::I64;
           R2 = Data.Functor.Const.$fReadConst5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.471304213 UTC

[section ""data" . Data.Functor.Const.$w$creadsPrec_closure" {
     Data.Functor.Const.$w$creadsPrec_closure:
         const Data.Functor.Const.$w$creadsPrec_info;
         const 0;
 },
 go1_s750f_entry() //  [R1, R2]
         { info_tbl: [(c756b,
                       label: go1_s750f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c756b: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c756c; else goto c756d;
       c756c: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c756d: // global
           I64[Sp - 24] = block_c7564_info;
           _s750f::P64 = R1;
           _s750e::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s750e::P64;
           P64[Sp - 8] = _s750f::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u756v; else goto c7565;
       u756v: // global
           call _c7564(R1) args: 0, res: 0, upd: 0;
       c7565: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7564() //  [R1]
         { info_tbl: [(c7564,
                       label: block_c7564_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7564: // global
           if (R1 & 7 == 1) goto c7568; else goto c7569;
       c7568: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7569: // global
           I64[Sp] = block_c756j_info;
           _s750j::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _s750j::P64;
           if (R1 & 7 != 0) goto u756u; else goto c756k;
       u756u: // global
           call _c756j(R1) args: 0, res: 0, upd: 0;
       c756k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c756j() //  [R1]
         { info_tbl: [(c756j,
                       label: block_c756j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c756j: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c756t; else goto c756s;
       c756t: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c756s: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s7505_entry() //  [R1, R2]
         { info_tbl: [(c756A,
                       label: go_s7505_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c756A: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c756B; else goto u756V;
       c756B: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u756V: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _c755F() args: 0, res: 0, upd: 0;
     }
 },
 _c755F() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c755F: // global
           _s7502::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_c755I_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7502::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u756X; else goto c755J;
       u756X: // global
           call _c755I(R1) args: 0, res: 0, upd: 0;
       c755J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c755I() //  [R1]
         { info_tbl: [(c755I,
                       label: block_c755I_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c755I: // global
           if (R1 & 7 == 1) goto c756x; else goto c756y;
       c756x: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c756y: // global
           I64[Sp - 8] = block_c755O_info;
           _s7509::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s7509::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u756Y; else goto c755P;
       u756Y: // global
           call _c755O(R1) args: 0, res: 0, upd: 0;
       c755P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c755O() //  [R1]
         { info_tbl: [(c755O,
                       label: block_c755O_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c755O: // global
           I64[Sp - 8] = block_c755T_info;
           R3 = Data.Functor.Const.$fReadConst4_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c755T() //  [R1]
         { info_tbl: [(c755T,
                       label: block_c755T_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c755T: // global
           _s7509::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c756K; else goto c756M;
       c756K: // global
           P64[Sp + 32] = _s7509::P64;
           Sp = Sp + 24;
           call _c755F() args: 0, res: 0, upd: 0;
       c756M: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c756P; else goto c756O;
       c756P: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c756O: // global
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _s7509::P64;
           I64[Hp - 8] = go1_s750f_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 24] = block_c756L_info;
           R2 = P64[Sp + 32];
           I64[Sp] = stg_ap_pp_info;
           _s750c::P64 = P64[Sp + 8];
           P64[Sp + 8] = Data.Functor.Const.$fReadConst3_closure+1;
           P64[Sp + 16] = _s750c::P64;
           P64[Sp + 32] = Hp - 7;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c756L() //  [R1]
         { info_tbl: [(c756L,
                       label: block_c756L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c756L: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_s750f_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750u_entry() //  [R1, R2]
         { info_tbl: [(c7578,
                       label: sat_s750u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7578: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7579; else goto c757a;
       c7579: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c757a: // global
           I64[Sp - 16] = block_c7576_info;
           R3 = R2;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7576() //  [R1]
         { info_tbl: [(c7576,
                       label: block_c7576_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7576: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s7505_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$w$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c757g,
                       label: Data.Functor.Const.$w$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c757g: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c757k; else goto c757j;
       c757k: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$w$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c757j: // global
           I64[Hp - 24] = go_s7505_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s750u_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           _s750r::P64 = I64[(%MO_S_Gt_W64(R3,
                                           10) << 3) + GHC.Types.Bool_closure_tbl];
           R3 = Hp - 7;
           R2 = _s750r::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.475534676 UTC

[section ""data" . Data.Functor.Const.$fReadConst_$creadsPrec_closure" {
     Data.Functor.Const.$fReadConst_$creadsPrec_closure:
         const Data.Functor.Const.$fReadConst_$creadsPrec_info;
         const 0;
 },
 Data.Functor.Const.$fReadConst_$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c757t,
                       label: Data.Functor.Const.$fReadConst_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c757t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c757u; else goto c757v;
       c757u: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fReadConst_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c757v: // global
           I64[Sp - 24] = block_c757q_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u757z; else goto c757r;
       u757z: // global
           call _c757q(R1) args: 0, res: 0, upd: 0;
       c757r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c757q() //  [R1]
         { info_tbl: [(c757q,
                       label: block_c757q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c757q: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Const.$w$creadsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.477155154 UTC

[section ""data" . Data.Functor.Const.$fReadConst2_closure" {
     Data.Functor.Const.$fReadConst2_closure:
         const Data.Functor.Const.$fReadConst2_info;
         const 0;
 },
 sat_s750D_entry() //  [R1, R2]
         { info_tbl: [(c757J,
                       label: sat_s750D_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c757J: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Const.$fReadConst_$creadsPrec_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fReadConst2_entry() //  [R2, R3, R4]
         { info_tbl: [(c757P,
                       label: Data.Functor.Const.$fReadConst2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c757P: // global
           _s750C::P64 = R4;
           _s750B::P64 = R3;
           _s750A::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c757Q; else goto c757R;
       c757R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c757T; else goto c757S;
       c757T: // global
           HpAlloc = 24;
           goto c757Q;
       c757Q: // global
           R4 = _s750C::P64;
           R3 = _s750B::P64;
           R2 = _s750A::P64;
           R1 = Data.Functor.Const.$fReadConst2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c757S: // global
           I64[Hp - 16] = sat_s750D_info;
           P64[Hp - 8] = _s750A::P64;
           P64[Hp] = _s750B::P64;
           I64[Sp - 8] = block_c757M_info;
           R3 = _s750C::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c757M() //  [R1]
         { info_tbl: [(c757M,
                       label: block_c757M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c757M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c757W; else goto c757V;
       c757W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c757V: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.478728815 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst5_closure" {
     Data.Functor.Const.$fFoldableConst5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.479828086 UTC

[section ""data" . Data.Functor.Const.$fReadConst_$creadList_closure" {
     Data.Functor.Const.$fReadConst_$creadList_closure:
         const Data.Functor.Const.$fReadConst_$creadList_info;
         const 0;
 },
 sat_s750H_entry() //  [R1, R2, R3]
         { info_tbl: [(c758a,
                       label: sat_s750H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c758a: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750I_entry() //  [R1]
         { info_tbl: [(c758d,
                       label: sat_s750I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c758d: // global
           _s750I::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c758e; else goto c758f;
       c758f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c758h; else goto c758g;
       c758h: // global
           HpAlloc = 16;
           goto c758e;
       c758e: // global
           R1 = _s750I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c758g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s750I::P64;
           _s750G::P64 = P64[_s750I::P64 + 16];
           I64[Hp - 8] = sat_s750H_info;
           P64[Hp] = _s750G::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Const.$fFoldableConst5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fReadConst_$creadList_entry() //  [R2]
         { info_tbl: [(c758i,
                       label: Data.Functor.Const.$fReadConst_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c758i: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c758m; else goto c758l;
       c758m: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fReadConst_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c758l: // global
           I64[Hp - 16] = sat_s750I_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.482178148 UTC

[section ""data" . Data.Functor.Const.$w$creadListPrec_closure" {
     Data.Functor.Const.$w$creadListPrec_closure:
         const Data.Functor.Const.$w$creadListPrec_info;
         const 0;
 },
 sat_s750L_entry() //  [R1, R2, R3]
         { info_tbl: [(c758A,
                       label: sat_s750L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c758A: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 w1_s750K_entry() //  [R1]
         { info_tbl: [(c758D,
                       label: w1_s750K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c758D: // global
           _s750K::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c758E; else goto c758F;
       c758F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c758H; else goto c758G;
       c758H: // global
           HpAlloc = 16;
           goto c758E;
       c758E: // global
           R1 = _s750K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c758G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s750K::P64;
           _s750J::P64 = P64[_s750K::P64 + 16];
           I64[Hp - 8] = sat_s750L_info;
           P64[Hp] = _s750J::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Const.$fFoldableConst5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 w2_s750M_entry() //  [R1, R2]
         { info_tbl: [(c758N,
                       label: w2_s750M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c758N: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750Q_entry() //  [R1, R2]
         { info_tbl: [(c758Y,
                       label: sat_s750Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c758Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c758Z; else goto c7590;
       c758Z: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7590: // global
           I64[Sp - 8] = block_c758V_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c758V() //  [R1]
         { info_tbl: [(c758V,
                       label: block_c758V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c758V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7593; else goto c7592;
       c7593: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7592: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$w$creadListPrec_entry() //  [R2]
         { info_tbl: [(c7594,
                       label: Data.Functor.Const.$w$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7594: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7598; else goto c7597;
       c7598: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Const.$w$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7597: // global
           I64[Hp - 48] = w1_s750K_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = w2_s750M_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s750Q_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.484527604 UTC

[section ""data" . Data.Functor.Const.$fReadConst1_closure" {
     Data.Functor.Const.$fReadConst1_closure:
         const Data.Functor.Const.$fReadConst1_info;
         const 0;
 },
 Data.Functor.Const.$fReadConst1_entry() //  [R2]
         { info_tbl: [(c759d,
                       label: Data.Functor.Const.$fReadConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c759d: // global
           R2 = R2;
           call Data.Functor.Const.$w$creadListPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.486075576 UTC

[section ""data" . Data.Functor.Const.$fReadConst_closure" {
     Data.Functor.Const.$fReadConst_closure:
         const Data.Functor.Const.$fReadConst_info;
         const 0;
 },
 lvl_s750U_entry() //  [R1]
         { info_tbl: [(c759o,
                       label: lvl_s750U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c759o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c759p; else goto c759q;
       c759p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c759q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$w$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s750Z_entry() //  [R1]
         { info_tbl: [(c759w,
                       label: sat_s750Z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c759w: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750X_entry() //  [R1, R2, R3]
         { info_tbl: [(c759E,
                       label: sat_s750X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c759E: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750W_entry() //  [R1]
         { info_tbl: [(c759L,
                       label: sat_s750W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c759L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c759M; else goto c759N;
       c759M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c759N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fReadConst_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s750V_entry() //  [R1, R2, R3]
         { info_tbl: [(c759T,
                       label: sat_s750V_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c759T: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst_$creadsPrec_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fReadConst_entry() //  [R2]
         { info_tbl: [(c759X,
                       label: Data.Functor.Const.$fReadConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c759X: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c75a1; else goto c75a0;
       c75a1: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fReadConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75a0: // global
           I64[Hp - 128] = lvl_s750U_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s750Z_info;
           P64[Hp - 96] = Hp - 128;
           I64[Hp - 88] = sat_s750X_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s750W_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s750V_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 46;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.488245625 UTC

[section ""cstring" . Data.Functor.Const.$fShowConst2_bytes" {
     Data.Functor.Const.$fShowConst2_bytes:
         I8[] [67,111,110,115,116,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.489051406 UTC

[section ""data" . Data.Functor.Const.$fShowConst1_closure" {
     Data.Functor.Const.$fShowConst1_closure:
         const Data.Functor.Const.$fShowConst1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fShowConst1_entry() //  [R1]
         { info_tbl: [(c75a8,
                       label: Data.Functor.Const.$fShowConst1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75a8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75a9; else goto c75aa;
       c75a9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75aa: // global
           (_c75a5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c75a5::I64 == 0) goto c75a7; else goto c75a6;
       c75a7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c75a6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c75a5::I64;
           R2 = Data.Functor.Const.$fShowConst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.492872646 UTC

[section ""data" . Data.Functor.Const.$w$cshowsPrec_closure" {
     Data.Functor.Const.$w$cshowsPrec_closure:
         const Data.Functor.Const.$w$cshowsPrec_info;
         const 0;
 },
 g_s7513_entry() //  [R1]
         { info_tbl: [(c75aj,
                       label: g_s7513_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75aj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c75ak; else goto c75al;
       c75ak: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75al: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Const.$fReadConst3_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s7516_entry() //  [R1]
         { info_tbl: [(c75ay,
                       label: sat_s7516_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ay: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7517_entry() //  [R1, R2]
         { info_tbl: [(c75aB,
                       label: sat_s7517_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75aB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c75aF; else goto c75aE;
       c75aF: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75aE: // global
           _s7513::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s7516_info;
           P64[Hp - 8] = _s7513::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Functor.Const.$fShowConst1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s751a_entry() //  [R1]
         { info_tbl: [(c75aV,
                       label: sat_s751a_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75aV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75aZ; else goto c75aY;
       c75aZ: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75aY: // global
           _s7513::P64 = P64[R1 + 16];
           _s7518::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s7518::P64;
           R2 = Hp - 14;
           R1 = _s7513::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s751b_entry() //  [R1]
         { info_tbl: [(c75b0,
                       label: sat_s751b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75b0: // global
           _s751b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c75b1; else goto c75b2;
       c75b2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c75b4; else goto c75b3;
       c75b4: // global
           HpAlloc = 32;
           goto c75b1;
       c75b1: // global
           R1 = _s751b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75b3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s751b::P64;
           _s7513::P64 = P64[_s751b::P64 + 16];
           _s7518::P64 = P64[_s751b::P64 + 24];
           I64[Hp - 24] = sat_s751a_info;
           P64[Hp - 8] = _s7513::P64;
           P64[Hp] = _s7518::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Const.$fShowConst1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s751c_entry() //  [R1, R2]
         { info_tbl: [(c75b6,
                       label: sat_s751c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75b6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c75ba; else goto c75b9;
       c75ba: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75b9: // global
           _s7513::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s751b_info;
           P64[Hp - 32] = _s7513::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c75be,
                       label: Data.Functor.Const.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75be: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c75bi; else goto c75bh;
       c75bi: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c75bh: // global
           I64[Hp - 40] = g_s7513_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c75af::P64 = Hp - 40;
           if (%MO_S_Le_W64(R3, 10)) goto c75bc; else goto c75bd;
       c75bc: // global
           I64[Hp - 8] = sat_s7517_info;
           P64[Hp] = _c75af::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c75bd: // global
           I64[Hp - 8] = sat_s751c_info;
           P64[Hp] = _c75af::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.495924279 UTC

[section ""data" . Data.Functor.Const.$fShowConst_$cshowsPrec_closure" {
     Data.Functor.Const.$fShowConst_$cshowsPrec_closure:
         const Data.Functor.Const.$fShowConst_$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Const.$fShowConst_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c75bq,
                       label: Data.Functor.Const.$fShowConst_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75bq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c75br; else goto c75bs;
       c75br: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c75bs: // global
           I64[Sp - 24] = block_c75bn_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u75bw; else goto c75bo;
       u75bw: // global
           call _c75bn(R1) args: 0, res: 0, upd: 0;
       c75bo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c75bn() //  [R1]
         { info_tbl: [(c75bn,
                       label: block_c75bn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75bn: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Const.$w$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.497511905 UTC

[section ""data" . Data.Functor.Const.$fShowConst_$cshow_closure" {
     Data.Functor.Const.$fShowConst_$cshow_closure:
         const Data.Functor.Const.$fShowConst_$cshow_info;
         const 0;
 },
 sat_s751k_entry() //  [R1]
         { info_tbl: [(c75bF,
                       label: sat_s751k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75bF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c75bG; else goto c75bH;
       c75bG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75bH: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Functor.Const.$fReadConst3_closure+1;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fShowConst_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c75bI,
                       label: Data.Functor.Const.$fShowConst_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75bI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c75bM; else goto c75bL;
       c75bM: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c75bL: // global
           I64[Hp - 24] = sat_s751k_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Functor.Const.$fShowConst1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.498990293 UTC

[section ""data" . Data.Functor.Const.$fShowConst_$cshowList_closure" {
     Data.Functor.Const.$fShowConst_$cshowList_closure:
         const Data.Functor.Const.$fShowConst_$cshowList_info;
         const 0;
 },
 sat_s751p_entry() //  [R1, R2]
         { info_tbl: [(c75bW,
                       label: sat_s751p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75bW: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Functor.Const.$w$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fShowConst_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c75bZ,
                       label: Data.Functor.Const.$fShowConst_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75bZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c75c3; else goto c75c2;
       c75c3: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c75c2: // global
           I64[Hp - 8] = sat_s751p_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.50063902 UTC

[section ""data" . Data.Functor.Const.$fShowConst_closure" {
     Data.Functor.Const.$fShowConst_closure:
         const Data.Functor.Const.$fShowConst_info;
         const 0;
 },
 sat_s751t_entry() //  [R1, R2, R3]
         { info_tbl: [(c75cd,
                       label: sat_s751t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75cd: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fShowConst_$cshowList_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s751s_entry() //  [R1, R2]
         { info_tbl: [(c75cl,
                       label: sat_s751s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75cl: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Const.$fShowConst_$cshow_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s751r_entry() //  [R1, R2, R3]
         { info_tbl: [(c75ct,
                       label: sat_s751r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ct: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fShowConst_$cshowsPrec_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fShowConst_entry() //  [R2]
         { info_tbl: [(c75cx,
                       label: Data.Functor.Const.$fShowConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75cx: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c75cB; else goto c75cA;
       c75cB: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75cA: // global
           I64[Hp - 72] = sat_s751t_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s751s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s751r_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.502377726 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldMap_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldMap_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldMap_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldMap_entry() //  [R2]
         { info_tbl: [(c75cG,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75cG: // global
           R2 = R2;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.503304045 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfold_closure" {
     Data.Functor.Const.$fFoldableConst_$cfold_closure:
         const Data.Functor.Const.$fFoldableConst_$cfold_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfold_entry() //  [R2]
         { info_tbl: [(c75cN,
                       label: Data.Functor.Const.$fFoldableConst_$cfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75cN: // global
           R2 = R2;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.504166772 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$csum_closure" {
     Data.Functor.Const.$fFoldableConst_$csum_closure:
         const Data.Functor.Const.$fFoldableConst_$csum_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$csum_entry() //  [R2]
         { info_tbl: [(c75cU,
                       label: Data.Functor.Const.$fFoldableConst_$csum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75cU: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fMonoidSum2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.504896251 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst2_bytes" {
     Data.Functor.Const.$fFoldableConst2_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.505735231 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst1_closure" {
     Data.Functor.Const.$fFoldableConst1_closure:
         const Data.Functor.Const.$fFoldableConst1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst1_entry() //  [R1]
         { info_tbl: [(c75d3,
                       label: Data.Functor.Const.$fFoldableConst1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75d3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75d4; else goto c75d5;
       c75d4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75d5: // global
           (_c75d0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c75d0::I64 == 0) goto c75d2; else goto c75d1;
       c75d2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c75d1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c75d0::I64;
           R2 = Data.Functor.Const.$fFoldableConst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.506817737 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cminimum_closure" {
     Data.Functor.Const.$fFoldableConst_$cminimum_closure:
         const Data.Functor.Const.$fFoldableConst_$cminimum_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cminimum_entry() //  []
         { info_tbl: [(c75da,
                       label: Data.Functor.Const.$fFoldableConst_$cminimum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75da: // global
           R2 = Data.Functor.Const.$fFoldableConst1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.507591538 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst4_bytes" {
     Data.Functor.Const.$fFoldableConst4_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.508374834 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst3_closure" {
     Data.Functor.Const.$fFoldableConst3_closure:
         const Data.Functor.Const.$fFoldableConst3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst3_entry() //  [R1]
         { info_tbl: [(c75dj,
                       label: Data.Functor.Const.$fFoldableConst3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75dj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75dk; else goto c75dl;
       c75dk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75dl: // global
           (_c75dg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c75dg::I64 == 0) goto c75di; else goto c75dh;
       c75di: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c75dh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c75dg::I64;
           R2 = Data.Functor.Const.$fFoldableConst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.509474751 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cmaximum_closure" {
     Data.Functor.Const.$fFoldableConst_$cmaximum_closure:
         const Data.Functor.Const.$fFoldableConst_$cmaximum_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cmaximum_entry() //  []
         { info_tbl: [(c75dq,
                       label: Data.Functor.Const.$fFoldableConst_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75dq: // global
           R2 = Data.Functor.Const.$fFoldableConst3_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.510409508 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$celem_closure" {
     Data.Functor.Const.$fFoldableConst_$celem_closure:
         const Data.Functor.Const.$fFoldableConst_$celem_info;
 },
 Data.Functor.Const.$fFoldableConst_$celem_entry() //  []
         { info_tbl: [(c75dx,
                       label: Data.Functor.Const.$fFoldableConst_$celem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75dx: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.511273949 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldl_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldl_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldl_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldl_entry() //  [R3]
         { info_tbl: [(c75dE,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75dE: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.512062629 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst7_bytes" {
     Data.Functor.Const.$fFoldableConst7_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.512865023 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst6_closure" {
     Data.Functor.Const.$fFoldableConst6_closure:
         const Data.Functor.Const.$fFoldableConst6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst6_entry() //  [R1]
         { info_tbl: [(c75dN,
                       label: Data.Functor.Const.$fFoldableConst6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75dN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75dO; else goto c75dP;
       c75dO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75dP: // global
           (_c75dK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c75dK::I64 == 0) goto c75dM; else goto c75dL;
       c75dM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c75dL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c75dK::I64;
           R2 = Data.Functor.Const.$fFoldableConst7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.514222849 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldl1_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldl1_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldl1_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldl1_entry() //  []
         { info_tbl: [(c75dU,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75dU: // global
           R2 = Data.Functor.Const.$fFoldableConst6_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.515148384 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldr'_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldr'_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldr'_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldr'_entry() //  [R3]
         { info_tbl: [(c75e1,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75e1: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.515979696 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$clength_closure" {
     Data.Functor.Const.$fFoldableConst_$clength_closure:
         const Data.Functor.Const.$fFoldableConst_$clength_info;
 },
 Data.Functor.Const.$fFoldableConst_$clength_entry() //  []
         { info_tbl: [(c75e8,
                       label: Data.Functor.Const.$fFoldableConst_$clength_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75e8: // global
           R1 = Data.Functor.Const.$fFoldableConst5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.516753973 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst9_bytes" {
     Data.Functor.Const.$fFoldableConst9_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.517577193 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst8_closure" {
     Data.Functor.Const.$fFoldableConst8_closure:
         const Data.Functor.Const.$fFoldableConst8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst8_entry() //  [R1]
         { info_tbl: [(c75eh,
                       label: Data.Functor.Const.$fFoldableConst8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75eh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75ei; else goto c75ej;
       c75ei: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75ej: // global
           (_c75ee::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c75ee::I64 == 0) goto c75eg; else goto c75ef;
       c75eg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c75ef: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c75ee::I64;
           R2 = Data.Functor.Const.$fFoldableConst9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.518755728 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldr1_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldr1_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldr1_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldr1_entry() //  []
         { info_tbl: [(c75eo,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75eo: // global
           R2 = Data.Functor.Const.$fFoldableConst8_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.519666314 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cnull_closure" {
     Data.Functor.Const.$fFoldableConst_$cnull_closure:
         const Data.Functor.Const.$fFoldableConst_$cnull_info;
 },
 Data.Functor.Const.$fFoldableConst_$cnull_entry() //  []
         { info_tbl: [(c75ev,
                       label: Data.Functor.Const.$fFoldableConst_$cnull_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ev: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.520618873 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cproduct_closure" {
     Data.Functor.Const.$fFoldableConst_$cproduct_closure:
         const Data.Functor.Const.$fFoldableConst_$cproduct_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cproduct_entry() //  [R2]
         { info_tbl: [(c75eC,
                       label: Data.Functor.Const.$fFoldableConst_$cproduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75eC: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fMonoidProduct2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.52162569 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$ctoList_closure" {
     Data.Functor.Const.$fFoldableConst_$ctoList_closure:
         const Data.Functor.Const.$fFoldableConst_$ctoList_info;
 },
 Data.Functor.Const.$fFoldableConst_$ctoList_entry() //  []
         { info_tbl: [(c75eJ,
                       label: Data.Functor.Const.$fFoldableConst_$ctoList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75eJ: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.52244731 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_closure" {
     Data.Functor.Const.$fFoldableConst_closure:
         const Data.Foldable.C:Foldable_con_info;
         const Data.Functor.Const.$fFoldableConst_$cfold_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cfoldMap_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldr'_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldr'_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldl_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldl_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldr1_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cfoldl1_closure+2;
         const Data.Functor.Const.$fFoldableConst_$ctoList_closure+1;
         const Data.Functor.Const.$fFoldableConst_$cnull_closure+1;
         const Data.Functor.Const.$fFoldableConst_$clength_closure+1;
         const Data.Functor.Const.$fFoldableConst_$celem_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cmaximum_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cminimum_closure+2;
         const Data.Functor.Const.$fFoldableConst_$csum_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cproduct_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.523453415 UTC

[section ""data" . Data.Functor.Const.$fFunctorConst2_closure" {
     Data.Functor.Const.$fFunctorConst2_closure:
         const Data.Functor.Const.$fFunctorConst2_info;
 },
 Data.Functor.Const.$fFunctorConst2_entry() //  [R3]
         { info_tbl: [(c75eQ,
                       label: Data.Functor.Const.$fFunctorConst2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75eQ: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.525618836 UTC

[section ""data" . Data.Functor.Const.$fFunctorConst1_closure" {
     Data.Functor.Const.$fFunctorConst1_closure:
         const Data.Functor.Const.$fFunctorConst1_info;
 },
 Data.Functor.Const.$fFunctorConst1_entry() //  [R3]
         { info_tbl: [(c75eX,
                       label: Data.Functor.Const.$fFunctorConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75eX: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.526348702 UTC

[section ""data" . Data.Functor.Const.$fFunctorConst_closure" {
     Data.Functor.Const.$fFunctorConst_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Const.$fFunctorConst2_closure+2;
         const Data.Functor.Const.$fFunctorConst1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.527986693 UTC

[section ""data" . Data.Functor.Const.$fApplicativeConst_closure" {
     Data.Functor.Const.$fApplicativeConst_closure:
         const Data.Functor.Const.$fApplicativeConst_info;
         const 0;
 },
 lvl_s7522_entry() //  [R1]
         { info_tbl: [(c75f8,
                       label: lvl_s7522_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75f8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75f9; else goto c75fa;
       c75f9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75fa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752f_entry() //  [R1, R2, R3]
         { info_tbl: [(c75fg,
                       label: sat_s752f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75fg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c75fh; else goto c75fi;
       c75fh: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c75fi: // global
           _s752d::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s752d::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s752c_entry() //  [R1, R2, R3]
         { info_tbl: [(c75fo,
                       label: sat_s752c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75fo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c75fp; else goto c75fq;
       c75fp: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c75fq: // global
           _s752a::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s752a::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7529_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c75fw,
                       label: sat_s7529_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75fw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c75fx; else goto c75fy;
       c75fx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c75fy: // global
           R2 = P64[R1 + 5];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7525_entry() //  [R1]
         { info_tbl: [(c75fD,
                       label: sat_s7525_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75fD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75fE; else goto c75fF;
       c75fE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75fF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7524_entry() //  [R1]
         { info_tbl: [(c75fL,
                       label: sat_s7524_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75fL: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fApplicativeConst_entry() //  [R2]
         { info_tbl: [(c75fP,
                       label: Data.Functor.Const.$fApplicativeConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75fP: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c75fT; else goto c75fS;
       c75fT: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Functor.Const.$fApplicativeConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75fS: // global
           I64[Hp - 160] = lvl_s7522_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s752f_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s752c_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s7529_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s7525_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s7524_info;
           P64[Hp - 56] = Hp - 160;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Data.Functor.Const.$fFunctorConst_closure+1;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 101;
           P64[Hp - 8] = Hp - 118;
           P64[Hp] = Hp - 134;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.531977323 UTC

[section ""data" . Data.Functor.Const.$fStorableConst_closure" {
     Data.Functor.Const.$fStorableConst_closure:
         const Data.Functor.Const.$fStorableConst_info;
 },
 sat_s752o_entry() //  [R1]
         { info_tbl: [(c75g2,
                       label: sat_s752o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75g2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75g3; else goto c75g4;
       c75g3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75g4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752n_entry() //  [R1]
         { info_tbl: [(c75g9,
                       label: sat_s752n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75g9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75ga; else goto c75gb;
       c75ga: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75gb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752m_entry() //  [R1]
         { info_tbl: [(c75gg,
                       label: sat_s752m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75gg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75gh; else goto c75gi;
       c75gh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75gi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752l_entry() //  [R1]
         { info_tbl: [(c75gn,
                       label: sat_s752l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75gn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75go; else goto c75gp;
       c75go: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75gp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752k_entry() //  [R1]
         { info_tbl: [(c75gu,
                       label: sat_s752k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75gu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75gv; else goto c75gw;
       c75gv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75gw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752j_entry() //  [R1]
         { info_tbl: [(c75gB,
                       label: sat_s752j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75gB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75gC; else goto c75gD;
       c75gC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75gD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752i_entry() //  [R1]
         { info_tbl: [(c75gI,
                       label: sat_s752i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75gI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75gJ; else goto c75gK;
       c75gJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75gK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.alignment_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752h_entry() //  [R1]
         { info_tbl: [(c75gP,
                       label: sat_s752h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75gP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75gQ; else goto c75gR;
       c75gQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75gR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fStorableConst_entry() //  [R2]
         { info_tbl: [(c75gT,
                       label: Data.Functor.Const.$fStorableConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75gT: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c75gX; else goto c75gW;
       c75gX: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Const.$fStorableConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75gW: // global
           I64[Hp - 256] = sat_s752o_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s752n_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s752m_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s752l_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s752k_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s752j_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s752i_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s752h_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.535980095 UTC

[section ""data" . Data.Functor.Const.$fNumConst_closure" {
     Data.Functor.Const.$fNumConst_closure:
         const Data.Functor.Const.$fNumConst_info;
 },
 sat_s752w_entry() //  [R1]
         { info_tbl: [(c75h6,
                       label: sat_s752w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75h6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75h7; else goto c75h8;
       c75h7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75h8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752v_entry() //  [R1]
         { info_tbl: [(c75hd,
                       label: sat_s752v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75hd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75he; else goto c75hf;
       c75he: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75hf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752u_entry() //  [R1]
         { info_tbl: [(c75hk,
                       label: sat_s752u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75hk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75hl; else goto c75hm;
       c75hl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75hm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752t_entry() //  [R1]
         { info_tbl: [(c75hr,
                       label: sat_s752t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75hr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75hs; else goto c75ht;
       c75hs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75ht: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752s_entry() //  [R1]
         { info_tbl: [(c75hy,
                       label: sat_s752s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75hy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75hz; else goto c75hA;
       c75hz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75hA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752r_entry() //  [R1]
         { info_tbl: [(c75hF,
                       label: sat_s752r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75hF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75hG; else goto c75hH;
       c75hG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75hH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752q_entry() //  [R1]
         { info_tbl: [(c75hM,
                       label: sat_s752q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75hM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75hN; else goto c75hO;
       c75hN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75hO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fNumConst_entry() //  [R2]
         { info_tbl: [(c75hQ,
                       label: Data.Functor.Const.$fNumConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75hQ: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c75hU; else goto c75hT;
       c75hU: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Const.$fNumConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75hT: // global
           I64[Hp - 224] = sat_s752w_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s752v_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s752u_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s752t_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s752s_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s752r_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s752q_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.539008969 UTC

[section ""data" . Data.Functor.Const.$fRealConst_$cp1Real_closure" {
     Data.Functor.Const.$fRealConst_$cp1Real_closure:
         const Data.Functor.Const.$fRealConst_$cp1Real_info;
 },
 sat_s752y_entry() //  [R1]
         { info_tbl: [(c75i3,
                       label: sat_s752y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75i3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75i4; else goto c75i5;
       c75i4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75i5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealConst_$cp1Real_entry() //  [R2]
         { info_tbl: [(c75i6,
                       label: Data.Functor.Const.$fRealConst_$cp1Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75i6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75ia; else goto c75i9;
       c75ia: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealConst_$cp1Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75i9: // global
           I64[Hp - 16] = sat_s752y_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fNumConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.540683074 UTC

[section ""data" . Data.Functor.Const.$fSemigroupConst_closure" {
     Data.Functor.Const.$fSemigroupConst_closure:
         const Data.Functor.Const.$fSemigroupConst_info;
 },
 sat_s752D_entry() //  [R1, R2]
         { info_tbl: [(c75ik,
                       label: sat_s752D_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ik: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75il; else goto c75im;
       c75il: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75im: // global
           _s752C::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s752C::P64;
           Sp = Sp - 16;
           call GHC.Base.stimes_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s752B_entry() //  [R1]
         { info_tbl: [(c75ir,
                       label: sat_s752B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ir: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75is; else goto c75it;
       c75is: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75it: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.sconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752A_entry() //  [R1]
         { info_tbl: [(c75iy,
                       label: sat_s752A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75iy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75iz; else goto c75iA;
       c75iz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75iA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fSemigroupConst_entry() //  [R2]
         { info_tbl: [(c75iC,
                       label: Data.Functor.Const.$fSemigroupConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75iC: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c75iG; else goto c75iF;
       c75iG: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = Data.Functor.Const.$fSemigroupConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75iF: // global
           I64[Hp - 88] = sat_s752D_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s752B_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s752A_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 87;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.542672722 UTC

[section ""data" . Data.Functor.Const.$fMonoidConst_$cp1Monoid_closure" {
     Data.Functor.Const.$fMonoidConst_$cp1Monoid_closure:
         const Data.Functor.Const.$fMonoidConst_$cp1Monoid_info;
 },
 sat_s752F_entry() //  [R1]
         { info_tbl: [(c75iP,
                       label: sat_s752F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75iP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75iQ; else goto c75iR;
       c75iQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75iR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fMonoidConst_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(c75iS,
                       label: Data.Functor.Const.$fMonoidConst_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75iS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75iW; else goto c75iV;
       c75iW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fMonoidConst_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75iV: // global
           I64[Hp - 16] = sat_s752F_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fSemigroupConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.544504454 UTC

[section ""data" . Data.Functor.Const.$fMonoidConst_closure" {
     Data.Functor.Const.$fMonoidConst_closure:
         const Data.Functor.Const.$fMonoidConst_info;
 },
 sat_s752K_entry() //  [R1]
         { info_tbl: [(c75j5,
                       label: sat_s752K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75j5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75j6; else goto c75j7;
       c75j6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75j7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752J_entry() //  [R1]
         { info_tbl: [(c75jc,
                       label: sat_s752J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75jc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75jd; else goto c75je;
       c75jd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75je: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752I_entry() //  [R1]
         { info_tbl: [(c75jj,
                       label: sat_s752I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75jj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75jk; else goto c75jl;
       c75jk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75jl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752H_entry() //  [R1]
         { info_tbl: [(c75jq,
                       label: sat_s752H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75jq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75jr; else goto c75js;
       c75jr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75js: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fMonoidConst_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fMonoidConst_entry() //  [R2]
         { info_tbl: [(c75ju,
                       label: Data.Functor.Const.$fMonoidConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ju: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c75jy; else goto c75jx;
       c75jy: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fMonoidConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75jx: // global
           I64[Hp - 128] = sat_s752K_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s752J_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s752I_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s752H_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.546638093 UTC

[section ""data" . Data.Functor.Const.$fGeneric1Const1_closure" {
     Data.Functor.Const.$fGeneric1Const1_closure:
         const Data.Functor.Const.$fGeneric1Const1_info;
 },
 Data.Functor.Const.$fGeneric1Const1_entry() //  [R2]
         { info_tbl: [(c75jD,
                       label: Data.Functor.Const.$fGeneric1Const1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75jD: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.547530691 UTC

[section ""data" . Data.Functor.Const.$fGeneric1Const2_closure" {
     Data.Functor.Const.$fGeneric1Const2_closure:
         const Data.Functor.Const.$fGeneric1Const2_info;
 },
 Data.Functor.Const.$fGeneric1Const2_entry() //  [R2]
         { info_tbl: [(c75jK,
                       label: Data.Functor.Const.$fGeneric1Const2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75jK: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.548334036 UTC

[section ""data" . Data.Functor.Const.$fGeneric1Const_closure" {
     Data.Functor.Const.$fGeneric1Const_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Const.$fGeneric1Const2_closure+1;
         const Data.Functor.Const.$fGeneric1Const1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.549111782 UTC

[section ""data" . Data.Functor.Const.$fGenericConst1_closure" {
     Data.Functor.Const.$fGenericConst1_closure:
         const Data.Functor.Const.$fGenericConst1_info;
 },
 Data.Functor.Const.$fGenericConst1_entry() //  [R2]
         { info_tbl: [(c75jR,
                       label: Data.Functor.Const.$fGenericConst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75jR: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.550532062 UTC

[section ""data" . Data.Functor.Const.$fGenericConst2_closure" {
     Data.Functor.Const.$fGenericConst2_closure:
         const Data.Functor.Const.$fGenericConst2_info;
 },
 Data.Functor.Const.$fGenericConst2_entry() //  [R2]
         { info_tbl: [(c75jY,
                       label: Data.Functor.Const.$fGenericConst2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75jY: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.551284349 UTC

[section ""data" . Data.Functor.Const.$fGenericConst_closure" {
     Data.Functor.Const.$fGenericConst_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Const.$fGenericConst2_closure+1;
         const Data.Functor.Const.$fGenericConst1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.552230945 UTC

[section ""data" . Data.Functor.Const.$fFractionalConst_$cp1Fractional_closure" {
     Data.Functor.Const.$fFractionalConst_$cp1Fractional_closure:
         const Data.Functor.Const.$fFractionalConst_$cp1Fractional_info;
 },
 sat_s752Q_entry() //  [R1]
         { info_tbl: [(c75k9,
                       label: sat_s752Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75k9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75ka; else goto c75kb;
       c75ka: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75kb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFractionalConst_$cp1Fractional_entry() //  [R2]
         { info_tbl: [(c75kc,
                       label: Data.Functor.Const.$fFractionalConst_$cp1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75kc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75kg; else goto c75kf;
       c75kg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fFractionalConst_$cp1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75kf: // global
           I64[Hp - 16] = sat_s752Q_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fNumConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.55401802 UTC

[section ""data" . Data.Functor.Const.$fFractionalConst_closure" {
     Data.Functor.Const.$fFractionalConst_closure:
         const Data.Functor.Const.$fFractionalConst_info;
 },
 sat_s752V_entry() //  [R1]
         { info_tbl: [(c75kp,
                       label: sat_s752V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75kp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75kq; else goto c75kr;
       c75kq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75kr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.fromRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752U_entry() //  [R1]
         { info_tbl: [(c75kw,
                       label: sat_s752U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75kw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75kx; else goto c75ky;
       c75kx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75ky: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752T_entry() //  [R1]
         { info_tbl: [(c75kD,
                       label: sat_s752T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75kD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75kE; else goto c75kF;
       c75kE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75kF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real./_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752S_entry() //  [R1]
         { info_tbl: [(c75kK,
                       label: sat_s752S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75kK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75kL; else goto c75kM;
       c75kL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75kM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fFractionalConst_$cp1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFractionalConst_entry() //  [R2]
         { info_tbl: [(c75kO,
                       label: Data.Functor.Const.$fFractionalConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75kO: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c75kS; else goto c75kR;
       c75kS: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fFractionalConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75kR: // global
           I64[Hp - 128] = sat_s752V_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s752U_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s752T_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s752S_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.556183421 UTC

[section ""data" . Data.Functor.Const.$fRealFracConst_$cp2RealFrac_closure" {
     Data.Functor.Const.$fRealFracConst_$cp2RealFrac_closure:
         const Data.Functor.Const.$fRealFracConst_$cp2RealFrac_info;
 },
 sat_s752X_entry() //  [R1]
         { info_tbl: [(c75l1,
                       label: sat_s752X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75l1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75l2; else goto c75l3;
       c75l2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75l3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFracConst_$cp2RealFrac_entry() //  [R2]
         { info_tbl: [(c75l4,
                       label: Data.Functor.Const.$fRealFracConst_$cp2RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75l4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75l8; else goto c75l7;
       c75l8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFracConst_$cp2RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75l7: // global
           I64[Hp - 16] = sat_s752X_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fFractionalConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.557643981 UTC

[section ""data" . Data.Functor.Const.$fFloatingConst_$cp1Floating_closure" {
     Data.Functor.Const.$fFloatingConst_$cp1Floating_closure:
         const Data.Functor.Const.$fFloatingConst_$cp1Floating_info;
 },
 sat_s752Z_entry() //  [R1]
         { info_tbl: [(c75lh,
                       label: sat_s752Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75lh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75li; else goto c75lj;
       c75li: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75lj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFloatingConst_$cp1Floating_entry() //  [R2]
         { info_tbl: [(c75lk,
                       label: Data.Functor.Const.$fFloatingConst_$cp1Floating_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75lk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75lo; else goto c75ln;
       c75lo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fFloatingConst_$cp1Floating_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75ln: // global
           I64[Hp - 16] = sat_s752Z_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fFractionalConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.562488318 UTC

[section ""data" . Data.Functor.Const.$fFloatingConst_closure" {
     Data.Functor.Const.$fFloatingConst_closure:
         const Data.Functor.Const.$fFloatingConst_info;
 },
 sat_s753n_entry() //  [R1]
         { info_tbl: [(c75lx,
                       label: sat_s753n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75lx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75ly; else goto c75lz;
       c75ly: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75lz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1mexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753m_entry() //  [R1]
         { info_tbl: [(c75lE,
                       label: sat_s753m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75lE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75lF; else goto c75lG;
       c75lF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75lG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1pexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753l_entry() //  [R1]
         { info_tbl: [(c75lL,
                       label: sat_s753l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75lL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75lM; else goto c75lN;
       c75lM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75lN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.expm1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753k_entry() //  [R1]
         { info_tbl: [(c75lS,
                       label: sat_s753k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75lS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75lT; else goto c75lU;
       c75lT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75lU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1p_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753j_entry() //  [R1]
         { info_tbl: [(c75lZ,
                       label: sat_s753j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75lZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75m0; else goto c75m1;
       c75m0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75m1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753i_entry() //  [R1]
         { info_tbl: [(c75m6,
                       label: sat_s753i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75m6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75m7; else goto c75m8;
       c75m7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75m8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753h_entry() //  [R1]
         { info_tbl: [(c75md,
                       label: sat_s753h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75md: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75me; else goto c75mf;
       c75me: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75mf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753g_entry() //  [R1]
         { info_tbl: [(c75mk,
                       label: sat_s753g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75mk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75ml; else goto c75mm;
       c75ml: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75mm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753f_entry() //  [R1]
         { info_tbl: [(c75mr,
                       label: sat_s753f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75mr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75ms; else goto c75mt;
       c75ms: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75mt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753e_entry() //  [R1]
         { info_tbl: [(c75my,
                       label: sat_s753e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75my: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75mz; else goto c75mA;
       c75mz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75mA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753d_entry() //  [R1]
         { info_tbl: [(c75mF,
                       label: sat_s753d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75mF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75mG; else goto c75mH;
       c75mG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75mH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753c_entry() //  [R1]
         { info_tbl: [(c75mM,
                       label: sat_s753c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75mM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75mN; else goto c75mO;
       c75mN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75mO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753b_entry() //  [R1]
         { info_tbl: [(c75mT,
                       label: sat_s753b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75mT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75mU; else goto c75mV;
       c75mU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75mV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753a_entry() //  [R1]
         { info_tbl: [(c75n0,
                       label: sat_s753a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75n0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75n1; else goto c75n2;
       c75n1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75n2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7539_entry() //  [R1]
         { info_tbl: [(c75n7,
                       label: sat_s7539_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75n7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75n8; else goto c75n9;
       c75n8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75n9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7538_entry() //  [R1]
         { info_tbl: [(c75ne,
                       label: sat_s7538_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ne: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75nf; else goto c75ng;
       c75nf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75ng: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7537_entry() //  [R1]
         { info_tbl: [(c75nl,
                       label: sat_s7537_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75nl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75nm; else goto c75nn;
       c75nm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75nn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.logBase_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7536_entry() //  [R1]
         { info_tbl: [(c75ns,
                       label: sat_s7536_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ns: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75nt; else goto c75nu;
       c75nt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75nu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.**_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7535_entry() //  [R1]
         { info_tbl: [(c75nz,
                       label: sat_s7535_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75nz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75nA; else goto c75nB;
       c75nA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75nB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sqrt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7534_entry() //  [R1]
         { info_tbl: [(c75nG,
                       label: sat_s7534_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75nG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75nH; else goto c75nI;
       c75nH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75nI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7533_entry() //  [R1]
         { info_tbl: [(c75nN,
                       label: sat_s7533_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75nN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75nO; else goto c75nP;
       c75nO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75nP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7532_entry() //  [R1]
         { info_tbl: [(c75nU,
                       label: sat_s7532_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75nU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75nV; else goto c75nW;
       c75nV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75nW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.pi_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7531_entry() //  [R1]
         { info_tbl: [(c75o1,
                       label: sat_s7531_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75o1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75o2; else goto c75o3;
       c75o2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75o3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fFloatingConst_$cp1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFloatingConst_entry() //  [R2]
         { info_tbl: [(c75o5,
                       label: Data.Functor.Const.$fFloatingConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75o5: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto c75o9; else goto c75o8;
       c75o9: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Const.$fFloatingConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75o8: // global
           I64[Hp - 736] = sat_s753n_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_s753m_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_s753l_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_s753k_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_s753j_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_s753i_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_s753h_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_s753g_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_s753f_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_s753e_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_s753d_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_s753c_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_s753b_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_s753a_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_s7539_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_s7538_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_s7537_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_s7536_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_s7535_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_s7534_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_s7533_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s7532_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s7531_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = GHC.Float.C:Floating_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.569982461 UTC

[section ""data" . Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_closure" {
     Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_closure:
         const Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_info;
 },
 sat_s753p_entry() //  [R1]
         { info_tbl: [(c75oi,
                       label: sat_s753p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75oi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75oj; else goto c75ok;
       c75oj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75ok: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_entry() //  [R2]
         { info_tbl: [(c75ol,
                       label: Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ol: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75op; else goto c75oo;
       c75op: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75oo: // global
           I64[Hp - 16] = sat_s753p_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fFloatingConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.571593127 UTC

[section ""data" . Data.Functor.Const.$fEqConst_closure" {
     Data.Functor.Const.$fEqConst_closure:
         const Data.Functor.Const.$fEqConst_info;
 },
 sat_s753s_entry() //  [R1]
         { info_tbl: [(c75oy,
                       label: sat_s753s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75oy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75oz; else goto c75oA;
       c75oz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75oA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753r_entry() //  [R1]
         { info_tbl: [(c75oF,
                       label: sat_s753r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75oF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75oG; else goto c75oH;
       c75oG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75oH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fEqConst_entry() //  [R2]
         { info_tbl: [(c75oJ,
                       label: Data.Functor.Const.$fEqConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75oJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c75oN; else goto c75oM;
       c75oN: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Const.$fEqConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75oM: // global
           I64[Hp - 64] = sat_s753s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s753r_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.573330301 UTC

[section ""data" . Data.Functor.Const.$fOrdConst_$cp1Ord_closure" {
     Data.Functor.Const.$fOrdConst_$cp1Ord_closure:
         const Data.Functor.Const.$fOrdConst_$cp1Ord_info;
 },
 sat_s753u_entry() //  [R1]
         { info_tbl: [(c75oW,
                       label: sat_s753u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75oW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75oX; else goto c75oY;
       c75oX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75oY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fOrdConst_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c75oZ,
                       label: Data.Functor.Const.$fOrdConst_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75oZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75p3; else goto c75p2;
       c75p3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fOrdConst_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75p2: // global
           I64[Hp - 16] = sat_s753u_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fEqConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.575608967 UTC

[section ""data" . Data.Functor.Const.$fOrdConst_closure" {
     Data.Functor.Const.$fOrdConst_closure:
         const Data.Functor.Const.$fOrdConst_info;
 },
 sat_s753D_entry() //  [R1]
         { info_tbl: [(c75pc,
                       label: sat_s753D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75pc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75pd; else goto c75pe;
       c75pd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75pe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753C_entry() //  [R1]
         { info_tbl: [(c75pj,
                       label: sat_s753C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75pj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75pk; else goto c75pl;
       c75pk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75pl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753B_entry() //  [R1]
         { info_tbl: [(c75pq,
                       label: sat_s753B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75pq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75pr; else goto c75ps;
       c75pr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75ps: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753A_entry() //  [R1]
         { info_tbl: [(c75px,
                       label: sat_s753A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75px: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75py; else goto c75pz;
       c75py: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75pz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753z_entry() //  [R1]
         { info_tbl: [(c75pE,
                       label: sat_s753z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75pE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75pF; else goto c75pG;
       c75pF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75pG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753y_entry() //  [R1]
         { info_tbl: [(c75pL,
                       label: sat_s753y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75pL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75pM; else goto c75pN;
       c75pM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75pN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753x_entry() //  [R1]
         { info_tbl: [(c75pS,
                       label: sat_s753x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75pS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75pT; else goto c75pU;
       c75pT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75pU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753w_entry() //  [R1]
         { info_tbl: [(c75pZ,
                       label: sat_s753w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75pZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75q0; else goto c75q1;
       c75q0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75q1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fOrdConst_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fOrdConst_entry() //  [R2]
         { info_tbl: [(c75q3,
                       label: Data.Functor.Const.$fOrdConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75q3: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c75q7; else goto c75q6;
       c75q7: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Const.$fOrdConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75q6: // global
           I64[Hp - 256] = sat_s753D_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s753C_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s753B_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s753A_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s753z_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s753y_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s753x_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s753w_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.578998261 UTC

[section ""data" . Data.Functor.Const.$fIxConst_$cp1Ix_closure" {
     Data.Functor.Const.$fIxConst_$cp1Ix_closure:
         const Data.Functor.Const.$fIxConst_$cp1Ix_info;
 },
 sat_s753F_entry() //  [R1]
         { info_tbl: [(c75qg,
                       label: sat_s753F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75qg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75qh; else goto c75qi;
       c75qh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75qi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.$p1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIxConst_$cp1Ix_entry() //  [R2]
         { info_tbl: [(c75qj,
                       label: Data.Functor.Const.$fIxConst_$cp1Ix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75qj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75qn; else goto c75qm;
       c75qn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fIxConst_$cp1Ix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75qm: // global
           I64[Hp - 16] = sat_s753F_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fOrdConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.581271697 UTC

[section ""data" . Data.Functor.Const.$fIxConst_closure" {
     Data.Functor.Const.$fIxConst_closure:
         const Data.Functor.Const.$fIxConst_info;
 },
 sat_s753N_entry() //  [R1]
         { info_tbl: [(c75qw,
                       label: sat_s753N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75qw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75qx; else goto c75qy;
       c75qx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75qy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeRangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753M_entry() //  [R1]
         { info_tbl: [(c75qD,
                       label: sat_s753M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75qD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75qE; else goto c75qF;
       c75qE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75qF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.rangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753L_entry() //  [R1]
         { info_tbl: [(c75qK,
                       label: sat_s753L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75qK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75qL; else goto c75qM;
       c75qL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75qM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.inRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753K_entry() //  [R1]
         { info_tbl: [(c75qR,
                       label: sat_s753K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75qR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75qS; else goto c75qT;
       c75qS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75qT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeIndex_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753J_entry() //  [R1]
         { info_tbl: [(c75qY,
                       label: sat_s753J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75qY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75qZ; else goto c75r0;
       c75qZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75r0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.index_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753I_entry() //  [R1]
         { info_tbl: [(c75r5,
                       label: sat_s753I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75r5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75r6; else goto c75r7;
       c75r6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75r7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.range_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753H_entry() //  [R1]
         { info_tbl: [(c75rc,
                       label: sat_s753H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75rc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75rd; else goto c75re;
       c75rd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75re: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fIxConst_$cp1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIxConst_entry() //  [R2]
         { info_tbl: [(c75rg,
                       label: Data.Functor.Const.$fIxConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75rg: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c75rk; else goto c75rj;
       c75rk: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Const.$fIxConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75rj: // global
           I64[Hp - 224] = sat_s753N_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s753M_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s753L_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s753K_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s753J_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s753I_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s753H_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Arr.C:Ix_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.58435384 UTC

[section ""data" . Data.Functor.Const.$fRealConst_$cp2Real_closure" {
     Data.Functor.Const.$fRealConst_$cp2Real_closure:
         const Data.Functor.Const.$fRealConst_$cp2Real_info;
 },
 sat_s753P_entry() //  [R1]
         { info_tbl: [(c75rt,
                       label: sat_s753P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75rt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75ru; else goto c75rv;
       c75ru: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75rv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealConst_$cp2Real_entry() //  [R2]
         { info_tbl: [(c75rw,
                       label: Data.Functor.Const.$fRealConst_$cp2Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75rw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75rA; else goto c75rz;
       c75rA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealConst_$cp2Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75rz: // global
           I64[Hp - 16] = sat_s753P_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fOrdConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.586038387 UTC

[section ""data" . Data.Functor.Const.$fRealConst_closure" {
     Data.Functor.Const.$fRealConst_closure:
         const Data.Functor.Const.$fRealConst_info;
 },
 sat_s753T_entry() //  [R1]
         { info_tbl: [(c75rJ,
                       label: sat_s753T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75rJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75rK; else goto c75rL;
       c75rK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75rL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753S_entry() //  [R1]
         { info_tbl: [(c75rQ,
                       label: sat_s753S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75rQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75rR; else goto c75rS;
       c75rR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75rS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealConst_$cp2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753R_entry() //  [R1]
         { info_tbl: [(c75rX,
                       label: sat_s753R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75rX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75rY; else goto c75rZ;
       c75rY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75rZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealConst_$cp1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealConst_entry() //  [R2]
         { info_tbl: [(c75s1,
                       label: Data.Functor.Const.$fRealConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75s1: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c75s5; else goto c75s4;
       c75s5: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75s4: // global
           I64[Hp - 96] = sat_s753T_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s753S_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s753R_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.588063758 UTC

[section ""data" . Data.Functor.Const.$fIntegralConst_$cp1Integral_closure" {
     Data.Functor.Const.$fIntegralConst_$cp1Integral_closure:
         const Data.Functor.Const.$fIntegralConst_$cp1Integral_info;
 },
 sat_s753V_entry() //  [R1]
         { info_tbl: [(c75se,
                       label: sat_s753V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75se: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75sf; else goto c75sg;
       c75sf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75sg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIntegralConst_$cp1Integral_entry() //  [R2]
         { info_tbl: [(c75sh,
                       label: Data.Functor.Const.$fIntegralConst_$cp1Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75sh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75sl; else goto c75sk;
       c75sl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fIntegralConst_$cp1Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75sk: // global
           I64[Hp - 16] = sat_s753V_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fRealConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.589637238 UTC

[section ""data" . Data.Functor.Const.$fRealFracConst_$cp1RealFrac_closure" {
     Data.Functor.Const.$fRealFracConst_$cp1RealFrac_closure:
         const Data.Functor.Const.$fRealFracConst_$cp1RealFrac_info;
 },
 sat_s753X_entry() //  [R1]
         { info_tbl: [(c75su,
                       label: sat_s753X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75su: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75sv; else goto c75sw;
       c75sv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75sw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFracConst_$cp1RealFrac_entry() //  [R2]
         { info_tbl: [(c75sx,
                       label: Data.Functor.Const.$fRealFracConst_$cp1RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75sx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75sB; else goto c75sA;
       c75sB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFracConst_$cp1RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75sA: // global
           I64[Hp - 16] = sat_s753X_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fRealConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.59199623 UTC

[section ""data" . Data.Functor.Const.$fRealFracConst_closure" {
     Data.Functor.Const.$fRealFracConst_closure:
         const Data.Functor.Const.$fRealFracConst_info;
 },
 sat_s754a_entry() //  [R1, R2]
         { info_tbl: [(c75sL,
                       label: sat_s754a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75sL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75sM; else goto c75sN;
       c75sM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75sN: // global
           _s7549::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7549::P64;
           Sp = Sp - 16;
           call GHC.Real.floor_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7548_entry() //  [R1, R2]
         { info_tbl: [(c75sT,
                       label: sat_s7548_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75sT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75sU; else goto c75sV;
       c75sU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75sV: // global
           _s7547::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7547::P64;
           Sp = Sp - 16;
           call GHC.Real.ceiling_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7546_entry() //  [R1, R2]
         { info_tbl: [(c75t1,
                       label: sat_s7546_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75t1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75t2; else goto c75t3;
       c75t2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75t3: // global
           _s7545::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7545::P64;
           Sp = Sp - 16;
           call GHC.Real.round_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7544_entry() //  [R1, R2]
         { info_tbl: [(c75t9,
                       label: sat_s7544_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75t9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75ta; else goto c75tb;
       c75ta: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75tb: // global
           _s7543::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7543::P64;
           Sp = Sp - 16;
           call GHC.Real.truncate_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7542_entry() //  [R1, R2]
         { info_tbl: [(c75th,
                       label: sat_s7542_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75th: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75ti; else goto c75tj;
       c75ti: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75tj: // global
           _s7541::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7541::P64;
           Sp = Sp - 16;
           call GHC.Real.properFraction_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7540_entry() //  [R1]
         { info_tbl: [(c75to,
                       label: sat_s7540_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75to: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75tp; else goto c75tq;
       c75tp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75tq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFracConst_$cp2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753Z_entry() //  [R1]
         { info_tbl: [(c75tv,
                       label: sat_s753Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75tv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75tw; else goto c75tx;
       c75tw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75tx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFracConst_$cp1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFracConst_entry() //  [R2]
         { info_tbl: [(c75tz,
                       label: Data.Functor.Const.$fRealFracConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75tz: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c75tD; else goto c75tC;
       c75tD: // global
           HpAlloc = 192;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFracConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75tC: // global
           I64[Hp - 184] = sat_s754a_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s7548_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s7546_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s7544_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s7542_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s7540_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s753Z_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 119;
           P64[Hp - 24] = Hp - 135;
           P64[Hp - 16] = Hp - 151;
           P64[Hp - 8] = Hp - 167;
           P64[Hp] = Hp - 183;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.596619119 UTC

[section ""data" . Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_closure" {
     Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_closure:
         const Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_info;
 },
 sat_s754c_entry() //  [R1]
         { info_tbl: [(c75tM,
                       label: sat_s754c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75tM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75tN; else goto c75tO;
       c75tN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75tO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_entry() //  [R2]
         { info_tbl: [(c75tP,
                       label: Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75tP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75tT; else goto c75tS;
       c75tT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75tS: // global
           I64[Hp - 16] = sat_s754c_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fRealFracConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.599809366 UTC

[section ""data" . Data.Functor.Const.$fRealFloatConst_closure" {
     Data.Functor.Const.$fRealFloatConst_closure:
         const Data.Functor.Const.$fRealFloatConst_info;
 },
 sat_s754t_entry() //  [R1]
         { info_tbl: [(c75u2,
                       label: sat_s754t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75u2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75u3; else goto c75u4;
       c75u3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75u4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754s_entry() //  [R1]
         { info_tbl: [(c75u9,
                       label: sat_s754s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75u9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75ua; else goto c75ub;
       c75ua: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75ub: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isIEEE_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754r_entry() //  [R1]
         { info_tbl: [(c75ug,
                       label: sat_s754r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ug: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75uh; else goto c75ui;
       c75uh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75ui: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNegativeZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754q_entry() //  [R1]
         { info_tbl: [(c75un,
                       label: sat_s754q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75un: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75uo; else goto c75up;
       c75uo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75up: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isDenormalized_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754p_entry() //  [R1]
         { info_tbl: [(c75uu,
                       label: sat_s754p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75uu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75uv; else goto c75uw;
       c75uv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75uw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isInfinite_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754o_entry() //  [R1]
         { info_tbl: [(c75uB,
                       label: sat_s754o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75uB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75uC; else goto c75uD;
       c75uC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75uD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNaN_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754n_entry() //  [R1]
         { info_tbl: [(c75uI,
                       label: sat_s754n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75uI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75uJ; else goto c75uK;
       c75uJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75uK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.scaleFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754m_entry() //  [R1]
         { info_tbl: [(c75uP,
                       label: sat_s754m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75uP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75uQ; else goto c75uR;
       c75uQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75uR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.significand_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754l_entry() //  [R1]
         { info_tbl: [(c75uW,
                       label: sat_s754l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75uW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75uX; else goto c75uY;
       c75uX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75uY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exponent_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754k_entry() //  [R1]
         { info_tbl: [(c75v3,
                       label: sat_s754k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75v3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75v4; else goto c75v5;
       c75v4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75v5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.encodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754j_entry() //  [R1]
         { info_tbl: [(c75va,
                       label: sat_s754j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75va: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75vb; else goto c75vc;
       c75vb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75vc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.decodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754i_entry() //  [R1]
         { info_tbl: [(c75vh,
                       label: sat_s754i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75vh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75vi; else goto c75vj;
       c75vi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75vj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754h_entry() //  [R1]
         { info_tbl: [(c75vo,
                       label: sat_s754h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75vo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75vp; else goto c75vq;
       c75vp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75vq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatDigits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754g_entry() //  [R1]
         { info_tbl: [(c75vv,
                       label: sat_s754g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75vv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75vw; else goto c75vx;
       c75vw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75vx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRadix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754f_entry() //  [R1]
         { info_tbl: [(c75vC,
                       label: sat_s754f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75vC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75vD; else goto c75vE;
       c75vD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75vE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754e_entry() //  [R1]
         { info_tbl: [(c75vJ,
                       label: sat_s754e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75vJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75vK; else goto c75vL;
       c75vK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75vL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFloatConst_entry() //  [R2]
         { info_tbl: [(c75vN,
                       label: Data.Functor.Const.$fRealFloatConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75vN: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto c75vR; else goto c75vQ;
       c75vR: // global
           HpAlloc = 520;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFloatConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75vQ: // global
           I64[Hp - 512] = sat_s754t_info;
           P64[Hp - 496] = R2;
           I64[Hp - 488] = sat_s754s_info;
           P64[Hp - 472] = R2;
           I64[Hp - 464] = sat_s754r_info;
           P64[Hp - 448] = R2;
           I64[Hp - 440] = sat_s754q_info;
           P64[Hp - 424] = R2;
           I64[Hp - 416] = sat_s754p_info;
           P64[Hp - 400] = R2;
           I64[Hp - 392] = sat_s754o_info;
           P64[Hp - 376] = R2;
           I64[Hp - 368] = sat_s754n_info;
           P64[Hp - 352] = R2;
           I64[Hp - 344] = sat_s754m_info;
           P64[Hp - 328] = R2;
           I64[Hp - 320] = sat_s754l_info;
           P64[Hp - 304] = R2;
           I64[Hp - 296] = sat_s754k_info;
           P64[Hp - 280] = R2;
           I64[Hp - 272] = sat_s754j_info;
           P64[Hp - 256] = R2;
           I64[Hp - 248] = sat_s754i_info;
           P64[Hp - 232] = R2;
           I64[Hp - 224] = sat_s754h_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s754g_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s754f_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s754e_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = GHC.Float.C:RealFloat_con_info;
           P64[Hp - 120] = Hp - 152;
           P64[Hp - 112] = Hp - 176;
           P64[Hp - 104] = Hp - 200;
           P64[Hp - 96] = Hp - 224;
           P64[Hp - 88] = Hp - 248;
           P64[Hp - 80] = Hp - 272;
           P64[Hp - 72] = Hp - 296;
           P64[Hp - 64] = Hp - 320;
           P64[Hp - 56] = Hp - 344;
           P64[Hp - 48] = Hp - 368;
           P64[Hp - 40] = Hp - 392;
           P64[Hp - 32] = Hp - 416;
           P64[Hp - 24] = Hp - 440;
           P64[Hp - 16] = Hp - 464;
           P64[Hp - 8] = Hp - 488;
           P64[Hp] = Hp - 512;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.60613053 UTC

[section ""data" . Data.Functor.Const.$fEnumConst_closure" {
     Data.Functor.Const.$fEnumConst_closure:
         const Data.Functor.Const.$fEnumConst_info;
 },
 sat_s754C_entry() //  [R1]
         { info_tbl: [(c75w0,
                       label: sat_s754C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75w0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75w1; else goto c75w2;
       c75w1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75w2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754B_entry() //  [R1]
         { info_tbl: [(c75w7,
                       label: sat_s754B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75w7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75w8; else goto c75w9;
       c75w8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75w9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754A_entry() //  [R1]
         { info_tbl: [(c75we,
                       label: sat_s754A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75we: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75wf; else goto c75wg;
       c75wf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75wg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754z_entry() //  [R1]
         { info_tbl: [(c75wl,
                       label: sat_s754z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75wl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75wm; else goto c75wn;
       c75wm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75wn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754y_entry() //  [R1]
         { info_tbl: [(c75ws,
                       label: sat_s754y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ws: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75wt; else goto c75wu;
       c75wt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75wu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.fromEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754x_entry() //  [R1]
         { info_tbl: [(c75wz,
                       label: sat_s754x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75wz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75wA; else goto c75wB;
       c75wA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75wB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.toEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754w_entry() //  [R1]
         { info_tbl: [(c75wG,
                       label: sat_s754w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75wG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75wH; else goto c75wI;
       c75wH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75wI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.pred_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754v_entry() //  [R1]
         { info_tbl: [(c75wN,
                       label: sat_s754v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75wN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75wO; else goto c75wP;
       c75wO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75wP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.succ_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fEnumConst_entry() //  [R2]
         { info_tbl: [(c75wR,
                       label: Data.Functor.Const.$fEnumConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75wR: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c75wV; else goto c75wU;
       c75wV: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Const.$fEnumConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75wU: // global
           I64[Hp - 256] = sat_s754C_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s754B_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s754A_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s754z_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s754y_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s754x_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s754w_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s754v_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.609492384 UTC

[section ""data" . Data.Functor.Const.$fIntegralConst_$cp2Integral_closure" {
     Data.Functor.Const.$fIntegralConst_$cp2Integral_closure:
         const Data.Functor.Const.$fIntegralConst_$cp2Integral_info;
 },
 sat_s754E_entry() //  [R1]
         { info_tbl: [(c75x4,
                       label: sat_s754E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75x4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75x5; else goto c75x6;
       c75x5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75x6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIntegralConst_$cp2Integral_entry() //  [R2]
         { info_tbl: [(c75x7,
                       label: Data.Functor.Const.$fIntegralConst_$cp2Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75x7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75xb; else goto c75xa;
       c75xb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fIntegralConst_$cp2Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75xa: // global
           I64[Hp - 16] = sat_s754E_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fEnumConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.611866072 UTC

[section ""data" . Data.Functor.Const.$fIntegralConst_closure" {
     Data.Functor.Const.$fIntegralConst_closure:
         const Data.Functor.Const.$fIntegralConst_info;
 },
 sat_s754O_entry() //  [R1]
         { info_tbl: [(c75xk,
                       label: sat_s754O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75xk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75xl; else goto c75xm;
       c75xl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75xm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754N_entry() //  [R1]
         { info_tbl: [(c75xr,
                       label: sat_s754N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75xr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75xs; else goto c75xt;
       c75xs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75xt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.divMod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754M_entry() //  [R1]
         { info_tbl: [(c75xy,
                       label: sat_s754M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75xy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75xz; else goto c75xA;
       c75xz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75xA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quotRem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754L_entry() //  [R1]
         { info_tbl: [(c75xF,
                       label: sat_s754L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75xF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75xG; else goto c75xH;
       c75xG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75xH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.mod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754K_entry() //  [R1]
         { info_tbl: [(c75xM,
                       label: sat_s754K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75xM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75xN; else goto c75xO;
       c75xN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75xO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.div_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754J_entry() //  [R1]
         { info_tbl: [(c75xT,
                       label: sat_s754J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75xT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75xU; else goto c75xV;
       c75xU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75xV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.rem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754I_entry() //  [R1]
         { info_tbl: [(c75y0,
                       label: sat_s754I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75y0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75y1; else goto c75y2;
       c75y1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75y2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quot_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754H_entry() //  [R1]
         { info_tbl: [(c75y7,
                       label: sat_s754H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75y7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75y8; else goto c75y9;
       c75y8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75y9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fIntegralConst_$cp2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754G_entry() //  [R1]
         { info_tbl: [(c75ye,
                       label: sat_s754G_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ye: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75yf; else goto c75yg;
       c75yf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75yg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fIntegralConst_$cp1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIntegralConst_entry() //  [R2]
         { info_tbl: [(c75yi,
                       label: Data.Functor.Const.$fIntegralConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75yi: // global
           Hp = Hp + 296;
           if (Hp > HpLim) (likely: False) goto c75ym; else goto c75yl;
       c75ym: // global
           HpAlloc = 296;
           R2 = R2;
           R1 = Data.Functor.Const.$fIntegralConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75yl: // global
           I64[Hp - 288] = sat_s754O_info;
           P64[Hp - 272] = R2;
           I64[Hp - 264] = sat_s754N_info;
           P64[Hp - 248] = R2;
           I64[Hp - 240] = sat_s754M_info;
           P64[Hp - 224] = R2;
           I64[Hp - 216] = sat_s754L_info;
           P64[Hp - 200] = R2;
           I64[Hp - 192] = sat_s754K_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s754J_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s754I_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s754H_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s754G_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = GHC.Real.C:Integral_con_info;
           P64[Hp - 64] = Hp - 96;
           P64[Hp - 56] = Hp - 120;
           P64[Hp - 48] = Hp - 144;
           P64[Hp - 40] = Hp - 168;
           P64[Hp - 32] = Hp - 192;
           P64[Hp - 24] = Hp - 216;
           P64[Hp - 16] = Hp - 240;
           P64[Hp - 8] = Hp - 264;
           P64[Hp] = Hp - 288;
           R1 = Hp - 71;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.615589492 UTC

[section ""data" . Data.Functor.Const.$fBoundedConst_closure" {
     Data.Functor.Const.$fBoundedConst_closure:
         const Data.Functor.Const.$fBoundedConst_info;
 },
 sat_s754R_entry() //  [R1]
         { info_tbl: [(c75yv,
                       label: sat_s754R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75yv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75yw; else goto c75yx;
       c75yw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75yx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754Q_entry() //  [R1]
         { info_tbl: [(c75yC,
                       label: sat_s754Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75yC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75yD; else goto c75yE;
       c75yD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75yE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fBoundedConst_entry() //  [R2]
         { info_tbl: [(c75yG,
                       label: Data.Functor.Const.$fBoundedConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75yG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c75yK; else goto c75yJ;
       c75yK: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Const.$fBoundedConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75yJ: // global
           I64[Hp - 64] = sat_s754R_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s754Q_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.617372065 UTC

[section ""data" . Data.Functor.Const.$fBitsConst_$cp1Bits_closure" {
     Data.Functor.Const.$fBitsConst_$cp1Bits_closure:
         const Data.Functor.Const.$fBitsConst_$cp1Bits_info;
 },
 sat_s754T_entry() //  [R1]
         { info_tbl: [(c75yT,
                       label: sat_s754T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75yT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75yU; else goto c75yV;
       c75yU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75yV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fBitsConst_$cp1Bits_entry() //  [R2]
         { info_tbl: [(c75yW,
                       label: Data.Functor.Const.$fBitsConst_$cp1Bits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75yW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75z0; else goto c75yZ;
       c75z0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fBitsConst_$cp1Bits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75yZ: // global
           I64[Hp - 16] = sat_s754T_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fEqConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.621521018 UTC

[section ""data" . Data.Functor.Const.$fBitsConst_closure" {
     Data.Functor.Const.$fBitsConst_closure:
         const Data.Functor.Const.$fBitsConst_info;
 },
 sat_s755h_entry() //  [R1]
         { info_tbl: [(c75z9,
                       label: sat_s755h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75z9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75za; else goto c75zb;
       c75za: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75zb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.popCount_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755g_entry() //  [R1]
         { info_tbl: [(c75zg,
                       label: sat_s755g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75zg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75zh; else goto c75zi;
       c75zh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75zi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755f_entry() //  [R1]
         { info_tbl: [(c75zn,
                       label: sat_s755f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75zn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75zo; else goto c75zp;
       c75zo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75zp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755e_entry() //  [R1]
         { info_tbl: [(c75zu,
                       label: sat_s755e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75zu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75zv; else goto c75zw;
       c75zv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75zw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755d_entry() //  [R1]
         { info_tbl: [(c75zB,
                       label: sat_s755d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75zB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75zC; else goto c75zD;
       c75zC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75zD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755c_entry() //  [R1]
         { info_tbl: [(c75zI,
                       label: sat_s755c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75zI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75zJ; else goto c75zK;
       c75zJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75zK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755b_entry() //  [R1]
         { info_tbl: [(c75zP,
                       label: sat_s755b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75zP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75zQ; else goto c75zR;
       c75zQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75zR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755a_entry() //  [R1]
         { info_tbl: [(c75zW,
                       label: sat_s755a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75zW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75zX; else goto c75zY;
       c75zX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75zY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.isSigned_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7559_entry() //  [R1]
         { info_tbl: [(c75A3,
                       label: sat_s7559_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75A3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75A4; else goto c75A5;
       c75A4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75A5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7558_entry() //  [R1]
         { info_tbl: [(c75Aa,
                       label: sat_s7558_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Aa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Ab; else goto c75Ac;
       c75Ab: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Ac: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7557_entry() //  [R1]
         { info_tbl: [(c75Ah,
                       label: sat_s7557_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ah: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Ai; else goto c75Aj;
       c75Ai: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Aj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.testBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7556_entry() //  [R1]
         { info_tbl: [(c75Ao,
                       label: sat_s7556_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ao: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Ap; else goto c75Aq;
       c75Ap: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Aq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complementBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7555_entry() //  [R1]
         { info_tbl: [(c75Av,
                       label: sat_s7555_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Av: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Aw; else goto c75Ax;
       c75Aw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Ax: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.clearBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7554_entry() //  [R1]
         { info_tbl: [(c75AC,
                       label: sat_s7554_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75AC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75AD; else goto c75AE;
       c75AD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75AE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.setBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7553_entry() //  [R1]
         { info_tbl: [(c75AJ,
                       label: sat_s7553_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75AJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75AK; else goto c75AL;
       c75AK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75AL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7552_entry() //  [R1]
         { info_tbl: [(c75AQ,
                       label: sat_s7552_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75AQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75AR; else goto c75AS;
       c75AR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75AS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.zeroBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7551_entry() //  [R1]
         { info_tbl: [(c75AX,
                       label: sat_s7551_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75AX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75AY; else goto c75AZ;
       c75AY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75AZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7550_entry() //  [R1]
         { info_tbl: [(c75B4,
                       label: sat_s7550_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75B4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75B5; else goto c75B6;
       c75B5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75B6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shift_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754Z_entry() //  [R1]
         { info_tbl: [(c75Bb,
                       label: sat_s754Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Bb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Bc; else goto c75Bd;
       c75Bc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Bd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complement_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754Y_entry() //  [R1]
         { info_tbl: [(c75Bi,
                       label: sat_s754Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Bi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Bj; else goto c75Bk;
       c75Bj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Bk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.xor_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754X_entry() //  [R1]
         { info_tbl: [(c75Bp,
                       label: sat_s754X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Bp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Bq; else goto c75Br;
       c75Bq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Br: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..|._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754W_entry() //  [R1]
         { info_tbl: [(c75Bw,
                       label: sat_s754W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Bw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Bx; else goto c75By;
       c75Bx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75By: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..&._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754V_entry() //  [R1]
         { info_tbl: [(c75BD,
                       label: sat_s754V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75BD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75BE; else goto c75BF;
       c75BE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75BF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fBitsConst_$cp1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fBitsConst_entry() //  [R2]
         { info_tbl: [(c75BH,
                       label: Data.Functor.Const.$fBitsConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75BH: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto c75BL; else goto c75BK;
       c75BL: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Const.$fBitsConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75BK: // global
           I64[Hp - 736] = sat_s755h_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_s755g_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_s755f_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_s755e_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_s755d_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_s755c_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_s755b_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_s755a_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_s7559_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_s7558_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_s7557_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_s7556_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_s7555_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_s7554_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_s7553_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_s7552_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_s7551_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_s7550_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_s754Z_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_s754Y_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_s754X_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s754W_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s754V_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = Data.Bits.C:Bits_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.630829972 UTC

[section ""data" . Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_closure" {
     Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_closure:
         const Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_info;
 },
 sat_s755j_entry() //  [R1]
         { info_tbl: [(c75BU,
                       label: sat_s755j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75BU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75BV; else goto c75BW;
       c75BV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75BW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_entry() //  [R2]
         { info_tbl: [(c75BX,
                       label: Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75BX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75C1; else goto c75C0;
       c75C1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75C0: // global
           I64[Hp - 16] = sat_s755j_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fBitsConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.632680286 UTC

[section ""data" . Data.Functor.Const.$fFiniteBitsConst_closure" {
     Data.Functor.Const.$fFiniteBitsConst_closure:
         const Data.Functor.Const.$fFiniteBitsConst_info;
 },
 sat_s755o_entry() //  [R1]
         { info_tbl: [(c75Ca,
                       label: sat_s755o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ca: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Cb; else goto c75Cc;
       c75Cb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Cc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countTrailingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755n_entry() //  [R1]
         { info_tbl: [(c75Ch,
                       label: sat_s755n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ch: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Ci; else goto c75Cj;
       c75Ci: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Cj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countLeadingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755m_entry() //  [R1]
         { info_tbl: [(c75Co,
                       label: sat_s755m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Co: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Cp; else goto c75Cq;
       c75Cp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Cq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755l_entry() //  [R1]
         { info_tbl: [(c75Cv,
                       label: sat_s755l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Cv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Cw; else goto c75Cx;
       c75Cw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Cx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFiniteBitsConst_entry() //  [R2]
         { info_tbl: [(c75Cz,
                       label: Data.Functor.Const.$fFiniteBitsConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Cz: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c75CD; else goto c75CC;
       c75CD: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fFiniteBitsConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75CC: // global
           I64[Hp - 128] = sat_s755o_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s755n_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s755m_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s755l_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Bits.C:FiniteBits_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.634786132 UTC

[section ""data" . Data.Functor.Const.getConst1_closure" {
     Data.Functor.Const.getConst1_closure:
         const Data.Functor.Const.getConst1_info;
 },
 Data.Functor.Const.getConst1_entry() //  [R2]
         { info_tbl: [(c75CI,
                       label: Data.Functor.Const.getConst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75CI: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.635648654 UTC

[section ""data" . Data.Functor.Const.getConst_closure" {
     Data.Functor.Const.getConst_closure:
         const Data.Functor.Const.getConst_info;
 },
 Data.Functor.Const.getConst_entry() //  [R2]
         { info_tbl: [(c75CP,
                       label: Data.Functor.Const.getConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75CP: // global
           R2 = R2;
           call Data.Functor.Const.getConst1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.636400039 UTC

[section ""cstring" . Data.Functor.Const.$trModule4_bytes" {
     Data.Functor.Const.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.637039566 UTC

[section ""data" . Data.Functor.Const.$trModule3_closure" {
     Data.Functor.Const.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.637709565 UTC

[section ""cstring" . Data.Functor.Const.$trModule2_bytes" {
     Data.Functor.Const.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.6383595 UTC

[section ""data" . Data.Functor.Const.$trModule1_closure" {
     Data.Functor.Const.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.638973888 UTC

[section ""data" . Data.Functor.Const.$trModule_closure" {
     Data.Functor.Const.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Const.$trModule3_closure+1;
         const Data.Functor.Const.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.639623453 UTC

[section ""data" . $krep_r74ZT_closure" {
     $krep_r74ZT_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.640278813 UTC

[section ""data" . $krep1_r74ZU_closure" {
     $krep1_r74ZU_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.640939658 UTC

[section ""data" . $krep2_r74ZV_closure" {
     $krep2_r74ZV_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r74ZU_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.641617937 UTC

[section ""data" . Data.Functor.Const.$tcConst1_closure" {
     Data.Functor.Const.$tcConst1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep2_r74ZV_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.642253545 UTC

[section ""data" . $krep3_r74ZW_closure" {
     $krep3_r74ZW_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.642819929 UTC

[section ""data" . Data.Functor.Const.$tcConst2_closure" {
     Data.Functor.Const.$tcConst2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$fReadConst5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.643461886 UTC

[section ""data" . Data.Functor.Const.$tcConst_closure" {
     Data.Functor.Const.$tcConst_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Const.$trModule_closure+1;
         const Data.Functor.Const.$tcConst2_closure+1;
         const Data.Functor.Const.$tcConst1_closure+4;
         const 18204097321285842582;
         const 16882168546145866005;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.644096915 UTC

[section ""data" . $krep4_r74ZX_closure" {
     $krep4_r74ZX_closure:
         const :_con_info;
         const $krep3_r74ZW_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.644729597 UTC

[section ""data" . $krep5_r74ZY_closure" {
     $krep5_r74ZY_closure:
         const :_con_info;
         const $krep_r74ZT_closure+2;
         const $krep4_r74ZX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.645550687 UTC

[section ""data" . $krep6_r74ZZ_closure" {
     $krep6_r74ZZ_closure:
         const :_con_info;
         const $krep1_r74ZU_closure+2;
         const $krep5_r74ZY_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.646205401 UTC

[section ""data" . $krep7_r7500_closure" {
     $krep7_r7500_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Const.$tcConst_closure+1;
         const $krep6_r74ZZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.646845648 UTC

[section ""data" . Data.Functor.Const.$tc'Const1_closure" {
     Data.Functor.Const.$tc'Const1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r74ZT_closure+2;
         const $krep7_r7500_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.64750148 UTC

[section ""cstring" . Data.Functor.Const.$tc'Const3_bytes" {
     Data.Functor.Const.$tc'Const3_bytes:
         I8[] [39,67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.648124498 UTC

[section ""data" . Data.Functor.Const.$tc'Const2_closure" {
     Data.Functor.Const.$tc'Const2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$tc'Const3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.648827867 UTC

[section ""data" . Data.Functor.Const.$tc'Const_closure" {
     Data.Functor.Const.$tc'Const_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Const.$trModule_closure+1;
         const Data.Functor.Const.$tc'Const2_closure+1;
         const Data.Functor.Const.$tc'Const1_closure+4;
         const 9035619270378585414;
         const 9797261638746114088;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.649535087 UTC

[section ""relreadonly" . S757l_srt" {
     S757l_srt:
         const Data.Functor.Const.$fReadConst4_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Data.Functor.Const.$w$creadsPrec_closure;
         const Data.Functor.Const.$fReadConst_$creadsPrec_closure;
         const Data.Functor.Const.$fReadConst2_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Const.$fReadConst_$creadList_closure;
         const Data.Functor.Const.$w$creadListPrec_closure;
         const Data.Functor.Const.$fReadConst_closure;
         const Data.Functor.Const.$fShowConst1_closure;
         const Data.Functor.Const.$w$cshowsPrec_closure;
         const Data.Functor.Const.$fShowConst_$cshowsPrec_closure;
         const Data.Functor.Const.$fShowConst_$cshow_closure;
         const Data.Functor.Const.$fShowConst_$cshowList_closure;
         const Data.Functor.Const.$fShowConst_closure;
         const Data.Semigroup.Internal.$fMonoidSum2_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Const.$fFoldableConst1_closure;
         const Data.Functor.Const.$fFoldableConst3_closure;
         const Data.Functor.Const.$fFoldableConst6_closure;
         const Data.Functor.Const.$fFoldableConst8_closure;
         const Data.Semigroup.Internal.$fMonoidProduct2_closure;
         const Data.Functor.Const.$fApplicativeConst_closure;
         const Data.Functor.Const.$fFunctorConst_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.650413178 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:20.651013574 UTC

[section ""data" . Data.Functor.Const.$fReadConst3_closure" {
     Data.Functor.Const.$fReadConst3_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.651664406 UTC

[section ""cstring" . Data.Functor.Const.$fReadConst5_bytes" {
     Data.Functor.Const.$fReadConst5_bytes:
         I8[] [67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.652700902 UTC

[section ""data" . Data.Functor.Const.$fReadConst4_closure" {
     Data.Functor.Const.$fReadConst4_closure:
         const Data.Functor.Const.$fReadConst4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fReadConst4_entry() //  [R1]
         { info_tbl: [(c75CY,
                       label: Data.Functor.Const.$fReadConst4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75CY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75CZ; else goto c75D0;
       c75CZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75D0: // global
           (_c75CV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c75CV::I64 == 0) goto c75CX; else goto c75CW;
       c75CX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c75CW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c75CV::I64;
           R2 = Data.Functor.Const.$fReadConst5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.6556493 UTC

[section ""data" . Data.Functor.Const.$w$creadsPrec_closure" {
     Data.Functor.Const.$w$creadsPrec_closure:
         const Data.Functor.Const.$w$creadsPrec_info;
         const 0;
 },
 go1_s750f_entry() //  [R1, R2]
         { info_tbl: [(c75DD,
                       label: go1_s750f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75DD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c75DE; else goto c75DF;
       c75DE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75DF: // global
           I64[Sp - 24] = block_c75Dw_info;
           _s750f::P64 = R1;
           _s750e::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s750e::P64;
           P64[Sp - 8] = _s750f::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u75DX; else goto c75Dx;
       u75DX: // global
           call _c75Dw(R1) args: 0, res: 0, upd: 0;
       c75Dx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c75Dw() //  [R1]
         { info_tbl: [(c75Dw,
                       label: block_c75Dw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Dw: // global
           if (R1 & 7 == 1) goto c75DA; else goto c75DB;
       c75DA: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c75DB: // global
           I64[Sp] = block_c75DL_info;
           _s750j::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _s750j::P64;
           if (R1 & 7 != 0) goto u75DW; else goto c75DM;
       u75DW: // global
           call _c75DL(R1) args: 0, res: 0, upd: 0;
       c75DM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c75DL() //  [R1]
         { info_tbl: [(c75DL,
                       label: block_c75DL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75DL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c75DV; else goto c75DU;
       c75DV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c75DU: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s7505_entry() //  [R1, R2]
         { info_tbl: [(c75E2,
                       label: go_s7505_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75E2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c75E3; else goto u75En;
       c75E3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u75En: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _c75D7() args: 0, res: 0, upd: 0;
     }
 },
 _c75D7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75D7: // global
           _s7502::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_c75Da_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7502::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u75Ep; else goto c75Db;
       u75Ep: // global
           call _c75Da(R1) args: 0, res: 0, upd: 0;
       c75Db: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c75Da() //  [R1]
         { info_tbl: [(c75Da,
                       label: block_c75Da_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Da: // global
           if (R1 & 7 == 1) goto c75DZ; else goto c75E0;
       c75DZ: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c75E0: // global
           I64[Sp - 8] = block_c75Dg_info;
           _s7509::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s7509::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u75Eq; else goto c75Dh;
       u75Eq: // global
           call _c75Dg(R1) args: 0, res: 0, upd: 0;
       c75Dh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c75Dg() //  [R1]
         { info_tbl: [(c75Dg,
                       label: block_c75Dg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Dg: // global
           I64[Sp - 8] = block_c75Dl_info;
           R3 = Data.Functor.Const.$fReadConst4_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c75Dl() //  [R1]
         { info_tbl: [(c75Dl,
                       label: block_c75Dl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Dl: // global
           _s7509::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c75Ec; else goto c75Ee;
       c75Ec: // global
           P64[Sp + 32] = _s7509::P64;
           Sp = Sp + 24;
           call _c75D7() args: 0, res: 0, upd: 0;
       c75Ee: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c75Eh; else goto c75Eg;
       c75Eh: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c75Eg: // global
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _s7509::P64;
           I64[Hp - 8] = go1_s750f_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 24] = block_c75Ed_info;
           R2 = P64[Sp + 32];
           I64[Sp] = stg_ap_pp_info;
           _s750c::P64 = P64[Sp + 8];
           P64[Sp + 8] = Data.Functor.Const.$fReadConst3_closure+1;
           P64[Sp + 16] = _s750c::P64;
           P64[Sp + 32] = Hp - 7;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c75Ed() //  [R1]
         { info_tbl: [(c75Ed,
                       label: block_c75Ed_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ed: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_s750f_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750u_entry() //  [R1, R2]
         { info_tbl: [(c75EA,
                       label: sat_s750u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75EA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75EB; else goto c75EC;
       c75EB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75EC: // global
           I64[Sp - 16] = block_c75Ey_info;
           R3 = R2;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c75Ey() //  [R1]
         { info_tbl: [(c75Ey,
                       label: block_c75Ey_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ey: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s7505_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$w$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c75EI,
                       label: Data.Functor.Const.$w$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75EI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c75EM; else goto c75EL;
       c75EM: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$w$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c75EL: // global
           I64[Hp - 24] = go_s7505_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s750u_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           _s750r::P64 = I64[(%MO_S_Gt_W64(R3,
                                           10) << 3) + GHC.Types.Bool_closure_tbl];
           R3 = Hp - 7;
           R2 = _s750r::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.661817107 UTC

[section ""data" . Data.Functor.Const.$fReadConst_$creadsPrec_closure" {
     Data.Functor.Const.$fReadConst_$creadsPrec_closure:
         const Data.Functor.Const.$fReadConst_$creadsPrec_info;
         const 0;
 },
 Data.Functor.Const.$fReadConst_$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c75EU,
                       label: Data.Functor.Const.$fReadConst_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75EU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c75EV; else goto c75EW;
       c75EV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fReadConst_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c75EW: // global
           I64[Sp - 24] = block_c75ER_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u75F0; else goto c75ES;
       u75F0: // global
           call _c75ER(R1) args: 0, res: 0, upd: 0;
       c75ES: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c75ER() //  [R1]
         { info_tbl: [(c75ER,
                       label: block_c75ER_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ER: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Const.$w$creadsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.66339964 UTC

[section ""data" . Data.Functor.Const.$fReadConst2_closure" {
     Data.Functor.Const.$fReadConst2_closure:
         const Data.Functor.Const.$fReadConst2_info;
         const 0;
 },
 sat_s750D_entry() //  [R1, R2]
         { info_tbl: [(c75Fa,
                       label: sat_s750D_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Fa: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Const.$fReadConst_$creadsPrec_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fReadConst2_entry() //  [R2, R3, R4]
         { info_tbl: [(c75Fg,
                       label: Data.Functor.Const.$fReadConst2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Fg: // global
           _s750C::P64 = R4;
           _s750B::P64 = R3;
           _s750A::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c75Fh; else goto c75Fi;
       c75Fi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75Fk; else goto c75Fj;
       c75Fk: // global
           HpAlloc = 24;
           goto c75Fh;
       c75Fh: // global
           R4 = _s750C::P64;
           R3 = _s750B::P64;
           R2 = _s750A::P64;
           R1 = Data.Functor.Const.$fReadConst2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c75Fj: // global
           I64[Hp - 16] = sat_s750D_info;
           P64[Hp - 8] = _s750A::P64;
           P64[Hp] = _s750B::P64;
           I64[Sp - 8] = block_c75Fd_info;
           R3 = _s750C::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c75Fd() //  [R1]
         { info_tbl: [(c75Fd,
                       label: block_c75Fd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Fd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c75Fn; else goto c75Fm;
       c75Fn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c75Fm: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.664859366 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst5_closure" {
     Data.Functor.Const.$fFoldableConst5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.666001881 UTC

[section ""data" . Data.Functor.Const.$fReadConst_$creadList_closure" {
     Data.Functor.Const.$fReadConst_$creadList_closure:
         const Data.Functor.Const.$fReadConst_$creadList_info;
         const 0;
 },
 sat_s750H_entry() //  [R1, R2, R3]
         { info_tbl: [(c75FB,
                       label: sat_s750H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75FB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750I_entry() //  [R1]
         { info_tbl: [(c75FE,
                       label: sat_s750I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75FE: // global
           _s750I::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c75FF; else goto c75FG;
       c75FG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c75FI; else goto c75FH;
       c75FI: // global
           HpAlloc = 16;
           goto c75FF;
       c75FF: // global
           R1 = _s750I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75FH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s750I::P64;
           _s750G::P64 = P64[_s750I::P64 + 16];
           I64[Hp - 8] = sat_s750H_info;
           P64[Hp] = _s750G::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Const.$fFoldableConst5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fReadConst_$creadList_entry() //  [R2]
         { info_tbl: [(c75FJ,
                       label: Data.Functor.Const.$fReadConst_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75FJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75FN; else goto c75FM;
       c75FN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fReadConst_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75FM: // global
           I64[Hp - 16] = sat_s750I_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.668253272 UTC

[section ""data" . Data.Functor.Const.$w$creadListPrec_closure" {
     Data.Functor.Const.$w$creadListPrec_closure:
         const Data.Functor.Const.$w$creadListPrec_info;
         const 0;
 },
 sat_s750L_entry() //  [R1, R2, R3]
         { info_tbl: [(c75G1,
                       label: sat_s750L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75G1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 w1_s750K_entry() //  [R1]
         { info_tbl: [(c75G4,
                       label: w1_s750K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75G4: // global
           _s750K::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c75G5; else goto c75G6;
       c75G6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c75G8; else goto c75G7;
       c75G8: // global
           HpAlloc = 16;
           goto c75G5;
       c75G5: // global
           R1 = _s750K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75G7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s750K::P64;
           _s750J::P64 = P64[_s750K::P64 + 16];
           I64[Hp - 8] = sat_s750L_info;
           P64[Hp] = _s750J::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Const.$fFoldableConst5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 w2_s750M_entry() //  [R1, R2]
         { info_tbl: [(c75Ge,
                       label: w2_s750M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ge: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750Q_entry() //  [R1, R2]
         { info_tbl: [(c75Gp,
                       label: sat_s750Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Gp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c75Gq; else goto c75Gr;
       c75Gq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Gr: // global
           I64[Sp - 8] = block_c75Gm_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c75Gm() //  [R1]
         { info_tbl: [(c75Gm,
                       label: block_c75Gm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Gm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c75Gu; else goto c75Gt;
       c75Gu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c75Gt: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$w$creadListPrec_entry() //  [R2]
         { info_tbl: [(c75Gv,
                       label: Data.Functor.Const.$w$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Gv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c75Gz; else goto c75Gy;
       c75Gz: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Const.$w$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Gy: // global
           I64[Hp - 48] = w1_s750K_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = w2_s750M_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s750Q_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.670570172 UTC

[section ""data" . Data.Functor.Const.$fReadConst1_closure" {
     Data.Functor.Const.$fReadConst1_closure:
         const Data.Functor.Const.$fReadConst1_info;
         const 0;
 },
 Data.Functor.Const.$fReadConst1_entry() //  [R2]
         { info_tbl: [(c75GE,
                       label: Data.Functor.Const.$fReadConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75GE: // global
           R2 = R2;
           call Data.Functor.Const.$w$creadListPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.672084617 UTC

[section ""data" . Data.Functor.Const.$fReadConst_closure" {
     Data.Functor.Const.$fReadConst_closure:
         const Data.Functor.Const.$fReadConst_info;
         const 0;
 },
 lvl_s750U_entry() //  [R1]
         { info_tbl: [(c75GP,
                       label: lvl_s750U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75GP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75GQ; else goto c75GR;
       c75GQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75GR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$w$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s750Z_entry() //  [R1]
         { info_tbl: [(c75GX,
                       label: sat_s750Z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75GX: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750X_entry() //  [R1, R2, R3]
         { info_tbl: [(c75H5,
                       label: sat_s750X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75H5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750W_entry() //  [R1]
         { info_tbl: [(c75Hc,
                       label: sat_s750W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Hc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Hd; else goto c75He;
       c75Hd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75He: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fReadConst_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s750V_entry() //  [R1, R2, R3]
         { info_tbl: [(c75Hk,
                       label: sat_s750V_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Hk: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst_$creadsPrec_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fReadConst_entry() //  [R2]
         { info_tbl: [(c75Ho,
                       label: Data.Functor.Const.$fReadConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ho: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c75Hs; else goto c75Hr;
       c75Hs: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fReadConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Hr: // global
           I64[Hp - 128] = lvl_s750U_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s750Z_info;
           P64[Hp - 96] = Hp - 128;
           I64[Hp - 88] = sat_s750X_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s750W_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s750V_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 46;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.674170023 UTC

[section ""cstring" . Data.Functor.Const.$fShowConst2_bytes" {
     Data.Functor.Const.$fShowConst2_bytes:
         I8[] [67,111,110,115,116,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.675011405 UTC

[section ""data" . Data.Functor.Const.$fShowConst1_closure" {
     Data.Functor.Const.$fShowConst1_closure:
         const Data.Functor.Const.$fShowConst1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fShowConst1_entry() //  [R1]
         { info_tbl: [(c75Hz,
                       label: Data.Functor.Const.$fShowConst1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Hz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75HA; else goto c75HB;
       c75HA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75HB: // global
           (_c75Hw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c75Hw::I64 == 0) goto c75Hy; else goto c75Hx;
       c75Hy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c75Hx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c75Hw::I64;
           R2 = Data.Functor.Const.$fShowConst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.677232603 UTC

[section ""data" . Data.Functor.Const.$w$cshowsPrec_closure" {
     Data.Functor.Const.$w$cshowsPrec_closure:
         const Data.Functor.Const.$w$cshowsPrec_info;
         const 0;
 },
 g_s7513_entry() //  [R1]
         { info_tbl: [(c75HK,
                       label: g_s7513_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75HK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c75HL; else goto c75HM;
       c75HL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75HM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Const.$fReadConst3_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s7516_entry() //  [R1]
         { info_tbl: [(c75HZ,
                       label: sat_s7516_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75HZ: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7517_entry() //  [R1, R2]
         { info_tbl: [(c75I2,
                       label: sat_s7517_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75I2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c75I6; else goto c75I5;
       c75I6: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75I5: // global
           _s7513::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s7516_info;
           P64[Hp - 8] = _s7513::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Functor.Const.$fShowConst1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s751a_entry() //  [R1]
         { info_tbl: [(c75Im,
                       label: sat_s751a_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Im: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75Iq; else goto c75Ip;
       c75Iq: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Ip: // global
           _s7513::P64 = P64[R1 + 16];
           _s7518::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s7518::P64;
           R2 = Hp - 14;
           R1 = _s7513::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s751b_entry() //  [R1]
         { info_tbl: [(c75Ir,
                       label: sat_s751b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ir: // global
           _s751b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c75Is; else goto c75It;
       c75It: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c75Iv; else goto c75Iu;
       c75Iv: // global
           HpAlloc = 32;
           goto c75Is;
       c75Is: // global
           R1 = _s751b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Iu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s751b::P64;
           _s7513::P64 = P64[_s751b::P64 + 16];
           _s7518::P64 = P64[_s751b::P64 + 24];
           I64[Hp - 24] = sat_s751a_info;
           P64[Hp - 8] = _s7513::P64;
           P64[Hp] = _s7518::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Const.$fShowConst1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s751c_entry() //  [R1, R2]
         { info_tbl: [(c75Ix,
                       label: sat_s751c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ix: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c75IB; else goto c75IA;
       c75IB: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75IA: // global
           _s7513::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s751b_info;
           P64[Hp - 32] = _s7513::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c75IF,
                       label: Data.Functor.Const.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75IF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c75IJ; else goto c75II;
       c75IJ: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c75II: // global
           I64[Hp - 40] = g_s7513_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c75HG::P64 = Hp - 40;
           if (%MO_S_Le_W64(R3, 10)) goto c75ID; else goto c75IE;
       c75ID: // global
           I64[Hp - 8] = sat_s7517_info;
           P64[Hp] = _c75HG::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c75IE: // global
           I64[Hp - 8] = sat_s751c_info;
           P64[Hp] = _c75HG::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.680398788 UTC

[section ""data" . Data.Functor.Const.$fShowConst_$cshowsPrec_closure" {
     Data.Functor.Const.$fShowConst_$cshowsPrec_closure:
         const Data.Functor.Const.$fShowConst_$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Const.$fShowConst_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c75IR,
                       label: Data.Functor.Const.$fShowConst_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75IR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c75IS; else goto c75IT;
       c75IS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c75IT: // global
           I64[Sp - 24] = block_c75IO_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u75IX; else goto c75IP;
       u75IX: // global
           call _c75IO(R1) args: 0, res: 0, upd: 0;
       c75IP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c75IO() //  [R1]
         { info_tbl: [(c75IO,
                       label: block_c75IO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75IO: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Const.$w$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.681975159 UTC

[section ""data" . Data.Functor.Const.$fShowConst_$cshow_closure" {
     Data.Functor.Const.$fShowConst_$cshow_closure:
         const Data.Functor.Const.$fShowConst_$cshow_info;
         const 0;
 },
 sat_s751k_entry() //  [R1]
         { info_tbl: [(c75J6,
                       label: sat_s751k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75J6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c75J7; else goto c75J8;
       c75J7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75J8: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Functor.Const.$fReadConst3_closure+1;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fShowConst_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c75J9,
                       label: Data.Functor.Const.$fShowConst_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75J9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c75Jd; else goto c75Jc;
       c75Jd: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c75Jc: // global
           I64[Hp - 24] = sat_s751k_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Functor.Const.$fShowConst1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.683577655 UTC

[section ""data" . Data.Functor.Const.$fShowConst_$cshowList_closure" {
     Data.Functor.Const.$fShowConst_$cshowList_closure:
         const Data.Functor.Const.$fShowConst_$cshowList_info;
         const 0;
 },
 sat_s751p_entry() //  [R1, R2]
         { info_tbl: [(c75Jn,
                       label: sat_s751p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Jn: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Functor.Const.$w$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fShowConst_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c75Jq,
                       label: Data.Functor.Const.$fShowConst_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Jq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c75Ju; else goto c75Jt;
       c75Ju: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c75Jt: // global
           I64[Hp - 8] = sat_s751p_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.685314125 UTC

[section ""data" . Data.Functor.Const.$fShowConst_closure" {
     Data.Functor.Const.$fShowConst_closure:
         const Data.Functor.Const.$fShowConst_info;
         const 0;
 },
 sat_s751t_entry() //  [R1, R2, R3]
         { info_tbl: [(c75JE,
                       label: sat_s751t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75JE: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fShowConst_$cshowList_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s751s_entry() //  [R1, R2]
         { info_tbl: [(c75JM,
                       label: sat_s751s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75JM: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Const.$fShowConst_$cshow_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s751r_entry() //  [R1, R2, R3]
         { info_tbl: [(c75JU,
                       label: sat_s751r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75JU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fShowConst_$cshowsPrec_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fShowConst_entry() //  [R2]
         { info_tbl: [(c75JY,
                       label: Data.Functor.Const.$fShowConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75JY: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c75K2; else goto c75K1;
       c75K2: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75K1: // global
           I64[Hp - 72] = sat_s751t_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s751s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s751r_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.686939491 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldMap_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldMap_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldMap_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldMap_entry() //  [R2]
         { info_tbl: [(c75K7,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75K7: // global
           R2 = R2;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.687888698 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfold_closure" {
     Data.Functor.Const.$fFoldableConst_$cfold_closure:
         const Data.Functor.Const.$fFoldableConst_$cfold_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfold_entry() //  [R2]
         { info_tbl: [(c75Ke,
                       label: Data.Functor.Const.$fFoldableConst_$cfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ke: // global
           R2 = R2;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.688797658 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$csum_closure" {
     Data.Functor.Const.$fFoldableConst_$csum_closure:
         const Data.Functor.Const.$fFoldableConst_$csum_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$csum_entry() //  [R2]
         { info_tbl: [(c75Kl,
                       label: Data.Functor.Const.$fFoldableConst_$csum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Kl: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fMonoidSum2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.690004423 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst2_bytes" {
     Data.Functor.Const.$fFoldableConst2_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.690876095 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst1_closure" {
     Data.Functor.Const.$fFoldableConst1_closure:
         const Data.Functor.Const.$fFoldableConst1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst1_entry() //  [R1]
         { info_tbl: [(c75Ku,
                       label: Data.Functor.Const.$fFoldableConst1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ku: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Kv; else goto c75Kw;
       c75Kv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Kw: // global
           (_c75Kr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c75Kr::I64 == 0) goto c75Kt; else goto c75Ks;
       c75Kt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c75Ks: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c75Kr::I64;
           R2 = Data.Functor.Const.$fFoldableConst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.692075452 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cminimum_closure" {
     Data.Functor.Const.$fFoldableConst_$cminimum_closure:
         const Data.Functor.Const.$fFoldableConst_$cminimum_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cminimum_entry() //  []
         { info_tbl: [(c75KB,
                       label: Data.Functor.Const.$fFoldableConst_$cminimum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75KB: // global
           R2 = Data.Functor.Const.$fFoldableConst1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.692900484 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst4_bytes" {
     Data.Functor.Const.$fFoldableConst4_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.693731339 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst3_closure" {
     Data.Functor.Const.$fFoldableConst3_closure:
         const Data.Functor.Const.$fFoldableConst3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst3_entry() //  [R1]
         { info_tbl: [(c75KK,
                       label: Data.Functor.Const.$fFoldableConst3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75KK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75KL; else goto c75KM;
       c75KL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75KM: // global
           (_c75KH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c75KH::I64 == 0) goto c75KJ; else goto c75KI;
       c75KJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c75KI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c75KH::I64;
           R2 = Data.Functor.Const.$fFoldableConst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.696322955 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cmaximum_closure" {
     Data.Functor.Const.$fFoldableConst_$cmaximum_closure:
         const Data.Functor.Const.$fFoldableConst_$cmaximum_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cmaximum_entry() //  []
         { info_tbl: [(c75KR,
                       label: Data.Functor.Const.$fFoldableConst_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75KR: // global
           R2 = Data.Functor.Const.$fFoldableConst3_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.697210306 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$celem_closure" {
     Data.Functor.Const.$fFoldableConst_$celem_closure:
         const Data.Functor.Const.$fFoldableConst_$celem_info;
 },
 Data.Functor.Const.$fFoldableConst_$celem_entry() //  []
         { info_tbl: [(c75KY,
                       label: Data.Functor.Const.$fFoldableConst_$celem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75KY: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.69814647 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldl_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldl_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldl_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldl_entry() //  [R3]
         { info_tbl: [(c75L5,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75L5: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.698902508 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst7_bytes" {
     Data.Functor.Const.$fFoldableConst7_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.699693565 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst6_closure" {
     Data.Functor.Const.$fFoldableConst6_closure:
         const Data.Functor.Const.$fFoldableConst6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst6_entry() //  [R1]
         { info_tbl: [(c75Le,
                       label: Data.Functor.Const.$fFoldableConst6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Le: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Lf; else goto c75Lg;
       c75Lf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Lg: // global
           (_c75Lb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c75Lb::I64 == 0) goto c75Ld; else goto c75Lc;
       c75Ld: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c75Lc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c75Lb::I64;
           R2 = Data.Functor.Const.$fFoldableConst7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.700700686 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldl1_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldl1_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldl1_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldl1_entry() //  []
         { info_tbl: [(c75Ll,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ll: // global
           R2 = Data.Functor.Const.$fFoldableConst6_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.702014348 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldr'_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldr'_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldr'_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldr'_entry() //  [R3]
         { info_tbl: [(c75Ls,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ls: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.702912437 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$clength_closure" {
     Data.Functor.Const.$fFoldableConst_$clength_closure:
         const Data.Functor.Const.$fFoldableConst_$clength_info;
 },
 Data.Functor.Const.$fFoldableConst_$clength_entry() //  []
         { info_tbl: [(c75Lz,
                       label: Data.Functor.Const.$fFoldableConst_$clength_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Lz: // global
           R1 = Data.Functor.Const.$fFoldableConst5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.703611458 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst9_bytes" {
     Data.Functor.Const.$fFoldableConst9_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.70446047 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst8_closure" {
     Data.Functor.Const.$fFoldableConst8_closure:
         const Data.Functor.Const.$fFoldableConst8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst8_entry() //  [R1]
         { info_tbl: [(c75LI,
                       label: Data.Functor.Const.$fFoldableConst8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75LI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75LJ; else goto c75LK;
       c75LJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75LK: // global
           (_c75LF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c75LF::I64 == 0) goto c75LH; else goto c75LG;
       c75LH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c75LG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c75LF::I64;
           R2 = Data.Functor.Const.$fFoldableConst9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.705506119 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldr1_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldr1_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldr1_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldr1_entry() //  []
         { info_tbl: [(c75LP,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75LP: // global
           R2 = Data.Functor.Const.$fFoldableConst8_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.706470788 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cnull_closure" {
     Data.Functor.Const.$fFoldableConst_$cnull_closure:
         const Data.Functor.Const.$fFoldableConst_$cnull_info;
 },
 Data.Functor.Const.$fFoldableConst_$cnull_entry() //  []
         { info_tbl: [(c75LW,
                       label: Data.Functor.Const.$fFoldableConst_$cnull_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75LW: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.707322659 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cproduct_closure" {
     Data.Functor.Const.$fFoldableConst_$cproduct_closure:
         const Data.Functor.Const.$fFoldableConst_$cproduct_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cproduct_entry() //  [R2]
         { info_tbl: [(c75M3,
                       label: Data.Functor.Const.$fFoldableConst_$cproduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75M3: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fMonoidProduct2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.708176362 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$ctoList_closure" {
     Data.Functor.Const.$fFoldableConst_$ctoList_closure:
         const Data.Functor.Const.$fFoldableConst_$ctoList_info;
 },
 Data.Functor.Const.$fFoldableConst_$ctoList_entry() //  []
         { info_tbl: [(c75Ma,
                       label: Data.Functor.Const.$fFoldableConst_$ctoList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ma: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.709065409 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_closure" {
     Data.Functor.Const.$fFoldableConst_closure:
         const Data.Foldable.C:Foldable_con_info;
         const Data.Functor.Const.$fFoldableConst_$cfold_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cfoldMap_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldr'_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldr'_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldl_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldl_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldr1_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cfoldl1_closure+2;
         const Data.Functor.Const.$fFoldableConst_$ctoList_closure+1;
         const Data.Functor.Const.$fFoldableConst_$cnull_closure+1;
         const Data.Functor.Const.$fFoldableConst_$clength_closure+1;
         const Data.Functor.Const.$fFoldableConst_$celem_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cmaximum_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cminimum_closure+2;
         const Data.Functor.Const.$fFoldableConst_$csum_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cproduct_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.709943349 UTC

[section ""data" . Data.Functor.Const.$fFunctorConst2_closure" {
     Data.Functor.Const.$fFunctorConst2_closure:
         const Data.Functor.Const.$fFunctorConst2_info;
 },
 Data.Functor.Const.$fFunctorConst2_entry() //  [R3]
         { info_tbl: [(c75Mh,
                       label: Data.Functor.Const.$fFunctorConst2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Mh: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.710883499 UTC

[section ""data" . Data.Functor.Const.$fFunctorConst1_closure" {
     Data.Functor.Const.$fFunctorConst1_closure:
         const Data.Functor.Const.$fFunctorConst1_info;
 },
 Data.Functor.Const.$fFunctorConst1_entry() //  [R3]
         { info_tbl: [(c75Mo,
                       label: Data.Functor.Const.$fFunctorConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Mo: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.711611471 UTC

[section ""data" . Data.Functor.Const.$fFunctorConst_closure" {
     Data.Functor.Const.$fFunctorConst_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Const.$fFunctorConst2_closure+2;
         const Data.Functor.Const.$fFunctorConst1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.713338836 UTC

[section ""data" . Data.Functor.Const.$fApplicativeConst_closure" {
     Data.Functor.Const.$fApplicativeConst_closure:
         const Data.Functor.Const.$fApplicativeConst_info;
         const 0;
 },
 lvl_s7522_entry() //  [R1]
         { info_tbl: [(c75Mz,
                       label: lvl_s7522_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Mz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75MA; else goto c75MB;
       c75MA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75MB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752f_entry() //  [R1, R2, R3]
         { info_tbl: [(c75MH,
                       label: sat_s752f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75MH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c75MI; else goto c75MJ;
       c75MI: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c75MJ: // global
           _s752d::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s752d::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s752c_entry() //  [R1, R2, R3]
         { info_tbl: [(c75MP,
                       label: sat_s752c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75MP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c75MQ; else goto c75MR;
       c75MQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c75MR: // global
           _s752a::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s752a::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7529_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c75MX,
                       label: sat_s7529_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75MX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c75MY; else goto c75MZ;
       c75MY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c75MZ: // global
           R2 = P64[R1 + 5];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7525_entry() //  [R1]
         { info_tbl: [(c75N4,
                       label: sat_s7525_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75N4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75N5; else goto c75N6;
       c75N5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75N6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7524_entry() //  [R1]
         { info_tbl: [(c75Nc,
                       label: sat_s7524_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Nc: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fApplicativeConst_entry() //  [R2]
         { info_tbl: [(c75Ng,
                       label: Data.Functor.Const.$fApplicativeConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ng: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c75Nk; else goto c75Nj;
       c75Nk: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Functor.Const.$fApplicativeConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Nj: // global
           I64[Hp - 160] = lvl_s7522_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s752f_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s752c_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s7529_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s7525_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s7524_info;
           P64[Hp - 56] = Hp - 160;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Data.Functor.Const.$fFunctorConst_closure+1;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 101;
           P64[Hp - 8] = Hp - 118;
           P64[Hp] = Hp - 134;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.716987513 UTC

[section ""data" . Data.Functor.Const.$fStorableConst_closure" {
     Data.Functor.Const.$fStorableConst_closure:
         const Data.Functor.Const.$fStorableConst_info;
 },
 sat_s752o_entry() //  [R1]
         { info_tbl: [(c75Nt,
                       label: sat_s752o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Nt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Nu; else goto c75Nv;
       c75Nu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Nv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752n_entry() //  [R1]
         { info_tbl: [(c75NA,
                       label: sat_s752n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75NA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75NB; else goto c75NC;
       c75NB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75NC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752m_entry() //  [R1]
         { info_tbl: [(c75NH,
                       label: sat_s752m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75NH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75NI; else goto c75NJ;
       c75NI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75NJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752l_entry() //  [R1]
         { info_tbl: [(c75NO,
                       label: sat_s752l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75NO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75NP; else goto c75NQ;
       c75NP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75NQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752k_entry() //  [R1]
         { info_tbl: [(c75NV,
                       label: sat_s752k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75NV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75NW; else goto c75NX;
       c75NW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75NX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752j_entry() //  [R1]
         { info_tbl: [(c75O2,
                       label: sat_s752j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75O2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75O3; else goto c75O4;
       c75O3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75O4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752i_entry() //  [R1]
         { info_tbl: [(c75O9,
                       label: sat_s752i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75O9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Oa; else goto c75Ob;
       c75Oa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Ob: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.alignment_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752h_entry() //  [R1]
         { info_tbl: [(c75Og,
                       label: sat_s752h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Og: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Oh; else goto c75Oi;
       c75Oh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Oi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fStorableConst_entry() //  [R2]
         { info_tbl: [(c75Ok,
                       label: Data.Functor.Const.$fStorableConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ok: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c75Oo; else goto c75On;
       c75Oo: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Const.$fStorableConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75On: // global
           I64[Hp - 256] = sat_s752o_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s752n_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s752m_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s752l_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s752k_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s752j_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s752i_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s752h_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.721020871 UTC

[section ""data" . Data.Functor.Const.$fNumConst_closure" {
     Data.Functor.Const.$fNumConst_closure:
         const Data.Functor.Const.$fNumConst_info;
 },
 sat_s752w_entry() //  [R1]
         { info_tbl: [(c75Ox,
                       label: sat_s752w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ox: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Oy; else goto c75Oz;
       c75Oy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Oz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752v_entry() //  [R1]
         { info_tbl: [(c75OE,
                       label: sat_s752v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75OE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75OF; else goto c75OG;
       c75OF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75OG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752u_entry() //  [R1]
         { info_tbl: [(c75OL,
                       label: sat_s752u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75OL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75OM; else goto c75ON;
       c75OM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75ON: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752t_entry() //  [R1]
         { info_tbl: [(c75OS,
                       label: sat_s752t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75OS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75OT; else goto c75OU;
       c75OT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75OU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752s_entry() //  [R1]
         { info_tbl: [(c75OZ,
                       label: sat_s752s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75OZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75P0; else goto c75P1;
       c75P0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75P1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752r_entry() //  [R1]
         { info_tbl: [(c75P6,
                       label: sat_s752r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75P6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75P7; else goto c75P8;
       c75P7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75P8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752q_entry() //  [R1]
         { info_tbl: [(c75Pd,
                       label: sat_s752q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Pd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Pe; else goto c75Pf;
       c75Pe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Pf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fNumConst_entry() //  [R2]
         { info_tbl: [(c75Ph,
                       label: Data.Functor.Const.$fNumConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ph: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c75Pl; else goto c75Pk;
       c75Pl: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Const.$fNumConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Pk: // global
           I64[Hp - 224] = sat_s752w_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s752v_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s752u_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s752t_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s752s_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s752r_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s752q_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.724168369 UTC

[section ""data" . Data.Functor.Const.$fRealConst_$cp1Real_closure" {
     Data.Functor.Const.$fRealConst_$cp1Real_closure:
         const Data.Functor.Const.$fRealConst_$cp1Real_info;
 },
 sat_s752y_entry() //  [R1]
         { info_tbl: [(c75Pu,
                       label: sat_s752y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Pu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Pv; else goto c75Pw;
       c75Pv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Pw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealConst_$cp1Real_entry() //  [R2]
         { info_tbl: [(c75Px,
                       label: Data.Functor.Const.$fRealConst_$cp1Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Px: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75PB; else goto c75PA;
       c75PB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealConst_$cp1Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75PA: // global
           I64[Hp - 16] = sat_s752y_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fNumConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.725898179 UTC

[section ""data" . Data.Functor.Const.$fSemigroupConst_closure" {
     Data.Functor.Const.$fSemigroupConst_closure:
         const Data.Functor.Const.$fSemigroupConst_info;
 },
 sat_s752D_entry() //  [R1, R2]
         { info_tbl: [(c75PL,
                       label: sat_s752D_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75PL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75PM; else goto c75PN;
       c75PM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75PN: // global
           _s752C::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s752C::P64;
           Sp = Sp - 16;
           call GHC.Base.stimes_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s752B_entry() //  [R1]
         { info_tbl: [(c75PS,
                       label: sat_s752B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75PS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75PT; else goto c75PU;
       c75PT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75PU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.sconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752A_entry() //  [R1]
         { info_tbl: [(c75PZ,
                       label: sat_s752A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75PZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Q0; else goto c75Q1;
       c75Q0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Q1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fSemigroupConst_entry() //  [R2]
         { info_tbl: [(c75Q3,
                       label: Data.Functor.Const.$fSemigroupConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Q3: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c75Q7; else goto c75Q6;
       c75Q7: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = Data.Functor.Const.$fSemigroupConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Q6: // global
           I64[Hp - 88] = sat_s752D_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s752B_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s752A_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 87;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.729456443 UTC

[section ""data" . Data.Functor.Const.$fMonoidConst_$cp1Monoid_closure" {
     Data.Functor.Const.$fMonoidConst_$cp1Monoid_closure:
         const Data.Functor.Const.$fMonoidConst_$cp1Monoid_info;
 },
 sat_s752F_entry() //  [R1]
         { info_tbl: [(c75Qg,
                       label: sat_s752F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Qg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Qh; else goto c75Qi;
       c75Qh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Qi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fMonoidConst_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(c75Qj,
                       label: Data.Functor.Const.$fMonoidConst_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Qj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75Qn; else goto c75Qm;
       c75Qn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fMonoidConst_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Qm: // global
           I64[Hp - 16] = sat_s752F_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fSemigroupConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.731595068 UTC

[section ""data" . Data.Functor.Const.$fMonoidConst_closure" {
     Data.Functor.Const.$fMonoidConst_closure:
         const Data.Functor.Const.$fMonoidConst_info;
 },
 sat_s752K_entry() //  [R1]
         { info_tbl: [(c75Qw,
                       label: sat_s752K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Qw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Qx; else goto c75Qy;
       c75Qx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Qy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752J_entry() //  [R1]
         { info_tbl: [(c75QD,
                       label: sat_s752J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75QD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75QE; else goto c75QF;
       c75QE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75QF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752I_entry() //  [R1]
         { info_tbl: [(c75QK,
                       label: sat_s752I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75QK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75QL; else goto c75QM;
       c75QL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75QM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752H_entry() //  [R1]
         { info_tbl: [(c75QR,
                       label: sat_s752H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75QR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75QS; else goto c75QT;
       c75QS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75QT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fMonoidConst_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fMonoidConst_entry() //  [R2]
         { info_tbl: [(c75QV,
                       label: Data.Functor.Const.$fMonoidConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75QV: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c75QZ; else goto c75QY;
       c75QZ: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fMonoidConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75QY: // global
           I64[Hp - 128] = sat_s752K_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s752J_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s752I_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s752H_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.733703322 UTC

[section ""data" . Data.Functor.Const.$fGeneric1Const1_closure" {
     Data.Functor.Const.$fGeneric1Const1_closure:
         const Data.Functor.Const.$fGeneric1Const1_info;
 },
 Data.Functor.Const.$fGeneric1Const1_entry() //  [R2]
         { info_tbl: [(c75R4,
                       label: Data.Functor.Const.$fGeneric1Const1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75R4: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.734596177 UTC

[section ""data" . Data.Functor.Const.$fGeneric1Const2_closure" {
     Data.Functor.Const.$fGeneric1Const2_closure:
         const Data.Functor.Const.$fGeneric1Const2_info;
 },
 Data.Functor.Const.$fGeneric1Const2_entry() //  [R2]
         { info_tbl: [(c75Rb,
                       label: Data.Functor.Const.$fGeneric1Const2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Rb: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.735369538 UTC

[section ""data" . Data.Functor.Const.$fGeneric1Const_closure" {
     Data.Functor.Const.$fGeneric1Const_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Const.$fGeneric1Const2_closure+1;
         const Data.Functor.Const.$fGeneric1Const1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.736105715 UTC

[section ""data" . Data.Functor.Const.$fGenericConst1_closure" {
     Data.Functor.Const.$fGenericConst1_closure:
         const Data.Functor.Const.$fGenericConst1_info;
 },
 Data.Functor.Const.$fGenericConst1_entry() //  [R2]
         { info_tbl: [(c75Ri,
                       label: Data.Functor.Const.$fGenericConst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ri: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.73697556 UTC

[section ""data" . Data.Functor.Const.$fGenericConst2_closure" {
     Data.Functor.Const.$fGenericConst2_closure:
         const Data.Functor.Const.$fGenericConst2_info;
 },
 Data.Functor.Const.$fGenericConst2_entry() //  [R2]
         { info_tbl: [(c75Rp,
                       label: Data.Functor.Const.$fGenericConst2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Rp: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.737754173 UTC

[section ""data" . Data.Functor.Const.$fGenericConst_closure" {
     Data.Functor.Const.$fGenericConst_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Const.$fGenericConst2_closure+1;
         const Data.Functor.Const.$fGenericConst1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.738712351 UTC

[section ""data" . Data.Functor.Const.$fFractionalConst_$cp1Fractional_closure" {
     Data.Functor.Const.$fFractionalConst_$cp1Fractional_closure:
         const Data.Functor.Const.$fFractionalConst_$cp1Fractional_info;
 },
 sat_s752Q_entry() //  [R1]
         { info_tbl: [(c75RA,
                       label: sat_s752Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75RA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75RB; else goto c75RC;
       c75RB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75RC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFractionalConst_$cp1Fractional_entry() //  [R2]
         { info_tbl: [(c75RD,
                       label: Data.Functor.Const.$fFractionalConst_$cp1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75RD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75RH; else goto c75RG;
       c75RH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fFractionalConst_$cp1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75RG: // global
           I64[Hp - 16] = sat_s752Q_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fNumConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.740516426 UTC

[section ""data" . Data.Functor.Const.$fFractionalConst_closure" {
     Data.Functor.Const.$fFractionalConst_closure:
         const Data.Functor.Const.$fFractionalConst_info;
 },
 sat_s752V_entry() //  [R1]
         { info_tbl: [(c75RQ,
                       label: sat_s752V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75RQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75RR; else goto c75RS;
       c75RR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75RS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.fromRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752U_entry() //  [R1]
         { info_tbl: [(c75RX,
                       label: sat_s752U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75RX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75RY; else goto c75RZ;
       c75RY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75RZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752T_entry() //  [R1]
         { info_tbl: [(c75S4,
                       label: sat_s752T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75S4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75S5; else goto c75S6;
       c75S5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75S6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real./_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752S_entry() //  [R1]
         { info_tbl: [(c75Sb,
                       label: sat_s752S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Sb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Sc; else goto c75Sd;
       c75Sc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Sd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fFractionalConst_$cp1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFractionalConst_entry() //  [R2]
         { info_tbl: [(c75Sf,
                       label: Data.Functor.Const.$fFractionalConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Sf: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c75Sj; else goto c75Si;
       c75Sj: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fFractionalConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Si: // global
           I64[Hp - 128] = sat_s752V_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s752U_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s752T_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s752S_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.742747623 UTC

[section ""data" . Data.Functor.Const.$fRealFracConst_$cp2RealFrac_closure" {
     Data.Functor.Const.$fRealFracConst_$cp2RealFrac_closure:
         const Data.Functor.Const.$fRealFracConst_$cp2RealFrac_info;
 },
 sat_s752X_entry() //  [R1]
         { info_tbl: [(c75Ss,
                       label: sat_s752X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ss: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75St; else goto c75Su;
       c75St: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Su: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFracConst_$cp2RealFrac_entry() //  [R2]
         { info_tbl: [(c75Sv,
                       label: Data.Functor.Const.$fRealFracConst_$cp2RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Sv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75Sz; else goto c75Sy;
       c75Sz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFracConst_$cp2RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Sy: // global
           I64[Hp - 16] = sat_s752X_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fFractionalConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.744172941 UTC

[section ""data" . Data.Functor.Const.$fFloatingConst_$cp1Floating_closure" {
     Data.Functor.Const.$fFloatingConst_$cp1Floating_closure:
         const Data.Functor.Const.$fFloatingConst_$cp1Floating_info;
 },
 sat_s752Z_entry() //  [R1]
         { info_tbl: [(c75SI,
                       label: sat_s752Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75SI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75SJ; else goto c75SK;
       c75SJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75SK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFloatingConst_$cp1Floating_entry() //  [R2]
         { info_tbl: [(c75SL,
                       label: Data.Functor.Const.$fFloatingConst_$cp1Floating_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75SL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75SP; else goto c75SO;
       c75SP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fFloatingConst_$cp1Floating_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75SO: // global
           I64[Hp - 16] = sat_s752Z_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fFractionalConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.74824393 UTC

[section ""data" . Data.Functor.Const.$fFloatingConst_closure" {
     Data.Functor.Const.$fFloatingConst_closure:
         const Data.Functor.Const.$fFloatingConst_info;
 },
 sat_s753n_entry() //  [R1]
         { info_tbl: [(c75SY,
                       label: sat_s753n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75SY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75SZ; else goto c75T0;
       c75SZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75T0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1mexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753m_entry() //  [R1]
         { info_tbl: [(c75T5,
                       label: sat_s753m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75T5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75T6; else goto c75T7;
       c75T6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75T7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1pexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753l_entry() //  [R1]
         { info_tbl: [(c75Tc,
                       label: sat_s753l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Tc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Td; else goto c75Te;
       c75Td: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Te: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.expm1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753k_entry() //  [R1]
         { info_tbl: [(c75Tj,
                       label: sat_s753k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Tj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Tk; else goto c75Tl;
       c75Tk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Tl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1p_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753j_entry() //  [R1]
         { info_tbl: [(c75Tq,
                       label: sat_s753j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Tq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Tr; else goto c75Ts;
       c75Tr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Ts: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753i_entry() //  [R1]
         { info_tbl: [(c75Tx,
                       label: sat_s753i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Tx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Ty; else goto c75Tz;
       c75Ty: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Tz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753h_entry() //  [R1]
         { info_tbl: [(c75TE,
                       label: sat_s753h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75TE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75TF; else goto c75TG;
       c75TF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75TG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753g_entry() //  [R1]
         { info_tbl: [(c75TL,
                       label: sat_s753g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75TL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75TM; else goto c75TN;
       c75TM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75TN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753f_entry() //  [R1]
         { info_tbl: [(c75TS,
                       label: sat_s753f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75TS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75TT; else goto c75TU;
       c75TT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75TU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753e_entry() //  [R1]
         { info_tbl: [(c75TZ,
                       label: sat_s753e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75TZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75U0; else goto c75U1;
       c75U0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75U1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753d_entry() //  [R1]
         { info_tbl: [(c75U6,
                       label: sat_s753d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75U6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75U7; else goto c75U8;
       c75U7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75U8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753c_entry() //  [R1]
         { info_tbl: [(c75Ud,
                       label: sat_s753c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ud: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Ue; else goto c75Uf;
       c75Ue: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Uf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753b_entry() //  [R1]
         { info_tbl: [(c75Uk,
                       label: sat_s753b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Uk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Ul; else goto c75Um;
       c75Ul: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Um: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753a_entry() //  [R1]
         { info_tbl: [(c75Ur,
                       label: sat_s753a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ur: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Us; else goto c75Ut;
       c75Us: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Ut: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7539_entry() //  [R1]
         { info_tbl: [(c75Uy,
                       label: sat_s7539_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Uy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Uz; else goto c75UA;
       c75Uz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75UA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7538_entry() //  [R1]
         { info_tbl: [(c75UF,
                       label: sat_s7538_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75UF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75UG; else goto c75UH;
       c75UG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75UH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7537_entry() //  [R1]
         { info_tbl: [(c75UM,
                       label: sat_s7537_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75UM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75UN; else goto c75UO;
       c75UN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75UO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.logBase_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7536_entry() //  [R1]
         { info_tbl: [(c75UT,
                       label: sat_s7536_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75UT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75UU; else goto c75UV;
       c75UU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75UV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.**_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7535_entry() //  [R1]
         { info_tbl: [(c75V0,
                       label: sat_s7535_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75V0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75V1; else goto c75V2;
       c75V1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75V2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sqrt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7534_entry() //  [R1]
         { info_tbl: [(c75V7,
                       label: sat_s7534_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75V7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75V8; else goto c75V9;
       c75V8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75V9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7533_entry() //  [R1]
         { info_tbl: [(c75Ve,
                       label: sat_s7533_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Ve: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Vf; else goto c75Vg;
       c75Vf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Vg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7532_entry() //  [R1]
         { info_tbl: [(c75Vl,
                       label: sat_s7532_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Vl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Vm; else goto c75Vn;
       c75Vm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Vn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.pi_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7531_entry() //  [R1]
         { info_tbl: [(c75Vs,
                       label: sat_s7531_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Vs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Vt; else goto c75Vu;
       c75Vt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Vu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fFloatingConst_$cp1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFloatingConst_entry() //  [R2]
         { info_tbl: [(c75Vw,
                       label: Data.Functor.Const.$fFloatingConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Vw: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto c75VA; else goto c75Vz;
       c75VA: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Const.$fFloatingConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Vz: // global
           I64[Hp - 736] = sat_s753n_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_s753m_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_s753l_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_s753k_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_s753j_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_s753i_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_s753h_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_s753g_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_s753f_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_s753e_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_s753d_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_s753c_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_s753b_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_s753a_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_s7539_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_s7538_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_s7537_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_s7536_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_s7535_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_s7534_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_s7533_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s7532_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s7531_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = GHC.Float.C:Floating_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.755532539 UTC

[section ""data" . Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_closure" {
     Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_closure:
         const Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_info;
 },
 sat_s753p_entry() //  [R1]
         { info_tbl: [(c75VJ,
                       label: sat_s753p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75VJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75VK; else goto c75VL;
       c75VK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75VL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_entry() //  [R2]
         { info_tbl: [(c75VM,
                       label: Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75VM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75VQ; else goto c75VP;
       c75VQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75VP: // global
           I64[Hp - 16] = sat_s753p_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fFloatingConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.757119615 UTC

[section ""data" . Data.Functor.Const.$fEqConst_closure" {
     Data.Functor.Const.$fEqConst_closure:
         const Data.Functor.Const.$fEqConst_info;
 },
 sat_s753s_entry() //  [R1]
         { info_tbl: [(c75VZ,
                       label: sat_s753s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75VZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75W0; else goto c75W1;
       c75W0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75W1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753r_entry() //  [R1]
         { info_tbl: [(c75W6,
                       label: sat_s753r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75W6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75W7; else goto c75W8;
       c75W7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75W8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fEqConst_entry() //  [R2]
         { info_tbl: [(c75Wa,
                       label: Data.Functor.Const.$fEqConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Wa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c75We; else goto c75Wd;
       c75We: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Const.$fEqConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Wd: // global
           I64[Hp - 64] = sat_s753s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s753r_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.758947459 UTC

[section ""data" . Data.Functor.Const.$fOrdConst_$cp1Ord_closure" {
     Data.Functor.Const.$fOrdConst_$cp1Ord_closure:
         const Data.Functor.Const.$fOrdConst_$cp1Ord_info;
 },
 sat_s753u_entry() //  [R1]
         { info_tbl: [(c75Wn,
                       label: sat_s753u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Wn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Wo; else goto c75Wp;
       c75Wo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Wp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fOrdConst_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c75Wq,
                       label: Data.Functor.Const.$fOrdConst_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Wq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75Wu; else goto c75Wt;
       c75Wu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fOrdConst_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Wt: // global
           I64[Hp - 16] = sat_s753u_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fEqConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.761588047 UTC

[section ""data" . Data.Functor.Const.$fOrdConst_closure" {
     Data.Functor.Const.$fOrdConst_closure:
         const Data.Functor.Const.$fOrdConst_info;
 },
 sat_s753D_entry() //  [R1]
         { info_tbl: [(c75WD,
                       label: sat_s753D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75WD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75WE; else goto c75WF;
       c75WE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75WF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753C_entry() //  [R1]
         { info_tbl: [(c75WK,
                       label: sat_s753C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75WK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75WL; else goto c75WM;
       c75WL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75WM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753B_entry() //  [R1]
         { info_tbl: [(c75WR,
                       label: sat_s753B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75WR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75WS; else goto c75WT;
       c75WS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75WT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753A_entry() //  [R1]
         { info_tbl: [(c75WY,
                       label: sat_s753A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75WY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75WZ; else goto c75X0;
       c75WZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75X0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753z_entry() //  [R1]
         { info_tbl: [(c75X5,
                       label: sat_s753z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75X5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75X6; else goto c75X7;
       c75X6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75X7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753y_entry() //  [R1]
         { info_tbl: [(c75Xc,
                       label: sat_s753y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Xc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Xd; else goto c75Xe;
       c75Xd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Xe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753x_entry() //  [R1]
         { info_tbl: [(c75Xj,
                       label: sat_s753x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Xj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Xk; else goto c75Xl;
       c75Xk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Xl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753w_entry() //  [R1]
         { info_tbl: [(c75Xq,
                       label: sat_s753w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Xq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Xr; else goto c75Xs;
       c75Xr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Xs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fOrdConst_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fOrdConst_entry() //  [R2]
         { info_tbl: [(c75Xu,
                       label: Data.Functor.Const.$fOrdConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Xu: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c75Xy; else goto c75Xx;
       c75Xy: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Const.$fOrdConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Xx: // global
           I64[Hp - 256] = sat_s753D_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s753C_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s753B_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s753A_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s753z_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s753y_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s753x_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s753w_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.766249291 UTC

[section ""data" . Data.Functor.Const.$fIxConst_$cp1Ix_closure" {
     Data.Functor.Const.$fIxConst_$cp1Ix_closure:
         const Data.Functor.Const.$fIxConst_$cp1Ix_info;
 },
 sat_s753F_entry() //  [R1]
         { info_tbl: [(c75XH,
                       label: sat_s753F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75XH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75XI; else goto c75XJ;
       c75XI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75XJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.$p1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIxConst_$cp1Ix_entry() //  [R2]
         { info_tbl: [(c75XK,
                       label: Data.Functor.Const.$fIxConst_$cp1Ix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75XK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75XO; else goto c75XN;
       c75XO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fIxConst_$cp1Ix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75XN: // global
           I64[Hp - 16] = sat_s753F_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fOrdConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.768336199 UTC

[section ""data" . Data.Functor.Const.$fIxConst_closure" {
     Data.Functor.Const.$fIxConst_closure:
         const Data.Functor.Const.$fIxConst_info;
 },
 sat_s753N_entry() //  [R1]
         { info_tbl: [(c75XX,
                       label: sat_s753N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75XX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75XY; else goto c75XZ;
       c75XY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75XZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeRangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753M_entry() //  [R1]
         { info_tbl: [(c75Y4,
                       label: sat_s753M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Y4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Y5; else goto c75Y6;
       c75Y5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Y6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.rangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753L_entry() //  [R1]
         { info_tbl: [(c75Yb,
                       label: sat_s753L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Yb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Yc; else goto c75Yd;
       c75Yc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Yd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.inRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753K_entry() //  [R1]
         { info_tbl: [(c75Yi,
                       label: sat_s753K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Yi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Yj; else goto c75Yk;
       c75Yj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Yk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeIndex_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753J_entry() //  [R1]
         { info_tbl: [(c75Yp,
                       label: sat_s753J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Yp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Yq; else goto c75Yr;
       c75Yq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Yr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.index_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753I_entry() //  [R1]
         { info_tbl: [(c75Yw,
                       label: sat_s753I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Yw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Yx; else goto c75Yy;
       c75Yx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Yy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.range_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753H_entry() //  [R1]
         { info_tbl: [(c75YD,
                       label: sat_s753H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75YD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75YE; else goto c75YF;
       c75YE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75YF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fIxConst_$cp1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIxConst_entry() //  [R2]
         { info_tbl: [(c75YH,
                       label: Data.Functor.Const.$fIxConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75YH: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c75YL; else goto c75YK;
       c75YL: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Const.$fIxConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75YK: // global
           I64[Hp - 224] = sat_s753N_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s753M_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s753L_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s753K_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s753J_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s753I_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s753H_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Arr.C:Ix_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.77137702 UTC

[section ""data" . Data.Functor.Const.$fRealConst_$cp2Real_closure" {
     Data.Functor.Const.$fRealConst_$cp2Real_closure:
         const Data.Functor.Const.$fRealConst_$cp2Real_info;
 },
 sat_s753P_entry() //  [R1]
         { info_tbl: [(c75YU,
                       label: sat_s753P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75YU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75YV; else goto c75YW;
       c75YV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75YW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealConst_$cp2Real_entry() //  [R2]
         { info_tbl: [(c75YX,
                       label: Data.Functor.Const.$fRealConst_$cp2Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75YX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75Z1; else goto c75Z0;
       c75Z1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealConst_$cp2Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Z0: // global
           I64[Hp - 16] = sat_s753P_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fOrdConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.772998967 UTC

[section ""data" . Data.Functor.Const.$fRealConst_closure" {
     Data.Functor.Const.$fRealConst_closure:
         const Data.Functor.Const.$fRealConst_info;
 },
 sat_s753T_entry() //  [R1]
         { info_tbl: [(c75Za,
                       label: sat_s753T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Za: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Zb; else goto c75Zc;
       c75Zb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Zc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753S_entry() //  [R1]
         { info_tbl: [(c75Zh,
                       label: sat_s753S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Zh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Zi; else goto c75Zj;
       c75Zi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Zj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealConst_$cp2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753R_entry() //  [R1]
         { info_tbl: [(c75Zo,
                       label: sat_s753R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Zo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75Zp; else goto c75Zq;
       c75Zp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75Zq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealConst_$cp1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealConst_entry() //  [R2]
         { info_tbl: [(c75Zs,
                       label: Data.Functor.Const.$fRealConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75Zs: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c75Zw; else goto c75Zv;
       c75Zw: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75Zv: // global
           I64[Hp - 96] = sat_s753T_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s753S_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s753R_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.774958133 UTC

[section ""data" . Data.Functor.Const.$fIntegralConst_$cp1Integral_closure" {
     Data.Functor.Const.$fIntegralConst_$cp1Integral_closure:
         const Data.Functor.Const.$fIntegralConst_$cp1Integral_info;
 },
 sat_s753V_entry() //  [R1]
         { info_tbl: [(c75ZF,
                       label: sat_s753V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ZF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75ZG; else goto c75ZH;
       c75ZG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75ZH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIntegralConst_$cp1Integral_entry() //  [R2]
         { info_tbl: [(c75ZI,
                       label: Data.Functor.Const.$fIntegralConst_$cp1Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ZI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c75ZM; else goto c75ZL;
       c75ZM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fIntegralConst_$cp1Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c75ZL: // global
           I64[Hp - 16] = sat_s753V_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fRealConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.776421854 UTC

[section ""data" . Data.Functor.Const.$fRealFracConst_$cp1RealFrac_closure" {
     Data.Functor.Const.$fRealFracConst_$cp1RealFrac_closure:
         const Data.Functor.Const.$fRealFracConst_$cp1RealFrac_info;
 },
 sat_s753X_entry() //  [R1]
         { info_tbl: [(c75ZV,
                       label: sat_s753X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ZV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c75ZW; else goto c75ZX;
       c75ZW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c75ZX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFracConst_$cp1RealFrac_entry() //  [R2]
         { info_tbl: [(c75ZY,
                       label: Data.Functor.Const.$fRealFracConst_$cp1RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c75ZY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7602; else goto c7601;
       c7602: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFracConst_$cp1RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7601: // global
           I64[Hp - 16] = sat_s753X_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fRealConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.778615557 UTC

[section ""data" . Data.Functor.Const.$fRealFracConst_closure" {
     Data.Functor.Const.$fRealFracConst_closure:
         const Data.Functor.Const.$fRealFracConst_info;
 },
 sat_s754a_entry() //  [R1, R2]
         { info_tbl: [(c760c,
                       label: sat_s754a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c760c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c760d; else goto c760e;
       c760d: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c760e: // global
           _s7549::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7549::P64;
           Sp = Sp - 16;
           call GHC.Real.floor_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7548_entry() //  [R1, R2]
         { info_tbl: [(c760k,
                       label: sat_s7548_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c760k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c760l; else goto c760m;
       c760l: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c760m: // global
           _s7547::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7547::P64;
           Sp = Sp - 16;
           call GHC.Real.ceiling_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7546_entry() //  [R1, R2]
         { info_tbl: [(c760s,
                       label: sat_s7546_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c760s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c760t; else goto c760u;
       c760t: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c760u: // global
           _s7545::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7545::P64;
           Sp = Sp - 16;
           call GHC.Real.round_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7544_entry() //  [R1, R2]
         { info_tbl: [(c760A,
                       label: sat_s7544_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c760A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c760B; else goto c760C;
       c760B: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c760C: // global
           _s7543::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7543::P64;
           Sp = Sp - 16;
           call GHC.Real.truncate_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7542_entry() //  [R1, R2]
         { info_tbl: [(c760I,
                       label: sat_s7542_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c760I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c760J; else goto c760K;
       c760J: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c760K: // global
           _s7541::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7541::P64;
           Sp = Sp - 16;
           call GHC.Real.properFraction_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7540_entry() //  [R1]
         { info_tbl: [(c760P,
                       label: sat_s7540_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c760P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c760Q; else goto c760R;
       c760Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c760R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFracConst_$cp2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753Z_entry() //  [R1]
         { info_tbl: [(c760W,
                       label: sat_s753Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c760W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c760X; else goto c760Y;
       c760X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c760Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFracConst_$cp1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFracConst_entry() //  [R2]
         { info_tbl: [(c7610,
                       label: Data.Functor.Const.$fRealFracConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7610: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c7614; else goto c7613;
       c7614: // global
           HpAlloc = 192;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFracConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7613: // global
           I64[Hp - 184] = sat_s754a_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s7548_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s7546_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s7544_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s7542_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s7540_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s753Z_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 119;
           P64[Hp - 24] = Hp - 135;
           P64[Hp - 16] = Hp - 151;
           P64[Hp - 8] = Hp - 167;
           P64[Hp] = Hp - 183;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.781833175 UTC

[section ""data" . Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_closure" {
     Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_closure:
         const Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_info;
 },
 sat_s754c_entry() //  [R1]
         { info_tbl: [(c761d,
                       label: sat_s754c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c761d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c761e; else goto c761f;
       c761e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c761f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_entry() //  [R2]
         { info_tbl: [(c761g,
                       label: Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c761g: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c761k; else goto c761j;
       c761k: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c761j: // global
           I64[Hp - 16] = sat_s754c_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fRealFracConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.785072439 UTC

[section ""data" . Data.Functor.Const.$fRealFloatConst_closure" {
     Data.Functor.Const.$fRealFloatConst_closure:
         const Data.Functor.Const.$fRealFloatConst_info;
 },
 sat_s754t_entry() //  [R1]
         { info_tbl: [(c761t,
                       label: sat_s754t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c761t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c761u; else goto c761v;
       c761u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c761v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754s_entry() //  [R1]
         { info_tbl: [(c761A,
                       label: sat_s754s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c761A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c761B; else goto c761C;
       c761B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c761C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isIEEE_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754r_entry() //  [R1]
         { info_tbl: [(c761H,
                       label: sat_s754r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c761H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c761I; else goto c761J;
       c761I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c761J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNegativeZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754q_entry() //  [R1]
         { info_tbl: [(c761O,
                       label: sat_s754q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c761O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c761P; else goto c761Q;
       c761P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c761Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isDenormalized_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754p_entry() //  [R1]
         { info_tbl: [(c761V,
                       label: sat_s754p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c761V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c761W; else goto c761X;
       c761W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c761X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isInfinite_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754o_entry() //  [R1]
         { info_tbl: [(c7622,
                       label: sat_s754o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7622: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7623; else goto c7624;
       c7623: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7624: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNaN_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754n_entry() //  [R1]
         { info_tbl: [(c7629,
                       label: sat_s754n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7629: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c762a; else goto c762b;
       c762a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c762b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.scaleFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754m_entry() //  [R1]
         { info_tbl: [(c762g,
                       label: sat_s754m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c762g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c762h; else goto c762i;
       c762h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c762i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.significand_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754l_entry() //  [R1]
         { info_tbl: [(c762n,
                       label: sat_s754l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c762n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c762o; else goto c762p;
       c762o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c762p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exponent_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754k_entry() //  [R1]
         { info_tbl: [(c762u,
                       label: sat_s754k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c762u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c762v; else goto c762w;
       c762v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c762w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.encodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754j_entry() //  [R1]
         { info_tbl: [(c762B,
                       label: sat_s754j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c762B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c762C; else goto c762D;
       c762C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c762D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.decodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754i_entry() //  [R1]
         { info_tbl: [(c762I,
                       label: sat_s754i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c762I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c762J; else goto c762K;
       c762J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c762K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754h_entry() //  [R1]
         { info_tbl: [(c762P,
                       label: sat_s754h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c762P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c762Q; else goto c762R;
       c762Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c762R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatDigits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754g_entry() //  [R1]
         { info_tbl: [(c762W,
                       label: sat_s754g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c762W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c762X; else goto c762Y;
       c762X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c762Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRadix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754f_entry() //  [R1]
         { info_tbl: [(c7633,
                       label: sat_s754f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7633: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7634; else goto c7635;
       c7634: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7635: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754e_entry() //  [R1]
         { info_tbl: [(c763a,
                       label: sat_s754e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c763a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c763b; else goto c763c;
       c763b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c763c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFloatConst_entry() //  [R2]
         { info_tbl: [(c763e,
                       label: Data.Functor.Const.$fRealFloatConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c763e: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto c763i; else goto c763h;
       c763i: // global
           HpAlloc = 520;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFloatConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c763h: // global
           I64[Hp - 512] = sat_s754t_info;
           P64[Hp - 496] = R2;
           I64[Hp - 488] = sat_s754s_info;
           P64[Hp - 472] = R2;
           I64[Hp - 464] = sat_s754r_info;
           P64[Hp - 448] = R2;
           I64[Hp - 440] = sat_s754q_info;
           P64[Hp - 424] = R2;
           I64[Hp - 416] = sat_s754p_info;
           P64[Hp - 400] = R2;
           I64[Hp - 392] = sat_s754o_info;
           P64[Hp - 376] = R2;
           I64[Hp - 368] = sat_s754n_info;
           P64[Hp - 352] = R2;
           I64[Hp - 344] = sat_s754m_info;
           P64[Hp - 328] = R2;
           I64[Hp - 320] = sat_s754l_info;
           P64[Hp - 304] = R2;
           I64[Hp - 296] = sat_s754k_info;
           P64[Hp - 280] = R2;
           I64[Hp - 272] = sat_s754j_info;
           P64[Hp - 256] = R2;
           I64[Hp - 248] = sat_s754i_info;
           P64[Hp - 232] = R2;
           I64[Hp - 224] = sat_s754h_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s754g_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s754f_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s754e_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = GHC.Float.C:RealFloat_con_info;
           P64[Hp - 120] = Hp - 152;
           P64[Hp - 112] = Hp - 176;
           P64[Hp - 104] = Hp - 200;
           P64[Hp - 96] = Hp - 224;
           P64[Hp - 88] = Hp - 248;
           P64[Hp - 80] = Hp - 272;
           P64[Hp - 72] = Hp - 296;
           P64[Hp - 64] = Hp - 320;
           P64[Hp - 56] = Hp - 344;
           P64[Hp - 48] = Hp - 368;
           P64[Hp - 40] = Hp - 392;
           P64[Hp - 32] = Hp - 416;
           P64[Hp - 24] = Hp - 440;
           P64[Hp - 16] = Hp - 464;
           P64[Hp - 8] = Hp - 488;
           P64[Hp] = Hp - 512;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.79153968 UTC

[section ""data" . Data.Functor.Const.$fEnumConst_closure" {
     Data.Functor.Const.$fEnumConst_closure:
         const Data.Functor.Const.$fEnumConst_info;
 },
 sat_s754C_entry() //  [R1]
         { info_tbl: [(c763r,
                       label: sat_s754C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c763r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c763s; else goto c763t;
       c763s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c763t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754B_entry() //  [R1]
         { info_tbl: [(c763y,
                       label: sat_s754B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c763y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c763z; else goto c763A;
       c763z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c763A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754A_entry() //  [R1]
         { info_tbl: [(c763F,
                       label: sat_s754A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c763F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c763G; else goto c763H;
       c763G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c763H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754z_entry() //  [R1]
         { info_tbl: [(c763M,
                       label: sat_s754z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c763M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c763N; else goto c763O;
       c763N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c763O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754y_entry() //  [R1]
         { info_tbl: [(c763T,
                       label: sat_s754y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c763T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c763U; else goto c763V;
       c763U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c763V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.fromEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754x_entry() //  [R1]
         { info_tbl: [(c7640,
                       label: sat_s754x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7640: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7641; else goto c7642;
       c7641: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7642: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.toEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754w_entry() //  [R1]
         { info_tbl: [(c7647,
                       label: sat_s754w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7647: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7648; else goto c7649;
       c7648: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7649: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.pred_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754v_entry() //  [R1]
         { info_tbl: [(c764e,
                       label: sat_s754v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c764e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c764f; else goto c764g;
       c764f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c764g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.succ_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fEnumConst_entry() //  [R2]
         { info_tbl: [(c764i,
                       label: Data.Functor.Const.$fEnumConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c764i: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c764m; else goto c764l;
       c764m: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Const.$fEnumConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c764l: // global
           I64[Hp - 256] = sat_s754C_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s754B_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s754A_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s754z_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s754y_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s754x_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s754w_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s754v_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.795037409 UTC

[section ""data" . Data.Functor.Const.$fIntegralConst_$cp2Integral_closure" {
     Data.Functor.Const.$fIntegralConst_$cp2Integral_closure:
         const Data.Functor.Const.$fIntegralConst_$cp2Integral_info;
 },
 sat_s754E_entry() //  [R1]
         { info_tbl: [(c764v,
                       label: sat_s754E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c764v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c764w; else goto c764x;
       c764w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c764x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIntegralConst_$cp2Integral_entry() //  [R2]
         { info_tbl: [(c764y,
                       label: Data.Functor.Const.$fIntegralConst_$cp2Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c764y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c764C; else goto c764B;
       c764C: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fIntegralConst_$cp2Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c764B: // global
           I64[Hp - 16] = sat_s754E_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fEnumConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.799086887 UTC

[section ""data" . Data.Functor.Const.$fIntegralConst_closure" {
     Data.Functor.Const.$fIntegralConst_closure:
         const Data.Functor.Const.$fIntegralConst_info;
 },
 sat_s754O_entry() //  [R1]
         { info_tbl: [(c764L,
                       label: sat_s754O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c764L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c764M; else goto c764N;
       c764M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c764N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754N_entry() //  [R1]
         { info_tbl: [(c764S,
                       label: sat_s754N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c764S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c764T; else goto c764U;
       c764T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c764U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.divMod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754M_entry() //  [R1]
         { info_tbl: [(c764Z,
                       label: sat_s754M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c764Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7650; else goto c7651;
       c7650: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7651: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quotRem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754L_entry() //  [R1]
         { info_tbl: [(c7656,
                       label: sat_s754L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7656: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7657; else goto c7658;
       c7657: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7658: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.mod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754K_entry() //  [R1]
         { info_tbl: [(c765d,
                       label: sat_s754K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c765d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c765e; else goto c765f;
       c765e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c765f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.div_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754J_entry() //  [R1]
         { info_tbl: [(c765k,
                       label: sat_s754J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c765k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c765l; else goto c765m;
       c765l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c765m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.rem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754I_entry() //  [R1]
         { info_tbl: [(c765r,
                       label: sat_s754I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c765r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c765s; else goto c765t;
       c765s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c765t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quot_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754H_entry() //  [R1]
         { info_tbl: [(c765y,
                       label: sat_s754H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c765y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c765z; else goto c765A;
       c765z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c765A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fIntegralConst_$cp2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754G_entry() //  [R1]
         { info_tbl: [(c765F,
                       label: sat_s754G_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c765F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c765G; else goto c765H;
       c765G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c765H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fIntegralConst_$cp1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIntegralConst_entry() //  [R2]
         { info_tbl: [(c765J,
                       label: Data.Functor.Const.$fIntegralConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c765J: // global
           Hp = Hp + 296;
           if (Hp > HpLim) (likely: False) goto c765N; else goto c765M;
       c765N: // global
           HpAlloc = 296;
           R2 = R2;
           R1 = Data.Functor.Const.$fIntegralConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c765M: // global
           I64[Hp - 288] = sat_s754O_info;
           P64[Hp - 272] = R2;
           I64[Hp - 264] = sat_s754N_info;
           P64[Hp - 248] = R2;
           I64[Hp - 240] = sat_s754M_info;
           P64[Hp - 224] = R2;
           I64[Hp - 216] = sat_s754L_info;
           P64[Hp - 200] = R2;
           I64[Hp - 192] = sat_s754K_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s754J_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s754I_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s754H_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s754G_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = GHC.Real.C:Integral_con_info;
           P64[Hp - 64] = Hp - 96;
           P64[Hp - 56] = Hp - 120;
           P64[Hp - 48] = Hp - 144;
           P64[Hp - 40] = Hp - 168;
           P64[Hp - 32] = Hp - 192;
           P64[Hp - 24] = Hp - 216;
           P64[Hp - 16] = Hp - 240;
           P64[Hp - 8] = Hp - 264;
           P64[Hp] = Hp - 288;
           R1 = Hp - 71;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.802764175 UTC

[section ""data" . Data.Functor.Const.$fBoundedConst_closure" {
     Data.Functor.Const.$fBoundedConst_closure:
         const Data.Functor.Const.$fBoundedConst_info;
 },
 sat_s754R_entry() //  [R1]
         { info_tbl: [(c765W,
                       label: sat_s754R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c765W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c765X; else goto c765Y;
       c765X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c765Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754Q_entry() //  [R1]
         { info_tbl: [(c7663,
                       label: sat_s754Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7663: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7664; else goto c7665;
       c7664: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7665: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fBoundedConst_entry() //  [R2]
         { info_tbl: [(c7667,
                       label: Data.Functor.Const.$fBoundedConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7667: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c766b; else goto c766a;
       c766b: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Const.$fBoundedConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c766a: // global
           I64[Hp - 64] = sat_s754R_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s754Q_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.804395038 UTC

[section ""data" . Data.Functor.Const.$fBitsConst_$cp1Bits_closure" {
     Data.Functor.Const.$fBitsConst_$cp1Bits_closure:
         const Data.Functor.Const.$fBitsConst_$cp1Bits_info;
 },
 sat_s754T_entry() //  [R1]
         { info_tbl: [(c766k,
                       label: sat_s754T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c766k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c766l; else goto c766m;
       c766l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c766m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fBitsConst_$cp1Bits_entry() //  [R2]
         { info_tbl: [(c766n,
                       label: Data.Functor.Const.$fBitsConst_$cp1Bits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c766n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c766r; else goto c766q;
       c766r: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fBitsConst_$cp1Bits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c766q: // global
           I64[Hp - 16] = sat_s754T_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fEqConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.808435407 UTC

[section ""data" . Data.Functor.Const.$fBitsConst_closure" {
     Data.Functor.Const.$fBitsConst_closure:
         const Data.Functor.Const.$fBitsConst_info;
 },
 sat_s755h_entry() //  [R1]
         { info_tbl: [(c766A,
                       label: sat_s755h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c766A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c766B; else goto c766C;
       c766B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c766C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.popCount_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755g_entry() //  [R1]
         { info_tbl: [(c766H,
                       label: sat_s755g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c766H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c766I; else goto c766J;
       c766I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c766J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755f_entry() //  [R1]
         { info_tbl: [(c766O,
                       label: sat_s755f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c766O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c766P; else goto c766Q;
       c766P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c766Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755e_entry() //  [R1]
         { info_tbl: [(c766V,
                       label: sat_s755e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c766V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c766W; else goto c766X;
       c766W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c766X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755d_entry() //  [R1]
         { info_tbl: [(c7672,
                       label: sat_s755d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7672: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7673; else goto c7674;
       c7673: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7674: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755c_entry() //  [R1]
         { info_tbl: [(c7679,
                       label: sat_s755c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7679: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c767a; else goto c767b;
       c767a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c767b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755b_entry() //  [R1]
         { info_tbl: [(c767g,
                       label: sat_s755b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c767g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c767h; else goto c767i;
       c767h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c767i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755a_entry() //  [R1]
         { info_tbl: [(c767n,
                       label: sat_s755a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c767n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c767o; else goto c767p;
       c767o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c767p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.isSigned_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7559_entry() //  [R1]
         { info_tbl: [(c767u,
                       label: sat_s7559_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c767u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c767v; else goto c767w;
       c767v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c767w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7558_entry() //  [R1]
         { info_tbl: [(c767B,
                       label: sat_s7558_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c767B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c767C; else goto c767D;
       c767C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c767D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7557_entry() //  [R1]
         { info_tbl: [(c767I,
                       label: sat_s7557_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c767I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c767J; else goto c767K;
       c767J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c767K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.testBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7556_entry() //  [R1]
         { info_tbl: [(c767P,
                       label: sat_s7556_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c767P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c767Q; else goto c767R;
       c767Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c767R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complementBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7555_entry() //  [R1]
         { info_tbl: [(c767W,
                       label: sat_s7555_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c767W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c767X; else goto c767Y;
       c767X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c767Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.clearBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7554_entry() //  [R1]
         { info_tbl: [(c7683,
                       label: sat_s7554_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7683: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7684; else goto c7685;
       c7684: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7685: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.setBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7553_entry() //  [R1]
         { info_tbl: [(c768a,
                       label: sat_s7553_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c768a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c768b; else goto c768c;
       c768b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c768c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7552_entry() //  [R1]
         { info_tbl: [(c768h,
                       label: sat_s7552_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c768h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c768i; else goto c768j;
       c768i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c768j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.zeroBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7551_entry() //  [R1]
         { info_tbl: [(c768o,
                       label: sat_s7551_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c768o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c768p; else goto c768q;
       c768p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c768q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7550_entry() //  [R1]
         { info_tbl: [(c768v,
                       label: sat_s7550_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c768v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c768w; else goto c768x;
       c768w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c768x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shift_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754Z_entry() //  [R1]
         { info_tbl: [(c768C,
                       label: sat_s754Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c768C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c768D; else goto c768E;
       c768D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c768E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complement_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754Y_entry() //  [R1]
         { info_tbl: [(c768J,
                       label: sat_s754Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c768J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c768K; else goto c768L;
       c768K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c768L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.xor_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754X_entry() //  [R1]
         { info_tbl: [(c768Q,
                       label: sat_s754X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c768Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c768R; else goto c768S;
       c768R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c768S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..|._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754W_entry() //  [R1]
         { info_tbl: [(c768X,
                       label: sat_s754W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c768X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c768Y; else goto c768Z;
       c768Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c768Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..&._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754V_entry() //  [R1]
         { info_tbl: [(c7694,
                       label: sat_s754V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7694: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7695; else goto c7696;
       c7695: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7696: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fBitsConst_$cp1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fBitsConst_entry() //  [R2]
         { info_tbl: [(c7698,
                       label: Data.Functor.Const.$fBitsConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7698: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto c769c; else goto c769b;
       c769c: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Const.$fBitsConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c769b: // global
           I64[Hp - 736] = sat_s755h_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_s755g_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_s755f_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_s755e_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_s755d_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_s755c_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_s755b_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_s755a_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_s7559_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_s7558_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_s7557_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_s7556_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_s7555_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_s7554_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_s7553_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_s7552_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_s7551_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_s7550_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_s754Z_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_s754Y_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_s754X_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s754W_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s754V_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = Data.Bits.C:Bits_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.815484334 UTC

[section ""data" . Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_closure" {
     Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_closure:
         const Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_info;
 },
 sat_s755j_entry() //  [R1]
         { info_tbl: [(c769l,
                       label: sat_s755j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c769l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c769m; else goto c769n;
       c769m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c769n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_entry() //  [R2]
         { info_tbl: [(c769o,
                       label: Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c769o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c769s; else goto c769r;
       c769s: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c769r: // global
           I64[Hp - 16] = sat_s755j_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fBitsConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.81723101 UTC

[section ""data" . Data.Functor.Const.$fFiniteBitsConst_closure" {
     Data.Functor.Const.$fFiniteBitsConst_closure:
         const Data.Functor.Const.$fFiniteBitsConst_info;
 },
 sat_s755o_entry() //  [R1]
         { info_tbl: [(c769B,
                       label: sat_s755o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c769B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c769C; else goto c769D;
       c769C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c769D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countTrailingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755n_entry() //  [R1]
         { info_tbl: [(c769I,
                       label: sat_s755n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c769I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c769J; else goto c769K;
       c769J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c769K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countLeadingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755m_entry() //  [R1]
         { info_tbl: [(c769P,
                       label: sat_s755m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c769P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c769Q; else goto c769R;
       c769Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c769R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755l_entry() //  [R1]
         { info_tbl: [(c769W,
                       label: sat_s755l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c769W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c769X; else goto c769Y;
       c769X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c769Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFiniteBitsConst_entry() //  [R2]
         { info_tbl: [(c76a0,
                       label: Data.Functor.Const.$fFiniteBitsConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76a0: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c76a4; else goto c76a3;
       c76a4: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fFiniteBitsConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76a3: // global
           I64[Hp - 128] = sat_s755o_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s755n_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s755m_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s755l_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Bits.C:FiniteBits_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.81935191 UTC

[section ""data" . Data.Functor.Const.getConst1_closure" {
     Data.Functor.Const.getConst1_closure:
         const Data.Functor.Const.getConst1_info;
 },
 Data.Functor.Const.getConst1_entry() //  [R2]
         { info_tbl: [(c76a9,
                       label: Data.Functor.Const.getConst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76a9: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.820242747 UTC

[section ""data" . Data.Functor.Const.getConst_closure" {
     Data.Functor.Const.getConst_closure:
         const Data.Functor.Const.getConst_info;
 },
 Data.Functor.Const.getConst_entry() //  [R2]
         { info_tbl: [(c76ag,
                       label: Data.Functor.Const.getConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76ag: // global
           R2 = R2;
           call Data.Functor.Const.getConst1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.821078398 UTC

[section ""cstring" . Data.Functor.Const.$trModule4_bytes" {
     Data.Functor.Const.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.821879037 UTC

[section ""data" . Data.Functor.Const.$trModule3_closure" {
     Data.Functor.Const.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.822504224 UTC

[section ""cstring" . Data.Functor.Const.$trModule2_bytes" {
     Data.Functor.Const.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.82312314 UTC

[section ""data" . Data.Functor.Const.$trModule1_closure" {
     Data.Functor.Const.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.823761967 UTC

[section ""data" . Data.Functor.Const.$trModule_closure" {
     Data.Functor.Const.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Const.$trModule3_closure+1;
         const Data.Functor.Const.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.824425766 UTC

[section ""data" . $krep_r74ZT_closure" {
     $krep_r74ZT_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.825126134 UTC

[section ""data" . $krep1_r74ZU_closure" {
     $krep1_r74ZU_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.825872525 UTC

[section ""data" . $krep2_r74ZV_closure" {
     $krep2_r74ZV_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r74ZU_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.826556375 UTC

[section ""data" . Data.Functor.Const.$tcConst1_closure" {
     Data.Functor.Const.$tcConst1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep2_r74ZV_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.827230907 UTC

[section ""data" . $krep3_r74ZW_closure" {
     $krep3_r74ZW_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.827968097 UTC

[section ""data" . Data.Functor.Const.$tcConst2_closure" {
     Data.Functor.Const.$tcConst2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$fReadConst5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.83013742 UTC

[section ""data" . Data.Functor.Const.$tcConst_closure" {
     Data.Functor.Const.$tcConst_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Const.$trModule_closure+1;
         const Data.Functor.Const.$tcConst2_closure+1;
         const Data.Functor.Const.$tcConst1_closure+4;
         const 18204097321285842582;
         const 16882168546145866005;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.83079681 UTC

[section ""data" . $krep4_r74ZX_closure" {
     $krep4_r74ZX_closure:
         const :_con_info;
         const $krep3_r74ZW_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.831416064 UTC

[section ""data" . $krep5_r74ZY_closure" {
     $krep5_r74ZY_closure:
         const :_con_info;
         const $krep_r74ZT_closure+2;
         const $krep4_r74ZX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.832015048 UTC

[section ""data" . $krep6_r74ZZ_closure" {
     $krep6_r74ZZ_closure:
         const :_con_info;
         const $krep1_r74ZU_closure+2;
         const $krep5_r74ZY_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.832623267 UTC

[section ""data" . $krep7_r7500_closure" {
     $krep7_r7500_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Const.$tcConst_closure+1;
         const $krep6_r74ZZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.833438972 UTC

[section ""data" . Data.Functor.Const.$tc'Const1_closure" {
     Data.Functor.Const.$tc'Const1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r74ZT_closure+2;
         const $krep7_r7500_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.83401466 UTC

[section ""cstring" . Data.Functor.Const.$tc'Const3_bytes" {
     Data.Functor.Const.$tc'Const3_bytes:
         I8[] [39,67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.83458988 UTC

[section ""data" . Data.Functor.Const.$tc'Const2_closure" {
     Data.Functor.Const.$tc'Const2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$tc'Const3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.835194846 UTC

[section ""data" . Data.Functor.Const.$tc'Const_closure" {
     Data.Functor.Const.$tc'Const_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Const.$trModule_closure+1;
         const Data.Functor.Const.$tc'Const2_closure+1;
         const Data.Functor.Const.$tc'Const1_closure+4;
         const 9035619270378585414;
         const 9797261638746114088;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.835845828 UTC

[section ""relreadonly" . S757l_srt" {
     S757l_srt:
         const Data.Functor.Const.$fReadConst4_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Data.Functor.Const.$w$creadsPrec_closure;
         const Data.Functor.Const.$fReadConst_$creadsPrec_closure;
         const Data.Functor.Const.$fReadConst2_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Const.$fReadConst_$creadList_closure;
         const Data.Functor.Const.$w$creadListPrec_closure;
         const Data.Functor.Const.$fReadConst_closure;
         const Data.Functor.Const.$fShowConst1_closure;
         const Data.Functor.Const.$w$cshowsPrec_closure;
         const Data.Functor.Const.$fShowConst_$cshowsPrec_closure;
         const Data.Functor.Const.$fShowConst_$cshow_closure;
         const Data.Functor.Const.$fShowConst_$cshowList_closure;
         const Data.Functor.Const.$fShowConst_closure;
         const Data.Semigroup.Internal.$fMonoidSum2_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Const.$fFoldableConst1_closure;
         const Data.Functor.Const.$fFoldableConst3_closure;
         const Data.Functor.Const.$fFoldableConst6_closure;
         const Data.Functor.Const.$fFoldableConst8_closure;
         const Data.Semigroup.Internal.$fMonoidProduct2_closure;
         const Data.Functor.Const.$fApplicativeConst_closure;
         const Data.Functor.Const.$fFunctorConst_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.836900591 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:20.838242096 UTC

[section ""data" . Data.Functor.Const.$fReadConst3_closure" {
     Data.Functor.Const.$fReadConst3_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.840221468 UTC

[section ""cstring" . Data.Functor.Const.$fReadConst5_bytes" {
     Data.Functor.Const.$fReadConst5_bytes:
         I8[] [67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.842489169 UTC

[section ""data" . Data.Functor.Const.$fReadConst4_closure" {
     Data.Functor.Const.$fReadConst4_closure:
         const Data.Functor.Const.$fReadConst4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fReadConst4_entry() //  [R1]
         { info_tbl: [(c76ar,
                       label: Data.Functor.Const.$fReadConst4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76ar: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76as; else goto c76at;
       c76as: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76at: // global
           (_c76ao::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c76ao::I64 == 0) goto c76aq; else goto c76ap;
       c76aq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c76ap: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c76ao::I64;
           R2 = Data.Functor.Const.$fReadConst5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.849073247 UTC

[section ""data" . Data.Functor.Const.$w$creadsPrec_closure" {
     Data.Functor.Const.$w$creadsPrec_closure:
         const Data.Functor.Const.$w$creadsPrec_info;
         const 0;
 },
 go1_s750f_entry() //  [R1, R2]
         { info_tbl: [(c76bd,
                       label: go1_s750f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76bd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c76be; else goto c76bf;
       c76be: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76bf: // global
           I64[Sp - 24] = block_c76b6_info;
           _s750f::P64 = R1;
           _s750e::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s750e::P64;
           P64[Sp - 8] = _s750f::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u76bx; else goto c76b7;
       u76bx: // global
           call _c76b6(R1) args: 0, res: 0, upd: 0;
       c76b7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c76b6() //  [R1]
         { info_tbl: [(c76b6,
                       label: block_c76b6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76b6: // global
           if (R1 & 7 == 1) goto c76ba; else goto c76bb;
       c76ba: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c76bb: // global
           I64[Sp] = block_c76bl_info;
           _s750j::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _s750j::P64;
           if (R1 & 7 != 0) goto u76bw; else goto c76bm;
       u76bw: // global
           call _c76bl(R1) args: 0, res: 0, upd: 0;
       c76bm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c76bl() //  [R1]
         { info_tbl: [(c76bl,
                       label: block_c76bl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76bl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c76bv; else goto c76bu;
       c76bv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c76bu: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s7505_entry() //  [R1, R2]
         { info_tbl: [(c76bC,
                       label: go_s7505_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76bC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c76bD; else goto u76bX;
       c76bD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u76bX: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _c76aH() args: 0, res: 0, upd: 0;
     }
 },
 _c76aH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76aH: // global
           _s7502::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_c76aK_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7502::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u76bZ; else goto c76aL;
       u76bZ: // global
           call _c76aK(R1) args: 0, res: 0, upd: 0;
       c76aL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c76aK() //  [R1]
         { info_tbl: [(c76aK,
                       label: block_c76aK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76aK: // global
           if (R1 & 7 == 1) goto c76bz; else goto c76bA;
       c76bz: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c76bA: // global
           I64[Sp - 8] = block_c76aQ_info;
           _s7509::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s7509::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u76c0; else goto c76aR;
       u76c0: // global
           call _c76aQ(R1) args: 0, res: 0, upd: 0;
       c76aR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c76aQ() //  [R1]
         { info_tbl: [(c76aQ,
                       label: block_c76aQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76aQ: // global
           I64[Sp - 8] = block_c76aV_info;
           R3 = Data.Functor.Const.$fReadConst4_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c76aV() //  [R1]
         { info_tbl: [(c76aV,
                       label: block_c76aV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76aV: // global
           _s7509::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c76bM; else goto c76bO;
       c76bM: // global
           P64[Sp + 32] = _s7509::P64;
           Sp = Sp + 24;
           call _c76aH() args: 0, res: 0, upd: 0;
       c76bO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c76bR; else goto c76bQ;
       c76bR: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c76bQ: // global
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _s7509::P64;
           I64[Hp - 8] = go1_s750f_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 24] = block_c76bN_info;
           R2 = P64[Sp + 32];
           I64[Sp] = stg_ap_pp_info;
           _s750c::P64 = P64[Sp + 8];
           P64[Sp + 8] = Data.Functor.Const.$fReadConst3_closure+1;
           P64[Sp + 16] = _s750c::P64;
           P64[Sp + 32] = Hp - 7;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c76bN() //  [R1]
         { info_tbl: [(c76bN,
                       label: block_c76bN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76bN: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_s750f_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750u_entry() //  [R1, R2]
         { info_tbl: [(c76ca,
                       label: sat_s750u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76ca: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76cb; else goto c76cc;
       c76cb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76cc: // global
           I64[Sp - 16] = block_c76c8_info;
           R3 = R2;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c76c8() //  [R1]
         { info_tbl: [(c76c8,
                       label: block_c76c8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76c8: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s7505_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$w$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c76ci,
                       label: Data.Functor.Const.$w$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76ci: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c76cm; else goto c76cl;
       c76cm: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$w$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c76cl: // global
           I64[Hp - 24] = go_s7505_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s750u_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           _s750r::P64 = I64[(%MO_S_Gt_W64(R3,
                                           10) << 3) + GHC.Types.Bool_closure_tbl];
           R3 = Hp - 7;
           R2 = _s750r::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.877037488 UTC

[section ""data" . Data.Functor.Const.$fReadConst_$creadsPrec_closure" {
     Data.Functor.Const.$fReadConst_$creadsPrec_closure:
         const Data.Functor.Const.$fReadConst_$creadsPrec_info;
         const 0;
 },
 Data.Functor.Const.$fReadConst_$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c76dx,
                       label: Data.Functor.Const.$fReadConst_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76dx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c76dy; else goto c76dz;
       c76dy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fReadConst_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c76dz: // global
           I64[Sp - 24] = block_c76du_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u76dD; else goto c76dv;
       u76dD: // global
           call _c76du(R1) args: 0, res: 0, upd: 0;
       c76dv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c76du() //  [R1]
         { info_tbl: [(c76du,
                       label: block_c76du_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76du: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Const.$w$creadsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.883968464 UTC

[section ""data" . Data.Functor.Const.$fReadConst2_closure" {
     Data.Functor.Const.$fReadConst2_closure:
         const Data.Functor.Const.$fReadConst2_info;
         const 0;
 },
 sat_s750D_entry() //  [R1, R2]
         { info_tbl: [(c76dW,
                       label: sat_s750D_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76dW: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Const.$fReadConst_$creadsPrec_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fReadConst2_entry() //  [R2, R3, R4]
         { info_tbl: [(c76e2,
                       label: Data.Functor.Const.$fReadConst2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76e2: // global
           _s750C::P64 = R4;
           _s750B::P64 = R3;
           _s750A::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c76e3; else goto c76e4;
       c76e4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76e6; else goto c76e5;
       c76e6: // global
           HpAlloc = 24;
           goto c76e3;
       c76e3: // global
           R4 = _s750C::P64;
           R3 = _s750B::P64;
           R2 = _s750A::P64;
           R1 = Data.Functor.Const.$fReadConst2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c76e5: // global
           I64[Hp - 16] = sat_s750D_info;
           P64[Hp - 8] = _s750A::P64;
           P64[Hp] = _s750B::P64;
           I64[Sp - 8] = block_c76dZ_info;
           R3 = _s750C::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c76dZ() //  [R1]
         { info_tbl: [(c76dZ,
                       label: block_c76dZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76dZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c76e9; else goto c76e8;
       c76e9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c76e8: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.893796312 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst5_closure" {
     Data.Functor.Const.$fFoldableConst5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.89617104 UTC

[section ""data" . Data.Functor.Const.$fReadConst_$creadList_closure" {
     Data.Functor.Const.$fReadConst_$creadList_closure:
         const Data.Functor.Const.$fReadConst_$creadList_info;
         const 0;
 },
 sat_s750H_entry() //  [R1, R2, R3]
         { info_tbl: [(c76eA,
                       label: sat_s750H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76eA: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750I_entry() //  [R1]
         { info_tbl: [(c76eD,
                       label: sat_s750I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76eD: // global
           _s750I::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c76eE; else goto c76eF;
       c76eF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c76eH; else goto c76eG;
       c76eH: // global
           HpAlloc = 16;
           goto c76eE;
       c76eE: // global
           R1 = _s750I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76eG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s750I::P64;
           _s750G::P64 = P64[_s750I::P64 + 16];
           I64[Hp - 8] = sat_s750H_info;
           P64[Hp] = _s750G::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Const.$fFoldableConst5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fReadConst_$creadList_entry() //  [R2]
         { info_tbl: [(c76eI,
                       label: Data.Functor.Const.$fReadConst_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76eI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76eM; else goto c76eL;
       c76eM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fReadConst_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76eL: // global
           I64[Hp - 16] = sat_s750I_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.904915068 UTC

[section ""data" . Data.Functor.Const.$w$creadListPrec_closure" {
     Data.Functor.Const.$w$creadListPrec_closure:
         const Data.Functor.Const.$w$creadListPrec_info;
         const 0;
 },
 sat_s750L_entry() //  [R1, R2, R3]
         { info_tbl: [(c76fb,
                       label: sat_s750L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76fb: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 w1_s750K_entry() //  [R1]
         { info_tbl: [(c76fe,
                       label: w1_s750K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76fe: // global
           _s750K::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c76ff; else goto c76fg;
       c76fg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c76fi; else goto c76fh;
       c76fi: // global
           HpAlloc = 16;
           goto c76ff;
       c76ff: // global
           R1 = _s750K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76fh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s750K::P64;
           _s750J::P64 = P64[_s750K::P64 + 16];
           I64[Hp - 8] = sat_s750L_info;
           P64[Hp] = _s750J::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Const.$fFoldableConst5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 w2_s750M_entry() //  [R1, R2]
         { info_tbl: [(c76fo,
                       label: w2_s750M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76fo: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750Q_entry() //  [R1, R2]
         { info_tbl: [(c76fz,
                       label: sat_s750Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76fz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c76fA; else goto c76fB;
       c76fA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76fB: // global
           I64[Sp - 8] = block_c76fw_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c76fw() //  [R1]
         { info_tbl: [(c76fw,
                       label: block_c76fw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76fw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c76fE; else goto c76fD;
       c76fE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c76fD: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$w$creadListPrec_entry() //  [R2]
         { info_tbl: [(c76fF,
                       label: Data.Functor.Const.$w$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76fF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c76fJ; else goto c76fI;
       c76fJ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Const.$w$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76fI: // global
           I64[Hp - 48] = w1_s750K_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = w2_s750M_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s750Q_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.918976756 UTC

[section ""data" . Data.Functor.Const.$fReadConst1_closure" {
     Data.Functor.Const.$fReadConst1_closure:
         const Data.Functor.Const.$fReadConst1_info;
         const 0;
 },
 Data.Functor.Const.$fReadConst1_entry() //  [R2]
         { info_tbl: [(c76gd,
                       label: Data.Functor.Const.$fReadConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76gd: // global
           R2 = R2;
           call Data.Functor.Const.$w$creadListPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.92378734 UTC

[section ""data" . Data.Functor.Const.$fReadConst_closure" {
     Data.Functor.Const.$fReadConst_closure:
         const Data.Functor.Const.$fReadConst_info;
         const 0;
 },
 lvl_s750U_entry() //  [R1]
         { info_tbl: [(c76gs,
                       label: lvl_s750U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76gs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76gt; else goto c76gu;
       c76gt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76gu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$w$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s750Z_entry() //  [R1]
         { info_tbl: [(c76gA,
                       label: sat_s750Z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76gA: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750X_entry() //  [R1, R2, R3]
         { info_tbl: [(c76gI,
                       label: sat_s750X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76gI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s750W_entry() //  [R1]
         { info_tbl: [(c76gP,
                       label: sat_s750W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76gP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76gQ; else goto c76gR;
       c76gQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76gR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fReadConst_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s750V_entry() //  [R1, R2, R3]
         { info_tbl: [(c76gX,
                       label: sat_s750V_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76gX: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst_$creadsPrec_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fReadConst_entry() //  [R2]
         { info_tbl: [(c76h1,
                       label: Data.Functor.Const.$fReadConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76h1: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c76h5; else goto c76h4;
       c76h5: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fReadConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76h4: // global
           I64[Hp - 128] = lvl_s750U_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s750Z_info;
           P64[Hp - 96] = Hp - 128;
           I64[Hp - 88] = sat_s750X_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s750W_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s750V_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 46;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.936227314 UTC

[section ""cstring" . Data.Functor.Const.$fShowConst2_bytes" {
     Data.Functor.Const.$fShowConst2_bytes:
         I8[] [67,111,110,115,116,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.93821679 UTC

[section ""data" . Data.Functor.Const.$fShowConst1_closure" {
     Data.Functor.Const.$fShowConst1_closure:
         const Data.Functor.Const.$fShowConst1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fShowConst1_entry() //  [R1]
         { info_tbl: [(c76hE,
                       label: Data.Functor.Const.$fShowConst1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76hE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76hF; else goto c76hG;
       c76hF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76hG: // global
           (_c76hB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c76hB::I64 == 0) goto c76hD; else goto c76hC;
       c76hD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c76hC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c76hB::I64;
           R2 = Data.Functor.Const.$fShowConst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.94352524 UTC

[section ""data" . Data.Functor.Const.$w$cshowsPrec_closure" {
     Data.Functor.Const.$w$cshowsPrec_closure:
         const Data.Functor.Const.$w$cshowsPrec_info;
         const 0;
 },
 g_s7513_entry() //  [R1]
         { info_tbl: [(c76hW,
                       label: g_s7513_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76hW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c76hX; else goto c76hY;
       c76hX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76hY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Const.$fReadConst3_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s7516_entry() //  [R1]
         { info_tbl: [(c76ib,
                       label: sat_s7516_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76ib: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7517_entry() //  [R1, R2]
         { info_tbl: [(c76ie,
                       label: sat_s7517_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76ie: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c76ii; else goto c76ih;
       c76ii: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76ih: // global
           _s7513::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s7516_info;
           P64[Hp - 8] = _s7513::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Functor.Const.$fShowConst1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s751a_entry() //  [R1]
         { info_tbl: [(c76iy,
                       label: sat_s751a_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76iy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76iC; else goto c76iB;
       c76iC: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76iB: // global
           _s7513::P64 = P64[R1 + 16];
           _s7518::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s7518::P64;
           R2 = Hp - 14;
           R1 = _s7513::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s751b_entry() //  [R1]
         { info_tbl: [(c76iD,
                       label: sat_s751b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76iD: // global
           _s751b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c76iE; else goto c76iF;
       c76iF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c76iH; else goto c76iG;
       c76iH: // global
           HpAlloc = 32;
           goto c76iE;
       c76iE: // global
           R1 = _s751b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76iG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s751b::P64;
           _s7513::P64 = P64[_s751b::P64 + 16];
           _s7518::P64 = P64[_s751b::P64 + 24];
           I64[Hp - 24] = sat_s751a_info;
           P64[Hp - 8] = _s7513::P64;
           P64[Hp] = _s7518::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Const.$fShowConst1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s751c_entry() //  [R1, R2]
         { info_tbl: [(c76iJ,
                       label: sat_s751c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76iJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c76iN; else goto c76iM;
       c76iN: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76iM: // global
           _s7513::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s751b_info;
           P64[Hp - 32] = _s7513::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c76iR,
                       label: Data.Functor.Const.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76iR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c76iV; else goto c76iU;
       c76iV: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c76iU: // global
           I64[Hp - 40] = g_s7513_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c76hS::P64 = Hp - 40;
           if (%MO_S_Le_W64(R3, 10)) goto c76iP; else goto c76iQ;
       c76iP: // global
           I64[Hp - 8] = sat_s7517_info;
           P64[Hp] = _c76hS::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c76iQ: // global
           I64[Hp - 8] = sat_s751c_info;
           P64[Hp] = _c76hS::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.960880715 UTC

[section ""data" . Data.Functor.Const.$fShowConst_$cshowsPrec_closure" {
     Data.Functor.Const.$fShowConst_$cshowsPrec_closure:
         const Data.Functor.Const.$fShowConst_$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Const.$fShowConst_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c76jw,
                       label: Data.Functor.Const.$fShowConst_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76jw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c76jx; else goto c76jy;
       c76jx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c76jy: // global
           I64[Sp - 24] = block_c76jt_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u76jC; else goto c76ju;
       u76jC: // global
           call _c76jt(R1) args: 0, res: 0, upd: 0;
       c76ju: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c76jt() //  [R1]
         { info_tbl: [(c76jt,
                       label: block_c76jt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76jt: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Const.$w$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.967042882 UTC

[section ""data" . Data.Functor.Const.$fShowConst_$cshow_closure" {
     Data.Functor.Const.$fShowConst_$cshow_closure:
         const Data.Functor.Const.$fShowConst_$cshow_info;
         const 0;
 },
 sat_s751k_entry() //  [R1]
         { info_tbl: [(c76jU,
                       label: sat_s751k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76jU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c76jV; else goto c76jW;
       c76jV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76jW: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Functor.Const.$fReadConst3_closure+1;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fShowConst_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c76jX,
                       label: Data.Functor.Const.$fShowConst_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76jX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c76k1; else goto c76k0;
       c76k1: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c76k0: // global
           I64[Hp - 24] = sat_s751k_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Functor.Const.$fShowConst1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.975049717 UTC

[section ""data" . Data.Functor.Const.$fShowConst_$cshowList_closure" {
     Data.Functor.Const.$fShowConst_$cshowList_closure:
         const Data.Functor.Const.$fShowConst_$cshowList_info;
         const 0;
 },
 sat_s751p_entry() //  [R1, R2]
         { info_tbl: [(c76kk,
                       label: sat_s751p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76kk: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Functor.Const.$w$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fShowConst_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c76kn,
                       label: Data.Functor.Const.$fShowConst_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76kn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c76kr; else goto c76kq;
       c76kr: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c76kq: // global
           I64[Hp - 8] = sat_s751p_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.984017932 UTC

[section ""data" . Data.Functor.Const.$fShowConst_closure" {
     Data.Functor.Const.$fShowConst_closure:
         const Data.Functor.Const.$fShowConst_info;
         const 0;
 },
 sat_s751t_entry() //  [R1, R2, R3]
         { info_tbl: [(c76kI,
                       label: sat_s751t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76kI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fShowConst_$cshowList_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s751s_entry() //  [R1, R2]
         { info_tbl: [(c76kQ,
                       label: sat_s751s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76kQ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Const.$fShowConst_$cshow_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s751r_entry() //  [R1, R2, R3]
         { info_tbl: [(c76kY,
                       label: sat_s751r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76kY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fShowConst_$cshowsPrec_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fShowConst_entry() //  [R2]
         { info_tbl: [(c76l2,
                       label: Data.Functor.Const.$fShowConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76l2: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c76l6; else goto c76l5;
       c76l6: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76l5: // global
           I64[Hp - 72] = sat_s751t_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s751s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s751r_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.992983649 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldMap_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldMap_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldMap_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldMap_entry() //  [R2]
         { info_tbl: [(c76ls,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76ls: // global
           R2 = R2;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:20.998664658 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfold_closure" {
     Data.Functor.Const.$fFoldableConst_$cfold_closure:
         const Data.Functor.Const.$fFoldableConst_$cfold_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfold_entry() //  [R2]
         { info_tbl: [(c76lD,
                       label: Data.Functor.Const.$fFoldableConst_$cfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76lD: // global
           R2 = R2;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.002671699 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$csum_closure" {
     Data.Functor.Const.$fFoldableConst_$csum_closure:
         const Data.Functor.Const.$fFoldableConst_$csum_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$csum_entry() //  [R2]
         { info_tbl: [(c76lO,
                       label: Data.Functor.Const.$fFoldableConst_$csum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76lO: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fMonoidSum2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.006155469 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst2_bytes" {
     Data.Functor.Const.$fFoldableConst2_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.008019571 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst1_closure" {
     Data.Functor.Const.$fFoldableConst1_closure:
         const Data.Functor.Const.$fFoldableConst1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst1_entry() //  [R1]
         { info_tbl: [(c76m2,
                       label: Data.Functor.Const.$fFoldableConst1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76m2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76m3; else goto c76m4;
       c76m3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76m4: // global
           (_c76lZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c76lZ::I64 == 0) goto c76m1; else goto c76m0;
       c76m1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c76m0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c76lZ::I64;
           R2 = Data.Functor.Const.$fFoldableConst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.012247537 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cminimum_closure" {
     Data.Functor.Const.$fFoldableConst_$cminimum_closure:
         const Data.Functor.Const.$fFoldableConst_$cminimum_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cminimum_entry() //  []
         { info_tbl: [(c76mg,
                       label: Data.Functor.Const.$fFoldableConst_$cminimum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76mg: // global
           R2 = Data.Functor.Const.$fFoldableConst1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.016639153 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst4_bytes" {
     Data.Functor.Const.$fFoldableConst4_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.018800999 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst3_closure" {
     Data.Functor.Const.$fFoldableConst3_closure:
         const Data.Functor.Const.$fFoldableConst3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst3_entry() //  [R1]
         { info_tbl: [(c76mu,
                       label: Data.Functor.Const.$fFoldableConst3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76mu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76mv; else goto c76mw;
       c76mv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76mw: // global
           (_c76mr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c76mr::I64 == 0) goto c76mt; else goto c76ms;
       c76mt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c76ms: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c76mr::I64;
           R2 = Data.Functor.Const.$fFoldableConst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.023244366 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cmaximum_closure" {
     Data.Functor.Const.$fFoldableConst_$cmaximum_closure:
         const Data.Functor.Const.$fFoldableConst_$cmaximum_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cmaximum_entry() //  []
         { info_tbl: [(c76mI,
                       label: Data.Functor.Const.$fFoldableConst_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76mI: // global
           R2 = Data.Functor.Const.$fFoldableConst3_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.026761976 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$celem_closure" {
     Data.Functor.Const.$fFoldableConst_$celem_closure:
         const Data.Functor.Const.$fFoldableConst_$celem_info;
 },
 Data.Functor.Const.$fFoldableConst_$celem_entry() //  []
         { info_tbl: [(c76mT,
                       label: Data.Functor.Const.$fFoldableConst_$celem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76mT: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.030400596 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldl_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldl_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldl_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldl_entry() //  [R3]
         { info_tbl: [(c76n5,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76n5: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.033946669 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst7_bytes" {
     Data.Functor.Const.$fFoldableConst7_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.035961909 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst6_closure" {
     Data.Functor.Const.$fFoldableConst6_closure:
         const Data.Functor.Const.$fFoldableConst6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst6_entry() //  [R1]
         { info_tbl: [(c76nj,
                       label: Data.Functor.Const.$fFoldableConst6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76nj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76nk; else goto c76nl;
       c76nk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76nl: // global
           (_c76ng::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c76ng::I64 == 0) goto c76ni; else goto c76nh;
       c76ni: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c76nh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c76ng::I64;
           R2 = Data.Functor.Const.$fFoldableConst7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.040526417 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldl1_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldl1_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldl1_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldl1_entry() //  []
         { info_tbl: [(c76nx,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76nx: // global
           R2 = Data.Functor.Const.$fFoldableConst6_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.045660268 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldr'_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldr'_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldr'_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldr'_entry() //  [R3]
         { info_tbl: [(c76nI,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76nI: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.049212628 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$clength_closure" {
     Data.Functor.Const.$fFoldableConst_$clength_closure:
         const Data.Functor.Const.$fFoldableConst_$clength_info;
 },
 Data.Functor.Const.$fFoldableConst_$clength_entry() //  []
         { info_tbl: [(c76nT,
                       label: Data.Functor.Const.$fFoldableConst_$clength_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76nT: // global
           R1 = Data.Functor.Const.$fFoldableConst5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.052710692 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst9_bytes" {
     Data.Functor.Const.$fFoldableConst9_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.054857873 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst8_closure" {
     Data.Functor.Const.$fFoldableConst8_closure:
         const Data.Functor.Const.$fFoldableConst8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst8_entry() //  [R1]
         { info_tbl: [(c76o8,
                       label: Data.Functor.Const.$fFoldableConst8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76o8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76o9; else goto c76oa;
       c76o9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76oa: // global
           (_c76o5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c76o5::I64 == 0) goto c76o7; else goto c76o6;
       c76o7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c76o6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c76o5::I64;
           R2 = Data.Functor.Const.$fFoldableConst9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.059323124 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldr1_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldr1_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldr1_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldr1_entry() //  []
         { info_tbl: [(c76om,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76om: // global
           R2 = Data.Functor.Const.$fFoldableConst8_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.063218421 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cnull_closure" {
     Data.Functor.Const.$fFoldableConst_$cnull_closure:
         const Data.Functor.Const.$fFoldableConst_$cnull_info;
 },
 Data.Functor.Const.$fFoldableConst_$cnull_entry() //  []
         { info_tbl: [(c76ox,
                       label: Data.Functor.Const.$fFoldableConst_$cnull_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76ox: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.066960823 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cproduct_closure" {
     Data.Functor.Const.$fFoldableConst_$cproduct_closure:
         const Data.Functor.Const.$fFoldableConst_$cproduct_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cproduct_entry() //  [R2]
         { info_tbl: [(c76oJ,
                       label: Data.Functor.Const.$fFoldableConst_$cproduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76oJ: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fMonoidProduct2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.070857252 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$ctoList_closure" {
     Data.Functor.Const.$fFoldableConst_$ctoList_closure:
         const Data.Functor.Const.$fFoldableConst_$ctoList_info;
 },
 Data.Functor.Const.$fFoldableConst_$ctoList_entry() //  []
         { info_tbl: [(c76oU,
                       label: Data.Functor.Const.$fFoldableConst_$ctoList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76oU: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.075446196 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_closure" {
     Data.Functor.Const.$fFoldableConst_closure:
         const Data.Foldable.C:Foldable_con_info;
         const Data.Functor.Const.$fFoldableConst_$cfold_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cfoldMap_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldr'_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldr'_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldl_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldl_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldr1_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cfoldl1_closure+2;
         const Data.Functor.Const.$fFoldableConst_$ctoList_closure+1;
         const Data.Functor.Const.$fFoldableConst_$cnull_closure+1;
         const Data.Functor.Const.$fFoldableConst_$clength_closure+1;
         const Data.Functor.Const.$fFoldableConst_$celem_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cmaximum_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cminimum_closure+2;
         const Data.Functor.Const.$fFoldableConst_$csum_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cproduct_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.078040517 UTC

[section ""data" . Data.Functor.Const.$fFunctorConst2_closure" {
     Data.Functor.Const.$fFunctorConst2_closure:
         const Data.Functor.Const.$fFunctorConst2_info;
 },
 Data.Functor.Const.$fFunctorConst2_entry() //  [R3]
         { info_tbl: [(c76p7,
                       label: Data.Functor.Const.$fFunctorConst2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76p7: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.081712931 UTC

[section ""data" . Data.Functor.Const.$fFunctorConst1_closure" {
     Data.Functor.Const.$fFunctorConst1_closure:
         const Data.Functor.Const.$fFunctorConst1_info;
 },
 Data.Functor.Const.$fFunctorConst1_entry() //  [R3]
         { info_tbl: [(c76pi,
                       label: Data.Functor.Const.$fFunctorConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76pi: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.085113809 UTC

[section ""data" . Data.Functor.Const.$fFunctorConst_closure" {
     Data.Functor.Const.$fFunctorConst_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Const.$fFunctorConst2_closure+2;
         const Data.Functor.Const.$fFunctorConst1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.0884099 UTC

[section ""data" . Data.Functor.Const.$fApplicativeConst_closure" {
     Data.Functor.Const.$fApplicativeConst_closure:
         const Data.Functor.Const.$fApplicativeConst_info;
         const 0;
 },
 lvl_s7522_entry() //  [R1]
         { info_tbl: [(c76py,
                       label: lvl_s7522_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76py: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76pz; else goto c76pA;
       c76pz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76pA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752f_entry() //  [R1, R2, R3]
         { info_tbl: [(c76pG,
                       label: sat_s752f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76pG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c76pH; else goto c76pI;
       c76pH: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c76pI: // global
           _s752d::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s752d::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s752c_entry() //  [R1, R2, R3]
         { info_tbl: [(c76pO,
                       label: sat_s752c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76pO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c76pP; else goto c76pQ;
       c76pP: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c76pQ: // global
           _s752a::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s752a::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7529_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c76pW,
                       label: sat_s7529_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76pW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c76pX; else goto c76pY;
       c76pX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c76pY: // global
           R2 = P64[R1 + 5];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7525_entry() //  [R1]
         { info_tbl: [(c76q3,
                       label: sat_s7525_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76q3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76q4; else goto c76q5;
       c76q4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76q5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7524_entry() //  [R1]
         { info_tbl: [(c76qb,
                       label: sat_s7524_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76qb: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fApplicativeConst_entry() //  [R2]
         { info_tbl: [(c76qf,
                       label: Data.Functor.Const.$fApplicativeConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76qf: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c76qj; else goto c76qi;
       c76qj: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Functor.Const.$fApplicativeConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76qi: // global
           I64[Hp - 160] = lvl_s7522_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s752f_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s752c_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s7529_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s7525_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s7524_info;
           P64[Hp - 56] = Hp - 160;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Data.Functor.Const.$fFunctorConst_closure+1;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 101;
           P64[Hp - 8] = Hp - 118;
           P64[Hp] = Hp - 134;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.106249505 UTC

[section ""data" . Data.Functor.Const.$fStorableConst_closure" {
     Data.Functor.Const.$fStorableConst_closure:
         const Data.Functor.Const.$fStorableConst_info;
 },
 sat_s752o_entry() //  [R1]
         { info_tbl: [(c76r0,
                       label: sat_s752o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76r0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76r1; else goto c76r2;
       c76r1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76r2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752n_entry() //  [R1]
         { info_tbl: [(c76r7,
                       label: sat_s752n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76r7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76r8; else goto c76r9;
       c76r8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76r9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752m_entry() //  [R1]
         { info_tbl: [(c76re,
                       label: sat_s752m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76re: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76rf; else goto c76rg;
       c76rf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76rg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752l_entry() //  [R1]
         { info_tbl: [(c76rl,
                       label: sat_s752l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76rl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76rm; else goto c76rn;
       c76rm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76rn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752k_entry() //  [R1]
         { info_tbl: [(c76rs,
                       label: sat_s752k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76rs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76rt; else goto c76ru;
       c76rt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76ru: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752j_entry() //  [R1]
         { info_tbl: [(c76rz,
                       label: sat_s752j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76rz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76rA; else goto c76rB;
       c76rA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76rB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752i_entry() //  [R1]
         { info_tbl: [(c76rG,
                       label: sat_s752i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76rG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76rH; else goto c76rI;
       c76rH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76rI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.alignment_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752h_entry() //  [R1]
         { info_tbl: [(c76rN,
                       label: sat_s752h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76rN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76rO; else goto c76rP;
       c76rO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76rP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fStorableConst_entry() //  [R2]
         { info_tbl: [(c76rR,
                       label: Data.Functor.Const.$fStorableConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76rR: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c76rV; else goto c76rU;
       c76rV: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Const.$fStorableConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76rU: // global
           I64[Hp - 256] = sat_s752o_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s752n_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s752m_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s752l_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s752k_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s752j_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s752i_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s752h_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.126157992 UTC

[section ""data" . Data.Functor.Const.$fNumConst_closure" {
     Data.Functor.Const.$fNumConst_closure:
         const Data.Functor.Const.$fNumConst_info;
 },
 sat_s752w_entry() //  [R1]
         { info_tbl: [(c76sN,
                       label: sat_s752w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76sN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76sO; else goto c76sP;
       c76sO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76sP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752v_entry() //  [R1]
         { info_tbl: [(c76sU,
                       label: sat_s752v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76sU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76sV; else goto c76sW;
       c76sV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76sW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752u_entry() //  [R1]
         { info_tbl: [(c76t1,
                       label: sat_s752u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76t1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76t2; else goto c76t3;
       c76t2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76t3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752t_entry() //  [R1]
         { info_tbl: [(c76t8,
                       label: sat_s752t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76t8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76t9; else goto c76ta;
       c76t9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76ta: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752s_entry() //  [R1]
         { info_tbl: [(c76tf,
                       label: sat_s752s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76tf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76tg; else goto c76th;
       c76tg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76th: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752r_entry() //  [R1]
         { info_tbl: [(c76tm,
                       label: sat_s752r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76tm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76tn; else goto c76to;
       c76tn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76to: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752q_entry() //  [R1]
         { info_tbl: [(c76tt,
                       label: sat_s752q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76tt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76tu; else goto c76tv;
       c76tu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76tv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fNumConst_entry() //  [R2]
         { info_tbl: [(c76tx,
                       label: Data.Functor.Const.$fNumConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76tx: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c76tB; else goto c76tA;
       c76tB: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Const.$fNumConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76tA: // global
           I64[Hp - 224] = sat_s752w_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s752v_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s752u_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s752t_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s752s_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s752r_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s752q_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.148910607 UTC

[section ""data" . Data.Functor.Const.$fRealConst_$cp1Real_closure" {
     Data.Functor.Const.$fRealConst_$cp1Real_closure:
         const Data.Functor.Const.$fRealConst_$cp1Real_info;
 },
 sat_s752y_entry() //  [R1]
         { info_tbl: [(c76uo,
                       label: sat_s752y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76uo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76up; else goto c76uq;
       c76up: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76uq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealConst_$cp1Real_entry() //  [R2]
         { info_tbl: [(c76ur,
                       label: Data.Functor.Const.$fRealConst_$cp1Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76ur: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76uv; else goto c76uu;
       c76uv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealConst_$cp1Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76uu: // global
           I64[Hp - 16] = sat_s752y_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fNumConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.159284807 UTC

[section ""data" . Data.Functor.Const.$fSemigroupConst_closure" {
     Data.Functor.Const.$fSemigroupConst_closure:
         const Data.Functor.Const.$fSemigroupConst_info;
 },
 sat_s752D_entry() //  [R1, R2]
         { info_tbl: [(c76uN,
                       label: sat_s752D_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76uN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76uO; else goto c76uP;
       c76uO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76uP: // global
           _s752C::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s752C::P64;
           Sp = Sp - 16;
           call GHC.Base.stimes_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s752B_entry() //  [R1]
         { info_tbl: [(c76uU,
                       label: sat_s752B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76uU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76uV; else goto c76uW;
       c76uV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76uW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.sconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752A_entry() //  [R1]
         { info_tbl: [(c76v1,
                       label: sat_s752A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76v1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76v2; else goto c76v3;
       c76v2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76v3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fSemigroupConst_entry() //  [R2]
         { info_tbl: [(c76v5,
                       label: Data.Functor.Const.$fSemigroupConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76v5: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c76v9; else goto c76v8;
       c76v9: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = Data.Functor.Const.$fSemigroupConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76v8: // global
           I64[Hp - 88] = sat_s752D_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s752B_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s752A_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 87;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.176913625 UTC

[section ""data" . Data.Functor.Const.$fMonoidConst_$cp1Monoid_closure" {
     Data.Functor.Const.$fMonoidConst_$cp1Monoid_closure:
         const Data.Functor.Const.$fMonoidConst_$cp1Monoid_info;
 },
 sat_s752F_entry() //  [R1]
         { info_tbl: [(c76vC,
                       label: sat_s752F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76vC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76vD; else goto c76vE;
       c76vD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76vE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fMonoidConst_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(c76vF,
                       label: Data.Functor.Const.$fMonoidConst_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76vF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76vJ; else goto c76vI;
       c76vJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fMonoidConst_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76vI: // global
           I64[Hp - 16] = sat_s752F_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fSemigroupConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.188134102 UTC

[section ""data" . Data.Functor.Const.$fMonoidConst_closure" {
     Data.Functor.Const.$fMonoidConst_closure:
         const Data.Functor.Const.$fMonoidConst_info;
 },
 sat_s752K_entry() //  [R1]
         { info_tbl: [(c76w0,
                       label: sat_s752K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76w0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76w1; else goto c76w2;
       c76w1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76w2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752J_entry() //  [R1]
         { info_tbl: [(c76w7,
                       label: sat_s752J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76w7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76w8; else goto c76w9;
       c76w8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76w9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752I_entry() //  [R1]
         { info_tbl: [(c76we,
                       label: sat_s752I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76we: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76wf; else goto c76wg;
       c76wf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76wg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752H_entry() //  [R1]
         { info_tbl: [(c76wl,
                       label: sat_s752H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76wl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76wm; else goto c76wn;
       c76wm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76wn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fMonoidConst_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fMonoidConst_entry() //  [R2]
         { info_tbl: [(c76wp,
                       label: Data.Functor.Const.$fMonoidConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76wp: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c76wt; else goto c76ws;
       c76wt: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fMonoidConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76ws: // global
           I64[Hp - 128] = sat_s752K_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s752J_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s752I_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s752H_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.205605824 UTC

[section ""data" . Data.Functor.Const.$fGeneric1Const1_closure" {
     Data.Functor.Const.$fGeneric1Const1_closure:
         const Data.Functor.Const.$fGeneric1Const1_info;
 },
 Data.Functor.Const.$fGeneric1Const1_entry() //  [R2]
         { info_tbl: [(c76wX,
                       label: Data.Functor.Const.$fGeneric1Const1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76wX: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.209160893 UTC

[section ""data" . Data.Functor.Const.$fGeneric1Const2_closure" {
     Data.Functor.Const.$fGeneric1Const2_closure:
         const Data.Functor.Const.$fGeneric1Const2_info;
 },
 Data.Functor.Const.$fGeneric1Const2_entry() //  [R2]
         { info_tbl: [(c76x8,
                       label: Data.Functor.Const.$fGeneric1Const2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76x8: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.213696422 UTC

[section ""data" . Data.Functor.Const.$fGeneric1Const_closure" {
     Data.Functor.Const.$fGeneric1Const_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Const.$fGeneric1Const2_closure+1;
         const Data.Functor.Const.$fGeneric1Const1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.216020874 UTC

[section ""data" . Data.Functor.Const.$fGenericConst1_closure" {
     Data.Functor.Const.$fGenericConst1_closure:
         const Data.Functor.Const.$fGenericConst1_info;
 },
 Data.Functor.Const.$fGenericConst1_entry() //  [R2]
         { info_tbl: [(c76xk,
                       label: Data.Functor.Const.$fGenericConst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76xk: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.219861888 UTC

[section ""data" . Data.Functor.Const.$fGenericConst2_closure" {
     Data.Functor.Const.$fGenericConst2_closure:
         const Data.Functor.Const.$fGenericConst2_info;
 },
 Data.Functor.Const.$fGenericConst2_entry() //  [R2]
         { info_tbl: [(c76xv,
                       label: Data.Functor.Const.$fGenericConst2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76xv: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.223269683 UTC

[section ""data" . Data.Functor.Const.$fGenericConst_closure" {
     Data.Functor.Const.$fGenericConst_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Const.$fGenericConst2_closure+1;
         const Data.Functor.Const.$fGenericConst1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.225972078 UTC

[section ""data" . Data.Functor.Const.$fFractionalConst_$cp1Fractional_closure" {
     Data.Functor.Const.$fFractionalConst_$cp1Fractional_closure:
         const Data.Functor.Const.$fFractionalConst_$cp1Fractional_info;
 },
 sat_s752Q_entry() //  [R1]
         { info_tbl: [(c76xL,
                       label: sat_s752Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76xL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76xM; else goto c76xN;
       c76xM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76xN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFractionalConst_$cp1Fractional_entry() //  [R2]
         { info_tbl: [(c76xO,
                       label: Data.Functor.Const.$fFractionalConst_$cp1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76xO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76xS; else goto c76xR;
       c76xS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fFractionalConst_$cp1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76xR: // global
           I64[Hp - 16] = sat_s752Q_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fNumConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.232261952 UTC

[section ""data" . Data.Functor.Const.$fFractionalConst_closure" {
     Data.Functor.Const.$fFractionalConst_closure:
         const Data.Functor.Const.$fFractionalConst_info;
 },
 sat_s752V_entry() //  [R1]
         { info_tbl: [(c76y9,
                       label: sat_s752V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76y9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76ya; else goto c76yb;
       c76ya: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76yb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.fromRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752U_entry() //  [R1]
         { info_tbl: [(c76yg,
                       label: sat_s752U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76yg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76yh; else goto c76yi;
       c76yh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76yi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752T_entry() //  [R1]
         { info_tbl: [(c76yn,
                       label: sat_s752T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76yn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76yo; else goto c76yp;
       c76yo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76yp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real./_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s752S_entry() //  [R1]
         { info_tbl: [(c76yu,
                       label: sat_s752S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76yu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76yv; else goto c76yw;
       c76yv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76yw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fFractionalConst_$cp1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFractionalConst_entry() //  [R2]
         { info_tbl: [(c76yy,
                       label: Data.Functor.Const.$fFractionalConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76yy: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c76yC; else goto c76yB;
       c76yC: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fFractionalConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76yB: // global
           I64[Hp - 128] = sat_s752V_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s752U_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s752T_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s752S_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.245501206 UTC

[section ""data" . Data.Functor.Const.$fRealFracConst_$cp2RealFrac_closure" {
     Data.Functor.Const.$fRealFracConst_$cp2RealFrac_closure:
         const Data.Functor.Const.$fRealFracConst_$cp2RealFrac_info;
 },
 sat_s752X_entry() //  [R1]
         { info_tbl: [(c76za,
                       label: sat_s752X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76za: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76zb; else goto c76zc;
       c76zb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76zc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFracConst_$cp2RealFrac_entry() //  [R2]
         { info_tbl: [(c76zd,
                       label: Data.Functor.Const.$fRealFracConst_$cp2RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76zd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76zh; else goto c76zg;
       c76zh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFracConst_$cp2RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76zg: // global
           I64[Hp - 16] = sat_s752X_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fFractionalConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.251653032 UTC

[section ""data" . Data.Functor.Const.$fFloatingConst_$cp1Floating_closure" {
     Data.Functor.Const.$fFloatingConst_$cp1Floating_closure:
         const Data.Functor.Const.$fFloatingConst_$cp1Floating_info;
 },
 sat_s752Z_entry() //  [R1]
         { info_tbl: [(c76zy,
                       label: sat_s752Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76zy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76zz; else goto c76zA;
       c76zz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76zA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFloatingConst_$cp1Floating_entry() //  [R2]
         { info_tbl: [(c76zB,
                       label: Data.Functor.Const.$fFloatingConst_$cp1Floating_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76zB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76zF; else goto c76zE;
       c76zF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fFloatingConst_$cp1Floating_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76zE: // global
           I64[Hp - 16] = sat_s752Z_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fFractionalConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.260579468 UTC

[section ""data" . Data.Functor.Const.$fFloatingConst_closure" {
     Data.Functor.Const.$fFloatingConst_closure:
         const Data.Functor.Const.$fFloatingConst_info;
 },
 sat_s753n_entry() //  [R1]
         { info_tbl: [(c76zW,
                       label: sat_s753n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76zW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76zX; else goto c76zY;
       c76zX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76zY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1mexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753m_entry() //  [R1]
         { info_tbl: [(c76A3,
                       label: sat_s753m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76A3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76A4; else goto c76A5;
       c76A4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76A5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1pexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753l_entry() //  [R1]
         { info_tbl: [(c76Aa,
                       label: sat_s753l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Aa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ab; else goto c76Ac;
       c76Ab: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Ac: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.expm1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753k_entry() //  [R1]
         { info_tbl: [(c76Ah,
                       label: sat_s753k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Ah: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ai; else goto c76Aj;
       c76Ai: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Aj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1p_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753j_entry() //  [R1]
         { info_tbl: [(c76Ao,
                       label: sat_s753j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Ao: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ap; else goto c76Aq;
       c76Ap: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Aq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753i_entry() //  [R1]
         { info_tbl: [(c76Av,
                       label: sat_s753i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Av: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Aw; else goto c76Ax;
       c76Aw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Ax: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753h_entry() //  [R1]
         { info_tbl: [(c76AC,
                       label: sat_s753h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76AC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76AD; else goto c76AE;
       c76AD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76AE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753g_entry() //  [R1]
         { info_tbl: [(c76AJ,
                       label: sat_s753g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76AJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76AK; else goto c76AL;
       c76AK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76AL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753f_entry() //  [R1]
         { info_tbl: [(c76AQ,
                       label: sat_s753f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76AQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76AR; else goto c76AS;
       c76AR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76AS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753e_entry() //  [R1]
         { info_tbl: [(c76AX,
                       label: sat_s753e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76AX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76AY; else goto c76AZ;
       c76AY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76AZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753d_entry() //  [R1]
         { info_tbl: [(c76B4,
                       label: sat_s753d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76B4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76B5; else goto c76B6;
       c76B5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76B6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753c_entry() //  [R1]
         { info_tbl: [(c76Bb,
                       label: sat_s753c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Bb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Bc; else goto c76Bd;
       c76Bc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Bd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753b_entry() //  [R1]
         { info_tbl: [(c76Bi,
                       label: sat_s753b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Bi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Bj; else goto c76Bk;
       c76Bj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Bk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753a_entry() //  [R1]
         { info_tbl: [(c76Bp,
                       label: sat_s753a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Bp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Bq; else goto c76Br;
       c76Bq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Br: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7539_entry() //  [R1]
         { info_tbl: [(c76Bw,
                       label: sat_s7539_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Bw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Bx; else goto c76By;
       c76Bx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76By: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7538_entry() //  [R1]
         { info_tbl: [(c76BD,
                       label: sat_s7538_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76BD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76BE; else goto c76BF;
       c76BE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76BF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7537_entry() //  [R1]
         { info_tbl: [(c76BK,
                       label: sat_s7537_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76BK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76BL; else goto c76BM;
       c76BL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76BM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.logBase_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7536_entry() //  [R1]
         { info_tbl: [(c76BR,
                       label: sat_s7536_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76BR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76BS; else goto c76BT;
       c76BS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76BT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.**_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7535_entry() //  [R1]
         { info_tbl: [(c76BY,
                       label: sat_s7535_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76BY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76BZ; else goto c76C0;
       c76BZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76C0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sqrt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7534_entry() //  [R1]
         { info_tbl: [(c76C5,
                       label: sat_s7534_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76C5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76C6; else goto c76C7;
       c76C6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76C7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7533_entry() //  [R1]
         { info_tbl: [(c76Cc,
                       label: sat_s7533_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Cc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Cd; else goto c76Ce;
       c76Cd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Ce: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7532_entry() //  [R1]
         { info_tbl: [(c76Cj,
                       label: sat_s7532_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Cj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ck; else goto c76Cl;
       c76Ck: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Cl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.pi_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7531_entry() //  [R1]
         { info_tbl: [(c76Cq,
                       label: sat_s7531_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Cq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Cr; else goto c76Cs;
       c76Cr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Cs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fFloatingConst_$cp1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFloatingConst_entry() //  [R2]
         { info_tbl: [(c76Cu,
                       label: Data.Functor.Const.$fFloatingConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Cu: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto c76Cy; else goto c76Cx;
       c76Cy: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Const.$fFloatingConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76Cx: // global
           I64[Hp - 736] = sat_s753n_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_s753m_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_s753l_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_s753k_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_s753j_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_s753i_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_s753h_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_s753g_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_s753f_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_s753e_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_s753d_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_s753c_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_s753b_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_s753a_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_s7539_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_s7538_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_s7537_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_s7536_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_s7535_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_s7534_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_s7533_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s7532_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s7531_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = GHC.Float.C:Floating_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.311824357 UTC

[section ""data" . Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_closure" {
     Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_closure:
         const Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_info;
 },
 sat_s753p_entry() //  [R1]
         { info_tbl: [(c76ED,
                       label: sat_s753p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76ED: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76EE; else goto c76EF;
       c76EE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76EF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_entry() //  [R2]
         { info_tbl: [(c76EG,
                       label: Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76EG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76EK; else goto c76EJ;
       c76EK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76EJ: // global
           I64[Hp - 16] = sat_s753p_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fFloatingConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.318368816 UTC

[section ""data" . Data.Functor.Const.$fEqConst_closure" {
     Data.Functor.Const.$fEqConst_closure:
         const Data.Functor.Const.$fEqConst_info;
 },
 sat_s753s_entry() //  [R1]
         { info_tbl: [(c76F1,
                       label: sat_s753s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76F1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76F2; else goto c76F3;
       c76F2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76F3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753r_entry() //  [R1]
         { info_tbl: [(c76F8,
                       label: sat_s753r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76F8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76F9; else goto c76Fa;
       c76F9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Fa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fEqConst_entry() //  [R2]
         { info_tbl: [(c76Fc,
                       label: Data.Functor.Const.$fEqConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Fc: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c76Fg; else goto c76Ff;
       c76Fg: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Const.$fEqConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76Ff: // global
           I64[Hp - 64] = sat_s753s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s753r_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.32631104 UTC

[section ""data" . Data.Functor.Const.$fOrdConst_$cp1Ord_closure" {
     Data.Functor.Const.$fOrdConst_$cp1Ord_closure:
         const Data.Functor.Const.$fOrdConst_$cp1Ord_info;
 },
 sat_s753u_entry() //  [R1]
         { info_tbl: [(c76FE,
                       label: sat_s753u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76FE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76FF; else goto c76FG;
       c76FF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76FG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fOrdConst_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c76FH,
                       label: Data.Functor.Const.$fOrdConst_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76FH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76FL; else goto c76FK;
       c76FL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fOrdConst_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76FK: // global
           I64[Hp - 16] = sat_s753u_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fEqConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.333140368 UTC

[section ""data" . Data.Functor.Const.$fOrdConst_closure" {
     Data.Functor.Const.$fOrdConst_closure:
         const Data.Functor.Const.$fOrdConst_info;
 },
 sat_s753D_entry() //  [R1]
         { info_tbl: [(c76G2,
                       label: sat_s753D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76G2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76G3; else goto c76G4;
       c76G3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76G4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753C_entry() //  [R1]
         { info_tbl: [(c76G9,
                       label: sat_s753C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76G9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ga; else goto c76Gb;
       c76Ga: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Gb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753B_entry() //  [R1]
         { info_tbl: [(c76Gg,
                       label: sat_s753B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Gg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Gh; else goto c76Gi;
       c76Gh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Gi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753A_entry() //  [R1]
         { info_tbl: [(c76Gn,
                       label: sat_s753A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Gn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Go; else goto c76Gp;
       c76Go: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Gp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753z_entry() //  [R1]
         { info_tbl: [(c76Gu,
                       label: sat_s753z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Gu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Gv; else goto c76Gw;
       c76Gv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Gw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753y_entry() //  [R1]
         { info_tbl: [(c76GB,
                       label: sat_s753y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76GB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76GC; else goto c76GD;
       c76GC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76GD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753x_entry() //  [R1]
         { info_tbl: [(c76GI,
                       label: sat_s753x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76GI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76GJ; else goto c76GK;
       c76GJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76GK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753w_entry() //  [R1]
         { info_tbl: [(c76GP,
                       label: sat_s753w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76GP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76GQ; else goto c76GR;
       c76GQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76GR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fOrdConst_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fOrdConst_entry() //  [R2]
         { info_tbl: [(c76GT,
                       label: Data.Functor.Const.$fOrdConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76GT: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c76GX; else goto c76GW;
       c76GX: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Const.$fOrdConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76GW: // global
           I64[Hp - 256] = sat_s753D_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s753C_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s753B_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s753A_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s753z_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s753y_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s753x_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s753w_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.352217754 UTC

[section ""data" . Data.Functor.Const.$fIxConst_$cp1Ix_closure" {
     Data.Functor.Const.$fIxConst_$cp1Ix_closure:
         const Data.Functor.Const.$fIxConst_$cp1Ix_info;
 },
 sat_s753F_entry() //  [R1]
         { info_tbl: [(c76HP,
                       label: sat_s753F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76HP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76HQ; else goto c76HR;
       c76HQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76HR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.$p1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIxConst_$cp1Ix_entry() //  [R2]
         { info_tbl: [(c76HS,
                       label: Data.Functor.Const.$fIxConst_$cp1Ix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76HS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76HW; else goto c76HV;
       c76HW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fIxConst_$cp1Ix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76HV: // global
           I64[Hp - 16] = sat_s753F_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fOrdConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.359299695 UTC

[section ""data" . Data.Functor.Const.$fIxConst_closure" {
     Data.Functor.Const.$fIxConst_closure:
         const Data.Functor.Const.$fIxConst_info;
 },
 sat_s753N_entry() //  [R1]
         { info_tbl: [(c76Id,
                       label: sat_s753N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Id: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ie; else goto c76If;
       c76Ie: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76If: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeRangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753M_entry() //  [R1]
         { info_tbl: [(c76Ik,
                       label: sat_s753M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Ik: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Il; else goto c76Im;
       c76Il: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Im: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.rangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753L_entry() //  [R1]
         { info_tbl: [(c76Ir,
                       label: sat_s753L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Ir: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Is; else goto c76It;
       c76Is: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76It: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.inRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753K_entry() //  [R1]
         { info_tbl: [(c76Iy,
                       label: sat_s753K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Iy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Iz; else goto c76IA;
       c76Iz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76IA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeIndex_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753J_entry() //  [R1]
         { info_tbl: [(c76IF,
                       label: sat_s753J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76IF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76IG; else goto c76IH;
       c76IG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76IH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.index_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753I_entry() //  [R1]
         { info_tbl: [(c76IM,
                       label: sat_s753I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76IM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76IN; else goto c76IO;
       c76IN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76IO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.range_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753H_entry() //  [R1]
         { info_tbl: [(c76IT,
                       label: sat_s753H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76IT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76IU; else goto c76IV;
       c76IU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76IV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fIxConst_$cp1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIxConst_entry() //  [R2]
         { info_tbl: [(c76IX,
                       label: Data.Functor.Const.$fIxConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76IX: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c76J1; else goto c76J0;
       c76J1: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Const.$fIxConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76J0: // global
           I64[Hp - 224] = sat_s753N_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s753M_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s753L_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s753K_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s753J_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s753I_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s753H_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Arr.C:Ix_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.377383677 UTC

[section ""data" . Data.Functor.Const.$fRealConst_$cp2Real_closure" {
     Data.Functor.Const.$fRealConst_$cp2Real_closure:
         const Data.Functor.Const.$fRealConst_$cp2Real_info;
 },
 sat_s753P_entry() //  [R1]
         { info_tbl: [(c76JO,
                       label: sat_s753P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76JO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76JP; else goto c76JQ;
       c76JP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76JQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealConst_$cp2Real_entry() //  [R2]
         { info_tbl: [(c76JR,
                       label: Data.Functor.Const.$fRealConst_$cp2Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76JR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76JV; else goto c76JU;
       c76JV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealConst_$cp2Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76JU: // global
           I64[Hp - 16] = sat_s753P_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fOrdConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.383613912 UTC

[section ""data" . Data.Functor.Const.$fRealConst_closure" {
     Data.Functor.Const.$fRealConst_closure:
         const Data.Functor.Const.$fRealConst_info;
 },
 sat_s753T_entry() //  [R1]
         { info_tbl: [(c76Kc,
                       label: sat_s753T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Kc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Kd; else goto c76Ke;
       c76Kd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Ke: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753S_entry() //  [R1]
         { info_tbl: [(c76Kj,
                       label: sat_s753S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Kj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Kk; else goto c76Kl;
       c76Kk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Kl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealConst_$cp2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753R_entry() //  [R1]
         { info_tbl: [(c76Kq,
                       label: sat_s753R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Kq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Kr; else goto c76Ks;
       c76Kr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Ks: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealConst_$cp1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealConst_entry() //  [R2]
         { info_tbl: [(c76Ku,
                       label: Data.Functor.Const.$fRealConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Ku: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c76Ky; else goto c76Kx;
       c76Ky: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76Kx: // global
           I64[Hp - 96] = sat_s753T_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s753S_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s753R_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.397211236 UTC

[section ""data" . Data.Functor.Const.$fIntegralConst_$cp1Integral_closure" {
     Data.Functor.Const.$fIntegralConst_$cp1Integral_closure:
         const Data.Functor.Const.$fIntegralConst_$cp1Integral_info;
 },
 sat_s753V_entry() //  [R1]
         { info_tbl: [(c76L1,
                       label: sat_s753V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76L1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76L2; else goto c76L3;
       c76L2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76L3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIntegralConst_$cp1Integral_entry() //  [R2]
         { info_tbl: [(c76L4,
                       label: Data.Functor.Const.$fIntegralConst_$cp1Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76L4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76L8; else goto c76L7;
       c76L8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fIntegralConst_$cp1Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76L7: // global
           I64[Hp - 16] = sat_s753V_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fRealConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.402896514 UTC

[section ""data" . Data.Functor.Const.$fRealFracConst_$cp1RealFrac_closure" {
     Data.Functor.Const.$fRealFracConst_$cp1RealFrac_closure:
         const Data.Functor.Const.$fRealFracConst_$cp1RealFrac_info;
 },
 sat_s753X_entry() //  [R1]
         { info_tbl: [(c76Lp,
                       label: sat_s753X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Lp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Lq; else goto c76Lr;
       c76Lq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Lr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFracConst_$cp1RealFrac_entry() //  [R2]
         { info_tbl: [(c76Ls,
                       label: Data.Functor.Const.$fRealFracConst_$cp1RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Ls: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76Lw; else goto c76Lv;
       c76Lw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFracConst_$cp1RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76Lv: // global
           I64[Hp - 16] = sat_s753X_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fRealConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.409375438 UTC

[section ""data" . Data.Functor.Const.$fRealFracConst_closure" {
     Data.Functor.Const.$fRealFracConst_closure:
         const Data.Functor.Const.$fRealFracConst_info;
 },
 sat_s754a_entry() //  [R1, R2]
         { info_tbl: [(c76LO,
                       label: sat_s754a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76LO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76LP; else goto c76LQ;
       c76LP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76LQ: // global
           _s7549::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7549::P64;
           Sp = Sp - 16;
           call GHC.Real.floor_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7548_entry() //  [R1, R2]
         { info_tbl: [(c76LW,
                       label: sat_s7548_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76LW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76LX; else goto c76LY;
       c76LX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76LY: // global
           _s7547::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7547::P64;
           Sp = Sp - 16;
           call GHC.Real.ceiling_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7546_entry() //  [R1, R2]
         { info_tbl: [(c76M4,
                       label: sat_s7546_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76M4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76M5; else goto c76M6;
       c76M5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76M6: // global
           _s7545::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7545::P64;
           Sp = Sp - 16;
           call GHC.Real.round_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7544_entry() //  [R1, R2]
         { info_tbl: [(c76Mc,
                       label: sat_s7544_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Mc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Md; else goto c76Me;
       c76Md: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76Me: // global
           _s7543::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7543::P64;
           Sp = Sp - 16;
           call GHC.Real.truncate_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7542_entry() //  [R1, R2]
         { info_tbl: [(c76Mk,
                       label: sat_s7542_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Mk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ml; else goto c76Mm;
       c76Ml: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76Mm: // global
           _s7541::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7541::P64;
           Sp = Sp - 16;
           call GHC.Real.properFraction_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7540_entry() //  [R1]
         { info_tbl: [(c76Mr,
                       label: sat_s7540_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Mr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ms; else goto c76Mt;
       c76Ms: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Mt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFracConst_$cp2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s753Z_entry() //  [R1]
         { info_tbl: [(c76My,
                       label: sat_s753Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76My: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Mz; else goto c76MA;
       c76Mz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76MA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFracConst_$cp1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFracConst_entry() //  [R2]
         { info_tbl: [(c76MC,
                       label: Data.Functor.Const.$fRealFracConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76MC: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c76MG; else goto c76MF;
       c76MG: // global
           HpAlloc = 192;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFracConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76MF: // global
           I64[Hp - 184] = sat_s754a_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s7548_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s7546_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s7544_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s7542_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s7540_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s753Z_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 119;
           P64[Hp - 24] = Hp - 135;
           P64[Hp - 16] = Hp - 151;
           P64[Hp - 8] = Hp - 167;
           P64[Hp] = Hp - 183;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.428894366 UTC

[section ""data" . Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_closure" {
     Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_closure:
         const Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_info;
 },
 sat_s754c_entry() //  [R1]
         { info_tbl: [(c76Nt,
                       label: sat_s754c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Nt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Nu; else goto c76Nv;
       c76Nu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Nv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_entry() //  [R2]
         { info_tbl: [(c76Nw,
                       label: Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Nw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76NA; else goto c76Nz;
       c76NA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76Nz: // global
           I64[Hp - 16] = sat_s754c_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fRealFracConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.436605701 UTC

[section ""data" . Data.Functor.Const.$fRealFloatConst_closure" {
     Data.Functor.Const.$fRealFloatConst_closure:
         const Data.Functor.Const.$fRealFloatConst_info;
 },
 sat_s754t_entry() //  [R1]
         { info_tbl: [(c76NR,
                       label: sat_s754t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76NR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76NS; else goto c76NT;
       c76NS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76NT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754s_entry() //  [R1]
         { info_tbl: [(c76NY,
                       label: sat_s754s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76NY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76NZ; else goto c76O0;
       c76NZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76O0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isIEEE_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754r_entry() //  [R1]
         { info_tbl: [(c76O5,
                       label: sat_s754r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76O5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76O6; else goto c76O7;
       c76O6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76O7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNegativeZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754q_entry() //  [R1]
         { info_tbl: [(c76Oc,
                       label: sat_s754q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Oc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Od; else goto c76Oe;
       c76Od: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Oe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isDenormalized_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754p_entry() //  [R1]
         { info_tbl: [(c76Oj,
                       label: sat_s754p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Oj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ok; else goto c76Ol;
       c76Ok: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Ol: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isInfinite_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754o_entry() //  [R1]
         { info_tbl: [(c76Oq,
                       label: sat_s754o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Oq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Or; else goto c76Os;
       c76Or: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Os: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNaN_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754n_entry() //  [R1]
         { info_tbl: [(c76Ox,
                       label: sat_s754n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Ox: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Oy; else goto c76Oz;
       c76Oy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Oz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.scaleFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754m_entry() //  [R1]
         { info_tbl: [(c76OE,
                       label: sat_s754m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76OE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76OF; else goto c76OG;
       c76OF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76OG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.significand_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754l_entry() //  [R1]
         { info_tbl: [(c76OL,
                       label: sat_s754l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76OL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76OM; else goto c76ON;
       c76OM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76ON: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exponent_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754k_entry() //  [R1]
         { info_tbl: [(c76OS,
                       label: sat_s754k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76OS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76OT; else goto c76OU;
       c76OT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76OU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.encodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754j_entry() //  [R1]
         { info_tbl: [(c76OZ,
                       label: sat_s754j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76OZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76P0; else goto c76P1;
       c76P0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76P1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.decodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754i_entry() //  [R1]
         { info_tbl: [(c76P6,
                       label: sat_s754i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76P6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76P7; else goto c76P8;
       c76P7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76P8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754h_entry() //  [R1]
         { info_tbl: [(c76Pd,
                       label: sat_s754h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Pd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Pe; else goto c76Pf;
       c76Pe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Pf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatDigits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754g_entry() //  [R1]
         { info_tbl: [(c76Pk,
                       label: sat_s754g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Pk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Pl; else goto c76Pm;
       c76Pl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Pm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRadix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754f_entry() //  [R1]
         { info_tbl: [(c76Pr,
                       label: sat_s754f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Pr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ps; else goto c76Pt;
       c76Ps: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Pt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754e_entry() //  [R1]
         { info_tbl: [(c76Py,
                       label: sat_s754e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Py: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Pz; else goto c76PA;
       c76Pz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76PA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFloatConst_entry() //  [R2]
         { info_tbl: [(c76PC,
                       label: Data.Functor.Const.$fRealFloatConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76PC: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto c76PG; else goto c76PF;
       c76PG: // global
           HpAlloc = 520;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFloatConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76PF: // global
           I64[Hp - 512] = sat_s754t_info;
           P64[Hp - 496] = R2;
           I64[Hp - 488] = sat_s754s_info;
           P64[Hp - 472] = R2;
           I64[Hp - 464] = sat_s754r_info;
           P64[Hp - 448] = R2;
           I64[Hp - 440] = sat_s754q_info;
           P64[Hp - 424] = R2;
           I64[Hp - 416] = sat_s754p_info;
           P64[Hp - 400] = R2;
           I64[Hp - 392] = sat_s754o_info;
           P64[Hp - 376] = R2;
           I64[Hp - 368] = sat_s754n_info;
           P64[Hp - 352] = R2;
           I64[Hp - 344] = sat_s754m_info;
           P64[Hp - 328] = R2;
           I64[Hp - 320] = sat_s754l_info;
           P64[Hp - 304] = R2;
           I64[Hp - 296] = sat_s754k_info;
           P64[Hp - 280] = R2;
           I64[Hp - 272] = sat_s754j_info;
           P64[Hp - 256] = R2;
           I64[Hp - 248] = sat_s754i_info;
           P64[Hp - 232] = R2;
           I64[Hp - 224] = sat_s754h_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s754g_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s754f_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s754e_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = GHC.Float.C:RealFloat_con_info;
           P64[Hp - 120] = Hp - 152;
           P64[Hp - 112] = Hp - 176;
           P64[Hp - 104] = Hp - 200;
           P64[Hp - 96] = Hp - 224;
           P64[Hp - 88] = Hp - 248;
           P64[Hp - 80] = Hp - 272;
           P64[Hp - 72] = Hp - 296;
           P64[Hp - 64] = Hp - 320;
           P64[Hp - 56] = Hp - 344;
           P64[Hp - 48] = Hp - 368;
           P64[Hp - 40] = Hp - 392;
           P64[Hp - 32] = Hp - 416;
           P64[Hp - 24] = Hp - 440;
           P64[Hp - 16] = Hp - 464;
           P64[Hp - 8] = Hp - 488;
           P64[Hp] = Hp - 512;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.472400846 UTC

[section ""data" . Data.Functor.Const.$fEnumConst_closure" {
     Data.Functor.Const.$fEnumConst_closure:
         const Data.Functor.Const.$fEnumConst_info;
 },
 sat_s754C_entry() //  [R1]
         { info_tbl: [(c76Rc,
                       label: sat_s754C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Rc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Rd; else goto c76Re;
       c76Rd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Re: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754B_entry() //  [R1]
         { info_tbl: [(c76Rj,
                       label: sat_s754B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Rj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Rk; else goto c76Rl;
       c76Rk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Rl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754A_entry() //  [R1]
         { info_tbl: [(c76Rq,
                       label: sat_s754A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Rq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Rr; else goto c76Rs;
       c76Rr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Rs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754z_entry() //  [R1]
         { info_tbl: [(c76Rx,
                       label: sat_s754z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Rx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ry; else goto c76Rz;
       c76Ry: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Rz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754y_entry() //  [R1]
         { info_tbl: [(c76RE,
                       label: sat_s754y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76RE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76RF; else goto c76RG;
       c76RF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76RG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.fromEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754x_entry() //  [R1]
         { info_tbl: [(c76RL,
                       label: sat_s754x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76RL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76RM; else goto c76RN;
       c76RM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76RN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.toEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754w_entry() //  [R1]
         { info_tbl: [(c76RS,
                       label: sat_s754w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76RS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76RT; else goto c76RU;
       c76RT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76RU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.pred_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754v_entry() //  [R1]
         { info_tbl: [(c76RZ,
                       label: sat_s754v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76RZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76S0; else goto c76S1;
       c76S0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76S1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.succ_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fEnumConst_entry() //  [R2]
         { info_tbl: [(c76S3,
                       label: Data.Functor.Const.$fEnumConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76S3: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c76S7; else goto c76S6;
       c76S7: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Const.$fEnumConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76S6: // global
           I64[Hp - 256] = sat_s754C_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s754B_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s754A_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s754z_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s754y_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s754x_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s754w_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s754v_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.493336934 UTC

[section ""data" . Data.Functor.Const.$fIntegralConst_$cp2Integral_closure" {
     Data.Functor.Const.$fIntegralConst_$cp2Integral_closure:
         const Data.Functor.Const.$fIntegralConst_$cp2Integral_info;
 },
 sat_s754E_entry() //  [R1]
         { info_tbl: [(c76SZ,
                       label: sat_s754E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76SZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76T0; else goto c76T1;
       c76T0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76T1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIntegralConst_$cp2Integral_entry() //  [R2]
         { info_tbl: [(c76T2,
                       label: Data.Functor.Const.$fIntegralConst_$cp2Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76T2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76T6; else goto c76T5;
       c76T6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fIntegralConst_$cp2Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76T5: // global
           I64[Hp - 16] = sat_s754E_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fEnumConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.50042565 UTC

[section ""data" . Data.Functor.Const.$fIntegralConst_closure" {
     Data.Functor.Const.$fIntegralConst_closure:
         const Data.Functor.Const.$fIntegralConst_info;
 },
 sat_s754O_entry() //  [R1]
         { info_tbl: [(c76Tn,
                       label: sat_s754O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Tn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76To; else goto c76Tp;
       c76To: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Tp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754N_entry() //  [R1]
         { info_tbl: [(c76Tu,
                       label: sat_s754N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Tu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Tv; else goto c76Tw;
       c76Tv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Tw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.divMod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754M_entry() //  [R1]
         { info_tbl: [(c76TB,
                       label: sat_s754M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76TB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76TC; else goto c76TD;
       c76TC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76TD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quotRem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754L_entry() //  [R1]
         { info_tbl: [(c76TI,
                       label: sat_s754L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76TI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76TJ; else goto c76TK;
       c76TJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76TK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.mod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754K_entry() //  [R1]
         { info_tbl: [(c76TP,
                       label: sat_s754K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76TP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76TQ; else goto c76TR;
       c76TQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76TR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.div_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754J_entry() //  [R1]
         { info_tbl: [(c76TW,
                       label: sat_s754J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76TW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76TX; else goto c76TY;
       c76TX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76TY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.rem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754I_entry() //  [R1]
         { info_tbl: [(c76U3,
                       label: sat_s754I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76U3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76U4; else goto c76U5;
       c76U4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76U5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quot_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754H_entry() //  [R1]
         { info_tbl: [(c76Ua,
                       label: sat_s754H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Ua: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ub; else goto c76Uc;
       c76Ub: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Uc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fIntegralConst_$cp2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754G_entry() //  [R1]
         { info_tbl: [(c76Uh,
                       label: sat_s754G_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Uh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Ui; else goto c76Uj;
       c76Ui: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Uj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fIntegralConst_$cp1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIntegralConst_entry() //  [R2]
         { info_tbl: [(c76Ul,
                       label: Data.Functor.Const.$fIntegralConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Ul: // global
           Hp = Hp + 296;
           if (Hp > HpLim) (likely: False) goto c76Up; else goto c76Uo;
       c76Up: // global
           HpAlloc = 296;
           R2 = R2;
           R1 = Data.Functor.Const.$fIntegralConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76Uo: // global
           I64[Hp - 288] = sat_s754O_info;
           P64[Hp - 272] = R2;
           I64[Hp - 264] = sat_s754N_info;
           P64[Hp - 248] = R2;
           I64[Hp - 240] = sat_s754M_info;
           P64[Hp - 224] = R2;
           I64[Hp - 216] = sat_s754L_info;
           P64[Hp - 200] = R2;
           I64[Hp - 192] = sat_s754K_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s754J_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s754I_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s754H_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s754G_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = GHC.Real.C:Integral_con_info;
           P64[Hp - 64] = Hp - 96;
           P64[Hp - 56] = Hp - 120;
           P64[Hp - 48] = Hp - 144;
           P64[Hp - 40] = Hp - 168;
           P64[Hp - 32] = Hp - 192;
           P64[Hp - 24] = Hp - 216;
           P64[Hp - 16] = Hp - 240;
           P64[Hp - 8] = Hp - 264;
           P64[Hp] = Hp - 288;
           R1 = Hp - 71;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.522736781 UTC

[section ""data" . Data.Functor.Const.$fBoundedConst_closure" {
     Data.Functor.Const.$fBoundedConst_closure:
         const Data.Functor.Const.$fBoundedConst_info;
 },
 sat_s754R_entry() //  [R1]
         { info_tbl: [(c76Vm,
                       label: sat_s754R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Vm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Vn; else goto c76Vo;
       c76Vn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Vo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754Q_entry() //  [R1]
         { info_tbl: [(c76Vt,
                       label: sat_s754Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Vt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Vu; else goto c76Vv;
       c76Vu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Vv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fBoundedConst_entry() //  [R2]
         { info_tbl: [(c76Vx,
                       label: Data.Functor.Const.$fBoundedConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Vx: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c76VB; else goto c76VA;
       c76VB: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Const.$fBoundedConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76VA: // global
           I64[Hp - 64] = sat_s754R_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s754Q_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.531768017 UTC

[section ""data" . Data.Functor.Const.$fBitsConst_$cp1Bits_closure" {
     Data.Functor.Const.$fBitsConst_$cp1Bits_closure:
         const Data.Functor.Const.$fBitsConst_$cp1Bits_info;
 },
 sat_s754T_entry() //  [R1]
         { info_tbl: [(c76VZ,
                       label: sat_s754T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76VZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76W0; else goto c76W1;
       c76W0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76W1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fBitsConst_$cp1Bits_entry() //  [R2]
         { info_tbl: [(c76W2,
                       label: Data.Functor.Const.$fBitsConst_$cp1Bits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76W2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c76W6; else goto c76W5;
       c76W6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fBitsConst_$cp1Bits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76W5: // global
           I64[Hp - 16] = sat_s754T_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fEqConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.540794709 UTC

[section ""data" . Data.Functor.Const.$fBitsConst_closure" {
     Data.Functor.Const.$fBitsConst_closure:
         const Data.Functor.Const.$fBitsConst_info;
 },
 sat_s755h_entry() //  [R1]
         { info_tbl: [(c76Wn,
                       label: sat_s755h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Wn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Wo; else goto c76Wp;
       c76Wo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Wp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.popCount_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755g_entry() //  [R1]
         { info_tbl: [(c76Wu,
                       label: sat_s755g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Wu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Wv; else goto c76Ww;
       c76Wv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Ww: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755f_entry() //  [R1]
         { info_tbl: [(c76WB,
                       label: sat_s755f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76WB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76WC; else goto c76WD;
       c76WC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76WD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755e_entry() //  [R1]
         { info_tbl: [(c76WI,
                       label: sat_s755e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76WI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76WJ; else goto c76WK;
       c76WJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76WK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755d_entry() //  [R1]
         { info_tbl: [(c76WP,
                       label: sat_s755d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76WP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76WQ; else goto c76WR;
       c76WQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76WR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755c_entry() //  [R1]
         { info_tbl: [(c76WW,
                       label: sat_s755c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76WW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76WX; else goto c76WY;
       c76WX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76WY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755b_entry() //  [R1]
         { info_tbl: [(c76X3,
                       label: sat_s755b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76X3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76X4; else goto c76X5;
       c76X4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76X5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755a_entry() //  [R1]
         { info_tbl: [(c76Xa,
                       label: sat_s755a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Xa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Xb; else goto c76Xc;
       c76Xb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Xc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.isSigned_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7559_entry() //  [R1]
         { info_tbl: [(c76Xh,
                       label: sat_s7559_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Xh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Xi; else goto c76Xj;
       c76Xi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Xj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7558_entry() //  [R1]
         { info_tbl: [(c76Xo,
                       label: sat_s7558_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Xo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Xp; else goto c76Xq;
       c76Xp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Xq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7557_entry() //  [R1]
         { info_tbl: [(c76Xv,
                       label: sat_s7557_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Xv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Xw; else goto c76Xx;
       c76Xw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Xx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.testBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7556_entry() //  [R1]
         { info_tbl: [(c76XC,
                       label: sat_s7556_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76XC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76XD; else goto c76XE;
       c76XD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76XE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complementBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7555_entry() //  [R1]
         { info_tbl: [(c76XJ,
                       label: sat_s7555_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76XJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76XK; else goto c76XL;
       c76XK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76XL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.clearBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7554_entry() //  [R1]
         { info_tbl: [(c76XQ,
                       label: sat_s7554_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76XQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76XR; else goto c76XS;
       c76XR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76XS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.setBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7553_entry() //  [R1]
         { info_tbl: [(c76XX,
                       label: sat_s7553_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76XX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76XY; else goto c76XZ;
       c76XY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76XZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7552_entry() //  [R1]
         { info_tbl: [(c76Y4,
                       label: sat_s7552_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Y4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Y5; else goto c76Y6;
       c76Y5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Y6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.zeroBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7551_entry() //  [R1]
         { info_tbl: [(c76Yb,
                       label: sat_s7551_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Yb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Yc; else goto c76Yd;
       c76Yc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Yd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7550_entry() //  [R1]
         { info_tbl: [(c76Yi,
                       label: sat_s7550_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Yi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Yj; else goto c76Yk;
       c76Yj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Yk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shift_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754Z_entry() //  [R1]
         { info_tbl: [(c76Yp,
                       label: sat_s754Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Yp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Yq; else goto c76Yr;
       c76Yq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Yr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complement_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754Y_entry() //  [R1]
         { info_tbl: [(c76Yw,
                       label: sat_s754Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76Yw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76Yx; else goto c76Yy;
       c76Yx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76Yy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.xor_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754X_entry() //  [R1]
         { info_tbl: [(c76YD,
                       label: sat_s754X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76YD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76YE; else goto c76YF;
       c76YE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76YF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..|._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754W_entry() //  [R1]
         { info_tbl: [(c76YK,
                       label: sat_s754W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76YK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76YL; else goto c76YM;
       c76YL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76YM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..&._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s754V_entry() //  [R1]
         { info_tbl: [(c76YR,
                       label: sat_s754V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76YR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c76YS; else goto c76YT;
       c76YS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c76YT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fBitsConst_$cp1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fBitsConst_entry() //  [R2]
         { info_tbl: [(c76YV,
                       label: Data.Functor.Const.$fBitsConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c76YV: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto c76YZ; else goto c76YY;
       c76YZ: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Const.$fBitsConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c76YY: // global
           I64[Hp - 736] = sat_s755h_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_s755g_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_s755f_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_s755e_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_s755d_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_s755c_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_s755b_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_s755a_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_s7559_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_s7558_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_s7557_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_s7556_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_s7555_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_s7554_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_s7553_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_s7552_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_s7551_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_s7550_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_s754Z_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_s754Y_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_s754X_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s754W_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s754V_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = Data.Bits.C:Bits_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.592131903 UTC

[section ""data" . Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_closure" {
     Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_closure:
         const Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_info;
 },
 sat_s755j_entry() //  [R1]
         { info_tbl: [(c7714,
                       label: sat_s755j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7714: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7715; else goto c7716;
       c7715: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7716: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_entry() //  [R2]
         { info_tbl: [(c7717,
                       label: Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7717: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c771b; else goto c771a;
       c771b: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c771a: // global
           I64[Hp - 16] = sat_s755j_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fBitsConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.598326243 UTC

[section ""data" . Data.Functor.Const.$fFiniteBitsConst_closure" {
     Data.Functor.Const.$fFiniteBitsConst_closure:
         const Data.Functor.Const.$fFiniteBitsConst_info;
 },
 sat_s755o_entry() //  [R1]
         { info_tbl: [(c771s,
                       label: sat_s755o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c771s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c771t; else goto c771u;
       c771t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c771u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countTrailingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755n_entry() //  [R1]
         { info_tbl: [(c771z,
                       label: sat_s755n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c771z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c771A; else goto c771B;
       c771A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c771B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countLeadingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755m_entry() //  [R1]
         { info_tbl: [(c771G,
                       label: sat_s755m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c771G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c771H; else goto c771I;
       c771H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c771I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s755l_entry() //  [R1]
         { info_tbl: [(c771N,
                       label: sat_s755l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c771N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c771O; else goto c771P;
       c771O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c771P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFiniteBitsConst_entry() //  [R2]
         { info_tbl: [(c771R,
                       label: Data.Functor.Const.$fFiniteBitsConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c771R: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c771V; else goto c771U;
       c771V: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fFiniteBitsConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c771U: // global
           I64[Hp - 128] = sat_s755o_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s755n_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s755m_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s755l_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Bits.C:FiniteBits_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.610165908 UTC

[section ""data" . Data.Functor.Const.getConst1_closure" {
     Data.Functor.Const.getConst1_closure:
         const Data.Functor.Const.getConst1_info;
 },
 Data.Functor.Const.getConst1_entry() //  [R2]
         { info_tbl: [(c772p,
                       label: Data.Functor.Const.getConst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c772p: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.614169663 UTC

[section ""data" . Data.Functor.Const.getConst_closure" {
     Data.Functor.Const.getConst_closure:
         const Data.Functor.Const.getConst_info;
 },
 Data.Functor.Const.getConst_entry() //  [R2]
         { info_tbl: [(c772A,
                       label: Data.Functor.Const.getConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c772A: // global
           R2 = R2;
           call Data.Functor.Const.getConst1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.61776338 UTC

[section ""cstring" . Data.Functor.Const.$trModule4_bytes" {
     Data.Functor.Const.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.619482683 UTC

[section ""data" . Data.Functor.Const.$trModule3_closure" {
     Data.Functor.Const.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.621186166 UTC

[section ""cstring" . Data.Functor.Const.$trModule2_bytes" {
     Data.Functor.Const.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.622982433 UTC

[section ""data" . Data.Functor.Const.$trModule1_closure" {
     Data.Functor.Const.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.624810553 UTC

[section ""data" . Data.Functor.Const.$trModule_closure" {
     Data.Functor.Const.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Const.$trModule3_closure+1;
         const Data.Functor.Const.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.626585283 UTC

[section ""data" . $krep_r74ZT_closure" {
     $krep_r74ZT_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.628286137 UTC

[section ""data" . $krep1_r74ZU_closure" {
     $krep1_r74ZU_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.630108259 UTC

[section ""data" . $krep2_r74ZV_closure" {
     $krep2_r74ZV_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r74ZU_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.631895993 UTC

[section ""data" . Data.Functor.Const.$tcConst1_closure" {
     Data.Functor.Const.$tcConst1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep2_r74ZV_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.633739027 UTC

[section ""data" . $krep3_r74ZW_closure" {
     $krep3_r74ZW_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.635552643 UTC

[section ""data" . Data.Functor.Const.$tcConst2_closure" {
     Data.Functor.Const.$tcConst2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$fReadConst5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.638012005 UTC

[section ""data" . Data.Functor.Const.$tcConst_closure" {
     Data.Functor.Const.$tcConst_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Const.$trModule_closure+1;
         const Data.Functor.Const.$tcConst2_closure+1;
         const Data.Functor.Const.$tcConst1_closure+4;
         const 18204097321285842582;
         const 16882168546145866005;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.639859795 UTC

[section ""data" . $krep4_r74ZX_closure" {
     $krep4_r74ZX_closure:
         const :_con_info;
         const $krep3_r74ZW_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.641917192 UTC

[section ""data" . $krep5_r74ZY_closure" {
     $krep5_r74ZY_closure:
         const :_con_info;
         const $krep_r74ZT_closure+2;
         const $krep4_r74ZX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.643662292 UTC

[section ""data" . $krep6_r74ZZ_closure" {
     $krep6_r74ZZ_closure:
         const :_con_info;
         const $krep1_r74ZU_closure+2;
         const $krep5_r74ZY_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.645430602 UTC

[section ""data" . $krep7_r7500_closure" {
     $krep7_r7500_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Const.$tcConst_closure+1;
         const $krep6_r74ZZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.647243343 UTC

[section ""data" . Data.Functor.Const.$tc'Const1_closure" {
     Data.Functor.Const.$tc'Const1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r74ZT_closure+2;
         const $krep7_r7500_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.649114351 UTC

[section ""cstring" . Data.Functor.Const.$tc'Const3_bytes" {
     Data.Functor.Const.$tc'Const3_bytes:
         I8[] [39,67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.650805941 UTC

[section ""data" . Data.Functor.Const.$tc'Const2_closure" {
     Data.Functor.Const.$tc'Const2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$tc'Const3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.652527933 UTC

[section ""data" . Data.Functor.Const.$tc'Const_closure" {
     Data.Functor.Const.$tc'Const_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Const.$trModule_closure+1;
         const Data.Functor.Const.$tc'Const2_closure+1;
         const Data.Functor.Const.$tc'Const1_closure+4;
         const 9035619270378585414;
         const 9797261638746114088;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:21.654524544 UTC

[section ""relreadonly" . S757l_srt" {
     S757l_srt:
         const Data.Functor.Const.$fReadConst4_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Data.Functor.Const.$w$creadsPrec_closure;
         const Data.Functor.Const.$fReadConst_$creadsPrec_closure;
         const Data.Functor.Const.$fReadConst2_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Const.$fReadConst_$creadList_closure;
         const Data.Functor.Const.$w$creadListPrec_closure;
         const Data.Functor.Const.$fReadConst_closure;
         const Data.Functor.Const.$fShowConst1_closure;
         const Data.Functor.Const.$w$cshowsPrec_closure;
         const Data.Functor.Const.$fShowConst_$cshowsPrec_closure;
         const Data.Functor.Const.$fShowConst_$cshow_closure;
         const Data.Functor.Const.$fShowConst_$cshowList_closure;
         const Data.Functor.Const.$fShowConst_closure;
         const Data.Semigroup.Internal.$fMonoidSum2_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Const.$fFoldableConst1_closure;
         const Data.Functor.Const.$fFoldableConst3_closure;
         const Data.Functor.Const.$fFoldableConst6_closure;
         const Data.Functor.Const.$fFoldableConst8_closure;
         const Data.Semigroup.Internal.$fMonoidProduct2_closure;
         const Data.Functor.Const.$fApplicativeConst_closure;
         const Data.Functor.Const.$fFunctorConst_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:24.921228293 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:24.922364826 UTC

[section ""data" . Data.Functor.Const.$fReadConst3_closure" {
     Data.Functor.Const.$fReadConst3_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:24.9240666 UTC

[section ""cstring" . Data.Functor.Const.$fReadConst5_bytes" {
     Data.Functor.Const.$fReadConst5_bytes:
         I8[] [67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:24.925963482 UTC

[section ""data" . Data.Functor.Const.$fReadConst4_closure" {
     Data.Functor.Const.$fReadConst4_closure:
         const Data.Functor.Const.$fReadConst4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fReadConst4_entry() //  [R1]
         { info_tbl: [(c778y,
                       label: Data.Functor.Const.$fReadConst4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c778y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c778z; else goto c778A;
       c778z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c778A: // global
           (_c778v::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c778v::I64 == 0) goto c778x; else goto c778w;
       c778x: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c778w: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c778v::I64;
           R2 = Data.Functor.Const.$fReadConst5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:24.931567831 UTC

[section ""data" . Data.Functor.Const.$w$creadsPrec_closure" {
     Data.Functor.Const.$w$creadsPrec_closure:
         const Data.Functor.Const.$w$creadsPrec_info;
         const 0;
 },
 go1_s773f_entry() //  [R1, R2]
         { info_tbl: [(c779l,
                       label: go1_s773f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c779l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c779m; else goto c779n;
       c779m: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c779n: // global
           I64[Sp - 24] = block_c779e_info;
           _s773f::P64 = R1;
           _s773e::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s773e::P64;
           P64[Sp - 8] = _s773f::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u779F; else goto c779f;
       u779F: // global
           call _c779e(R1) args: 0, res: 0, upd: 0;
       c779f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c779e() //  [R1]
         { info_tbl: [(c779e,
                       label: block_c779e_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c779e: // global
           if (R1 & 7 == 1) goto c779i; else goto c779j;
       c779i: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c779j: // global
           I64[Sp] = block_c779t_info;
           _s773j::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _s773j::P64;
           if (R1 & 7 != 0) goto u779E; else goto c779u;
       u779E: // global
           call _c779t(R1) args: 0, res: 0, upd: 0;
       c779u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c779t() //  [R1]
         { info_tbl: [(c779t,
                       label: block_c779t_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c779t: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c779D; else goto c779C;
       c779D: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c779C: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s7735_entry() //  [R1, R2]
         { info_tbl: [(c779K,
                       label: go_s7735_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c779K: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c779L; else goto u77a5;
       c779L: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u77a5: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _c778P() args: 0, res: 0, upd: 0;
     }
 },
 _c778P() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c778P: // global
           _s7732::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_c778S_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7732::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u77a7; else goto c778T;
       u77a7: // global
           call _c778S(R1) args: 0, res: 0, upd: 0;
       c778T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c778S() //  [R1]
         { info_tbl: [(c778S,
                       label: block_c778S_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c778S: // global
           if (R1 & 7 == 1) goto c779H; else goto c779I;
       c779H: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c779I: // global
           I64[Sp - 8] = block_c778Y_info;
           _s7739::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s7739::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u77a8; else goto c778Z;
       u77a8: // global
           call _c778Y(R1) args: 0, res: 0, upd: 0;
       c778Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c778Y() //  [R1]
         { info_tbl: [(c778Y,
                       label: block_c778Y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c778Y: // global
           I64[Sp - 8] = block_c7793_info;
           R3 = Data.Functor.Const.$fReadConst4_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7793() //  [R1]
         { info_tbl: [(c7793,
                       label: block_c7793_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7793: // global
           _s7739::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c779U; else goto c779W;
       c779U: // global
           P64[Sp + 32] = _s7739::P64;
           Sp = Sp + 24;
           call _c778P() args: 0, res: 0, upd: 0;
       c779W: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c779Z; else goto c779Y;
       c779Z: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c779Y: // global
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _s7739::P64;
           I64[Hp - 8] = go1_s773f_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 24] = block_c779V_info;
           R2 = P64[Sp + 32];
           I64[Sp] = stg_ap_pp_info;
           _s773c::P64 = P64[Sp + 8];
           P64[Sp + 8] = Data.Functor.Const.$fReadConst3_closure+1;
           P64[Sp + 16] = _s773c::P64;
           P64[Sp + 32] = Hp - 7;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c779V() //  [R1]
         { info_tbl: [(c779V,
                       label: block_c779V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c779V: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_s773f_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s773u_entry() //  [R1, R2]
         { info_tbl: [(c77ai,
                       label: sat_s773u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ai: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77aj; else goto c77ak;
       c77aj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77ak: // global
           I64[Sp - 16] = block_c77ag_info;
           R3 = R2;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c77ag() //  [R1]
         { info_tbl: [(c77ag,
                       label: block_c77ag_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ag: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s7735_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$w$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c77aq,
                       label: Data.Functor.Const.$w$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77aq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c77au; else goto c77at;
       c77au: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$w$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c77at: // global
           I64[Hp - 24] = go_s7735_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s773u_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           _s773r::P64 = I64[(%MO_S_Gt_W64(R3,
                                           10) << 3) + GHC.Types.Bool_closure_tbl];
           R3 = Hp - 7;
           R2 = _s773r::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:24.956830862 UTC

[section ""data" . Data.Functor.Const.$fReadConst_$creadsPrec_closure" {
     Data.Functor.Const.$fReadConst_$creadsPrec_closure:
         const Data.Functor.Const.$fReadConst_$creadsPrec_info;
         const 0;
 },
 Data.Functor.Const.$fReadConst_$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c77bX,
                       label: Data.Functor.Const.$fReadConst_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77bX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c77bY; else goto c77bZ;
       c77bY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fReadConst_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c77bZ: // global
           I64[Sp - 24] = block_c77bU_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u77c3; else goto c77bV;
       u77c3: // global
           call _c77bU(R1) args: 0, res: 0, upd: 0;
       c77bV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c77bU() //  [R1]
         { info_tbl: [(c77bU,
                       label: block_c77bU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77bU: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Const.$w$creadsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:24.962981187 UTC

[section ""data" . Data.Functor.Const.$fReadConst2_closure" {
     Data.Functor.Const.$fReadConst2_closure:
         const Data.Functor.Const.$fReadConst2_info;
         const 0;
 },
 sat_s773D_entry() //  [R1, R2]
         { info_tbl: [(c77cn,
                       label: sat_s773D_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77cn: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Const.$fReadConst_$creadsPrec_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fReadConst2_entry() //  [R2, R3, R4]
         { info_tbl: [(c77ct,
                       label: Data.Functor.Const.$fReadConst2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ct: // global
           _s773C::P64 = R4;
           _s773B::P64 = R3;
           _s773A::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c77cu; else goto c77cv;
       c77cv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77cx; else goto c77cw;
       c77cx: // global
           HpAlloc = 24;
           goto c77cu;
       c77cu: // global
           R4 = _s773C::P64;
           R3 = _s773B::P64;
           R2 = _s773A::P64;
           R1 = Data.Functor.Const.$fReadConst2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c77cw: // global
           I64[Hp - 16] = sat_s773D_info;
           P64[Hp - 8] = _s773A::P64;
           P64[Hp] = _s773B::P64;
           I64[Sp - 8] = block_c77cq_info;
           R3 = _s773C::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c77cq() //  [R1]
         { info_tbl: [(c77cq,
                       label: block_c77cq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77cq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c77cA; else goto c77cz;
       c77cA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c77cz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:24.970343202 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst5_closure" {
     Data.Functor.Const.$fFoldableConst5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:24.972598943 UTC

[section ""data" . Data.Functor.Const.$fReadConst_$creadList_closure" {
     Data.Functor.Const.$fReadConst_$creadList_closure:
         const Data.Functor.Const.$fReadConst_$creadList_info;
         const 0;
 },
 sat_s773H_entry() //  [R1, R2, R3]
         { info_tbl: [(c77d4,
                       label: sat_s773H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77d4: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s773I_entry() //  [R1]
         { info_tbl: [(c77d7,
                       label: sat_s773I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77d7: // global
           _s773I::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c77d8; else goto c77d9;
       c77d9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c77db; else goto c77da;
       c77db: // global
           HpAlloc = 16;
           goto c77d8;
       c77d8: // global
           R1 = _s773I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77da: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s773I::P64;
           _s773G::P64 = P64[_s773I::P64 + 16];
           I64[Hp - 8] = sat_s773H_info;
           P64[Hp] = _s773G::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Const.$fFoldableConst5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fReadConst_$creadList_entry() //  [R2]
         { info_tbl: [(c77dc,
                       label: Data.Functor.Const.$fReadConst_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77dc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77dg; else goto c77df;
       c77dg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fReadConst_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77df: // global
           I64[Hp - 16] = sat_s773I_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:24.981712851 UTC

[section ""data" . Data.Functor.Const.$w$creadListPrec_closure" {
     Data.Functor.Const.$w$creadListPrec_closure:
         const Data.Functor.Const.$w$creadListPrec_info;
         const 0;
 },
 sat_s773L_entry() //  [R1, R2, R3]
         { info_tbl: [(c77dN,
                       label: sat_s773L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77dN: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 w1_s773K_entry() //  [R1]
         { info_tbl: [(c77dQ,
                       label: w1_s773K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77dQ: // global
           _s773K::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c77dR; else goto c77dS;
       c77dS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c77dU; else goto c77dT;
       c77dU: // global
           HpAlloc = 16;
           goto c77dR;
       c77dR: // global
           R1 = _s773K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77dT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s773K::P64;
           _s773J::P64 = P64[_s773K::P64 + 16];
           I64[Hp - 8] = sat_s773L_info;
           P64[Hp] = _s773J::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Const.$fFoldableConst5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 w2_s773M_entry() //  [R1, R2]
         { info_tbl: [(c77e0,
                       label: w2_s773M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77e0: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s773Q_entry() //  [R1, R2]
         { info_tbl: [(c77eb,
                       label: sat_s773Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77eb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c77ec; else goto c77ed;
       c77ec: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77ed: // global
           I64[Sp - 8] = block_c77e8_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c77e8() //  [R1]
         { info_tbl: [(c77e8,
                       label: block_c77e8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77e8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c77eg; else goto c77ef;
       c77eg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c77ef: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$w$creadListPrec_entry() //  [R2]
         { info_tbl: [(c77eh,
                       label: Data.Functor.Const.$w$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77eh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c77el; else goto c77ek;
       c77el: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Const.$w$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77ek: // global
           I64[Hp - 48] = w1_s773K_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = w2_s773M_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s773Q_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:24.995549737 UTC

[section ""data" . Data.Functor.Const.$fReadConst1_closure" {
     Data.Functor.Const.$fReadConst1_closure:
         const Data.Functor.Const.$fReadConst1_info;
         const 0;
 },
 Data.Functor.Const.$fReadConst1_entry() //  [R2]
         { info_tbl: [(c77f0,
                       label: Data.Functor.Const.$fReadConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77f0: // global
           R2 = R2;
           call Data.Functor.Const.$w$creadListPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:24.999433364 UTC

[section ""data" . Data.Functor.Const.$fReadConst_closure" {
     Data.Functor.Const.$fReadConst_closure:
         const Data.Functor.Const.$fReadConst_info;
         const 0;
 },
 lvl_s773U_entry() //  [R1]
         { info_tbl: [(c77ff,
                       label: lvl_s773U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ff: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77fg; else goto c77fh;
       c77fg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77fh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$w$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s773Z_entry() //  [R1]
         { info_tbl: [(c77fn,
                       label: sat_s773Z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77fn: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s773X_entry() //  [R1, R2, R3]
         { info_tbl: [(c77fv,
                       label: sat_s773X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77fv: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s773W_entry() //  [R1]
         { info_tbl: [(c77fC,
                       label: sat_s773W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77fC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77fD; else goto c77fE;
       c77fD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77fE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fReadConst_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s773V_entry() //  [R1, R2, R3]
         { info_tbl: [(c77fK,
                       label: sat_s773V_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77fK: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fReadConst_$creadsPrec_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fReadConst_entry() //  [R2]
         { info_tbl: [(c77fO,
                       label: Data.Functor.Const.$fReadConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77fO: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c77fS; else goto c77fR;
       c77fS: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fReadConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77fR: // global
           I64[Hp - 128] = lvl_s773U_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s773Z_info;
           P64[Hp - 96] = Hp - 128;
           I64[Hp - 88] = sat_s773X_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s773W_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s773V_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 46;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.011813404 UTC

[section ""cstring" . Data.Functor.Const.$fShowConst2_bytes" {
     Data.Functor.Const.$fShowConst2_bytes:
         I8[] [67,111,110,115,116,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.013944596 UTC

[section ""data" . Data.Functor.Const.$fShowConst1_closure" {
     Data.Functor.Const.$fShowConst1_closure:
         const Data.Functor.Const.$fShowConst1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fShowConst1_entry() //  [R1]
         { info_tbl: [(c77gz,
                       label: Data.Functor.Const.$fShowConst1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77gz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77gA; else goto c77gB;
       c77gA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77gB: // global
           (_c77gw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c77gw::I64 == 0) goto c77gy; else goto c77gx;
       c77gy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c77gx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c77gw::I64;
           R2 = Data.Functor.Const.$fShowConst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.020186702 UTC

[section ""data" . Data.Functor.Const.$w$cshowsPrec_closure" {
     Data.Functor.Const.$w$cshowsPrec_closure:
         const Data.Functor.Const.$w$cshowsPrec_info;
         const 0;
 },
 g_s7743_entry() //  [R1]
         { info_tbl: [(c77gS,
                       label: g_s7743_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77gS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c77gT; else goto c77gU;
       c77gT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77gU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Const.$fReadConst3_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s7746_entry() //  [R1]
         { info_tbl: [(c77h7,
                       label: sat_s7746_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77h7: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7747_entry() //  [R1, R2]
         { info_tbl: [(c77ha,
                       label: sat_s7747_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ha: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c77he; else goto c77hd;
       c77he: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77hd: // global
           _s7743::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s7746_info;
           P64[Hp - 8] = _s7743::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Functor.Const.$fShowConst1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s774a_entry() //  [R1]
         { info_tbl: [(c77hu,
                       label: sat_s774a_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77hu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77hy; else goto c77hx;
       c77hy: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77hx: // global
           _s7743::P64 = P64[R1 + 16];
           _s7748::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s7748::P64;
           R2 = Hp - 14;
           R1 = _s7743::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s774b_entry() //  [R1]
         { info_tbl: [(c77hz,
                       label: sat_s774b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77hz: // global
           _s774b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c77hA; else goto c77hB;
       c77hB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c77hD; else goto c77hC;
       c77hD: // global
           HpAlloc = 32;
           goto c77hA;
       c77hA: // global
           R1 = _s774b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77hC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s774b::P64;
           _s7743::P64 = P64[_s774b::P64 + 16];
           _s7748::P64 = P64[_s774b::P64 + 24];
           I64[Hp - 24] = sat_s774a_info;
           P64[Hp - 8] = _s7743::P64;
           P64[Hp] = _s7748::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Const.$fShowConst1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s774c_entry() //  [R1, R2]
         { info_tbl: [(c77hF,
                       label: sat_s774c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77hF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c77hJ; else goto c77hI;
       c77hJ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77hI: // global
           _s7743::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s774b_info;
           P64[Hp - 32] = _s7743::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c77hN,
                       label: Data.Functor.Const.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77hN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c77hR; else goto c77hQ;
       c77hR: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c77hQ: // global
           I64[Hp - 40] = g_s7743_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c77gO::P64 = Hp - 40;
           if (%MO_S_Le_W64(R3, 10)) goto c77hL; else goto c77hM;
       c77hL: // global
           I64[Hp - 8] = sat_s7747_info;
           P64[Hp] = _c77gO::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c77hM: // global
           I64[Hp - 8] = sat_s774c_info;
           P64[Hp] = _c77gO::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.036593172 UTC

[section ""data" . Data.Functor.Const.$fShowConst_$cshowsPrec_closure" {
     Data.Functor.Const.$fShowConst_$cshowsPrec_closure:
         const Data.Functor.Const.$fShowConst_$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Const.$fShowConst_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c77iG,
                       label: Data.Functor.Const.$fShowConst_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77iG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c77iH; else goto c77iI;
       c77iH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c77iI: // global
           I64[Sp - 24] = block_c77iD_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u77iM; else goto c77iE;
       u77iM: // global
           call _c77iD(R1) args: 0, res: 0, upd: 0;
       c77iE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c77iD() //  [R1]
         { info_tbl: [(c77iD,
                       label: block_c77iD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77iD: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Const.$w$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.042506795 UTC

[section ""data" . Data.Functor.Const.$fShowConst_$cshow_closure" {
     Data.Functor.Const.$fShowConst_$cshow_closure:
         const Data.Functor.Const.$fShowConst_$cshow_info;
         const 0;
 },
 sat_s774k_entry() //  [R1]
         { info_tbl: [(c77j5,
                       label: sat_s774k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77j5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c77j6; else goto c77j7;
       c77j6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77j7: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Functor.Const.$fReadConst3_closure+1;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fShowConst_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c77j8,
                       label: Data.Functor.Const.$fShowConst_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77j8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c77jc; else goto c77jb;
       c77jc: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c77jb: // global
           I64[Hp - 24] = sat_s774k_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Functor.Const.$fShowConst1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.048712647 UTC

[section ""data" . Data.Functor.Const.$fShowConst_$cshowList_closure" {
     Data.Functor.Const.$fShowConst_$cshowList_closure:
         const Data.Functor.Const.$fShowConst_$cshowList_info;
         const 0;
 },
 sat_s774p_entry() //  [R1, R2]
         { info_tbl: [(c77jA,
                       label: sat_s774p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77jA: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Functor.Const.$w$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fShowConst_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c77jD,
                       label: Data.Functor.Const.$fShowConst_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77jD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c77jH; else goto c77jG;
       c77jH: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c77jG: // global
           I64[Hp - 8] = sat_s774p_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.055460005 UTC

[section ""data" . Data.Functor.Const.$fShowConst_closure" {
     Data.Functor.Const.$fShowConst_closure:
         const Data.Functor.Const.$fShowConst_info;
         const 0;
 },
 sat_s774t_entry() //  [R1, R2, R3]
         { info_tbl: [(c77jZ,
                       label: sat_s774t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77jZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fShowConst_$cshowList_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s774s_entry() //  [R1, R2]
         { info_tbl: [(c77k7,
                       label: sat_s774s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77k7: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Const.$fShowConst_$cshow_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s774r_entry() //  [R1, R2, R3]
         { info_tbl: [(c77kf,
                       label: sat_s774r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77kf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Const.$fShowConst_$cshowsPrec_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fShowConst_entry() //  [R2]
         { info_tbl: [(c77kj,
                       label: Data.Functor.Const.$fShowConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77kj: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c77kn; else goto c77km;
       c77kn: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Const.$fShowConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77km: // global
           I64[Hp - 72] = sat_s774t_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s774s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s774r_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.064081029 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldMap_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldMap_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldMap_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldMap_entry() //  [R2]
         { info_tbl: [(c77kN,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77kN: // global
           R2 = R2;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.0680048 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfold_closure" {
     Data.Functor.Const.$fFoldableConst_$cfold_closure:
         const Data.Functor.Const.$fFoldableConst_$cfold_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfold_entry() //  [R2]
         { info_tbl: [(c77kY,
                       label: Data.Functor.Const.$fFoldableConst_$cfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77kY: // global
           R2 = R2;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.071242446 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$csum_closure" {
     Data.Functor.Const.$fFoldableConst_$csum_closure:
         const Data.Functor.Const.$fFoldableConst_$csum_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$csum_entry() //  [R2]
         { info_tbl: [(c77l9,
                       label: Data.Functor.Const.$fFoldableConst_$csum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77l9: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fMonoidSum2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.074526981 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst2_bytes" {
     Data.Functor.Const.$fFoldableConst2_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.076391917 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst1_closure" {
     Data.Functor.Const.$fFoldableConst1_closure:
         const Data.Functor.Const.$fFoldableConst1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst1_entry() //  [R1]
         { info_tbl: [(c77ln,
                       label: Data.Functor.Const.$fFoldableConst1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ln: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77lo; else goto c77lp;
       c77lo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77lp: // global
           (_c77lk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c77lk::I64 == 0) goto c77lm; else goto c77ll;
       c77lm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c77ll: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c77lk::I64;
           R2 = Data.Functor.Const.$fFoldableConst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.082035812 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cminimum_closure" {
     Data.Functor.Const.$fFoldableConst_$cminimum_closure:
         const Data.Functor.Const.$fFoldableConst_$cminimum_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cminimum_entry() //  []
         { info_tbl: [(c77lC,
                       label: Data.Functor.Const.$fFoldableConst_$cminimum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77lC: // global
           R2 = Data.Functor.Const.$fFoldableConst1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.085903886 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst4_bytes" {
     Data.Functor.Const.$fFoldableConst4_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.087735724 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst3_closure" {
     Data.Functor.Const.$fFoldableConst3_closure:
         const Data.Functor.Const.$fFoldableConst3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst3_entry() //  [R1]
         { info_tbl: [(c77lQ,
                       label: Data.Functor.Const.$fFoldableConst3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77lQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77lR; else goto c77lS;
       c77lR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77lS: // global
           (_c77lN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c77lN::I64 == 0) goto c77lP; else goto c77lO;
       c77lP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c77lO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c77lN::I64;
           R2 = Data.Functor.Const.$fFoldableConst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.091683613 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cmaximum_closure" {
     Data.Functor.Const.$fFoldableConst_$cmaximum_closure:
         const Data.Functor.Const.$fFoldableConst_$cmaximum_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cmaximum_entry() //  []
         { info_tbl: [(c77m5,
                       label: Data.Functor.Const.$fFoldableConst_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77m5: // global
           R2 = Data.Functor.Const.$fFoldableConst3_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.095620035 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$celem_closure" {
     Data.Functor.Const.$fFoldableConst_$celem_closure:
         const Data.Functor.Const.$fFoldableConst_$celem_info;
 },
 Data.Functor.Const.$fFoldableConst_$celem_entry() //  []
         { info_tbl: [(c77mg,
                       label: Data.Functor.Const.$fFoldableConst_$celem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77mg: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.099018652 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldl_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldl_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldl_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldl_entry() //  [R3]
         { info_tbl: [(c77mt,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77mt: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.102225897 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst7_bytes" {
     Data.Functor.Const.$fFoldableConst7_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.104107726 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst6_closure" {
     Data.Functor.Const.$fFoldableConst6_closure:
         const Data.Functor.Const.$fFoldableConst6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst6_entry() //  [R1]
         { info_tbl: [(c77mH,
                       label: Data.Functor.Const.$fFoldableConst6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77mH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77mI; else goto c77mJ;
       c77mI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77mJ: // global
           (_c77mE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c77mE::I64 == 0) goto c77mG; else goto c77mF;
       c77mG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c77mF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c77mE::I64;
           R2 = Data.Functor.Const.$fFoldableConst7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.108593818 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldl1_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldl1_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldl1_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldl1_entry() //  []
         { info_tbl: [(c77mW,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77mW: // global
           R2 = Data.Functor.Const.$fFoldableConst6_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.111969901 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldr'_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldr'_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldr'_info;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldr'_entry() //  [R3]
         { info_tbl: [(c77n7,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77n7: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.116120286 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$clength_closure" {
     Data.Functor.Const.$fFoldableConst_$clength_closure:
         const Data.Functor.Const.$fFoldableConst_$clength_info;
 },
 Data.Functor.Const.$fFoldableConst_$clength_entry() //  []
         { info_tbl: [(c77ni,
                       label: Data.Functor.Const.$fFoldableConst_$clength_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ni: // global
           R1 = Data.Functor.Const.$fFoldableConst5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.119288906 UTC

[section ""cstring" . Data.Functor.Const.$fFoldableConst9_bytes" {
     Data.Functor.Const.$fFoldableConst9_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.121063963 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst8_closure" {
     Data.Functor.Const.$fFoldableConst8_closure:
         const Data.Functor.Const.$fFoldableConst8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst8_entry() //  [R1]
         { info_tbl: [(c77nx,
                       label: Data.Functor.Const.$fFoldableConst8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77nx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77ny; else goto c77nz;
       c77ny: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77nz: // global
           (_c77nu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c77nu::I64 == 0) goto c77nw; else goto c77nv;
       c77nw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c77nv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c77nu::I64;
           R2 = Data.Functor.Const.$fFoldableConst9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.125940851 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cfoldr1_closure" {
     Data.Functor.Const.$fFoldableConst_$cfoldr1_closure:
         const Data.Functor.Const.$fFoldableConst_$cfoldr1_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cfoldr1_entry() //  []
         { info_tbl: [(c77nM,
                       label: Data.Functor.Const.$fFoldableConst_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77nM: // global
           R2 = Data.Functor.Const.$fFoldableConst8_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.129759921 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cnull_closure" {
     Data.Functor.Const.$fFoldableConst_$cnull_closure:
         const Data.Functor.Const.$fFoldableConst_$cnull_info;
 },
 Data.Functor.Const.$fFoldableConst_$cnull_entry() //  []
         { info_tbl: [(c77nX,
                       label: Data.Functor.Const.$fFoldableConst_$cnull_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77nX: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.133928119 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$cproduct_closure" {
     Data.Functor.Const.$fFoldableConst_$cproduct_closure:
         const Data.Functor.Const.$fFoldableConst_$cproduct_info;
         const 0;
 },
 Data.Functor.Const.$fFoldableConst_$cproduct_entry() //  [R2]
         { info_tbl: [(c77oa,
                       label: Data.Functor.Const.$fFoldableConst_$cproduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77oa: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fMonoidProduct2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.137223808 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_$ctoList_closure" {
     Data.Functor.Const.$fFoldableConst_$ctoList_closure:
         const Data.Functor.Const.$fFoldableConst_$ctoList_info;
 },
 Data.Functor.Const.$fFoldableConst_$ctoList_entry() //  []
         { info_tbl: [(c77ol,
                       label: Data.Functor.Const.$fFoldableConst_$ctoList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ol: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.140572621 UTC

[section ""data" . Data.Functor.Const.$fFoldableConst_closure" {
     Data.Functor.Const.$fFoldableConst_closure:
         const Data.Foldable.C:Foldable_con_info;
         const Data.Functor.Const.$fFoldableConst_$cfold_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cfoldMap_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldr'_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldr'_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldl_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldl_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cfoldr1_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cfoldl1_closure+2;
         const Data.Functor.Const.$fFoldableConst_$ctoList_closure+1;
         const Data.Functor.Const.$fFoldableConst_$cnull_closure+1;
         const Data.Functor.Const.$fFoldableConst_$clength_closure+1;
         const Data.Functor.Const.$fFoldableConst_$celem_closure+3;
         const Data.Functor.Const.$fFoldableConst_$cmaximum_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cminimum_closure+2;
         const Data.Functor.Const.$fFoldableConst_$csum_closure+2;
         const Data.Functor.Const.$fFoldableConst_$cproduct_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.142890403 UTC

[section ""data" . Data.Functor.Const.$fFunctorConst2_closure" {
     Data.Functor.Const.$fFunctorConst2_closure:
         const Data.Functor.Const.$fFunctorConst2_info;
 },
 Data.Functor.Const.$fFunctorConst2_entry() //  [R3]
         { info_tbl: [(c77oz,
                       label: Data.Functor.Const.$fFunctorConst2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77oz: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.146462438 UTC

[section ""data" . Data.Functor.Const.$fFunctorConst1_closure" {
     Data.Functor.Const.$fFunctorConst1_closure:
         const Data.Functor.Const.$fFunctorConst1_info;
 },
 Data.Functor.Const.$fFunctorConst1_entry() //  [R3]
         { info_tbl: [(c77oK,
                       label: Data.Functor.Const.$fFunctorConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77oK: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.150222261 UTC

[section ""data" . Data.Functor.Const.$fFunctorConst_closure" {
     Data.Functor.Const.$fFunctorConst_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Const.$fFunctorConst2_closure+2;
         const Data.Functor.Const.$fFunctorConst1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.152951805 UTC

[section ""data" . Data.Functor.Const.$fApplicativeConst_closure" {
     Data.Functor.Const.$fApplicativeConst_closure:
         const Data.Functor.Const.$fApplicativeConst_info;
         const 0;
 },
 lvl_s7752_entry() //  [R1]
         { info_tbl: [(c77p0,
                       label: lvl_s7752_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77p0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77p1; else goto c77p2;
       c77p1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77p2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775f_entry() //  [R1, R2, R3]
         { info_tbl: [(c77p8,
                       label: sat_s775f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77p8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c77p9; else goto c77pa;
       c77p9: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c77pa: // global
           _s775d::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s775d::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s775c_entry() //  [R1, R2, R3]
         { info_tbl: [(c77pg,
                       label: sat_s775c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77pg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c77ph; else goto c77pi;
       c77ph: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c77pi: // global
           _s775a::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s775a::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7759_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c77po,
                       label: sat_s7759_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77po: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c77pp; else goto c77pq;
       c77pp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c77pq: // global
           R2 = P64[R1 + 5];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7755_entry() //  [R1]
         { info_tbl: [(c77pv,
                       label: sat_s7755_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77pv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77pw; else goto c77px;
       c77pw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77px: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7754_entry() //  [R1]
         { info_tbl: [(c77pD,
                       label: sat_s7754_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77pD: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Const.$fApplicativeConst_entry() //  [R2]
         { info_tbl: [(c77pH,
                       label: Data.Functor.Const.$fApplicativeConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77pH: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c77pL; else goto c77pK;
       c77pL: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Functor.Const.$fApplicativeConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77pK: // global
           I64[Hp - 160] = lvl_s7752_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s775f_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s775c_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s7759_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s7755_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s7754_info;
           P64[Hp - 56] = Hp - 160;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Data.Functor.Const.$fFunctorConst_closure+1;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 101;
           P64[Hp - 8] = Hp - 118;
           P64[Hp] = Hp - 134;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.169195359 UTC

[section ""data" . Data.Functor.Const.$fStorableConst_closure" {
     Data.Functor.Const.$fStorableConst_closure:
         const Data.Functor.Const.$fStorableConst_info;
 },
 sat_s775o_entry() //  [R1]
         { info_tbl: [(c77qF,
                       label: sat_s775o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77qF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77qG; else goto c77qH;
       c77qG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77qH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775n_entry() //  [R1]
         { info_tbl: [(c77qM,
                       label: sat_s775n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77qM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77qN; else goto c77qO;
       c77qN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77qO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775m_entry() //  [R1]
         { info_tbl: [(c77qT,
                       label: sat_s775m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77qT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77qU; else goto c77qV;
       c77qU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77qV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775l_entry() //  [R1]
         { info_tbl: [(c77r0,
                       label: sat_s775l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77r0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77r1; else goto c77r2;
       c77r1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77r2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775k_entry() //  [R1]
         { info_tbl: [(c77r7,
                       label: sat_s775k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77r7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77r8; else goto c77r9;
       c77r8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77r9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775j_entry() //  [R1]
         { info_tbl: [(c77re,
                       label: sat_s775j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77re: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77rf; else goto c77rg;
       c77rf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77rg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775i_entry() //  [R1]
         { info_tbl: [(c77rl,
                       label: sat_s775i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77rl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77rm; else goto c77rn;
       c77rm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77rn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.alignment_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775h_entry() //  [R1]
         { info_tbl: [(c77rs,
                       label: sat_s775h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77rs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77rt; else goto c77ru;
       c77rt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77ru: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fStorableConst_entry() //  [R2]
         { info_tbl: [(c77rw,
                       label: Data.Functor.Const.$fStorableConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77rw: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c77rA; else goto c77rz;
       c77rA: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Const.$fStorableConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77rz: // global
           I64[Hp - 256] = sat_s775o_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s775n_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s775m_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s775l_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s775k_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s775j_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s775i_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s775h_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.190848226 UTC

[section ""data" . Data.Functor.Const.$fNumConst_closure" {
     Data.Functor.Const.$fNumConst_closure:
         const Data.Functor.Const.$fNumConst_info;
 },
 sat_s775w_entry() //  [R1]
         { info_tbl: [(c77sJ,
                       label: sat_s775w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77sJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77sK; else goto c77sL;
       c77sK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77sL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775v_entry() //  [R1]
         { info_tbl: [(c77sQ,
                       label: sat_s775v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77sQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77sR; else goto c77sS;
       c77sR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77sS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775u_entry() //  [R1]
         { info_tbl: [(c77sX,
                       label: sat_s775u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77sX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77sY; else goto c77sZ;
       c77sY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77sZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775t_entry() //  [R1]
         { info_tbl: [(c77t4,
                       label: sat_s775t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77t4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77t5; else goto c77t6;
       c77t5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77t6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775s_entry() //  [R1]
         { info_tbl: [(c77tb,
                       label: sat_s775s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77tb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77tc; else goto c77td;
       c77tc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77td: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775r_entry() //  [R1]
         { info_tbl: [(c77ti,
                       label: sat_s775r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ti: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77tj; else goto c77tk;
       c77tj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77tk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775q_entry() //  [R1]
         { info_tbl: [(c77tp,
                       label: sat_s775q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77tp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77tq; else goto c77tr;
       c77tq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77tr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fNumConst_entry() //  [R2]
         { info_tbl: [(c77tt,
                       label: Data.Functor.Const.$fNumConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77tt: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c77tx; else goto c77tw;
       c77tx: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Const.$fNumConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77tw: // global
           I64[Hp - 224] = sat_s775w_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s775v_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s775u_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s775t_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s775s_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s775r_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s775q_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.208033707 UTC

[section ""data" . Data.Functor.Const.$fRealConst_$cp1Real_closure" {
     Data.Functor.Const.$fRealConst_$cp1Real_closure:
         const Data.Functor.Const.$fRealConst_$cp1Real_info;
 },
 sat_s775y_entry() //  [R1]
         { info_tbl: [(c77uz,
                       label: sat_s775y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77uz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77uA; else goto c77uB;
       c77uA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77uB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealConst_$cp1Real_entry() //  [R2]
         { info_tbl: [(c77uC,
                       label: Data.Functor.Const.$fRealConst_$cp1Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77uC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77uG; else goto c77uF;
       c77uG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealConst_$cp1Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77uF: // global
           I64[Hp - 16] = sat_s775y_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fNumConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.214338834 UTC

[section ""data" . Data.Functor.Const.$fSemigroupConst_closure" {
     Data.Functor.Const.$fSemigroupConst_closure:
         const Data.Functor.Const.$fSemigroupConst_info;
 },
 sat_s775D_entry() //  [R1, R2]
         { info_tbl: [(c77v0,
                       label: sat_s775D_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77v0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77v1; else goto c77v2;
       c77v1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77v2: // global
           _s775C::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s775C::P64;
           Sp = Sp - 16;
           call GHC.Base.stimes_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s775B_entry() //  [R1]
         { info_tbl: [(c77v7,
                       label: sat_s775B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77v7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77v8; else goto c77v9;
       c77v8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77v9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.sconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775A_entry() //  [R1]
         { info_tbl: [(c77ve,
                       label: sat_s775A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ve: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77vf; else goto c77vg;
       c77vf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77vg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fSemigroupConst_entry() //  [R2]
         { info_tbl: [(c77vi,
                       label: Data.Functor.Const.$fSemigroupConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77vi: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c77vm; else goto c77vl;
       c77vm: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = Data.Functor.Const.$fSemigroupConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77vl: // global
           I64[Hp - 88] = sat_s775D_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s775B_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s775A_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 87;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.224512712 UTC

[section ""data" . Data.Functor.Const.$fMonoidConst_$cp1Monoid_closure" {
     Data.Functor.Const.$fMonoidConst_$cp1Monoid_closure:
         const Data.Functor.Const.$fMonoidConst_$cp1Monoid_info;
 },
 sat_s775F_entry() //  [R1]
         { info_tbl: [(c77vW,
                       label: sat_s775F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77vW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77vX; else goto c77vY;
       c77vX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77vY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fMonoidConst_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(c77vZ,
                       label: Data.Functor.Const.$fMonoidConst_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77vZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77w3; else goto c77w2;
       c77w3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fMonoidConst_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77w2: // global
           I64[Hp - 16] = sat_s775F_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fSemigroupConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.231233587 UTC

[section ""data" . Data.Functor.Const.$fMonoidConst_closure" {
     Data.Functor.Const.$fMonoidConst_closure:
         const Data.Functor.Const.$fMonoidConst_info;
 },
 sat_s775K_entry() //  [R1]
         { info_tbl: [(c77wm,
                       label: sat_s775K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77wm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77wn; else goto c77wo;
       c77wn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77wo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775J_entry() //  [R1]
         { info_tbl: [(c77wt,
                       label: sat_s775J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77wt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77wu; else goto c77wv;
       c77wu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77wv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775I_entry() //  [R1]
         { info_tbl: [(c77wA,
                       label: sat_s775I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77wA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77wB; else goto c77wC;
       c77wB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77wC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775H_entry() //  [R1]
         { info_tbl: [(c77wH,
                       label: sat_s775H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77wH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77wI; else goto c77wJ;
       c77wI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77wJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fMonoidConst_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fMonoidConst_entry() //  [R2]
         { info_tbl: [(c77wL,
                       label: Data.Functor.Const.$fMonoidConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77wL: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c77wP; else goto c77wO;
       c77wP: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fMonoidConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77wO: // global
           I64[Hp - 128] = sat_s775K_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s775J_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s775I_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s775H_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.242665413 UTC

[section ""data" . Data.Functor.Const.$fGeneric1Const1_closure" {
     Data.Functor.Const.$fGeneric1Const1_closure:
         const Data.Functor.Const.$fGeneric1Const1_info;
 },
 Data.Functor.Const.$fGeneric1Const1_entry() //  [R2]
         { info_tbl: [(c77xs,
                       label: Data.Functor.Const.$fGeneric1Const1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77xs: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.246222495 UTC

[section ""data" . Data.Functor.Const.$fGeneric1Const2_closure" {
     Data.Functor.Const.$fGeneric1Const2_closure:
         const Data.Functor.Const.$fGeneric1Const2_info;
 },
 Data.Functor.Const.$fGeneric1Const2_entry() //  [R2]
         { info_tbl: [(c77xD,
                       label: Data.Functor.Const.$fGeneric1Const2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77xD: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.250385612 UTC

[section ""data" . Data.Functor.Const.$fGeneric1Const_closure" {
     Data.Functor.Const.$fGeneric1Const_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Const.$fGeneric1Const2_closure+1;
         const Data.Functor.Const.$fGeneric1Const1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.25216172 UTC

[section ""data" . Data.Functor.Const.$fGenericConst1_closure" {
     Data.Functor.Const.$fGenericConst1_closure:
         const Data.Functor.Const.$fGenericConst1_info;
 },
 Data.Functor.Const.$fGenericConst1_entry() //  [R2]
         { info_tbl: [(c77xP,
                       label: Data.Functor.Const.$fGenericConst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77xP: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.255421773 UTC

[section ""data" . Data.Functor.Const.$fGenericConst2_closure" {
     Data.Functor.Const.$fGenericConst2_closure:
         const Data.Functor.Const.$fGenericConst2_info;
 },
 Data.Functor.Const.$fGenericConst2_entry() //  [R2]
         { info_tbl: [(c77y0,
                       label: Data.Functor.Const.$fGenericConst2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77y0: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.258615971 UTC

[section ""data" . Data.Functor.Const.$fGenericConst_closure" {
     Data.Functor.Const.$fGenericConst_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Const.$fGenericConst2_closure+1;
         const Data.Functor.Const.$fGenericConst1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.260727956 UTC

[section ""data" . Data.Functor.Const.$fFractionalConst_$cp1Fractional_closure" {
     Data.Functor.Const.$fFractionalConst_$cp1Fractional_closure:
         const Data.Functor.Const.$fFractionalConst_$cp1Fractional_info;
 },
 sat_s775Q_entry() //  [R1]
         { info_tbl: [(c77yg,
                       label: sat_s775Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77yg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77yh; else goto c77yi;
       c77yh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77yi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFractionalConst_$cp1Fractional_entry() //  [R2]
         { info_tbl: [(c77yj,
                       label: Data.Functor.Const.$fFractionalConst_$cp1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77yj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77yn; else goto c77ym;
       c77yn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fFractionalConst_$cp1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77ym: // global
           I64[Hp - 16] = sat_s775Q_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fNumConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.267283956 UTC

[section ""data" . Data.Functor.Const.$fFractionalConst_closure" {
     Data.Functor.Const.$fFractionalConst_closure:
         const Data.Functor.Const.$fFractionalConst_info;
 },
 sat_s775V_entry() //  [R1]
         { info_tbl: [(c77yG,
                       label: sat_s775V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77yG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77yH; else goto c77yI;
       c77yH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77yI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.fromRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775U_entry() //  [R1]
         { info_tbl: [(c77yN,
                       label: sat_s775U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77yN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77yO; else goto c77yP;
       c77yO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77yP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775T_entry() //  [R1]
         { info_tbl: [(c77yU,
                       label: sat_s775T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77yU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77yV; else goto c77yW;
       c77yV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77yW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real./_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s775S_entry() //  [R1]
         { info_tbl: [(c77z1,
                       label: sat_s775S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77z1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77z2; else goto c77z3;
       c77z2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77z3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fFractionalConst_$cp1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFractionalConst_entry() //  [R2]
         { info_tbl: [(c77z5,
                       label: Data.Functor.Const.$fFractionalConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77z5: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c77z9; else goto c77z8;
       c77z9: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fFractionalConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77z8: // global
           I64[Hp - 128] = sat_s775V_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s775U_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s775T_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s775S_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.279106517 UTC

[section ""data" . Data.Functor.Const.$fRealFracConst_$cp2RealFrac_closure" {
     Data.Functor.Const.$fRealFracConst_$cp2RealFrac_closure:
         const Data.Functor.Const.$fRealFracConst_$cp2RealFrac_info;
 },
 sat_s775X_entry() //  [R1]
         { info_tbl: [(c77zQ,
                       label: sat_s775X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77zQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77zR; else goto c77zS;
       c77zR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77zS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFracConst_$cp2RealFrac_entry() //  [R2]
         { info_tbl: [(c77zT,
                       label: Data.Functor.Const.$fRealFracConst_$cp2RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77zT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77zX; else goto c77zW;
       c77zX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFracConst_$cp2RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77zW: // global
           I64[Hp - 16] = sat_s775X_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fFractionalConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.285725932 UTC

[section ""data" . Data.Functor.Const.$fFloatingConst_$cp1Floating_closure" {
     Data.Functor.Const.$fFloatingConst_$cp1Floating_closure:
         const Data.Functor.Const.$fFloatingConst_$cp1Floating_info;
 },
 sat_s775Z_entry() //  [R1]
         { info_tbl: [(c77Ag,
                       label: sat_s775Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Ag: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Ah; else goto c77Ai;
       c77Ah: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Ai: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFloatingConst_$cp1Floating_entry() //  [R2]
         { info_tbl: [(c77Aj,
                       label: Data.Functor.Const.$fFloatingConst_$cp1Floating_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Aj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77An; else goto c77Am;
       c77An: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fFloatingConst_$cp1Floating_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77Am: // global
           I64[Hp - 16] = sat_s775Z_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fFractionalConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.293939547 UTC

[section ""data" . Data.Functor.Const.$fFloatingConst_closure" {
     Data.Functor.Const.$fFloatingConst_closure:
         const Data.Functor.Const.$fFloatingConst_info;
 },
 sat_s776n_entry() //  [R1]
         { info_tbl: [(c77AG,
                       label: sat_s776n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77AG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77AH; else goto c77AI;
       c77AH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77AI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1mexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776m_entry() //  [R1]
         { info_tbl: [(c77AN,
                       label: sat_s776m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77AN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77AO; else goto c77AP;
       c77AO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77AP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1pexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776l_entry() //  [R1]
         { info_tbl: [(c77AU,
                       label: sat_s776l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77AU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77AV; else goto c77AW;
       c77AV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77AW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.expm1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776k_entry() //  [R1]
         { info_tbl: [(c77B1,
                       label: sat_s776k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77B1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77B2; else goto c77B3;
       c77B2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77B3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1p_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776j_entry() //  [R1]
         { info_tbl: [(c77B8,
                       label: sat_s776j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77B8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77B9; else goto c77Ba;
       c77B9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Ba: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776i_entry() //  [R1]
         { info_tbl: [(c77Bf,
                       label: sat_s776i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Bf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Bg; else goto c77Bh;
       c77Bg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Bh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776h_entry() //  [R1]
         { info_tbl: [(c77Bm,
                       label: sat_s776h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Bm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Bn; else goto c77Bo;
       c77Bn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Bo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776g_entry() //  [R1]
         { info_tbl: [(c77Bt,
                       label: sat_s776g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Bt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Bu; else goto c77Bv;
       c77Bu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Bv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776f_entry() //  [R1]
         { info_tbl: [(c77BA,
                       label: sat_s776f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77BA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77BB; else goto c77BC;
       c77BB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77BC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776e_entry() //  [R1]
         { info_tbl: [(c77BH,
                       label: sat_s776e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77BH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77BI; else goto c77BJ;
       c77BI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77BJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776d_entry() //  [R1]
         { info_tbl: [(c77BO,
                       label: sat_s776d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77BO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77BP; else goto c77BQ;
       c77BP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77BQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776c_entry() //  [R1]
         { info_tbl: [(c77BV,
                       label: sat_s776c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77BV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77BW; else goto c77BX;
       c77BW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77BX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776b_entry() //  [R1]
         { info_tbl: [(c77C2,
                       label: sat_s776b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77C2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77C3; else goto c77C4;
       c77C3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77C4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776a_entry() //  [R1]
         { info_tbl: [(c77C9,
                       label: sat_s776a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77C9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Ca; else goto c77Cb;
       c77Ca: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Cb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7769_entry() //  [R1]
         { info_tbl: [(c77Cg,
                       label: sat_s7769_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Cg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Ch; else goto c77Ci;
       c77Ch: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Ci: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7768_entry() //  [R1]
         { info_tbl: [(c77Cn,
                       label: sat_s7768_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Cn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Co; else goto c77Cp;
       c77Co: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Cp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7767_entry() //  [R1]
         { info_tbl: [(c77Cu,
                       label: sat_s7767_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Cu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Cv; else goto c77Cw;
       c77Cv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Cw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.logBase_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7766_entry() //  [R1]
         { info_tbl: [(c77CB,
                       label: sat_s7766_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77CB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77CC; else goto c77CD;
       c77CC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77CD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.**_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7765_entry() //  [R1]
         { info_tbl: [(c77CI,
                       label: sat_s7765_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77CI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77CJ; else goto c77CK;
       c77CJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77CK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sqrt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7764_entry() //  [R1]
         { info_tbl: [(c77CP,
                       label: sat_s7764_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77CP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77CQ; else goto c77CR;
       c77CQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77CR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7763_entry() //  [R1]
         { info_tbl: [(c77CW,
                       label: sat_s7763_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77CW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77CX; else goto c77CY;
       c77CX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77CY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7762_entry() //  [R1]
         { info_tbl: [(c77D3,
                       label: sat_s7762_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77D3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77D4; else goto c77D5;
       c77D4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77D5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.pi_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7761_entry() //  [R1]
         { info_tbl: [(c77Da,
                       label: sat_s7761_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Da: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Db; else goto c77Dc;
       c77Db: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Dc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fFloatingConst_$cp1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFloatingConst_entry() //  [R2]
         { info_tbl: [(c77De,
                       label: Data.Functor.Const.$fFloatingConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77De: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto c77Di; else goto c77Dh;
       c77Di: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Const.$fFloatingConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77Dh: // global
           I64[Hp - 736] = sat_s776n_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_s776m_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_s776l_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_s776k_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_s776j_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_s776i_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_s776h_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_s776g_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_s776f_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_s776e_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_s776d_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_s776c_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_s776b_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_s776a_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_s7769_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_s7768_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_s7767_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_s7766_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_s7765_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_s7764_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_s7763_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s7762_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s7761_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = GHC.Float.C:Floating_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.34314451 UTC

[section ""data" . Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_closure" {
     Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_closure:
         const Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_info;
 },
 sat_s776p_entry() //  [R1]
         { info_tbl: [(c77G8,
                       label: sat_s776p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77G8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77G9; else goto c77Ga;
       c77G9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Ga: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_entry() //  [R2]
         { info_tbl: [(c77Gb,
                       label: Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Gb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77Gf; else goto c77Ge;
       c77Gf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77Ge: // global
           I64[Hp - 16] = sat_s776p_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fFloatingConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.350408936 UTC

[section ""data" . Data.Functor.Const.$fEqConst_closure" {
     Data.Functor.Const.$fEqConst_closure:
         const Data.Functor.Const.$fEqConst_info;
 },
 sat_s776s_entry() //  [R1]
         { info_tbl: [(c77Gy,
                       label: sat_s776s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Gy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Gz; else goto c77GA;
       c77Gz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77GA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776r_entry() //  [R1]
         { info_tbl: [(c77GF,
                       label: sat_s776r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77GF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77GG; else goto c77GH;
       c77GG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77GH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fEqConst_entry() //  [R2]
         { info_tbl: [(c77GJ,
                       label: Data.Functor.Const.$fEqConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77GJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c77GN; else goto c77GM;
       c77GN: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Const.$fEqConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77GM: // global
           I64[Hp - 64] = sat_s776s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s776r_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.358124555 UTC

[section ""data" . Data.Functor.Const.$fOrdConst_$cp1Ord_closure" {
     Data.Functor.Const.$fOrdConst_$cp1Ord_closure:
         const Data.Functor.Const.$fOrdConst_$cp1Ord_info;
 },
 sat_s776u_entry() //  [R1]
         { info_tbl: [(c77Hg,
                       label: sat_s776u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Hg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Hh; else goto c77Hi;
       c77Hh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Hi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fOrdConst_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c77Hj,
                       label: Data.Functor.Const.$fOrdConst_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Hj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77Hn; else goto c77Hm;
       c77Hn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fOrdConst_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77Hm: // global
           I64[Hp - 16] = sat_s776u_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fEqConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.364839806 UTC

[section ""data" . Data.Functor.Const.$fOrdConst_closure" {
     Data.Functor.Const.$fOrdConst_closure:
         const Data.Functor.Const.$fOrdConst_info;
 },
 sat_s776D_entry() //  [R1]
         { info_tbl: [(c77HG,
                       label: sat_s776D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77HG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77HH; else goto c77HI;
       c77HH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77HI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776C_entry() //  [R1]
         { info_tbl: [(c77HN,
                       label: sat_s776C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77HN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77HO; else goto c77HP;
       c77HO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77HP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776B_entry() //  [R1]
         { info_tbl: [(c77HU,
                       label: sat_s776B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77HU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77HV; else goto c77HW;
       c77HV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77HW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776A_entry() //  [R1]
         { info_tbl: [(c77I1,
                       label: sat_s776A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77I1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77I2; else goto c77I3;
       c77I2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77I3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776z_entry() //  [R1]
         { info_tbl: [(c77I8,
                       label: sat_s776z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77I8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77I9; else goto c77Ia;
       c77I9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Ia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776y_entry() //  [R1]
         { info_tbl: [(c77If,
                       label: sat_s776y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77If: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Ig; else goto c77Ih;
       c77Ig: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Ih: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776x_entry() //  [R1]
         { info_tbl: [(c77Im,
                       label: sat_s776x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Im: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77In; else goto c77Io;
       c77In: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Io: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776w_entry() //  [R1]
         { info_tbl: [(c77It,
                       label: sat_s776w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77It: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Iu; else goto c77Iv;
       c77Iu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Iv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fOrdConst_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fOrdConst_entry() //  [R2]
         { info_tbl: [(c77Ix,
                       label: Data.Functor.Const.$fOrdConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Ix: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c77IB; else goto c77IA;
       c77IB: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Const.$fOrdConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77IA: // global
           I64[Hp - 256] = sat_s776D_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s776C_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s776B_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s776A_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s776z_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s776y_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s776x_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s776w_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.384931554 UTC

[section ""data" . Data.Functor.Const.$fIxConst_$cp1Ix_closure" {
     Data.Functor.Const.$fIxConst_$cp1Ix_closure:
         const Data.Functor.Const.$fIxConst_$cp1Ix_info;
 },
 sat_s776F_entry() //  [R1]
         { info_tbl: [(c77JK,
                       label: sat_s776F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77JK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77JL; else goto c77JM;
       c77JL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77JM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.$p1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIxConst_$cp1Ix_entry() //  [R2]
         { info_tbl: [(c77JN,
                       label: Data.Functor.Const.$fIxConst_$cp1Ix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77JN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77JR; else goto c77JQ;
       c77JR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fIxConst_$cp1Ix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77JQ: // global
           I64[Hp - 16] = sat_s776F_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fOrdConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.391609272 UTC

[section ""data" . Data.Functor.Const.$fIxConst_closure" {
     Data.Functor.Const.$fIxConst_closure:
         const Data.Functor.Const.$fIxConst_info;
 },
 sat_s776N_entry() //  [R1]
         { info_tbl: [(c77Ka,
                       label: sat_s776N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Ka: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Kb; else goto c77Kc;
       c77Kb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Kc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeRangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776M_entry() //  [R1]
         { info_tbl: [(c77Kh,
                       label: sat_s776M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Kh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Ki; else goto c77Kj;
       c77Ki: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Kj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.rangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776L_entry() //  [R1]
         { info_tbl: [(c77Ko,
                       label: sat_s776L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Ko: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Kp; else goto c77Kq;
       c77Kp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Kq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.inRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776K_entry() //  [R1]
         { info_tbl: [(c77Kv,
                       label: sat_s776K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Kv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Kw; else goto c77Kx;
       c77Kw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Kx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeIndex_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776J_entry() //  [R1]
         { info_tbl: [(c77KC,
                       label: sat_s776J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77KC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77KD; else goto c77KE;
       c77KD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77KE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.index_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776I_entry() //  [R1]
         { info_tbl: [(c77KJ,
                       label: sat_s776I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77KJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77KK; else goto c77KL;
       c77KK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77KL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.range_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776H_entry() //  [R1]
         { info_tbl: [(c77KQ,
                       label: sat_s776H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77KQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77KR; else goto c77KS;
       c77KR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77KS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fIxConst_$cp1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIxConst_entry() //  [R2]
         { info_tbl: [(c77KU,
                       label: Data.Functor.Const.$fIxConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77KU: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c77KY; else goto c77KX;
       c77KY: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Const.$fIxConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77KX: // global
           I64[Hp - 224] = sat_s776N_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s776M_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s776L_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s776K_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s776J_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s776I_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s776H_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Arr.C:Ix_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.40910097 UTC

[section ""data" . Data.Functor.Const.$fRealConst_$cp2Real_closure" {
     Data.Functor.Const.$fRealConst_$cp2Real_closure:
         const Data.Functor.Const.$fRealConst_$cp2Real_info;
 },
 sat_s776P_entry() //  [R1]
         { info_tbl: [(c77M0,
                       label: sat_s776P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77M0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77M1; else goto c77M2;
       c77M1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77M2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealConst_$cp2Real_entry() //  [R2]
         { info_tbl: [(c77M3,
                       label: Data.Functor.Const.$fRealConst_$cp2Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77M3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77M7; else goto c77M6;
       c77M7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealConst_$cp2Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77M6: // global
           I64[Hp - 16] = sat_s776P_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fOrdConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.416221223 UTC

[section ""data" . Data.Functor.Const.$fRealConst_closure" {
     Data.Functor.Const.$fRealConst_closure:
         const Data.Functor.Const.$fRealConst_info;
 },
 sat_s776T_entry() //  [R1]
         { info_tbl: [(c77Mq,
                       label: sat_s776T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Mq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Mr; else goto c77Ms;
       c77Mr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Ms: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776S_entry() //  [R1]
         { info_tbl: [(c77Mx,
                       label: sat_s776S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Mx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77My; else goto c77Mz;
       c77My: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Mz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealConst_$cp2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776R_entry() //  [R1]
         { info_tbl: [(c77ME,
                       label: sat_s776R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ME: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77MF; else goto c77MG;
       c77MF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77MG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealConst_$cp1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealConst_entry() //  [R2]
         { info_tbl: [(c77MI,
                       label: Data.Functor.Const.$fRealConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77MI: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c77MM; else goto c77ML;
       c77MM: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77ML: // global
           I64[Hp - 96] = sat_s776T_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s776S_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s776R_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.42613264 UTC

[section ""data" . Data.Functor.Const.$fIntegralConst_$cp1Integral_closure" {
     Data.Functor.Const.$fIntegralConst_$cp1Integral_closure:
         const Data.Functor.Const.$fIntegralConst_$cp1Integral_info;
 },
 sat_s776V_entry() //  [R1]
         { info_tbl: [(c77Nm,
                       label: sat_s776V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Nm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Nn; else goto c77No;
       c77Nn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77No: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIntegralConst_$cp1Integral_entry() //  [R2]
         { info_tbl: [(c77Np,
                       label: Data.Functor.Const.$fIntegralConst_$cp1Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Np: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77Nt; else goto c77Ns;
       c77Nt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fIntegralConst_$cp1Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77Ns: // global
           I64[Hp - 16] = sat_s776V_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fRealConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.432046588 UTC

[section ""data" . Data.Functor.Const.$fRealFracConst_$cp1RealFrac_closure" {
     Data.Functor.Const.$fRealFracConst_$cp1RealFrac_closure:
         const Data.Functor.Const.$fRealFracConst_$cp1RealFrac_info;
 },
 sat_s776X_entry() //  [R1]
         { info_tbl: [(c77NM,
                       label: sat_s776X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77NM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77NN; else goto c77NO;
       c77NN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77NO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFracConst_$cp1RealFrac_entry() //  [R2]
         { info_tbl: [(c77NP,
                       label: Data.Functor.Const.$fRealFracConst_$cp1RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77NP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77NT; else goto c77NS;
       c77NT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFracConst_$cp1RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77NS: // global
           I64[Hp - 16] = sat_s776X_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fRealConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.438667964 UTC

[section ""data" . Data.Functor.Const.$fRealFracConst_closure" {
     Data.Functor.Const.$fRealFracConst_closure:
         const Data.Functor.Const.$fRealFracConst_info;
 },
 sat_s777a_entry() //  [R1, R2]
         { info_tbl: [(c77Od,
                       label: sat_s777a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Od: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Oe; else goto c77Of;
       c77Oe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77Of: // global
           _s7779::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7779::P64;
           Sp = Sp - 16;
           call GHC.Real.floor_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7778_entry() //  [R1, R2]
         { info_tbl: [(c77Ol,
                       label: sat_s7778_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Ol: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Om; else goto c77On;
       c77Om: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77On: // global
           _s7777::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7777::P64;
           Sp = Sp - 16;
           call GHC.Real.ceiling_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7776_entry() //  [R1, R2]
         { info_tbl: [(c77Ot,
                       label: sat_s7776_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Ot: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Ou; else goto c77Ov;
       c77Ou: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77Ov: // global
           _s7775::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7775::P64;
           Sp = Sp - 16;
           call GHC.Real.round_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7774_entry() //  [R1, R2]
         { info_tbl: [(c77OB,
                       label: sat_s7774_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77OB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77OC; else goto c77OD;
       c77OC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77OD: // global
           _s7773::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7773::P64;
           Sp = Sp - 16;
           call GHC.Real.truncate_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7772_entry() //  [R1, R2]
         { info_tbl: [(c77OJ,
                       label: sat_s7772_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77OJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77OK; else goto c77OL;
       c77OK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77OL: // global
           _s7771::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s7771::P64;
           Sp = Sp - 16;
           call GHC.Real.properFraction_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7770_entry() //  [R1]
         { info_tbl: [(c77OQ,
                       label: sat_s7770_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77OQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77OR; else goto c77OS;
       c77OR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77OS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFracConst_$cp2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s776Z_entry() //  [R1]
         { info_tbl: [(c77OX,
                       label: sat_s776Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77OX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77OY; else goto c77OZ;
       c77OY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77OZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFracConst_$cp1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFracConst_entry() //  [R2]
         { info_tbl: [(c77P1,
                       label: Data.Functor.Const.$fRealFracConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77P1: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c77P5; else goto c77P4;
       c77P5: // global
           HpAlloc = 192;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFracConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77P4: // global
           I64[Hp - 184] = sat_s777a_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s7778_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s7776_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s7774_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s7772_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s7770_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s776Z_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 119;
           P64[Hp - 24] = Hp - 135;
           P64[Hp - 16] = Hp - 151;
           P64[Hp - 8] = Hp - 167;
           P64[Hp] = Hp - 183;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.457475798 UTC

[section ""data" . Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_closure" {
     Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_closure:
         const Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_info;
 },
 sat_s777c_entry() //  [R1]
         { info_tbl: [(c77Q7,
                       label: sat_s777c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Q7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Q8; else goto c77Q9;
       c77Q8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Q9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_entry() //  [R2]
         { info_tbl: [(c77Qa,
                       label: Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Qa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77Qe; else goto c77Qd;
       c77Qe: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77Qd: // global
           I64[Hp - 16] = sat_s777c_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fRealFracConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.464889362 UTC

[section ""data" . Data.Functor.Const.$fRealFloatConst_closure" {
     Data.Functor.Const.$fRealFloatConst_closure:
         const Data.Functor.Const.$fRealFloatConst_info;
 },
 sat_s777t_entry() //  [R1]
         { info_tbl: [(c77Qx,
                       label: sat_s777t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Qx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Qy; else goto c77Qz;
       c77Qy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Qz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777s_entry() //  [R1]
         { info_tbl: [(c77QE,
                       label: sat_s777s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77QE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77QF; else goto c77QG;
       c77QF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77QG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isIEEE_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777r_entry() //  [R1]
         { info_tbl: [(c77QL,
                       label: sat_s777r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77QL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77QM; else goto c77QN;
       c77QM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77QN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNegativeZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777q_entry() //  [R1]
         { info_tbl: [(c77QS,
                       label: sat_s777q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77QS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77QT; else goto c77QU;
       c77QT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77QU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isDenormalized_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777p_entry() //  [R1]
         { info_tbl: [(c77QZ,
                       label: sat_s777p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77QZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77R0; else goto c77R1;
       c77R0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77R1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isInfinite_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777o_entry() //  [R1]
         { info_tbl: [(c77R6,
                       label: sat_s777o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77R6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77R7; else goto c77R8;
       c77R7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77R8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNaN_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777n_entry() //  [R1]
         { info_tbl: [(c77Rd,
                       label: sat_s777n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Rd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Re; else goto c77Rf;
       c77Re: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Rf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.scaleFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777m_entry() //  [R1]
         { info_tbl: [(c77Rk,
                       label: sat_s777m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Rk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Rl; else goto c77Rm;
       c77Rl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Rm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.significand_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777l_entry() //  [R1]
         { info_tbl: [(c77Rr,
                       label: sat_s777l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Rr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Rs; else goto c77Rt;
       c77Rs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Rt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exponent_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777k_entry() //  [R1]
         { info_tbl: [(c77Ry,
                       label: sat_s777k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Ry: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Rz; else goto c77RA;
       c77Rz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77RA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.encodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777j_entry() //  [R1]
         { info_tbl: [(c77RF,
                       label: sat_s777j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77RF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77RG; else goto c77RH;
       c77RG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77RH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.decodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777i_entry() //  [R1]
         { info_tbl: [(c77RM,
                       label: sat_s777i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77RM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77RN; else goto c77RO;
       c77RN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77RO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777h_entry() //  [R1]
         { info_tbl: [(c77RT,
                       label: sat_s777h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77RT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77RU; else goto c77RV;
       c77RU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77RV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatDigits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777g_entry() //  [R1]
         { info_tbl: [(c77S0,
                       label: sat_s777g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77S0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77S1; else goto c77S2;
       c77S1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77S2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRadix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777f_entry() //  [R1]
         { info_tbl: [(c77S7,
                       label: sat_s777f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77S7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77S8; else goto c77S9;
       c77S8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77S9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFloatConst_$cp2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777e_entry() //  [R1]
         { info_tbl: [(c77Se,
                       label: sat_s777e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Se: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Sf; else goto c77Sg;
       c77Sf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Sg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fRealFloatConst_$cp1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fRealFloatConst_entry() //  [R2]
         { info_tbl: [(c77Si,
                       label: Data.Functor.Const.$fRealFloatConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Si: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto c77Sm; else goto c77Sl;
       c77Sm: // global
           HpAlloc = 520;
           R2 = R2;
           R1 = Data.Functor.Const.$fRealFloatConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77Sl: // global
           I64[Hp - 512] = sat_s777t_info;
           P64[Hp - 496] = R2;
           I64[Hp - 488] = sat_s777s_info;
           P64[Hp - 472] = R2;
           I64[Hp - 464] = sat_s777r_info;
           P64[Hp - 448] = R2;
           I64[Hp - 440] = sat_s777q_info;
           P64[Hp - 424] = R2;
           I64[Hp - 416] = sat_s777p_info;
           P64[Hp - 400] = R2;
           I64[Hp - 392] = sat_s777o_info;
           P64[Hp - 376] = R2;
           I64[Hp - 368] = sat_s777n_info;
           P64[Hp - 352] = R2;
           I64[Hp - 344] = sat_s777m_info;
           P64[Hp - 328] = R2;
           I64[Hp - 320] = sat_s777l_info;
           P64[Hp - 304] = R2;
           I64[Hp - 296] = sat_s777k_info;
           P64[Hp - 280] = R2;
           I64[Hp - 272] = sat_s777j_info;
           P64[Hp - 256] = R2;
           I64[Hp - 248] = sat_s777i_info;
           P64[Hp - 232] = R2;
           I64[Hp - 224] = sat_s777h_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s777g_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s777f_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s777e_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = GHC.Float.C:RealFloat_con_info;
           P64[Hp - 120] = Hp - 152;
           P64[Hp - 112] = Hp - 176;
           P64[Hp - 104] = Hp - 200;
           P64[Hp - 96] = Hp - 224;
           P64[Hp - 88] = Hp - 248;
           P64[Hp - 80] = Hp - 272;
           P64[Hp - 72] = Hp - 296;
           P64[Hp - 64] = Hp - 320;
           P64[Hp - 56] = Hp - 344;
           P64[Hp - 48] = Hp - 368;
           P64[Hp - 40] = Hp - 392;
           P64[Hp - 32] = Hp - 416;
           P64[Hp - 24] = Hp - 440;
           P64[Hp - 16] = Hp - 464;
           P64[Hp - 8] = Hp - 488;
           P64[Hp] = Hp - 512;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.501358364 UTC

[section ""data" . Data.Functor.Const.$fEnumConst_closure" {
     Data.Functor.Const.$fEnumConst_closure:
         const Data.Functor.Const.$fEnumConst_info;
 },
 sat_s777C_entry() //  [R1]
         { info_tbl: [(c77Up,
                       label: sat_s777C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Up: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Uq; else goto c77Ur;
       c77Uq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Ur: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777B_entry() //  [R1]
         { info_tbl: [(c77Uw,
                       label: sat_s777B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Uw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Ux; else goto c77Uy;
       c77Ux: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Uy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777A_entry() //  [R1]
         { info_tbl: [(c77UD,
                       label: sat_s777A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77UD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77UE; else goto c77UF;
       c77UE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77UF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777z_entry() //  [R1]
         { info_tbl: [(c77UK,
                       label: sat_s777z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77UK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77UL; else goto c77UM;
       c77UL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77UM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777y_entry() //  [R1]
         { info_tbl: [(c77UR,
                       label: sat_s777y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77UR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77US; else goto c77UT;
       c77US: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77UT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.fromEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777x_entry() //  [R1]
         { info_tbl: [(c77UY,
                       label: sat_s777x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77UY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77UZ; else goto c77V0;
       c77UZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77V0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.toEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777w_entry() //  [R1]
         { info_tbl: [(c77V5,
                       label: sat_s777w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77V5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77V6; else goto c77V7;
       c77V6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77V7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.pred_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777v_entry() //  [R1]
         { info_tbl: [(c77Vc,
                       label: sat_s777v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Vc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Vd; else goto c77Ve;
       c77Vd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Ve: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.succ_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fEnumConst_entry() //  [R2]
         { info_tbl: [(c77Vg,
                       label: Data.Functor.Const.$fEnumConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Vg: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c77Vk; else goto c77Vj;
       c77Vk: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Const.$fEnumConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77Vj: // global
           I64[Hp - 256] = sat_s777C_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s777B_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s777A_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s777z_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s777y_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s777x_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s777w_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s777v_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.52169781 UTC

[section ""data" . Data.Functor.Const.$fIntegralConst_$cp2Integral_closure" {
     Data.Functor.Const.$fIntegralConst_$cp2Integral_closure:
         const Data.Functor.Const.$fIntegralConst_$cp2Integral_info;
 },
 sat_s777E_entry() //  [R1]
         { info_tbl: [(c77Wt,
                       label: sat_s777E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Wt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Wu; else goto c77Wv;
       c77Wu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Wv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIntegralConst_$cp2Integral_entry() //  [R2]
         { info_tbl: [(c77Ww,
                       label: Data.Functor.Const.$fIntegralConst_$cp2Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Ww: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c77WA; else goto c77Wz;
       c77WA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fIntegralConst_$cp2Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77Wz: // global
           I64[Hp - 16] = sat_s777E_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fEnumConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.528801695 UTC

[section ""data" . Data.Functor.Const.$fIntegralConst_closure" {
     Data.Functor.Const.$fIntegralConst_closure:
         const Data.Functor.Const.$fIntegralConst_info;
 },
 sat_s777O_entry() //  [R1]
         { info_tbl: [(c77WT,
                       label: sat_s777O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77WT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77WU; else goto c77WV;
       c77WU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77WV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777N_entry() //  [R1]
         { info_tbl: [(c77X0,
                       label: sat_s777N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77X0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77X1; else goto c77X2;
       c77X1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77X2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.divMod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777M_entry() //  [R1]
         { info_tbl: [(c77X7,
                       label: sat_s777M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77X7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77X8; else goto c77X9;
       c77X8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77X9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quotRem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777L_entry() //  [R1]
         { info_tbl: [(c77Xe,
                       label: sat_s777L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Xe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Xf; else goto c77Xg;
       c77Xf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Xg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.mod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777K_entry() //  [R1]
         { info_tbl: [(c77Xl,
                       label: sat_s777K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Xl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Xm; else goto c77Xn;
       c77Xm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Xn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.div_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777J_entry() //  [R1]
         { info_tbl: [(c77Xs,
                       label: sat_s777J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Xs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Xt; else goto c77Xu;
       c77Xt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Xu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.rem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777I_entry() //  [R1]
         { info_tbl: [(c77Xz,
                       label: sat_s777I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Xz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77XA; else goto c77XB;
       c77XA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77XB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quot_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777H_entry() //  [R1]
         { info_tbl: [(c77XG,
                       label: sat_s777H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77XG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77XH; else goto c77XI;
       c77XH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77XI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fIntegralConst_$cp2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777G_entry() //  [R1]
         { info_tbl: [(c77XN,
                       label: sat_s777G_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77XN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77XO; else goto c77XP;
       c77XO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77XP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fIntegralConst_$cp1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fIntegralConst_entry() //  [R2]
         { info_tbl: [(c77XR,
                       label: Data.Functor.Const.$fIntegralConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77XR: // global
           Hp = Hp + 296;
           if (Hp > HpLim) (likely: False) goto c77XV; else goto c77XU;
       c77XV: // global
           HpAlloc = 296;
           R2 = R2;
           R1 = Data.Functor.Const.$fIntegralConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77XU: // global
           I64[Hp - 288] = sat_s777O_info;
           P64[Hp - 272] = R2;
           I64[Hp - 264] = sat_s777N_info;
           P64[Hp - 248] = R2;
           I64[Hp - 240] = sat_s777M_info;
           P64[Hp - 224] = R2;
           I64[Hp - 216] = sat_s777L_info;
           P64[Hp - 200] = R2;
           I64[Hp - 192] = sat_s777K_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s777J_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s777I_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s777H_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s777G_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = GHC.Real.C:Integral_con_info;
           P64[Hp - 64] = Hp - 96;
           P64[Hp - 56] = Hp - 120;
           P64[Hp - 48] = Hp - 144;
           P64[Hp - 40] = Hp - 168;
           P64[Hp - 32] = Hp - 192;
           P64[Hp - 24] = Hp - 216;
           P64[Hp - 16] = Hp - 240;
           P64[Hp - 8] = Hp - 264;
           P64[Hp] = Hp - 288;
           R1 = Hp - 71;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.551213601 UTC

[section ""data" . Data.Functor.Const.$fBoundedConst_closure" {
     Data.Functor.Const.$fBoundedConst_closure:
         const Data.Functor.Const.$fBoundedConst_info;
 },
 sat_s777R_entry() //  [R1]
         { info_tbl: [(c77Zb,
                       label: sat_s777R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Zb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Zc; else goto c77Zd;
       c77Zc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Zd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777Q_entry() //  [R1]
         { info_tbl: [(c77Zi,
                       label: sat_s777Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Zi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77Zj; else goto c77Zk;
       c77Zj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77Zk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fBoundedConst_entry() //  [R2]
         { info_tbl: [(c77Zm,
                       label: Data.Functor.Const.$fBoundedConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77Zm: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c77Zq; else goto c77Zp;
       c77Zq: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Const.$fBoundedConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77Zp: // global
           I64[Hp - 64] = sat_s777R_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s777Q_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.559145773 UTC

[section ""data" . Data.Functor.Const.$fBitsConst_$cp1Bits_closure" {
     Data.Functor.Const.$fBitsConst_$cp1Bits_closure:
         const Data.Functor.Const.$fBitsConst_$cp1Bits_info;
 },
 sat_s777T_entry() //  [R1]
         { info_tbl: [(c77ZT,
                       label: sat_s777T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ZT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c77ZU; else goto c77ZV;
       c77ZU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c77ZV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fBitsConst_$cp1Bits_entry() //  [R2]
         { info_tbl: [(c77ZW,
                       label: Data.Functor.Const.$fBitsConst_$cp1Bits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c77ZW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7800; else goto c77ZZ;
       c7800: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fBitsConst_$cp1Bits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c77ZZ: // global
           I64[Hp - 16] = sat_s777T_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fEqConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.567899127 UTC

[section ""data" . Data.Functor.Const.$fBitsConst_closure" {
     Data.Functor.Const.$fBitsConst_closure:
         const Data.Functor.Const.$fBitsConst_info;
 },
 sat_s778h_entry() //  [R1]
         { info_tbl: [(c780j,
                       label: sat_s778h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c780j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c780k; else goto c780l;
       c780k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c780l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.popCount_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s778g_entry() //  [R1]
         { info_tbl: [(c780q,
                       label: sat_s778g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c780q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c780r; else goto c780s;
       c780r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c780s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s778f_entry() //  [R1]
         { info_tbl: [(c780x,
                       label: sat_s778f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c780x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c780y; else goto c780z;
       c780y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c780z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s778e_entry() //  [R1]
         { info_tbl: [(c780E,
                       label: sat_s778e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c780E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c780F; else goto c780G;
       c780F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c780G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s778d_entry() //  [R1]
         { info_tbl: [(c780L,
                       label: sat_s778d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c780L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c780M; else goto c780N;
       c780M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c780N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s778c_entry() //  [R1]
         { info_tbl: [(c780S,
                       label: sat_s778c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c780S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c780T; else goto c780U;
       c780T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c780U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s778b_entry() //  [R1]
         { info_tbl: [(c780Z,
                       label: sat_s778b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c780Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7810; else goto c7811;
       c7810: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7811: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s778a_entry() //  [R1]
         { info_tbl: [(c7816,
                       label: sat_s778a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7816: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7817; else goto c7818;
       c7817: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7818: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.isSigned_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7789_entry() //  [R1]
         { info_tbl: [(c781d,
                       label: sat_s7789_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c781d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c781e; else goto c781f;
       c781e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c781f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7788_entry() //  [R1]
         { info_tbl: [(c781k,
                       label: sat_s7788_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c781k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c781l; else goto c781m;
       c781l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c781m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7787_entry() //  [R1]
         { info_tbl: [(c781r,
                       label: sat_s7787_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c781r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c781s; else goto c781t;
       c781s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c781t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.testBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7786_entry() //  [R1]
         { info_tbl: [(c781y,
                       label: sat_s7786_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c781y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c781z; else goto c781A;
       c781z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c781A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complementBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7785_entry() //  [R1]
         { info_tbl: [(c781F,
                       label: sat_s7785_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c781F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c781G; else goto c781H;
       c781G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c781H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.clearBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7784_entry() //  [R1]
         { info_tbl: [(c781M,
                       label: sat_s7784_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c781M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c781N; else goto c781O;
       c781N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c781O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.setBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7783_entry() //  [R1]
         { info_tbl: [(c781T,
                       label: sat_s7783_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c781T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c781U; else goto c781V;
       c781U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c781V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7782_entry() //  [R1]
         { info_tbl: [(c7820,
                       label: sat_s7782_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7820: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7821; else goto c7822;
       c7821: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7822: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.zeroBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7781_entry() //  [R1]
         { info_tbl: [(c7827,
                       label: sat_s7781_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7827: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7828; else goto c7829;
       c7828: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7829: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7780_entry() //  [R1]
         { info_tbl: [(c782e,
                       label: sat_s7780_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c782e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c782f; else goto c782g;
       c782f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c782g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shift_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777Z_entry() //  [R1]
         { info_tbl: [(c782l,
                       label: sat_s777Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c782l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c782m; else goto c782n;
       c782m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c782n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complement_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777Y_entry() //  [R1]
         { info_tbl: [(c782s,
                       label: sat_s777Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c782s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c782t; else goto c782u;
       c782t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c782u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.xor_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777X_entry() //  [R1]
         { info_tbl: [(c782z,
                       label: sat_s777X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c782z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c782A; else goto c782B;
       c782A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c782B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..|._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777W_entry() //  [R1]
         { info_tbl: [(c782G,
                       label: sat_s777W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c782G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c782H; else goto c782I;
       c782H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c782I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..&._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s777V_entry() //  [R1]
         { info_tbl: [(c782N,
                       label: sat_s777V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c782N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c782O; else goto c782P;
       c782O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c782P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fBitsConst_$cp1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fBitsConst_entry() //  [R2]
         { info_tbl: [(c782R,
                       label: Data.Functor.Const.$fBitsConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c782R: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto c782V; else goto c782U;
       c782V: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Const.$fBitsConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c782U: // global
           I64[Hp - 736] = sat_s778h_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_s778g_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_s778f_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_s778e_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_s778d_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_s778c_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_s778b_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_s778a_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_s7789_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_s7788_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_s7787_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_s7786_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_s7785_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_s7784_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_s7783_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_s7782_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_s7781_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_s7780_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_s777Z_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_s777Y_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_s777X_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s777W_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s777V_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = Data.Bits.C:Bits_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.621709059 UTC

[section ""data" . Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_closure" {
     Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_closure:
         const Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_info;
 },
 sat_s778j_entry() //  [R1]
         { info_tbl: [(c785L,
                       label: sat_s778j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c785L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c785M; else goto c785N;
       c785M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c785N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_entry() //  [R2]
         { info_tbl: [(c785O,
                       label: Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c785O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c785S; else goto c785R;
       c785S: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c785R: // global
           I64[Hp - 16] = sat_s778j_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Const.$fBitsConst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.628051344 UTC

[section ""data" . Data.Functor.Const.$fFiniteBitsConst_closure" {
     Data.Functor.Const.$fFiniteBitsConst_closure:
         const Data.Functor.Const.$fFiniteBitsConst_info;
 },
 sat_s778o_entry() //  [R1]
         { info_tbl: [(c786b,
                       label: sat_s778o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c786b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c786c; else goto c786d;
       c786c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c786d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countTrailingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s778n_entry() //  [R1]
         { info_tbl: [(c786i,
                       label: sat_s778n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c786i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c786j; else goto c786k;
       c786j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c786k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countLeadingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s778m_entry() //  [R1]
         { info_tbl: [(c786p,
                       label: sat_s778m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c786p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c786q; else goto c786r;
       c786q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c786r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s778l_entry() //  [R1]
         { info_tbl: [(c786w,
                       label: sat_s778l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c786w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c786x; else goto c786y;
       c786x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c786y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fFiniteBitsConst_$cp1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Const.$fFiniteBitsConst_entry() //  [R2]
         { info_tbl: [(c786A,
                       label: Data.Functor.Const.$fFiniteBitsConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c786A: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c786E; else goto c786D;
       c786E: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Const.$fFiniteBitsConst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c786D: // global
           I64[Hp - 128] = sat_s778o_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s778n_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s778m_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s778l_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Bits.C:FiniteBits_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.639923778 UTC

[section ""data" . Data.Functor.Const.getConst1_closure" {
     Data.Functor.Const.getConst1_closure:
         const Data.Functor.Const.getConst1_info;
 },
 Data.Functor.Const.getConst1_entry() //  [R2]
         { info_tbl: [(c787h,
                       label: Data.Functor.Const.getConst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c787h: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.64349676 UTC

[section ""data" . Data.Functor.Const.getConst_closure" {
     Data.Functor.Const.getConst_closure:
         const Data.Functor.Const.getConst_info;
 },
 Data.Functor.Const.getConst_entry() //  [R2]
         { info_tbl: [(c787s,
                       label: Data.Functor.Const.getConst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c787s: // global
           R2 = R2;
           call Data.Functor.Const.getConst1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.64694742 UTC

[section ""cstring" . Data.Functor.Const.$trModule4_bytes" {
     Data.Functor.Const.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.64922913 UTC

[section ""data" . Data.Functor.Const.$trModule3_closure" {
     Data.Functor.Const.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.651261525 UTC

[section ""cstring" . Data.Functor.Const.$trModule2_bytes" {
     Data.Functor.Const.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.652957732 UTC

[section ""data" . Data.Functor.Const.$trModule1_closure" {
     Data.Functor.Const.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.654776389 UTC

[section ""data" . Data.Functor.Const.$trModule_closure" {
     Data.Functor.Const.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Const.$trModule3_closure+1;
         const Data.Functor.Const.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.656590953 UTC

[section ""data" . $krep_r74ZT_closure" {
     $krep_r74ZT_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.658351673 UTC

[section ""data" . $krep1_r74ZU_closure" {
     $krep1_r74ZU_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.660113665 UTC

[section ""data" . $krep2_r74ZV_closure" {
     $krep2_r74ZV_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r74ZU_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.661874007 UTC

[section ""data" . Data.Functor.Const.$tcConst1_closure" {
     Data.Functor.Const.$tcConst1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep2_r74ZV_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.663634985 UTC

[section ""data" . $krep3_r74ZW_closure" {
     $krep3_r74ZW_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.665338961 UTC

[section ""data" . Data.Functor.Const.$tcConst2_closure" {
     Data.Functor.Const.$tcConst2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$fReadConst5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.66707635 UTC

[section ""data" . Data.Functor.Const.$tcConst_closure" {
     Data.Functor.Const.$tcConst_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Const.$trModule_closure+1;
         const Data.Functor.Const.$tcConst2_closure+1;
         const Data.Functor.Const.$tcConst1_closure+4;
         const 18204097321285842582;
         const 16882168546145866005;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.668851809 UTC

[section ""data" . $krep4_r74ZX_closure" {
     $krep4_r74ZX_closure:
         const :_con_info;
         const $krep3_r74ZW_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.670650303 UTC

[section ""data" . $krep5_r74ZY_closure" {
     $krep5_r74ZY_closure:
         const :_con_info;
         const $krep_r74ZT_closure+2;
         const $krep4_r74ZX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.672430305 UTC

[section ""data" . $krep6_r74ZZ_closure" {
     $krep6_r74ZZ_closure:
         const :_con_info;
         const $krep1_r74ZU_closure+2;
         const $krep5_r74ZY_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.675167564 UTC

[section ""data" . $krep7_r7500_closure" {
     $krep7_r7500_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Const.$tcConst_closure+1;
         const $krep6_r74ZZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.676847418 UTC

[section ""data" . Data.Functor.Const.$tc'Const1_closure" {
     Data.Functor.Const.$tc'Const1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r74ZT_closure+2;
         const $krep7_r7500_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.678513221 UTC

[section ""cstring" . Data.Functor.Const.$tc'Const3_bytes" {
     Data.Functor.Const.$tc'Const3_bytes:
         I8[] [39,67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.680111273 UTC

[section ""data" . Data.Functor.Const.$tc'Const2_closure" {
     Data.Functor.Const.$tc'Const2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Const.$tc'Const3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.68179905 UTC

[section ""data" . Data.Functor.Const.$tc'Const_closure" {
     Data.Functor.Const.$tc'Const_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Const.$trModule_closure+1;
         const Data.Functor.Const.$tc'Const2_closure+1;
         const Data.Functor.Const.$tc'Const1_closure+4;
         const 9035619270378585414;
         const 9797261638746114088;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:25.683483519 UTC

[section ""relreadonly" . S77av_srt" {
     S77av_srt:
         const Data.Functor.Const.$fReadConst4_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Data.Functor.Const.$w$creadsPrec_closure;
         const Data.Functor.Const.$fReadConst_$creadsPrec_closure;
         const Data.Functor.Const.$fReadConst2_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Const.$fReadConst_$creadList_closure;
         const Data.Functor.Const.$w$creadListPrec_closure;
         const Data.Functor.Const.$fReadConst_closure;
         const Data.Functor.Const.$fShowConst1_closure;
         const Data.Functor.Const.$w$cshowsPrec_closure;
         const Data.Functor.Const.$fShowConst_$cshowsPrec_closure;
         const Data.Functor.Const.$fShowConst_$cshow_closure;
         const Data.Functor.Const.$fShowConst_$cshowList_closure;
         const Data.Functor.Const.$fShowConst_closure;
         const Data.Semigroup.Internal.$fMonoidSum2_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Const.$fFoldableConst1_closure;
         const Data.Functor.Const.$fFoldableConst3_closure;
         const Data.Functor.Const.$fFoldableConst6_closure;
         const Data.Functor.Const.$fFoldableConst8_closure;
         const Data.Semigroup.Internal.$fMonoidProduct2_closure;
         const Data.Functor.Const.$fApplicativeConst_closure;
         const Data.Functor.Const.$fFunctorConst_closure;
 }]

