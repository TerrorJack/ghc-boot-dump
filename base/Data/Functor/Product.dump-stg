
==================== Pre unarise: ====================
2018-03-16 16:11:54.714151475 UTC

Data.Functor.Product.$fEq1Product_$cliftEq
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sg5oo $dEq2_sg5op eq_sg5oq ds_sg5or ds1_sg5os]
        case ds_sg5or of {
          Data.Functor.Product.Pair x1_sg5ou [Occ=Once]
                                    y1_sg5ov [Occ=Once] ->
              case ds1_sg5os of {
                Data.Functor.Product.Pair x2_sg5ox [Occ=Once]
                                          y2_sg5oy [Occ=Once] ->
                    case $dEq1_sg5oo eq_sg5oq x1_sg5ou x2_sg5ox of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> $dEq2_sg5op eq_sg5oq y1_sg5ov y2_sg5oy;
                    };
              };
        };

Data.Functor.Product.$fEq1Product [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     Data.Functor.Classes.Eq1 (Data.Functor.Product.Product f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Product.$fEq1Product_$cliftEq
            eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Product.$w$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> f a -> g a -> f b -> g b -> GHC.Types.Ordering
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5oA
           w1_sg5oB
           w2_sg5oC
           ww_sg5oD
           ww1_sg5oE
           ww2_sg5oF
           ww3_sg5oG]
        case
            Data.Functor.Classes.liftCompare
                w_sg5oA w2_sg5oC ww_sg5oD ww2_sg5oF
        of
        { GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ ->
              Data.Functor.Classes.liftCompare
                  w1_sg5oB w2_sg5oC ww1_sg5oE ww3_sg5oG;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Product.$fOrd1Product_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5oI w1_sg5oJ w2_sg5oK w3_sg5oL w4_sg5oM]
        case w3_sg5oL of {
          Data.Functor.Product.Pair ww1_sg5oO [Occ=Once]
                                    ww2_sg5oP [Occ=Once] ->
              case w4_sg5oM of {
                Data.Functor.Product.Pair ww4_sg5oR [Occ=Once]
                                          ww5_sg5oS [Occ=Once] ->
                    Data.Functor.Product.$w$cliftCompare
                        w_sg5oI w1_sg5oJ w2_sg5oK ww1_sg5oO ww2_sg5oP ww4_sg5oR ww5_sg5oS;
              };
        };

Data.Functor.Product.$w$cp1Ord1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> f a -> g a -> f b -> g b -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5oT
           w1_sg5oU
           w2_sg5oV
           ww_sg5oW
           ww1_sg5oX
           ww2_sg5oY
           ww3_sg5oZ]
        case
            Data.Functor.Classes.$p1Ord1 w_sg5oT w2_sg5oV ww_sg5oW ww2_sg5oY
        of
        { GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True ->
              Data.Functor.Classes.$p1Ord1 w1_sg5oU w2_sg5oV ww1_sg5oX ww3_sg5oZ;
        };

Data.Functor.Product.$fOrd1Product1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5p1 w1_sg5p2 w2_sg5p3 w3_sg5p4 w4_sg5p5]
        case w3_sg5p4 of {
          Data.Functor.Product.Pair ww1_sg5p7 [Occ=Once]
                                    ww2_sg5p8 [Occ=Once] ->
              case w4_sg5p5 of {
                Data.Functor.Product.Pair ww4_sg5pa [Occ=Once]
                                          ww5_sg5pb [Occ=Once] ->
                    Data.Functor.Product.$w$cp1Ord1
                        w_sg5p1 w1_sg5p2 w2_sg5p3 ww1_sg5p7 ww2_sg5p8 ww4_sg5pa ww5_sg5pb;
              };
        };

Data.Functor.Product.$fOrd1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     Data.Functor.Classes.Ord1 (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(C1(C1(U))),C(C1(C1(U))))>m] =
    [] \r [$dOrd1_sg5pc $dOrd2_sg5pd]
        let {
          sat_sg5pf [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Product.Product f_Xg499 g_Xg49b a
               -> Data.Functor.Product.Product f_Xg499 g_Xg49b b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sg5pc $dOrd2_sg5pd] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fOrd1Product_$cliftCompare
                      $dOrd1_sg5pc $dOrd2_sg5pd eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5pe [Occ=Once]
            :: Data.Functor.Classes.Eq1
                 (Data.Functor.Product.Product f_Xg499 g_Xg49b)
          [LclId] =
              [$dOrd1_sg5pc $dOrd2_sg5pd] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fOrd1Product1
                      $dOrd1_sg5pc $dOrd2_sg5pd eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sg5pe sat_sg5pf];

Data.Functor.Product.$fRead1Product3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Pair"#;

Data.Functor.Product.$fRead1Product2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Product.$fRead1Product3;

Data.Functor.Product.$fRead1Product1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Product.$fRead1Product2];

Data.Functor.Product.$fRead1Product_lvl3
  :: Text.ParserCombinators.ReadPrec.Prec
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Product.$fRead1Product_$cliftReadPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5pg $dRead2_sg5ph rp_sg5pi rl_sg5pj]
        let {
          reader_sg5pk [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_ag45N a_ag46b)
          [LclId] =
              [$dRead1_sg5pg rp_sg5pi rl_sg5pj] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead1_sg5pg rp_sg5pi rl_sg5pj; } in
        let {
          reader1_sg5pl [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (g_ag45O a_ag46b)
          [LclId] =
              [$dRead2_sg5ph rp_sg5pi rl_sg5pj] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead2_sg5ph rp_sg5pi rl_sg5pj; } in
        let {
          $wlvl_sg5pm [InlPrag=NOUSERINLINE[0], Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: GHC.Prim.Int#
               -> forall b.
                  (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46b
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [reader_sg5pk reader1_sg5pl] \r [ww_sg5pn w_sg5po]
                  case <=# [ww_sg5pn 10#] of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                    1# ->
                        let {
                          sat_sg5pw [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_sg4P0
                          [LclId] =
                              [reader_sg5pk reader1_sg5pl w_sg5po] \r [a1_sg5pq]
                                  let {
                                    sat_sg5pv [Occ=Once]
                                      :: f_ag45N a_ag46b -> Text.ParserCombinators.ReadP.P b_sg4P0
                                    [LclId] =
                                        [reader1_sg5pl w_sg5po] \r [a2_sg5pr]
                                            let {
                                              sat_sg5pu [Occ=Once]
                                                :: g_ag45O a_ag46b
                                                   -> Text.ParserCombinators.ReadP.P b_sg4P0
                                              [LclId] =
                                                  [w_sg5po a2_sg5pr] \r [a3_sg5ps]
                                                      let {
                                                        sat_sg5pt [Occ=Once]
                                                          :: Data.Functor.Product.Product
                                                               f_ag45N g_ag45O a_ag46b
                                                        [LclId] =
                                                            CCCS Data.Functor.Product.Pair! [a2_sg5pr
                                                                                             a3_sg5ps];
                                                      } in  w_sg5po sat_sg5pt;
                                            } in 
                                              reader1_sg5pl
                                                  Data.Functor.Product.$fRead1Product_lvl3
                                                  sat_sg5pu;
                                  } in 
                                    reader_sg5pk Data.Functor.Product.$fRead1Product_lvl3 sat_sg5pv;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Functor.Product.$fRead1Product1 sat_sg5pw
                          of
                          { Unit# ww2_sg5py [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_sg5py];
                          };
                  }; } in
        let {
          lvl9_sg5pz [InlPrag=NOUSERINLINE[0], Occ=OnceL, Dmd=<L,C(C(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46b
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
              [$wlvl_sg5pm] \r [w_sg5pA w1_sg5pB]
                  case w_sg5pA of {
                    GHC.Types.I# ww1_sg5pD [Occ=Once] ->
                        $wlvl_sg5pm ww1_sg5pD w1_sg5pB;
                  }; } in
        let {
          sat_sg5pG [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46b
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [lvl9_sg5pz] \r [eta_sg5pE eta1_sg5pF]
                  GHC.Read.list3 lvl9_sg5pz eta_sg5pE eta1_sg5pF;
        } in  sat_sg5pG;

Data.Functor.Product.$fRead1Product_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5pH $dRead2_sg5pI rp_sg5pJ rl_sg5pK]
        let {
          ds_sg5pL [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag45N g_ag45O a_ag45U)
          [LclId] =
              [$dRead1_sg5pH $dRead2_sg5pI rp_sg5pJ rl_sg5pK] \u []
                  let {
                    sat_sg5pR [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag45U]
                    [LclId] =
                        [rl_sg5pK] \r [n_sg5pN w1_sg5pO]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sg5pK w1_sg5pO
                            of
                            { Unit# ww1_sg5pQ [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sg5pQ];
                            }; } in
                  let {
                    sat_sg5pM [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag45U
                    [LclId] =
                        [rp_sg5pJ] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sg5pJ eta_B1;
                  } in 
                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                        $dRead1_sg5pH $dRead2_sg5pI sat_sg5pM sat_sg5pR; } in
        let {
          sat_sg5pU [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag45N g_ag45O a_ag45U)
          [LclId] =
              [ds_sg5pL] \r [n_sg5pS]
                  let {
                    sat_sg5pT [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Product.Product f_ag45N g_ag45O a_ag45U)
                    [LclId] =
                        [ds_sg5pL n_sg5pS] \u []
                            ds_sg5pL
                                n_sg5pS Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sg5pT;
        } in  sat_sg5pU;

Data.Functor.Product.$fRead1Product_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Product.Product f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5pV $dRead2_sg5pW rp_sg5pX rl_sg5pY]
        let {
          sat_sg5pZ [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46x)
          [LclId] =
              [$dRead1_sg5pV $dRead2_sg5pW rp_sg5pX rl_sg5pY] \s []
                  Data.Functor.Product.$fRead1Product_$cliftReadPrec
                      $dRead1_sg5pV $dRead2_sg5pW rp_sg5pX rl_sg5pY;
        } in  GHC.Read.list sat_sg5pZ;

Data.Functor.Product.$fRead1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     Data.Functor.Classes.Read1 (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>m] =
    [] \r [$dRead1_sg5q0 $dRead2_sg5q1]
        let {
          sat_sg5q5 [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Product.Product f_ag45N g_ag45O a]
          [LclId] =
              [$dRead1_sg5q0 $dRead2_sg5q1] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fRead1Product_$cliftReadListPrec
                      $dRead1_sg5q0 $dRead2_sg5q1 eta_B2 eta_B1; } in
        let {
          sat_sg5q4 [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Product.Product f_ag45N g_ag45O a)
          [LclId] =
              [$dRead1_sg5q0 $dRead2_sg5q1] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fRead1Product_$cliftReadPrec
                      $dRead1_sg5q0 $dRead2_sg5q1 eta_B2 eta_B1; } in
        let {
          sat_sg5q3 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Product.Product f_ag45N g_ag45O a]
          [LclId] =
              [$dRead1_sg5q0 $dRead2_sg5q1] \u []
                  Data.Functor.Product.$fRead1Product_$cliftReadList
                      $dRead1_sg5q0 $dRead2_sg5q1; } in
        let {
          sat_sg5q2 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag45N g_ag45O a)
          [LclId] =
              [$dRead1_sg5q0 $dRead2_sg5q1] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fRead1Product_$cliftReadsPrec
                      $dRead1_sg5q0 $dRead2_sg5q1 eta_B2 eta_B1;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sg5q2
                                        sat_sg5q3
                                        sat_sg5q4
                                        sat_sg5q5];
Data.Functor.Product.$fRead1Product_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Product.Product f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5q6 $dRead2_sg5q7]
        let {
          sat_sg5q8 [Occ=Once]
            :: Data.Functor.Classes.Read1
                 (Data.Functor.Product.Product f_ag45N g_ag45O)
          [LclId] =
              [$dRead1_sg5q6 $dRead2_sg5q7] \u []
                  Data.Functor.Product.$fRead1Product $dRead1_sg5q6 $dRead2_sg5q7;
        } in  Data.Functor.Classes.liftReadListDefault sat_sg5q8;

Data.Functor.Product.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> f a
     -> g a
     -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5q9
           w1_sg5qa
           w2_sg5qb
           w3_sg5qc
           ww_sg5qd
           ww1_sg5qe
           ww2_sg5qf]
        let {
          sat_sg5qh [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> g_sg4Pq a_sg4Pt -> GHC.Show.ShowS
          [LclId] =
              [w1_sg5qa w2_sg5qb w3_sg5qc] \s []
                  Data.Functor.Classes.liftShowsPrec w1_sg5qa w2_sg5qb w3_sg5qc; } in
        let {
          sat_sg5qg [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> f_sg4Pp a_sg4Pt -> GHC.Show.ShowS
          [LclId] =
              [w_sg5q9 w2_sg5qb w3_sg5qc] \s []
                  Data.Functor.Classes.liftShowsPrec w_sg5q9 w2_sg5qb w3_sg5qc;
        } in 
          Data.Functor.Classes.$wshowsBinaryWith
              sat_sg5qg
              sat_sg5qh
              Data.Functor.Product.$fRead1Product2
              ww_sg5qd
              ww1_sg5qe
              ww2_sg5qf;

Data.Functor.Product.$fShow1Product_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Product.Product f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5qi w1_sg5qj w2_sg5qk w3_sg5ql w4_sg5qm w5_sg5qn]
        case w4_sg5qm of {
          GHC.Types.I# ww1_sg5qp [Occ=Once] ->
              case w5_sg5qn of {
                Data.Functor.Product.Pair ww3_sg5qr [Occ=Once]
                                          ww4_sg5qs [Occ=Once] ->
                    Data.Functor.Product.$w$cliftShowsPrec
                        w_sg5qi w1_sg5qj w2_sg5qk w3_sg5ql ww1_sg5qp ww3_sg5qr ww4_sg5qs;
              };
        };

Data.Functor.Product.$fFoldableProduct4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Product.$fShow1Product_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Product.Product f g a]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U><L,U><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sg5qt
           $dShow2_sg5qu
           sp_sg5qv
           sl_sg5qw
           eta_sg5qx
           eta1_sg5qy]
        let {
          sat_sg5qD [Occ=Once]
            :: Data.Functor.Product.Product f_ag45l g_ag45m a_ag45G
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg5qt $dShow2_sg5qu sp_sg5qv sl_sg5qw] \r [w_sg5qz]
                  case w_sg5qz of {
                    Data.Functor.Product.Pair ww1_sg5qB [Occ=Once]
                                              ww2_sg5qC [Occ=Once] ->
                        Data.Functor.Product.$w$cliftShowsPrec
                            $dShow1_sg5qt
                            $dShow2_sg5qu
                            sp_sg5qv
                            sl_sg5qw
                            0#
                            ww1_sg5qB
                            ww2_sg5qC;
                  };
        } in  GHC.Show.showList__ sat_sg5qD eta_sg5qx eta1_sg5qy;

Data.Functor.Product.$fShow1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     Data.Functor.Classes.Show1 (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)>m] =
    [] \r [$dShow1_sg5qE $dShow2_sg5qF]
        let {
          sat_sg5qH [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Product.Product f_ag45l g_ag45m a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg5qE $dShow2_sg5qF] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fShow1Product_$cliftShowList
                      $dShow1_sg5qE $dShow2_sg5qF eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5qG [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Product.Product f_ag45l g_ag45m a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg5qE $dShow2_sg5qF] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fShow1Product_$cliftShowsPrec
                      $dShow1_sg5qE $dShow2_sg5qF eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sg5qG sat_sg5qH];

Data.Functor.Product.$w$c== [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5qI
           w1_sg5qJ
           w2_sg5qK
           ww_sg5qL
           ww1_sg5qM
           ww2_sg5qN
           ww3_sg5qO]
        let {
          eq_sg5qP :: a_sg4PK -> a_sg4PK -> GHC.Types.Bool
          [LclId] =
              [w2_sg5qK] \u [] GHC.Classes.== w2_sg5qK;
        } in 
          case w_sg5qI eq_sg5qP ww_sg5qL ww2_sg5qN of {
            GHC.Types.False -> GHC.Types.False [];
            GHC.Types.True -> w1_sg5qJ eq_sg5qP ww1_sg5qM ww3_sg5qO;
          };

Data.Functor.Product.$fEqProduct_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5qR w1_sg5qS w2_sg5qT w3_sg5qU w4_sg5qV]
        case w3_sg5qU of {
          Data.Functor.Product.Pair ww1_sg5qX [Occ=Once]
                                    ww2_sg5qY [Occ=Once] ->
              case w4_sg5qV of {
                Data.Functor.Product.Pair ww4_sg5r0 [Occ=Once]
                                          ww5_sg5r1 [Occ=Once] ->
                    Data.Functor.Product.$w$c==
                        w_sg5qR w1_sg5qS w2_sg5qT ww1_sg5qX ww2_sg5qY ww4_sg5r0 ww5_sg5r1;
              };
        };

Data.Functor.Product.$fEqProduct_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sg5r2 $dEq2_sg5r3 $dEq_sg5r4 eta_sg5r5 eta1_sg5r6]
        case eta_sg5r5 of {
          Data.Functor.Product.Pair ww1_sg5r8 [Occ=Once]
                                    ww2_sg5r9 [Occ=Once] ->
              case eta1_sg5r6 of {
                Data.Functor.Product.Pair ww4_sg5rb [Occ=Once]
                                          ww5_sg5rc [Occ=Once] ->
                    let {
                      eq_sg5rd :: a_ag452 -> a_ag452 -> GHC.Types.Bool
                      [LclId] =
                          [$dEq_sg5r4] \u [] GHC.Classes.== $dEq_sg5r4;
                    } in 
                      case $dEq1_sg5r2 eq_sg5rd ww1_sg5r8 ww4_sg5rb of {
                        GHC.Types.False -> GHC.Types.True [];
                        GHC.Types.True ->
                            case $dEq2_sg5r3 eq_sg5rd ww2_sg5r9 ww5_sg5rc of {
                              GHC.Types.False -> GHC.Types.True [];
                              GHC.Types.True -> GHC.Types.False [];
                            };
                      };
              };
        };

Data.Functor.Product.$fEqProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     GHC.Classes.Eq (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><L,U(U,A)>m] =
    [] \r [$dEq1_sg5rg $dEq2_sg5rh $dEq_sg5ri]
        let {
          sat_sg5rk [Occ=Once]
            :: Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sg5rg $dEq2_sg5rh $dEq_sg5ri] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fEqProduct_$c/=
                      $dEq1_sg5rg $dEq2_sg5rh $dEq_sg5ri eta_B2 eta_B1; } in
        let {
          sat_sg5rj [Occ=Once]
            :: Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sg5rg $dEq2_sg5rh $dEq_sg5ri] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fEqProduct_$c==
                      $dEq1_sg5rg $dEq2_sg5rh $dEq_sg5ri eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sg5rj sat_sg5rk];

Data.Functor.Product.$fOrdProduct_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg5rl $dOrd2_sg5rm $dOrd_sg5rn eta_sg5ro eta1_sg5rp]
        case eta_sg5ro of {
          Data.Functor.Product.Pair ww1_sg5rr [Occ=Once]
                                    ww2_sg5rs [Occ=Once] ->
              case eta1_sg5rp of {
                Data.Functor.Product.Pair ww4_sg5ru [Occ=Once]
                                          ww5_sg5rv [Occ=Once] ->
                    let {
                      w_sg5rw :: a_ag44e -> a_ag44e -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg5rn] \u [] GHC.Classes.compare $dOrd_sg5rn;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg5rl w_sg5rw ww1_sg5rr ww4_sg5ru
                      of
                      { GHC.Types.LT -> GHC.Types.LT [];
                        GHC.Types.EQ ->
                            Data.Functor.Classes.liftCompare
                                $dOrd2_sg5rm w_sg5rw ww2_sg5rs ww5_sg5rv;
                        GHC.Types.GT -> GHC.Types.GT [];
                      };
              };
        };

Data.Functor.Product.$fOrdProduct_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Eq (Data.Functor.Product.Product f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg5ry $dOrd2_sg5rz $dOrd_sg5rA]
        let {
          sat_sg5rD [Occ=Once, Dmd=<L,U(U,A)>] :: GHC.Classes.Eq a_ag44e
          [LclId] =
              [$dOrd_sg5rA] \u [] GHC.Classes.$p1Ord $dOrd_sg5rA; } in
        let {
          sat_sg5rC [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 g_ag44d
          [LclId] =
              [$dOrd2_sg5rz] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sg5rz; } in
        let {
          sat_sg5rB [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 f_ag44c
          [LclId] =
              [$dOrd1_sg5ry] \u [] Data.Functor.Classes.$p1Ord1 $dOrd1_sg5ry;
        } in 
          Data.Functor.Product.$fEqProduct sat_sg5rB sat_sg5rC sat_sg5rD;

Data.Functor.Product.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5rE
           w1_sg5rF
           w2_sg5rG
           ww_sg5rH
           ww1_sg5rI
           ww2_sg5rJ
           ww3_sg5rK]
        let {
          comp_sg5rL :: a_sg4Q3 -> a_sg4Q3 -> GHC.Types.Ordering
          [LclId] =
              [w2_sg5rG] \u [] GHC.Classes.compare w2_sg5rG;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sg5rE comp_sg5rL ww_sg5rH ww2_sg5rJ
          of
          { GHC.Types.LT -> GHC.Types.True [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sg5rF comp_sg5rL ww1_sg5rI ww3_sg5rK
                of
                { __DEFAULT -> GHC.Types.False [];
                  GHC.Types.LT -> GHC.Types.True [];
                };
            GHC.Types.GT -> GHC.Types.False [];
          };

Data.Functor.Product.$fOrdProduct_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5rO w1_sg5rP w2_sg5rQ w3_sg5rR w4_sg5rS]
        case w3_sg5rR of {
          Data.Functor.Product.Pair ww1_sg5rU [Occ=Once]
                                    ww2_sg5rV [Occ=Once] ->
              case w4_sg5rS of {
                Data.Functor.Product.Pair ww4_sg5rX [Occ=Once]
                                          ww5_sg5rY [Occ=Once] ->
                    Data.Functor.Product.$w$c<
                        w_sg5rO w1_sg5rP w2_sg5rQ ww1_sg5rU ww2_sg5rV ww4_sg5rX ww5_sg5rY;
              };
        };

Data.Functor.Product.$w$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5rZ
           w1_sg5s0
           w2_sg5s1
           ww_sg5s2
           ww1_sg5s3
           ww2_sg5s4
           ww3_sg5s5]
        let {
          comp_sg5s6 :: a_sg4Qm -> a_sg4Qm -> GHC.Types.Ordering
          [LclId] =
              [w2_sg5s1] \u [] GHC.Classes.compare w2_sg5s1;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sg5rZ comp_sg5s6 ww_sg5s2 ww2_sg5s4
          of
          { GHC.Types.LT -> GHC.Types.False [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sg5s0 comp_sg5s6 ww1_sg5s3 ww3_sg5s5
                of
                { __DEFAULT -> GHC.Types.True [];
                  GHC.Types.LT -> GHC.Types.False [];
                };
            GHC.Types.GT -> GHC.Types.True [];
          };

Data.Functor.Product.$fOrdProduct_$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5s9 w1_sg5sa w2_sg5sb w3_sg5sc w4_sg5sd]
        case w3_sg5sc of {
          Data.Functor.Product.Pair ww1_sg5sf [Occ=Once]
                                    ww2_sg5sg [Occ=Once] ->
              case w4_sg5sd of {
                Data.Functor.Product.Pair ww4_sg5si [Occ=Once]
                                          ww5_sg5sj [Occ=Once] ->
                    Data.Functor.Product.$w$c>=
                        w_sg5s9 w1_sg5sa w2_sg5sb ww1_sg5sf ww2_sg5sg ww4_sg5si ww5_sg5sj;
              };
        };

Data.Functor.Product.$w$c> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5sk
           w1_sg5sl
           w2_sg5sm
           ww_sg5sn
           ww1_sg5so
           ww2_sg5sp
           ww3_sg5sq]
        let {
          comp_sg5sr :: a_sg4QF -> a_sg4QF -> GHC.Types.Ordering
          [LclId] =
              [w2_sg5sm] \u [] GHC.Classes.compare w2_sg5sm;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sg5sk comp_sg5sr ww_sg5sn ww2_sg5sp
          of
          { GHC.Types.LT -> GHC.Types.False [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sg5sl comp_sg5sr ww1_sg5so ww3_sg5sq
                of
                { __DEFAULT -> GHC.Types.False [];
                  GHC.Types.GT -> GHC.Types.True [];
                };
            GHC.Types.GT -> GHC.Types.True [];
          };

Data.Functor.Product.$fOrdProduct_$c> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5su w1_sg5sv w2_sg5sw w3_sg5sx w4_sg5sy]
        case w3_sg5sx of {
          Data.Functor.Product.Pair ww1_sg5sA [Occ=Once]
                                    ww2_sg5sB [Occ=Once] ->
              case w4_sg5sy of {
                Data.Functor.Product.Pair ww4_sg5sD [Occ=Once]
                                          ww5_sg5sE [Occ=Once] ->
                    Data.Functor.Product.$w$c>
                        w_sg5su w1_sg5sv w2_sg5sw ww1_sg5sA ww2_sg5sB ww4_sg5sD ww5_sg5sE;
              };
        };

Data.Functor.Product.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5sF
           w1_sg5sG
           w2_sg5sH
           ww_sg5sI
           ww1_sg5sJ
           ww2_sg5sK
           ww3_sg5sL]
        let {
          comp_sg5sM :: a_sg4QY -> a_sg4QY -> GHC.Types.Ordering
          [LclId] =
              [w2_sg5sH] \u [] GHC.Classes.compare w2_sg5sH;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sg5sF comp_sg5sM ww_sg5sI ww2_sg5sK
          of
          { GHC.Types.LT -> GHC.Types.True [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sg5sG comp_sg5sM ww1_sg5sJ ww3_sg5sL
                of
                { __DEFAULT -> GHC.Types.True [];
                  GHC.Types.GT -> GHC.Types.False [];
                };
            GHC.Types.GT -> GHC.Types.False [];
          };

Data.Functor.Product.$fOrdProduct_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5sP w1_sg5sQ w2_sg5sR w3_sg5sS w4_sg5sT]
        case w3_sg5sS of {
          Data.Functor.Product.Pair ww1_sg5sV [Occ=Once]
                                    ww2_sg5sW [Occ=Once] ->
              case w4_sg5sT of {
                Data.Functor.Product.Pair ww4_sg5sY [Occ=Once]
                                          ww5_sg5sZ [Occ=Once] ->
                    Data.Functor.Product.$w$c<=
                        w_sg5sP w1_sg5sQ w2_sg5sR ww1_sg5sV ww2_sg5sW ww4_sg5sY ww5_sg5sZ;
              };
        };

Data.Functor.Product.$fOrdProduct_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg5t0 $dOrd2_sg5t1 $dOrd_sg5t2 x_sg5t3 y_sg5t4]
        case x_sg5t3 of ww_sg5t5 {
          Data.Functor.Product.Pair ww1_sg5t6 [Occ=Once]
                                    ww2_sg5t7 [Occ=Once] ->
              case y_sg5t4 of ww3_sg5t8 {
                Data.Functor.Product.Pair ww4_sg5t9 [Occ=Once]
                                          ww5_sg5ta [Occ=Once] ->
                    let {
                      comp_sg5tb :: a_ag44e -> a_ag44e -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg5t2] \u [] GHC.Classes.compare $dOrd_sg5t2;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg5t0 comp_sg5tb ww1_sg5t6 ww4_sg5t9
                      of
                      { GHC.Types.LT -> ww3_sg5t8;
                        GHC.Types.EQ ->
                            case
                                Data.Functor.Classes.liftCompare
                                    $dOrd2_sg5t1 comp_sg5tb ww2_sg5t7 ww5_sg5ta
                            of
                            { __DEFAULT -> ww3_sg5t8;
                              GHC.Types.GT -> ww_sg5t5;
                            };
                        GHC.Types.GT -> ww_sg5t5;
                      };
              };
        };

Data.Functor.Product.$fOrdProduct_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg5te $dOrd2_sg5tf $dOrd_sg5tg x_sg5th y_sg5ti]
        case x_sg5th of ww_sg5tj {
          Data.Functor.Product.Pair ww1_sg5tk [Occ=Once]
                                    ww2_sg5tl [Occ=Once] ->
              case y_sg5ti of ww3_sg5tm {
                Data.Functor.Product.Pair ww4_sg5tn [Occ=Once]
                                          ww5_sg5to [Occ=Once] ->
                    let {
                      comp_sg5tp :: a_ag44e -> a_ag44e -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg5tg] \u [] GHC.Classes.compare $dOrd_sg5tg;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg5te comp_sg5tp ww1_sg5tk ww4_sg5tn
                      of
                      { GHC.Types.LT -> ww_sg5tj;
                        GHC.Types.EQ ->
                            case
                                Data.Functor.Classes.liftCompare
                                    $dOrd2_sg5tf comp_sg5tp ww2_sg5tl ww5_sg5to
                            of
                            { __DEFAULT -> ww_sg5tj;
                              GHC.Types.GT -> ww3_sg5tm;
                            };
                        GHC.Types.GT -> ww3_sg5tm;
                      };
              };
        };

Data.Functor.Product.$fOrdProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Ord (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m] =
    [] \r [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu]
        let {
          sat_sg5tC [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$cmin
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5tB [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$cmax
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5tA [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c>=
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5tz [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c>
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5ty [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c<=
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5tx [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c<
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5tw [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$ccompare
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5tv [Occ=Once]
            :: GHC.Classes.Eq
                 (Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e)
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \u []
                  Data.Functor.Product.$fOrdProduct_$cp1Ord
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu;
        } in 
          GHC.Classes.C:Ord [sat_sg5tv
                             sat_sg5tw
                             sat_sg5tx
                             sat_sg5ty
                             sat_sg5tz
                             sat_sg5tA
                             sat_sg5tB
                             sat_sg5tC];

Data.Functor.Product.$fReadProduct_$creadPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       (Data.Functor.Product.Product f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5tD $dRead2_sg5tE $dRead_sg5tF]
        let {
          sat_sg5tH [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag43H]
          [LclId] =
              [$dRead_sg5tF] \u [] GHC.Read.readListPrec $dRead_sg5tF; } in
        let {
          sat_sg5tG [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag43H
          [LclId] =
              [$dRead_sg5tF] \u [] GHC.Read.readPrec $dRead_sg5tF;
        } in 
          Data.Functor.Product.$fRead1Product_$cliftReadPrec
              $dRead1_sg5tD $dRead2_sg5tE sat_sg5tG sat_sg5tH;

Data.Functor.Product.$fReadProduct_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Product.Product f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5tI $dRead2_sg5tJ $dRead_sg5tK]
        let {
          ds_sg5tL [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sg5tI $dRead2_sg5tJ $dRead_sg5tK] \u []
                  let {
                    sat_sg5tN [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag43H]
                    [LclId] =
                        [$dRead_sg5tK] \u [] GHC.Read.readListPrec $dRead_sg5tK; } in
                  let {
                    sat_sg5tM [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag43H
                    [LclId] =
                        [$dRead_sg5tK] \u [] GHC.Read.readPrec $dRead_sg5tK;
                  } in 
                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                        $dRead1_sg5tI $dRead2_sg5tJ sat_sg5tM sat_sg5tN; } in
        let {
          sat_sg5tQ [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [ds_sg5tL] \r [n_sg5tO]
                  let {
                    sat_sg5tP [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
                    [LclId] =
                        [ds_sg5tL n_sg5tO] \u []
                            ds_sg5tL
                                n_sg5tO Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sg5tP;
        } in  sat_sg5tQ;

Data.Functor.Product.$fReadProduct_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Product.Product f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5tR $dRead2_sg5tS $dRead_sg5tT]
        let {
          sat_sg5tW [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sg5tR $dRead2_sg5tS $dRead_sg5tT] \s []
                  let {
                    sat_sg5tV [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag43H]
                    [LclId] =
                        [$dRead_sg5tT] \u [] GHC.Read.readListPrec $dRead_sg5tT; } in
                  let {
                    sat_sg5tU [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag43H
                    [LclId] =
                        [$dRead_sg5tT] \u [] GHC.Read.readPrec $dRead_sg5tT;
                  } in 
                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                        $dRead1_sg5tR $dRead2_sg5tS sat_sg5tU sat_sg5tV;
        } in  GHC.Read.list sat_sg5tW;

Data.Functor.Product.$fReadProduct_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Functor.Product.Product f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5tX $dRead2_sg5tY $dRead_sg5tZ]
        let {
          sat_sg5u0 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H]
          [LclId] =
              [$dRead1_sg5tX $dRead2_sg5tY $dRead_sg5tZ] \u []
                  Data.Functor.Product.$fReadProduct_$creadListPrec
                      $dRead1_sg5tX
                      $dRead2_sg5tY
                      $dRead_sg5tZ
                      GHC.Read.$fRead()7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sg5u0;

Data.Functor.Product.$fReadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Read.Read (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,U,U)>m] =
    [] \r [$dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3]
        let {
          sat_sg5u7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H]
          [LclId] =
              [$dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3] \u []
                  Data.Functor.Product.$fReadProduct_$creadListPrec
                      $dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3; } in
        let {
          sat_sg5u6 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3] \u []
                  Data.Functor.Product.$fReadProduct_$creadPrec
                      $dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3; } in
        let {
          sat_sg5u5 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H]
          [LclId] =
              [$dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3] \u []
                  Data.Functor.Product.$fReadProduct_$creadList
                      $dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3; } in
        let {
          sat_sg5u4 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3] \u []
                  Data.Functor.Product.$fReadProduct_$creadsPrec
                      $dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3;
        } in  GHC.Read.C:Read [sat_sg5u4 sat_sg5u5 sat_sg5u6 sat_sg5u7];

Data.Functor.Product.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Prim.Int# -> f a -> g a -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5u8 w1_sg5u9 w2_sg5ua ww_sg5ub ww1_sg5uc ww2_sg5ud]
        let {
          sp_sg5ue :: GHC.Types.Int -> a_sg4Rt -> GHC.Show.ShowS
          [LclId] =
              [w2_sg5ua] \u [] GHC.Show.showsPrec w2_sg5ua; } in
        let {
          sl_sg5uf :: [a_sg4Rt] -> GHC.Show.ShowS
          [LclId] =
              [w2_sg5ua] \u [] GHC.Show.showList w2_sg5ua; } in
        let {
          sat_sg5uh [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> g_sg4Rs a_sg4Rt -> GHC.Show.ShowS
          [LclId] =
              [w1_sg5u9 sp_sg5ue sl_sg5uf] \s []
                  Data.Functor.Classes.liftShowsPrec w1_sg5u9 sp_sg5ue sl_sg5uf; } in
        let {
          sat_sg5ug [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> f_sg4Rr a_sg4Rt -> GHC.Show.ShowS
          [LclId] =
              [w_sg5u8 sp_sg5ue sl_sg5uf] \s []
                  Data.Functor.Classes.liftShowsPrec w_sg5u8 sp_sg5ue sl_sg5uf;
        } in 
          Data.Functor.Classes.$wshowsBinaryWith
              sat_sg5ug
              sat_sg5uh
              Data.Functor.Product.$fRead1Product2
              ww_sg5ub
              ww1_sg5uc
              ww2_sg5ud;

Data.Functor.Product.$fShowProduct_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Types.Int
     -> Data.Functor.Product.Product f g a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5ui w1_sg5uj w2_sg5uk w3_sg5ul w4_sg5um]
        case w3_sg5ul of {
          GHC.Types.I# ww1_sg5uo [Occ=Once] ->
              case w4_sg5um of {
                Data.Functor.Product.Pair ww3_sg5uq [Occ=Once]
                                          ww4_sg5ur [Occ=Once] ->
                    Data.Functor.Product.$w$cshowsPrec
                        w_sg5ui w1_sg5uj w2_sg5uk ww1_sg5uo ww3_sg5uq ww4_sg5ur;
              };
        };

Data.Functor.Product.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     f a -> g a -> GHC.Base.String
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*U,A,1*U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5us w1_sg5ut w2_sg5uu ww_sg5uv ww1_sg5uw]
        let {
          sp_sg5ux :: GHC.Types.Int -> a_sg4RL -> GHC.Show.ShowS
          [LclId] =
              [w2_sg5uu] \u [] GHC.Show.showsPrec w2_sg5uu; } in
        let {
          sl_sg5uy :: [a_sg4RL] -> GHC.Show.ShowS
          [LclId] =
              [w2_sg5uu] \u [] GHC.Show.showList w2_sg5uu; } in
        let {
          sat_sg5uB [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [w_sg5us w1_sg5ut ww_sg5uv ww1_sg5uw sp_sg5ux sl_sg5uy] \u []
                  let {
                    sat_sg5uz [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [w1_sg5ut ww1_sg5uw sp_sg5ux sl_sg5uy] \u []
                            Data.Functor.Classes.liftShowsPrec
                                w1_sg5ut
                                sp_sg5ux
                                sl_sg5uy
                                Data.Functor.Classes.$fRead1Const1
                                ww1_sg5uw
                                GHC.Types.[]; } in
                  let {
                    sat_sg5uA [Occ=Once] :: GHC.Base.String
                    [LclId] =
                        CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sg5uz];
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w_sg5us
                        sp_sg5ux
                        sl_sg5uy
                        Data.Functor.Classes.$fRead1Const1
                        ww_sg5uv
                        sat_sg5uA; } in
        let {
          sat_sg5uC [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sg5uB];
        } in  GHC.Base.++ Data.Functor.Product.$fRead1Product2 sat_sg5uC;

Data.Functor.Product.$fShowProduct_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     Data.Functor.Product.Product f g a -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(U,A,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5uD w1_sg5uE w2_sg5uF w3_sg5uG]
        case w3_sg5uG of {
          Data.Functor.Product.Pair ww1_sg5uI [Occ=Once]
                                    ww2_sg5uJ [Occ=Once] ->
              Data.Functor.Product.$w$cshow
                  w_sg5uD w1_sg5uE w2_sg5uF ww1_sg5uI ww2_sg5uJ;
        };

Data.Functor.Product.$fShowProduct_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     [Data.Functor.Product.Product f g a] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sg5uK $dShow2_sg5uL $dShow_sg5uM ls_sg5uN s_sg5uO]
        let {
          lvl9_sg5uP [Occ=OnceL]
            :: GHC.Types.Int -> a_ag43h -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sg5uM] \u [] GHC.Show.showsPrec $dShow_sg5uM; } in
        let {
          lvl10_sg5uQ [Occ=OnceL] :: [a_ag43h] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sg5uM] \u [] GHC.Show.showList $dShow_sg5uM; } in
        let {
          sat_sg5uV [Occ=Once]
            :: Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg5uK $dShow2_sg5uL lvl9_sg5uP lvl10_sg5uQ] \r [eta_sg5uR]
                  case eta_sg5uR of {
                    Data.Functor.Product.Pair ww1_sg5uT [Occ=Once]
                                              ww2_sg5uU [Occ=Once] ->
                        Data.Functor.Product.$w$cliftShowsPrec
                            $dShow1_sg5uK
                            $dShow2_sg5uL
                            lvl9_sg5uP
                            lvl10_sg5uQ
                            0#
                            ww1_sg5uT
                            ww2_sg5uU;
                  };
        } in  GHC.Show.showList__ sat_sg5uV ls_sg5uN s_sg5uO;

Data.Functor.Product.$fShowProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Show.Show (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(U,A,U)>m] =
    [] \r [$dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY]
        let {
          sat_sg5v1 [Occ=Once]
            :: [Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fShowProduct_$cshowList
                      $dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY eta_B2 eta_B1; } in
        let {
          sat_sg5v0 [Occ=Once]
            :: Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h
               -> GHC.Base.String
          [LclId] =
              [$dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY] \r [eta_B1]
                  Data.Functor.Product.$fShowProduct_$cshow
                      $dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY eta_B1; } in
        let {
          sat_sg5uZ [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fShowProduct_$cshowsPrec
                      $dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sg5uZ sat_sg5v0 sat_sg5v1];

Data.Functor.Product.$fFunctorProduct_$cfmap
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sg5v2 $dFunctor1_sg5v3 f1_sg5v4 ds_sg5v5]
        case ds_sg5v5 of {
          Data.Functor.Product.Pair x_sg5v7 [Occ=Once] y_sg5v8 [Occ=Once] ->
              let {
                sat_sg5va [Occ=Once] :: g_ag42H b_ag42O
                [LclId] =
                    [$dFunctor1_sg5v3 f1_sg5v4 y_sg5v8] \u []
                        GHC.Base.fmap $dFunctor1_sg5v3 f1_sg5v4 y_sg5v8; } in
              let {
                sat_sg5v9 [Occ=Once] :: f_ag42G b_ag42O
                [LclId] =
                    [$dFunctor_sg5v2 f1_sg5v4 x_sg5v7] \u []
                        GHC.Base.fmap $dFunctor_sg5v2 f1_sg5v4 x_sg5v7;
              } in  Data.Functor.Product.Pair [sat_sg5v9 sat_sg5va];
        };

Data.Functor.Product.$fFunctorProduct_$c<$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sg5vb w1_sg5vc w2_sg5vd w3_sg5ve]
        case w3_sg5ve of {
          Data.Functor.Product.Pair ww1_sg5vg [Occ=Once]
                                    ww2_sg5vh [Occ=Once] ->
              let {
                f1_sg5vi :: b_sg4S9 -> a_sg4S8
                [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
                    [w2_sg5vd] \r [ds_sg5vj] w2_sg5vd; } in
              let {
                sat_sg5vl [Occ=Once] :: g_sg4S5 a_sg4S8
                [LclId] =
                    [w1_sg5vc ww2_sg5vh f1_sg5vi] \u []
                        GHC.Base.fmap w1_sg5vc f1_sg5vi ww2_sg5vh; } in
              let {
                sat_sg5vk [Occ=Once] :: f_sg4S4 a_sg4S8
                [LclId] =
                    [w_sg5vb ww1_sg5vg f1_sg5vi] \u []
                        GHC.Base.fmap w_sg5vb f1_sg5vi ww1_sg5vg;
              } in  Data.Functor.Product.Pair [sat_sg5vk sat_sg5vl];
        };

Data.Functor.Product.$fFunctorProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     GHC.Base.Functor (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dFunctor_sg5vm $dFunctor1_sg5vn]
        let {
          sat_sg5vp [Occ=Once]
            :: forall a b.
               a
               -> Data.Functor.Product.Product f_ag42G g_ag42H b
               -> Data.Functor.Product.Product f_ag42G g_ag42H a
          [LclId] =
              [$dFunctor_sg5vm $dFunctor1_sg5vn] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFunctorProduct_$c<$
                      $dFunctor_sg5vm $dFunctor1_sg5vn eta_B2 eta_B1; } in
        let {
          sat_sg5vo [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Product.Product f_ag42G g_ag42H a
               -> Data.Functor.Product.Product f_ag42G g_ag42H b
          [LclId] =
              [$dFunctor_sg5vm $dFunctor1_sg5vn] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFunctorProduct_$cfmap
                      $dFunctor_sg5vm $dFunctor1_sg5vn eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sg5vo sat_sg5vp];

Data.Functor.Product.$w$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> f a -> g a -> m
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5vq w1_sg5vr w2_sg5vs w3_sg5vt ww_sg5vu ww1_sg5vv]
        let {
          sat_sg5vx [Occ=Once] :: m_sg4Sp
          [LclId] =
              [w1_sg5vr w2_sg5vs w3_sg5vt ww1_sg5vv] \u []
                  Data.Foldable.foldMap w1_sg5vr w2_sg5vs w3_sg5vt ww1_sg5vv; } in
        let {
          sat_sg5vw [Occ=Once] :: m_sg4Sp
          [LclId] =
              [w_sg5vq w2_sg5vs w3_sg5vt ww_sg5vu] \u []
                  Data.Foldable.foldMap w_sg5vq w2_sg5vs w3_sg5vt ww_sg5vu;
        } in  GHC.Base.mappend w2_sg5vs sat_sg5vw sat_sg5vx;

Data.Functor.Product.$fFoldableProduct_$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Functor.Product.Product f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5vy w1_sg5vz w2_sg5vA w3_sg5vB w4_sg5vC]
        case w4_sg5vC of {
          Data.Functor.Product.Pair ww1_sg5vE [Occ=Once]
                                    ww2_sg5vF [Occ=Once] ->
              Data.Functor.Product.$w$cfoldMap
                  w_sg5vy w1_sg5vz w2_sg5vA w3_sg5vB ww1_sg5vE ww2_sg5vF;
        };

Data.Functor.Product.$fFoldableProduct_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m.
     GHC.Base.Monoid m =>
     Data.Functor.Product.Product f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5vG $dFoldable1_sg5vH $dMonoid_sg5vI w_sg5vJ]
        case w_sg5vJ of {
          Data.Functor.Product.Pair ww1_sg5vL [Occ=Once]
                                    ww2_sg5vM [Occ=Once] ->
              Data.Functor.Product.$w$cfoldMap
                  $dFoldable_sg5vG
                  $dFoldable1_sg5vH
                  $dMonoid_sg5vI
                  GHC.Base.id
                  ww1_sg5vL
                  ww2_sg5vM;
        };

Data.Functor.Product.$fFoldableProduct1 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sg5vN] v_sg5vN;

Data.Functor.Product.$fFoldableProduct_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5vO $dFoldable1_sg5vP $dNum_sg5vQ]
        let {
          $dMonoid_sg5vR
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_ag42n)
          [LclId] =
              [$dNum_sg5vQ] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sg5vQ; } in
        let {
          sat_sg5vY [Occ=Once]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag42n
               -> Data.Semigroup.Internal.Sum a_ag42n
          [LclId] =
              [$dFoldable_sg5vO
               $dFoldable1_sg5vP
               $dNum_sg5vQ
               $dMonoid_sg5vR] \r [ds_sg5vS]
                  case ds_sg5vS of {
                    Data.Functor.Product.Pair x_sg5vU [Occ=Once] y_sg5vV [Occ=Once] ->
                        let {
                          sat_sg5vX [Occ=Once] :: a_ag42n
                          [LclId] =
                              [$dFoldable1_sg5vP $dMonoid_sg5vR y_sg5vV] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_sg5vP
                                      $dMonoid_sg5vR
                                      Data.Functor.Product.$fFoldableProduct1
                                      y_sg5vV; } in
                        let {
                          sat_sg5vW [Occ=Once] :: a_ag42n
                          [LclId] =
                              [$dFoldable_sg5vO $dMonoid_sg5vR x_sg5vU] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_sg5vO
                                      $dMonoid_sg5vR
                                      Data.Functor.Product.$fFoldableProduct1
                                      x_sg5vU;
                        } in  GHC.Num.+ $dNum_sg5vQ sat_sg5vW sat_sg5vX;
                  };
        } in  sat_sg5vY;

lvl_rg5nW :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Functor.Product.$fFoldableProduct2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rg5nW of sat_sg5vZ {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg5vZ;
        };

Data.Functor.Product.$fFoldableProduct_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5w0 $dFoldable1_sg5w1 $dOrd_sg5w2]
        let {
          $dMonoid_sg5w3 :: GHC.Base.Monoid (Data.Functor.Utils.Min a_ag42d)
          [LclId] =
              [$dOrd_sg5w2] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_sg5w2; } in
        let {
          sat_sg5wf [Occ=OnceT[0]]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag42d -> a_ag42d
          [LclId] =
              [$dFoldable_sg5w0
               $dFoldable1_sg5w1
               $dOrd_sg5w2
               $dMonoid_sg5w3] \r [x_sg5w4]
                  case x_sg5w4 of {
                    Data.Functor.Product.Pair x1_sg5w6 [Occ=Once*]
                                              y_sg5w7 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sg5w1 $dMonoid_sg5w3 GHC.Base.Just y_sg5w7
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sg5w0 $dMonoid_sg5w3 GHC.Base.Just x1_sg5w6
                              of
                              { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct2;
                                GHC.Base.Just v_sg5wa [Occ=Once] -> v_sg5wa;
                              };
                          GHC.Base.Just ipv_sg5wb ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sg5w0 $dMonoid_sg5w3 GHC.Base.Just x1_sg5w6
                              of
                              { GHC.Base.Nothing -> ipv_sg5wb;
                                GHC.Base.Just x2_sg5wd ->
                                    case GHC.Classes.<= $dOrd_sg5w2 x2_sg5wd ipv_sg5wb of {
                                      GHC.Types.False -> ipv_sg5wb;
                                      GHC.Types.True -> x2_sg5wd;
                                    };
                              };
                        };
                  };
        } in  sat_sg5wf;

lvl1_rg5nX :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Functor.Product.$fFoldableProduct3 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rg5nX of sat_sg5wg {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg5wg;
        };

Data.Functor.Product.$fFoldableProduct_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5wh $dFoldable1_sg5wi $dOrd_sg5wj]
        let {
          $dMonoid_sg5wk :: GHC.Base.Monoid (Data.Functor.Utils.Max a_ag423)
          [LclId] =
              [$dOrd_sg5wj] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_sg5wj; } in
        let {
          sat_sg5ww [Occ=OnceT[0]]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag423 -> a_ag423
          [LclId] =
              [$dFoldable_sg5wh
               $dFoldable1_sg5wi
               $dOrd_sg5wj
               $dMonoid_sg5wk] \r [x_sg5wl]
                  case x_sg5wl of {
                    Data.Functor.Product.Pair x1_sg5wn [Occ=Once*]
                                              y_sg5wo [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sg5wi $dMonoid_sg5wk GHC.Base.Just y_sg5wo
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sg5wh $dMonoid_sg5wk GHC.Base.Just x1_sg5wn
                              of
                              { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct3;
                                GHC.Base.Just v_sg5wr [Occ=Once] -> v_sg5wr;
                              };
                          GHC.Base.Just ipv_sg5ws ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sg5wh $dMonoid_sg5wk GHC.Base.Just x1_sg5wn
                              of
                              { GHC.Base.Nothing -> ipv_sg5ws;
                                GHC.Base.Just x2_sg5wu ->
                                    case GHC.Classes.>= $dOrd_sg5wj x2_sg5wu ipv_sg5ws of {
                                      GHC.Types.False -> ipv_sg5ws;
                                      GHC.Types.True -> x2_sg5wu;
                                    };
                              };
                        };
                  };
        } in  sat_sg5ww;

Data.Functor.Product.$fFoldableProduct_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5wx $dFoldable1_sg5wy $dEq_sg5wz eta_sg5wA]
        let {
          f1_sg5wB :: a_ag41T -> GHC.Types.Bool
          [LclId] =
              [$dEq_sg5wz eta_sg5wA] \u []
                  GHC.Classes.== $dEq_sg5wz eta_sg5wA; } in
        let {
          sat_sg5wH [Occ=Once]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag41T
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_sg5wx $dFoldable1_sg5wy f1_sg5wB] \r [ds_sg5wC]
                  case ds_sg5wC of {
                    Data.Functor.Product.Pair x_sg5wE [Occ=Once] y_sg5wF [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_sg5wx
                                Data.Semigroup.Internal.$fMonoidAny
                                f1_sg5wB
                                x_sg5wE
                        of
                        { GHC.Types.False ->
                              Data.Foldable.foldMap
                                  $dFoldable1_sg5wy
                                  Data.Semigroup.Internal.$fMonoidAny
                                  f1_sg5wB
                                  y_sg5wF;
                          GHC.Types.True -> GHC.Types.True [];
                        };
                  };
        } in  sat_sg5wH;

Data.Functor.Product.$fFoldableProduct8
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Functor.Product.$w$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5wI w1_sg5wJ w2_sg5wK w3_sg5wL ww_sg5wM ww1_sg5wN]
        let {
          f1_sg5wO :: a_sg4T4 -> b_sg4T3 -> b_sg4T3
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [w2_sg5wK] \r [x_sg5wP y_sg5wQ] w2_sg5wK y_sg5wQ x_sg5wP; } in
        let {
          sat_sg5wR [Occ=Once] :: b_sg4T3
          [LclId] =
              [w_sg5wI w3_sg5wL ww_sg5wM f1_sg5wO] \u []
                  Data.Foldable.foldMap
                      w_sg5wI
                      Data.Functor.Product.$fFoldableProduct8
                      f1_sg5wO
                      ww_sg5wM
                      w3_sg5wL;
        } in 
          Data.Foldable.foldMap
              w1_sg5wJ
              Data.Functor.Product.$fFoldableProduct8
              f1_sg5wO
              ww1_sg5wN
              sat_sg5wR;

Data.Functor.Product.$fFoldableProduct_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5wS w1_sg5wT w2_sg5wU w3_sg5wV w4_sg5wW]
        case w4_sg5wW of {
          Data.Functor.Product.Pair ww1_sg5wY [Occ=Once]
                                    ww2_sg5wZ [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl
                  w_sg5wS w1_sg5wT w2_sg5wU w3_sg5wV ww1_sg5wY ww2_sg5wZ;
        };

lvl2_rg5nY :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Functor.Product.$fFoldableProduct7 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rg5nY of sat_sg5x0 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg5x0;
        };

Data.Functor.Product.$w$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5x1 w1_sg5x2 w2_sg5x3 ww_sg5x4 ww1_sg5x5]
        let {
          f1_sg5x6
            :: a_sg4Ti -> GHC.Base.Maybe a_sg4Ti -> GHC.Base.Maybe a_sg4Ti
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_sg5x3] \r [x_sg5x7 y_sg5x8]
                  let {
                    sat_sg5xb [Occ=Once] :: a_sg4Ti
                    [LclId] =
                        [w2_sg5x3 x_sg5x7 y_sg5x8] \u []
                            case y_sg5x8 of {
                              GHC.Base.Nothing -> x_sg5x7;
                              GHC.Base.Just x1_sg5xa [Occ=Once] -> w2_sg5x3 x1_sg5xa x_sg5x7;
                            };
                  } in  GHC.Base.Just [sat_sg5xb]; } in
        let {
          sat_sg5xc [Occ=Once] :: GHC.Base.Maybe a_sg4Ti
          [LclId] =
              [w_sg5x1 ww_sg5x4 f1_sg5x6] \u []
                  Data.Foldable.foldMap
                      w_sg5x1
                      Data.Functor.Product.$fFoldableProduct8
                      f1_sg5x6
                      ww_sg5x4
                      GHC.Base.Nothing;
        } in 
          case
              Data.Foldable.foldMap
                  w1_sg5x2
                  Data.Functor.Product.$fFoldableProduct8
                  f1_sg5x6
                  ww1_sg5x5
                  sat_sg5xc
          of
          { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct7;
            GHC.Base.Just v_sg5xe [Occ=Once] -> v_sg5xe;
          };

Data.Functor.Product.$fFoldableProduct_$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5xf w1_sg5xg w2_sg5xh w3_sg5xi]
        case w3_sg5xi of {
          Data.Functor.Product.Pair ww1_sg5xk [Occ=Once]
                                    ww2_sg5xl [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl1
                  w_sg5xf w1_sg5xg w2_sg5xh ww1_sg5xk ww2_sg5xl;
        };

Data.Functor.Product.$w$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5xm w1_sg5xn w2_sg5xo w3_sg5xp ww_sg5xq ww1_sg5xr]
        let {
          f1_sg5xs :: a_sg4Tv -> (b_sg4Tw -> b_sg4Tw) -> b_sg4Tw -> b_sg4Tw
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_sg5xo] \r [x_sg5xt y_sg5xu z_sg5xv]
                  case w2_sg5xo x_sg5xt z_sg5xv of vx_sg5xw {
                    __DEFAULT -> y_sg5xu vx_sg5xw;
                  }; } in
        let {
          sat_sg5xx [Occ=Once] :: b_sg4Tw -> b_sg4Tw
          [LclId] =
              [w_sg5xm ww_sg5xq f1_sg5xs] \u []
                  Data.Foldable.foldMap
                      w_sg5xm
                      Data.Functor.Product.$fFoldableProduct8
                      f1_sg5xs
                      ww_sg5xq
                      GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              w1_sg5xn
              Data.Functor.Product.$fFoldableProduct8
              f1_sg5xs
              ww1_sg5xr
              sat_sg5xx
              w3_sg5xp;

Data.Functor.Product.$fFoldableProduct_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5xy w1_sg5xz w2_sg5xA w3_sg5xB w4_sg5xC]
        case w4_sg5xC of {
          Data.Functor.Product.Pair ww1_sg5xE [Occ=Once]
                                    ww2_sg5xF [Occ=Once] ->
              Data.Functor.Product.$w$cfoldr'
                  w_sg5xy w1_sg5xz w2_sg5xA w3_sg5xB ww1_sg5xE ww2_sg5xF;
        };

Data.Functor.Product.$w$cfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5xG w1_sg5xH w2_sg5xI w3_sg5xJ ww_sg5xK ww1_sg5xL]
        let {
          sat_sg5xM [Occ=Once] :: b_sg4TL
          [LclId] =
              [w1_sg5xH w2_sg5xI w3_sg5xJ ww1_sg5xL] \u []
                  Data.Foldable.foldMap
                      w1_sg5xH
                      Data.Semigroup.Internal.$fMonoidEndo
                      w2_sg5xI
                      ww1_sg5xL
                      w3_sg5xJ;
        } in 
          Data.Foldable.foldMap
              w_sg5xG
              Data.Semigroup.Internal.$fMonoidEndo
              w2_sg5xI
              ww_sg5xK
              sat_sg5xM;

Data.Functor.Product.$fFoldableProduct_$cfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5xN w1_sg5xO w2_sg5xP w3_sg5xQ w4_sg5xR]
        case w4_sg5xR of {
          Data.Functor.Product.Pair ww1_sg5xT [Occ=Once]
                                    ww2_sg5xU [Occ=Once] ->
              Data.Functor.Product.$w$cfoldr
                  w_sg5xN w1_sg5xO w2_sg5xP w3_sg5xQ ww1_sg5xT ww2_sg5xU;
        };

Data.Functor.Product.$w$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5xV w1_sg5xW w2_sg5xX w3_sg5xY ww_sg5xZ ww1_sg5y0]
        let {
          f1_sg5y1 :: a_sg4U0 -> (b_sg4TZ -> b_sg4TZ) -> b_sg4TZ -> b_sg4TZ
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_sg5xX] \r [x_sg5y2 k_sg5y3 z_sg5y4]
                  case w2_sg5xX z_sg5y4 x_sg5y2 of vx_sg5y5 {
                    __DEFAULT -> k_sg5y3 vx_sg5y5;
                  }; } in
        let {
          sat_sg5y6 [Occ=Once] :: b_sg4TZ -> b_sg4TZ
          [LclId] =
              [w1_sg5xW ww1_sg5y0 f1_sg5y1] \u []
                  Data.Foldable.foldMap
                      w1_sg5xW
                      Data.Semigroup.Internal.$fMonoidEndo
                      f1_sg5y1
                      ww1_sg5y0
                      GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              w_sg5xV
              Data.Semigroup.Internal.$fMonoidEndo
              f1_sg5y1
              ww_sg5xZ
              sat_sg5y6
              w3_sg5xY;

Data.Functor.Product.$fFoldableProduct_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5y7 w1_sg5y8 w2_sg5y9 w3_sg5ya w4_sg5yb]
        case w4_sg5yb of {
          Data.Functor.Product.Pair ww1_sg5yd [Occ=Once]
                                    ww2_sg5ye [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl'
                  w_sg5y7 w1_sg5y8 w2_sg5y9 w3_sg5ya ww1_sg5yd ww2_sg5ye;
        };

Data.Functor.Product.$fFoldableProduct5
  :: forall a. GHC.Types.Int -> a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,A>m,
 Unf=OtherCon []] =
    [] \r [c_sg5yf ds_sg5yg]
        case c_sg5yf of {
          GHC.Types.I# x_sg5yi [Occ=Once] ->
              case +# [x_sg5yi 1#] of sat_sg5yj {
                __DEFAULT -> GHC.Types.I# [sat_sg5yj];
              };
        };

Data.Functor.Product.$fFoldableProduct_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Product.Product f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5yk $dFoldable1_sg5yl eta_sg5ym]
        case eta_sg5ym of {
          Data.Functor.Product.Pair ww1_sg5yo [Occ=Once]
                                    ww2_sg5yp [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl'
                  $dFoldable_sg5yk
                  $dFoldable1_sg5yl
                  Data.Functor.Product.$fFoldableProduct5
                  Data.Functor.Product.$fFoldableProduct4
                  ww1_sg5yo
                  ww2_sg5yp;
        };

lvl3_rg5nZ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Functor.Product.$fFoldableProduct9 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_rg5nZ of sat_sg5yq {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg5yq;
        };

Data.Functor.Product.$w$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5yr w1_sg5ys w2_sg5yt ww_sg5yu ww1_sg5yv]
        let {
          w3_sg5yw
            :: a_sg4Ue -> GHC.Base.Maybe a_sg4Ue -> GHC.Base.Maybe a_sg4Ue
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_sg5yt] \r [x_sg5yx m_sg5yy]
                  let {
                    sat_sg5yB [Occ=Once] :: a_sg4Ue
                    [LclId] =
                        [w2_sg5yt x_sg5yx m_sg5yy] \u []
                            case m_sg5yy of {
                              GHC.Base.Nothing -> x_sg5yx;
                              GHC.Base.Just y_sg5yA [Occ=Once] -> w2_sg5yt x_sg5yx y_sg5yA;
                            };
                  } in  GHC.Base.Just [sat_sg5yB]; } in
        let {
          sat_sg5yC [Occ=Once] :: GHC.Base.Maybe a_sg4Ue
          [LclId] =
              [w1_sg5ys ww1_sg5yv w3_sg5yw] \u []
                  Data.Foldable.foldMap
                      w1_sg5ys
                      Data.Semigroup.Internal.$fMonoidEndo
                      w3_sg5yw
                      ww1_sg5yv
                      GHC.Base.Nothing;
        } in 
          case
              Data.Foldable.foldMap
                  w_sg5yr
                  Data.Semigroup.Internal.$fMonoidEndo
                  w3_sg5yw
                  ww_sg5yu
                  sat_sg5yC
          of
          { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct9;
            GHC.Base.Just v_sg5yE [Occ=Once] -> v_sg5yE;
          };

Data.Functor.Product.$fFoldableProduct_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5yF w1_sg5yG w2_sg5yH w3_sg5yI]
        case w3_sg5yI of {
          Data.Functor.Product.Pair ww1_sg5yK [Occ=Once]
                                    ww2_sg5yL [Occ=Once] ->
              Data.Functor.Product.$w$cfoldr1
                  w_sg5yF w1_sg5yG w2_sg5yH ww1_sg5yK ww2_sg5yL;
        };

Data.Functor.Product.$fFoldableProduct6
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sg5yM ds1_sg5yN] GHC.Types.False [];

Data.Functor.Product.$fFoldableProduct_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5yO $dFoldable1_sg5yP eta_sg5yQ]
        case eta_sg5yQ of {
          Data.Functor.Product.Pair ww1_sg5yS [Occ=Once]
                                    ww2_sg5yT [Occ=Once] ->
              let {
                sat_sg5yU [Occ=Once] :: GHC.Types.Bool
                [LclId] =
                    [$dFoldable1_sg5yP ww2_sg5yT] \u []
                        Data.Foldable.foldMap
                            $dFoldable1_sg5yP
                            Data.Semigroup.Internal.$fMonoidEndo
                            Data.Functor.Product.$fFoldableProduct6
                            ww2_sg5yT
                            GHC.Types.True;
              } in 
                Data.Foldable.foldMap
                    $dFoldable_sg5yO
                    Data.Semigroup.Internal.$fMonoidEndo
                    Data.Functor.Product.$fFoldableProduct6
                    ww1_sg5yS
                    sat_sg5yU;
        };

Data.Functor.Product.$fFoldableProduct_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5yV $dFoldable1_sg5yW $dNum_sg5yX]
        let {
          $dMonoid_sg5yY
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_ag42x)
          [LclId] =
              [$dNum_sg5yX] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sg5yX; } in
        let {
          sat_sg5z5 [Occ=Once]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag42x
               -> Data.Semigroup.Internal.Product a_ag42x
          [LclId] =
              [$dFoldable_sg5yV
               $dFoldable1_sg5yW
               $dNum_sg5yX
               $dMonoid_sg5yY] \r [ds_sg5yZ]
                  case ds_sg5yZ of {
                    Data.Functor.Product.Pair x_sg5z1 [Occ=Once] y_sg5z2 [Occ=Once] ->
                        let {
                          sat_sg5z4 [Occ=Once] :: a_ag42x
                          [LclId] =
                              [$dFoldable1_sg5yW $dMonoid_sg5yY y_sg5z2] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_sg5yW
                                      $dMonoid_sg5yY
                                      Data.Functor.Product.$fFoldableProduct1
                                      y_sg5z2; } in
                        let {
                          sat_sg5z3 [Occ=Once] :: a_ag42x
                          [LclId] =
                              [$dFoldable_sg5yV $dMonoid_sg5yY x_sg5z1] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_sg5yV
                                      $dMonoid_sg5yY
                                      Data.Functor.Product.$fFoldableProduct1
                                      x_sg5z1;
                        } in  GHC.Num.* $dNum_sg5yX sat_sg5z3 sat_sg5z4;
                  };
        } in  sat_sg5z5;

Data.Functor.Product.$fFoldableProduct_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Product.Product f g a -> [a]
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5z6 $dFoldable1_sg5z7 eta_sg5z8]
        case eta_sg5z8 of {
          Data.Functor.Product.Pair ww1_sg5za [Occ=Once]
                                    ww2_sg5zb [Occ=Once] ->
              let {
                sat_sg5zc [Occ=Once] :: [a_ag41v]
                [LclId] =
                    [$dFoldable1_sg5z7 ww2_sg5zb] \u []
                        Data.Foldable.foldMap
                            $dFoldable1_sg5z7
                            Data.Semigroup.Internal.$fMonoidEndo
                            GHC.Types.:
                            ww2_sg5zb
                            GHC.Types.[];
              } in 
                Data.Foldable.foldMap
                    $dFoldable_sg5z6
                    Data.Semigroup.Internal.$fMonoidEndo
                    GHC.Types.:
                    ww1_sg5za
                    sat_sg5zc;
        };

Data.Functor.Product.$fFoldableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_sg5zd $dFoldable1_sg5ze]
        let {
          sat_sg5zu [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cproduct
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zt [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$csum
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zs [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cminimum
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zr [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cmaximum
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zq [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a
               -> Data.Functor.Product.Product f_ag400 g_ag401 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$celem
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B2 eta_B1; } in
        let {
          sat_sg5zp [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag400 g_ag401 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$clength
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zo [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag400 g_ag401 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cnull
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zn [Occ=Once]
            :: forall a. Data.Functor.Product.Product f_ag400 g_ag401 a -> [a]
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$ctoList
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zm [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldl1
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B2 eta_B1; } in
        let {
          sat_sg5zl [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldr1
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B2 eta_B1; } in
        let {
          sat_sg5zk [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldl'
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5zj [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldl
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5zi [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldr'
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5zh [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldr
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5zg [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> Data.Functor.Product.Product f_ag400 g_ag401 a -> m
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldMap
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5zf [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               Data.Functor.Product.Product f_ag400 g_ag401 m -> m
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfold
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_sg5zf
                                    sat_sg5zg
                                    sat_sg5zh
                                    sat_sg5zi
                                    sat_sg5zj
                                    sat_sg5zk
                                    sat_sg5zl
                                    sat_sg5zm
                                    sat_sg5zn
                                    sat_sg5zo
                                    sat_sg5zp
                                    sat_sg5zq
                                    sat_sg5zr
                                    sat_sg5zs
                                    sat_sg5zt
                                    sat_sg5zu];

Data.Functor.Product.$w$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> f a -> g a -> f1 (Data.Functor.Product.Product f g b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5zv w1_sg5zw w2_sg5zx w3_sg5zy ww_sg5zz ww1_sg5zA]
        let {
          sat_sg5zC [Occ=Once] :: f1_sg4Ux (g_sg4Uu b_sg4Uz)
          [LclId] =
              [w1_sg5zw w2_sg5zx w3_sg5zy ww1_sg5zA] \u []
                  Data.Traversable.traverse
                      w1_sg5zw w2_sg5zx w3_sg5zy ww1_sg5zA; } in
        let {
          sat_sg5zB [Occ=Once] :: f1_sg4Ux (f_sg4Ut b_sg4Uz)
          [LclId] =
              [w_sg5zv w2_sg5zx w3_sg5zy ww_sg5zz] \u []
                  Data.Traversable.traverse w_sg5zv w2_sg5zx w3_sg5zy ww_sg5zz;
        } in 
          GHC.Base.liftA2
              w2_sg5zx Data.Functor.Product.Pair sat_sg5zB sat_sg5zC;

Data.Functor.Product.$fTraversableProduct_$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> Data.Functor.Product.Product f g a
     -> f1 (Data.Functor.Product.Product f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5zD w1_sg5zE w2_sg5zF w3_sg5zG w4_sg5zH]
        case w4_sg5zH of {
          Data.Functor.Product.Pair ww1_sg5zJ [Occ=Once]
                                    ww2_sg5zK [Occ=Once] ->
              Data.Functor.Product.$w$ctraverse
                  w_sg5zD w1_sg5zE w2_sg5zF w3_sg5zG ww1_sg5zJ ww2_sg5zK;
        };

Data.Functor.Product.$fTraversableProduct_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg5zL $dTraversable1_sg5zM]
        let {
          sat_sg5zO [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_ag3YH
          [LclId] =
              [$dTraversable1_sg5zM] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sg5zM; } in
        let {
          sat_sg5zN [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_ag3YG
          [LclId] =
              [$dTraversable_sg5zL] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sg5zL;
        } in  Data.Functor.Product.$fFoldableProduct sat_sg5zN sat_sg5zO;

Data.Functor.Product.$fTraversableProduct_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg5zP $dTraversable1_sg5zQ]
        let {
          sat_sg5zS [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor g_ag3YH
          [LclId] =
              [$dTraversable1_sg5zQ] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sg5zQ; } in
        let {
          sat_sg5zR [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_ag3YG
          [LclId] =
              [$dTraversable_sg5zP] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sg5zP;
        } in  Data.Functor.Product.$fFunctorProduct sat_sg5zR sat_sg5zS;

Data.Functor.Product.$fTraversableProduct_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     Data.Functor.Product.Product f g (f1 a)
     -> f1 (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg5zT
           $dTraversable1_sg5zU
           $dApplicative_sg5zV
           w_sg5zW]
        case w_sg5zW of {
          Data.Functor.Product.Pair ww1_sg5zY [Occ=Once]
                                    ww2_sg5zZ [Occ=Once] ->
              Data.Functor.Product.$w$ctraverse
                  $dTraversable_sg5zT
                  $dTraversable1_sg5zU
                  $dApplicative_sg5zV
                  GHC.Base.id
                  ww1_sg5zY
                  ww2_sg5zZ;
        };

Data.Functor.Product.$fTraversableProduct_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg5A0
           $dTraversable1_sg5A1
           $dMonad_sg5A2
           eta_sg5A3
           eta1_sg5A4]
        case eta1_sg5A4 of {
          Data.Functor.Product.Pair ww1_sg5A6 [Occ=Once]
                                    ww2_sg5A7 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sg5A2 of sat_sg5A8 {
                __DEFAULT ->
                    Data.Functor.Product.$w$ctraverse
                        $dTraversable_sg5A0
                        $dTraversable1_sg5A1
                        sat_sg5A8
                        eta_sg5A3
                        ww1_sg5A6
                        ww2_sg5A7;
              };
        };

Data.Functor.Product.$fTraversableProduct_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Product.Product f g (m a)
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg5A9
           $dTraversable1_sg5Aa
           $dMonad_sg5Ab
           eta_sg5Ac]
        case eta_sg5Ac of {
          Data.Functor.Product.Pair ww1_sg5Ae [Occ=Once]
                                    ww2_sg5Af [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sg5Ab of sat_sg5Ag {
                __DEFAULT ->
                    Data.Functor.Product.$w$ctraverse
                        $dTraversable_sg5A9
                        $dTraversable1_sg5Aa
                        sat_sg5Ag
                        GHC.Base.id
                        ww1_sg5Ae
                        ww2_sg5Af;
              };
        };

Data.Functor.Product.$fTraversableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sg5Ah $dTraversable1_sg5Ai]
        let {
          sat_sg5Ao [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               Data.Functor.Product.Product f_ag3YG g_ag3YH (m a)
               -> m (Data.Functor.Product.Product f_ag3YG g_ag3YH a)
          [LclId] =
              [$dTraversable_sg5Ah $dTraversable1_sg5Ai] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$csequence
                      $dTraversable_sg5Ah $dTraversable1_sg5Ai eta_B2 eta_B1; } in
        let {
          sat_sg5An [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> Data.Functor.Product.Product f_ag3YG g_ag3YH a
               -> m (Data.Functor.Product.Product f_ag3YG g_ag3YH b)
          [LclId] =
              [$dTraversable_sg5Ah $dTraversable1_sg5Ai] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$cmapM
                      $dTraversable_sg5Ah $dTraversable1_sg5Ai eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5Am [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               Data.Functor.Product.Product f_ag3YG g_ag3YH (f a)
               -> f (Data.Functor.Product.Product f_ag3YG g_ag3YH a)
          [LclId] =
              [$dTraversable_sg5Ah $dTraversable1_sg5Ai] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$csequenceA
                      $dTraversable_sg5Ah $dTraversable1_sg5Ai eta_B2 eta_B1; } in
        let {
          sat_sg5Al [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> Data.Functor.Product.Product f_ag3YG g_ag3YH a
               -> f (Data.Functor.Product.Product f_ag3YG g_ag3YH b)
          [LclId] =
              [$dTraversable_sg5Ah $dTraversable1_sg5Ai] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$ctraverse
                      $dTraversable_sg5Ah $dTraversable1_sg5Ai eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5Ak [Occ=Once]
            :: Data.Foldable.Foldable
                 (Data.Functor.Product.Product f_ag3YG g_ag3YH)
          [LclId] =
              [$dTraversable_sg5Ah $dTraversable1_sg5Ai] \u []
                  Data.Functor.Product.$fTraversableProduct_$cp2Traversable
                      $dTraversable_sg5Ah $dTraversable1_sg5Ai; } in
        let {
          sat_sg5Aj [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Product.Product f_ag3YG g_ag3YH)
          [LclId] =
              [$dTraversable_sg5Ah $dTraversable1_sg5Ai] \u []
                  Data.Functor.Product.$fTraversableProduct_$cp1Traversable
                      $dTraversable_sg5Ah $dTraversable1_sg5Ai;
        } in 
          Data.Traversable.C:Traversable [sat_sg5Aj
                                          sat_sg5Ak
                                          sat_sg5Al
                                          sat_sg5Am
                                          sat_sg5An
                                          sat_sg5Ao];

Data.Functor.Product.$fApplicativeProduct_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b c.
     (a -> b -> c)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sg5Ap w1_sg5Aq w2_sg5Ar w3_sg5As w4_sg5At]
        case w3_sg5As of {
          Data.Functor.Product.Pair ww1_sg5Av [Occ=Once]
                                    ww2_sg5Aw [Occ=Once] ->
              case w4_sg5At of {
                Data.Functor.Product.Pair ww4_sg5Ay [Occ=Once]
                                          ww5_sg5Az [Occ=Once] ->
                    let {
                      sat_sg5AB [Occ=Once] :: g_sg4UK c_sg4UP
                      [LclId] =
                          [w1_sg5Aq w2_sg5Ar ww2_sg5Aw ww5_sg5Az] \u []
                              GHC.Base.liftA2 w1_sg5Aq w2_sg5Ar ww2_sg5Aw ww5_sg5Az; } in
                    let {
                      sat_sg5AA [Occ=Once] :: f_sg4UJ c_sg4UP
                      [LclId] =
                          [w_sg5Ap w2_sg5Ar ww1_sg5Av ww4_sg5Ay] \u []
                              GHC.Base.liftA2 w_sg5Ap w2_sg5Ar ww1_sg5Av ww4_sg5Ay;
                    } in  Data.Functor.Product.Pair [sat_sg5AA sat_sg5AB];
              };
        };

Data.Functor.Product.$fApplicativeProduct_$c<*>
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Product.Product f g (a -> b)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sg5AC $dApplicative1_sg5AD ds_sg5AE ds1_sg5AF]
        case ds_sg5AE of {
          Data.Functor.Product.Pair f1_sg5AH [Occ=Once]
                                    g1_sg5AI [Occ=Once] ->
              case ds1_sg5AF of {
                Data.Functor.Product.Pair x_sg5AK [Occ=Once] y_sg5AL [Occ=Once] ->
                    let {
                      sat_sg5AN [Occ=Once] :: g_ag3Xi b_ag3XJ
                      [LclId] =
                          [$dApplicative1_sg5AD g1_sg5AI y_sg5AL] \u []
                              GHC.Base.<*> $dApplicative1_sg5AD g1_sg5AI y_sg5AL; } in
                    let {
                      sat_sg5AM [Occ=Once] :: f_ag3Xh b_ag3XJ
                      [LclId] =
                          [$dApplicative_sg5AC f1_sg5AH x_sg5AK] \u []
                              GHC.Base.<*> $dApplicative_sg5AC f1_sg5AH x_sg5AK;
                    } in  Data.Functor.Product.Pair [sat_sg5AM sat_sg5AN];
              };
        };

Data.Functor.Product.$fApplicativeProduct_$cpure
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a. a -> Data.Functor.Product.Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U),A,A,A,A)><L,1*U(A,1*C1(U),A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sg5AO $dApplicative1_sg5AP x_sg5AQ]
        let {
          sat_sg5AS [Occ=Once] :: g_ag3Xi a_ag3Xs
          [LclId] =
              [$dApplicative1_sg5AP x_sg5AQ] \u []
                  GHC.Base.pure $dApplicative1_sg5AP x_sg5AQ; } in
        let {
          sat_sg5AR [Occ=Once] :: f_ag3Xh a_ag3Xs
          [LclId] =
              [$dApplicative_sg5AO x_sg5AQ] \u []
                  GHC.Base.pure $dApplicative_sg5AO x_sg5AQ;
        } in  Data.Functor.Product.Pair [sat_sg5AR sat_sg5AS];

Data.Functor.Product.$fApplicativeProduct_$cp1Applicative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Functor (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sg5AT $dApplicative1_sg5AU]
        let {
          sat_sg5AW [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor g_ag3Xi
          [LclId] =
              [$dApplicative1_sg5AU] \u []
                  GHC.Base.$p1Applicative $dApplicative1_sg5AU; } in
        let {
          sat_sg5AV [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_ag3Xh
          [LclId] =
              [$dApplicative_sg5AT] \u []
                  GHC.Base.$p1Applicative $dApplicative_sg5AT;
        } in  Data.Functor.Product.$fFunctorProduct sat_sg5AV sat_sg5AW;

Data.Functor.Product.$fApplicativeProduct1
  :: forall a b. a -> b -> b
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sg5AX eta_B1] GHC.Base.breakpoint eta_B1;

Data.Functor.Product.$w$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b. f a -> g a -> f b -> g b -> (# f b, g b #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5AY w1_sg5AZ ww_sg5B0 ww1_sg5B1 ww2_sg5B2 ww3_sg5B3]
        let {
          sat_sg5B9 [Occ=Once] :: g_sg4V8 b_sg4Vc
          [LclId] =
              [w1_sg5AZ ww1_sg5B1 ww3_sg5B3] \u []
                  let {
                    sat_sg5B8 [Occ=Once] :: g_sg4V8 (b_sg4Vc -> b_sg4Vc)
                    [LclId] =
                        [w1_sg5AZ ww1_sg5B1] \u []
                            case GHC.Base.$p1Applicative w1_sg5AZ of sat_sg5B7 {
                              __DEFAULT ->
                                  GHC.Base.fmap
                                      sat_sg5B7
                                      Data.Functor.Product.$fApplicativeProduct1
                                      ww1_sg5B1;
                            };
                  } in  GHC.Base.<*> w1_sg5AZ sat_sg5B8 ww3_sg5B3; } in
        let {
          sat_sg5B6 [Occ=Once] :: f_sg4V7 b_sg4Vc
          [LclId] =
              [w_sg5AY ww_sg5B0 ww2_sg5B2] \u []
                  let {
                    sat_sg5B5 [Occ=Once] :: f_sg4V7 (b_sg4Vc -> b_sg4Vc)
                    [LclId] =
                        [w_sg5AY ww_sg5B0] \u []
                            case GHC.Base.$p1Applicative w_sg5AY of sat_sg5B4 {
                              __DEFAULT ->
                                  GHC.Base.fmap
                                      sat_sg5B4 Data.Functor.Product.$fApplicativeProduct1 ww_sg5B0;
                            };
                  } in  GHC.Base.<*> w_sg5AY sat_sg5B5 ww2_sg5B2;
        } in  (#,#) [sat_sg5B6 sat_sg5B9];

Data.Functor.Product.$fApplicativeProduct_$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sg5Ba w1_sg5Bb w2_sg5Bc w3_sg5Bd]
        case w2_sg5Bc of {
          Data.Functor.Product.Pair ww1_sg5Bf [Occ=Once]
                                    ww2_sg5Bg [Occ=Once] ->
              case w3_sg5Bd of {
                Data.Functor.Product.Pair ww4_sg5Bi [Occ=Once]
                                          ww5_sg5Bj [Occ=Once] ->
                    case
                        Data.Functor.Product.$w$c*>
                            w_sg5Ba w1_sg5Bb ww1_sg5Bf ww2_sg5Bg ww4_sg5Bi ww5_sg5Bj
                    of
                    { (#,#) ww7_sg5Bl [Occ=Once] ww8_sg5Bm [Occ=Once] ->
                          Data.Functor.Product.Pair [ww7_sg5Bl ww8_sg5Bm];
                    };
              };
        };

Data.Functor.Product.$fApplicativeProduct_$c<*
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sg5Bn $dApplicative1_sg5Bo w_sg5Bp w1_sg5Bq]
        case w_sg5Bp of {
          Data.Functor.Product.Pair ww1_sg5Bs [Occ=Once]
                                    ww2_sg5Bt [Occ=Once] ->
              case w1_sg5Bq of {
                Data.Functor.Product.Pair ww4_sg5Bv [Occ=Once]
                                          ww5_sg5Bw [Occ=Once] ->
                    let {
                      sat_sg5By [Occ=Once] :: g_ag3Xi a_ag3Yx
                      [LclId] =
                          [$dApplicative1_sg5Bo ww2_sg5Bt ww5_sg5Bw] \u []
                              GHC.Base.liftA2
                                  $dApplicative1_sg5Bo GHC.Base.const ww2_sg5Bt ww5_sg5Bw; } in
                    let {
                      sat_sg5Bx [Occ=Once] :: f_ag3Xh a_ag3Yx
                      [LclId] =
                          [$dApplicative_sg5Bn ww1_sg5Bs ww4_sg5Bv] \u []
                              GHC.Base.liftA2
                                  $dApplicative_sg5Bn GHC.Base.const ww1_sg5Bs ww4_sg5Bv;
                    } in  Data.Functor.Product.Pair [sat_sg5Bx sat_sg5By];
              };
        };

Data.Functor.Product.$fApplicativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Applicative (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)><L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>m] =
    [] \r [$dApplicative_sg5Bz $dApplicative1_sg5BA]
        let {
          sat_sg5BG [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
          [LclId] =
              [$dApplicative_sg5Bz $dApplicative1_sg5BA] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$c<*
                      $dApplicative_sg5Bz $dApplicative1_sg5BA eta_B2 eta_B1; } in
        let {
          sat_sg5BF [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
          [LclId] =
              [$dApplicative_sg5Bz $dApplicative1_sg5BA] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$c*>
                      $dApplicative_sg5Bz $dApplicative1_sg5BA eta_B2 eta_B1; } in
        let {
          sat_sg5BE [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi c
          [LclId] =
              [$dApplicative_sg5Bz $dApplicative1_sg5BA] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$cliftA2
                      $dApplicative_sg5Bz $dApplicative1_sg5BA eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5BD [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Xh g_ag3Xi (a -> b)
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
          [LclId] =
              [$dApplicative_sg5Bz $dApplicative1_sg5BA] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$c<*>
                      $dApplicative_sg5Bz $dApplicative1_sg5BA eta_B2 eta_B1; } in
        let {
          sat_sg5BC [Occ=Once]
            :: forall a. a -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
          [LclId] =
              [$dApplicative_sg5Bz $dApplicative1_sg5BA] \r [eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$cpure
                      $dApplicative_sg5Bz $dApplicative1_sg5BA eta_B1; } in
        let {
          sat_sg5BB [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Product.Product f_ag3Xh g_ag3Xi)
          [LclId] =
              [$dApplicative_sg5Bz $dApplicative1_sg5BA] \u []
                  Data.Functor.Product.$fApplicativeProduct_$cp1Applicative
                      $dApplicative_sg5Bz $dApplicative1_sg5BA;
        } in 
          GHC.Base.C:Applicative [sat_sg5BB
                                  sat_sg5BC
                                  sat_sg5BD
                                  sat_sg5BE
                                  sat_sg5BF
                                  sat_sg5BG];

Data.Functor.Product.$fAlternativeProduct_$c<|>
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     forall a.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A)><L,1*U(A,A,1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sg5BH $dAlternative1_sg5BI ds_sg5BJ ds1_sg5BK]
        case ds_sg5BJ of {
          Data.Functor.Product.Pair x1_sg5BM [Occ=Once]
                                    y1_sg5BN [Occ=Once] ->
              case ds1_sg5BK of {
                Data.Functor.Product.Pair x2_sg5BP [Occ=Once]
                                          y2_sg5BQ [Occ=Once] ->
                    let {
                      sat_sg5BS [Occ=Once] :: g_ag3Wm a_ag3WM
                      [LclId] =
                          [$dAlternative1_sg5BI y1_sg5BN y2_sg5BQ] \u []
                              GHC.Base.<|> $dAlternative1_sg5BI y1_sg5BN y2_sg5BQ; } in
                    let {
                      sat_sg5BR [Occ=Once] :: f_ag3Wl a_ag3WM
                      [LclId] =
                          [$dAlternative_sg5BH x1_sg5BM x2_sg5BP] \u []
                              GHC.Base.<|> $dAlternative_sg5BH x1_sg5BM x2_sg5BP;
                    } in  Data.Functor.Product.Pair [sat_sg5BR sat_sg5BS];
              };
        };

Data.Functor.Product.$fAlternativeProduct_$cempty
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     forall a. Data.Functor.Product.Product f g a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A,A)><L,1*U(A,1*U,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sg5BT $dAlternative1_sg5BU]
        let {
          sat_sg5BW [Occ=Once] :: g_ag3Wm a_ag3Ww
          [LclId] =
              [$dAlternative1_sg5BU] \u []
                  GHC.Base.empty $dAlternative1_sg5BU; } in
        let {
          sat_sg5BV [Occ=Once] :: f_ag3Wl a_ag3Ww
          [LclId] =
              [$dAlternative_sg5BT] \u [] GHC.Base.empty $dAlternative_sg5BT;
        } in  Data.Functor.Product.Pair [sat_sg5BV sat_sg5BW];

Data.Functor.Product.$fAlternativeProduct_$cp1Alternative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     GHC.Base.Applicative (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)><L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sg5BX $dAlternative1_sg5BY]
        let {
          sat_sg5C0 [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative g_ag3Wm
          [LclId] =
              [$dAlternative1_sg5BY] \u []
                  GHC.Base.$p1Alternative $dAlternative1_sg5BY; } in
        let {
          sat_sg5BZ [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative f_ag3Wl
          [LclId] =
              [$dAlternative_sg5BX] \u []
                  GHC.Base.$p1Alternative $dAlternative_sg5BX;
        } in 
          Data.Functor.Product.$fApplicativeProduct sat_sg5BZ sat_sg5C0;

poly_some_v_rg5o0
  :: forall (f :: * -> *) (g :: * -> *) a.
     Data.Functor.Product.Product f g [a]
[GblId, Str=b] =
    [] \u [] poly_some_v_rg5o0;

Data.Functor.Product.$fAlternativeProduct_$csome [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     forall a.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g [a]
[GblId, Arity=3, Str=<B,A><B,A><B,1*H>b, Unf=OtherCon []] =
    [] \r [w_sg5C1 w1_sg5C2 w2_sg5C3]
        case w2_sg5C3 of {
          Data.Functor.Product.Pair _ [Occ=Dead] _ [Occ=Dead] ->
              poly_some_v_rg5o0;
        };

Data.Functor.Product.$fAlternativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     GHC.Base.Alternative (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)><L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>m] =
    [] \r [$dAlternative_sg5C7 $dAlternative1_sg5C8]
        let {
          sat_sg5Cd [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm [a]
          [LclId] =
              [$dAlternative_sg5C7 $dAlternative1_sg5C8] \r [eta_B1]
                  Data.Functor.Product.$fAlternativeProduct_$csome
                      $dAlternative_sg5C7 $dAlternative1_sg5C8 eta_B1; } in
        let {
          sat_sg5Cc [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm [a]
          [LclId] =
              [$dAlternative_sg5C7 $dAlternative1_sg5C8] \r [eta_B1]
                  Data.Functor.Product.$fAlternativeProduct_$csome
                      $dAlternative_sg5C7 $dAlternative1_sg5C8 eta_B1; } in
        let {
          sat_sg5Cb [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
          [LclId] =
              [$dAlternative_sg5C7 $dAlternative1_sg5C8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fAlternativeProduct_$c<|>
                      $dAlternative_sg5C7 $dAlternative1_sg5C8 eta_B2 eta_B1; } in
        let {
          sat_sg5Ca [Occ=Once]
            :: forall a. Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
          [LclId] =
              [$dAlternative_sg5C7 $dAlternative1_sg5C8] \u []
                  Data.Functor.Product.$fAlternativeProduct_$cempty
                      $dAlternative_sg5C7 $dAlternative1_sg5C8; } in
        let {
          sat_sg5C9 [Occ=Once]
            :: GHC.Base.Applicative
                 (Data.Functor.Product.Product f_ag3Wl g_ag3Wm)
          [LclId] =
              [$dAlternative_sg5C7 $dAlternative1_sg5C8] \u []
                  Data.Functor.Product.$fAlternativeProduct_$cp1Alternative
                      $dAlternative_sg5C7 $dAlternative1_sg5C8;
        } in 
          GHC.Base.C:Alternative [sat_sg5C9
                                  sat_sg5Ca
                                  sat_sg5Cb
                                  sat_sg5Cc
                                  sat_sg5Cd];

Data.Functor.Product.$fMonadProduct_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> (a -> Data.Functor.Product.Product f g b)
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><L,C(U(1*U,1*U))>m,
 Unf=OtherCon []] =
    [] \r [w_sg5Ce w1_sg5Cf w2_sg5Cg w3_sg5Ch]
        case w2_sg5Cg of {
          Data.Functor.Product.Pair ww1_sg5Cj [Occ=Once]
                                    ww2_sg5Ck [Occ=Once] ->
              let {
                sat_sg5Cw [Occ=Once] :: g_sg4VS b_sg4VW
                [LclId] =
                    [w1_sg5Cf w3_sg5Ch ww2_sg5Ck] \u []
                        let {
                          sat_sg5Cv [Occ=Once] :: a_sg4VV -> g_sg4VS b_sg4VW
                          [LclId] =
                              [w3_sg5Ch] \r [x_sg5Cr]
                                  case w3_sg5Ch x_sg5Cr of {
                                    Data.Functor.Product.Pair _ [Occ=Dead] b1_sg5Cu [Occ=Once] ->
                                        b1_sg5Cu;
                                  };
                        } in  GHC.Base.>>= w1_sg5Cf ww2_sg5Ck sat_sg5Cv; } in
              let {
                sat_sg5Cq [Occ=Once] :: f_sg4VR b_sg4VW
                [LclId] =
                    [w_sg5Ce w3_sg5Ch ww1_sg5Cj] \u []
                        let {
                          sat_sg5Cp [Occ=Once] :: a_sg4VV -> f_sg4VR b_sg4VW
                          [LclId] =
                              [w3_sg5Ch] \r [x_sg5Cl]
                                  case w3_sg5Ch x_sg5Cl of {
                                    Data.Functor.Product.Pair a1_sg5Cn [Occ=Once] _ [Occ=Dead] ->
                                        a1_sg5Cn;
                                  };
                        } in  GHC.Base.>>= w_sg5Ce ww1_sg5Cj sat_sg5Cp;
              } in  Data.Functor.Product.Pair [sat_sg5Cq sat_sg5Cw];
        };

Data.Functor.Product.$fMonadProduct_$cp1Monad
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     GHC.Base.Applicative (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)><L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonad_sg5Cx $dMonad1_sg5Cy]
        let {
          sat_sg5CA [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative g_ag3Uv
          [LclId] =
              [$dMonad1_sg5Cy] \u [] GHC.Base.$p1Monad $dMonad1_sg5Cy; } in
        let {
          sat_sg5Cz [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative f_ag3Uu
          [LclId] =
              [$dMonad_sg5Cx] \u [] GHC.Base.$p1Monad $dMonad_sg5Cx;
        } in 
          Data.Functor.Product.$fApplicativeProduct sat_sg5Cz sat_sg5CA;

Data.Functor.Product.$fMonadProduct_$creturn [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     forall a. a -> Data.Functor.Product.Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sg5CB w1_sg5CC w2_sg5CD]
        let {
          sat_sg5CH [Occ=Once] :: g_sg4W9 a_sg4Wc
          [LclId] =
              [w1_sg5CC w2_sg5CD] \u []
                  case GHC.Base.$p1Monad w1_sg5CC of sat_sg5CG {
                    __DEFAULT -> GHC.Base.pure sat_sg5CG w2_sg5CD;
                  }; } in
        let {
          sat_sg5CF [Occ=Once] :: f_sg4W8 a_sg4Wc
          [LclId] =
              [w_sg5CB w2_sg5CD] \u []
                  case GHC.Base.$p1Monad w_sg5CB of sat_sg5CE {
                    __DEFAULT -> GHC.Base.pure sat_sg5CE w2_sg5CD;
                  };
        } in  Data.Functor.Product.Pair [sat_sg5CF sat_sg5CH];

Data.Functor.Product.$fMonadProduct_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonad_sg5CI $dMonad1_sg5CJ eta_sg5CK eta1_sg5CL]
        case eta_sg5CK of {
          Data.Functor.Product.Pair m_sg5CN [Occ=Once] n_sg5CO [Occ=Once] ->
              let {
                sat_sg5D0 [Occ=Once] :: g_ag3Uv b_ag3VX
                [LclId] =
                    [$dMonad1_sg5CJ eta1_sg5CL n_sg5CO] \u []
                        let {
                          sat_sg5CZ [Occ=Once] :: a_ag3VW -> g_ag3Uv b_ag3VX
                          [LclId] =
                              [eta1_sg5CL] \r [x_sg5CV]
                                  case eta1_sg5CL of {
                                    Data.Functor.Product.Pair _ [Occ=Dead] b1_sg5CY [Occ=Once] ->
                                        b1_sg5CY;
                                  };
                        } in  GHC.Base.>>= $dMonad1_sg5CJ n_sg5CO sat_sg5CZ; } in
              let {
                sat_sg5CU [Occ=Once] :: f_ag3Uu b_ag3VX
                [LclId] =
                    [$dMonad_sg5CI eta1_sg5CL m_sg5CN] \u []
                        let {
                          sat_sg5CT [Occ=Once] :: a_ag3VW -> f_ag3Uu b_ag3VX
                          [LclId] =
                              [eta1_sg5CL] \r [x_sg5CP]
                                  case eta1_sg5CL of {
                                    Data.Functor.Product.Pair a1_sg5CR [Occ=Once] _ [Occ=Dead] ->
                                        a1_sg5CR;
                                  };
                        } in  GHC.Base.>>= $dMonad_sg5CI m_sg5CN sat_sg5CT;
              } in  Data.Functor.Product.Pair [sat_sg5CU sat_sg5D0];
        };

lvl4_rg5o1
  :: forall (f :: * -> *) (g :: * -> *) a.
     [GHC.Types.Char] -> Data.Functor.Product.Product f g a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sg5D1] GHC.Err.errorWithoutStackTrace eta_sg5D1;

Data.Functor.Product.$fMonadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)><L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>m] =
    [] \r [$dMonad_sg5D2 $dMonad1_sg5D3]
        let {
          sat_sg5D7 [Occ=Once]
            :: forall a. a -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv a
          [LclId] =
              [$dMonad_sg5D2 $dMonad1_sg5D3] \r [eta_B1]
                  Data.Functor.Product.$fMonadProduct_$creturn
                      $dMonad_sg5D2 $dMonad1_sg5D3 eta_B1; } in
        let {
          sat_sg5D6 [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Uu g_ag3Uv a
               -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b
               -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b
          [LclId] =
              [$dMonad_sg5D2 $dMonad1_sg5D3] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadProduct_$c>>
                      $dMonad_sg5D2 $dMonad1_sg5D3 eta_B2 eta_B1; } in
        let {
          sat_sg5D5 [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Uu g_ag3Uv a
               -> (a -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b)
               -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b
          [LclId] =
              [$dMonad_sg5D2 $dMonad1_sg5D3] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadProduct_$c>>=
                      $dMonad_sg5D2 $dMonad1_sg5D3 eta_B2 eta_B1; } in
        let {
          sat_sg5D4 [Occ=Once]
            :: GHC.Base.Applicative
                 (Data.Functor.Product.Product f_ag3Uu g_ag3Uv)
          [LclId] =
              [$dMonad_sg5D2 $dMonad1_sg5D3] \u []
                  Data.Functor.Product.$fMonadProduct_$cp1Monad
                      $dMonad_sg5D2 $dMonad1_sg5D3;
        } in 
          GHC.Base.C:Monad [sat_sg5D4
                            sat_sg5D5
                            sat_sg5D6
                            sat_sg5D7
                            lvl4_rg5o1];

Data.Functor.Product.$fMonadPlusProduct_$cmplus
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     forall a.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(U)))><L,1*U(A,A,A,1*C1(C1(U)))><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sg5D8 $dMonadPlus1_sg5D9 ds_sg5Da ds1_sg5Db]
        case ds_sg5Da of {
          Data.Functor.Product.Pair x1_sg5Dd [Occ=Once]
                                    y1_sg5De [Occ=Once] ->
              case ds1_sg5Db of {
                Data.Functor.Product.Pair x2_sg5Dg [Occ=Once]
                                          y2_sg5Dh [Occ=Once] ->
                    let {
                      sat_sg5Dj [Occ=Once] :: g_ag3TL a_ag3Uf
                      [LclId] =
                          [$dMonadPlus1_sg5D9 y1_sg5De y2_sg5Dh] \u []
                              GHC.Base.mplus $dMonadPlus1_sg5D9 y1_sg5De y2_sg5Dh; } in
                    let {
                      sat_sg5Di [Occ=Once] :: f_ag3TK a_ag3Uf
                      [LclId] =
                          [$dMonadPlus_sg5D8 x1_sg5Dd x2_sg5Dg] \u []
                              GHC.Base.mplus $dMonadPlus_sg5D8 x1_sg5Dd x2_sg5Dg;
                    } in  Data.Functor.Product.Pair [sat_sg5Di sat_sg5Dj];
              };
        };

Data.Functor.Product.$fMonadPlusProduct_$cmzero
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     forall a. Data.Functor.Product.Product f g a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*U,A)><L,1*U(A,A,1*U,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sg5Dk $dMonadPlus1_sg5Dl]
        let {
          sat_sg5Dn [Occ=Once] :: g_ag3TL a_ag3TZ
          [LclId] =
              [$dMonadPlus1_sg5Dl] \u [] GHC.Base.mzero $dMonadPlus1_sg5Dl; } in
        let {
          sat_sg5Dm [Occ=Once] :: f_ag3TK a_ag3TZ
          [LclId] =
              [$dMonadPlus_sg5Dk] \u [] GHC.Base.mzero $dMonadPlus_sg5Dk;
        } in  Data.Functor.Product.Pair [sat_sg5Dm sat_sg5Dn];

Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A)><L,1*U(A,1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sg5Do $dMonadPlus1_sg5Dp]
        let {
          sat_sg5Dr [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_ag3TL
          [LclId] =
              [$dMonadPlus1_sg5Dp] \u []
                  GHC.Base.$p2MonadPlus $dMonadPlus1_sg5Dp; } in
        let {
          sat_sg5Dq [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_ag3TK
          [LclId] =
              [$dMonadPlus_sg5Do] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_sg5Do;
        } in  Data.Functor.Product.$fMonadProduct sat_sg5Dq sat_sg5Dr;

Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     GHC.Base.Alternative (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sg5Ds $dMonadPlus1_sg5Dt]
        let {
          sat_sg5Dv [Occ=Once,
                     Dmd=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>]
            :: GHC.Base.Alternative g_ag3TL
          [LclId] =
              [$dMonadPlus1_sg5Dt] \u []
                  GHC.Base.$p1MonadPlus $dMonadPlus1_sg5Dt; } in
        let {
          sat_sg5Du [Occ=Once,
                     Dmd=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>]
            :: GHC.Base.Alternative f_ag3TK
          [LclId] =
              [$dMonadPlus_sg5Ds] \u [] GHC.Base.$p1MonadPlus $dMonadPlus_sg5Ds;
        } in 
          Data.Functor.Product.$fAlternativeProduct sat_sg5Du sat_sg5Dv;

Data.Functor.Product.$fMonadPlusProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     GHC.Base.MonadPlus (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),1*U,C(C1(U)))><L,U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),1*U,C(C1(U)))>m] =
    [] \r [$dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx]
        let {
          sat_sg5DB [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3TK g_ag3TL a
               -> Data.Functor.Product.Product f_ag3TK g_ag3TL a
               -> Data.Functor.Product.Product f_ag3TK g_ag3TL a
          [LclId] =
              [$dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadPlusProduct_$cmplus
                      $dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx eta_B2 eta_B1; } in
        let {
          sat_sg5DA [Occ=Once]
            :: forall a. Data.Functor.Product.Product f_ag3TK g_ag3TL a
          [LclId] =
              [$dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx] \u []
                  Data.Functor.Product.$fMonadPlusProduct_$cmzero
                      $dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx; } in
        let {
          sat_sg5Dz [Occ=Once]
            :: GHC.Base.Monad (Data.Functor.Product.Product f_ag3TK g_ag3TL)
          [LclId] =
              [$dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx] \u []
                  Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus
                      $dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx; } in
        let {
          sat_sg5Dy [Occ=Once]
            :: GHC.Base.Alternative
                 (Data.Functor.Product.Product f_ag3TK g_ag3TL)
          [LclId] =
              [$dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx] \u []
                  Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus
                      $dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx;
        } in 
          GHC.Base.C:MonadPlus [sat_sg5Dy sat_sg5Dz sat_sg5DA sat_sg5DB];

Data.Functor.Product.$fMonadFixProduct_$cmfix [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) =>
     forall a.
     (a -> Data.Functor.Product.Product f g a)
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U))><L,1*U(A,1*C1(U))><L,C(U(1*U,1*U))>m,
 Unf=OtherCon []] =
    [] \r [w_sg5DC w1_sg5DD w2_sg5DE]
        let {
          sat_sg5DQ [Occ=Once] :: g_sg4Wj a_sg4Wm
          [LclId] =
              [w1_sg5DD w2_sg5DE] \u []
                  let {
                    sat_sg5DP [Occ=Once] :: a_sg4Wm -> g_sg4Wj a_sg4Wm
                    [LclId] =
                        [w2_sg5DE] \r [x_sg5DL]
                            case w2_sg5DE x_sg5DL of {
                              Data.Functor.Product.Pair _ [Occ=Dead] b_sg5DO [Occ=Once] ->
                                  b_sg5DO;
                            };
                  } in  Control.Monad.Fix.mfix w1_sg5DD sat_sg5DP; } in
        let {
          sat_sg5DK [Occ=Once] :: f_sg4Wi a_sg4Wm
          [LclId] =
              [w_sg5DC w2_sg5DE] \u []
                  let {
                    sat_sg5DJ [Occ=Once] :: a_sg4Wm -> f_sg4Wi a_sg4Wm
                    [LclId] =
                        [w2_sg5DE] \r [x_sg5DF]
                            case w2_sg5DE x_sg5DF of {
                              Data.Functor.Product.Pair a1_sg5DH [Occ=Once] _ [Occ=Dead] ->
                                  a1_sg5DH;
                            };
                  } in  Control.Monad.Fix.mfix w_sg5DC sat_sg5DJ;
        } in  Data.Functor.Product.Pair [sat_sg5DK sat_sg5DQ];

Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A)><L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadFix_sg5DR $dMonadFix1_sg5DS]
        let {
          sat_sg5DU [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_ag3Sn
          [LclId] =
              [$dMonadFix1_sg5DS] \u []
                  Control.Monad.Fix.$p1MonadFix $dMonadFix1_sg5DS; } in
        let {
          sat_sg5DT [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_ag3Sm
          [LclId] =
              [$dMonadFix_sg5DR] \u []
                  Control.Monad.Fix.$p1MonadFix $dMonadFix_sg5DR;
        } in  Data.Functor.Product.$fMonadProduct sat_sg5DT sat_sg5DU;

Data.Functor.Product.$fMonadFixProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) =>
     Control.Monad.Fix.MonadFix (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),C(U))><L,U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),C(U))>m] =
    [] \r [$dMonadFix_sg5DV $dMonadFix1_sg5DW]
        let {
          sat_sg5DY [Occ=Once]
            :: forall a.
               (a -> Data.Functor.Product.Product f_ag3Sm g_ag3Sn a)
               -> Data.Functor.Product.Product f_ag3Sm g_ag3Sn a
          [LclId] =
              [$dMonadFix_sg5DV $dMonadFix1_sg5DW] \r [eta_B1]
                  Data.Functor.Product.$fMonadFixProduct_$cmfix
                      $dMonadFix_sg5DV $dMonadFix1_sg5DW eta_B1; } in
        let {
          sat_sg5DX [Occ=Once]
            :: GHC.Base.Monad (Data.Functor.Product.Product f_ag3Sm g_ag3Sn)
          [LclId] =
              [$dMonadFix_sg5DV $dMonadFix1_sg5DW] \u []
                  Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix
                      $dMonadFix_sg5DV $dMonadFix1_sg5DW;
        } in  Control.Monad.Fix.C:MonadFix [sat_sg5DX sat_sg5DY];

Data.Functor.Product.$fMonadZipProduct_$cmzipWith [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b c.
     (a -> b -> c)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sg5DZ w1_sg5E0 w2_sg5E1 w3_sg5E2 w4_sg5E3]
        case w3_sg5E2 of {
          Data.Functor.Product.Pair ww1_sg5E5 [Occ=Once]
                                    ww2_sg5E6 [Occ=Once] ->
              case w4_sg5E3 of {
                Data.Functor.Product.Pair ww4_sg5E8 [Occ=Once]
                                          ww5_sg5E9 [Occ=Once] ->
                    let {
                      sat_sg5Eb [Occ=Once] :: g_sg4Wt c_sg4Wy
                      [LclId] =
                          [w1_sg5E0 w2_sg5E1 ww2_sg5E6 ww5_sg5E9] \u []
                              Control.Monad.Zip.mzipWith
                                  w1_sg5E0 w2_sg5E1 ww2_sg5E6 ww5_sg5E9; } in
                    let {
                      sat_sg5Ea [Occ=Once] :: f_sg4Ws c_sg4Wy
                      [LclId] =
                          [w_sg5DZ w2_sg5E1 ww1_sg5E5 ww4_sg5E8] \u []
                              Control.Monad.Zip.mzipWith w_sg5DZ w2_sg5E1 ww1_sg5E5 ww4_sg5E8;
                    } in  Data.Functor.Product.Pair [sat_sg5Ea sat_sg5Eb];
              };
        };

Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sg5Ec $dMonadZip1_sg5Ed]
        let {
          sat_sg5Ef [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_ag3Rx
          [LclId] =
              [$dMonadZip1_sg5Ed] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip1_sg5Ed; } in
        let {
          sat_sg5Ee [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_ag3Rw
          [LclId] =
              [$dMonadZip_sg5Ec] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sg5Ec;
        } in  Data.Functor.Product.$fMonadProduct sat_sg5Ee sat_sg5Ef;

Data.Functor.Product.$fMonadZipProduct_$cmzip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sg5Eg $dMonadZip1_sg5Eh w_sg5Ei w1_sg5Ej]
        case w_sg5Ei of {
          Data.Functor.Product.Pair ww1_sg5El [Occ=Once]
                                    ww2_sg5Em [Occ=Once] ->
              case w1_sg5Ej of {
                Data.Functor.Product.Pair ww4_sg5Eo [Occ=Once]
                                          ww5_sg5Ep [Occ=Once] ->
                    let {
                      sat_sg5Er [Occ=Once] :: g_ag3Rx (a_ag3RH, b_ag3RI)
                      [LclId] =
                          [$dMonadZip1_sg5Eh ww2_sg5Em ww5_sg5Ep] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip1_sg5Eh GHC.Tuple.(,) ww2_sg5Em ww5_sg5Ep; } in
                    let {
                      sat_sg5Eq [Occ=Once] :: f_ag3Rw (a_ag3RH, b_ag3RI)
                      [LclId] =
                          [$dMonadZip_sg5Eg ww1_sg5El ww4_sg5Eo] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip_sg5Eg GHC.Tuple.(,) ww1_sg5El ww4_sg5Eo;
                    } in  Data.Functor.Product.Pair [sat_sg5Eq sat_sg5Er];
              };
        };

Data.Functor.Product.$w$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     Data.Functor.Product.Product f g (a, b)
     -> (# Data.Functor.Product.Product f g a,
           Data.Functor.Product.Product f g b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5Es w1_sg5Et w2_sg5Eu]
        let {
          $dMonad_sg5Ev [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_sg4WQ
          [LclId] =
              [w_sg5Es] \u [] Control.Monad.Zip.$p1MonadZip w_sg5Es; } in
        let {
          $dMonad1_sg5Ew [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_sg4WR
          [LclId] =
              [w1_sg5Et] \u [] Control.Monad.Zip.$p1MonadZip w1_sg5Et; } in
        let {
          sat_sg5Fa [Occ=Once]
            :: Data.Functor.Product.Product f_sg4WQ g_sg4WR b_sg4WV
          [LclId] =
              [w2_sg5Eu $dMonad_sg5Ev $dMonad1_sg5Ew] \u []
                  case w2_sg5Eu of {
                    Data.Functor.Product.Pair m_sg5ES [Occ=Once] n_sg5ET [Occ=Once] ->
                        let {
                          sat_sg5F9 [Occ=Once] :: g_sg4WR b_sg4WV
                          [LclId] =
                              [$dMonad1_sg5Ew n_sg5ET] \u []
                                  let {
                                    lvl9_sg5F2 [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative g_sg4WR
                                    [LclId] =
                                        [$dMonad1_sg5Ew] \u []
                                            GHC.Base.$p1Monad $dMonad1_sg5Ew; } in
                                  let {
                                    sat_sg5F8 [Occ=Once] :: (a_sg4WU, b_sg4WV) -> g_sg4WR b_sg4WV
                                    [LclId] =
                                        [lvl9_sg5F2] \r [x_sg5F3]
                                            let {
                                              sat_sg5F7 [Occ=Once] :: b_sg4WV
                                              [LclId] =
                                                  [x_sg5F3] \u []
                                                      case x_sg5F3 of {
                                                        (,) _ [Occ=Dead] y_sg5F6 [Occ=Once] ->
                                                            y_sg5F6;
                                                      };
                                            } in  GHC.Base.pure lvl9_sg5F2 sat_sg5F7;
                                  } in  GHC.Base.>>= $dMonad1_sg5Ew n_sg5ET sat_sg5F8; } in
                        let {
                          sat_sg5F1 [Occ=Once] :: f_sg4WQ b_sg4WV
                          [LclId] =
                              [$dMonad_sg5Ev m_sg5ES] \u []
                                  let {
                                    lvl9_sg5EU [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative f_sg4WQ
                                    [LclId] =
                                        [$dMonad_sg5Ev] \u [] GHC.Base.$p1Monad $dMonad_sg5Ev; } in
                                  let {
                                    sat_sg5F0 [Occ=Once] :: (a_sg4WU, b_sg4WV) -> f_sg4WQ b_sg4WV
                                    [LclId] =
                                        [lvl9_sg5EU] \r [x_sg5EV]
                                            let {
                                              sat_sg5EZ [Occ=Once] :: b_sg4WV
                                              [LclId] =
                                                  [x_sg5EV] \u []
                                                      case x_sg5EV of {
                                                        (,) _ [Occ=Dead] y_sg5EY [Occ=Once] ->
                                                            y_sg5EY;
                                                      };
                                            } in  GHC.Base.pure lvl9_sg5EU sat_sg5EZ;
                                  } in  GHC.Base.>>= $dMonad_sg5Ev m_sg5ES sat_sg5F0;
                        } in  Data.Functor.Product.Pair [sat_sg5F1 sat_sg5F9];
                  }; } in
        let {
          sat_sg5EQ [Occ=Once]
            :: Data.Functor.Product.Product f_sg4WQ g_sg4WR a_sg4WU
          [LclId] =
              [w2_sg5Eu $dMonad_sg5Ev $dMonad1_sg5Ew] \u []
                  case w2_sg5Eu of {
                    Data.Functor.Product.Pair m_sg5Ey [Occ=Once] n_sg5Ez [Occ=Once] ->
                        let {
                          sat_sg5EP [Occ=Once] :: g_sg4WR a_sg4WU
                          [LclId] =
                              [$dMonad1_sg5Ew n_sg5Ez] \u []
                                  let {
                                    lvl9_sg5EI [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative g_sg4WR
                                    [LclId] =
                                        [$dMonad1_sg5Ew] \u []
                                            GHC.Base.$p1Monad $dMonad1_sg5Ew; } in
                                  let {
                                    sat_sg5EO [Occ=Once] :: (a_sg4WU, b_sg4WV) -> g_sg4WR a_sg4WU
                                    [LclId] =
                                        [lvl9_sg5EI] \r [x_sg5EJ]
                                            let {
                                              sat_sg5EN [Occ=Once] :: a_sg4WU
                                              [LclId] =
                                                  [x_sg5EJ] \u []
                                                      case x_sg5EJ of {
                                                        (,) x1_sg5EL [Occ=Once] _ [Occ=Dead] ->
                                                            x1_sg5EL;
                                                      };
                                            } in  GHC.Base.pure lvl9_sg5EI sat_sg5EN;
                                  } in  GHC.Base.>>= $dMonad1_sg5Ew n_sg5Ez sat_sg5EO; } in
                        let {
                          sat_sg5EH [Occ=Once] :: f_sg4WQ a_sg4WU
                          [LclId] =
                              [$dMonad_sg5Ev m_sg5Ey] \u []
                                  let {
                                    lvl9_sg5EA [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative f_sg4WQ
                                    [LclId] =
                                        [$dMonad_sg5Ev] \u [] GHC.Base.$p1Monad $dMonad_sg5Ev; } in
                                  let {
                                    sat_sg5EG [Occ=Once] :: (a_sg4WU, b_sg4WV) -> f_sg4WQ a_sg4WU
                                    [LclId] =
                                        [lvl9_sg5EA] \r [x_sg5EB]
                                            let {
                                              sat_sg5EF [Occ=Once] :: a_sg4WU
                                              [LclId] =
                                                  [x_sg5EB] \u []
                                                      case x_sg5EB of {
                                                        (,) x1_sg5ED [Occ=Once] _ [Occ=Dead] ->
                                                            x1_sg5ED;
                                                      };
                                            } in  GHC.Base.pure lvl9_sg5EA sat_sg5EF;
                                  } in  GHC.Base.>>= $dMonad_sg5Ev m_sg5Ey sat_sg5EG;
                        } in  Data.Functor.Product.Pair [sat_sg5EH sat_sg5EP];
                  };
        } in  (#,#) [sat_sg5EQ sat_sg5Fa];

Data.Functor.Product.$fMonadZipProduct_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     Data.Functor.Product.Product f g (a, b)
     -> (Data.Functor.Product.Product f g a,
         Data.Functor.Product.Product f g b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sg5Fb w1_sg5Fc w2_sg5Fd]
        case Data.Functor.Product.$w$cmunzip w_sg5Fb w1_sg5Fc w2_sg5Fd of {
          (#,#) ww1_sg5Ff [Occ=Once] ww2_sg5Fg [Occ=Once] ->
              (,) [ww1_sg5Ff ww2_sg5Fg];
        };

Data.Functor.Product.$fMonadZipProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     Control.Monad.Zip.MonadZip (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)><L,U(U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sg5Fh $dMonadZip1_sg5Fi]
        let {
          sat_sg5Fm [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Rw g_ag3Rx (a, b)
               -> (Data.Functor.Product.Product f_ag3Rw g_ag3Rx a,
                   Data.Functor.Product.Product f_ag3Rw g_ag3Rx b)
          [LclId] =
              [$dMonadZip_sg5Fh $dMonadZip1_sg5Fi] \r [eta_B1]
                  Data.Functor.Product.$fMonadZipProduct_$cmunzip
                      $dMonadZip_sg5Fh $dMonadZip1_sg5Fi eta_B1; } in
        let {
          sat_sg5Fl [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx a
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx b
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx c
          [LclId] =
              [$dMonadZip_sg5Fh $dMonadZip1_sg5Fi] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadZipProduct_$cmzipWith
                      $dMonadZip_sg5Fh $dMonadZip1_sg5Fi eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5Fk [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Rw g_ag3Rx a
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx b
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx (a, b)
          [LclId] =
              [$dMonadZip_sg5Fh $dMonadZip1_sg5Fi] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadZipProduct_$cmzip
                      $dMonadZip_sg5Fh $dMonadZip1_sg5Fi eta_B2 eta_B1; } in
        let {
          sat_sg5Fj [Occ=Once]
            :: GHC.Base.Monad (Data.Functor.Product.Product f_ag3Rw g_ag3Rx)
          [LclId] =
              [$dMonadZip_sg5Fh $dMonadZip1_sg5Fi] \u []
                  Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip
                      $dMonadZip_sg5Fh $dMonadZip1_sg5Fi;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sg5Fj
                                        sat_sg5Fk
                                        sat_sg5Fl
                                        sat_sg5Fm];

Data.Functor.Product.$fGeneric1Product_$cto1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Data.Functor.Product.Product f g) a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sg5Fn]
        case ds_sg5Fn of {
          GHC.Generics.:*: ds1_sg5Fp [Occ=Once] ds2_sg5Fq [Occ=Once] ->
              Data.Functor.Product.Pair [ds1_sg5Fp ds2_sg5Fq];
        };

Data.Functor.Product.$fGeneric1Product1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Product.Product f g a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Pair" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.Rec1 f)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.Rec1 g))
          a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_sg5Fr]
        case x_sg5Fr of {
          Data.Functor.Product.Pair g1_sg5Ft [Occ=Once]
                                    g2_sg5Fu [Occ=Once] ->
              GHC.Generics.:*: [g1_sg5Ft g2_sg5Fu];
        };

Data.Functor.Product.$fGeneric1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *).
     GHC.Generics.Generic1 (Data.Functor.Product.Product f g)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Functor.Product.$fGeneric1Product1
                                            Data.Functor.Product.$fGeneric1Product_$cto1];

Data.Functor.Product.$fGenericProduct_$cto
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Data.Functor.Product.Product f g a) x
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sg5Fv]
        case ds_sg5Fv of {
          GHC.Generics.:*: ds1_sg5Fx [Occ=Once] ds2_sg5Fy [Occ=Once] ->
              Data.Functor.Product.Pair [ds1_sg5Fx ds2_sg5Fy];
        };

Data.Functor.Product.$fGenericProduct1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     Data.Functor.Product.Product f g a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Pair" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R (f a))
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.K1 GHC.Generics.R (g a)))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x1_sg5Fz]
        case x1_sg5Fz of {
          Data.Functor.Product.Pair g1_sg5FB [Occ=Once]
                                    g2_sg5FC [Occ=Once] ->
              GHC.Generics.:*: [g1_sg5FB g2_sg5FC];
        };

Data.Functor.Product.$fGenericProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Generic (Data.Functor.Product.Product f g a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Product.$fGenericProduct1
                                           Data.Functor.Product.$fGenericProduct_$cto];

Data.Functor.Product.$fDataProduct_$cgfoldl
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g1. g1 -> c g1)
     -> Data.Functor.Product.Product f g a
     -> c (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg5FD
           $dTypeable1_sg5FE
           $dTypeable2_sg5FF
           $dTypeable3_sg5FG
           $dData_sg5FH
           $dData1_sg5FI
           k1_sg5FJ
           z_sg5FK
           ds_sg5FL]
        case ds_sg5FL of {
          Data.Functor.Product.Pair a1_sg5FN [Occ=Once]
                                    a2_sg5FO [Occ=Once] ->
              let {
                sat_sg5FQ [Occ=Once]
                  :: c_ag3Ll (g_ag3L6 a_ag3L7
                              -> Data.Functor.Product.Product f_ag3L5 g_ag3L6 a_ag3L7)
                [LclId] =
                    [$dData_sg5FH k1_sg5FJ z_sg5FK a1_sg5FN] \u []
                        let {
                          sat_sg5FP [Occ=Once]
                            :: c_ag3Ll (f_ag3L5 a_ag3L7
                                        -> g_ag3L6 a_ag3L7
                                        -> Data.Functor.Product.Product f_ag3L5 g_ag3L6 a_ag3L7)
                          [LclId] =
                              [z_sg5FK] \u [] z_sg5FK Data.Functor.Product.Pair;
                        } in  k1_sg5FJ $dData_sg5FH sat_sg5FP a1_sg5FN;
              } in  k1_sg5FJ $dData1_sg5FI sat_sg5FQ a2_sg5FO;
        };

Data.Functor.Product.$fDataProduct6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Product"#;

Data.Functor.Product.$fDataProduct5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Product.$fDataProduct6;

go61_rg5o2
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sg5FR _ys_sg5FS]
        case ds2_sg5FR of {
          [] -> GHC.List.badHead;
          : ipv_sg5FU [Occ=Once!] ipv1_sg5FV [Occ=Once] ->
              case _ys_sg5FS of {
                [] -> GHC.List.badHead;
                : ipv2_sg5FX [Occ=Once] ipv3_sg5FY [Occ=Once] ->
                    case ipv_sg5FU of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sg5G1 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case
                              GHC.Base.eqString ds4_sg5G1 Data.Functor.Product.$fRead1Product2
                          of
                          { GHC.Types.False -> go61_rg5o2 ipv1_sg5FV ipv3_sg5FY;
                            GHC.Types.True -> ipv2_sg5FX;
                          };
                    };
              };
        };

$cPair1_rg5o3 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cPair2_rg5o4];
Data.Functor.Product.$fDataProduct4 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Product.$cPair GHC.Types.[]];
Data.Functor.Product.$fDataProduct3 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Functor.Product.$fDataProduct4];
Data.Functor.Product.$tProduct :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Functor.Product.$fDataProduct5
                                       Data.Functor.Product.$fDataProduct3];
Data.Functor.Product.$cPair [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cPair1_rg5o3
                                     Data.Functor.Product.$fRead1Product2
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Functor.Product.$tProduct];
$cPair2_rg5o4 :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rg5o2 Data.Functor.Product.$fDataProduct4 Data.Data.mkConstr1;

Data.Functor.Product.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Product.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$trModule4];

Data.Functor.Product.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Product"#;

Data.Functor.Product.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$trModule2];

Data.Functor.Product.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Product.$trModule3
                                     Data.Functor.Product.$trModule1];

$krep_rg5o5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_rg5o6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rg5o5 GHC.Types.krep$*];

$krep2_rg5o7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rg5o6 $krep1_rg5o6];

Data.Functor.Product.$fDataProduct8 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rg5o6 $krep2_rg5o7];

$krep3_rg5o8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep4_rg5o9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_rg5oa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [3#];

$krep6_rg5ob :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rg5o9 $krep5_rg5oa];

$krep7_rg5oc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep3_rg5o8 $krep5_rg5oa];

Data.Functor.Product.$fDataProduct9 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$fDataProduct6];

Data.Functor.Product.$tcProduct :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9904636435990105341##
                                    16069493191308336164##
                                    Data.Functor.Product.$trModule
                                    Data.Functor.Product.$fDataProduct9
                                    1#
                                    Data.Functor.Product.$fDataProduct8];

$krep8_rg5od :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep5_rg5oa GHC.Types.[]];

$krep9_rg5oe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rg5o8 $krep8_rg5od];

$krep10_rg5of :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rg5o9 $krep9_rg5oe];

$krep11_rg5og :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rg5o5 $krep10_rg5of];

$krep12_rg5oh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Product.$tcProduct
                                              $krep11_rg5og];

$krep13_rg5oi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_rg5oc $krep12_rg5oh];

Data.Functor.Product.$tc'Pair1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rg5ob $krep13_rg5oi];

Data.Functor.Product.$tc'Pair3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Pair"#;

Data.Functor.Product.$tc'Pair2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$tc'Pair3];

Data.Functor.Product.$tc'Pair :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11374113252541295849##
                                    18011678063065699923##
                                    Data.Functor.Product.$trModule
                                    Data.Functor.Product.$tc'Pair2
                                    4#
                                    Data.Functor.Product.$tc'Pair1];

Data.Functor.Product.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Product.Product f g a)
[GblId, Arity=4, Str=<S,U><S,U><S,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sg5G6 w1_sg5G7 w2_sg5G8 w3_sg5G9]
        let {
          sat_sg5Ga [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w3_sg5G9]; } in
        let {
          sat_sg5Gb [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sg5Ga GHC.Types.[]];
        } in 
          case
              Data.Typeable.Internal.$wmkTrCon
                  9904636435990105341##
                  16069493191308336164##
                  Data.Functor.Product.$trModule
                  Data.Functor.Product.$fDataProduct9
                  1#
                  Data.Functor.Product.$fDataProduct8
                  sat_sg5Gb
          of
          { (#,,,,#) ww8_sg5Gd [Occ=Once]
                     ww9_sg5Ge [Occ=Once]
                     ww10_sg5Gf [Occ=Once]
                     ww11_sg5Gg [Occ=Once]
                     ww12_sg5Gh [Occ=Once] ->
                let {
                  sat_sg5Gi [Occ=Once]
                    :: Data.Typeable.Internal.TypeRep Data.Functor.Product.Product
                  [LclId] =
                      CCCS Data.Typeable.Internal.TrTyCon! [ww8_sg5Gd
                                                            ww9_sg5Ge
                                                            ww10_sg5Gf
                                                            ww11_sg5Gg
                                                            ww12_sg5Gh];
                } in 
                  case
                      Data.Typeable.Internal.mkTrApp sat_sg5Gi w1_sg5G7
                  of
                  sat_sg5Gj
                  { __DEFAULT ->
                        case
                            Data.Typeable.Internal.mkTrApp sat_sg5Gj w2_sg5G8
                        of
                        sat_sg5Gk
                        { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sg5Gk w_sg5G6;
                        };
                  };
          };

Data.Functor.Product.$fDataProduct7 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Product.Product f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sg5Gl w1_sg5Gm w2_sg5Gn w3_sg5Go w4_sg5Gp w5_sg5Gq]
        Data.Functor.Product.$w$cp1Data w_sg5Gl w1_sg5Gm w2_sg5Gn w3_sg5Go;

Data.Functor.Product.$fDataProduct1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (f a -> g a -> Data.Functor.Product.Product f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Product.Pair GHC.Types.False];

Data.Functor.Product.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5Gr w1_sg5Gs w2_sg5Gt w3_sg5Gu w4_sg5Gv]
        let {
          lvl9_sg5Gw [Occ=OnceL]
            :: m_sg4Xt (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm)
          [LclId] =
              [w2_sg5Gt] \u [] GHC.Base.mzero w2_sg5Gt;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sg5Gt
          of
          $dMonad_sg5Gx [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sg5H1 [Occ=Once]
                    :: (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm,
                        GHC.Types.Bool)
                       -> m_sg4Xt (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm)
                  [LclId] =
                      [lvl9_sg5Gw $dMonad_sg5Gx] \r [ds_sg5GW]
                          case ds_sg5GW of {
                            (,) x'_sg5GY [Occ=Once] b_sg5GZ [Occ=Once!] ->
                                case b_sg5GZ of {
                                  GHC.Types.False -> lvl9_sg5Gw;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sg5Gx x'_sg5GY;
                                };
                          }; } in
                let {
                  sat_sg5GV [Occ=Once]
                    :: m_sg4Xt (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sg5Gr w1_sg5Gs w2_sg5Gt w3_sg5Gu w4_sg5Gv $dMonad_sg5Gx] \u []
                          case w4_sg5Gv of {
                            Data.Functor.Product.Pair a1_sg5Gz [Occ=Once]
                                                      a2_sg5GA [Occ=Once] ->
                                let {
                                  k1_sg5GB [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_sg4Xt (d -> b)
                                       -> d -> m_sg4Xt (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [w2_sg5Gt w3_sg5Gu $dMonad_sg5Gx] \r [$dData1_sg5GC
                                                                                     ds_sg5GD
                                                                                     y_sg5GE]
                                          let {
                                            lvl10_sg5GF [Occ=OnceL] :: m_sg4Xt d_ae2Ws
                                            [LclId] =
                                                [w3_sg5Gu $dData1_sg5GC y_sg5GE] \u []
                                                    w3_sg5Gu $dData1_sg5GC y_sg5GE; } in
                                          let {
                                            sat_sg5GS [Occ=Once]
                                              :: (d_ae2Ws -> b_ae2Wt, GHC.Types.Bool)
                                                 -> m_sg4Xt (b_ae2Wt, GHC.Types.Bool)
                                            [LclId] =
                                                [w2_sg5Gt
                                                 $dMonad_sg5Gx
                                                 y_sg5GE
                                                 lvl10_sg5GF] \r [ds1_sg5GG]
                                                    case ds1_sg5GG of {
                                                      (,) h_sg5GI b1_sg5GJ [Occ=Once] ->
                                                          let {
                                                            sat_sg5GR [Occ=Once]
                                                              :: m_sg4Xt (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sg5Gx
                                                                 y_sg5GE
                                                                 h_sg5GI
                                                                 b1_sg5GJ] \u []
                                                                    let {
                                                                      sat_sg5GP [Occ=Once]
                                                                        :: b_ae2Wt
                                                                      [LclId] =
                                                                          [y_sg5GE h_sg5GI] \u []
                                                                              h_sg5GI y_sg5GE; } in
                                                                    let {
                                                                      sat_sg5GQ [Occ=Once]
                                                                        :: (b_ae2Wt, GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sg5GP
                                                                                     b1_sg5GJ];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sg5Gx
                                                                          sat_sg5GQ; } in
                                                          let {
                                                            sat_sg5GO [Occ=Once]
                                                              :: m_sg4Xt (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sg5Gx
                                                                 lvl10_sg5GF
                                                                 h_sg5GI] \u []
                                                                    let {
                                                                      sat_sg5GN [Occ=Once]
                                                                        :: d_ae2Ws
                                                                           -> m_sg4Xt (b_ae2Wt,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sg5Gx
                                                                           h_sg5GI] \r [y'_sg5GK]
                                                                              let {
                                                                                sat_sg5GL [Occ=Once]
                                                                                  :: b_ae2Wt
                                                                                [LclId] =
                                                                                    [h_sg5GI
                                                                                     y'_sg5GK] \u []
                                                                                        h_sg5GI
                                                                                            y'_sg5GK; } in
                                                                              let {
                                                                                sat_sg5GM [Occ=Once]
                                                                                  :: (b_ae2Wt,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sg5GL
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sg5Gx
                                                                                    sat_sg5GM;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sg5Gx
                                                                          lvl10_sg5GF
                                                                          sat_sg5GN;
                                                          } in 
                                                            GHC.Base.mplus
                                                                w2_sg5Gt sat_sg5GO sat_sg5GR;
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sg5Gx ds_sg5GD sat_sg5GS; } in
                                let {
                                  sat_sg5GU [Occ=Once]
                                    :: Data.Data.Mp
                                         m_sg4Xt
                                         (g_sg4Xl a_sg4Xm
                                          -> Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm)
                                  [LclId] =
                                      [w_sg5Gr $dMonad_sg5Gx a1_sg5Gz k1_sg5GB] \u []
                                          let {
                                            sat_sg5GT [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_sg4Xt
                                                   (f_sg4Xk a_sg4Xm
                                                    -> g_sg4Xl a_sg4Xm
                                                    -> Data.Functor.Product.Product
                                                         f_sg4Xk g_sg4Xl a_sg4Xm)
                                            [LclId] =
                                                [$dMonad_sg5Gx] \u []
                                                    GHC.Base.return
                                                        $dMonad_sg5Gx
                                                        Data.Functor.Product.$fDataProduct1;
                                          } in  k1_sg5GB w_sg5Gr sat_sg5GT a1_sg5Gz;
                                } in  k1_sg5GB w1_sg5Gs sat_sg5GU a2_sg5GA;
                          };
                } in  GHC.Base.>>= $dMonad_sg5Gx sat_sg5GV sat_sg5H1;
          };

Data.Functor.Product.$fDataProduct_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5H2
           w1_sg5H3
           w2_sg5H4
           w3_sg5H5
           w4_sg5H6
           w5_sg5H7
           w6_sg5H8
           w7_sg5H9
           w8_sg5Ha]
        Data.Functor.Product.$w$cgmapMp
            w4_sg5H6 w5_sg5H7 w6_sg5H8 w7_sg5H9 w8_sg5Ha;

Data.Functor.Product.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> f a -> g a -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5Hb w1_sg5Hc w2_sg5Hd w3_sg5He ww_sg5Hf ww1_sg5Hg]
        let {
          k1_sg5Hh [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
            :: forall d b.
               Data.Data.Data d =>
               m_sg4XN (d -> b) -> d -> m_sg4XN b
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w2_sg5Hd w3_sg5He] \r [$dData1_sg5Hi c_sg5Hj x_sg5Hk]
                  let {
                    lvl9_sg5Hl [Occ=OnceL] :: m_sg4XN d_ae2Vh
                    [LclId] =
                        [w3_sg5He $dData1_sg5Hi x_sg5Hk] \u []
                            w3_sg5He $dData1_sg5Hi x_sg5Hk; } in
                  let {
                    sat_sg5Hq [Occ=Once] :: (d_ae2Vh -> b_ae2Vi) -> m_sg4XN b_ae2Vi
                    [LclId] =
                        [w2_sg5Hd lvl9_sg5Hl] \r [c'_sg5Hm]
                            let {
                              sat_sg5Hp [Occ=Once] :: d_ae2Vh -> m_sg4XN b_ae2Vi
                              [LclId] =
                                  [w2_sg5Hd c'_sg5Hm] \r [x'_sg5Hn]
                                      let {
                                        sat_sg5Ho [Occ=Once] :: b_ae2Vi
                                        [LclId] =
                                            [c'_sg5Hm x'_sg5Hn] \u [] c'_sg5Hm x'_sg5Hn;
                                      } in  GHC.Base.return w2_sg5Hd sat_sg5Ho;
                            } in  GHC.Base.>>= w2_sg5Hd lvl9_sg5Hl sat_sg5Hp;
                  } in  GHC.Base.>>= w2_sg5Hd c_sg5Hj sat_sg5Hq; } in
        let {
          sat_sg5Hs [Occ=Once]
            :: m_sg4XN (g_sg4XF a_sg4XG
                        -> Data.Functor.Product.Product f_sg4XE g_sg4XF a_sg4XG)
          [LclId] =
              [w_sg5Hb w2_sg5Hd ww_sg5Hf k1_sg5Hh] \u []
                  let {
                    sat_sg5Hr [Occ=Once]
                      :: m_sg4XN (f_sg4XE a_sg4XG
                                  -> g_sg4XF a_sg4XG
                                  -> Data.Functor.Product.Product f_sg4XE g_sg4XF a_sg4XG)
                    [LclId] =
                        [w2_sg5Hd] \u []
                            GHC.Base.return w2_sg5Hd Data.Functor.Product.Pair;
                  } in  k1_sg5Hh w_sg5Hb sat_sg5Hr ww_sg5Hf;
        } in  k1_sg5Hh w1_sg5Hc sat_sg5Hs ww1_sg5Hg;

Data.Functor.Product.$fDataProduct_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5Ht
           w1_sg5Hu
           w2_sg5Hv
           w3_sg5Hw
           w4_sg5Hx
           w5_sg5Hy
           w6_sg5Hz
           w7_sg5HA
           w8_sg5HB]
        case w8_sg5HB of {
          Data.Functor.Product.Pair ww1_sg5HD [Occ=Once]
                                    ww2_sg5HE [Occ=Once] ->
              Data.Functor.Product.$w$cgmapM
                  w4_sg5Hx w5_sg5Hy w6_sg5Hz w7_sg5HA ww1_sg5HD ww2_sg5HE;
        };

Data.Functor.Product.$fDataProduct_$cgmapQi
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Functor.Product.Product f g a
     -> u
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg5HF
           $dTypeable1_sg5HG
           $dTypeable2_sg5HH
           $dTypeable3_sg5HI
           $dData_sg5HJ
           $dData1_sg5HK
           ds_sg5HL
           ds1_sg5HM
           x_sg5HN]
        case x_sg5HN of {
          Data.Functor.Product.Pair a1_sg5HP [Occ=Once]
                                    a2_sg5HQ [Occ=Once] ->
              case ds_sg5HL of {
                GHC.Types.I# x1_sg5HS [Occ=Once!] ->
                    case x1_sg5HS of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sg5HM $dData_sg5HJ a1_sg5HP;
                      1# -> ds1_sg5HM $dData1_sg5HK a2_sg5HQ;
                    };
              };
        };

Data.Functor.Product.$fDataProduct_$cgmapQr
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Product.Product f g a
     -> r
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg5HU
           $dTypeable1_sg5HV
           $dTypeable2_sg5HW
           $dTypeable3_sg5HX
           $dData_sg5HY
           $dData1_sg5HZ
           ds_sg5I0
           ds1_sg5I1
           ds2_sg5I2
           x0_sg5I3]
        case x0_sg5I3 of {
          Data.Functor.Product.Pair a1_sg5I5 [Occ=Once]
                                    a2_sg5I6 [Occ=Once] ->
              let {
                sat_sg5I9 [Occ=Once] :: r_ag3N9
                [LclId] =
                    [$dData1_sg5HZ ds_sg5I0 ds1_sg5I1 ds2_sg5I2 a2_sg5I6] \u []
                        let {
                          sat_sg5I8 [Occ=Once] :: r'_ag3Na
                          [LclId] =
                              [$dData1_sg5HZ ds2_sg5I2 a2_sg5I6] \u []
                                  ds2_sg5I2 $dData1_sg5HZ a2_sg5I6;
                        } in  ds_sg5I0 sat_sg5I8 ds1_sg5I1; } in
              let {
                sat_sg5I7 [Occ=Once] :: r'_ag3Na
                [LclId] =
                    [$dData_sg5HY ds2_sg5I2 a1_sg5I5] \u []
                        ds2_sg5I2 $dData_sg5HY a1_sg5I5;
              } in  ds_sg5I0 sat_sg5I7 sat_sg5I9;
        };

Data.Functor.Product.$fDataProduct2
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Const.Const r (Data.Functor.Product.Product f g a)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg5Ia
           $dTypeable1_sg5Ib
           $dTypeable2_sg5Ic
           $dTypeable3_sg5Id
           $dData_sg5Ie
           $dData1_sg5If
           ds_sg5Ig
           ds1_sg5Ih
           ds2_sg5Ii
           eta_sg5Ij]
        case eta_sg5Ij of {
          Data.Functor.Product.Pair a1_sg5Il [Occ=Once]
                                    a2_sg5Im [Occ=Once] ->
              let {
                sat_sg5Ip [Occ=Once] :: r'_ag3MT
                [LclId] =
                    [$dData1_sg5If ds2_sg5Ii a2_sg5Im] \u []
                        ds2_sg5Ii $dData1_sg5If a2_sg5Im; } in
              let {
                sat_sg5Io [Occ=Once] :: r_ag3MS
                [LclId] =
                    [$dData_sg5Ie ds_sg5Ig ds1_sg5Ih ds2_sg5Ii a1_sg5Il] \u []
                        let {
                          sat_sg5In [Occ=Once] :: r'_ag3MT
                          [LclId] =
                              [$dData_sg5Ie ds2_sg5Ii a1_sg5Il] \u []
                                  ds2_sg5Ii $dData_sg5Ie a1_sg5Il;
                        } in  ds_sg5Ig ds1_sg5Ih sat_sg5In;
              } in  ds_sg5Ig sat_sg5Io sat_sg5Ip;
        };

Data.Functor.Product.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5Iq w1_sg5Ir w2_sg5Is w3_sg5It w4_sg5Iu]
        let {
          lvl9_sg5Iv [Occ=OnceL]
            :: m_sg4Yc (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
          [LclId] =
              [w2_sg5Is] \u [] GHC.Base.mzero w2_sg5Is;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sg5Is
          of
          $dMonad_sg5Iw [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sg5J3 [Occ=Once]
                    :: (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5,
                        GHC.Types.Bool)
                       -> m_sg4Yc (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
                  [LclId] =
                      [lvl9_sg5Iv $dMonad_sg5Iw] \r [ds_sg5IY]
                          case ds_sg5IY of {
                            (,) x'_sg5J0 [Occ=Once] b_sg5J1 [Occ=Once!] ->
                                case b_sg5J1 of {
                                  GHC.Types.False -> lvl9_sg5Iv;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sg5Iw x'_sg5J0;
                                };
                          }; } in
                let {
                  sat_sg5IX [Occ=Once]
                    :: m_sg4Yc (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sg5Iq w1_sg5Ir w2_sg5Is w3_sg5It w4_sg5Iu $dMonad_sg5Iw] \u []
                          case w4_sg5Iu of {
                            Data.Functor.Product.Pair a1_sg5Iy [Occ=Once]
                                                      a2_sg5Iz [Occ=Once] ->
                                let {
                                  k1_sg5IA [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_sg4Yc (d -> b)
                                       -> d -> m_sg4Yc (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [w2_sg5Is w3_sg5It $dMonad_sg5Iw] \r [$dData1_sg5IB
                                                                                     ds_sg5IC
                                                                                     y_sg5ID]
                                          let {
                                            lvl10_sg5IE [Occ=OnceL] :: m_sg4Yc d_ae2Ya
                                            [LclId] =
                                                [w3_sg5It $dData1_sg5IB y_sg5ID] \u []
                                                    w3_sg5It $dData1_sg5IB y_sg5ID; } in
                                          let {
                                            sat_sg5IU [Occ=Once]
                                              :: (d_ae2Ya -> b_ae2Yb, GHC.Types.Bool)
                                                 -> m_sg4Yc (b_ae2Yb, GHC.Types.Bool)
                                            [LclId] =
                                                [w2_sg5Is
                                                 $dMonad_sg5Iw
                                                 y_sg5ID
                                                 lvl10_sg5IE] \r [ds1_sg5IF]
                                                    case ds1_sg5IF of {
                                                      (,) h_sg5IH b1_sg5II [Occ=Once!] ->
                                                          case b1_sg5II of {
                                                            GHC.Types.False ->
                                                                let {
                                                                  sat_sg5IR [Occ=Once]
                                                                    :: m_sg4Yc (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sg5Iw
                                                                       y_sg5ID
                                                                       h_sg5IH] \u []
                                                                          let {
                                                                            sat_sg5IP [Occ=Once]
                                                                              :: b_ae2Yb
                                                                            [LclId] =
                                                                                [y_sg5ID
                                                                                 h_sg5IH] \u []
                                                                                    h_sg5IH
                                                                                        y_sg5ID; } in
                                                                          let {
                                                                            sat_sg5IQ [Occ=Once]
                                                                              :: (b_ae2Yb,
                                                                                  GHC.Types.Bool)
                                                                            [LclId] =
                                                                                CCCS (,)! [sat_sg5IP
                                                                                           GHC.Types.False];
                                                                          } in 
                                                                            GHC.Base.return
                                                                                $dMonad_sg5Iw
                                                                                sat_sg5IQ; } in
                                                                let {
                                                                  sat_sg5IO [Occ=Once]
                                                                    :: m_sg4Yc (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sg5Iw
                                                                       lvl10_sg5IE
                                                                       h_sg5IH] \u []
                                                                          let {
                                                                            sat_sg5IN [Occ=Once]
                                                                              :: d_ae2Ya
                                                                                 -> m_sg4Yc (b_ae2Yb,
                                                                                             GHC.Types.Bool)
                                                                            [LclId] =
                                                                                [$dMonad_sg5Iw
                                                                                 h_sg5IH] \r [y'_sg5IK]
                                                                                    let {
                                                                                      sat_sg5IL [Occ=Once]
                                                                                        :: b_ae2Yb
                                                                                      [LclId] =
                                                                                          [h_sg5IH
                                                                                           y'_sg5IK] \u []
                                                                                              h_sg5IH
                                                                                                  y'_sg5IK; } in
                                                                                    let {
                                                                                      sat_sg5IM [Occ=Once]
                                                                                        :: (b_ae2Yb,
                                                                                            GHC.Types.Bool)
                                                                                      [LclId] =
                                                                                          CCCS (,)! [sat_sg5IL
                                                                                                     GHC.Types.True];
                                                                                    } in 
                                                                                      GHC.Base.return
                                                                                          $dMonad_sg5Iw
                                                                                          sat_sg5IM;
                                                                          } in 
                                                                            GHC.Base.>>=
                                                                                $dMonad_sg5Iw
                                                                                lvl10_sg5IE
                                                                                sat_sg5IN;
                                                                } in 
                                                                  GHC.Base.mplus
                                                                      w2_sg5Is sat_sg5IO sat_sg5IR;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_sg5IS [Occ=Once] :: b_ae2Yb
                                                                  [LclId] =
                                                                      [y_sg5ID h_sg5IH] \u []
                                                                          h_sg5IH y_sg5ID; } in
                                                                let {
                                                                  sat_sg5IT [Occ=Once]
                                                                    :: (b_ae2Yb, GHC.Types.Bool)
                                                                  [LclId] =
                                                                      CCCS (,)! [sat_sg5IS
                                                                                 GHC.Types.True];
                                                                } in 
                                                                  GHC.Base.return
                                                                      $dMonad_sg5Iw sat_sg5IT;
                                                          };
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sg5Iw ds_sg5IC sat_sg5IU; } in
                                let {
                                  sat_sg5IW [Occ=Once]
                                    :: Data.Data.Mp
                                         m_sg4Yc
                                         (g_sg4Y4 a_sg4Y5
                                          -> Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
                                  [LclId] =
                                      [w_sg5Iq $dMonad_sg5Iw a1_sg5Iy k1_sg5IA] \u []
                                          let {
                                            sat_sg5IV [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_sg4Yc
                                                   (f_sg4Y3 a_sg4Y5
                                                    -> g_sg4Y4 a_sg4Y5
                                                    -> Data.Functor.Product.Product
                                                         f_sg4Y3 g_sg4Y4 a_sg4Y5)
                                            [LclId] =
                                                [$dMonad_sg5Iw] \u []
                                                    GHC.Base.return
                                                        $dMonad_sg5Iw
                                                        Data.Functor.Product.$fDataProduct1;
                                          } in  k1_sg5IA w_sg5Iq sat_sg5IV a1_sg5Iy;
                                } in  k1_sg5IA w1_sg5Ir sat_sg5IW a2_sg5Iz;
                          };
                } in  GHC.Base.>>= $dMonad_sg5Iw sat_sg5IX sat_sg5J3;
          };

Data.Functor.Product.$fDataProduct_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5J4
           w1_sg5J5
           w2_sg5J6
           w3_sg5J7
           w4_sg5J8
           w5_sg5J9
           w6_sg5Ja
           w7_sg5Jb
           w8_sg5Jc]
        Data.Functor.Product.$w$cgmapMo
            w4_sg5J8 w5_sg5J9 w6_sg5Ja w7_sg5Jb w8_sg5Jc;

lvl5_rg5oj
  :: forall k (g :: k -> *) (a :: k) (f :: k -> *).
     Data.Functor.Product.Product f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_sg5Jd]
        case ds_sg5Jd of {
          Data.Functor.Product.Pair _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Functor.Product.$cPair;
        };

lvl6_rg5ok
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Product.Product f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sg5Jh] Data.Functor.Product.$tProduct;

lvl7_rg5ol
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Functor.Product.Product f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sg5Ji ds_sg5Jj] GHC.Base.Nothing [];

lvl8_rg5om
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Functor.Product.Product f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sg5Jk ds_sg5Jl] GHC.Base.Nothing [];

Data.Functor.Product.$fDataProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Data.Data (Data.Functor.Product.Product f g a)
[GblId[DFunId], Arity=6, Str=<L,U><L,U><L,U><L,U><L,U><L,U>] =
    [] \r [$dTypeable_sg5Jm
           $dTypeable1_sg5Jn
           $dTypeable2_sg5Jo
           $dTypeable3_sg5Jp
           $dData_sg5Jq
           $dData1_sg5Jr]
        let {
          sat_sg5K2 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> m (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dData_sg5Jq $dData1_sg5Jr] \r [w_sg5JZ w1_sg5K0 w2_sg5K1]
                  Data.Functor.Product.$w$cgmapMo
                      $dData_sg5Jq $dData1_sg5Jr w_sg5JZ w1_sg5K0 w2_sg5K1; } in
        let {
          sat_sg5JY [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> m (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dData_sg5Jq $dData1_sg5Jr] \r [w_sg5JV w1_sg5JW w2_sg5JX]
                  Data.Functor.Product.$w$cgmapMp
                      $dData_sg5Jq $dData1_sg5Jr w_sg5JV w1_sg5JW w2_sg5JX; } in
        let {
          sat_sg5JU [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> m (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dTypeable_sg5Jm
               $dTypeable1_sg5Jn
               $dTypeable2_sg5Jo
               $dTypeable3_sg5Jp
               $dData_sg5Jq
               $dData1_sg5Jr] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgmapM
                      $dTypeable_sg5Jm
                      $dTypeable1_sg5Jn
                      $dTypeable2_sg5Jo
                      $dTypeable3_sg5Jp
                      $dData_sg5Jq
                      $dData1_sg5Jr
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg5JT [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> u
          [LclId] =
              [$dTypeable_sg5Jm
               $dTypeable1_sg5Jn
               $dTypeable2_sg5Jo
               $dTypeable3_sg5Jp
               $dData_sg5Jq
               $dData1_sg5Jr] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgmapQi
                      $dTypeable_sg5Jm
                      $dTypeable1_sg5Jn
                      $dTypeable2_sg5Jo
                      $dTypeable3_sg5Jp
                      $dData_sg5Jq
                      $dData1_sg5Jr
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg5JS [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7 -> [u]
          [LclId] =
              [$dData_sg5Jq $dData1_sg5Jr] \r [ds_sg5JK x0_sg5JL]
                  case x0_sg5JL of {
                    Data.Functor.Product.Pair a1_sg5JN [Occ=Once]
                                              a2_sg5JO [Occ=Once] ->
                        let {
                          sat_sg5JQ [Occ=Once] :: u_ag3Nq
                          [LclId] =
                              [$dData1_sg5Jr ds_sg5JK a2_sg5JO] \u []
                                  ds_sg5JK $dData1_sg5Jr a2_sg5JO; } in
                        let {
                          sat_sg5JR [Occ=Once] :: [u_ag3Nq]
                          [LclId] =
                              CCCS :! [sat_sg5JQ GHC.Types.[]]; } in
                        let {
                          sat_sg5JP [Occ=Once] :: u_ag3Nq
                          [LclId] =
                              [$dData_sg5Jq ds_sg5JK a1_sg5JN] \u []
                                  ds_sg5JK $dData_sg5Jq a1_sg5JN;
                        } in  : [sat_sg5JP sat_sg5JR];
                  }; } in
        let {
          sat_sg5JJ [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> r
          [LclId] =
              [$dTypeable_sg5Jm
               $dTypeable1_sg5Jn
               $dTypeable2_sg5Jo
               $dTypeable3_sg5Jp
               $dData_sg5Jq
               $dData1_sg5Jr] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgmapQr
                      $dTypeable_sg5Jm
                      $dTypeable1_sg5Jn
                      $dTypeable2_sg5Jo
                      $dTypeable3_sg5Jp
                      $dData_sg5Jq
                      $dData1_sg5Jr
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg5JI [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> r
          [LclId] =
              [$dTypeable_sg5Jm
               $dTypeable1_sg5Jn
               $dTypeable2_sg5Jo
               $dTypeable3_sg5Jp
               $dData_sg5Jq
               $dData1_sg5Jr] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct2
                      $dTypeable_sg5Jm
                      $dTypeable1_sg5Jn
                      $dTypeable2_sg5Jo
                      $dTypeable3_sg5Jp
                      $dData_sg5Jq
                      $dData1_sg5Jr
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg5JH [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
          [LclId] =
              [$dData_sg5Jq $dData1_sg5Jr] \r [ds_sg5JA x0_sg5JB]
                  case x0_sg5JB of {
                    Data.Functor.Product.Pair a1_sg5JD [Occ=Once]
                                              a2_sg5JE [Occ=Once] ->
                        let {
                          sat_sg5JG [Occ=Once] :: g_Xg3V4 a_Xg3V7
                          [LclId] =
                              [$dData1_sg5Jr ds_sg5JA a2_sg5JE] \u []
                                  ds_sg5JA $dData1_sg5Jr a2_sg5JE; } in
                        let {
                          sat_sg5JF [Occ=Once] :: f_Xg3PP a_Xg3V7
                          [LclId] =
                              [$dData_sg5Jq ds_sg5JA a1_sg5JD] \u []
                                  ds_sg5JA $dData_sg5Jq a1_sg5JD;
                        } in  Data.Functor.Product.Pair [sat_sg5JF sat_sg5JG];
                  }; } in
        let {
          sat_sg5Jz [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dData_sg5Jq $dData1_sg5Jr] \r [k1_sg5Ju z_sg5Jv ds_sg5Jw]
                  let {
                    sat_sg5Jy [Occ=Once]
                      :: c_ag3LC (g_Xg3V4 a_Xg3V7
                                  -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
                    [LclId] =
                        [$dData_sg5Jq k1_sg5Ju z_sg5Jv] \u []
                            let {
                              sat_sg5Jx [Occ=Once]
                                :: c_ag3LC (f_Xg3PP a_Xg3V7
                                            -> g_Xg3V4 a_Xg3V7
                                            -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
                              [LclId] =
                                  [z_sg5Jv] \u [] z_sg5Jv Data.Functor.Product.Pair;
                            } in  k1_sg5Ju $dData_sg5Jq sat_sg5Jx;
                  } in  k1_sg5Ju $dData1_sg5Jr sat_sg5Jy; } in
        let {
          sat_sg5Jt [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> c (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dTypeable_sg5Jm
               $dTypeable1_sg5Jn
               $dTypeable2_sg5Jo
               $dTypeable3_sg5Jp
               $dData_sg5Jq
               $dData1_sg5Jr] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgfoldl
                      $dTypeable_sg5Jm
                      $dTypeable1_sg5Jn
                      $dTypeable2_sg5Jo
                      $dTypeable3_sg5Jp
                      $dData_sg5Jq
                      $dData1_sg5Jr
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg5Js [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dTypeable_sg5Jm
               $dTypeable1_sg5Jn
               $dTypeable2_sg5Jo
               $dTypeable3_sg5Jp] \u []
                  Data.Functor.Product.$w$cp1Data
                      $dTypeable_sg5Jm
                      $dTypeable1_sg5Jn
                      $dTypeable2_sg5Jo
                      $dTypeable3_sg5Jp;
        } in 
          Data.Data.C:Data [sat_sg5Js
                            sat_sg5Jt
                            sat_sg5Jz
                            lvl5_rg5oj
                            lvl6_rg5ok
                            lvl7_rg5ol
                            lvl8_rg5om
                            sat_sg5JH
                            sat_sg5JI
                            sat_sg5JJ
                            sat_sg5JS
                            sat_sg5JT
                            sat_sg5JU
                            sat_sg5JY
                            sat_sg5K2];

Data.Functor.Product.Pair
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     f a -> g a -> Data.Functor.Product.Product f g a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Product.Pair [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:11:54.81502472 UTC

Data.Functor.Product.$fEq1Product_$cliftEq
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sg5oo $dEq2_sg5op eq_sg5oq ds_sg5or ds1_sg5os]
        case ds_sg5or of {
          Data.Functor.Product.Pair x1_sg5ou [Occ=Once]
                                    y1_sg5ov [Occ=Once] ->
              case ds1_sg5os of {
                Data.Functor.Product.Pair x2_sg5ox [Occ=Once]
                                          y2_sg5oy [Occ=Once] ->
                    case $dEq1_sg5oo eq_sg5oq x1_sg5ou x2_sg5ox of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> $dEq2_sg5op eq_sg5oq y1_sg5ov y2_sg5oy;
                    };
              };
        };

Data.Functor.Product.$fEq1Product [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     Data.Functor.Classes.Eq1 (Data.Functor.Product.Product f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Product.$fEq1Product_$cliftEq
            eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Product.$w$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> f a -> g a -> f b -> g b -> GHC.Types.Ordering
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5oA
           w1_sg5oB
           w2_sg5oC
           ww_sg5oD
           ww1_sg5oE
           ww2_sg5oF
           ww3_sg5oG]
        case
            Data.Functor.Classes.liftCompare
                w_sg5oA w2_sg5oC ww_sg5oD ww2_sg5oF
        of
        { GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ ->
              Data.Functor.Classes.liftCompare
                  w1_sg5oB w2_sg5oC ww1_sg5oE ww3_sg5oG;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Product.$fOrd1Product_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5oI w1_sg5oJ w2_sg5oK w3_sg5oL w4_sg5oM]
        case w3_sg5oL of {
          Data.Functor.Product.Pair ww1_sg5oO [Occ=Once]
                                    ww2_sg5oP [Occ=Once] ->
              case w4_sg5oM of {
                Data.Functor.Product.Pair ww4_sg5oR [Occ=Once]
                                          ww5_sg5oS [Occ=Once] ->
                    Data.Functor.Product.$w$cliftCompare
                        w_sg5oI w1_sg5oJ w2_sg5oK ww1_sg5oO ww2_sg5oP ww4_sg5oR ww5_sg5oS;
              };
        };

Data.Functor.Product.$w$cp1Ord1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> f a -> g a -> f b -> g b -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5oT
           w1_sg5oU
           w2_sg5oV
           ww_sg5oW
           ww1_sg5oX
           ww2_sg5oY
           ww3_sg5oZ]
        case
            Data.Functor.Classes.$p1Ord1 w_sg5oT w2_sg5oV ww_sg5oW ww2_sg5oY
        of
        { GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True ->
              Data.Functor.Classes.$p1Ord1 w1_sg5oU w2_sg5oV ww1_sg5oX ww3_sg5oZ;
        };

Data.Functor.Product.$fOrd1Product1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5p1 w1_sg5p2 w2_sg5p3 w3_sg5p4 w4_sg5p5]
        case w3_sg5p4 of {
          Data.Functor.Product.Pair ww1_sg5p7 [Occ=Once]
                                    ww2_sg5p8 [Occ=Once] ->
              case w4_sg5p5 of {
                Data.Functor.Product.Pair ww4_sg5pa [Occ=Once]
                                          ww5_sg5pb [Occ=Once] ->
                    Data.Functor.Product.$w$cp1Ord1
                        w_sg5p1 w1_sg5p2 w2_sg5p3 ww1_sg5p7 ww2_sg5p8 ww4_sg5pa ww5_sg5pb;
              };
        };

Data.Functor.Product.$fOrd1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     Data.Functor.Classes.Ord1 (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(C1(C1(U))),C(C1(C1(U))))>m] =
    [] \r [$dOrd1_sg5pc $dOrd2_sg5pd]
        let {
          sat_sg5pf [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Product.Product f_Xg499 g_Xg49b a
               -> Data.Functor.Product.Product f_Xg499 g_Xg49b b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sg5pc $dOrd2_sg5pd] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fOrd1Product_$cliftCompare
                      $dOrd1_sg5pc $dOrd2_sg5pd eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5pe [Occ=Once]
            :: Data.Functor.Classes.Eq1
                 (Data.Functor.Product.Product f_Xg499 g_Xg49b)
          [LclId] =
              [$dOrd1_sg5pc $dOrd2_sg5pd] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fOrd1Product1
                      $dOrd1_sg5pc $dOrd2_sg5pd eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sg5pe sat_sg5pf];

Data.Functor.Product.$fRead1Product3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Pair"#;

Data.Functor.Product.$fRead1Product2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Product.$fRead1Product3;

Data.Functor.Product.$fRead1Product1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Product.$fRead1Product2];

Data.Functor.Product.$fRead1Product_lvl3
  :: Text.ParserCombinators.ReadPrec.Prec
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Product.$fRead1Product_$cliftReadPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5pg $dRead2_sg5ph rp_sg5pi rl_sg5pj]
        let {
          reader_sg5pk [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_ag45N a_ag46b)
          [LclId] =
              [$dRead1_sg5pg rp_sg5pi rl_sg5pj] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead1_sg5pg rp_sg5pi rl_sg5pj; } in
        let {
          reader1_sg5pl [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (g_ag45O a_ag46b)
          [LclId] =
              [$dRead2_sg5ph rp_sg5pi rl_sg5pj] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead2_sg5ph rp_sg5pi rl_sg5pj; } in
        let {
          $wlvl_sg5pm [InlPrag=NOUSERINLINE[0], Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: GHC.Prim.Int#
               -> forall b.
                  (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46b
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [reader_sg5pk reader1_sg5pl] \r [ww_sg5pn w_sg5po]
                  case <=# [ww_sg5pn 10#] of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                    1# ->
                        let {
                          sat_sg5pw [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_sg4P0
                          [LclId] =
                              [reader_sg5pk reader1_sg5pl w_sg5po] \r [a1_sg5pq]
                                  let {
                                    sat_sg5pv [Occ=Once]
                                      :: f_ag45N a_ag46b -> Text.ParserCombinators.ReadP.P b_sg4P0
                                    [LclId] =
                                        [reader1_sg5pl w_sg5po] \r [a2_sg5pr]
                                            let {
                                              sat_sg5pu [Occ=Once]
                                                :: g_ag45O a_ag46b
                                                   -> Text.ParserCombinators.ReadP.P b_sg4P0
                                              [LclId] =
                                                  [w_sg5po a2_sg5pr] \r [a3_sg5ps]
                                                      let {
                                                        sat_sg5pt [Occ=Once]
                                                          :: Data.Functor.Product.Product
                                                               f_ag45N g_ag45O a_ag46b
                                                        [LclId] =
                                                            CCCS Data.Functor.Product.Pair! [a2_sg5pr
                                                                                             a3_sg5ps];
                                                      } in  w_sg5po sat_sg5pt;
                                            } in 
                                              reader1_sg5pl
                                                  Data.Functor.Product.$fRead1Product_lvl3
                                                  sat_sg5pu;
                                  } in 
                                    reader_sg5pk Data.Functor.Product.$fRead1Product_lvl3 sat_sg5pv;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Functor.Product.$fRead1Product1 sat_sg5pw
                          of
                          { Unit# ww2_sg5py [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_sg5py];
                          };
                  }; } in
        let {
          lvl9_sg5pz [InlPrag=NOUSERINLINE[0], Occ=OnceL, Dmd=<L,C(C(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46b
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
              [$wlvl_sg5pm] \r [w_sg5pA w1_sg5pB]
                  case w_sg5pA of {
                    GHC.Types.I# ww1_sg5pD [Occ=Once] ->
                        $wlvl_sg5pm ww1_sg5pD w1_sg5pB;
                  }; } in
        let {
          sat_sg5pG [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46b
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [lvl9_sg5pz] \r [eta_sg5pE eta1_sg5pF]
                  GHC.Read.list3 lvl9_sg5pz eta_sg5pE eta1_sg5pF;
        } in  sat_sg5pG;

Data.Functor.Product.$fRead1Product_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5pH $dRead2_sg5pI rp_sg5pJ rl_sg5pK]
        let {
          ds_sg5pL [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag45N g_ag45O a_ag45U)
          [LclId] =
              [$dRead1_sg5pH $dRead2_sg5pI rp_sg5pJ rl_sg5pK] \u []
                  let {
                    sat_sg5pR [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag45U]
                    [LclId] =
                        [rl_sg5pK] \r [n_sg5pN w1_sg5pO]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sg5pK w1_sg5pO
                            of
                            { Unit# ww1_sg5pQ [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sg5pQ];
                            }; } in
                  let {
                    sat_sg5pM [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag45U
                    [LclId] =
                        [rp_sg5pJ] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sg5pJ eta_B1;
                  } in 
                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                        $dRead1_sg5pH $dRead2_sg5pI sat_sg5pM sat_sg5pR; } in
        let {
          sat_sg5pU [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag45N g_ag45O a_ag45U)
          [LclId] =
              [ds_sg5pL] \r [n_sg5pS]
                  let {
                    sat_sg5pT [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Product.Product f_ag45N g_ag45O a_ag45U)
                    [LclId] =
                        [ds_sg5pL n_sg5pS] \u []
                            ds_sg5pL
                                n_sg5pS Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sg5pT;
        } in  sat_sg5pU;

Data.Functor.Product.$fRead1Product_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Product.Product f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5pV $dRead2_sg5pW rp_sg5pX rl_sg5pY]
        let {
          sat_sg5pZ [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46x)
          [LclId] =
              [$dRead1_sg5pV $dRead2_sg5pW rp_sg5pX rl_sg5pY] \s []
                  Data.Functor.Product.$fRead1Product_$cliftReadPrec
                      $dRead1_sg5pV $dRead2_sg5pW rp_sg5pX rl_sg5pY;
        } in  GHC.Read.list sat_sg5pZ;

Data.Functor.Product.$fRead1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     Data.Functor.Classes.Read1 (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>m] =
    [] \r [$dRead1_sg5q0 $dRead2_sg5q1]
        let {
          sat_sg5q5 [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Product.Product f_ag45N g_ag45O a]
          [LclId] =
              [$dRead1_sg5q0 $dRead2_sg5q1] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fRead1Product_$cliftReadListPrec
                      $dRead1_sg5q0 $dRead2_sg5q1 eta_B2 eta_B1; } in
        let {
          sat_sg5q4 [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Product.Product f_ag45N g_ag45O a)
          [LclId] =
              [$dRead1_sg5q0 $dRead2_sg5q1] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fRead1Product_$cliftReadPrec
                      $dRead1_sg5q0 $dRead2_sg5q1 eta_B2 eta_B1; } in
        let {
          sat_sg5q3 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Product.Product f_ag45N g_ag45O a]
          [LclId] =
              [$dRead1_sg5q0 $dRead2_sg5q1] \u []
                  Data.Functor.Product.$fRead1Product_$cliftReadList
                      $dRead1_sg5q0 $dRead2_sg5q1; } in
        let {
          sat_sg5q2 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag45N g_ag45O a)
          [LclId] =
              [$dRead1_sg5q0 $dRead2_sg5q1] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fRead1Product_$cliftReadsPrec
                      $dRead1_sg5q0 $dRead2_sg5q1 eta_B2 eta_B1;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sg5q2
                                        sat_sg5q3
                                        sat_sg5q4
                                        sat_sg5q5];
Data.Functor.Product.$fRead1Product_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Product.Product f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5q6 $dRead2_sg5q7]
        let {
          sat_sg5q8 [Occ=Once]
            :: Data.Functor.Classes.Read1
                 (Data.Functor.Product.Product f_ag45N g_ag45O)
          [LclId] =
              [$dRead1_sg5q6 $dRead2_sg5q7] \u []
                  Data.Functor.Product.$fRead1Product $dRead1_sg5q6 $dRead2_sg5q7;
        } in  Data.Functor.Classes.liftReadListDefault sat_sg5q8;

Data.Functor.Product.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> f a
     -> g a
     -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5q9
           w1_sg5qa
           w2_sg5qb
           w3_sg5qc
           ww_sg5qd
           ww1_sg5qe
           ww2_sg5qf]
        let {
          sat_sg5qh [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> g_sg4Pq a_sg4Pt -> GHC.Show.ShowS
          [LclId] =
              [w1_sg5qa w2_sg5qb w3_sg5qc] \s []
                  Data.Functor.Classes.liftShowsPrec w1_sg5qa w2_sg5qb w3_sg5qc; } in
        let {
          sat_sg5qg [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> f_sg4Pp a_sg4Pt -> GHC.Show.ShowS
          [LclId] =
              [w_sg5q9 w2_sg5qb w3_sg5qc] \s []
                  Data.Functor.Classes.liftShowsPrec w_sg5q9 w2_sg5qb w3_sg5qc;
        } in 
          Data.Functor.Classes.$wshowsBinaryWith
              sat_sg5qg
              sat_sg5qh
              Data.Functor.Product.$fRead1Product2
              ww_sg5qd
              ww1_sg5qe
              ww2_sg5qf;

Data.Functor.Product.$fShow1Product_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Product.Product f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5qi w1_sg5qj w2_sg5qk w3_sg5ql w4_sg5qm w5_sg5qn]
        case w4_sg5qm of {
          GHC.Types.I# ww1_sg5qp [Occ=Once] ->
              case w5_sg5qn of {
                Data.Functor.Product.Pair ww3_sg5qr [Occ=Once]
                                          ww4_sg5qs [Occ=Once] ->
                    Data.Functor.Product.$w$cliftShowsPrec
                        w_sg5qi w1_sg5qj w2_sg5qk w3_sg5ql ww1_sg5qp ww3_sg5qr ww4_sg5qs;
              };
        };

Data.Functor.Product.$fFoldableProduct4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Product.$fShow1Product_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Product.Product f g a]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U><L,U><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sg5qt
           $dShow2_sg5qu
           sp_sg5qv
           sl_sg5qw
           eta_sg5qx
           eta1_sg5qy]
        let {
          sat_sg5qD [Occ=Once]
            :: Data.Functor.Product.Product f_ag45l g_ag45m a_ag45G
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg5qt $dShow2_sg5qu sp_sg5qv sl_sg5qw] \r [w_sg5qz]
                  case w_sg5qz of {
                    Data.Functor.Product.Pair ww1_sg5qB [Occ=Once]
                                              ww2_sg5qC [Occ=Once] ->
                        Data.Functor.Product.$w$cliftShowsPrec
                            $dShow1_sg5qt
                            $dShow2_sg5qu
                            sp_sg5qv
                            sl_sg5qw
                            0#
                            ww1_sg5qB
                            ww2_sg5qC;
                  };
        } in  GHC.Show.showList__ sat_sg5qD eta_sg5qx eta1_sg5qy;

Data.Functor.Product.$fShow1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     Data.Functor.Classes.Show1 (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)>m] =
    [] \r [$dShow1_sg5qE $dShow2_sg5qF]
        let {
          sat_sg5qH [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Product.Product f_ag45l g_ag45m a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg5qE $dShow2_sg5qF] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fShow1Product_$cliftShowList
                      $dShow1_sg5qE $dShow2_sg5qF eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5qG [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Product.Product f_ag45l g_ag45m a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg5qE $dShow2_sg5qF] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fShow1Product_$cliftShowsPrec
                      $dShow1_sg5qE $dShow2_sg5qF eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sg5qG sat_sg5qH];

Data.Functor.Product.$w$c== [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5qI
           w1_sg5qJ
           w2_sg5qK
           ww_sg5qL
           ww1_sg5qM
           ww2_sg5qN
           ww3_sg5qO]
        let {
          eq_sg5qP :: a_sg4PK -> a_sg4PK -> GHC.Types.Bool
          [LclId] =
              [w2_sg5qK] \u [] GHC.Classes.== w2_sg5qK;
        } in 
          case w_sg5qI eq_sg5qP ww_sg5qL ww2_sg5qN of {
            GHC.Types.False -> GHC.Types.False [];
            GHC.Types.True -> w1_sg5qJ eq_sg5qP ww1_sg5qM ww3_sg5qO;
          };

Data.Functor.Product.$fEqProduct_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5qR w1_sg5qS w2_sg5qT w3_sg5qU w4_sg5qV]
        case w3_sg5qU of {
          Data.Functor.Product.Pair ww1_sg5qX [Occ=Once]
                                    ww2_sg5qY [Occ=Once] ->
              case w4_sg5qV of {
                Data.Functor.Product.Pair ww4_sg5r0 [Occ=Once]
                                          ww5_sg5r1 [Occ=Once] ->
                    Data.Functor.Product.$w$c==
                        w_sg5qR w1_sg5qS w2_sg5qT ww1_sg5qX ww2_sg5qY ww4_sg5r0 ww5_sg5r1;
              };
        };

Data.Functor.Product.$fEqProduct_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sg5r2 $dEq2_sg5r3 $dEq_sg5r4 eta_sg5r5 eta1_sg5r6]
        case eta_sg5r5 of {
          Data.Functor.Product.Pair ww1_sg5r8 [Occ=Once]
                                    ww2_sg5r9 [Occ=Once] ->
              case eta1_sg5r6 of {
                Data.Functor.Product.Pair ww4_sg5rb [Occ=Once]
                                          ww5_sg5rc [Occ=Once] ->
                    let {
                      eq_sg5rd :: a_ag452 -> a_ag452 -> GHC.Types.Bool
                      [LclId] =
                          [$dEq_sg5r4] \u [] GHC.Classes.== $dEq_sg5r4;
                    } in 
                      case $dEq1_sg5r2 eq_sg5rd ww1_sg5r8 ww4_sg5rb of {
                        GHC.Types.False -> GHC.Types.True [];
                        GHC.Types.True ->
                            case $dEq2_sg5r3 eq_sg5rd ww2_sg5r9 ww5_sg5rc of {
                              GHC.Types.False -> GHC.Types.True [];
                              GHC.Types.True -> GHC.Types.False [];
                            };
                      };
              };
        };

Data.Functor.Product.$fEqProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     GHC.Classes.Eq (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><L,U(U,A)>m] =
    [] \r [$dEq1_sg5rg $dEq2_sg5rh $dEq_sg5ri]
        let {
          sat_sg5rk [Occ=Once]
            :: Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sg5rg $dEq2_sg5rh $dEq_sg5ri] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fEqProduct_$c/=
                      $dEq1_sg5rg $dEq2_sg5rh $dEq_sg5ri eta_B2 eta_B1; } in
        let {
          sat_sg5rj [Occ=Once]
            :: Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sg5rg $dEq2_sg5rh $dEq_sg5ri] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fEqProduct_$c==
                      $dEq1_sg5rg $dEq2_sg5rh $dEq_sg5ri eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sg5rj sat_sg5rk];

Data.Functor.Product.$fOrdProduct_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg5rl $dOrd2_sg5rm $dOrd_sg5rn eta_sg5ro eta1_sg5rp]
        case eta_sg5ro of {
          Data.Functor.Product.Pair ww1_sg5rr [Occ=Once]
                                    ww2_sg5rs [Occ=Once] ->
              case eta1_sg5rp of {
                Data.Functor.Product.Pair ww4_sg5ru [Occ=Once]
                                          ww5_sg5rv [Occ=Once] ->
                    let {
                      w_sg5rw :: a_ag44e -> a_ag44e -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg5rn] \u [] GHC.Classes.compare $dOrd_sg5rn;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg5rl w_sg5rw ww1_sg5rr ww4_sg5ru
                      of
                      { GHC.Types.LT -> GHC.Types.LT [];
                        GHC.Types.EQ ->
                            Data.Functor.Classes.liftCompare
                                $dOrd2_sg5rm w_sg5rw ww2_sg5rs ww5_sg5rv;
                        GHC.Types.GT -> GHC.Types.GT [];
                      };
              };
        };

Data.Functor.Product.$fOrdProduct_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Eq (Data.Functor.Product.Product f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg5ry $dOrd2_sg5rz $dOrd_sg5rA]
        let {
          sat_sg5rD [Occ=Once, Dmd=<L,U(U,A)>] :: GHC.Classes.Eq a_ag44e
          [LclId] =
              [$dOrd_sg5rA] \u [] GHC.Classes.$p1Ord $dOrd_sg5rA; } in
        let {
          sat_sg5rC [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 g_ag44d
          [LclId] =
              [$dOrd2_sg5rz] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sg5rz; } in
        let {
          sat_sg5rB [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 f_ag44c
          [LclId] =
              [$dOrd1_sg5ry] \u [] Data.Functor.Classes.$p1Ord1 $dOrd1_sg5ry;
        } in 
          Data.Functor.Product.$fEqProduct sat_sg5rB sat_sg5rC sat_sg5rD;

Data.Functor.Product.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5rE
           w1_sg5rF
           w2_sg5rG
           ww_sg5rH
           ww1_sg5rI
           ww2_sg5rJ
           ww3_sg5rK]
        let {
          comp_sg5rL :: a_sg4Q3 -> a_sg4Q3 -> GHC.Types.Ordering
          [LclId] =
              [w2_sg5rG] \u [] GHC.Classes.compare w2_sg5rG;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sg5rE comp_sg5rL ww_sg5rH ww2_sg5rJ
          of
          { GHC.Types.LT -> GHC.Types.True [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sg5rF comp_sg5rL ww1_sg5rI ww3_sg5rK
                of
                { __DEFAULT -> GHC.Types.False [];
                  GHC.Types.LT -> GHC.Types.True [];
                };
            GHC.Types.GT -> GHC.Types.False [];
          };

Data.Functor.Product.$fOrdProduct_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5rO w1_sg5rP w2_sg5rQ w3_sg5rR w4_sg5rS]
        case w3_sg5rR of {
          Data.Functor.Product.Pair ww1_sg5rU [Occ=Once]
                                    ww2_sg5rV [Occ=Once] ->
              case w4_sg5rS of {
                Data.Functor.Product.Pair ww4_sg5rX [Occ=Once]
                                          ww5_sg5rY [Occ=Once] ->
                    Data.Functor.Product.$w$c<
                        w_sg5rO w1_sg5rP w2_sg5rQ ww1_sg5rU ww2_sg5rV ww4_sg5rX ww5_sg5rY;
              };
        };

Data.Functor.Product.$w$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5rZ
           w1_sg5s0
           w2_sg5s1
           ww_sg5s2
           ww1_sg5s3
           ww2_sg5s4
           ww3_sg5s5]
        let {
          comp_sg5s6 :: a_sg4Qm -> a_sg4Qm -> GHC.Types.Ordering
          [LclId] =
              [w2_sg5s1] \u [] GHC.Classes.compare w2_sg5s1;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sg5rZ comp_sg5s6 ww_sg5s2 ww2_sg5s4
          of
          { GHC.Types.LT -> GHC.Types.False [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sg5s0 comp_sg5s6 ww1_sg5s3 ww3_sg5s5
                of
                { __DEFAULT -> GHC.Types.True [];
                  GHC.Types.LT -> GHC.Types.False [];
                };
            GHC.Types.GT -> GHC.Types.True [];
          };

Data.Functor.Product.$fOrdProduct_$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5s9 w1_sg5sa w2_sg5sb w3_sg5sc w4_sg5sd]
        case w3_sg5sc of {
          Data.Functor.Product.Pair ww1_sg5sf [Occ=Once]
                                    ww2_sg5sg [Occ=Once] ->
              case w4_sg5sd of {
                Data.Functor.Product.Pair ww4_sg5si [Occ=Once]
                                          ww5_sg5sj [Occ=Once] ->
                    Data.Functor.Product.$w$c>=
                        w_sg5s9 w1_sg5sa w2_sg5sb ww1_sg5sf ww2_sg5sg ww4_sg5si ww5_sg5sj;
              };
        };

Data.Functor.Product.$w$c> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5sk
           w1_sg5sl
           w2_sg5sm
           ww_sg5sn
           ww1_sg5so
           ww2_sg5sp
           ww3_sg5sq]
        let {
          comp_sg5sr :: a_sg4QF -> a_sg4QF -> GHC.Types.Ordering
          [LclId] =
              [w2_sg5sm] \u [] GHC.Classes.compare w2_sg5sm;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sg5sk comp_sg5sr ww_sg5sn ww2_sg5sp
          of
          { GHC.Types.LT -> GHC.Types.False [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sg5sl comp_sg5sr ww1_sg5so ww3_sg5sq
                of
                { __DEFAULT -> GHC.Types.False [];
                  GHC.Types.GT -> GHC.Types.True [];
                };
            GHC.Types.GT -> GHC.Types.True [];
          };

Data.Functor.Product.$fOrdProduct_$c> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5su w1_sg5sv w2_sg5sw w3_sg5sx w4_sg5sy]
        case w3_sg5sx of {
          Data.Functor.Product.Pair ww1_sg5sA [Occ=Once]
                                    ww2_sg5sB [Occ=Once] ->
              case w4_sg5sy of {
                Data.Functor.Product.Pair ww4_sg5sD [Occ=Once]
                                          ww5_sg5sE [Occ=Once] ->
                    Data.Functor.Product.$w$c>
                        w_sg5su w1_sg5sv w2_sg5sw ww1_sg5sA ww2_sg5sB ww4_sg5sD ww5_sg5sE;
              };
        };

Data.Functor.Product.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5sF
           w1_sg5sG
           w2_sg5sH
           ww_sg5sI
           ww1_sg5sJ
           ww2_sg5sK
           ww3_sg5sL]
        let {
          comp_sg5sM :: a_sg4QY -> a_sg4QY -> GHC.Types.Ordering
          [LclId] =
              [w2_sg5sH] \u [] GHC.Classes.compare w2_sg5sH;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sg5sF comp_sg5sM ww_sg5sI ww2_sg5sK
          of
          { GHC.Types.LT -> GHC.Types.True [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sg5sG comp_sg5sM ww1_sg5sJ ww3_sg5sL
                of
                { __DEFAULT -> GHC.Types.True [];
                  GHC.Types.GT -> GHC.Types.False [];
                };
            GHC.Types.GT -> GHC.Types.False [];
          };

Data.Functor.Product.$fOrdProduct_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5sP w1_sg5sQ w2_sg5sR w3_sg5sS w4_sg5sT]
        case w3_sg5sS of {
          Data.Functor.Product.Pair ww1_sg5sV [Occ=Once]
                                    ww2_sg5sW [Occ=Once] ->
              case w4_sg5sT of {
                Data.Functor.Product.Pair ww4_sg5sY [Occ=Once]
                                          ww5_sg5sZ [Occ=Once] ->
                    Data.Functor.Product.$w$c<=
                        w_sg5sP w1_sg5sQ w2_sg5sR ww1_sg5sV ww2_sg5sW ww4_sg5sY ww5_sg5sZ;
              };
        };

Data.Functor.Product.$fOrdProduct_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg5t0 $dOrd2_sg5t1 $dOrd_sg5t2 x_sg5t3 y_sg5t4]
        case x_sg5t3 of ww_sg5t5 {
          Data.Functor.Product.Pair ww1_sg5t6 [Occ=Once]
                                    ww2_sg5t7 [Occ=Once] ->
              case y_sg5t4 of ww3_sg5t8 {
                Data.Functor.Product.Pair ww4_sg5t9 [Occ=Once]
                                          ww5_sg5ta [Occ=Once] ->
                    let {
                      comp_sg5tb :: a_ag44e -> a_ag44e -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg5t2] \u [] GHC.Classes.compare $dOrd_sg5t2;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg5t0 comp_sg5tb ww1_sg5t6 ww4_sg5t9
                      of
                      { GHC.Types.LT -> ww3_sg5t8;
                        GHC.Types.EQ ->
                            case
                                Data.Functor.Classes.liftCompare
                                    $dOrd2_sg5t1 comp_sg5tb ww2_sg5t7 ww5_sg5ta
                            of
                            { __DEFAULT -> ww3_sg5t8;
                              GHC.Types.GT -> ww_sg5t5;
                            };
                        GHC.Types.GT -> ww_sg5t5;
                      };
              };
        };

Data.Functor.Product.$fOrdProduct_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg5te $dOrd2_sg5tf $dOrd_sg5tg x_sg5th y_sg5ti]
        case x_sg5th of ww_sg5tj {
          Data.Functor.Product.Pair ww1_sg5tk [Occ=Once]
                                    ww2_sg5tl [Occ=Once] ->
              case y_sg5ti of ww3_sg5tm {
                Data.Functor.Product.Pair ww4_sg5tn [Occ=Once]
                                          ww5_sg5to [Occ=Once] ->
                    let {
                      comp_sg5tp :: a_ag44e -> a_ag44e -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg5tg] \u [] GHC.Classes.compare $dOrd_sg5tg;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg5te comp_sg5tp ww1_sg5tk ww4_sg5tn
                      of
                      { GHC.Types.LT -> ww_sg5tj;
                        GHC.Types.EQ ->
                            case
                                Data.Functor.Classes.liftCompare
                                    $dOrd2_sg5tf comp_sg5tp ww2_sg5tl ww5_sg5to
                            of
                            { __DEFAULT -> ww_sg5tj;
                              GHC.Types.GT -> ww3_sg5tm;
                            };
                        GHC.Types.GT -> ww3_sg5tm;
                      };
              };
        };

Data.Functor.Product.$fOrdProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Ord (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m] =
    [] \r [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu]
        let {
          sat_sg5tC [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$cmin
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5tB [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$cmax
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5tA [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c>=
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5tz [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c>
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5ty [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c<=
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5tx [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c<
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5tw [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$ccompare
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu eta_B2 eta_B1; } in
        let {
          sat_sg5tv [Occ=Once]
            :: GHC.Classes.Eq
                 (Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e)
          [LclId] =
              [$dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu] \u []
                  Data.Functor.Product.$fOrdProduct_$cp1Ord
                      $dOrd1_sg5ts $dOrd2_sg5tt $dOrd_sg5tu;
        } in 
          GHC.Classes.C:Ord [sat_sg5tv
                             sat_sg5tw
                             sat_sg5tx
                             sat_sg5ty
                             sat_sg5tz
                             sat_sg5tA
                             sat_sg5tB
                             sat_sg5tC];

Data.Functor.Product.$fReadProduct_$creadPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       (Data.Functor.Product.Product f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5tD $dRead2_sg5tE $dRead_sg5tF]
        let {
          sat_sg5tH [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag43H]
          [LclId] =
              [$dRead_sg5tF] \u [] GHC.Read.readListPrec $dRead_sg5tF; } in
        let {
          sat_sg5tG [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag43H
          [LclId] =
              [$dRead_sg5tF] \u [] GHC.Read.readPrec $dRead_sg5tF;
        } in 
          Data.Functor.Product.$fRead1Product_$cliftReadPrec
              $dRead1_sg5tD $dRead2_sg5tE sat_sg5tG sat_sg5tH;

Data.Functor.Product.$fReadProduct_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Product.Product f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5tI $dRead2_sg5tJ $dRead_sg5tK]
        let {
          ds_sg5tL [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sg5tI $dRead2_sg5tJ $dRead_sg5tK] \u []
                  let {
                    sat_sg5tN [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag43H]
                    [LclId] =
                        [$dRead_sg5tK] \u [] GHC.Read.readListPrec $dRead_sg5tK; } in
                  let {
                    sat_sg5tM [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag43H
                    [LclId] =
                        [$dRead_sg5tK] \u [] GHC.Read.readPrec $dRead_sg5tK;
                  } in 
                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                        $dRead1_sg5tI $dRead2_sg5tJ sat_sg5tM sat_sg5tN; } in
        let {
          sat_sg5tQ [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [ds_sg5tL] \r [n_sg5tO]
                  let {
                    sat_sg5tP [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
                    [LclId] =
                        [ds_sg5tL n_sg5tO] \u []
                            ds_sg5tL
                                n_sg5tO Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sg5tP;
        } in  sat_sg5tQ;

Data.Functor.Product.$fReadProduct_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Product.Product f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5tR $dRead2_sg5tS $dRead_sg5tT]
        let {
          sat_sg5tW [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sg5tR $dRead2_sg5tS $dRead_sg5tT] \s []
                  let {
                    sat_sg5tV [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag43H]
                    [LclId] =
                        [$dRead_sg5tT] \u [] GHC.Read.readListPrec $dRead_sg5tT; } in
                  let {
                    sat_sg5tU [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag43H
                    [LclId] =
                        [$dRead_sg5tT] \u [] GHC.Read.readPrec $dRead_sg5tT;
                  } in 
                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                        $dRead1_sg5tR $dRead2_sg5tS sat_sg5tU sat_sg5tV;
        } in  GHC.Read.list sat_sg5tW;

Data.Functor.Product.$fReadProduct_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Functor.Product.Product f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg5tX $dRead2_sg5tY $dRead_sg5tZ]
        let {
          sat_sg5u0 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H]
          [LclId] =
              [$dRead1_sg5tX $dRead2_sg5tY $dRead_sg5tZ] \u []
                  Data.Functor.Product.$fReadProduct_$creadListPrec
                      $dRead1_sg5tX
                      $dRead2_sg5tY
                      $dRead_sg5tZ
                      GHC.Read.$fRead()7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sg5u0;

Data.Functor.Product.$fReadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Read.Read (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,U,U)>m] =
    [] \r [$dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3]
        let {
          sat_sg5u7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H]
          [LclId] =
              [$dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3] \u []
                  Data.Functor.Product.$fReadProduct_$creadListPrec
                      $dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3; } in
        let {
          sat_sg5u6 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3] \u []
                  Data.Functor.Product.$fReadProduct_$creadPrec
                      $dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3; } in
        let {
          sat_sg5u5 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H]
          [LclId] =
              [$dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3] \u []
                  Data.Functor.Product.$fReadProduct_$creadList
                      $dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3; } in
        let {
          sat_sg5u4 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3] \u []
                  Data.Functor.Product.$fReadProduct_$creadsPrec
                      $dRead1_sg5u1 $dRead2_sg5u2 $dRead_sg5u3;
        } in  GHC.Read.C:Read [sat_sg5u4 sat_sg5u5 sat_sg5u6 sat_sg5u7];

Data.Functor.Product.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Prim.Int# -> f a -> g a -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5u8 w1_sg5u9 w2_sg5ua ww_sg5ub ww1_sg5uc ww2_sg5ud]
        let {
          sp_sg5ue :: GHC.Types.Int -> a_sg4Rt -> GHC.Show.ShowS
          [LclId] =
              [w2_sg5ua] \u [] GHC.Show.showsPrec w2_sg5ua; } in
        let {
          sl_sg5uf :: [a_sg4Rt] -> GHC.Show.ShowS
          [LclId] =
              [w2_sg5ua] \u [] GHC.Show.showList w2_sg5ua; } in
        let {
          sat_sg5uh [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> g_sg4Rs a_sg4Rt -> GHC.Show.ShowS
          [LclId] =
              [w1_sg5u9 sp_sg5ue sl_sg5uf] \s []
                  Data.Functor.Classes.liftShowsPrec w1_sg5u9 sp_sg5ue sl_sg5uf; } in
        let {
          sat_sg5ug [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> f_sg4Rr a_sg4Rt -> GHC.Show.ShowS
          [LclId] =
              [w_sg5u8 sp_sg5ue sl_sg5uf] \s []
                  Data.Functor.Classes.liftShowsPrec w_sg5u8 sp_sg5ue sl_sg5uf;
        } in 
          Data.Functor.Classes.$wshowsBinaryWith
              sat_sg5ug
              sat_sg5uh
              Data.Functor.Product.$fRead1Product2
              ww_sg5ub
              ww1_sg5uc
              ww2_sg5ud;

Data.Functor.Product.$fShowProduct_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Types.Int
     -> Data.Functor.Product.Product f g a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5ui w1_sg5uj w2_sg5uk w3_sg5ul w4_sg5um]
        case w3_sg5ul of {
          GHC.Types.I# ww1_sg5uo [Occ=Once] ->
              case w4_sg5um of {
                Data.Functor.Product.Pair ww3_sg5uq [Occ=Once]
                                          ww4_sg5ur [Occ=Once] ->
                    Data.Functor.Product.$w$cshowsPrec
                        w_sg5ui w1_sg5uj w2_sg5uk ww1_sg5uo ww3_sg5uq ww4_sg5ur;
              };
        };

Data.Functor.Product.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     f a -> g a -> GHC.Base.String
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*U,A,1*U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5us w1_sg5ut w2_sg5uu ww_sg5uv ww1_sg5uw]
        let {
          sp_sg5ux :: GHC.Types.Int -> a_sg4RL -> GHC.Show.ShowS
          [LclId] =
              [w2_sg5uu] \u [] GHC.Show.showsPrec w2_sg5uu; } in
        let {
          sl_sg5uy :: [a_sg4RL] -> GHC.Show.ShowS
          [LclId] =
              [w2_sg5uu] \u [] GHC.Show.showList w2_sg5uu; } in
        let {
          sat_sg5uB [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [w_sg5us w1_sg5ut ww_sg5uv ww1_sg5uw sp_sg5ux sl_sg5uy] \u []
                  let {
                    sat_sg5uz [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [w1_sg5ut ww1_sg5uw sp_sg5ux sl_sg5uy] \u []
                            Data.Functor.Classes.liftShowsPrec
                                w1_sg5ut
                                sp_sg5ux
                                sl_sg5uy
                                Data.Functor.Classes.$fRead1Const1
                                ww1_sg5uw
                                GHC.Types.[]; } in
                  let {
                    sat_sg5uA [Occ=Once] :: GHC.Base.String
                    [LclId] =
                        CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sg5uz];
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w_sg5us
                        sp_sg5ux
                        sl_sg5uy
                        Data.Functor.Classes.$fRead1Const1
                        ww_sg5uv
                        sat_sg5uA; } in
        let {
          sat_sg5uC [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sg5uB];
        } in  GHC.Base.++ Data.Functor.Product.$fRead1Product2 sat_sg5uC;

Data.Functor.Product.$fShowProduct_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     Data.Functor.Product.Product f g a -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(U,A,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5uD w1_sg5uE w2_sg5uF w3_sg5uG]
        case w3_sg5uG of {
          Data.Functor.Product.Pair ww1_sg5uI [Occ=Once]
                                    ww2_sg5uJ [Occ=Once] ->
              Data.Functor.Product.$w$cshow
                  w_sg5uD w1_sg5uE w2_sg5uF ww1_sg5uI ww2_sg5uJ;
        };

Data.Functor.Product.$fShowProduct_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     [Data.Functor.Product.Product f g a] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sg5uK $dShow2_sg5uL $dShow_sg5uM ls_sg5uN s_sg5uO]
        let {
          lvl9_sg5uP [Occ=OnceL]
            :: GHC.Types.Int -> a_ag43h -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sg5uM] \u [] GHC.Show.showsPrec $dShow_sg5uM; } in
        let {
          lvl10_sg5uQ [Occ=OnceL] :: [a_ag43h] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sg5uM] \u [] GHC.Show.showList $dShow_sg5uM; } in
        let {
          sat_sg5uV [Occ=Once]
            :: Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg5uK $dShow2_sg5uL lvl9_sg5uP lvl10_sg5uQ] \r [eta_sg5uR]
                  case eta_sg5uR of {
                    Data.Functor.Product.Pair ww1_sg5uT [Occ=Once]
                                              ww2_sg5uU [Occ=Once] ->
                        Data.Functor.Product.$w$cliftShowsPrec
                            $dShow1_sg5uK
                            $dShow2_sg5uL
                            lvl9_sg5uP
                            lvl10_sg5uQ
                            0#
                            ww1_sg5uT
                            ww2_sg5uU;
                  };
        } in  GHC.Show.showList__ sat_sg5uV ls_sg5uN s_sg5uO;

Data.Functor.Product.$fShowProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Show.Show (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(U,A,U)>m] =
    [] \r [$dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY]
        let {
          sat_sg5v1 [Occ=Once]
            :: [Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fShowProduct_$cshowList
                      $dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY eta_B2 eta_B1; } in
        let {
          sat_sg5v0 [Occ=Once]
            :: Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h
               -> GHC.Base.String
          [LclId] =
              [$dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY] \r [eta_B1]
                  Data.Functor.Product.$fShowProduct_$cshow
                      $dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY eta_B1; } in
        let {
          sat_sg5uZ [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fShowProduct_$cshowsPrec
                      $dShow1_sg5uW $dShow2_sg5uX $dShow_sg5uY eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sg5uZ sat_sg5v0 sat_sg5v1];

Data.Functor.Product.$fFunctorProduct_$cfmap
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sg5v2 $dFunctor1_sg5v3 f1_sg5v4 ds_sg5v5]
        case ds_sg5v5 of {
          Data.Functor.Product.Pair x_sg5v7 [Occ=Once] y_sg5v8 [Occ=Once] ->
              let {
                sat_sg5va [Occ=Once] :: g_ag42H b_ag42O
                [LclId] =
                    [$dFunctor1_sg5v3 f1_sg5v4 y_sg5v8] \u []
                        GHC.Base.fmap $dFunctor1_sg5v3 f1_sg5v4 y_sg5v8; } in
              let {
                sat_sg5v9 [Occ=Once] :: f_ag42G b_ag42O
                [LclId] =
                    [$dFunctor_sg5v2 f1_sg5v4 x_sg5v7] \u []
                        GHC.Base.fmap $dFunctor_sg5v2 f1_sg5v4 x_sg5v7;
              } in  Data.Functor.Product.Pair [sat_sg5v9 sat_sg5va];
        };

Data.Functor.Product.$fFunctorProduct_$c<$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sg5vb w1_sg5vc w2_sg5vd w3_sg5ve]
        case w3_sg5ve of {
          Data.Functor.Product.Pair ww1_sg5vg [Occ=Once]
                                    ww2_sg5vh [Occ=Once] ->
              let {
                f1_sg5vi :: b_sg4S9 -> a_sg4S8
                [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
                    [w2_sg5vd] \r [ds_sg5vj] w2_sg5vd; } in
              let {
                sat_sg5vl [Occ=Once] :: g_sg4S5 a_sg4S8
                [LclId] =
                    [w1_sg5vc ww2_sg5vh f1_sg5vi] \u []
                        GHC.Base.fmap w1_sg5vc f1_sg5vi ww2_sg5vh; } in
              let {
                sat_sg5vk [Occ=Once] :: f_sg4S4 a_sg4S8
                [LclId] =
                    [w_sg5vb ww1_sg5vg f1_sg5vi] \u []
                        GHC.Base.fmap w_sg5vb f1_sg5vi ww1_sg5vg;
              } in  Data.Functor.Product.Pair [sat_sg5vk sat_sg5vl];
        };

Data.Functor.Product.$fFunctorProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     GHC.Base.Functor (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dFunctor_sg5vm $dFunctor1_sg5vn]
        let {
          sat_sg5vp [Occ=Once]
            :: forall a b.
               a
               -> Data.Functor.Product.Product f_ag42G g_ag42H b
               -> Data.Functor.Product.Product f_ag42G g_ag42H a
          [LclId] =
              [$dFunctor_sg5vm $dFunctor1_sg5vn] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFunctorProduct_$c<$
                      $dFunctor_sg5vm $dFunctor1_sg5vn eta_B2 eta_B1; } in
        let {
          sat_sg5vo [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Product.Product f_ag42G g_ag42H a
               -> Data.Functor.Product.Product f_ag42G g_ag42H b
          [LclId] =
              [$dFunctor_sg5vm $dFunctor1_sg5vn] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFunctorProduct_$cfmap
                      $dFunctor_sg5vm $dFunctor1_sg5vn eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sg5vo sat_sg5vp];

Data.Functor.Product.$w$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> f a -> g a -> m
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5vq w1_sg5vr w2_sg5vs w3_sg5vt ww_sg5vu ww1_sg5vv]
        let {
          sat_sg5vx [Occ=Once] :: m_sg4Sp
          [LclId] =
              [w1_sg5vr w2_sg5vs w3_sg5vt ww1_sg5vv] \u []
                  Data.Foldable.foldMap w1_sg5vr w2_sg5vs w3_sg5vt ww1_sg5vv; } in
        let {
          sat_sg5vw [Occ=Once] :: m_sg4Sp
          [LclId] =
              [w_sg5vq w2_sg5vs w3_sg5vt ww_sg5vu] \u []
                  Data.Foldable.foldMap w_sg5vq w2_sg5vs w3_sg5vt ww_sg5vu;
        } in  GHC.Base.mappend w2_sg5vs sat_sg5vw sat_sg5vx;

Data.Functor.Product.$fFoldableProduct_$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Functor.Product.Product f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5vy w1_sg5vz w2_sg5vA w3_sg5vB w4_sg5vC]
        case w4_sg5vC of {
          Data.Functor.Product.Pair ww1_sg5vE [Occ=Once]
                                    ww2_sg5vF [Occ=Once] ->
              Data.Functor.Product.$w$cfoldMap
                  w_sg5vy w1_sg5vz w2_sg5vA w3_sg5vB ww1_sg5vE ww2_sg5vF;
        };

Data.Functor.Product.$fFoldableProduct_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m.
     GHC.Base.Monoid m =>
     Data.Functor.Product.Product f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5vG $dFoldable1_sg5vH $dMonoid_sg5vI w_sg5vJ]
        case w_sg5vJ of {
          Data.Functor.Product.Pair ww1_sg5vL [Occ=Once]
                                    ww2_sg5vM [Occ=Once] ->
              Data.Functor.Product.$w$cfoldMap
                  $dFoldable_sg5vG
                  $dFoldable1_sg5vH
                  $dMonoid_sg5vI
                  GHC.Base.id
                  ww1_sg5vL
                  ww2_sg5vM;
        };

Data.Functor.Product.$fFoldableProduct1 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sg5vN] v_sg5vN;

Data.Functor.Product.$fFoldableProduct_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5vO $dFoldable1_sg5vP $dNum_sg5vQ]
        let {
          $dMonoid_sg5vR
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_ag42n)
          [LclId] =
              [$dNum_sg5vQ] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sg5vQ; } in
        let {
          sat_sg5vY [Occ=Once]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag42n
               -> Data.Semigroup.Internal.Sum a_ag42n
          [LclId] =
              [$dFoldable_sg5vO
               $dFoldable1_sg5vP
               $dNum_sg5vQ
               $dMonoid_sg5vR] \r [ds_sg5vS]
                  case ds_sg5vS of {
                    Data.Functor.Product.Pair x_sg5vU [Occ=Once] y_sg5vV [Occ=Once] ->
                        let {
                          sat_sg5vX [Occ=Once] :: a_ag42n
                          [LclId] =
                              [$dFoldable1_sg5vP $dMonoid_sg5vR y_sg5vV] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_sg5vP
                                      $dMonoid_sg5vR
                                      Data.Functor.Product.$fFoldableProduct1
                                      y_sg5vV; } in
                        let {
                          sat_sg5vW [Occ=Once] :: a_ag42n
                          [LclId] =
                              [$dFoldable_sg5vO $dMonoid_sg5vR x_sg5vU] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_sg5vO
                                      $dMonoid_sg5vR
                                      Data.Functor.Product.$fFoldableProduct1
                                      x_sg5vU;
                        } in  GHC.Num.+ $dNum_sg5vQ sat_sg5vW sat_sg5vX;
                  };
        } in  sat_sg5vY;

lvl_rg5nW :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Functor.Product.$fFoldableProduct2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rg5nW of sat_sg5vZ {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg5vZ;
        };

Data.Functor.Product.$fFoldableProduct_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5w0 $dFoldable1_sg5w1 $dOrd_sg5w2]
        let {
          $dMonoid_sg5w3 :: GHC.Base.Monoid (Data.Functor.Utils.Min a_ag42d)
          [LclId] =
              [$dOrd_sg5w2] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_sg5w2; } in
        let {
          sat_sg5wf [Occ=OnceT[0]]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag42d -> a_ag42d
          [LclId] =
              [$dFoldable_sg5w0
               $dFoldable1_sg5w1
               $dOrd_sg5w2
               $dMonoid_sg5w3] \r [x_sg5w4]
                  case x_sg5w4 of {
                    Data.Functor.Product.Pair x1_sg5w6 [Occ=Once*]
                                              y_sg5w7 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sg5w1 $dMonoid_sg5w3 GHC.Base.Just y_sg5w7
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sg5w0 $dMonoid_sg5w3 GHC.Base.Just x1_sg5w6
                              of
                              { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct2;
                                GHC.Base.Just v_sg5wa [Occ=Once] -> v_sg5wa;
                              };
                          GHC.Base.Just ipv_sg5wb ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sg5w0 $dMonoid_sg5w3 GHC.Base.Just x1_sg5w6
                              of
                              { GHC.Base.Nothing -> ipv_sg5wb;
                                GHC.Base.Just x2_sg5wd ->
                                    case GHC.Classes.<= $dOrd_sg5w2 x2_sg5wd ipv_sg5wb of {
                                      GHC.Types.False -> ipv_sg5wb;
                                      GHC.Types.True -> x2_sg5wd;
                                    };
                              };
                        };
                  };
        } in  sat_sg5wf;

lvl1_rg5nX :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Functor.Product.$fFoldableProduct3 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rg5nX of sat_sg5wg {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg5wg;
        };

Data.Functor.Product.$fFoldableProduct_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5wh $dFoldable1_sg5wi $dOrd_sg5wj]
        let {
          $dMonoid_sg5wk :: GHC.Base.Monoid (Data.Functor.Utils.Max a_ag423)
          [LclId] =
              [$dOrd_sg5wj] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_sg5wj; } in
        let {
          sat_sg5ww [Occ=OnceT[0]]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag423 -> a_ag423
          [LclId] =
              [$dFoldable_sg5wh
               $dFoldable1_sg5wi
               $dOrd_sg5wj
               $dMonoid_sg5wk] \r [x_sg5wl]
                  case x_sg5wl of {
                    Data.Functor.Product.Pair x1_sg5wn [Occ=Once*]
                                              y_sg5wo [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sg5wi $dMonoid_sg5wk GHC.Base.Just y_sg5wo
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sg5wh $dMonoid_sg5wk GHC.Base.Just x1_sg5wn
                              of
                              { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct3;
                                GHC.Base.Just v_sg5wr [Occ=Once] -> v_sg5wr;
                              };
                          GHC.Base.Just ipv_sg5ws ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sg5wh $dMonoid_sg5wk GHC.Base.Just x1_sg5wn
                              of
                              { GHC.Base.Nothing -> ipv_sg5ws;
                                GHC.Base.Just x2_sg5wu ->
                                    case GHC.Classes.>= $dOrd_sg5wj x2_sg5wu ipv_sg5ws of {
                                      GHC.Types.False -> ipv_sg5ws;
                                      GHC.Types.True -> x2_sg5wu;
                                    };
                              };
                        };
                  };
        } in  sat_sg5ww;

Data.Functor.Product.$fFoldableProduct_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5wx $dFoldable1_sg5wy $dEq_sg5wz eta_sg5wA]
        let {
          f1_sg5wB :: a_ag41T -> GHC.Types.Bool
          [LclId] =
              [$dEq_sg5wz eta_sg5wA] \u []
                  GHC.Classes.== $dEq_sg5wz eta_sg5wA; } in
        let {
          sat_sg5wH [Occ=Once]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag41T
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_sg5wx $dFoldable1_sg5wy f1_sg5wB] \r [ds_sg5wC]
                  case ds_sg5wC of {
                    Data.Functor.Product.Pair x_sg5wE [Occ=Once] y_sg5wF [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_sg5wx
                                Data.Semigroup.Internal.$fMonoidAny
                                f1_sg5wB
                                x_sg5wE
                        of
                        { GHC.Types.False ->
                              Data.Foldable.foldMap
                                  $dFoldable1_sg5wy
                                  Data.Semigroup.Internal.$fMonoidAny
                                  f1_sg5wB
                                  y_sg5wF;
                          GHC.Types.True -> GHC.Types.True [];
                        };
                  };
        } in  sat_sg5wH;

Data.Functor.Product.$fFoldableProduct8
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Functor.Product.$w$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5wI w1_sg5wJ w2_sg5wK w3_sg5wL ww_sg5wM ww1_sg5wN]
        let {
          f1_sg5wO :: a_sg4T4 -> b_sg4T3 -> b_sg4T3
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [w2_sg5wK] \r [x_sg5wP y_sg5wQ] w2_sg5wK y_sg5wQ x_sg5wP; } in
        let {
          sat_sg5wR [Occ=Once] :: b_sg4T3
          [LclId] =
              [w_sg5wI w3_sg5wL ww_sg5wM f1_sg5wO] \u []
                  Data.Foldable.foldMap
                      w_sg5wI
                      Data.Functor.Product.$fFoldableProduct8
                      f1_sg5wO
                      ww_sg5wM
                      w3_sg5wL;
        } in 
          Data.Foldable.foldMap
              w1_sg5wJ
              Data.Functor.Product.$fFoldableProduct8
              f1_sg5wO
              ww1_sg5wN
              sat_sg5wR;

Data.Functor.Product.$fFoldableProduct_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5wS w1_sg5wT w2_sg5wU w3_sg5wV w4_sg5wW]
        case w4_sg5wW of {
          Data.Functor.Product.Pair ww1_sg5wY [Occ=Once]
                                    ww2_sg5wZ [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl
                  w_sg5wS w1_sg5wT w2_sg5wU w3_sg5wV ww1_sg5wY ww2_sg5wZ;
        };

lvl2_rg5nY :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Functor.Product.$fFoldableProduct7 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rg5nY of sat_sg5x0 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg5x0;
        };

Data.Functor.Product.$w$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5x1 w1_sg5x2 w2_sg5x3 ww_sg5x4 ww1_sg5x5]
        let {
          f1_sg5x6
            :: a_sg4Ti -> GHC.Base.Maybe a_sg4Ti -> GHC.Base.Maybe a_sg4Ti
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_sg5x3] \r [x_sg5x7 y_sg5x8]
                  let {
                    sat_sg5xb [Occ=Once] :: a_sg4Ti
                    [LclId] =
                        [w2_sg5x3 x_sg5x7 y_sg5x8] \u []
                            case y_sg5x8 of {
                              GHC.Base.Nothing -> x_sg5x7;
                              GHC.Base.Just x1_sg5xa [Occ=Once] -> w2_sg5x3 x1_sg5xa x_sg5x7;
                            };
                  } in  GHC.Base.Just [sat_sg5xb]; } in
        let {
          sat_sg5xc [Occ=Once] :: GHC.Base.Maybe a_sg4Ti
          [LclId] =
              [w_sg5x1 ww_sg5x4 f1_sg5x6] \u []
                  Data.Foldable.foldMap
                      w_sg5x1
                      Data.Functor.Product.$fFoldableProduct8
                      f1_sg5x6
                      ww_sg5x4
                      GHC.Base.Nothing;
        } in 
          case
              Data.Foldable.foldMap
                  w1_sg5x2
                  Data.Functor.Product.$fFoldableProduct8
                  f1_sg5x6
                  ww1_sg5x5
                  sat_sg5xc
          of
          { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct7;
            GHC.Base.Just v_sg5xe [Occ=Once] -> v_sg5xe;
          };

Data.Functor.Product.$fFoldableProduct_$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5xf w1_sg5xg w2_sg5xh w3_sg5xi]
        case w3_sg5xi of {
          Data.Functor.Product.Pair ww1_sg5xk [Occ=Once]
                                    ww2_sg5xl [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl1
                  w_sg5xf w1_sg5xg w2_sg5xh ww1_sg5xk ww2_sg5xl;
        };

Data.Functor.Product.$w$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5xm w1_sg5xn w2_sg5xo w3_sg5xp ww_sg5xq ww1_sg5xr]
        let {
          f1_sg5xs :: a_sg4Tv -> (b_sg4Tw -> b_sg4Tw) -> b_sg4Tw -> b_sg4Tw
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_sg5xo] \r [x_sg5xt y_sg5xu z_sg5xv]
                  case w2_sg5xo x_sg5xt z_sg5xv of vx_sg5xw {
                    __DEFAULT -> y_sg5xu vx_sg5xw;
                  }; } in
        let {
          sat_sg5xx [Occ=Once] :: b_sg4Tw -> b_sg4Tw
          [LclId] =
              [w_sg5xm ww_sg5xq f1_sg5xs] \u []
                  Data.Foldable.foldMap
                      w_sg5xm
                      Data.Functor.Product.$fFoldableProduct8
                      f1_sg5xs
                      ww_sg5xq
                      GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              w1_sg5xn
              Data.Functor.Product.$fFoldableProduct8
              f1_sg5xs
              ww1_sg5xr
              sat_sg5xx
              w3_sg5xp;

Data.Functor.Product.$fFoldableProduct_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5xy w1_sg5xz w2_sg5xA w3_sg5xB w4_sg5xC]
        case w4_sg5xC of {
          Data.Functor.Product.Pair ww1_sg5xE [Occ=Once]
                                    ww2_sg5xF [Occ=Once] ->
              Data.Functor.Product.$w$cfoldr'
                  w_sg5xy w1_sg5xz w2_sg5xA w3_sg5xB ww1_sg5xE ww2_sg5xF;
        };

Data.Functor.Product.$w$cfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5xG w1_sg5xH w2_sg5xI w3_sg5xJ ww_sg5xK ww1_sg5xL]
        let {
          sat_sg5xM [Occ=Once] :: b_sg4TL
          [LclId] =
              [w1_sg5xH w2_sg5xI w3_sg5xJ ww1_sg5xL] \u []
                  Data.Foldable.foldMap
                      w1_sg5xH
                      Data.Semigroup.Internal.$fMonoidEndo
                      w2_sg5xI
                      ww1_sg5xL
                      w3_sg5xJ;
        } in 
          Data.Foldable.foldMap
              w_sg5xG
              Data.Semigroup.Internal.$fMonoidEndo
              w2_sg5xI
              ww_sg5xK
              sat_sg5xM;

Data.Functor.Product.$fFoldableProduct_$cfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5xN w1_sg5xO w2_sg5xP w3_sg5xQ w4_sg5xR]
        case w4_sg5xR of {
          Data.Functor.Product.Pair ww1_sg5xT [Occ=Once]
                                    ww2_sg5xU [Occ=Once] ->
              Data.Functor.Product.$w$cfoldr
                  w_sg5xN w1_sg5xO w2_sg5xP w3_sg5xQ ww1_sg5xT ww2_sg5xU;
        };

Data.Functor.Product.$w$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5xV w1_sg5xW w2_sg5xX w3_sg5xY ww_sg5xZ ww1_sg5y0]
        let {
          f1_sg5y1 :: a_sg4U0 -> (b_sg4TZ -> b_sg4TZ) -> b_sg4TZ -> b_sg4TZ
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_sg5xX] \r [x_sg5y2 k_sg5y3 z_sg5y4]
                  case w2_sg5xX z_sg5y4 x_sg5y2 of vx_sg5y5 {
                    __DEFAULT -> k_sg5y3 vx_sg5y5;
                  }; } in
        let {
          sat_sg5y6 [Occ=Once] :: b_sg4TZ -> b_sg4TZ
          [LclId] =
              [w1_sg5xW ww1_sg5y0 f1_sg5y1] \u []
                  Data.Foldable.foldMap
                      w1_sg5xW
                      Data.Semigroup.Internal.$fMonoidEndo
                      f1_sg5y1
                      ww1_sg5y0
                      GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              w_sg5xV
              Data.Semigroup.Internal.$fMonoidEndo
              f1_sg5y1
              ww_sg5xZ
              sat_sg5y6
              w3_sg5xY;

Data.Functor.Product.$fFoldableProduct_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5y7 w1_sg5y8 w2_sg5y9 w3_sg5ya w4_sg5yb]
        case w4_sg5yb of {
          Data.Functor.Product.Pair ww1_sg5yd [Occ=Once]
                                    ww2_sg5ye [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl'
                  w_sg5y7 w1_sg5y8 w2_sg5y9 w3_sg5ya ww1_sg5yd ww2_sg5ye;
        };

Data.Functor.Product.$fFoldableProduct5
  :: forall a. GHC.Types.Int -> a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,A>m,
 Unf=OtherCon []] =
    [] \r [c_sg5yf ds_sg5yg]
        case c_sg5yf of {
          GHC.Types.I# x_sg5yi [Occ=Once] ->
              case +# [x_sg5yi 1#] of sat_sg5yj {
                __DEFAULT -> GHC.Types.I# [sat_sg5yj];
              };
        };

Data.Functor.Product.$fFoldableProduct_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Product.Product f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5yk $dFoldable1_sg5yl eta_sg5ym]
        case eta_sg5ym of {
          Data.Functor.Product.Pair ww1_sg5yo [Occ=Once]
                                    ww2_sg5yp [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl'
                  $dFoldable_sg5yk
                  $dFoldable1_sg5yl
                  Data.Functor.Product.$fFoldableProduct5
                  Data.Functor.Product.$fFoldableProduct4
                  ww1_sg5yo
                  ww2_sg5yp;
        };

lvl3_rg5nZ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Functor.Product.$fFoldableProduct9 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_rg5nZ of sat_sg5yq {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg5yq;
        };

Data.Functor.Product.$w$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5yr w1_sg5ys w2_sg5yt ww_sg5yu ww1_sg5yv]
        let {
          w3_sg5yw
            :: a_sg4Ue -> GHC.Base.Maybe a_sg4Ue -> GHC.Base.Maybe a_sg4Ue
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_sg5yt] \r [x_sg5yx m_sg5yy]
                  let {
                    sat_sg5yB [Occ=Once] :: a_sg4Ue
                    [LclId] =
                        [w2_sg5yt x_sg5yx m_sg5yy] \u []
                            case m_sg5yy of {
                              GHC.Base.Nothing -> x_sg5yx;
                              GHC.Base.Just y_sg5yA [Occ=Once] -> w2_sg5yt x_sg5yx y_sg5yA;
                            };
                  } in  GHC.Base.Just [sat_sg5yB]; } in
        let {
          sat_sg5yC [Occ=Once] :: GHC.Base.Maybe a_sg4Ue
          [LclId] =
              [w1_sg5ys ww1_sg5yv w3_sg5yw] \u []
                  Data.Foldable.foldMap
                      w1_sg5ys
                      Data.Semigroup.Internal.$fMonoidEndo
                      w3_sg5yw
                      ww1_sg5yv
                      GHC.Base.Nothing;
        } in 
          case
              Data.Foldable.foldMap
                  w_sg5yr
                  Data.Semigroup.Internal.$fMonoidEndo
                  w3_sg5yw
                  ww_sg5yu
                  sat_sg5yC
          of
          { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct9;
            GHC.Base.Just v_sg5yE [Occ=Once] -> v_sg5yE;
          };

Data.Functor.Product.$fFoldableProduct_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5yF w1_sg5yG w2_sg5yH w3_sg5yI]
        case w3_sg5yI of {
          Data.Functor.Product.Pair ww1_sg5yK [Occ=Once]
                                    ww2_sg5yL [Occ=Once] ->
              Data.Functor.Product.$w$cfoldr1
                  w_sg5yF w1_sg5yG w2_sg5yH ww1_sg5yK ww2_sg5yL;
        };

Data.Functor.Product.$fFoldableProduct6
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sg5yM ds1_sg5yN] GHC.Types.False [];

Data.Functor.Product.$fFoldableProduct_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5yO $dFoldable1_sg5yP eta_sg5yQ]
        case eta_sg5yQ of {
          Data.Functor.Product.Pair ww1_sg5yS [Occ=Once]
                                    ww2_sg5yT [Occ=Once] ->
              let {
                sat_sg5yU [Occ=Once] :: GHC.Types.Bool
                [LclId] =
                    [$dFoldable1_sg5yP ww2_sg5yT] \u []
                        Data.Foldable.foldMap
                            $dFoldable1_sg5yP
                            Data.Semigroup.Internal.$fMonoidEndo
                            Data.Functor.Product.$fFoldableProduct6
                            ww2_sg5yT
                            GHC.Types.True;
              } in 
                Data.Foldable.foldMap
                    $dFoldable_sg5yO
                    Data.Semigroup.Internal.$fMonoidEndo
                    Data.Functor.Product.$fFoldableProduct6
                    ww1_sg5yS
                    sat_sg5yU;
        };

Data.Functor.Product.$fFoldableProduct_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5yV $dFoldable1_sg5yW $dNum_sg5yX]
        let {
          $dMonoid_sg5yY
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_ag42x)
          [LclId] =
              [$dNum_sg5yX] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sg5yX; } in
        let {
          sat_sg5z5 [Occ=Once]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag42x
               -> Data.Semigroup.Internal.Product a_ag42x
          [LclId] =
              [$dFoldable_sg5yV
               $dFoldable1_sg5yW
               $dNum_sg5yX
               $dMonoid_sg5yY] \r [ds_sg5yZ]
                  case ds_sg5yZ of {
                    Data.Functor.Product.Pair x_sg5z1 [Occ=Once] y_sg5z2 [Occ=Once] ->
                        let {
                          sat_sg5z4 [Occ=Once] :: a_ag42x
                          [LclId] =
                              [$dFoldable1_sg5yW $dMonoid_sg5yY y_sg5z2] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_sg5yW
                                      $dMonoid_sg5yY
                                      Data.Functor.Product.$fFoldableProduct1
                                      y_sg5z2; } in
                        let {
                          sat_sg5z3 [Occ=Once] :: a_ag42x
                          [LclId] =
                              [$dFoldable_sg5yV $dMonoid_sg5yY x_sg5z1] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_sg5yV
                                      $dMonoid_sg5yY
                                      Data.Functor.Product.$fFoldableProduct1
                                      x_sg5z1;
                        } in  GHC.Num.* $dNum_sg5yX sat_sg5z3 sat_sg5z4;
                  };
        } in  sat_sg5z5;

Data.Functor.Product.$fFoldableProduct_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Product.Product f g a -> [a]
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg5z6 $dFoldable1_sg5z7 eta_sg5z8]
        case eta_sg5z8 of {
          Data.Functor.Product.Pair ww1_sg5za [Occ=Once]
                                    ww2_sg5zb [Occ=Once] ->
              let {
                sat_sg5zc [Occ=Once] :: [a_ag41v]
                [LclId] =
                    [$dFoldable1_sg5z7 ww2_sg5zb] \u []
                        Data.Foldable.foldMap
                            $dFoldable1_sg5z7
                            Data.Semigroup.Internal.$fMonoidEndo
                            GHC.Types.:
                            ww2_sg5zb
                            GHC.Types.[];
              } in 
                Data.Foldable.foldMap
                    $dFoldable_sg5z6
                    Data.Semigroup.Internal.$fMonoidEndo
                    GHC.Types.:
                    ww1_sg5za
                    sat_sg5zc;
        };

Data.Functor.Product.$fFoldableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_sg5zd $dFoldable1_sg5ze]
        let {
          sat_sg5zu [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cproduct
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zt [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$csum
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zs [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cminimum
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zr [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cmaximum
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zq [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a
               -> Data.Functor.Product.Product f_ag400 g_ag401 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$celem
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B2 eta_B1; } in
        let {
          sat_sg5zp [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag400 g_ag401 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$clength
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zo [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag400 g_ag401 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cnull
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zn [Occ=Once]
            :: forall a. Data.Functor.Product.Product f_ag400 g_ag401 a -> [a]
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$ctoList
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B1; } in
        let {
          sat_sg5zm [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldl1
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B2 eta_B1; } in
        let {
          sat_sg5zl [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldr1
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B2 eta_B1; } in
        let {
          sat_sg5zk [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldl'
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5zj [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldl
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5zi [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldr'
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5zh [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldr
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5zg [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> Data.Functor.Product.Product f_ag400 g_ag401 a -> m
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldMap
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5zf [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               Data.Functor.Product.Product f_ag400 g_ag401 m -> m
          [LclId] =
              [$dFoldable_sg5zd $dFoldable1_sg5ze] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfold
                      $dFoldable_sg5zd $dFoldable1_sg5ze eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_sg5zf
                                    sat_sg5zg
                                    sat_sg5zh
                                    sat_sg5zi
                                    sat_sg5zj
                                    sat_sg5zk
                                    sat_sg5zl
                                    sat_sg5zm
                                    sat_sg5zn
                                    sat_sg5zo
                                    sat_sg5zp
                                    sat_sg5zq
                                    sat_sg5zr
                                    sat_sg5zs
                                    sat_sg5zt
                                    sat_sg5zu];

Data.Functor.Product.$w$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> f a -> g a -> f1 (Data.Functor.Product.Product f g b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5zv w1_sg5zw w2_sg5zx w3_sg5zy ww_sg5zz ww1_sg5zA]
        let {
          sat_sg5zC [Occ=Once] :: f1_sg4Ux (g_sg4Uu b_sg4Uz)
          [LclId] =
              [w1_sg5zw w2_sg5zx w3_sg5zy ww1_sg5zA] \u []
                  Data.Traversable.traverse
                      w1_sg5zw w2_sg5zx w3_sg5zy ww1_sg5zA; } in
        let {
          sat_sg5zB [Occ=Once] :: f1_sg4Ux (f_sg4Ut b_sg4Uz)
          [LclId] =
              [w_sg5zv w2_sg5zx w3_sg5zy ww_sg5zz] \u []
                  Data.Traversable.traverse w_sg5zv w2_sg5zx w3_sg5zy ww_sg5zz;
        } in 
          GHC.Base.liftA2
              w2_sg5zx Data.Functor.Product.Pair sat_sg5zB sat_sg5zC;

Data.Functor.Product.$fTraversableProduct_$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> Data.Functor.Product.Product f g a
     -> f1 (Data.Functor.Product.Product f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5zD w1_sg5zE w2_sg5zF w3_sg5zG w4_sg5zH]
        case w4_sg5zH of {
          Data.Functor.Product.Pair ww1_sg5zJ [Occ=Once]
                                    ww2_sg5zK [Occ=Once] ->
              Data.Functor.Product.$w$ctraverse
                  w_sg5zD w1_sg5zE w2_sg5zF w3_sg5zG ww1_sg5zJ ww2_sg5zK;
        };

Data.Functor.Product.$fTraversableProduct_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg5zL $dTraversable1_sg5zM]
        let {
          sat_sg5zO [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_ag3YH
          [LclId] =
              [$dTraversable1_sg5zM] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sg5zM; } in
        let {
          sat_sg5zN [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_ag3YG
          [LclId] =
              [$dTraversable_sg5zL] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sg5zL;
        } in  Data.Functor.Product.$fFoldableProduct sat_sg5zN sat_sg5zO;

Data.Functor.Product.$fTraversableProduct_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg5zP $dTraversable1_sg5zQ]
        let {
          sat_sg5zS [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor g_ag3YH
          [LclId] =
              [$dTraversable1_sg5zQ] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sg5zQ; } in
        let {
          sat_sg5zR [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_ag3YG
          [LclId] =
              [$dTraversable_sg5zP] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sg5zP;
        } in  Data.Functor.Product.$fFunctorProduct sat_sg5zR sat_sg5zS;

Data.Functor.Product.$fTraversableProduct_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     Data.Functor.Product.Product f g (f1 a)
     -> f1 (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg5zT
           $dTraversable1_sg5zU
           $dApplicative_sg5zV
           w_sg5zW]
        case w_sg5zW of {
          Data.Functor.Product.Pair ww1_sg5zY [Occ=Once]
                                    ww2_sg5zZ [Occ=Once] ->
              Data.Functor.Product.$w$ctraverse
                  $dTraversable_sg5zT
                  $dTraversable1_sg5zU
                  $dApplicative_sg5zV
                  GHC.Base.id
                  ww1_sg5zY
                  ww2_sg5zZ;
        };

Data.Functor.Product.$fTraversableProduct_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg5A0
           $dTraversable1_sg5A1
           $dMonad_sg5A2
           eta_sg5A3
           eta1_sg5A4]
        case eta1_sg5A4 of {
          Data.Functor.Product.Pair ww1_sg5A6 [Occ=Once]
                                    ww2_sg5A7 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sg5A2 of sat_sg5A8 {
                __DEFAULT ->
                    Data.Functor.Product.$w$ctraverse
                        $dTraversable_sg5A0
                        $dTraversable1_sg5A1
                        sat_sg5A8
                        eta_sg5A3
                        ww1_sg5A6
                        ww2_sg5A7;
              };
        };

Data.Functor.Product.$fTraversableProduct_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Product.Product f g (m a)
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg5A9
           $dTraversable1_sg5Aa
           $dMonad_sg5Ab
           eta_sg5Ac]
        case eta_sg5Ac of {
          Data.Functor.Product.Pair ww1_sg5Ae [Occ=Once]
                                    ww2_sg5Af [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sg5Ab of sat_sg5Ag {
                __DEFAULT ->
                    Data.Functor.Product.$w$ctraverse
                        $dTraversable_sg5A9
                        $dTraversable1_sg5Aa
                        sat_sg5Ag
                        GHC.Base.id
                        ww1_sg5Ae
                        ww2_sg5Af;
              };
        };

Data.Functor.Product.$fTraversableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sg5Ah $dTraversable1_sg5Ai]
        let {
          sat_sg5Ao [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               Data.Functor.Product.Product f_ag3YG g_ag3YH (m a)
               -> m (Data.Functor.Product.Product f_ag3YG g_ag3YH a)
          [LclId] =
              [$dTraversable_sg5Ah $dTraversable1_sg5Ai] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$csequence
                      $dTraversable_sg5Ah $dTraversable1_sg5Ai eta_B2 eta_B1; } in
        let {
          sat_sg5An [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> Data.Functor.Product.Product f_ag3YG g_ag3YH a
               -> m (Data.Functor.Product.Product f_ag3YG g_ag3YH b)
          [LclId] =
              [$dTraversable_sg5Ah $dTraversable1_sg5Ai] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$cmapM
                      $dTraversable_sg5Ah $dTraversable1_sg5Ai eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5Am [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               Data.Functor.Product.Product f_ag3YG g_ag3YH (f a)
               -> f (Data.Functor.Product.Product f_ag3YG g_ag3YH a)
          [LclId] =
              [$dTraversable_sg5Ah $dTraversable1_sg5Ai] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$csequenceA
                      $dTraversable_sg5Ah $dTraversable1_sg5Ai eta_B2 eta_B1; } in
        let {
          sat_sg5Al [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> Data.Functor.Product.Product f_ag3YG g_ag3YH a
               -> f (Data.Functor.Product.Product f_ag3YG g_ag3YH b)
          [LclId] =
              [$dTraversable_sg5Ah $dTraversable1_sg5Ai] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$ctraverse
                      $dTraversable_sg5Ah $dTraversable1_sg5Ai eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5Ak [Occ=Once]
            :: Data.Foldable.Foldable
                 (Data.Functor.Product.Product f_ag3YG g_ag3YH)
          [LclId] =
              [$dTraversable_sg5Ah $dTraversable1_sg5Ai] \u []
                  Data.Functor.Product.$fTraversableProduct_$cp2Traversable
                      $dTraversable_sg5Ah $dTraversable1_sg5Ai; } in
        let {
          sat_sg5Aj [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Product.Product f_ag3YG g_ag3YH)
          [LclId] =
              [$dTraversable_sg5Ah $dTraversable1_sg5Ai] \u []
                  Data.Functor.Product.$fTraversableProduct_$cp1Traversable
                      $dTraversable_sg5Ah $dTraversable1_sg5Ai;
        } in 
          Data.Traversable.C:Traversable [sat_sg5Aj
                                          sat_sg5Ak
                                          sat_sg5Al
                                          sat_sg5Am
                                          sat_sg5An
                                          sat_sg5Ao];

Data.Functor.Product.$fApplicativeProduct_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b c.
     (a -> b -> c)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sg5Ap w1_sg5Aq w2_sg5Ar w3_sg5As w4_sg5At]
        case w3_sg5As of {
          Data.Functor.Product.Pair ww1_sg5Av [Occ=Once]
                                    ww2_sg5Aw [Occ=Once] ->
              case w4_sg5At of {
                Data.Functor.Product.Pair ww4_sg5Ay [Occ=Once]
                                          ww5_sg5Az [Occ=Once] ->
                    let {
                      sat_sg5AB [Occ=Once] :: g_sg4UK c_sg4UP
                      [LclId] =
                          [w1_sg5Aq w2_sg5Ar ww2_sg5Aw ww5_sg5Az] \u []
                              GHC.Base.liftA2 w1_sg5Aq w2_sg5Ar ww2_sg5Aw ww5_sg5Az; } in
                    let {
                      sat_sg5AA [Occ=Once] :: f_sg4UJ c_sg4UP
                      [LclId] =
                          [w_sg5Ap w2_sg5Ar ww1_sg5Av ww4_sg5Ay] \u []
                              GHC.Base.liftA2 w_sg5Ap w2_sg5Ar ww1_sg5Av ww4_sg5Ay;
                    } in  Data.Functor.Product.Pair [sat_sg5AA sat_sg5AB];
              };
        };

Data.Functor.Product.$fApplicativeProduct_$c<*>
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Product.Product f g (a -> b)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sg5AC $dApplicative1_sg5AD ds_sg5AE ds1_sg5AF]
        case ds_sg5AE of {
          Data.Functor.Product.Pair f1_sg5AH [Occ=Once]
                                    g1_sg5AI [Occ=Once] ->
              case ds1_sg5AF of {
                Data.Functor.Product.Pair x_sg5AK [Occ=Once] y_sg5AL [Occ=Once] ->
                    let {
                      sat_sg5AN [Occ=Once] :: g_ag3Xi b_ag3XJ
                      [LclId] =
                          [$dApplicative1_sg5AD g1_sg5AI y_sg5AL] \u []
                              GHC.Base.<*> $dApplicative1_sg5AD g1_sg5AI y_sg5AL; } in
                    let {
                      sat_sg5AM [Occ=Once] :: f_ag3Xh b_ag3XJ
                      [LclId] =
                          [$dApplicative_sg5AC f1_sg5AH x_sg5AK] \u []
                              GHC.Base.<*> $dApplicative_sg5AC f1_sg5AH x_sg5AK;
                    } in  Data.Functor.Product.Pair [sat_sg5AM sat_sg5AN];
              };
        };

Data.Functor.Product.$fApplicativeProduct_$cpure
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a. a -> Data.Functor.Product.Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U),A,A,A,A)><L,1*U(A,1*C1(U),A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sg5AO $dApplicative1_sg5AP x_sg5AQ]
        let {
          sat_sg5AS [Occ=Once] :: g_ag3Xi a_ag3Xs
          [LclId] =
              [$dApplicative1_sg5AP x_sg5AQ] \u []
                  GHC.Base.pure $dApplicative1_sg5AP x_sg5AQ; } in
        let {
          sat_sg5AR [Occ=Once] :: f_ag3Xh a_ag3Xs
          [LclId] =
              [$dApplicative_sg5AO x_sg5AQ] \u []
                  GHC.Base.pure $dApplicative_sg5AO x_sg5AQ;
        } in  Data.Functor.Product.Pair [sat_sg5AR sat_sg5AS];

Data.Functor.Product.$fApplicativeProduct_$cp1Applicative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Functor (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sg5AT $dApplicative1_sg5AU]
        let {
          sat_sg5AW [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor g_ag3Xi
          [LclId] =
              [$dApplicative1_sg5AU] \u []
                  GHC.Base.$p1Applicative $dApplicative1_sg5AU; } in
        let {
          sat_sg5AV [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_ag3Xh
          [LclId] =
              [$dApplicative_sg5AT] \u []
                  GHC.Base.$p1Applicative $dApplicative_sg5AT;
        } in  Data.Functor.Product.$fFunctorProduct sat_sg5AV sat_sg5AW;

Data.Functor.Product.$fApplicativeProduct1
  :: forall a b. a -> b -> b
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sg5AX eta_B1] GHC.Base.breakpoint eta_B1;

Data.Functor.Product.$w$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b. f a -> g a -> f b -> g b -> (# f b, g b #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5AY w1_sg5AZ ww_sg5B0 ww1_sg5B1 ww2_sg5B2 ww3_sg5B3]
        let {
          sat_sg5B9 [Occ=Once] :: g_sg4V8 b_sg4Vc
          [LclId] =
              [w1_sg5AZ ww1_sg5B1 ww3_sg5B3] \u []
                  let {
                    sat_sg5B8 [Occ=Once] :: g_sg4V8 (b_sg4Vc -> b_sg4Vc)
                    [LclId] =
                        [w1_sg5AZ ww1_sg5B1] \u []
                            case GHC.Base.$p1Applicative w1_sg5AZ of sat_sg5B7 {
                              __DEFAULT ->
                                  GHC.Base.fmap
                                      sat_sg5B7
                                      Data.Functor.Product.$fApplicativeProduct1
                                      ww1_sg5B1;
                            };
                  } in  GHC.Base.<*> w1_sg5AZ sat_sg5B8 ww3_sg5B3; } in
        let {
          sat_sg5B6 [Occ=Once] :: f_sg4V7 b_sg4Vc
          [LclId] =
              [w_sg5AY ww_sg5B0 ww2_sg5B2] \u []
                  let {
                    sat_sg5B5 [Occ=Once] :: f_sg4V7 (b_sg4Vc -> b_sg4Vc)
                    [LclId] =
                        [w_sg5AY ww_sg5B0] \u []
                            case GHC.Base.$p1Applicative w_sg5AY of sat_sg5B4 {
                              __DEFAULT ->
                                  GHC.Base.fmap
                                      sat_sg5B4 Data.Functor.Product.$fApplicativeProduct1 ww_sg5B0;
                            };
                  } in  GHC.Base.<*> w_sg5AY sat_sg5B5 ww2_sg5B2;
        } in  (#,#) [sat_sg5B6 sat_sg5B9];

Data.Functor.Product.$fApplicativeProduct_$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sg5Ba w1_sg5Bb w2_sg5Bc w3_sg5Bd]
        case w2_sg5Bc of {
          Data.Functor.Product.Pair ww1_sg5Bf [Occ=Once]
                                    ww2_sg5Bg [Occ=Once] ->
              case w3_sg5Bd of {
                Data.Functor.Product.Pair ww4_sg5Bi [Occ=Once]
                                          ww5_sg5Bj [Occ=Once] ->
                    case
                        Data.Functor.Product.$w$c*>
                            w_sg5Ba w1_sg5Bb ww1_sg5Bf ww2_sg5Bg ww4_sg5Bi ww5_sg5Bj
                    of
                    { (#,#) ww7_sg5Bl [Occ=Once] ww8_sg5Bm [Occ=Once] ->
                          Data.Functor.Product.Pair [ww7_sg5Bl ww8_sg5Bm];
                    };
              };
        };

Data.Functor.Product.$fApplicativeProduct_$c<*
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sg5Bn $dApplicative1_sg5Bo w_sg5Bp w1_sg5Bq]
        case w_sg5Bp of {
          Data.Functor.Product.Pair ww1_sg5Bs [Occ=Once]
                                    ww2_sg5Bt [Occ=Once] ->
              case w1_sg5Bq of {
                Data.Functor.Product.Pair ww4_sg5Bv [Occ=Once]
                                          ww5_sg5Bw [Occ=Once] ->
                    let {
                      sat_sg5By [Occ=Once] :: g_ag3Xi a_ag3Yx
                      [LclId] =
                          [$dApplicative1_sg5Bo ww2_sg5Bt ww5_sg5Bw] \u []
                              GHC.Base.liftA2
                                  $dApplicative1_sg5Bo GHC.Base.const ww2_sg5Bt ww5_sg5Bw; } in
                    let {
                      sat_sg5Bx [Occ=Once] :: f_ag3Xh a_ag3Yx
                      [LclId] =
                          [$dApplicative_sg5Bn ww1_sg5Bs ww4_sg5Bv] \u []
                              GHC.Base.liftA2
                                  $dApplicative_sg5Bn GHC.Base.const ww1_sg5Bs ww4_sg5Bv;
                    } in  Data.Functor.Product.Pair [sat_sg5Bx sat_sg5By];
              };
        };

Data.Functor.Product.$fApplicativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Applicative (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)><L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>m] =
    [] \r [$dApplicative_sg5Bz $dApplicative1_sg5BA]
        let {
          sat_sg5BG [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
          [LclId] =
              [$dApplicative_sg5Bz $dApplicative1_sg5BA] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$c<*
                      $dApplicative_sg5Bz $dApplicative1_sg5BA eta_B2 eta_B1; } in
        let {
          sat_sg5BF [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
          [LclId] =
              [$dApplicative_sg5Bz $dApplicative1_sg5BA] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$c*>
                      $dApplicative_sg5Bz $dApplicative1_sg5BA eta_B2 eta_B1; } in
        let {
          sat_sg5BE [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi c
          [LclId] =
              [$dApplicative_sg5Bz $dApplicative1_sg5BA] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$cliftA2
                      $dApplicative_sg5Bz $dApplicative1_sg5BA eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5BD [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Xh g_ag3Xi (a -> b)
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
          [LclId] =
              [$dApplicative_sg5Bz $dApplicative1_sg5BA] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$c<*>
                      $dApplicative_sg5Bz $dApplicative1_sg5BA eta_B2 eta_B1; } in
        let {
          sat_sg5BC [Occ=Once]
            :: forall a. a -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
          [LclId] =
              [$dApplicative_sg5Bz $dApplicative1_sg5BA] \r [eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$cpure
                      $dApplicative_sg5Bz $dApplicative1_sg5BA eta_B1; } in
        let {
          sat_sg5BB [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Product.Product f_ag3Xh g_ag3Xi)
          [LclId] =
              [$dApplicative_sg5Bz $dApplicative1_sg5BA] \u []
                  Data.Functor.Product.$fApplicativeProduct_$cp1Applicative
                      $dApplicative_sg5Bz $dApplicative1_sg5BA;
        } in 
          GHC.Base.C:Applicative [sat_sg5BB
                                  sat_sg5BC
                                  sat_sg5BD
                                  sat_sg5BE
                                  sat_sg5BF
                                  sat_sg5BG];

Data.Functor.Product.$fAlternativeProduct_$c<|>
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     forall a.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A)><L,1*U(A,A,1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sg5BH $dAlternative1_sg5BI ds_sg5BJ ds1_sg5BK]
        case ds_sg5BJ of {
          Data.Functor.Product.Pair x1_sg5BM [Occ=Once]
                                    y1_sg5BN [Occ=Once] ->
              case ds1_sg5BK of {
                Data.Functor.Product.Pair x2_sg5BP [Occ=Once]
                                          y2_sg5BQ [Occ=Once] ->
                    let {
                      sat_sg5BS [Occ=Once] :: g_ag3Wm a_ag3WM
                      [LclId] =
                          [$dAlternative1_sg5BI y1_sg5BN y2_sg5BQ] \u []
                              GHC.Base.<|> $dAlternative1_sg5BI y1_sg5BN y2_sg5BQ; } in
                    let {
                      sat_sg5BR [Occ=Once] :: f_ag3Wl a_ag3WM
                      [LclId] =
                          [$dAlternative_sg5BH x1_sg5BM x2_sg5BP] \u []
                              GHC.Base.<|> $dAlternative_sg5BH x1_sg5BM x2_sg5BP;
                    } in  Data.Functor.Product.Pair [sat_sg5BR sat_sg5BS];
              };
        };

Data.Functor.Product.$fAlternativeProduct_$cempty
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     forall a. Data.Functor.Product.Product f g a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A,A)><L,1*U(A,1*U,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sg5BT $dAlternative1_sg5BU]
        let {
          sat_sg5BW [Occ=Once] :: g_ag3Wm a_ag3Ww
          [LclId] =
              [$dAlternative1_sg5BU] \u []
                  GHC.Base.empty $dAlternative1_sg5BU; } in
        let {
          sat_sg5BV [Occ=Once] :: f_ag3Wl a_ag3Ww
          [LclId] =
              [$dAlternative_sg5BT] \u [] GHC.Base.empty $dAlternative_sg5BT;
        } in  Data.Functor.Product.Pair [sat_sg5BV sat_sg5BW];

Data.Functor.Product.$fAlternativeProduct_$cp1Alternative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     GHC.Base.Applicative (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)><L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sg5BX $dAlternative1_sg5BY]
        let {
          sat_sg5C0 [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative g_ag3Wm
          [LclId] =
              [$dAlternative1_sg5BY] \u []
                  GHC.Base.$p1Alternative $dAlternative1_sg5BY; } in
        let {
          sat_sg5BZ [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative f_ag3Wl
          [LclId] =
              [$dAlternative_sg5BX] \u []
                  GHC.Base.$p1Alternative $dAlternative_sg5BX;
        } in 
          Data.Functor.Product.$fApplicativeProduct sat_sg5BZ sat_sg5C0;

poly_some_v_rg5o0
  :: forall (f :: * -> *) (g :: * -> *) a.
     Data.Functor.Product.Product f g [a]
[GblId, Str=b] =
    [] \u [] poly_some_v_rg5o0;

Data.Functor.Product.$fAlternativeProduct_$csome [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     forall a.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g [a]
[GblId, Arity=3, Str=<B,A><B,A><B,1*H>b, Unf=OtherCon []] =
    [] \r [w_sg5C1 w1_sg5C2 w2_sg5C3]
        case w2_sg5C3 of {
          Data.Functor.Product.Pair _ [Occ=Dead] _ [Occ=Dead] ->
              poly_some_v_rg5o0;
        };

Data.Functor.Product.$fAlternativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     GHC.Base.Alternative (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)><L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>m] =
    [] \r [$dAlternative_sg5C7 $dAlternative1_sg5C8]
        let {
          sat_sg5Cd [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm [a]
          [LclId] =
              [$dAlternative_sg5C7 $dAlternative1_sg5C8] \r [eta_B1]
                  Data.Functor.Product.$fAlternativeProduct_$csome
                      $dAlternative_sg5C7 $dAlternative1_sg5C8 eta_B1; } in
        let {
          sat_sg5Cc [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm [a]
          [LclId] =
              [$dAlternative_sg5C7 $dAlternative1_sg5C8] \r [eta_B1]
                  Data.Functor.Product.$fAlternativeProduct_$csome
                      $dAlternative_sg5C7 $dAlternative1_sg5C8 eta_B1; } in
        let {
          sat_sg5Cb [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
          [LclId] =
              [$dAlternative_sg5C7 $dAlternative1_sg5C8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fAlternativeProduct_$c<|>
                      $dAlternative_sg5C7 $dAlternative1_sg5C8 eta_B2 eta_B1; } in
        let {
          sat_sg5Ca [Occ=Once]
            :: forall a. Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
          [LclId] =
              [$dAlternative_sg5C7 $dAlternative1_sg5C8] \u []
                  Data.Functor.Product.$fAlternativeProduct_$cempty
                      $dAlternative_sg5C7 $dAlternative1_sg5C8; } in
        let {
          sat_sg5C9 [Occ=Once]
            :: GHC.Base.Applicative
                 (Data.Functor.Product.Product f_ag3Wl g_ag3Wm)
          [LclId] =
              [$dAlternative_sg5C7 $dAlternative1_sg5C8] \u []
                  Data.Functor.Product.$fAlternativeProduct_$cp1Alternative
                      $dAlternative_sg5C7 $dAlternative1_sg5C8;
        } in 
          GHC.Base.C:Alternative [sat_sg5C9
                                  sat_sg5Ca
                                  sat_sg5Cb
                                  sat_sg5Cc
                                  sat_sg5Cd];

Data.Functor.Product.$fMonadProduct_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> (a -> Data.Functor.Product.Product f g b)
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><L,C(U(1*U,1*U))>m,
 Unf=OtherCon []] =
    [] \r [w_sg5Ce w1_sg5Cf w2_sg5Cg w3_sg5Ch]
        case w2_sg5Cg of {
          Data.Functor.Product.Pair ww1_sg5Cj [Occ=Once]
                                    ww2_sg5Ck [Occ=Once] ->
              let {
                sat_sg5Cw [Occ=Once] :: g_sg4VS b_sg4VW
                [LclId] =
                    [w1_sg5Cf w3_sg5Ch ww2_sg5Ck] \u []
                        let {
                          sat_sg5Cv [Occ=Once] :: a_sg4VV -> g_sg4VS b_sg4VW
                          [LclId] =
                              [w3_sg5Ch] \r [x_sg5Cr]
                                  case w3_sg5Ch x_sg5Cr of {
                                    Data.Functor.Product.Pair _ [Occ=Dead] b1_sg5Cu [Occ=Once] ->
                                        b1_sg5Cu;
                                  };
                        } in  GHC.Base.>>= w1_sg5Cf ww2_sg5Ck sat_sg5Cv; } in
              let {
                sat_sg5Cq [Occ=Once] :: f_sg4VR b_sg4VW
                [LclId] =
                    [w_sg5Ce w3_sg5Ch ww1_sg5Cj] \u []
                        let {
                          sat_sg5Cp [Occ=Once] :: a_sg4VV -> f_sg4VR b_sg4VW
                          [LclId] =
                              [w3_sg5Ch] \r [x_sg5Cl]
                                  case w3_sg5Ch x_sg5Cl of {
                                    Data.Functor.Product.Pair a1_sg5Cn [Occ=Once] _ [Occ=Dead] ->
                                        a1_sg5Cn;
                                  };
                        } in  GHC.Base.>>= w_sg5Ce ww1_sg5Cj sat_sg5Cp;
              } in  Data.Functor.Product.Pair [sat_sg5Cq sat_sg5Cw];
        };

Data.Functor.Product.$fMonadProduct_$cp1Monad
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     GHC.Base.Applicative (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)><L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonad_sg5Cx $dMonad1_sg5Cy]
        let {
          sat_sg5CA [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative g_ag3Uv
          [LclId] =
              [$dMonad1_sg5Cy] \u [] GHC.Base.$p1Monad $dMonad1_sg5Cy; } in
        let {
          sat_sg5Cz [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative f_ag3Uu
          [LclId] =
              [$dMonad_sg5Cx] \u [] GHC.Base.$p1Monad $dMonad_sg5Cx;
        } in 
          Data.Functor.Product.$fApplicativeProduct sat_sg5Cz sat_sg5CA;

Data.Functor.Product.$fMonadProduct_$creturn [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     forall a. a -> Data.Functor.Product.Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sg5CB w1_sg5CC w2_sg5CD]
        let {
          sat_sg5CH [Occ=Once] :: g_sg4W9 a_sg4Wc
          [LclId] =
              [w1_sg5CC w2_sg5CD] \u []
                  case GHC.Base.$p1Monad w1_sg5CC of sat_sg5CG {
                    __DEFAULT -> GHC.Base.pure sat_sg5CG w2_sg5CD;
                  }; } in
        let {
          sat_sg5CF [Occ=Once] :: f_sg4W8 a_sg4Wc
          [LclId] =
              [w_sg5CB w2_sg5CD] \u []
                  case GHC.Base.$p1Monad w_sg5CB of sat_sg5CE {
                    __DEFAULT -> GHC.Base.pure sat_sg5CE w2_sg5CD;
                  };
        } in  Data.Functor.Product.Pair [sat_sg5CF sat_sg5CH];

Data.Functor.Product.$fMonadProduct_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonad_sg5CI $dMonad1_sg5CJ eta_sg5CK eta1_sg5CL]
        case eta_sg5CK of {
          Data.Functor.Product.Pair m_sg5CN [Occ=Once] n_sg5CO [Occ=Once] ->
              let {
                sat_sg5D0 [Occ=Once] :: g_ag3Uv b_ag3VX
                [LclId] =
                    [$dMonad1_sg5CJ eta1_sg5CL n_sg5CO] \u []
                        let {
                          sat_sg5CZ [Occ=Once] :: a_ag3VW -> g_ag3Uv b_ag3VX
                          [LclId] =
                              [eta1_sg5CL] \r [x_sg5CV]
                                  case eta1_sg5CL of {
                                    Data.Functor.Product.Pair _ [Occ=Dead] b1_sg5CY [Occ=Once] ->
                                        b1_sg5CY;
                                  };
                        } in  GHC.Base.>>= $dMonad1_sg5CJ n_sg5CO sat_sg5CZ; } in
              let {
                sat_sg5CU [Occ=Once] :: f_ag3Uu b_ag3VX
                [LclId] =
                    [$dMonad_sg5CI eta1_sg5CL m_sg5CN] \u []
                        let {
                          sat_sg5CT [Occ=Once] :: a_ag3VW -> f_ag3Uu b_ag3VX
                          [LclId] =
                              [eta1_sg5CL] \r [x_sg5CP]
                                  case eta1_sg5CL of {
                                    Data.Functor.Product.Pair a1_sg5CR [Occ=Once] _ [Occ=Dead] ->
                                        a1_sg5CR;
                                  };
                        } in  GHC.Base.>>= $dMonad_sg5CI m_sg5CN sat_sg5CT;
              } in  Data.Functor.Product.Pair [sat_sg5CU sat_sg5D0];
        };

lvl4_rg5o1
  :: forall (f :: * -> *) (g :: * -> *) a.
     [GHC.Types.Char] -> Data.Functor.Product.Product f g a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sg5D1] GHC.Err.errorWithoutStackTrace eta_sg5D1;

Data.Functor.Product.$fMonadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)><L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>m] =
    [] \r [$dMonad_sg5D2 $dMonad1_sg5D3]
        let {
          sat_sg5D7 [Occ=Once]
            :: forall a. a -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv a
          [LclId] =
              [$dMonad_sg5D2 $dMonad1_sg5D3] \r [eta_B1]
                  Data.Functor.Product.$fMonadProduct_$creturn
                      $dMonad_sg5D2 $dMonad1_sg5D3 eta_B1; } in
        let {
          sat_sg5D6 [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Uu g_ag3Uv a
               -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b
               -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b
          [LclId] =
              [$dMonad_sg5D2 $dMonad1_sg5D3] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadProduct_$c>>
                      $dMonad_sg5D2 $dMonad1_sg5D3 eta_B2 eta_B1; } in
        let {
          sat_sg5D5 [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Uu g_ag3Uv a
               -> (a -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b)
               -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b
          [LclId] =
              [$dMonad_sg5D2 $dMonad1_sg5D3] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadProduct_$c>>=
                      $dMonad_sg5D2 $dMonad1_sg5D3 eta_B2 eta_B1; } in
        let {
          sat_sg5D4 [Occ=Once]
            :: GHC.Base.Applicative
                 (Data.Functor.Product.Product f_ag3Uu g_ag3Uv)
          [LclId] =
              [$dMonad_sg5D2 $dMonad1_sg5D3] \u []
                  Data.Functor.Product.$fMonadProduct_$cp1Monad
                      $dMonad_sg5D2 $dMonad1_sg5D3;
        } in 
          GHC.Base.C:Monad [sat_sg5D4
                            sat_sg5D5
                            sat_sg5D6
                            sat_sg5D7
                            lvl4_rg5o1];

Data.Functor.Product.$fMonadPlusProduct_$cmplus
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     forall a.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(U)))><L,1*U(A,A,A,1*C1(C1(U)))><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sg5D8 $dMonadPlus1_sg5D9 ds_sg5Da ds1_sg5Db]
        case ds_sg5Da of {
          Data.Functor.Product.Pair x1_sg5Dd [Occ=Once]
                                    y1_sg5De [Occ=Once] ->
              case ds1_sg5Db of {
                Data.Functor.Product.Pair x2_sg5Dg [Occ=Once]
                                          y2_sg5Dh [Occ=Once] ->
                    let {
                      sat_sg5Dj [Occ=Once] :: g_ag3TL a_ag3Uf
                      [LclId] =
                          [$dMonadPlus1_sg5D9 y1_sg5De y2_sg5Dh] \u []
                              GHC.Base.mplus $dMonadPlus1_sg5D9 y1_sg5De y2_sg5Dh; } in
                    let {
                      sat_sg5Di [Occ=Once] :: f_ag3TK a_ag3Uf
                      [LclId] =
                          [$dMonadPlus_sg5D8 x1_sg5Dd x2_sg5Dg] \u []
                              GHC.Base.mplus $dMonadPlus_sg5D8 x1_sg5Dd x2_sg5Dg;
                    } in  Data.Functor.Product.Pair [sat_sg5Di sat_sg5Dj];
              };
        };

Data.Functor.Product.$fMonadPlusProduct_$cmzero
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     forall a. Data.Functor.Product.Product f g a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*U,A)><L,1*U(A,A,1*U,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sg5Dk $dMonadPlus1_sg5Dl]
        let {
          sat_sg5Dn [Occ=Once] :: g_ag3TL a_ag3TZ
          [LclId] =
              [$dMonadPlus1_sg5Dl] \u [] GHC.Base.mzero $dMonadPlus1_sg5Dl; } in
        let {
          sat_sg5Dm [Occ=Once] :: f_ag3TK a_ag3TZ
          [LclId] =
              [$dMonadPlus_sg5Dk] \u [] GHC.Base.mzero $dMonadPlus_sg5Dk;
        } in  Data.Functor.Product.Pair [sat_sg5Dm sat_sg5Dn];

Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A)><L,1*U(A,1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sg5Do $dMonadPlus1_sg5Dp]
        let {
          sat_sg5Dr [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_ag3TL
          [LclId] =
              [$dMonadPlus1_sg5Dp] \u []
                  GHC.Base.$p2MonadPlus $dMonadPlus1_sg5Dp; } in
        let {
          sat_sg5Dq [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_ag3TK
          [LclId] =
              [$dMonadPlus_sg5Do] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_sg5Do;
        } in  Data.Functor.Product.$fMonadProduct sat_sg5Dq sat_sg5Dr;

Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     GHC.Base.Alternative (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sg5Ds $dMonadPlus1_sg5Dt]
        let {
          sat_sg5Dv [Occ=Once,
                     Dmd=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>]
            :: GHC.Base.Alternative g_ag3TL
          [LclId] =
              [$dMonadPlus1_sg5Dt] \u []
                  GHC.Base.$p1MonadPlus $dMonadPlus1_sg5Dt; } in
        let {
          sat_sg5Du [Occ=Once,
                     Dmd=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>]
            :: GHC.Base.Alternative f_ag3TK
          [LclId] =
              [$dMonadPlus_sg5Ds] \u [] GHC.Base.$p1MonadPlus $dMonadPlus_sg5Ds;
        } in 
          Data.Functor.Product.$fAlternativeProduct sat_sg5Du sat_sg5Dv;

Data.Functor.Product.$fMonadPlusProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     GHC.Base.MonadPlus (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),1*U,C(C1(U)))><L,U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),1*U,C(C1(U)))>m] =
    [] \r [$dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx]
        let {
          sat_sg5DB [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3TK g_ag3TL a
               -> Data.Functor.Product.Product f_ag3TK g_ag3TL a
               -> Data.Functor.Product.Product f_ag3TK g_ag3TL a
          [LclId] =
              [$dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadPlusProduct_$cmplus
                      $dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx eta_B2 eta_B1; } in
        let {
          sat_sg5DA [Occ=Once]
            :: forall a. Data.Functor.Product.Product f_ag3TK g_ag3TL a
          [LclId] =
              [$dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx] \u []
                  Data.Functor.Product.$fMonadPlusProduct_$cmzero
                      $dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx; } in
        let {
          sat_sg5Dz [Occ=Once]
            :: GHC.Base.Monad (Data.Functor.Product.Product f_ag3TK g_ag3TL)
          [LclId] =
              [$dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx] \u []
                  Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus
                      $dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx; } in
        let {
          sat_sg5Dy [Occ=Once]
            :: GHC.Base.Alternative
                 (Data.Functor.Product.Product f_ag3TK g_ag3TL)
          [LclId] =
              [$dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx] \u []
                  Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus
                      $dMonadPlus_sg5Dw $dMonadPlus1_sg5Dx;
        } in 
          GHC.Base.C:MonadPlus [sat_sg5Dy sat_sg5Dz sat_sg5DA sat_sg5DB];

Data.Functor.Product.$fMonadFixProduct_$cmfix [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) =>
     forall a.
     (a -> Data.Functor.Product.Product f g a)
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U))><L,1*U(A,1*C1(U))><L,C(U(1*U,1*U))>m,
 Unf=OtherCon []] =
    [] \r [w_sg5DC w1_sg5DD w2_sg5DE]
        let {
          sat_sg5DQ [Occ=Once] :: g_sg4Wj a_sg4Wm
          [LclId] =
              [w1_sg5DD w2_sg5DE] \u []
                  let {
                    sat_sg5DP [Occ=Once] :: a_sg4Wm -> g_sg4Wj a_sg4Wm
                    [LclId] =
                        [w2_sg5DE] \r [x_sg5DL]
                            case w2_sg5DE x_sg5DL of {
                              Data.Functor.Product.Pair _ [Occ=Dead] b_sg5DO [Occ=Once] ->
                                  b_sg5DO;
                            };
                  } in  Control.Monad.Fix.mfix w1_sg5DD sat_sg5DP; } in
        let {
          sat_sg5DK [Occ=Once] :: f_sg4Wi a_sg4Wm
          [LclId] =
              [w_sg5DC w2_sg5DE] \u []
                  let {
                    sat_sg5DJ [Occ=Once] :: a_sg4Wm -> f_sg4Wi a_sg4Wm
                    [LclId] =
                        [w2_sg5DE] \r [x_sg5DF]
                            case w2_sg5DE x_sg5DF of {
                              Data.Functor.Product.Pair a1_sg5DH [Occ=Once] _ [Occ=Dead] ->
                                  a1_sg5DH;
                            };
                  } in  Control.Monad.Fix.mfix w_sg5DC sat_sg5DJ;
        } in  Data.Functor.Product.Pair [sat_sg5DK sat_sg5DQ];

Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A)><L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadFix_sg5DR $dMonadFix1_sg5DS]
        let {
          sat_sg5DU [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_ag3Sn
          [LclId] =
              [$dMonadFix1_sg5DS] \u []
                  Control.Monad.Fix.$p1MonadFix $dMonadFix1_sg5DS; } in
        let {
          sat_sg5DT [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_ag3Sm
          [LclId] =
              [$dMonadFix_sg5DR] \u []
                  Control.Monad.Fix.$p1MonadFix $dMonadFix_sg5DR;
        } in  Data.Functor.Product.$fMonadProduct sat_sg5DT sat_sg5DU;

Data.Functor.Product.$fMonadFixProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) =>
     Control.Monad.Fix.MonadFix (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),C(U))><L,U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),C(U))>m] =
    [] \r [$dMonadFix_sg5DV $dMonadFix1_sg5DW]
        let {
          sat_sg5DY [Occ=Once]
            :: forall a.
               (a -> Data.Functor.Product.Product f_ag3Sm g_ag3Sn a)
               -> Data.Functor.Product.Product f_ag3Sm g_ag3Sn a
          [LclId] =
              [$dMonadFix_sg5DV $dMonadFix1_sg5DW] \r [eta_B1]
                  Data.Functor.Product.$fMonadFixProduct_$cmfix
                      $dMonadFix_sg5DV $dMonadFix1_sg5DW eta_B1; } in
        let {
          sat_sg5DX [Occ=Once]
            :: GHC.Base.Monad (Data.Functor.Product.Product f_ag3Sm g_ag3Sn)
          [LclId] =
              [$dMonadFix_sg5DV $dMonadFix1_sg5DW] \u []
                  Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix
                      $dMonadFix_sg5DV $dMonadFix1_sg5DW;
        } in  Control.Monad.Fix.C:MonadFix [sat_sg5DX sat_sg5DY];

Data.Functor.Product.$fMonadZipProduct_$cmzipWith [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b c.
     (a -> b -> c)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sg5DZ w1_sg5E0 w2_sg5E1 w3_sg5E2 w4_sg5E3]
        case w3_sg5E2 of {
          Data.Functor.Product.Pair ww1_sg5E5 [Occ=Once]
                                    ww2_sg5E6 [Occ=Once] ->
              case w4_sg5E3 of {
                Data.Functor.Product.Pair ww4_sg5E8 [Occ=Once]
                                          ww5_sg5E9 [Occ=Once] ->
                    let {
                      sat_sg5Eb [Occ=Once] :: g_sg4Wt c_sg4Wy
                      [LclId] =
                          [w1_sg5E0 w2_sg5E1 ww2_sg5E6 ww5_sg5E9] \u []
                              Control.Monad.Zip.mzipWith
                                  w1_sg5E0 w2_sg5E1 ww2_sg5E6 ww5_sg5E9; } in
                    let {
                      sat_sg5Ea [Occ=Once] :: f_sg4Ws c_sg4Wy
                      [LclId] =
                          [w_sg5DZ w2_sg5E1 ww1_sg5E5 ww4_sg5E8] \u []
                              Control.Monad.Zip.mzipWith w_sg5DZ w2_sg5E1 ww1_sg5E5 ww4_sg5E8;
                    } in  Data.Functor.Product.Pair [sat_sg5Ea sat_sg5Eb];
              };
        };

Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sg5Ec $dMonadZip1_sg5Ed]
        let {
          sat_sg5Ef [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_ag3Rx
          [LclId] =
              [$dMonadZip1_sg5Ed] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip1_sg5Ed; } in
        let {
          sat_sg5Ee [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_ag3Rw
          [LclId] =
              [$dMonadZip_sg5Ec] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sg5Ec;
        } in  Data.Functor.Product.$fMonadProduct sat_sg5Ee sat_sg5Ef;

Data.Functor.Product.$fMonadZipProduct_$cmzip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sg5Eg $dMonadZip1_sg5Eh w_sg5Ei w1_sg5Ej]
        case w_sg5Ei of {
          Data.Functor.Product.Pair ww1_sg5El [Occ=Once]
                                    ww2_sg5Em [Occ=Once] ->
              case w1_sg5Ej of {
                Data.Functor.Product.Pair ww4_sg5Eo [Occ=Once]
                                          ww5_sg5Ep [Occ=Once] ->
                    let {
                      sat_sg5Er [Occ=Once] :: g_ag3Rx (a_ag3RH, b_ag3RI)
                      [LclId] =
                          [$dMonadZip1_sg5Eh ww2_sg5Em ww5_sg5Ep] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip1_sg5Eh GHC.Tuple.(,) ww2_sg5Em ww5_sg5Ep; } in
                    let {
                      sat_sg5Eq [Occ=Once] :: f_ag3Rw (a_ag3RH, b_ag3RI)
                      [LclId] =
                          [$dMonadZip_sg5Eg ww1_sg5El ww4_sg5Eo] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip_sg5Eg GHC.Tuple.(,) ww1_sg5El ww4_sg5Eo;
                    } in  Data.Functor.Product.Pair [sat_sg5Eq sat_sg5Er];
              };
        };

Data.Functor.Product.$w$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     Data.Functor.Product.Product f g (a, b)
     -> (# Data.Functor.Product.Product f g a,
           Data.Functor.Product.Product f g b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5Es w1_sg5Et w2_sg5Eu]
        let {
          $dMonad_sg5Ev [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_sg4WQ
          [LclId] =
              [w_sg5Es] \u [] Control.Monad.Zip.$p1MonadZip w_sg5Es; } in
        let {
          $dMonad1_sg5Ew [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_sg4WR
          [LclId] =
              [w1_sg5Et] \u [] Control.Monad.Zip.$p1MonadZip w1_sg5Et; } in
        let {
          sat_sg5Fa [Occ=Once]
            :: Data.Functor.Product.Product f_sg4WQ g_sg4WR b_sg4WV
          [LclId] =
              [w2_sg5Eu $dMonad_sg5Ev $dMonad1_sg5Ew] \u []
                  case w2_sg5Eu of {
                    Data.Functor.Product.Pair m_sg5ES [Occ=Once] n_sg5ET [Occ=Once] ->
                        let {
                          sat_sg5F9 [Occ=Once] :: g_sg4WR b_sg4WV
                          [LclId] =
                              [$dMonad1_sg5Ew n_sg5ET] \u []
                                  let {
                                    lvl9_sg5F2 [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative g_sg4WR
                                    [LclId] =
                                        [$dMonad1_sg5Ew] \u []
                                            GHC.Base.$p1Monad $dMonad1_sg5Ew; } in
                                  let {
                                    sat_sg5F8 [Occ=Once] :: (a_sg4WU, b_sg4WV) -> g_sg4WR b_sg4WV
                                    [LclId] =
                                        [lvl9_sg5F2] \r [x_sg5F3]
                                            let {
                                              sat_sg5F7 [Occ=Once] :: b_sg4WV
                                              [LclId] =
                                                  [x_sg5F3] \u []
                                                      case x_sg5F3 of {
                                                        (,) _ [Occ=Dead] y_sg5F6 [Occ=Once] ->
                                                            y_sg5F6;
                                                      };
                                            } in  GHC.Base.pure lvl9_sg5F2 sat_sg5F7;
                                  } in  GHC.Base.>>= $dMonad1_sg5Ew n_sg5ET sat_sg5F8; } in
                        let {
                          sat_sg5F1 [Occ=Once] :: f_sg4WQ b_sg4WV
                          [LclId] =
                              [$dMonad_sg5Ev m_sg5ES] \u []
                                  let {
                                    lvl9_sg5EU [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative f_sg4WQ
                                    [LclId] =
                                        [$dMonad_sg5Ev] \u [] GHC.Base.$p1Monad $dMonad_sg5Ev; } in
                                  let {
                                    sat_sg5F0 [Occ=Once] :: (a_sg4WU, b_sg4WV) -> f_sg4WQ b_sg4WV
                                    [LclId] =
                                        [lvl9_sg5EU] \r [x_sg5EV]
                                            let {
                                              sat_sg5EZ [Occ=Once] :: b_sg4WV
                                              [LclId] =
                                                  [x_sg5EV] \u []
                                                      case x_sg5EV of {
                                                        (,) _ [Occ=Dead] y_sg5EY [Occ=Once] ->
                                                            y_sg5EY;
                                                      };
                                            } in  GHC.Base.pure lvl9_sg5EU sat_sg5EZ;
                                  } in  GHC.Base.>>= $dMonad_sg5Ev m_sg5ES sat_sg5F0;
                        } in  Data.Functor.Product.Pair [sat_sg5F1 sat_sg5F9];
                  }; } in
        let {
          sat_sg5EQ [Occ=Once]
            :: Data.Functor.Product.Product f_sg4WQ g_sg4WR a_sg4WU
          [LclId] =
              [w2_sg5Eu $dMonad_sg5Ev $dMonad1_sg5Ew] \u []
                  case w2_sg5Eu of {
                    Data.Functor.Product.Pair m_sg5Ey [Occ=Once] n_sg5Ez [Occ=Once] ->
                        let {
                          sat_sg5EP [Occ=Once] :: g_sg4WR a_sg4WU
                          [LclId] =
                              [$dMonad1_sg5Ew n_sg5Ez] \u []
                                  let {
                                    lvl9_sg5EI [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative g_sg4WR
                                    [LclId] =
                                        [$dMonad1_sg5Ew] \u []
                                            GHC.Base.$p1Monad $dMonad1_sg5Ew; } in
                                  let {
                                    sat_sg5EO [Occ=Once] :: (a_sg4WU, b_sg4WV) -> g_sg4WR a_sg4WU
                                    [LclId] =
                                        [lvl9_sg5EI] \r [x_sg5EJ]
                                            let {
                                              sat_sg5EN [Occ=Once] :: a_sg4WU
                                              [LclId] =
                                                  [x_sg5EJ] \u []
                                                      case x_sg5EJ of {
                                                        (,) x1_sg5EL [Occ=Once] _ [Occ=Dead] ->
                                                            x1_sg5EL;
                                                      };
                                            } in  GHC.Base.pure lvl9_sg5EI sat_sg5EN;
                                  } in  GHC.Base.>>= $dMonad1_sg5Ew n_sg5Ez sat_sg5EO; } in
                        let {
                          sat_sg5EH [Occ=Once] :: f_sg4WQ a_sg4WU
                          [LclId] =
                              [$dMonad_sg5Ev m_sg5Ey] \u []
                                  let {
                                    lvl9_sg5EA [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative f_sg4WQ
                                    [LclId] =
                                        [$dMonad_sg5Ev] \u [] GHC.Base.$p1Monad $dMonad_sg5Ev; } in
                                  let {
                                    sat_sg5EG [Occ=Once] :: (a_sg4WU, b_sg4WV) -> f_sg4WQ a_sg4WU
                                    [LclId] =
                                        [lvl9_sg5EA] \r [x_sg5EB]
                                            let {
                                              sat_sg5EF [Occ=Once] :: a_sg4WU
                                              [LclId] =
                                                  [x_sg5EB] \u []
                                                      case x_sg5EB of {
                                                        (,) x1_sg5ED [Occ=Once] _ [Occ=Dead] ->
                                                            x1_sg5ED;
                                                      };
                                            } in  GHC.Base.pure lvl9_sg5EA sat_sg5EF;
                                  } in  GHC.Base.>>= $dMonad_sg5Ev m_sg5Ey sat_sg5EG;
                        } in  Data.Functor.Product.Pair [sat_sg5EH sat_sg5EP];
                  };
        } in  (#,#) [sat_sg5EQ sat_sg5Fa];

Data.Functor.Product.$fMonadZipProduct_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     Data.Functor.Product.Product f g (a, b)
     -> (Data.Functor.Product.Product f g a,
         Data.Functor.Product.Product f g b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sg5Fb w1_sg5Fc w2_sg5Fd]
        case Data.Functor.Product.$w$cmunzip w_sg5Fb w1_sg5Fc w2_sg5Fd of {
          (#,#) ww1_sg5Ff [Occ=Once] ww2_sg5Fg [Occ=Once] ->
              (,) [ww1_sg5Ff ww2_sg5Fg];
        };

Data.Functor.Product.$fMonadZipProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     Control.Monad.Zip.MonadZip (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)><L,U(U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sg5Fh $dMonadZip1_sg5Fi]
        let {
          sat_sg5Fm [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Rw g_ag3Rx (a, b)
               -> (Data.Functor.Product.Product f_ag3Rw g_ag3Rx a,
                   Data.Functor.Product.Product f_ag3Rw g_ag3Rx b)
          [LclId] =
              [$dMonadZip_sg5Fh $dMonadZip1_sg5Fi] \r [eta_B1]
                  Data.Functor.Product.$fMonadZipProduct_$cmunzip
                      $dMonadZip_sg5Fh $dMonadZip1_sg5Fi eta_B1; } in
        let {
          sat_sg5Fl [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx a
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx b
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx c
          [LclId] =
              [$dMonadZip_sg5Fh $dMonadZip1_sg5Fi] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadZipProduct_$cmzipWith
                      $dMonadZip_sg5Fh $dMonadZip1_sg5Fi eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg5Fk [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Rw g_ag3Rx a
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx b
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx (a, b)
          [LclId] =
              [$dMonadZip_sg5Fh $dMonadZip1_sg5Fi] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadZipProduct_$cmzip
                      $dMonadZip_sg5Fh $dMonadZip1_sg5Fi eta_B2 eta_B1; } in
        let {
          sat_sg5Fj [Occ=Once]
            :: GHC.Base.Monad (Data.Functor.Product.Product f_ag3Rw g_ag3Rx)
          [LclId] =
              [$dMonadZip_sg5Fh $dMonadZip1_sg5Fi] \u []
                  Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip
                      $dMonadZip_sg5Fh $dMonadZip1_sg5Fi;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sg5Fj
                                        sat_sg5Fk
                                        sat_sg5Fl
                                        sat_sg5Fm];

Data.Functor.Product.$fGeneric1Product_$cto1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Data.Functor.Product.Product f g) a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sg5Fn]
        case ds_sg5Fn of {
          GHC.Generics.:*: ds1_sg5Fp [Occ=Once] ds2_sg5Fq [Occ=Once] ->
              Data.Functor.Product.Pair [ds1_sg5Fp ds2_sg5Fq];
        };

Data.Functor.Product.$fGeneric1Product1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Product.Product f g a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Pair" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.Rec1 f)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.Rec1 g))
          a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_sg5Fr]
        case x_sg5Fr of {
          Data.Functor.Product.Pair g1_sg5Ft [Occ=Once]
                                    g2_sg5Fu [Occ=Once] ->
              GHC.Generics.:*: [g1_sg5Ft g2_sg5Fu];
        };

Data.Functor.Product.$fGeneric1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *).
     GHC.Generics.Generic1 (Data.Functor.Product.Product f g)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Functor.Product.$fGeneric1Product1
                                            Data.Functor.Product.$fGeneric1Product_$cto1];

Data.Functor.Product.$fGenericProduct_$cto
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Data.Functor.Product.Product f g a) x
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sg5Fv]
        case ds_sg5Fv of {
          GHC.Generics.:*: ds1_sg5Fx [Occ=Once] ds2_sg5Fy [Occ=Once] ->
              Data.Functor.Product.Pair [ds1_sg5Fx ds2_sg5Fy];
        };

Data.Functor.Product.$fGenericProduct1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     Data.Functor.Product.Product f g a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Pair" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R (f a))
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.K1 GHC.Generics.R (g a)))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x1_sg5Fz]
        case x1_sg5Fz of {
          Data.Functor.Product.Pair g1_sg5FB [Occ=Once]
                                    g2_sg5FC [Occ=Once] ->
              GHC.Generics.:*: [g1_sg5FB g2_sg5FC];
        };

Data.Functor.Product.$fGenericProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Generic (Data.Functor.Product.Product f g a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Product.$fGenericProduct1
                                           Data.Functor.Product.$fGenericProduct_$cto];

Data.Functor.Product.$fDataProduct_$cgfoldl
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g1. g1 -> c g1)
     -> Data.Functor.Product.Product f g a
     -> c (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg5FD
           $dTypeable1_sg5FE
           $dTypeable2_sg5FF
           $dTypeable3_sg5FG
           $dData_sg5FH
           $dData1_sg5FI
           k1_sg5FJ
           z_sg5FK
           ds_sg5FL]
        case ds_sg5FL of {
          Data.Functor.Product.Pair a1_sg5FN [Occ=Once]
                                    a2_sg5FO [Occ=Once] ->
              let {
                sat_sg5FQ [Occ=Once]
                  :: c_ag3Ll (g_ag3L6 a_ag3L7
                              -> Data.Functor.Product.Product f_ag3L5 g_ag3L6 a_ag3L7)
                [LclId] =
                    [$dData_sg5FH k1_sg5FJ z_sg5FK a1_sg5FN] \u []
                        let {
                          sat_sg5FP [Occ=Once]
                            :: c_ag3Ll (f_ag3L5 a_ag3L7
                                        -> g_ag3L6 a_ag3L7
                                        -> Data.Functor.Product.Product f_ag3L5 g_ag3L6 a_ag3L7)
                          [LclId] =
                              [z_sg5FK] \u [] z_sg5FK Data.Functor.Product.Pair;
                        } in  k1_sg5FJ $dData_sg5FH sat_sg5FP a1_sg5FN;
              } in  k1_sg5FJ $dData1_sg5FI sat_sg5FQ a2_sg5FO;
        };

Data.Functor.Product.$fDataProduct6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Product"#;

Data.Functor.Product.$fDataProduct5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Product.$fDataProduct6;

go61_rg5o2
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sg5FR _ys_sg5FS]
        case ds2_sg5FR of {
          [] -> GHC.List.badHead;
          : ipv_sg5FU [Occ=Once!] ipv1_sg5FV [Occ=Once] ->
              case _ys_sg5FS of {
                [] -> GHC.List.badHead;
                : ipv2_sg5FX [Occ=Once] ipv3_sg5FY [Occ=Once] ->
                    case ipv_sg5FU of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sg5G1 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case
                              GHC.Base.eqString ds4_sg5G1 Data.Functor.Product.$fRead1Product2
                          of
                          { GHC.Types.False -> go61_rg5o2 ipv1_sg5FV ipv3_sg5FY;
                            GHC.Types.True -> ipv2_sg5FX;
                          };
                    };
              };
        };

$cPair1_rg5o3 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cPair2_rg5o4];
Data.Functor.Product.$fDataProduct4 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Product.$cPair GHC.Types.[]];
Data.Functor.Product.$fDataProduct3 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Functor.Product.$fDataProduct4];
Data.Functor.Product.$tProduct :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Functor.Product.$fDataProduct5
                                       Data.Functor.Product.$fDataProduct3];
Data.Functor.Product.$cPair [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cPair1_rg5o3
                                     Data.Functor.Product.$fRead1Product2
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Functor.Product.$tProduct];
$cPair2_rg5o4 :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rg5o2 Data.Functor.Product.$fDataProduct4 Data.Data.mkConstr1;

Data.Functor.Product.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Product.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$trModule4];

Data.Functor.Product.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Product"#;

Data.Functor.Product.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$trModule2];

Data.Functor.Product.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Product.$trModule3
                                     Data.Functor.Product.$trModule1];

$krep_rg5o5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_rg5o6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rg5o5 GHC.Types.krep$*];

$krep2_rg5o7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rg5o6 $krep1_rg5o6];

Data.Functor.Product.$fDataProduct8 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rg5o6 $krep2_rg5o7];

$krep3_rg5o8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep4_rg5o9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_rg5oa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [3#];

$krep6_rg5ob :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rg5o9 $krep5_rg5oa];

$krep7_rg5oc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep3_rg5o8 $krep5_rg5oa];

Data.Functor.Product.$fDataProduct9 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$fDataProduct6];

Data.Functor.Product.$tcProduct :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9904636435990105341##
                                    16069493191308336164##
                                    Data.Functor.Product.$trModule
                                    Data.Functor.Product.$fDataProduct9
                                    1#
                                    Data.Functor.Product.$fDataProduct8];

$krep8_rg5od :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep5_rg5oa GHC.Types.[]];

$krep9_rg5oe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rg5o8 $krep8_rg5od];

$krep10_rg5of :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rg5o9 $krep9_rg5oe];

$krep11_rg5og :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rg5o5 $krep10_rg5of];

$krep12_rg5oh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Product.$tcProduct
                                              $krep11_rg5og];

$krep13_rg5oi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_rg5oc $krep12_rg5oh];

Data.Functor.Product.$tc'Pair1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rg5ob $krep13_rg5oi];

Data.Functor.Product.$tc'Pair3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Pair"#;

Data.Functor.Product.$tc'Pair2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$tc'Pair3];

Data.Functor.Product.$tc'Pair :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11374113252541295849##
                                    18011678063065699923##
                                    Data.Functor.Product.$trModule
                                    Data.Functor.Product.$tc'Pair2
                                    4#
                                    Data.Functor.Product.$tc'Pair1];

Data.Functor.Product.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Product.Product f g a)
[GblId, Arity=4, Str=<S,U><S,U><S,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sg5G6 w1_sg5G7 w2_sg5G8 w3_sg5G9]
        let {
          sat_sg5Ga [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w3_sg5G9]; } in
        let {
          sat_sg5Gb [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sg5Ga GHC.Types.[]];
        } in 
          case
              Data.Typeable.Internal.$wmkTrCon
                  9904636435990105341##
                  16069493191308336164##
                  Data.Functor.Product.$trModule
                  Data.Functor.Product.$fDataProduct9
                  1#
                  Data.Functor.Product.$fDataProduct8
                  sat_sg5Gb
          of
          { (#,,,,#) ww8_sg5Gd [Occ=Once]
                     ww9_sg5Ge [Occ=Once]
                     ww10_sg5Gf [Occ=Once]
                     ww11_sg5Gg [Occ=Once]
                     ww12_sg5Gh [Occ=Once] ->
                let {
                  sat_sg5Gi [Occ=Once]
                    :: Data.Typeable.Internal.TypeRep Data.Functor.Product.Product
                  [LclId] =
                      CCCS Data.Typeable.Internal.TrTyCon! [ww8_sg5Gd
                                                            ww9_sg5Ge
                                                            ww10_sg5Gf
                                                            ww11_sg5Gg
                                                            ww12_sg5Gh];
                } in 
                  case
                      Data.Typeable.Internal.mkTrApp sat_sg5Gi w1_sg5G7
                  of
                  sat_sg5Gj
                  { __DEFAULT ->
                        case
                            Data.Typeable.Internal.mkTrApp sat_sg5Gj w2_sg5G8
                        of
                        sat_sg5Gk
                        { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sg5Gk w_sg5G6;
                        };
                  };
          };

Data.Functor.Product.$fDataProduct7 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Product.Product f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sg5Gl w1_sg5Gm w2_sg5Gn w3_sg5Go w4_sg5Gp w5_sg5Gq]
        Data.Functor.Product.$w$cp1Data w_sg5Gl w1_sg5Gm w2_sg5Gn w3_sg5Go;

Data.Functor.Product.$fDataProduct1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (f a -> g a -> Data.Functor.Product.Product f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Product.Pair GHC.Types.False];

Data.Functor.Product.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5Gr w1_sg5Gs w2_sg5Gt w3_sg5Gu w4_sg5Gv]
        let {
          lvl9_sg5Gw [Occ=OnceL]
            :: m_sg4Xt (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm)
          [LclId] =
              [w2_sg5Gt] \u [] GHC.Base.mzero w2_sg5Gt;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sg5Gt
          of
          $dMonad_sg5Gx [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sg5H1 [Occ=Once]
                    :: (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm,
                        GHC.Types.Bool)
                       -> m_sg4Xt (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm)
                  [LclId] =
                      [lvl9_sg5Gw $dMonad_sg5Gx] \r [ds_sg5GW]
                          case ds_sg5GW of {
                            (,) x'_sg5GY [Occ=Once] b_sg5GZ [Occ=Once!] ->
                                case b_sg5GZ of {
                                  GHC.Types.False -> lvl9_sg5Gw;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sg5Gx x'_sg5GY;
                                };
                          }; } in
                let {
                  sat_sg5GV [Occ=Once]
                    :: m_sg4Xt (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sg5Gr w1_sg5Gs w2_sg5Gt w3_sg5Gu w4_sg5Gv $dMonad_sg5Gx] \u []
                          case w4_sg5Gv of {
                            Data.Functor.Product.Pair a1_sg5Gz [Occ=Once]
                                                      a2_sg5GA [Occ=Once] ->
                                let {
                                  k1_sg5GB [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_sg4Xt (d -> b)
                                       -> d -> m_sg4Xt (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [w2_sg5Gt w3_sg5Gu $dMonad_sg5Gx] \r [$dData1_sg5GC
                                                                                     ds_sg5GD
                                                                                     y_sg5GE]
                                          let {
                                            lvl10_sg5GF [Occ=OnceL] :: m_sg4Xt d_ae2Ws
                                            [LclId] =
                                                [w3_sg5Gu $dData1_sg5GC y_sg5GE] \u []
                                                    w3_sg5Gu $dData1_sg5GC y_sg5GE; } in
                                          let {
                                            sat_sg5GS [Occ=Once]
                                              :: (d_ae2Ws -> b_ae2Wt, GHC.Types.Bool)
                                                 -> m_sg4Xt (b_ae2Wt, GHC.Types.Bool)
                                            [LclId] =
                                                [w2_sg5Gt
                                                 $dMonad_sg5Gx
                                                 y_sg5GE
                                                 lvl10_sg5GF] \r [ds1_sg5GG]
                                                    case ds1_sg5GG of {
                                                      (,) h_sg5GI b1_sg5GJ [Occ=Once] ->
                                                          let {
                                                            sat_sg5GR [Occ=Once]
                                                              :: m_sg4Xt (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sg5Gx
                                                                 y_sg5GE
                                                                 h_sg5GI
                                                                 b1_sg5GJ] \u []
                                                                    let {
                                                                      sat_sg5GP [Occ=Once]
                                                                        :: b_ae2Wt
                                                                      [LclId] =
                                                                          [y_sg5GE h_sg5GI] \u []
                                                                              h_sg5GI y_sg5GE; } in
                                                                    let {
                                                                      sat_sg5GQ [Occ=Once]
                                                                        :: (b_ae2Wt, GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sg5GP
                                                                                     b1_sg5GJ];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sg5Gx
                                                                          sat_sg5GQ; } in
                                                          let {
                                                            sat_sg5GO [Occ=Once]
                                                              :: m_sg4Xt (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sg5Gx
                                                                 lvl10_sg5GF
                                                                 h_sg5GI] \u []
                                                                    let {
                                                                      sat_sg5GN [Occ=Once]
                                                                        :: d_ae2Ws
                                                                           -> m_sg4Xt (b_ae2Wt,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sg5Gx
                                                                           h_sg5GI] \r [y'_sg5GK]
                                                                              let {
                                                                                sat_sg5GL [Occ=Once]
                                                                                  :: b_ae2Wt
                                                                                [LclId] =
                                                                                    [h_sg5GI
                                                                                     y'_sg5GK] \u []
                                                                                        h_sg5GI
                                                                                            y'_sg5GK; } in
                                                                              let {
                                                                                sat_sg5GM [Occ=Once]
                                                                                  :: (b_ae2Wt,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sg5GL
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sg5Gx
                                                                                    sat_sg5GM;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sg5Gx
                                                                          lvl10_sg5GF
                                                                          sat_sg5GN;
                                                          } in 
                                                            GHC.Base.mplus
                                                                w2_sg5Gt sat_sg5GO sat_sg5GR;
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sg5Gx ds_sg5GD sat_sg5GS; } in
                                let {
                                  sat_sg5GU [Occ=Once]
                                    :: Data.Data.Mp
                                         m_sg4Xt
                                         (g_sg4Xl a_sg4Xm
                                          -> Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm)
                                  [LclId] =
                                      [w_sg5Gr $dMonad_sg5Gx a1_sg5Gz k1_sg5GB] \u []
                                          let {
                                            sat_sg5GT [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_sg4Xt
                                                   (f_sg4Xk a_sg4Xm
                                                    -> g_sg4Xl a_sg4Xm
                                                    -> Data.Functor.Product.Product
                                                         f_sg4Xk g_sg4Xl a_sg4Xm)
                                            [LclId] =
                                                [$dMonad_sg5Gx] \u []
                                                    GHC.Base.return
                                                        $dMonad_sg5Gx
                                                        Data.Functor.Product.$fDataProduct1;
                                          } in  k1_sg5GB w_sg5Gr sat_sg5GT a1_sg5Gz;
                                } in  k1_sg5GB w1_sg5Gs sat_sg5GU a2_sg5GA;
                          };
                } in  GHC.Base.>>= $dMonad_sg5Gx sat_sg5GV sat_sg5H1;
          };

Data.Functor.Product.$fDataProduct_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5H2
           w1_sg5H3
           w2_sg5H4
           w3_sg5H5
           w4_sg5H6
           w5_sg5H7
           w6_sg5H8
           w7_sg5H9
           w8_sg5Ha]
        Data.Functor.Product.$w$cgmapMp
            w4_sg5H6 w5_sg5H7 w6_sg5H8 w7_sg5H9 w8_sg5Ha;

Data.Functor.Product.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> f a -> g a -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sg5Hb w1_sg5Hc w2_sg5Hd w3_sg5He ww_sg5Hf ww1_sg5Hg]
        let {
          k1_sg5Hh [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
            :: forall d b.
               Data.Data.Data d =>
               m_sg4XN (d -> b) -> d -> m_sg4XN b
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w2_sg5Hd w3_sg5He] \r [$dData1_sg5Hi c_sg5Hj x_sg5Hk]
                  let {
                    lvl9_sg5Hl [Occ=OnceL] :: m_sg4XN d_ae2Vh
                    [LclId] =
                        [w3_sg5He $dData1_sg5Hi x_sg5Hk] \u []
                            w3_sg5He $dData1_sg5Hi x_sg5Hk; } in
                  let {
                    sat_sg5Hq [Occ=Once] :: (d_ae2Vh -> b_ae2Vi) -> m_sg4XN b_ae2Vi
                    [LclId] =
                        [w2_sg5Hd lvl9_sg5Hl] \r [c'_sg5Hm]
                            let {
                              sat_sg5Hp [Occ=Once] :: d_ae2Vh -> m_sg4XN b_ae2Vi
                              [LclId] =
                                  [w2_sg5Hd c'_sg5Hm] \r [x'_sg5Hn]
                                      let {
                                        sat_sg5Ho [Occ=Once] :: b_ae2Vi
                                        [LclId] =
                                            [c'_sg5Hm x'_sg5Hn] \u [] c'_sg5Hm x'_sg5Hn;
                                      } in  GHC.Base.return w2_sg5Hd sat_sg5Ho;
                            } in  GHC.Base.>>= w2_sg5Hd lvl9_sg5Hl sat_sg5Hp;
                  } in  GHC.Base.>>= w2_sg5Hd c_sg5Hj sat_sg5Hq; } in
        let {
          sat_sg5Hs [Occ=Once]
            :: m_sg4XN (g_sg4XF a_sg4XG
                        -> Data.Functor.Product.Product f_sg4XE g_sg4XF a_sg4XG)
          [LclId] =
              [w_sg5Hb w2_sg5Hd ww_sg5Hf k1_sg5Hh] \u []
                  let {
                    sat_sg5Hr [Occ=Once]
                      :: m_sg4XN (f_sg4XE a_sg4XG
                                  -> g_sg4XF a_sg4XG
                                  -> Data.Functor.Product.Product f_sg4XE g_sg4XF a_sg4XG)
                    [LclId] =
                        [w2_sg5Hd] \u []
                            GHC.Base.return w2_sg5Hd Data.Functor.Product.Pair;
                  } in  k1_sg5Hh w_sg5Hb sat_sg5Hr ww_sg5Hf;
        } in  k1_sg5Hh w1_sg5Hc sat_sg5Hs ww1_sg5Hg;

Data.Functor.Product.$fDataProduct_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5Ht
           w1_sg5Hu
           w2_sg5Hv
           w3_sg5Hw
           w4_sg5Hx
           w5_sg5Hy
           w6_sg5Hz
           w7_sg5HA
           w8_sg5HB]
        case w8_sg5HB of {
          Data.Functor.Product.Pair ww1_sg5HD [Occ=Once]
                                    ww2_sg5HE [Occ=Once] ->
              Data.Functor.Product.$w$cgmapM
                  w4_sg5Hx w5_sg5Hy w6_sg5Hz w7_sg5HA ww1_sg5HD ww2_sg5HE;
        };

Data.Functor.Product.$fDataProduct_$cgmapQi
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Functor.Product.Product f g a
     -> u
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg5HF
           $dTypeable1_sg5HG
           $dTypeable2_sg5HH
           $dTypeable3_sg5HI
           $dData_sg5HJ
           $dData1_sg5HK
           ds_sg5HL
           ds1_sg5HM
           x_sg5HN]
        case x_sg5HN of {
          Data.Functor.Product.Pair a1_sg5HP [Occ=Once]
                                    a2_sg5HQ [Occ=Once] ->
              case ds_sg5HL of {
                GHC.Types.I# x1_sg5HS [Occ=Once!] ->
                    case x1_sg5HS of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sg5HM $dData_sg5HJ a1_sg5HP;
                      1# -> ds1_sg5HM $dData1_sg5HK a2_sg5HQ;
                    };
              };
        };

Data.Functor.Product.$fDataProduct_$cgmapQr
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Product.Product f g a
     -> r
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg5HU
           $dTypeable1_sg5HV
           $dTypeable2_sg5HW
           $dTypeable3_sg5HX
           $dData_sg5HY
           $dData1_sg5HZ
           ds_sg5I0
           ds1_sg5I1
           ds2_sg5I2
           x0_sg5I3]
        case x0_sg5I3 of {
          Data.Functor.Product.Pair a1_sg5I5 [Occ=Once]
                                    a2_sg5I6 [Occ=Once] ->
              let {
                sat_sg5I9 [Occ=Once] :: r_ag3N9
                [LclId] =
                    [$dData1_sg5HZ ds_sg5I0 ds1_sg5I1 ds2_sg5I2 a2_sg5I6] \u []
                        let {
                          sat_sg5I8 [Occ=Once] :: r'_ag3Na
                          [LclId] =
                              [$dData1_sg5HZ ds2_sg5I2 a2_sg5I6] \u []
                                  ds2_sg5I2 $dData1_sg5HZ a2_sg5I6;
                        } in  ds_sg5I0 sat_sg5I8 ds1_sg5I1; } in
              let {
                sat_sg5I7 [Occ=Once] :: r'_ag3Na
                [LclId] =
                    [$dData_sg5HY ds2_sg5I2 a1_sg5I5] \u []
                        ds2_sg5I2 $dData_sg5HY a1_sg5I5;
              } in  ds_sg5I0 sat_sg5I7 sat_sg5I9;
        };

Data.Functor.Product.$fDataProduct2
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Const.Const r (Data.Functor.Product.Product f g a)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg5Ia
           $dTypeable1_sg5Ib
           $dTypeable2_sg5Ic
           $dTypeable3_sg5Id
           $dData_sg5Ie
           $dData1_sg5If
           ds_sg5Ig
           ds1_sg5Ih
           ds2_sg5Ii
           eta_sg5Ij]
        case eta_sg5Ij of {
          Data.Functor.Product.Pair a1_sg5Il [Occ=Once]
                                    a2_sg5Im [Occ=Once] ->
              let {
                sat_sg5Ip [Occ=Once] :: r'_ag3MT
                [LclId] =
                    [$dData1_sg5If ds2_sg5Ii a2_sg5Im] \u []
                        ds2_sg5Ii $dData1_sg5If a2_sg5Im; } in
              let {
                sat_sg5Io [Occ=Once] :: r_ag3MS
                [LclId] =
                    [$dData_sg5Ie ds_sg5Ig ds1_sg5Ih ds2_sg5Ii a1_sg5Il] \u []
                        let {
                          sat_sg5In [Occ=Once] :: r'_ag3MT
                          [LclId] =
                              [$dData_sg5Ie ds2_sg5Ii a1_sg5Il] \u []
                                  ds2_sg5Ii $dData_sg5Ie a1_sg5Il;
                        } in  ds_sg5Ig ds1_sg5Ih sat_sg5In;
              } in  ds_sg5Ig sat_sg5Io sat_sg5Ip;
        };

Data.Functor.Product.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5Iq w1_sg5Ir w2_sg5Is w3_sg5It w4_sg5Iu]
        let {
          lvl9_sg5Iv [Occ=OnceL]
            :: m_sg4Yc (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
          [LclId] =
              [w2_sg5Is] \u [] GHC.Base.mzero w2_sg5Is;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sg5Is
          of
          $dMonad_sg5Iw [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sg5J3 [Occ=Once]
                    :: (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5,
                        GHC.Types.Bool)
                       -> m_sg4Yc (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
                  [LclId] =
                      [lvl9_sg5Iv $dMonad_sg5Iw] \r [ds_sg5IY]
                          case ds_sg5IY of {
                            (,) x'_sg5J0 [Occ=Once] b_sg5J1 [Occ=Once!] ->
                                case b_sg5J1 of {
                                  GHC.Types.False -> lvl9_sg5Iv;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sg5Iw x'_sg5J0;
                                };
                          }; } in
                let {
                  sat_sg5IX [Occ=Once]
                    :: m_sg4Yc (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sg5Iq w1_sg5Ir w2_sg5Is w3_sg5It w4_sg5Iu $dMonad_sg5Iw] \u []
                          case w4_sg5Iu of {
                            Data.Functor.Product.Pair a1_sg5Iy [Occ=Once]
                                                      a2_sg5Iz [Occ=Once] ->
                                let {
                                  k1_sg5IA [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_sg4Yc (d -> b)
                                       -> d -> m_sg4Yc (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [w2_sg5Is w3_sg5It $dMonad_sg5Iw] \r [$dData1_sg5IB
                                                                                     ds_sg5IC
                                                                                     y_sg5ID]
                                          let {
                                            lvl10_sg5IE [Occ=OnceL] :: m_sg4Yc d_ae2Ya
                                            [LclId] =
                                                [w3_sg5It $dData1_sg5IB y_sg5ID] \u []
                                                    w3_sg5It $dData1_sg5IB y_sg5ID; } in
                                          let {
                                            sat_sg5IU [Occ=Once]
                                              :: (d_ae2Ya -> b_ae2Yb, GHC.Types.Bool)
                                                 -> m_sg4Yc (b_ae2Yb, GHC.Types.Bool)
                                            [LclId] =
                                                [w2_sg5Is
                                                 $dMonad_sg5Iw
                                                 y_sg5ID
                                                 lvl10_sg5IE] \r [ds1_sg5IF]
                                                    case ds1_sg5IF of {
                                                      (,) h_sg5IH b1_sg5II [Occ=Once!] ->
                                                          case b1_sg5II of {
                                                            GHC.Types.False ->
                                                                let {
                                                                  sat_sg5IR [Occ=Once]
                                                                    :: m_sg4Yc (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sg5Iw
                                                                       y_sg5ID
                                                                       h_sg5IH] \u []
                                                                          let {
                                                                            sat_sg5IP [Occ=Once]
                                                                              :: b_ae2Yb
                                                                            [LclId] =
                                                                                [y_sg5ID
                                                                                 h_sg5IH] \u []
                                                                                    h_sg5IH
                                                                                        y_sg5ID; } in
                                                                          let {
                                                                            sat_sg5IQ [Occ=Once]
                                                                              :: (b_ae2Yb,
                                                                                  GHC.Types.Bool)
                                                                            [LclId] =
                                                                                CCCS (,)! [sat_sg5IP
                                                                                           GHC.Types.False];
                                                                          } in 
                                                                            GHC.Base.return
                                                                                $dMonad_sg5Iw
                                                                                sat_sg5IQ; } in
                                                                let {
                                                                  sat_sg5IO [Occ=Once]
                                                                    :: m_sg4Yc (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sg5Iw
                                                                       lvl10_sg5IE
                                                                       h_sg5IH] \u []
                                                                          let {
                                                                            sat_sg5IN [Occ=Once]
                                                                              :: d_ae2Ya
                                                                                 -> m_sg4Yc (b_ae2Yb,
                                                                                             GHC.Types.Bool)
                                                                            [LclId] =
                                                                                [$dMonad_sg5Iw
                                                                                 h_sg5IH] \r [y'_sg5IK]
                                                                                    let {
                                                                                      sat_sg5IL [Occ=Once]
                                                                                        :: b_ae2Yb
                                                                                      [LclId] =
                                                                                          [h_sg5IH
                                                                                           y'_sg5IK] \u []
                                                                                              h_sg5IH
                                                                                                  y'_sg5IK; } in
                                                                                    let {
                                                                                      sat_sg5IM [Occ=Once]
                                                                                        :: (b_ae2Yb,
                                                                                            GHC.Types.Bool)
                                                                                      [LclId] =
                                                                                          CCCS (,)! [sat_sg5IL
                                                                                                     GHC.Types.True];
                                                                                    } in 
                                                                                      GHC.Base.return
                                                                                          $dMonad_sg5Iw
                                                                                          sat_sg5IM;
                                                                          } in 
                                                                            GHC.Base.>>=
                                                                                $dMonad_sg5Iw
                                                                                lvl10_sg5IE
                                                                                sat_sg5IN;
                                                                } in 
                                                                  GHC.Base.mplus
                                                                      w2_sg5Is sat_sg5IO sat_sg5IR;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_sg5IS [Occ=Once] :: b_ae2Yb
                                                                  [LclId] =
                                                                      [y_sg5ID h_sg5IH] \u []
                                                                          h_sg5IH y_sg5ID; } in
                                                                let {
                                                                  sat_sg5IT [Occ=Once]
                                                                    :: (b_ae2Yb, GHC.Types.Bool)
                                                                  [LclId] =
                                                                      CCCS (,)! [sat_sg5IS
                                                                                 GHC.Types.True];
                                                                } in 
                                                                  GHC.Base.return
                                                                      $dMonad_sg5Iw sat_sg5IT;
                                                          };
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sg5Iw ds_sg5IC sat_sg5IU; } in
                                let {
                                  sat_sg5IW [Occ=Once]
                                    :: Data.Data.Mp
                                         m_sg4Yc
                                         (g_sg4Y4 a_sg4Y5
                                          -> Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
                                  [LclId] =
                                      [w_sg5Iq $dMonad_sg5Iw a1_sg5Iy k1_sg5IA] \u []
                                          let {
                                            sat_sg5IV [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_sg4Yc
                                                   (f_sg4Y3 a_sg4Y5
                                                    -> g_sg4Y4 a_sg4Y5
                                                    -> Data.Functor.Product.Product
                                                         f_sg4Y3 g_sg4Y4 a_sg4Y5)
                                            [LclId] =
                                                [$dMonad_sg5Iw] \u []
                                                    GHC.Base.return
                                                        $dMonad_sg5Iw
                                                        Data.Functor.Product.$fDataProduct1;
                                          } in  k1_sg5IA w_sg5Iq sat_sg5IV a1_sg5Iy;
                                } in  k1_sg5IA w1_sg5Ir sat_sg5IW a2_sg5Iz;
                          };
                } in  GHC.Base.>>= $dMonad_sg5Iw sat_sg5IX sat_sg5J3;
          };

Data.Functor.Product.$fDataProduct_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sg5J4
           w1_sg5J5
           w2_sg5J6
           w3_sg5J7
           w4_sg5J8
           w5_sg5J9
           w6_sg5Ja
           w7_sg5Jb
           w8_sg5Jc]
        Data.Functor.Product.$w$cgmapMo
            w4_sg5J8 w5_sg5J9 w6_sg5Ja w7_sg5Jb w8_sg5Jc;

lvl5_rg5oj
  :: forall k (g :: k -> *) (a :: k) (f :: k -> *).
     Data.Functor.Product.Product f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_sg5Jd]
        case ds_sg5Jd of {
          Data.Functor.Product.Pair _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Functor.Product.$cPair;
        };

lvl6_rg5ok
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Product.Product f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sg5Jh] Data.Functor.Product.$tProduct;

lvl7_rg5ol
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Functor.Product.Product f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sg5Ji ds_sg5Jj] GHC.Base.Nothing [];

lvl8_rg5om
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Functor.Product.Product f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sg5Jk ds_sg5Jl] GHC.Base.Nothing [];

Data.Functor.Product.$fDataProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Data.Data (Data.Functor.Product.Product f g a)
[GblId[DFunId], Arity=6, Str=<L,U><L,U><L,U><L,U><L,U><L,U>] =
    [] \r [$dTypeable_sg5Jm
           $dTypeable1_sg5Jn
           $dTypeable2_sg5Jo
           $dTypeable3_sg5Jp
           $dData_sg5Jq
           $dData1_sg5Jr]
        let {
          sat_sg5K2 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> m (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dData_sg5Jq $dData1_sg5Jr] \r [w_sg5JZ w1_sg5K0 w2_sg5K1]
                  Data.Functor.Product.$w$cgmapMo
                      $dData_sg5Jq $dData1_sg5Jr w_sg5JZ w1_sg5K0 w2_sg5K1; } in
        let {
          sat_sg5JY [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> m (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dData_sg5Jq $dData1_sg5Jr] \r [w_sg5JV w1_sg5JW w2_sg5JX]
                  Data.Functor.Product.$w$cgmapMp
                      $dData_sg5Jq $dData1_sg5Jr w_sg5JV w1_sg5JW w2_sg5JX; } in
        let {
          sat_sg5JU [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> m (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dTypeable_sg5Jm
               $dTypeable1_sg5Jn
               $dTypeable2_sg5Jo
               $dTypeable3_sg5Jp
               $dData_sg5Jq
               $dData1_sg5Jr] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgmapM
                      $dTypeable_sg5Jm
                      $dTypeable1_sg5Jn
                      $dTypeable2_sg5Jo
                      $dTypeable3_sg5Jp
                      $dData_sg5Jq
                      $dData1_sg5Jr
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg5JT [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> u
          [LclId] =
              [$dTypeable_sg5Jm
               $dTypeable1_sg5Jn
               $dTypeable2_sg5Jo
               $dTypeable3_sg5Jp
               $dData_sg5Jq
               $dData1_sg5Jr] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgmapQi
                      $dTypeable_sg5Jm
                      $dTypeable1_sg5Jn
                      $dTypeable2_sg5Jo
                      $dTypeable3_sg5Jp
                      $dData_sg5Jq
                      $dData1_sg5Jr
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg5JS [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7 -> [u]
          [LclId] =
              [$dData_sg5Jq $dData1_sg5Jr] \r [ds_sg5JK x0_sg5JL]
                  case x0_sg5JL of {
                    Data.Functor.Product.Pair a1_sg5JN [Occ=Once]
                                              a2_sg5JO [Occ=Once] ->
                        let {
                          sat_sg5JQ [Occ=Once] :: u_ag3Nq
                          [LclId] =
                              [$dData1_sg5Jr ds_sg5JK a2_sg5JO] \u []
                                  ds_sg5JK $dData1_sg5Jr a2_sg5JO; } in
                        let {
                          sat_sg5JR [Occ=Once] :: [u_ag3Nq]
                          [LclId] =
                              CCCS :! [sat_sg5JQ GHC.Types.[]]; } in
                        let {
                          sat_sg5JP [Occ=Once] :: u_ag3Nq
                          [LclId] =
                              [$dData_sg5Jq ds_sg5JK a1_sg5JN] \u []
                                  ds_sg5JK $dData_sg5Jq a1_sg5JN;
                        } in  : [sat_sg5JP sat_sg5JR];
                  }; } in
        let {
          sat_sg5JJ [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> r
          [LclId] =
              [$dTypeable_sg5Jm
               $dTypeable1_sg5Jn
               $dTypeable2_sg5Jo
               $dTypeable3_sg5Jp
               $dData_sg5Jq
               $dData1_sg5Jr] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgmapQr
                      $dTypeable_sg5Jm
                      $dTypeable1_sg5Jn
                      $dTypeable2_sg5Jo
                      $dTypeable3_sg5Jp
                      $dData_sg5Jq
                      $dData1_sg5Jr
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg5JI [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> r
          [LclId] =
              [$dTypeable_sg5Jm
               $dTypeable1_sg5Jn
               $dTypeable2_sg5Jo
               $dTypeable3_sg5Jp
               $dData_sg5Jq
               $dData1_sg5Jr] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct2
                      $dTypeable_sg5Jm
                      $dTypeable1_sg5Jn
                      $dTypeable2_sg5Jo
                      $dTypeable3_sg5Jp
                      $dData_sg5Jq
                      $dData1_sg5Jr
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg5JH [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
          [LclId] =
              [$dData_sg5Jq $dData1_sg5Jr] \r [ds_sg5JA x0_sg5JB]
                  case x0_sg5JB of {
                    Data.Functor.Product.Pair a1_sg5JD [Occ=Once]
                                              a2_sg5JE [Occ=Once] ->
                        let {
                          sat_sg5JG [Occ=Once] :: g_Xg3V4 a_Xg3V7
                          [LclId] =
                              [$dData1_sg5Jr ds_sg5JA a2_sg5JE] \u []
                                  ds_sg5JA $dData1_sg5Jr a2_sg5JE; } in
                        let {
                          sat_sg5JF [Occ=Once] :: f_Xg3PP a_Xg3V7
                          [LclId] =
                              [$dData_sg5Jq ds_sg5JA a1_sg5JD] \u []
                                  ds_sg5JA $dData_sg5Jq a1_sg5JD;
                        } in  Data.Functor.Product.Pair [sat_sg5JF sat_sg5JG];
                  }; } in
        let {
          sat_sg5Jz [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dData_sg5Jq $dData1_sg5Jr] \r [k1_sg5Ju z_sg5Jv ds_sg5Jw]
                  let {
                    sat_sg5Jy [Occ=Once]
                      :: c_ag3LC (g_Xg3V4 a_Xg3V7
                                  -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
                    [LclId] =
                        [$dData_sg5Jq k1_sg5Ju z_sg5Jv] \u []
                            let {
                              sat_sg5Jx [Occ=Once]
                                :: c_ag3LC (f_Xg3PP a_Xg3V7
                                            -> g_Xg3V4 a_Xg3V7
                                            -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
                              [LclId] =
                                  [z_sg5Jv] \u [] z_sg5Jv Data.Functor.Product.Pair;
                            } in  k1_sg5Ju $dData_sg5Jq sat_sg5Jx;
                  } in  k1_sg5Ju $dData1_sg5Jr sat_sg5Jy; } in
        let {
          sat_sg5Jt [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> c (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dTypeable_sg5Jm
               $dTypeable1_sg5Jn
               $dTypeable2_sg5Jo
               $dTypeable3_sg5Jp
               $dData_sg5Jq
               $dData1_sg5Jr] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgfoldl
                      $dTypeable_sg5Jm
                      $dTypeable1_sg5Jn
                      $dTypeable2_sg5Jo
                      $dTypeable3_sg5Jp
                      $dData_sg5Jq
                      $dData1_sg5Jr
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg5Js [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dTypeable_sg5Jm
               $dTypeable1_sg5Jn
               $dTypeable2_sg5Jo
               $dTypeable3_sg5Jp] \u []
                  Data.Functor.Product.$w$cp1Data
                      $dTypeable_sg5Jm
                      $dTypeable1_sg5Jn
                      $dTypeable2_sg5Jo
                      $dTypeable3_sg5Jp;
        } in 
          Data.Data.C:Data [sat_sg5Js
                            sat_sg5Jt
                            sat_sg5Jz
                            lvl5_rg5oj
                            lvl6_rg5ok
                            lvl7_rg5ol
                            lvl8_rg5om
                            sat_sg5JH
                            sat_sg5JI
                            sat_sg5JJ
                            sat_sg5JS
                            sat_sg5JT
                            sat_sg5JU
                            sat_sg5JY
                            sat_sg5K2];

Data.Functor.Product.Pair
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     f a -> g a -> Data.Functor.Product.Product f g a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Product.Pair [eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:12:03.764867052 UTC

Data.Functor.Product.$fEq1Product_$cliftEq
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sgao2 $dEq2_sgao3 eq_sgao4 ds_sgao5 ds1_sgao6]
        case ds_sgao5 of {
          Data.Functor.Product.Pair x1_sgao8 [Occ=Once]
                                    y1_sgao9 [Occ=Once] ->
              case ds1_sgao6 of {
                Data.Functor.Product.Pair x2_sgaob [Occ=Once]
                                          y2_sgaoc [Occ=Once] ->
                    case $dEq1_sgao2 eq_sgao4 x1_sgao8 x2_sgaob of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> $dEq2_sgao3 eq_sgao4 y1_sgao9 y2_sgaoc;
                    };
              };
        };

Data.Functor.Product.$fEq1Product [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     Data.Functor.Classes.Eq1 (Data.Functor.Product.Product f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Product.$fEq1Product_$cliftEq
            eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Product.$w$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> f a -> g a -> f b -> g b -> GHC.Types.Ordering
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaoe
           w1_sgaof
           w2_sgaog
           ww_sgaoh
           ww1_sgaoi
           ww2_sgaoj
           ww3_sgaok]
        case
            Data.Functor.Classes.liftCompare
                w_sgaoe w2_sgaog ww_sgaoh ww2_sgaoj
        of
        { GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ ->
              Data.Functor.Classes.liftCompare
                  w1_sgaof w2_sgaog ww1_sgaoi ww3_sgaok;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Product.$fOrd1Product_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaom w1_sgaon w2_sgaoo w3_sgaop w4_sgaoq]
        case w3_sgaop of {
          Data.Functor.Product.Pair ww1_sgaos [Occ=Once]
                                    ww2_sgaot [Occ=Once] ->
              case w4_sgaoq of {
                Data.Functor.Product.Pair ww4_sgaov [Occ=Once]
                                          ww5_sgaow [Occ=Once] ->
                    Data.Functor.Product.$w$cliftCompare
                        w_sgaom w1_sgaon w2_sgaoo ww1_sgaos ww2_sgaot ww4_sgaov ww5_sgaow;
              };
        };

Data.Functor.Product.$w$cp1Ord1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> f a -> g a -> f b -> g b -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaox
           w1_sgaoy
           w2_sgaoz
           ww_sgaoA
           ww1_sgaoB
           ww2_sgaoC
           ww3_sgaoD]
        case
            Data.Functor.Classes.$p1Ord1 w_sgaox w2_sgaoz ww_sgaoA ww2_sgaoC
        of
        { GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True ->
              Data.Functor.Classes.$p1Ord1 w1_sgaoy w2_sgaoz ww1_sgaoB ww3_sgaoD;
        };

Data.Functor.Product.$fOrd1Product1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaoF w1_sgaoG w2_sgaoH w3_sgaoI w4_sgaoJ]
        case w3_sgaoI of {
          Data.Functor.Product.Pair ww1_sgaoL [Occ=Once]
                                    ww2_sgaoM [Occ=Once] ->
              case w4_sgaoJ of {
                Data.Functor.Product.Pair ww4_sgaoO [Occ=Once]
                                          ww5_sgaoP [Occ=Once] ->
                    Data.Functor.Product.$w$cp1Ord1
                        w_sgaoF w1_sgaoG w2_sgaoH ww1_sgaoL ww2_sgaoM ww4_sgaoO ww5_sgaoP;
              };
        };

Data.Functor.Product.$fOrd1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     Data.Functor.Classes.Ord1 (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(C1(C1(U))),C(C1(C1(U))))>m] =
    [] \r [$dOrd1_sgaoQ $dOrd2_sgaoR]
        let {
          sat_sgaoT [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Product.Product f_Xg499 g_Xg49b a
               -> Data.Functor.Product.Product f_Xg499 g_Xg49b b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sgaoQ $dOrd2_sgaoR] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fOrd1Product_$cliftCompare
                      $dOrd1_sgaoQ $dOrd2_sgaoR eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgaoS [Occ=Once]
            :: Data.Functor.Classes.Eq1
                 (Data.Functor.Product.Product f_Xg499 g_Xg49b)
          [LclId] =
              [$dOrd1_sgaoQ $dOrd2_sgaoR] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fOrd1Product1
                      $dOrd1_sgaoQ $dOrd2_sgaoR eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sgaoS sat_sgaoT];

Data.Functor.Product.$fRead1Product3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Pair"#;

Data.Functor.Product.$fRead1Product2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Product.$fRead1Product3;

Data.Functor.Product.$fRead1Product1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Product.$fRead1Product2];

Data.Functor.Product.$fRead1Product_lvl3
  :: Text.ParserCombinators.ReadPrec.Prec
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Product.$fRead1Product_$cliftReadPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgaoU $dRead2_sgaoV rp_sgaoW rl_sgaoX]
        let {
          reader_sgaoY [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_ag45N a_ag46b)
          [LclId] =
              [$dRead1_sgaoU rp_sgaoW rl_sgaoX] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead1_sgaoU rp_sgaoW rl_sgaoX; } in
        let {
          reader1_sgaoZ [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (g_ag45O a_ag46b)
          [LclId] =
              [$dRead2_sgaoV rp_sgaoW rl_sgaoX] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead2_sgaoV rp_sgaoW rl_sgaoX; } in
        let {
          $wlvl_sgap0 [InlPrag=NOUSERINLINE[0], Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: GHC.Prim.Int#
               -> forall b.
                  (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46b
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [reader_sgaoY reader1_sgaoZ] \r [ww_sgap1 w_sgap2]
                  case <=# [ww_sgap1 10#] of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                    1# ->
                        let {
                          sat_sgapa [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_sg4P0
                          [LclId] =
                              [reader_sgaoY reader1_sgaoZ w_sgap2] \r [a1_sgap4]
                                  let {
                                    sat_sgap9 [Occ=Once]
                                      :: f_ag45N a_ag46b -> Text.ParserCombinators.ReadP.P b_sg4P0
                                    [LclId] =
                                        [reader1_sgaoZ w_sgap2] \r [a2_sgap5]
                                            let {
                                              sat_sgap8 [Occ=Once]
                                                :: g_ag45O a_ag46b
                                                   -> Text.ParserCombinators.ReadP.P b_sg4P0
                                              [LclId] =
                                                  [w_sgap2 a2_sgap5] \r [a3_sgap6]
                                                      let {
                                                        sat_sgap7 [Occ=Once]
                                                          :: Data.Functor.Product.Product
                                                               f_ag45N g_ag45O a_ag46b
                                                        [LclId] =
                                                            CCCS Data.Functor.Product.Pair! [a2_sgap5
                                                                                             a3_sgap6];
                                                      } in  w_sgap2 sat_sgap7;
                                            } in 
                                              reader1_sgaoZ
                                                  Data.Functor.Product.$fRead1Product_lvl3
                                                  sat_sgap8;
                                  } in 
                                    reader_sgaoY Data.Functor.Product.$fRead1Product_lvl3 sat_sgap9;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Functor.Product.$fRead1Product1 sat_sgapa
                          of
                          { Unit# ww2_sgapc [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_sgapc];
                          };
                  }; } in
        let {
          lvl9_sgapd [InlPrag=NOUSERINLINE[0], Occ=OnceL, Dmd=<L,C(C(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46b
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
              [$wlvl_sgap0] \r [w_sgape w1_sgapf]
                  case w_sgape of {
                    GHC.Types.I# ww1_sgaph [Occ=Once] ->
                        $wlvl_sgap0 ww1_sgaph w1_sgapf;
                  }; } in
        let {
          sat_sgapk [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46b
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [lvl9_sgapd] \r [eta_sgapi eta1_sgapj]
                  GHC.Read.list3 lvl9_sgapd eta_sgapi eta1_sgapj;
        } in  sat_sgapk;

Data.Functor.Product.$fRead1Product_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgapl $dRead2_sgapm rp_sgapn rl_sgapo]
        let {
          ds_sgapp [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag45N g_ag45O a_ag45U)
          [LclId] =
              [$dRead1_sgapl $dRead2_sgapm rp_sgapn rl_sgapo] \u []
                  let {
                    sat_sgapv [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag45U]
                    [LclId] =
                        [rl_sgapo] \r [n_sgapr w1_sgaps]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sgapo w1_sgaps
                            of
                            { Unit# ww1_sgapu [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sgapu];
                            }; } in
                  let {
                    sat_sgapq [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag45U
                    [LclId] =
                        [rp_sgapn] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sgapn eta_B1;
                  } in 
                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                        $dRead1_sgapl $dRead2_sgapm sat_sgapq sat_sgapv; } in
        let {
          sat_sgapy [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag45N g_ag45O a_ag45U)
          [LclId] =
              [ds_sgapp] \r [n_sgapw]
                  let {
                    sat_sgapx [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Product.Product f_ag45N g_ag45O a_ag45U)
                    [LclId] =
                        [ds_sgapp n_sgapw] \u []
                            ds_sgapp
                                n_sgapw Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgapx;
        } in  sat_sgapy;

Data.Functor.Product.$fRead1Product_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Product.Product f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgapz $dRead2_sgapA rp_sgapB rl_sgapC]
        let {
          sat_sgapD [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46x)
          [LclId] =
              [$dRead1_sgapz $dRead2_sgapA rp_sgapB rl_sgapC] \s []
                  Data.Functor.Product.$fRead1Product_$cliftReadPrec
                      $dRead1_sgapz $dRead2_sgapA rp_sgapB rl_sgapC;
        } in  GHC.Read.list sat_sgapD;

Data.Functor.Product.$fRead1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     Data.Functor.Classes.Read1 (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>m] =
    [] \r [$dRead1_sgapE $dRead2_sgapF]
        let {
          sat_sgapJ [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Product.Product f_ag45N g_ag45O a]
          [LclId] =
              [$dRead1_sgapE $dRead2_sgapF] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fRead1Product_$cliftReadListPrec
                      $dRead1_sgapE $dRead2_sgapF eta_B2 eta_B1; } in
        let {
          sat_sgapI [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Product.Product f_ag45N g_ag45O a)
          [LclId] =
              [$dRead1_sgapE $dRead2_sgapF] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fRead1Product_$cliftReadPrec
                      $dRead1_sgapE $dRead2_sgapF eta_B2 eta_B1; } in
        let {
          sat_sgapH [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Product.Product f_ag45N g_ag45O a]
          [LclId] =
              [$dRead1_sgapE $dRead2_sgapF] \u []
                  Data.Functor.Product.$fRead1Product_$cliftReadList
                      $dRead1_sgapE $dRead2_sgapF; } in
        let {
          sat_sgapG [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag45N g_ag45O a)
          [LclId] =
              [$dRead1_sgapE $dRead2_sgapF] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fRead1Product_$cliftReadsPrec
                      $dRead1_sgapE $dRead2_sgapF eta_B2 eta_B1;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sgapG
                                        sat_sgapH
                                        sat_sgapI
                                        sat_sgapJ];
Data.Functor.Product.$fRead1Product_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Product.Product f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgapK $dRead2_sgapL]
        let {
          sat_sgapM [Occ=Once]
            :: Data.Functor.Classes.Read1
                 (Data.Functor.Product.Product f_ag45N g_ag45O)
          [LclId] =
              [$dRead1_sgapK $dRead2_sgapL] \u []
                  Data.Functor.Product.$fRead1Product $dRead1_sgapK $dRead2_sgapL;
        } in  Data.Functor.Classes.liftReadListDefault sat_sgapM;

Data.Functor.Product.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> f a
     -> g a
     -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgapN
           w1_sgapO
           w2_sgapP
           w3_sgapQ
           ww_sgapR
           ww1_sgapS
           ww2_sgapT]
        let {
          sat_sgapV [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> g_sg4Pq a_sg4Pt -> GHC.Show.ShowS
          [LclId] =
              [w1_sgapO w2_sgapP w3_sgapQ] \s []
                  Data.Functor.Classes.liftShowsPrec w1_sgapO w2_sgapP w3_sgapQ; } in
        let {
          sat_sgapU [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> f_sg4Pp a_sg4Pt -> GHC.Show.ShowS
          [LclId] =
              [w_sgapN w2_sgapP w3_sgapQ] \s []
                  Data.Functor.Classes.liftShowsPrec w_sgapN w2_sgapP w3_sgapQ;
        } in 
          Data.Functor.Classes.$wshowsBinaryWith
              sat_sgapU
              sat_sgapV
              Data.Functor.Product.$fRead1Product2
              ww_sgapR
              ww1_sgapS
              ww2_sgapT;

Data.Functor.Product.$fShow1Product_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Product.Product f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgapW w1_sgapX w2_sgapY w3_sgapZ w4_sgaq0 w5_sgaq1]
        case w4_sgaq0 of {
          GHC.Types.I# ww1_sgaq3 [Occ=Once] ->
              case w5_sgaq1 of {
                Data.Functor.Product.Pair ww3_sgaq5 [Occ=Once]
                                          ww4_sgaq6 [Occ=Once] ->
                    Data.Functor.Product.$w$cliftShowsPrec
                        w_sgapW w1_sgapX w2_sgapY w3_sgapZ ww1_sgaq3 ww3_sgaq5 ww4_sgaq6;
              };
        };

Data.Functor.Product.$fFoldableProduct4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Product.$fShow1Product_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Product.Product f g a]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U><L,U><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgaq7
           $dShow2_sgaq8
           sp_sgaq9
           sl_sgaqa
           eta_sgaqb
           eta1_sgaqc]
        let {
          sat_sgaqh [Occ=Once]
            :: Data.Functor.Product.Product f_ag45l g_ag45m a_ag45G
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgaq7 $dShow2_sgaq8 sp_sgaq9 sl_sgaqa] \r [w_sgaqd]
                  case w_sgaqd of {
                    Data.Functor.Product.Pair ww1_sgaqf [Occ=Once]
                                              ww2_sgaqg [Occ=Once] ->
                        Data.Functor.Product.$w$cliftShowsPrec
                            $dShow1_sgaq7
                            $dShow2_sgaq8
                            sp_sgaq9
                            sl_sgaqa
                            0#
                            ww1_sgaqf
                            ww2_sgaqg;
                  };
        } in  GHC.Show.showList__ sat_sgaqh eta_sgaqb eta1_sgaqc;

Data.Functor.Product.$fShow1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     Data.Functor.Classes.Show1 (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)>m] =
    [] \r [$dShow1_sgaqi $dShow2_sgaqj]
        let {
          sat_sgaql [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Product.Product f_ag45l g_ag45m a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgaqi $dShow2_sgaqj] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fShow1Product_$cliftShowList
                      $dShow1_sgaqi $dShow2_sgaqj eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgaqk [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Product.Product f_ag45l g_ag45m a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgaqi $dShow2_sgaqj] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fShow1Product_$cliftShowsPrec
                      $dShow1_sgaqi $dShow2_sgaqj eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sgaqk sat_sgaql];

Data.Functor.Product.$w$c== [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaqm
           w1_sgaqn
           w2_sgaqo
           ww_sgaqp
           ww1_sgaqq
           ww2_sgaqr
           ww3_sgaqs]
        let {
          eq_sgaqt :: a_sg4PK -> a_sg4PK -> GHC.Types.Bool
          [LclId] =
              [w2_sgaqo] \u [] GHC.Classes.== w2_sgaqo;
        } in 
          case w_sgaqm eq_sgaqt ww_sgaqp ww2_sgaqr of {
            GHC.Types.False -> GHC.Types.False [];
            GHC.Types.True -> w1_sgaqn eq_sgaqt ww1_sgaqq ww3_sgaqs;
          };

Data.Functor.Product.$fEqProduct_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaqv w1_sgaqw w2_sgaqx w3_sgaqy w4_sgaqz]
        case w3_sgaqy of {
          Data.Functor.Product.Pair ww1_sgaqB [Occ=Once]
                                    ww2_sgaqC [Occ=Once] ->
              case w4_sgaqz of {
                Data.Functor.Product.Pair ww4_sgaqE [Occ=Once]
                                          ww5_sgaqF [Occ=Once] ->
                    Data.Functor.Product.$w$c==
                        w_sgaqv w1_sgaqw w2_sgaqx ww1_sgaqB ww2_sgaqC ww4_sgaqE ww5_sgaqF;
              };
        };

Data.Functor.Product.$fEqProduct_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sgaqG $dEq2_sgaqH $dEq_sgaqI eta_sgaqJ eta1_sgaqK]
        case eta_sgaqJ of {
          Data.Functor.Product.Pair ww1_sgaqM [Occ=Once]
                                    ww2_sgaqN [Occ=Once] ->
              case eta1_sgaqK of {
                Data.Functor.Product.Pair ww4_sgaqP [Occ=Once]
                                          ww5_sgaqQ [Occ=Once] ->
                    let {
                      eq_sgaqR :: a_ag452 -> a_ag452 -> GHC.Types.Bool
                      [LclId] =
                          [$dEq_sgaqI] \u [] GHC.Classes.== $dEq_sgaqI;
                    } in 
                      case $dEq1_sgaqG eq_sgaqR ww1_sgaqM ww4_sgaqP of {
                        GHC.Types.False -> GHC.Types.True [];
                        GHC.Types.True ->
                            case $dEq2_sgaqH eq_sgaqR ww2_sgaqN ww5_sgaqQ of {
                              GHC.Types.False -> GHC.Types.True [];
                              GHC.Types.True -> GHC.Types.False [];
                            };
                      };
              };
        };

Data.Functor.Product.$fEqProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     GHC.Classes.Eq (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><L,U(U,A)>m] =
    [] \r [$dEq1_sgaqU $dEq2_sgaqV $dEq_sgaqW]
        let {
          sat_sgaqY [Occ=Once]
            :: Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sgaqU $dEq2_sgaqV $dEq_sgaqW] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fEqProduct_$c/=
                      $dEq1_sgaqU $dEq2_sgaqV $dEq_sgaqW eta_B2 eta_B1; } in
        let {
          sat_sgaqX [Occ=Once]
            :: Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sgaqU $dEq2_sgaqV $dEq_sgaqW] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fEqProduct_$c==
                      $dEq1_sgaqU $dEq2_sgaqV $dEq_sgaqW eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sgaqX sat_sgaqY];

Data.Functor.Product.$fOrdProduct_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgaqZ $dOrd2_sgar0 $dOrd_sgar1 eta_sgar2 eta1_sgar3]
        case eta_sgar2 of {
          Data.Functor.Product.Pair ww1_sgar5 [Occ=Once]
                                    ww2_sgar6 [Occ=Once] ->
              case eta1_sgar3 of {
                Data.Functor.Product.Pair ww4_sgar8 [Occ=Once]
                                          ww5_sgar9 [Occ=Once] ->
                    let {
                      w_sgara :: a_ag44e -> a_ag44e -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sgar1] \u [] GHC.Classes.compare $dOrd_sgar1;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sgaqZ w_sgara ww1_sgar5 ww4_sgar8
                      of
                      { GHC.Types.LT -> GHC.Types.LT [];
                        GHC.Types.EQ ->
                            Data.Functor.Classes.liftCompare
                                $dOrd2_sgar0 w_sgara ww2_sgar6 ww5_sgar9;
                        GHC.Types.GT -> GHC.Types.GT [];
                      };
              };
        };

Data.Functor.Product.$fOrdProduct_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Eq (Data.Functor.Product.Product f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgarc $dOrd2_sgard $dOrd_sgare]
        let {
          sat_sgarh [Occ=Once, Dmd=<L,U(U,A)>] :: GHC.Classes.Eq a_ag44e
          [LclId] =
              [$dOrd_sgare] \u [] GHC.Classes.$p1Ord $dOrd_sgare; } in
        let {
          sat_sgarg [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 g_ag44d
          [LclId] =
              [$dOrd2_sgard] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sgard; } in
        let {
          sat_sgarf [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 f_ag44c
          [LclId] =
              [$dOrd1_sgarc] \u [] Data.Functor.Classes.$p1Ord1 $dOrd1_sgarc;
        } in 
          Data.Functor.Product.$fEqProduct sat_sgarf sat_sgarg sat_sgarh;

Data.Functor.Product.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgari
           w1_sgarj
           w2_sgark
           ww_sgarl
           ww1_sgarm
           ww2_sgarn
           ww3_sgaro]
        let {
          comp_sgarp :: a_sg4Q3 -> a_sg4Q3 -> GHC.Types.Ordering
          [LclId] =
              [w2_sgark] \u [] GHC.Classes.compare w2_sgark;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sgari comp_sgarp ww_sgarl ww2_sgarn
          of
          { GHC.Types.LT -> GHC.Types.True [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sgarj comp_sgarp ww1_sgarm ww3_sgaro
                of
                { __DEFAULT -> GHC.Types.False [];
                  GHC.Types.LT -> GHC.Types.True [];
                };
            GHC.Types.GT -> GHC.Types.False [];
          };

Data.Functor.Product.$fOrdProduct_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgars w1_sgart w2_sgaru w3_sgarv w4_sgarw]
        case w3_sgarv of {
          Data.Functor.Product.Pair ww1_sgary [Occ=Once]
                                    ww2_sgarz [Occ=Once] ->
              case w4_sgarw of {
                Data.Functor.Product.Pair ww4_sgarB [Occ=Once]
                                          ww5_sgarC [Occ=Once] ->
                    Data.Functor.Product.$w$c<
                        w_sgars w1_sgart w2_sgaru ww1_sgary ww2_sgarz ww4_sgarB ww5_sgarC;
              };
        };

Data.Functor.Product.$w$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgarD
           w1_sgarE
           w2_sgarF
           ww_sgarG
           ww1_sgarH
           ww2_sgarI
           ww3_sgarJ]
        let {
          comp_sgarK :: a_sg4Qm -> a_sg4Qm -> GHC.Types.Ordering
          [LclId] =
              [w2_sgarF] \u [] GHC.Classes.compare w2_sgarF;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sgarD comp_sgarK ww_sgarG ww2_sgarI
          of
          { GHC.Types.LT -> GHC.Types.False [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sgarE comp_sgarK ww1_sgarH ww3_sgarJ
                of
                { __DEFAULT -> GHC.Types.True [];
                  GHC.Types.LT -> GHC.Types.False [];
                };
            GHC.Types.GT -> GHC.Types.True [];
          };

Data.Functor.Product.$fOrdProduct_$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgarN w1_sgarO w2_sgarP w3_sgarQ w4_sgarR]
        case w3_sgarQ of {
          Data.Functor.Product.Pair ww1_sgarT [Occ=Once]
                                    ww2_sgarU [Occ=Once] ->
              case w4_sgarR of {
                Data.Functor.Product.Pair ww4_sgarW [Occ=Once]
                                          ww5_sgarX [Occ=Once] ->
                    Data.Functor.Product.$w$c>=
                        w_sgarN w1_sgarO w2_sgarP ww1_sgarT ww2_sgarU ww4_sgarW ww5_sgarX;
              };
        };

Data.Functor.Product.$w$c> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgarY
           w1_sgarZ
           w2_sgas0
           ww_sgas1
           ww1_sgas2
           ww2_sgas3
           ww3_sgas4]
        let {
          comp_sgas5 :: a_sg4QF -> a_sg4QF -> GHC.Types.Ordering
          [LclId] =
              [w2_sgas0] \u [] GHC.Classes.compare w2_sgas0;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sgarY comp_sgas5 ww_sgas1 ww2_sgas3
          of
          { GHC.Types.LT -> GHC.Types.False [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sgarZ comp_sgas5 ww1_sgas2 ww3_sgas4
                of
                { __DEFAULT -> GHC.Types.False [];
                  GHC.Types.GT -> GHC.Types.True [];
                };
            GHC.Types.GT -> GHC.Types.True [];
          };

Data.Functor.Product.$fOrdProduct_$c> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgas8 w1_sgas9 w2_sgasa w3_sgasb w4_sgasc]
        case w3_sgasb of {
          Data.Functor.Product.Pair ww1_sgase [Occ=Once]
                                    ww2_sgasf [Occ=Once] ->
              case w4_sgasc of {
                Data.Functor.Product.Pair ww4_sgash [Occ=Once]
                                          ww5_sgasi [Occ=Once] ->
                    Data.Functor.Product.$w$c>
                        w_sgas8 w1_sgas9 w2_sgasa ww1_sgase ww2_sgasf ww4_sgash ww5_sgasi;
              };
        };

Data.Functor.Product.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgasj
           w1_sgask
           w2_sgasl
           ww_sgasm
           ww1_sgasn
           ww2_sgaso
           ww3_sgasp]
        let {
          comp_sgasq :: a_sg4QY -> a_sg4QY -> GHC.Types.Ordering
          [LclId] =
              [w2_sgasl] \u [] GHC.Classes.compare w2_sgasl;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sgasj comp_sgasq ww_sgasm ww2_sgaso
          of
          { GHC.Types.LT -> GHC.Types.True [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sgask comp_sgasq ww1_sgasn ww3_sgasp
                of
                { __DEFAULT -> GHC.Types.True [];
                  GHC.Types.GT -> GHC.Types.False [];
                };
            GHC.Types.GT -> GHC.Types.False [];
          };

Data.Functor.Product.$fOrdProduct_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgast w1_sgasu w2_sgasv w3_sgasw w4_sgasx]
        case w3_sgasw of {
          Data.Functor.Product.Pair ww1_sgasz [Occ=Once]
                                    ww2_sgasA [Occ=Once] ->
              case w4_sgasx of {
                Data.Functor.Product.Pair ww4_sgasC [Occ=Once]
                                          ww5_sgasD [Occ=Once] ->
                    Data.Functor.Product.$w$c<=
                        w_sgast w1_sgasu w2_sgasv ww1_sgasz ww2_sgasA ww4_sgasC ww5_sgasD;
              };
        };

Data.Functor.Product.$fOrdProduct_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgasE $dOrd2_sgasF $dOrd_sgasG x_sgasH y_sgasI]
        case x_sgasH of ww_sgasJ {
          Data.Functor.Product.Pair ww1_sgasK [Occ=Once]
                                    ww2_sgasL [Occ=Once] ->
              case y_sgasI of ww3_sgasM {
                Data.Functor.Product.Pair ww4_sgasN [Occ=Once]
                                          ww5_sgasO [Occ=Once] ->
                    let {
                      comp_sgasP :: a_ag44e -> a_ag44e -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sgasG] \u [] GHC.Classes.compare $dOrd_sgasG;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sgasE comp_sgasP ww1_sgasK ww4_sgasN
                      of
                      { GHC.Types.LT -> ww3_sgasM;
                        GHC.Types.EQ ->
                            case
                                Data.Functor.Classes.liftCompare
                                    $dOrd2_sgasF comp_sgasP ww2_sgasL ww5_sgasO
                            of
                            { __DEFAULT -> ww3_sgasM;
                              GHC.Types.GT -> ww_sgasJ;
                            };
                        GHC.Types.GT -> ww_sgasJ;
                      };
              };
        };

Data.Functor.Product.$fOrdProduct_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgasS $dOrd2_sgasT $dOrd_sgasU x_sgasV y_sgasW]
        case x_sgasV of ww_sgasX {
          Data.Functor.Product.Pair ww1_sgasY [Occ=Once]
                                    ww2_sgasZ [Occ=Once] ->
              case y_sgasW of ww3_sgat0 {
                Data.Functor.Product.Pair ww4_sgat1 [Occ=Once]
                                          ww5_sgat2 [Occ=Once] ->
                    let {
                      comp_sgat3 :: a_ag44e -> a_ag44e -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sgasU] \u [] GHC.Classes.compare $dOrd_sgasU;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sgasS comp_sgat3 ww1_sgasY ww4_sgat1
                      of
                      { GHC.Types.LT -> ww_sgasX;
                        GHC.Types.EQ ->
                            case
                                Data.Functor.Classes.liftCompare
                                    $dOrd2_sgasT comp_sgat3 ww2_sgasZ ww5_sgat2
                            of
                            { __DEFAULT -> ww_sgasX;
                              GHC.Types.GT -> ww3_sgat0;
                            };
                        GHC.Types.GT -> ww3_sgat0;
                      };
              };
        };

Data.Functor.Product.$fOrdProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Ord (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m] =
    [] \r [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8]
        let {
          sat_sgatg [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$cmin
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgatf [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$cmax
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgate [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c>=
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgatd [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c>
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgatc [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c<=
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgatb [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c<
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgata [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$ccompare
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgat9 [Occ=Once]
            :: GHC.Classes.Eq
                 (Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e)
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \u []
                  Data.Functor.Product.$fOrdProduct_$cp1Ord
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8;
        } in 
          GHC.Classes.C:Ord [sat_sgat9
                             sat_sgata
                             sat_sgatb
                             sat_sgatc
                             sat_sgatd
                             sat_sgate
                             sat_sgatf
                             sat_sgatg];

Data.Functor.Product.$fReadProduct_$creadPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       (Data.Functor.Product.Product f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgath $dRead2_sgati $dRead_sgatj]
        let {
          sat_sgatl [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag43H]
          [LclId] =
              [$dRead_sgatj] \u [] GHC.Read.readListPrec $dRead_sgatj; } in
        let {
          sat_sgatk [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag43H
          [LclId] =
              [$dRead_sgatj] \u [] GHC.Read.readPrec $dRead_sgatj;
        } in 
          Data.Functor.Product.$fRead1Product_$cliftReadPrec
              $dRead1_sgath $dRead2_sgati sat_sgatk sat_sgatl;

Data.Functor.Product.$fReadProduct_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Product.Product f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgatm $dRead2_sgatn $dRead_sgato]
        let {
          ds_sgatp [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sgatm $dRead2_sgatn $dRead_sgato] \u []
                  let {
                    sat_sgatr [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag43H]
                    [LclId] =
                        [$dRead_sgato] \u [] GHC.Read.readListPrec $dRead_sgato; } in
                  let {
                    sat_sgatq [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag43H
                    [LclId] =
                        [$dRead_sgato] \u [] GHC.Read.readPrec $dRead_sgato;
                  } in 
                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                        $dRead1_sgatm $dRead2_sgatn sat_sgatq sat_sgatr; } in
        let {
          sat_sgatu [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [ds_sgatp] \r [n_sgats]
                  let {
                    sat_sgatt [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
                    [LclId] =
                        [ds_sgatp n_sgats] \u []
                            ds_sgatp
                                n_sgats Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgatt;
        } in  sat_sgatu;

Data.Functor.Product.$fReadProduct_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Product.Product f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgatv $dRead2_sgatw $dRead_sgatx]
        let {
          sat_sgatA [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sgatv $dRead2_sgatw $dRead_sgatx] \s []
                  let {
                    sat_sgatz [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag43H]
                    [LclId] =
                        [$dRead_sgatx] \u [] GHC.Read.readListPrec $dRead_sgatx; } in
                  let {
                    sat_sgaty [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag43H
                    [LclId] =
                        [$dRead_sgatx] \u [] GHC.Read.readPrec $dRead_sgatx;
                  } in 
                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                        $dRead1_sgatv $dRead2_sgatw sat_sgaty sat_sgatz;
        } in  GHC.Read.list sat_sgatA;

Data.Functor.Product.$fReadProduct_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Functor.Product.Product f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgatB $dRead2_sgatC $dRead_sgatD]
        let {
          sat_sgatE [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H]
          [LclId] =
              [$dRead1_sgatB $dRead2_sgatC $dRead_sgatD] \u []
                  Data.Functor.Product.$fReadProduct_$creadListPrec
                      $dRead1_sgatB
                      $dRead2_sgatC
                      $dRead_sgatD
                      GHC.Read.$fRead()7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgatE;

Data.Functor.Product.$fReadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Read.Read (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,U,U)>m] =
    [] \r [$dRead1_sgatF $dRead2_sgatG $dRead_sgatH]
        let {
          sat_sgatL [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H]
          [LclId] =
              [$dRead1_sgatF $dRead2_sgatG $dRead_sgatH] \u []
                  Data.Functor.Product.$fReadProduct_$creadListPrec
                      $dRead1_sgatF $dRead2_sgatG $dRead_sgatH; } in
        let {
          sat_sgatK [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sgatF $dRead2_sgatG $dRead_sgatH] \u []
                  Data.Functor.Product.$fReadProduct_$creadPrec
                      $dRead1_sgatF $dRead2_sgatG $dRead_sgatH; } in
        let {
          sat_sgatJ [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H]
          [LclId] =
              [$dRead1_sgatF $dRead2_sgatG $dRead_sgatH] \u []
                  Data.Functor.Product.$fReadProduct_$creadList
                      $dRead1_sgatF $dRead2_sgatG $dRead_sgatH; } in
        let {
          sat_sgatI [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sgatF $dRead2_sgatG $dRead_sgatH] \u []
                  Data.Functor.Product.$fReadProduct_$creadsPrec
                      $dRead1_sgatF $dRead2_sgatG $dRead_sgatH;
        } in  GHC.Read.C:Read [sat_sgatI sat_sgatJ sat_sgatK sat_sgatL];

Data.Functor.Product.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Prim.Int# -> f a -> g a -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgatM w1_sgatN w2_sgatO ww_sgatP ww1_sgatQ ww2_sgatR]
        let {
          sp_sgatS :: GHC.Types.Int -> a_sg4Rt -> GHC.Show.ShowS
          [LclId] =
              [w2_sgatO] \u [] GHC.Show.showsPrec w2_sgatO; } in
        let {
          sl_sgatT :: [a_sg4Rt] -> GHC.Show.ShowS
          [LclId] =
              [w2_sgatO] \u [] GHC.Show.showList w2_sgatO; } in
        let {
          sat_sgatV [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> g_sg4Rs a_sg4Rt -> GHC.Show.ShowS
          [LclId] =
              [w1_sgatN sp_sgatS sl_sgatT] \s []
                  Data.Functor.Classes.liftShowsPrec w1_sgatN sp_sgatS sl_sgatT; } in
        let {
          sat_sgatU [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> f_sg4Rr a_sg4Rt -> GHC.Show.ShowS
          [LclId] =
              [w_sgatM sp_sgatS sl_sgatT] \s []
                  Data.Functor.Classes.liftShowsPrec w_sgatM sp_sgatS sl_sgatT;
        } in 
          Data.Functor.Classes.$wshowsBinaryWith
              sat_sgatU
              sat_sgatV
              Data.Functor.Product.$fRead1Product2
              ww_sgatP
              ww1_sgatQ
              ww2_sgatR;

Data.Functor.Product.$fShowProduct_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Types.Int
     -> Data.Functor.Product.Product f g a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgatW w1_sgatX w2_sgatY w3_sgatZ w4_sgau0]
        case w3_sgatZ of {
          GHC.Types.I# ww1_sgau2 [Occ=Once] ->
              case w4_sgau0 of {
                Data.Functor.Product.Pair ww3_sgau4 [Occ=Once]
                                          ww4_sgau5 [Occ=Once] ->
                    Data.Functor.Product.$w$cshowsPrec
                        w_sgatW w1_sgatX w2_sgatY ww1_sgau2 ww3_sgau4 ww4_sgau5;
              };
        };

Data.Functor.Product.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     f a -> g a -> GHC.Base.String
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*U,A,1*U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgau6 w1_sgau7 w2_sgau8 ww_sgau9 ww1_sgaua]
        let {
          sp_sgaub :: GHC.Types.Int -> a_sg4RL -> GHC.Show.ShowS
          [LclId] =
              [w2_sgau8] \u [] GHC.Show.showsPrec w2_sgau8; } in
        let {
          sl_sgauc :: [a_sg4RL] -> GHC.Show.ShowS
          [LclId] =
              [w2_sgau8] \u [] GHC.Show.showList w2_sgau8; } in
        let {
          sat_sgauf [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [w_sgau6 w1_sgau7 ww_sgau9 ww1_sgaua sp_sgaub sl_sgauc] \u []
                  let {
                    sat_sgaud [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [w1_sgau7 ww1_sgaua sp_sgaub sl_sgauc] \u []
                            Data.Functor.Classes.liftShowsPrec
                                w1_sgau7
                                sp_sgaub
                                sl_sgauc
                                Data.Functor.Classes.$fRead1Const1
                                ww1_sgaua
                                GHC.Types.[]; } in
                  let {
                    sat_sgaue [Occ=Once] :: GHC.Base.String
                    [LclId] =
                        CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sgaud];
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w_sgau6
                        sp_sgaub
                        sl_sgauc
                        Data.Functor.Classes.$fRead1Const1
                        ww_sgau9
                        sat_sgaue; } in
        let {
          sat_sgaug [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sgauf];
        } in  GHC.Base.++ Data.Functor.Product.$fRead1Product2 sat_sgaug;

Data.Functor.Product.$fShowProduct_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     Data.Functor.Product.Product f g a -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(U,A,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgauh w1_sgaui w2_sgauj w3_sgauk]
        case w3_sgauk of {
          Data.Functor.Product.Pair ww1_sgaum [Occ=Once]
                                    ww2_sgaun [Occ=Once] ->
              Data.Functor.Product.$w$cshow
                  w_sgauh w1_sgaui w2_sgauj ww1_sgaum ww2_sgaun;
        };

Data.Functor.Product.$fShowProduct_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     [Data.Functor.Product.Product f g a] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgauo $dShow2_sgaup $dShow_sgauq ls_sgaur s_sgaus]
        let {
          lvl9_sgaut [Occ=OnceL]
            :: GHC.Types.Int -> a_ag43h -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgauq] \u [] GHC.Show.showsPrec $dShow_sgauq; } in
        let {
          lvl10_sgauu [Occ=OnceL] :: [a_ag43h] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgauq] \u [] GHC.Show.showList $dShow_sgauq; } in
        let {
          sat_sgauz [Occ=Once]
            :: Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgauo $dShow2_sgaup lvl9_sgaut lvl10_sgauu] \r [eta_sgauv]
                  case eta_sgauv of {
                    Data.Functor.Product.Pair ww1_sgaux [Occ=Once]
                                              ww2_sgauy [Occ=Once] ->
                        Data.Functor.Product.$w$cliftShowsPrec
                            $dShow1_sgauo
                            $dShow2_sgaup
                            lvl9_sgaut
                            lvl10_sgauu
                            0#
                            ww1_sgaux
                            ww2_sgauy;
                  };
        } in  GHC.Show.showList__ sat_sgauz ls_sgaur s_sgaus;

Data.Functor.Product.$fShowProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Show.Show (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(U,A,U)>m] =
    [] \r [$dShow1_sgauA $dShow2_sgauB $dShow_sgauC]
        let {
          sat_sgauF [Occ=Once]
            :: [Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgauA $dShow2_sgauB $dShow_sgauC] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fShowProduct_$cshowList
                      $dShow1_sgauA $dShow2_sgauB $dShow_sgauC eta_B2 eta_B1; } in
        let {
          sat_sgauE [Occ=Once]
            :: Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h
               -> GHC.Base.String
          [LclId] =
              [$dShow1_sgauA $dShow2_sgauB $dShow_sgauC] \r [eta_B1]
                  Data.Functor.Product.$fShowProduct_$cshow
                      $dShow1_sgauA $dShow2_sgauB $dShow_sgauC eta_B1; } in
        let {
          sat_sgauD [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgauA $dShow2_sgauB $dShow_sgauC] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fShowProduct_$cshowsPrec
                      $dShow1_sgauA $dShow2_sgauB $dShow_sgauC eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgauD sat_sgauE sat_sgauF];

Data.Functor.Product.$fFunctorProduct_$cfmap
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgauG $dFunctor1_sgauH f1_sgauI ds_sgauJ]
        case ds_sgauJ of {
          Data.Functor.Product.Pair x_sgauL [Occ=Once] y_sgauM [Occ=Once] ->
              let {
                sat_sgauO [Occ=Once] :: g_ag42H b_ag42O
                [LclId] =
                    [$dFunctor1_sgauH f1_sgauI y_sgauM] \u []
                        GHC.Base.fmap $dFunctor1_sgauH f1_sgauI y_sgauM; } in
              let {
                sat_sgauN [Occ=Once] :: f_ag42G b_ag42O
                [LclId] =
                    [$dFunctor_sgauG f1_sgauI x_sgauL] \u []
                        GHC.Base.fmap $dFunctor_sgauG f1_sgauI x_sgauL;
              } in  Data.Functor.Product.Pair [sat_sgauN sat_sgauO];
        };

Data.Functor.Product.$fFunctorProduct_$c<$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgauP w1_sgauQ w2_sgauR w3_sgauS]
        case w3_sgauS of {
          Data.Functor.Product.Pair ww1_sgauU [Occ=Once]
                                    ww2_sgauV [Occ=Once] ->
              let {
                f1_sgauW :: b_sg4S9 -> a_sg4S8
                [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
                    [w2_sgauR] \r [ds_sgauX] w2_sgauR; } in
              let {
                sat_sgauZ [Occ=Once] :: g_sg4S5 a_sg4S8
                [LclId] =
                    [w1_sgauQ ww2_sgauV f1_sgauW] \u []
                        GHC.Base.fmap w1_sgauQ f1_sgauW ww2_sgauV; } in
              let {
                sat_sgauY [Occ=Once] :: f_sg4S4 a_sg4S8
                [LclId] =
                    [w_sgauP ww1_sgauU f1_sgauW] \u []
                        GHC.Base.fmap w_sgauP f1_sgauW ww1_sgauU;
              } in  Data.Functor.Product.Pair [sat_sgauY sat_sgauZ];
        };

Data.Functor.Product.$fFunctorProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     GHC.Base.Functor (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dFunctor_sgav0 $dFunctor1_sgav1]
        let {
          sat_sgav3 [Occ=Once]
            :: forall a b.
               a
               -> Data.Functor.Product.Product f_ag42G g_ag42H b
               -> Data.Functor.Product.Product f_ag42G g_ag42H a
          [LclId] =
              [$dFunctor_sgav0 $dFunctor1_sgav1] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFunctorProduct_$c<$
                      $dFunctor_sgav0 $dFunctor1_sgav1 eta_B2 eta_B1; } in
        let {
          sat_sgav2 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Product.Product f_ag42G g_ag42H a
               -> Data.Functor.Product.Product f_ag42G g_ag42H b
          [LclId] =
              [$dFunctor_sgav0 $dFunctor1_sgav1] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFunctorProduct_$cfmap
                      $dFunctor_sgav0 $dFunctor1_sgav1 eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sgav2 sat_sgav3];

Data.Functor.Product.$w$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> f a -> g a -> m
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgav4 w1_sgav5 w2_sgav6 w3_sgav7 ww_sgav8 ww1_sgav9]
        let {
          sat_sgavb [Occ=Once] :: m_sg4Sp
          [LclId] =
              [w1_sgav5 w2_sgav6 w3_sgav7 ww1_sgav9] \u []
                  Data.Foldable.foldMap w1_sgav5 w2_sgav6 w3_sgav7 ww1_sgav9; } in
        let {
          sat_sgava [Occ=Once] :: m_sg4Sp
          [LclId] =
              [w_sgav4 w2_sgav6 w3_sgav7 ww_sgav8] \u []
                  Data.Foldable.foldMap w_sgav4 w2_sgav6 w3_sgav7 ww_sgav8;
        } in  GHC.Base.mappend w2_sgav6 sat_sgava sat_sgavb;

Data.Functor.Product.$fFoldableProduct_$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Functor.Product.Product f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgavc w1_sgavd w2_sgave w3_sgavf w4_sgavg]
        case w4_sgavg of {
          Data.Functor.Product.Pair ww1_sgavi [Occ=Once]
                                    ww2_sgavj [Occ=Once] ->
              Data.Functor.Product.$w$cfoldMap
                  w_sgavc w1_sgavd w2_sgave w3_sgavf ww1_sgavi ww2_sgavj;
        };

Data.Functor.Product.$fFoldableProduct_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m.
     GHC.Base.Monoid m =>
     Data.Functor.Product.Product f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgavk $dFoldable1_sgavl $dMonoid_sgavm w_sgavn]
        case w_sgavn of {
          Data.Functor.Product.Pair ww1_sgavp [Occ=Once]
                                    ww2_sgavq [Occ=Once] ->
              Data.Functor.Product.$w$cfoldMap
                  $dFoldable_sgavk
                  $dFoldable1_sgavl
                  $dMonoid_sgavm
                  GHC.Base.id
                  ww1_sgavp
                  ww2_sgavq;
        };

Data.Functor.Product.$fFoldableProduct1 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgavr] v_sgavr;

Data.Functor.Product.$fFoldableProduct_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgavs $dFoldable1_sgavt $dNum_sgavu]
        let {
          $dMonoid_sgavv
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_ag42n)
          [LclId] =
              [$dNum_sgavu] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sgavu; } in
        let {
          sat_sgavC [Occ=Once]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag42n
               -> Data.Semigroup.Internal.Sum a_ag42n
          [LclId] =
              [$dFoldable_sgavs
               $dFoldable1_sgavt
               $dNum_sgavu
               $dMonoid_sgavv] \r [ds_sgavw]
                  case ds_sgavw of {
                    Data.Functor.Product.Pair x_sgavy [Occ=Once] y_sgavz [Occ=Once] ->
                        let {
                          sat_sgavB [Occ=Once] :: a_ag42n
                          [LclId] =
                              [$dFoldable1_sgavt $dMonoid_sgavv y_sgavz] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_sgavt
                                      $dMonoid_sgavv
                                      Data.Functor.Product.$fFoldableProduct1
                                      y_sgavz; } in
                        let {
                          sat_sgavA [Occ=Once] :: a_ag42n
                          [LclId] =
                              [$dFoldable_sgavs $dMonoid_sgavv x_sgavy] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_sgavs
                                      $dMonoid_sgavv
                                      Data.Functor.Product.$fFoldableProduct1
                                      x_sgavy;
                        } in  GHC.Num.+ $dNum_sgavu sat_sgavA sat_sgavB;
                  };
        } in  sat_sgavC;

lvl_rg5nW :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Functor.Product.$fFoldableProduct2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rg5nW of sat_sgavD {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgavD;
        };

Data.Functor.Product.$fFoldableProduct_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgavE $dFoldable1_sgavF $dOrd_sgavG]
        let {
          $dMonoid_sgavH :: GHC.Base.Monoid (Data.Functor.Utils.Min a_ag42d)
          [LclId] =
              [$dOrd_sgavG] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_sgavG; } in
        let {
          sat_sgavT [Occ=OnceT[0]]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag42d -> a_ag42d
          [LclId] =
              [$dFoldable_sgavE
               $dFoldable1_sgavF
               $dOrd_sgavG
               $dMonoid_sgavH] \r [x_sgavI]
                  case x_sgavI of {
                    Data.Functor.Product.Pair x1_sgavK [Occ=Once*]
                                              y_sgavL [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sgavF $dMonoid_sgavH GHC.Base.Just y_sgavL
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sgavE $dMonoid_sgavH GHC.Base.Just x1_sgavK
                              of
                              { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct2;
                                GHC.Base.Just v_sgavO [Occ=Once] -> v_sgavO;
                              };
                          GHC.Base.Just ipv_sgavP ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sgavE $dMonoid_sgavH GHC.Base.Just x1_sgavK
                              of
                              { GHC.Base.Nothing -> ipv_sgavP;
                                GHC.Base.Just x2_sgavR ->
                                    case GHC.Classes.<= $dOrd_sgavG x2_sgavR ipv_sgavP of {
                                      GHC.Types.False -> ipv_sgavP;
                                      GHC.Types.True -> x2_sgavR;
                                    };
                              };
                        };
                  };
        } in  sat_sgavT;

lvl1_rg5nX :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Functor.Product.$fFoldableProduct3 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rg5nX of sat_sgavU {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgavU;
        };

Data.Functor.Product.$fFoldableProduct_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgavV $dFoldable1_sgavW $dOrd_sgavX]
        let {
          $dMonoid_sgavY :: GHC.Base.Monoid (Data.Functor.Utils.Max a_ag423)
          [LclId] =
              [$dOrd_sgavX] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_sgavX; } in
        let {
          sat_sgawa [Occ=OnceT[0]]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag423 -> a_ag423
          [LclId] =
              [$dFoldable_sgavV
               $dFoldable1_sgavW
               $dOrd_sgavX
               $dMonoid_sgavY] \r [x_sgavZ]
                  case x_sgavZ of {
                    Data.Functor.Product.Pair x1_sgaw1 [Occ=Once*]
                                              y_sgaw2 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sgavW $dMonoid_sgavY GHC.Base.Just y_sgaw2
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sgavV $dMonoid_sgavY GHC.Base.Just x1_sgaw1
                              of
                              { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct3;
                                GHC.Base.Just v_sgaw5 [Occ=Once] -> v_sgaw5;
                              };
                          GHC.Base.Just ipv_sgaw6 ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sgavV $dMonoid_sgavY GHC.Base.Just x1_sgaw1
                              of
                              { GHC.Base.Nothing -> ipv_sgaw6;
                                GHC.Base.Just x2_sgaw8 ->
                                    case GHC.Classes.>= $dOrd_sgavX x2_sgaw8 ipv_sgaw6 of {
                                      GHC.Types.False -> ipv_sgaw6;
                                      GHC.Types.True -> x2_sgaw8;
                                    };
                              };
                        };
                  };
        } in  sat_sgawa;

Data.Functor.Product.$fFoldableProduct_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgawb $dFoldable1_sgawc $dEq_sgawd eta_sgawe]
        let {
          f1_sgawf :: a_ag41T -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgawd eta_sgawe] \u []
                  GHC.Classes.== $dEq_sgawd eta_sgawe; } in
        let {
          sat_sgawl [Occ=Once]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag41T
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_sgawb $dFoldable1_sgawc f1_sgawf] \r [ds_sgawg]
                  case ds_sgawg of {
                    Data.Functor.Product.Pair x_sgawi [Occ=Once] y_sgawj [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_sgawb
                                Data.Semigroup.Internal.$fMonoidAny
                                f1_sgawf
                                x_sgawi
                        of
                        { GHC.Types.False ->
                              Data.Foldable.foldMap
                                  $dFoldable1_sgawc
                                  Data.Semigroup.Internal.$fMonoidAny
                                  f1_sgawf
                                  y_sgawj;
                          GHC.Types.True -> GHC.Types.True [];
                        };
                  };
        } in  sat_sgawl;

Data.Functor.Product.$fFoldableProduct8
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Functor.Product.$w$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgawm w1_sgawn w2_sgawo w3_sgawp ww_sgawq ww1_sgawr]
        let {
          f1_sgaws :: a_sg4T4 -> b_sg4T3 -> b_sg4T3
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [w2_sgawo] \r [x_sgawt y_sgawu] w2_sgawo y_sgawu x_sgawt; } in
        let {
          sat_sgawv [Occ=Once] :: b_sg4T3
          [LclId] =
              [w_sgawm w3_sgawp ww_sgawq f1_sgaws] \u []
                  Data.Foldable.foldMap
                      w_sgawm
                      Data.Functor.Product.$fFoldableProduct8
                      f1_sgaws
                      ww_sgawq
                      w3_sgawp;
        } in 
          Data.Foldable.foldMap
              w1_sgawn
              Data.Functor.Product.$fFoldableProduct8
              f1_sgaws
              ww1_sgawr
              sat_sgawv;

Data.Functor.Product.$fFoldableProduct_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaww w1_sgawx w2_sgawy w3_sgawz w4_sgawA]
        case w4_sgawA of {
          Data.Functor.Product.Pair ww1_sgawC [Occ=Once]
                                    ww2_sgawD [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl
                  w_sgaww w1_sgawx w2_sgawy w3_sgawz ww1_sgawC ww2_sgawD;
        };

lvl2_rg5nY :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Functor.Product.$fFoldableProduct7 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rg5nY of sat_sgawE {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgawE;
        };

Data.Functor.Product.$w$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgawF w1_sgawG w2_sgawH ww_sgawI ww1_sgawJ]
        let {
          f1_sgawK
            :: a_sg4Ti -> GHC.Base.Maybe a_sg4Ti -> GHC.Base.Maybe a_sg4Ti
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_sgawH] \r [x_sgawL y_sgawM]
                  let {
                    sat_sgawP [Occ=Once] :: a_sg4Ti
                    [LclId] =
                        [w2_sgawH x_sgawL y_sgawM] \u []
                            case y_sgawM of {
                              GHC.Base.Nothing -> x_sgawL;
                              GHC.Base.Just x1_sgawO [Occ=Once] -> w2_sgawH x1_sgawO x_sgawL;
                            };
                  } in  GHC.Base.Just [sat_sgawP]; } in
        let {
          sat_sgawQ [Occ=Once] :: GHC.Base.Maybe a_sg4Ti
          [LclId] =
              [w_sgawF ww_sgawI f1_sgawK] \u []
                  Data.Foldable.foldMap
                      w_sgawF
                      Data.Functor.Product.$fFoldableProduct8
                      f1_sgawK
                      ww_sgawI
                      GHC.Base.Nothing;
        } in 
          case
              Data.Foldable.foldMap
                  w1_sgawG
                  Data.Functor.Product.$fFoldableProduct8
                  f1_sgawK
                  ww1_sgawJ
                  sat_sgawQ
          of
          { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct7;
            GHC.Base.Just v_sgawS [Occ=Once] -> v_sgawS;
          };

Data.Functor.Product.$fFoldableProduct_$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgawT w1_sgawU w2_sgawV w3_sgawW]
        case w3_sgawW of {
          Data.Functor.Product.Pair ww1_sgawY [Occ=Once]
                                    ww2_sgawZ [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl1
                  w_sgawT w1_sgawU w2_sgawV ww1_sgawY ww2_sgawZ;
        };

Data.Functor.Product.$w$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgax0 w1_sgax1 w2_sgax2 w3_sgax3 ww_sgax4 ww1_sgax5]
        let {
          f1_sgax6 :: a_sg4Tv -> (b_sg4Tw -> b_sg4Tw) -> b_sg4Tw -> b_sg4Tw
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_sgax2] \r [x_sgax7 y_sgax8 z_sgax9]
                  case w2_sgax2 x_sgax7 z_sgax9 of vx_sgaxa {
                    __DEFAULT -> y_sgax8 vx_sgaxa;
                  }; } in
        let {
          sat_sgaxb [Occ=Once] :: b_sg4Tw -> b_sg4Tw
          [LclId] =
              [w_sgax0 ww_sgax4 f1_sgax6] \u []
                  Data.Foldable.foldMap
                      w_sgax0
                      Data.Functor.Product.$fFoldableProduct8
                      f1_sgax6
                      ww_sgax4
                      GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              w1_sgax1
              Data.Functor.Product.$fFoldableProduct8
              f1_sgax6
              ww1_sgax5
              sat_sgaxb
              w3_sgax3;

Data.Functor.Product.$fFoldableProduct_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaxc w1_sgaxd w2_sgaxe w3_sgaxf w4_sgaxg]
        case w4_sgaxg of {
          Data.Functor.Product.Pair ww1_sgaxi [Occ=Once]
                                    ww2_sgaxj [Occ=Once] ->
              Data.Functor.Product.$w$cfoldr'
                  w_sgaxc w1_sgaxd w2_sgaxe w3_sgaxf ww1_sgaxi ww2_sgaxj;
        };

Data.Functor.Product.$w$cfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaxk w1_sgaxl w2_sgaxm w3_sgaxn ww_sgaxo ww1_sgaxp]
        let {
          sat_sgaxq [Occ=Once] :: b_sg4TL
          [LclId] =
              [w1_sgaxl w2_sgaxm w3_sgaxn ww1_sgaxp] \u []
                  Data.Foldable.foldMap
                      w1_sgaxl
                      Data.Semigroup.Internal.$fMonoidEndo
                      w2_sgaxm
                      ww1_sgaxp
                      w3_sgaxn;
        } in 
          Data.Foldable.foldMap
              w_sgaxk
              Data.Semigroup.Internal.$fMonoidEndo
              w2_sgaxm
              ww_sgaxo
              sat_sgaxq;

Data.Functor.Product.$fFoldableProduct_$cfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaxr w1_sgaxs w2_sgaxt w3_sgaxu w4_sgaxv]
        case w4_sgaxv of {
          Data.Functor.Product.Pair ww1_sgaxx [Occ=Once]
                                    ww2_sgaxy [Occ=Once] ->
              Data.Functor.Product.$w$cfoldr
                  w_sgaxr w1_sgaxs w2_sgaxt w3_sgaxu ww1_sgaxx ww2_sgaxy;
        };

Data.Functor.Product.$w$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaxz w1_sgaxA w2_sgaxB w3_sgaxC ww_sgaxD ww1_sgaxE]
        let {
          f1_sgaxF :: a_sg4U0 -> (b_sg4TZ -> b_sg4TZ) -> b_sg4TZ -> b_sg4TZ
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_sgaxB] \r [x_sgaxG k_sgaxH z_sgaxI]
                  case w2_sgaxB z_sgaxI x_sgaxG of vx_sgaxJ {
                    __DEFAULT -> k_sgaxH vx_sgaxJ;
                  }; } in
        let {
          sat_sgaxK [Occ=Once] :: b_sg4TZ -> b_sg4TZ
          [LclId] =
              [w1_sgaxA ww1_sgaxE f1_sgaxF] \u []
                  Data.Foldable.foldMap
                      w1_sgaxA
                      Data.Semigroup.Internal.$fMonoidEndo
                      f1_sgaxF
                      ww1_sgaxE
                      GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              w_sgaxz
              Data.Semigroup.Internal.$fMonoidEndo
              f1_sgaxF
              ww_sgaxD
              sat_sgaxK
              w3_sgaxC;

Data.Functor.Product.$fFoldableProduct_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaxL w1_sgaxM w2_sgaxN w3_sgaxO w4_sgaxP]
        case w4_sgaxP of {
          Data.Functor.Product.Pair ww1_sgaxR [Occ=Once]
                                    ww2_sgaxS [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl'
                  w_sgaxL w1_sgaxM w2_sgaxN w3_sgaxO ww1_sgaxR ww2_sgaxS;
        };

Data.Functor.Product.$fFoldableProduct5
  :: forall a. GHC.Types.Int -> a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,A>m,
 Unf=OtherCon []] =
    [] \r [c_sgaxT ds_sgaxU]
        case c_sgaxT of {
          GHC.Types.I# x_sgaxW [Occ=Once] ->
              case +# [x_sgaxW 1#] of sat_sgaxX {
                __DEFAULT -> GHC.Types.I# [sat_sgaxX];
              };
        };

Data.Functor.Product.$fFoldableProduct_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Product.Product f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgaxY $dFoldable1_sgaxZ eta_sgay0]
        case eta_sgay0 of {
          Data.Functor.Product.Pair ww1_sgay2 [Occ=Once]
                                    ww2_sgay3 [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl'
                  $dFoldable_sgaxY
                  $dFoldable1_sgaxZ
                  Data.Functor.Product.$fFoldableProduct5
                  Data.Functor.Product.$fFoldableProduct4
                  ww1_sgay2
                  ww2_sgay3;
        };

lvl3_rg5nZ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Functor.Product.$fFoldableProduct9 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_rg5nZ of sat_sgay4 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgay4;
        };

Data.Functor.Product.$w$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgay5 w1_sgay6 w2_sgay7 ww_sgay8 ww1_sgay9]
        let {
          w3_sgaya
            :: a_sg4Ue -> GHC.Base.Maybe a_sg4Ue -> GHC.Base.Maybe a_sg4Ue
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_sgay7] \r [x_sgayb m_sgayc]
                  let {
                    sat_sgayf [Occ=Once] :: a_sg4Ue
                    [LclId] =
                        [w2_sgay7 x_sgayb m_sgayc] \u []
                            case m_sgayc of {
                              GHC.Base.Nothing -> x_sgayb;
                              GHC.Base.Just y_sgaye [Occ=Once] -> w2_sgay7 x_sgayb y_sgaye;
                            };
                  } in  GHC.Base.Just [sat_sgayf]; } in
        let {
          sat_sgayg [Occ=Once] :: GHC.Base.Maybe a_sg4Ue
          [LclId] =
              [w1_sgay6 ww1_sgay9 w3_sgaya] \u []
                  Data.Foldable.foldMap
                      w1_sgay6
                      Data.Semigroup.Internal.$fMonoidEndo
                      w3_sgaya
                      ww1_sgay9
                      GHC.Base.Nothing;
        } in 
          case
              Data.Foldable.foldMap
                  w_sgay5
                  Data.Semigroup.Internal.$fMonoidEndo
                  w3_sgaya
                  ww_sgay8
                  sat_sgayg
          of
          { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct9;
            GHC.Base.Just v_sgayi [Occ=Once] -> v_sgayi;
          };

Data.Functor.Product.$fFoldableProduct_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgayj w1_sgayk w2_sgayl w3_sgaym]
        case w3_sgaym of {
          Data.Functor.Product.Pair ww1_sgayo [Occ=Once]
                                    ww2_sgayp [Occ=Once] ->
              Data.Functor.Product.$w$cfoldr1
                  w_sgayj w1_sgayk w2_sgayl ww1_sgayo ww2_sgayp;
        };

Data.Functor.Product.$fFoldableProduct6
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgayq ds1_sgayr] GHC.Types.False [];

Data.Functor.Product.$fFoldableProduct_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgays $dFoldable1_sgayt eta_sgayu]
        case eta_sgayu of {
          Data.Functor.Product.Pair ww1_sgayw [Occ=Once]
                                    ww2_sgayx [Occ=Once] ->
              let {
                sat_sgayy [Occ=Once] :: GHC.Types.Bool
                [LclId] =
                    [$dFoldable1_sgayt ww2_sgayx] \u []
                        Data.Foldable.foldMap
                            $dFoldable1_sgayt
                            Data.Semigroup.Internal.$fMonoidEndo
                            Data.Functor.Product.$fFoldableProduct6
                            ww2_sgayx
                            GHC.Types.True;
              } in 
                Data.Foldable.foldMap
                    $dFoldable_sgays
                    Data.Semigroup.Internal.$fMonoidEndo
                    Data.Functor.Product.$fFoldableProduct6
                    ww1_sgayw
                    sat_sgayy;
        };

Data.Functor.Product.$fFoldableProduct_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgayz $dFoldable1_sgayA $dNum_sgayB]
        let {
          $dMonoid_sgayC
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_ag42x)
          [LclId] =
              [$dNum_sgayB] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sgayB; } in
        let {
          sat_sgayJ [Occ=Once]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag42x
               -> Data.Semigroup.Internal.Product a_ag42x
          [LclId] =
              [$dFoldable_sgayz
               $dFoldable1_sgayA
               $dNum_sgayB
               $dMonoid_sgayC] \r [ds_sgayD]
                  case ds_sgayD of {
                    Data.Functor.Product.Pair x_sgayF [Occ=Once] y_sgayG [Occ=Once] ->
                        let {
                          sat_sgayI [Occ=Once] :: a_ag42x
                          [LclId] =
                              [$dFoldable1_sgayA $dMonoid_sgayC y_sgayG] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_sgayA
                                      $dMonoid_sgayC
                                      Data.Functor.Product.$fFoldableProduct1
                                      y_sgayG; } in
                        let {
                          sat_sgayH [Occ=Once] :: a_ag42x
                          [LclId] =
                              [$dFoldable_sgayz $dMonoid_sgayC x_sgayF] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_sgayz
                                      $dMonoid_sgayC
                                      Data.Functor.Product.$fFoldableProduct1
                                      x_sgayF;
                        } in  GHC.Num.* $dNum_sgayB sat_sgayH sat_sgayI;
                  };
        } in  sat_sgayJ;

Data.Functor.Product.$fFoldableProduct_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Product.Product f g a -> [a]
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgayK $dFoldable1_sgayL eta_sgayM]
        case eta_sgayM of {
          Data.Functor.Product.Pair ww1_sgayO [Occ=Once]
                                    ww2_sgayP [Occ=Once] ->
              let {
                sat_sgayQ [Occ=Once] :: [a_ag41v]
                [LclId] =
                    [$dFoldable1_sgayL ww2_sgayP] \u []
                        Data.Foldable.foldMap
                            $dFoldable1_sgayL
                            Data.Semigroup.Internal.$fMonoidEndo
                            GHC.Types.:
                            ww2_sgayP
                            GHC.Types.[];
              } in 
                Data.Foldable.foldMap
                    $dFoldable_sgayK
                    Data.Semigroup.Internal.$fMonoidEndo
                    GHC.Types.:
                    ww1_sgayO
                    sat_sgayQ;
        };

Data.Functor.Product.$fFoldableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_sgayR $dFoldable1_sgayS]
        let {
          sat_sgaz8 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cproduct
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz7 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$csum
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz6 [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cminimum
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz5 [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cmaximum
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz4 [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a
               -> Data.Functor.Product.Product f_ag400 g_ag401 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$celem
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B2 eta_B1; } in
        let {
          sat_sgaz3 [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag400 g_ag401 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$clength
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz2 [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag400 g_ag401 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cnull
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz1 [Occ=Once]
            :: forall a. Data.Functor.Product.Product f_ag400 g_ag401 a -> [a]
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$ctoList
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz0 [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldl1
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B2 eta_B1; } in
        let {
          sat_sgayZ [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldr1
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B2 eta_B1; } in
        let {
          sat_sgayY [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldl'
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgayX [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldl
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgayW [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldr'
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgayV [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldr
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgayU [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> Data.Functor.Product.Product f_ag400 g_ag401 a -> m
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldMap
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgayT [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               Data.Functor.Product.Product f_ag400 g_ag401 m -> m
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfold
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_sgayT
                                    sat_sgayU
                                    sat_sgayV
                                    sat_sgayW
                                    sat_sgayX
                                    sat_sgayY
                                    sat_sgayZ
                                    sat_sgaz0
                                    sat_sgaz1
                                    sat_sgaz2
                                    sat_sgaz3
                                    sat_sgaz4
                                    sat_sgaz5
                                    sat_sgaz6
                                    sat_sgaz7
                                    sat_sgaz8];

Data.Functor.Product.$w$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> f a -> g a -> f1 (Data.Functor.Product.Product f g b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaz9 w1_sgaza w2_sgazb w3_sgazc ww_sgazd ww1_sgaze]
        let {
          sat_sgazg [Occ=Once] :: f1_sg4Ux (g_sg4Uu b_sg4Uz)
          [LclId] =
              [w1_sgaza w2_sgazb w3_sgazc ww1_sgaze] \u []
                  Data.Traversable.traverse
                      w1_sgaza w2_sgazb w3_sgazc ww1_sgaze; } in
        let {
          sat_sgazf [Occ=Once] :: f1_sg4Ux (f_sg4Ut b_sg4Uz)
          [LclId] =
              [w_sgaz9 w2_sgazb w3_sgazc ww_sgazd] \u []
                  Data.Traversable.traverse w_sgaz9 w2_sgazb w3_sgazc ww_sgazd;
        } in 
          GHC.Base.liftA2
              w2_sgazb Data.Functor.Product.Pair sat_sgazf sat_sgazg;

Data.Functor.Product.$fTraversableProduct_$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> Data.Functor.Product.Product f g a
     -> f1 (Data.Functor.Product.Product f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgazh w1_sgazi w2_sgazj w3_sgazk w4_sgazl]
        case w4_sgazl of {
          Data.Functor.Product.Pair ww1_sgazn [Occ=Once]
                                    ww2_sgazo [Occ=Once] ->
              Data.Functor.Product.$w$ctraverse
                  w_sgazh w1_sgazi w2_sgazj w3_sgazk ww1_sgazn ww2_sgazo;
        };

Data.Functor.Product.$fTraversableProduct_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgazp $dTraversable1_sgazq]
        let {
          sat_sgazs [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_ag3YH
          [LclId] =
              [$dTraversable1_sgazq] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sgazq; } in
        let {
          sat_sgazr [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_ag3YG
          [LclId] =
              [$dTraversable_sgazp] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sgazp;
        } in  Data.Functor.Product.$fFoldableProduct sat_sgazr sat_sgazs;

Data.Functor.Product.$fTraversableProduct_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgazt $dTraversable1_sgazu]
        let {
          sat_sgazw [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor g_ag3YH
          [LclId] =
              [$dTraversable1_sgazu] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sgazu; } in
        let {
          sat_sgazv [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_ag3YG
          [LclId] =
              [$dTraversable_sgazt] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sgazt;
        } in  Data.Functor.Product.$fFunctorProduct sat_sgazv sat_sgazw;

Data.Functor.Product.$fTraversableProduct_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     Data.Functor.Product.Product f g (f1 a)
     -> f1 (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgazx
           $dTraversable1_sgazy
           $dApplicative_sgazz
           w_sgazA]
        case w_sgazA of {
          Data.Functor.Product.Pair ww1_sgazC [Occ=Once]
                                    ww2_sgazD [Occ=Once] ->
              Data.Functor.Product.$w$ctraverse
                  $dTraversable_sgazx
                  $dTraversable1_sgazy
                  $dApplicative_sgazz
                  GHC.Base.id
                  ww1_sgazC
                  ww2_sgazD;
        };

Data.Functor.Product.$fTraversableProduct_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgazE
           $dTraversable1_sgazF
           $dMonad_sgazG
           eta_sgazH
           eta1_sgazI]
        case eta1_sgazI of {
          Data.Functor.Product.Pair ww1_sgazK [Occ=Once]
                                    ww2_sgazL [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sgazG of sat_sgazM {
                __DEFAULT ->
                    Data.Functor.Product.$w$ctraverse
                        $dTraversable_sgazE
                        $dTraversable1_sgazF
                        sat_sgazM
                        eta_sgazH
                        ww1_sgazK
                        ww2_sgazL;
              };
        };

Data.Functor.Product.$fTraversableProduct_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Product.Product f g (m a)
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgazN
           $dTraversable1_sgazO
           $dMonad_sgazP
           eta_sgazQ]
        case eta_sgazQ of {
          Data.Functor.Product.Pair ww1_sgazS [Occ=Once]
                                    ww2_sgazT [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sgazP of sat_sgazU {
                __DEFAULT ->
                    Data.Functor.Product.$w$ctraverse
                        $dTraversable_sgazN
                        $dTraversable1_sgazO
                        sat_sgazU
                        GHC.Base.id
                        ww1_sgazS
                        ww2_sgazT;
              };
        };

Data.Functor.Product.$fTraversableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sgazV $dTraversable1_sgazW]
        let {
          sat_sgaA2 [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               Data.Functor.Product.Product f_ag3YG g_ag3YH (m a)
               -> m (Data.Functor.Product.Product f_ag3YG g_ag3YH a)
          [LclId] =
              [$dTraversable_sgazV $dTraversable1_sgazW] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$csequence
                      $dTraversable_sgazV $dTraversable1_sgazW eta_B2 eta_B1; } in
        let {
          sat_sgaA1 [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> Data.Functor.Product.Product f_ag3YG g_ag3YH a
               -> m (Data.Functor.Product.Product f_ag3YG g_ag3YH b)
          [LclId] =
              [$dTraversable_sgazV $dTraversable1_sgazW] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$cmapM
                      $dTraversable_sgazV $dTraversable1_sgazW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgaA0 [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               Data.Functor.Product.Product f_ag3YG g_ag3YH (f a)
               -> f (Data.Functor.Product.Product f_ag3YG g_ag3YH a)
          [LclId] =
              [$dTraversable_sgazV $dTraversable1_sgazW] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$csequenceA
                      $dTraversable_sgazV $dTraversable1_sgazW eta_B2 eta_B1; } in
        let {
          sat_sgazZ [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> Data.Functor.Product.Product f_ag3YG g_ag3YH a
               -> f (Data.Functor.Product.Product f_ag3YG g_ag3YH b)
          [LclId] =
              [$dTraversable_sgazV $dTraversable1_sgazW] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$ctraverse
                      $dTraversable_sgazV $dTraversable1_sgazW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgazY [Occ=Once]
            :: Data.Foldable.Foldable
                 (Data.Functor.Product.Product f_ag3YG g_ag3YH)
          [LclId] =
              [$dTraversable_sgazV $dTraversable1_sgazW] \u []
                  Data.Functor.Product.$fTraversableProduct_$cp2Traversable
                      $dTraversable_sgazV $dTraversable1_sgazW; } in
        let {
          sat_sgazX [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Product.Product f_ag3YG g_ag3YH)
          [LclId] =
              [$dTraversable_sgazV $dTraversable1_sgazW] \u []
                  Data.Functor.Product.$fTraversableProduct_$cp1Traversable
                      $dTraversable_sgazV $dTraversable1_sgazW;
        } in 
          Data.Traversable.C:Traversable [sat_sgazX
                                          sat_sgazY
                                          sat_sgazZ
                                          sat_sgaA0
                                          sat_sgaA1
                                          sat_sgaA2];

Data.Functor.Product.$fApplicativeProduct_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b c.
     (a -> b -> c)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgaA3 w1_sgaA4 w2_sgaA5 w3_sgaA6 w4_sgaA7]
        case w3_sgaA6 of {
          Data.Functor.Product.Pair ww1_sgaA9 [Occ=Once]
                                    ww2_sgaAa [Occ=Once] ->
              case w4_sgaA7 of {
                Data.Functor.Product.Pair ww4_sgaAc [Occ=Once]
                                          ww5_sgaAd [Occ=Once] ->
                    let {
                      sat_sgaAf [Occ=Once] :: g_sg4UK c_sg4UP
                      [LclId] =
                          [w1_sgaA4 w2_sgaA5 ww2_sgaAa ww5_sgaAd] \u []
                              GHC.Base.liftA2 w1_sgaA4 w2_sgaA5 ww2_sgaAa ww5_sgaAd; } in
                    let {
                      sat_sgaAe [Occ=Once] :: f_sg4UJ c_sg4UP
                      [LclId] =
                          [w_sgaA3 w2_sgaA5 ww1_sgaA9 ww4_sgaAc] \u []
                              GHC.Base.liftA2 w_sgaA3 w2_sgaA5 ww1_sgaA9 ww4_sgaAc;
                    } in  Data.Functor.Product.Pair [sat_sgaAe sat_sgaAf];
              };
        };

Data.Functor.Product.$fApplicativeProduct_$c<*>
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Product.Product f g (a -> b)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgaAg $dApplicative1_sgaAh ds_sgaAi ds1_sgaAj]
        case ds_sgaAi of {
          Data.Functor.Product.Pair f1_sgaAl [Occ=Once]
                                    g1_sgaAm [Occ=Once] ->
              case ds1_sgaAj of {
                Data.Functor.Product.Pair x_sgaAo [Occ=Once] y_sgaAp [Occ=Once] ->
                    let {
                      sat_sgaAr [Occ=Once] :: g_ag3Xi b_ag3XJ
                      [LclId] =
                          [$dApplicative1_sgaAh g1_sgaAm y_sgaAp] \u []
                              GHC.Base.<*> $dApplicative1_sgaAh g1_sgaAm y_sgaAp; } in
                    let {
                      sat_sgaAq [Occ=Once] :: f_ag3Xh b_ag3XJ
                      [LclId] =
                          [$dApplicative_sgaAg f1_sgaAl x_sgaAo] \u []
                              GHC.Base.<*> $dApplicative_sgaAg f1_sgaAl x_sgaAo;
                    } in  Data.Functor.Product.Pair [sat_sgaAq sat_sgaAr];
              };
        };

Data.Functor.Product.$fApplicativeProduct_$cpure
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a. a -> Data.Functor.Product.Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U),A,A,A,A)><L,1*U(A,1*C1(U),A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgaAs $dApplicative1_sgaAt x_sgaAu]
        let {
          sat_sgaAw [Occ=Once] :: g_ag3Xi a_ag3Xs
          [LclId] =
              [$dApplicative1_sgaAt x_sgaAu] \u []
                  GHC.Base.pure $dApplicative1_sgaAt x_sgaAu; } in
        let {
          sat_sgaAv [Occ=Once] :: f_ag3Xh a_ag3Xs
          [LclId] =
              [$dApplicative_sgaAs x_sgaAu] \u []
                  GHC.Base.pure $dApplicative_sgaAs x_sgaAu;
        } in  Data.Functor.Product.Pair [sat_sgaAv sat_sgaAw];

Data.Functor.Product.$fApplicativeProduct_$cp1Applicative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Functor (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgaAx $dApplicative1_sgaAy]
        let {
          sat_sgaAA [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor g_ag3Xi
          [LclId] =
              [$dApplicative1_sgaAy] \u []
                  GHC.Base.$p1Applicative $dApplicative1_sgaAy; } in
        let {
          sat_sgaAz [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_ag3Xh
          [LclId] =
              [$dApplicative_sgaAx] \u []
                  GHC.Base.$p1Applicative $dApplicative_sgaAx;
        } in  Data.Functor.Product.$fFunctorProduct sat_sgaAz sat_sgaAA;

Data.Functor.Product.$fApplicativeProduct1
  :: forall a b. a -> b -> b
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgaAB eta_B1] GHC.Base.breakpoint eta_B1;

Data.Functor.Product.$w$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b. f a -> g a -> f b -> g b -> (# f b, g b #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaAC w1_sgaAD ww_sgaAE ww1_sgaAF ww2_sgaAG ww3_sgaAH]
        let {
          sat_sgaAN [Occ=Once] :: g_sg4V8 b_sg4Vc
          [LclId] =
              [w1_sgaAD ww1_sgaAF ww3_sgaAH] \u []
                  let {
                    sat_sgaAM [Occ=Once] :: g_sg4V8 (b_sg4Vc -> b_sg4Vc)
                    [LclId] =
                        [w1_sgaAD ww1_sgaAF] \u []
                            case GHC.Base.$p1Applicative w1_sgaAD of sat_sgaAL {
                              __DEFAULT ->
                                  GHC.Base.fmap
                                      sat_sgaAL
                                      Data.Functor.Product.$fApplicativeProduct1
                                      ww1_sgaAF;
                            };
                  } in  GHC.Base.<*> w1_sgaAD sat_sgaAM ww3_sgaAH; } in
        let {
          sat_sgaAK [Occ=Once] :: f_sg4V7 b_sg4Vc
          [LclId] =
              [w_sgaAC ww_sgaAE ww2_sgaAG] \u []
                  let {
                    sat_sgaAJ [Occ=Once] :: f_sg4V7 (b_sg4Vc -> b_sg4Vc)
                    [LclId] =
                        [w_sgaAC ww_sgaAE] \u []
                            case GHC.Base.$p1Applicative w_sgaAC of sat_sgaAI {
                              __DEFAULT ->
                                  GHC.Base.fmap
                                      sat_sgaAI Data.Functor.Product.$fApplicativeProduct1 ww_sgaAE;
                            };
                  } in  GHC.Base.<*> w_sgaAC sat_sgaAJ ww2_sgaAG;
        } in  (#,#) [sat_sgaAK sat_sgaAN];

Data.Functor.Product.$fApplicativeProduct_$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgaAO w1_sgaAP w2_sgaAQ w3_sgaAR]
        case w2_sgaAQ of {
          Data.Functor.Product.Pair ww1_sgaAT [Occ=Once]
                                    ww2_sgaAU [Occ=Once] ->
              case w3_sgaAR of {
                Data.Functor.Product.Pair ww4_sgaAW [Occ=Once]
                                          ww5_sgaAX [Occ=Once] ->
                    case
                        Data.Functor.Product.$w$c*>
                            w_sgaAO w1_sgaAP ww1_sgaAT ww2_sgaAU ww4_sgaAW ww5_sgaAX
                    of
                    { (#,#) ww7_sgaAZ [Occ=Once] ww8_sgaB0 [Occ=Once] ->
                          Data.Functor.Product.Pair [ww7_sgaAZ ww8_sgaB0];
                    };
              };
        };

Data.Functor.Product.$fApplicativeProduct_$c<*
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgaB1 $dApplicative1_sgaB2 w_sgaB3 w1_sgaB4]
        case w_sgaB3 of {
          Data.Functor.Product.Pair ww1_sgaB6 [Occ=Once]
                                    ww2_sgaB7 [Occ=Once] ->
              case w1_sgaB4 of {
                Data.Functor.Product.Pair ww4_sgaB9 [Occ=Once]
                                          ww5_sgaBa [Occ=Once] ->
                    let {
                      sat_sgaBc [Occ=Once] :: g_ag3Xi a_ag3Yx
                      [LclId] =
                          [$dApplicative1_sgaB2 ww2_sgaB7 ww5_sgaBa] \u []
                              GHC.Base.liftA2
                                  $dApplicative1_sgaB2 GHC.Base.const ww2_sgaB7 ww5_sgaBa; } in
                    let {
                      sat_sgaBb [Occ=Once] :: f_ag3Xh a_ag3Yx
                      [LclId] =
                          [$dApplicative_sgaB1 ww1_sgaB6 ww4_sgaB9] \u []
                              GHC.Base.liftA2
                                  $dApplicative_sgaB1 GHC.Base.const ww1_sgaB6 ww4_sgaB9;
                    } in  Data.Functor.Product.Pair [sat_sgaBb sat_sgaBc];
              };
        };

Data.Functor.Product.$fApplicativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Applicative (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)><L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>m] =
    [] \r [$dApplicative_sgaBd $dApplicative1_sgaBe]
        let {
          sat_sgaBk [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
          [LclId] =
              [$dApplicative_sgaBd $dApplicative1_sgaBe] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$c<*
                      $dApplicative_sgaBd $dApplicative1_sgaBe eta_B2 eta_B1; } in
        let {
          sat_sgaBj [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
          [LclId] =
              [$dApplicative_sgaBd $dApplicative1_sgaBe] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$c*>
                      $dApplicative_sgaBd $dApplicative1_sgaBe eta_B2 eta_B1; } in
        let {
          sat_sgaBi [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi c
          [LclId] =
              [$dApplicative_sgaBd $dApplicative1_sgaBe] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$cliftA2
                      $dApplicative_sgaBd $dApplicative1_sgaBe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgaBh [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Xh g_ag3Xi (a -> b)
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
          [LclId] =
              [$dApplicative_sgaBd $dApplicative1_sgaBe] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$c<*>
                      $dApplicative_sgaBd $dApplicative1_sgaBe eta_B2 eta_B1; } in
        let {
          sat_sgaBg [Occ=Once]
            :: forall a. a -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
          [LclId] =
              [$dApplicative_sgaBd $dApplicative1_sgaBe] \r [eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$cpure
                      $dApplicative_sgaBd $dApplicative1_sgaBe eta_B1; } in
        let {
          sat_sgaBf [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Product.Product f_ag3Xh g_ag3Xi)
          [LclId] =
              [$dApplicative_sgaBd $dApplicative1_sgaBe] \u []
                  Data.Functor.Product.$fApplicativeProduct_$cp1Applicative
                      $dApplicative_sgaBd $dApplicative1_sgaBe;
        } in 
          GHC.Base.C:Applicative [sat_sgaBf
                                  sat_sgaBg
                                  sat_sgaBh
                                  sat_sgaBi
                                  sat_sgaBj
                                  sat_sgaBk];

Data.Functor.Product.$fAlternativeProduct_$c<|>
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     forall a.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A)><L,1*U(A,A,1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgaBl $dAlternative1_sgaBm ds_sgaBn ds1_sgaBo]
        case ds_sgaBn of {
          Data.Functor.Product.Pair x1_sgaBq [Occ=Once]
                                    y1_sgaBr [Occ=Once] ->
              case ds1_sgaBo of {
                Data.Functor.Product.Pair x2_sgaBt [Occ=Once]
                                          y2_sgaBu [Occ=Once] ->
                    let {
                      sat_sgaBw [Occ=Once] :: g_ag3Wm a_ag3WM
                      [LclId] =
                          [$dAlternative1_sgaBm y1_sgaBr y2_sgaBu] \u []
                              GHC.Base.<|> $dAlternative1_sgaBm y1_sgaBr y2_sgaBu; } in
                    let {
                      sat_sgaBv [Occ=Once] :: f_ag3Wl a_ag3WM
                      [LclId] =
                          [$dAlternative_sgaBl x1_sgaBq x2_sgaBt] \u []
                              GHC.Base.<|> $dAlternative_sgaBl x1_sgaBq x2_sgaBt;
                    } in  Data.Functor.Product.Pair [sat_sgaBv sat_sgaBw];
              };
        };

Data.Functor.Product.$fAlternativeProduct_$cempty
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     forall a. Data.Functor.Product.Product f g a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A,A)><L,1*U(A,1*U,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgaBx $dAlternative1_sgaBy]
        let {
          sat_sgaBA [Occ=Once] :: g_ag3Wm a_ag3Ww
          [LclId] =
              [$dAlternative1_sgaBy] \u []
                  GHC.Base.empty $dAlternative1_sgaBy; } in
        let {
          sat_sgaBz [Occ=Once] :: f_ag3Wl a_ag3Ww
          [LclId] =
              [$dAlternative_sgaBx] \u [] GHC.Base.empty $dAlternative_sgaBx;
        } in  Data.Functor.Product.Pair [sat_sgaBz sat_sgaBA];

Data.Functor.Product.$fAlternativeProduct_$cp1Alternative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     GHC.Base.Applicative (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)><L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgaBB $dAlternative1_sgaBC]
        let {
          sat_sgaBE [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative g_ag3Wm
          [LclId] =
              [$dAlternative1_sgaBC] \u []
                  GHC.Base.$p1Alternative $dAlternative1_sgaBC; } in
        let {
          sat_sgaBD [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative f_ag3Wl
          [LclId] =
              [$dAlternative_sgaBB] \u []
                  GHC.Base.$p1Alternative $dAlternative_sgaBB;
        } in 
          Data.Functor.Product.$fApplicativeProduct sat_sgaBD sat_sgaBE;

poly_some_v_rg5o0
  :: forall (f :: * -> *) (g :: * -> *) a.
     Data.Functor.Product.Product f g [a]
[GblId, Str=b] =
    [] \u [] poly_some_v_rg5o0;

Data.Functor.Product.$fAlternativeProduct_$csome [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     forall a.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g [a]
[GblId, Arity=3, Str=<B,A><B,A><B,1*H>b, Unf=OtherCon []] =
    [] \r [w_sgaBF w1_sgaBG w2_sgaBH]
        case w2_sgaBH of {
          Data.Functor.Product.Pair _ [Occ=Dead] _ [Occ=Dead] ->
              poly_some_v_rg5o0;
        };

Data.Functor.Product.$fAlternativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     GHC.Base.Alternative (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)><L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>m] =
    [] \r [$dAlternative_sgaBL $dAlternative1_sgaBM]
        let {
          sat_sgaBR [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm [a]
          [LclId] =
              [$dAlternative_sgaBL $dAlternative1_sgaBM] \r [eta_B1]
                  Data.Functor.Product.$fAlternativeProduct_$csome
                      $dAlternative_sgaBL $dAlternative1_sgaBM eta_B1; } in
        let {
          sat_sgaBQ [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm [a]
          [LclId] =
              [$dAlternative_sgaBL $dAlternative1_sgaBM] \r [eta_B1]
                  Data.Functor.Product.$fAlternativeProduct_$csome
                      $dAlternative_sgaBL $dAlternative1_sgaBM eta_B1; } in
        let {
          sat_sgaBP [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
          [LclId] =
              [$dAlternative_sgaBL $dAlternative1_sgaBM] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fAlternativeProduct_$c<|>
                      $dAlternative_sgaBL $dAlternative1_sgaBM eta_B2 eta_B1; } in
        let {
          sat_sgaBO [Occ=Once]
            :: forall a. Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
          [LclId] =
              [$dAlternative_sgaBL $dAlternative1_sgaBM] \u []
                  Data.Functor.Product.$fAlternativeProduct_$cempty
                      $dAlternative_sgaBL $dAlternative1_sgaBM; } in
        let {
          sat_sgaBN [Occ=Once]
            :: GHC.Base.Applicative
                 (Data.Functor.Product.Product f_ag3Wl g_ag3Wm)
          [LclId] =
              [$dAlternative_sgaBL $dAlternative1_sgaBM] \u []
                  Data.Functor.Product.$fAlternativeProduct_$cp1Alternative
                      $dAlternative_sgaBL $dAlternative1_sgaBM;
        } in 
          GHC.Base.C:Alternative [sat_sgaBN
                                  sat_sgaBO
                                  sat_sgaBP
                                  sat_sgaBQ
                                  sat_sgaBR];

Data.Functor.Product.$fMonadProduct_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> (a -> Data.Functor.Product.Product f g b)
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><L,C(U(1*U,1*U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgaBS w1_sgaBT w2_sgaBU w3_sgaBV]
        case w2_sgaBU of {
          Data.Functor.Product.Pair ww1_sgaBX [Occ=Once]
                                    ww2_sgaBY [Occ=Once] ->
              let {
                sat_sgaCa [Occ=Once] :: g_sg4VS b_sg4VW
                [LclId] =
                    [w1_sgaBT w3_sgaBV ww2_sgaBY] \u []
                        let {
                          sat_sgaC9 [Occ=Once] :: a_sg4VV -> g_sg4VS b_sg4VW
                          [LclId] =
                              [w3_sgaBV] \r [x_sgaC5]
                                  case w3_sgaBV x_sgaC5 of {
                                    Data.Functor.Product.Pair _ [Occ=Dead] b1_sgaC8 [Occ=Once] ->
                                        b1_sgaC8;
                                  };
                        } in  GHC.Base.>>= w1_sgaBT ww2_sgaBY sat_sgaC9; } in
              let {
                sat_sgaC4 [Occ=Once] :: f_sg4VR b_sg4VW
                [LclId] =
                    [w_sgaBS w3_sgaBV ww1_sgaBX] \u []
                        let {
                          sat_sgaC3 [Occ=Once] :: a_sg4VV -> f_sg4VR b_sg4VW
                          [LclId] =
                              [w3_sgaBV] \r [x_sgaBZ]
                                  case w3_sgaBV x_sgaBZ of {
                                    Data.Functor.Product.Pair a1_sgaC1 [Occ=Once] _ [Occ=Dead] ->
                                        a1_sgaC1;
                                  };
                        } in  GHC.Base.>>= w_sgaBS ww1_sgaBX sat_sgaC3;
              } in  Data.Functor.Product.Pair [sat_sgaC4 sat_sgaCa];
        };

Data.Functor.Product.$fMonadProduct_$cp1Monad
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     GHC.Base.Applicative (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)><L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgaCb $dMonad1_sgaCc]
        let {
          sat_sgaCe [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative g_ag3Uv
          [LclId] =
              [$dMonad1_sgaCc] \u [] GHC.Base.$p1Monad $dMonad1_sgaCc; } in
        let {
          sat_sgaCd [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative f_ag3Uu
          [LclId] =
              [$dMonad_sgaCb] \u [] GHC.Base.$p1Monad $dMonad_sgaCb;
        } in 
          Data.Functor.Product.$fApplicativeProduct sat_sgaCd sat_sgaCe;

Data.Functor.Product.$fMonadProduct_$creturn [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     forall a. a -> Data.Functor.Product.Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgaCf w1_sgaCg w2_sgaCh]
        let {
          sat_sgaCl [Occ=Once] :: g_sg4W9 a_sg4Wc
          [LclId] =
              [w1_sgaCg w2_sgaCh] \u []
                  case GHC.Base.$p1Monad w1_sgaCg of sat_sgaCk {
                    __DEFAULT -> GHC.Base.pure sat_sgaCk w2_sgaCh;
                  }; } in
        let {
          sat_sgaCj [Occ=Once] :: f_sg4W8 a_sg4Wc
          [LclId] =
              [w_sgaCf w2_sgaCh] \u []
                  case GHC.Base.$p1Monad w_sgaCf of sat_sgaCi {
                    __DEFAULT -> GHC.Base.pure sat_sgaCi w2_sgaCh;
                  };
        } in  Data.Functor.Product.Pair [sat_sgaCj sat_sgaCl];

Data.Functor.Product.$fMonadProduct_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgaCm $dMonad1_sgaCn eta_sgaCo eta1_sgaCp]
        case eta_sgaCo of {
          Data.Functor.Product.Pair m_sgaCr [Occ=Once] n_sgaCs [Occ=Once] ->
              let {
                sat_sgaCE [Occ=Once] :: g_ag3Uv b_ag3VX
                [LclId] =
                    [$dMonad1_sgaCn eta1_sgaCp n_sgaCs] \u []
                        let {
                          sat_sgaCD [Occ=Once] :: a_ag3VW -> g_ag3Uv b_ag3VX
                          [LclId] =
                              [eta1_sgaCp] \r [x_sgaCz]
                                  case eta1_sgaCp of {
                                    Data.Functor.Product.Pair _ [Occ=Dead] b1_sgaCC [Occ=Once] ->
                                        b1_sgaCC;
                                  };
                        } in  GHC.Base.>>= $dMonad1_sgaCn n_sgaCs sat_sgaCD; } in
              let {
                sat_sgaCy [Occ=Once] :: f_ag3Uu b_ag3VX
                [LclId] =
                    [$dMonad_sgaCm eta1_sgaCp m_sgaCr] \u []
                        let {
                          sat_sgaCx [Occ=Once] :: a_ag3VW -> f_ag3Uu b_ag3VX
                          [LclId] =
                              [eta1_sgaCp] \r [x_sgaCt]
                                  case eta1_sgaCp of {
                                    Data.Functor.Product.Pair a1_sgaCv [Occ=Once] _ [Occ=Dead] ->
                                        a1_sgaCv;
                                  };
                        } in  GHC.Base.>>= $dMonad_sgaCm m_sgaCr sat_sgaCx;
              } in  Data.Functor.Product.Pair [sat_sgaCy sat_sgaCE];
        };

lvl4_rg5o1
  :: forall (f :: * -> *) (g :: * -> *) a.
     [GHC.Types.Char] -> Data.Functor.Product.Product f g a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sgaCF] GHC.Err.errorWithoutStackTrace eta_sgaCF;

Data.Functor.Product.$fMonadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)><L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>m] =
    [] \r [$dMonad_sgaCG $dMonad1_sgaCH]
        let {
          sat_sgaCL [Occ=Once]
            :: forall a. a -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv a
          [LclId] =
              [$dMonad_sgaCG $dMonad1_sgaCH] \r [eta_B1]
                  Data.Functor.Product.$fMonadProduct_$creturn
                      $dMonad_sgaCG $dMonad1_sgaCH eta_B1; } in
        let {
          sat_sgaCK [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Uu g_ag3Uv a
               -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b
               -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b
          [LclId] =
              [$dMonad_sgaCG $dMonad1_sgaCH] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadProduct_$c>>
                      $dMonad_sgaCG $dMonad1_sgaCH eta_B2 eta_B1; } in
        let {
          sat_sgaCJ [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Uu g_ag3Uv a
               -> (a -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b)
               -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b
          [LclId] =
              [$dMonad_sgaCG $dMonad1_sgaCH] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadProduct_$c>>=
                      $dMonad_sgaCG $dMonad1_sgaCH eta_B2 eta_B1; } in
        let {
          sat_sgaCI [Occ=Once]
            :: GHC.Base.Applicative
                 (Data.Functor.Product.Product f_ag3Uu g_ag3Uv)
          [LclId] =
              [$dMonad_sgaCG $dMonad1_sgaCH] \u []
                  Data.Functor.Product.$fMonadProduct_$cp1Monad
                      $dMonad_sgaCG $dMonad1_sgaCH;
        } in 
          GHC.Base.C:Monad [sat_sgaCI
                            sat_sgaCJ
                            sat_sgaCK
                            sat_sgaCL
                            lvl4_rg5o1];

Data.Functor.Product.$fMonadPlusProduct_$cmplus
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     forall a.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(U)))><L,1*U(A,A,A,1*C1(C1(U)))><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sgaCM $dMonadPlus1_sgaCN ds_sgaCO ds1_sgaCP]
        case ds_sgaCO of {
          Data.Functor.Product.Pair x1_sgaCR [Occ=Once]
                                    y1_sgaCS [Occ=Once] ->
              case ds1_sgaCP of {
                Data.Functor.Product.Pair x2_sgaCU [Occ=Once]
                                          y2_sgaCV [Occ=Once] ->
                    let {
                      sat_sgaCX [Occ=Once] :: g_ag3TL a_ag3Uf
                      [LclId] =
                          [$dMonadPlus1_sgaCN y1_sgaCS y2_sgaCV] \u []
                              GHC.Base.mplus $dMonadPlus1_sgaCN y1_sgaCS y2_sgaCV; } in
                    let {
                      sat_sgaCW [Occ=Once] :: f_ag3TK a_ag3Uf
                      [LclId] =
                          [$dMonadPlus_sgaCM x1_sgaCR x2_sgaCU] \u []
                              GHC.Base.mplus $dMonadPlus_sgaCM x1_sgaCR x2_sgaCU;
                    } in  Data.Functor.Product.Pair [sat_sgaCW sat_sgaCX];
              };
        };

Data.Functor.Product.$fMonadPlusProduct_$cmzero
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     forall a. Data.Functor.Product.Product f g a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*U,A)><L,1*U(A,A,1*U,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sgaCY $dMonadPlus1_sgaCZ]
        let {
          sat_sgaD1 [Occ=Once] :: g_ag3TL a_ag3TZ
          [LclId] =
              [$dMonadPlus1_sgaCZ] \u [] GHC.Base.mzero $dMonadPlus1_sgaCZ; } in
        let {
          sat_sgaD0 [Occ=Once] :: f_ag3TK a_ag3TZ
          [LclId] =
              [$dMonadPlus_sgaCY] \u [] GHC.Base.mzero $dMonadPlus_sgaCY;
        } in  Data.Functor.Product.Pair [sat_sgaD0 sat_sgaD1];

Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A)><L,1*U(A,1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sgaD2 $dMonadPlus1_sgaD3]
        let {
          sat_sgaD5 [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_ag3TL
          [LclId] =
              [$dMonadPlus1_sgaD3] \u []
                  GHC.Base.$p2MonadPlus $dMonadPlus1_sgaD3; } in
        let {
          sat_sgaD4 [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_ag3TK
          [LclId] =
              [$dMonadPlus_sgaD2] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_sgaD2;
        } in  Data.Functor.Product.$fMonadProduct sat_sgaD4 sat_sgaD5;

Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     GHC.Base.Alternative (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sgaD6 $dMonadPlus1_sgaD7]
        let {
          sat_sgaD9 [Occ=Once,
                     Dmd=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>]
            :: GHC.Base.Alternative g_ag3TL
          [LclId] =
              [$dMonadPlus1_sgaD7] \u []
                  GHC.Base.$p1MonadPlus $dMonadPlus1_sgaD7; } in
        let {
          sat_sgaD8 [Occ=Once,
                     Dmd=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>]
            :: GHC.Base.Alternative f_ag3TK
          [LclId] =
              [$dMonadPlus_sgaD6] \u [] GHC.Base.$p1MonadPlus $dMonadPlus_sgaD6;
        } in 
          Data.Functor.Product.$fAlternativeProduct sat_sgaD8 sat_sgaD9;

Data.Functor.Product.$fMonadPlusProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     GHC.Base.MonadPlus (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),1*U,C(C1(U)))><L,U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),1*U,C(C1(U)))>m] =
    [] \r [$dMonadPlus_sgaDa $dMonadPlus1_sgaDb]
        let {
          sat_sgaDf [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3TK g_ag3TL a
               -> Data.Functor.Product.Product f_ag3TK g_ag3TL a
               -> Data.Functor.Product.Product f_ag3TK g_ag3TL a
          [LclId] =
              [$dMonadPlus_sgaDa $dMonadPlus1_sgaDb] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadPlusProduct_$cmplus
                      $dMonadPlus_sgaDa $dMonadPlus1_sgaDb eta_B2 eta_B1; } in
        let {
          sat_sgaDe [Occ=Once]
            :: forall a. Data.Functor.Product.Product f_ag3TK g_ag3TL a
          [LclId] =
              [$dMonadPlus_sgaDa $dMonadPlus1_sgaDb] \u []
                  Data.Functor.Product.$fMonadPlusProduct_$cmzero
                      $dMonadPlus_sgaDa $dMonadPlus1_sgaDb; } in
        let {
          sat_sgaDd [Occ=Once]
            :: GHC.Base.Monad (Data.Functor.Product.Product f_ag3TK g_ag3TL)
          [LclId] =
              [$dMonadPlus_sgaDa $dMonadPlus1_sgaDb] \u []
                  Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus
                      $dMonadPlus_sgaDa $dMonadPlus1_sgaDb; } in
        let {
          sat_sgaDc [Occ=Once]
            :: GHC.Base.Alternative
                 (Data.Functor.Product.Product f_ag3TK g_ag3TL)
          [LclId] =
              [$dMonadPlus_sgaDa $dMonadPlus1_sgaDb] \u []
                  Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus
                      $dMonadPlus_sgaDa $dMonadPlus1_sgaDb;
        } in 
          GHC.Base.C:MonadPlus [sat_sgaDc sat_sgaDd sat_sgaDe sat_sgaDf];

Data.Functor.Product.$fMonadFixProduct_$cmfix [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) =>
     forall a.
     (a -> Data.Functor.Product.Product f g a)
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U))><L,1*U(A,1*C1(U))><L,C(U(1*U,1*U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgaDg w1_sgaDh w2_sgaDi]
        let {
          sat_sgaDu [Occ=Once] :: g_sg4Wj a_sg4Wm
          [LclId] =
              [w1_sgaDh w2_sgaDi] \u []
                  let {
                    sat_sgaDt [Occ=Once] :: a_sg4Wm -> g_sg4Wj a_sg4Wm
                    [LclId] =
                        [w2_sgaDi] \r [x_sgaDp]
                            case w2_sgaDi x_sgaDp of {
                              Data.Functor.Product.Pair _ [Occ=Dead] b_sgaDs [Occ=Once] ->
                                  b_sgaDs;
                            };
                  } in  Control.Monad.Fix.mfix w1_sgaDh sat_sgaDt; } in
        let {
          sat_sgaDo [Occ=Once] :: f_sg4Wi a_sg4Wm
          [LclId] =
              [w_sgaDg w2_sgaDi] \u []
                  let {
                    sat_sgaDn [Occ=Once] :: a_sg4Wm -> f_sg4Wi a_sg4Wm
                    [LclId] =
                        [w2_sgaDi] \r [x_sgaDj]
                            case w2_sgaDi x_sgaDj of {
                              Data.Functor.Product.Pair a1_sgaDl [Occ=Once] _ [Occ=Dead] ->
                                  a1_sgaDl;
                            };
                  } in  Control.Monad.Fix.mfix w_sgaDg sat_sgaDn;
        } in  Data.Functor.Product.Pair [sat_sgaDo sat_sgaDu];

Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A)><L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadFix_sgaDv $dMonadFix1_sgaDw]
        let {
          sat_sgaDy [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_ag3Sn
          [LclId] =
              [$dMonadFix1_sgaDw] \u []
                  Control.Monad.Fix.$p1MonadFix $dMonadFix1_sgaDw; } in
        let {
          sat_sgaDx [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_ag3Sm
          [LclId] =
              [$dMonadFix_sgaDv] \u []
                  Control.Monad.Fix.$p1MonadFix $dMonadFix_sgaDv;
        } in  Data.Functor.Product.$fMonadProduct sat_sgaDx sat_sgaDy;

Data.Functor.Product.$fMonadFixProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) =>
     Control.Monad.Fix.MonadFix (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),C(U))><L,U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),C(U))>m] =
    [] \r [$dMonadFix_sgaDz $dMonadFix1_sgaDA]
        let {
          sat_sgaDC [Occ=Once]
            :: forall a.
               (a -> Data.Functor.Product.Product f_ag3Sm g_ag3Sn a)
               -> Data.Functor.Product.Product f_ag3Sm g_ag3Sn a
          [LclId] =
              [$dMonadFix_sgaDz $dMonadFix1_sgaDA] \r [eta_B1]
                  Data.Functor.Product.$fMonadFixProduct_$cmfix
                      $dMonadFix_sgaDz $dMonadFix1_sgaDA eta_B1; } in
        let {
          sat_sgaDB [Occ=Once]
            :: GHC.Base.Monad (Data.Functor.Product.Product f_ag3Sm g_ag3Sn)
          [LclId] =
              [$dMonadFix_sgaDz $dMonadFix1_sgaDA] \u []
                  Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix
                      $dMonadFix_sgaDz $dMonadFix1_sgaDA;
        } in  Control.Monad.Fix.C:MonadFix [sat_sgaDB sat_sgaDC];

Data.Functor.Product.$fMonadZipProduct_$cmzipWith [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b c.
     (a -> b -> c)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgaDD w1_sgaDE w2_sgaDF w3_sgaDG w4_sgaDH]
        case w3_sgaDG of {
          Data.Functor.Product.Pair ww1_sgaDJ [Occ=Once]
                                    ww2_sgaDK [Occ=Once] ->
              case w4_sgaDH of {
                Data.Functor.Product.Pair ww4_sgaDM [Occ=Once]
                                          ww5_sgaDN [Occ=Once] ->
                    let {
                      sat_sgaDP [Occ=Once] :: g_sg4Wt c_sg4Wy
                      [LclId] =
                          [w1_sgaDE w2_sgaDF ww2_sgaDK ww5_sgaDN] \u []
                              Control.Monad.Zip.mzipWith
                                  w1_sgaDE w2_sgaDF ww2_sgaDK ww5_sgaDN; } in
                    let {
                      sat_sgaDO [Occ=Once] :: f_sg4Ws c_sg4Wy
                      [LclId] =
                          [w_sgaDD w2_sgaDF ww1_sgaDJ ww4_sgaDM] \u []
                              Control.Monad.Zip.mzipWith w_sgaDD w2_sgaDF ww1_sgaDJ ww4_sgaDM;
                    } in  Data.Functor.Product.Pair [sat_sgaDO sat_sgaDP];
              };
        };

Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sgaDQ $dMonadZip1_sgaDR]
        let {
          sat_sgaDT [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_ag3Rx
          [LclId] =
              [$dMonadZip1_sgaDR] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip1_sgaDR; } in
        let {
          sat_sgaDS [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_ag3Rw
          [LclId] =
              [$dMonadZip_sgaDQ] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sgaDQ;
        } in  Data.Functor.Product.$fMonadProduct sat_sgaDS sat_sgaDT;

Data.Functor.Product.$fMonadZipProduct_$cmzip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sgaDU $dMonadZip1_sgaDV w_sgaDW w1_sgaDX]
        case w_sgaDW of {
          Data.Functor.Product.Pair ww1_sgaDZ [Occ=Once]
                                    ww2_sgaE0 [Occ=Once] ->
              case w1_sgaDX of {
                Data.Functor.Product.Pair ww4_sgaE2 [Occ=Once]
                                          ww5_sgaE3 [Occ=Once] ->
                    let {
                      sat_sgaE5 [Occ=Once] :: g_ag3Rx (a_ag3RH, b_ag3RI)
                      [LclId] =
                          [$dMonadZip1_sgaDV ww2_sgaE0 ww5_sgaE3] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip1_sgaDV GHC.Tuple.(,) ww2_sgaE0 ww5_sgaE3; } in
                    let {
                      sat_sgaE4 [Occ=Once] :: f_ag3Rw (a_ag3RH, b_ag3RI)
                      [LclId] =
                          [$dMonadZip_sgaDU ww1_sgaDZ ww4_sgaE2] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip_sgaDU GHC.Tuple.(,) ww1_sgaDZ ww4_sgaE2;
                    } in  Data.Functor.Product.Pair [sat_sgaE4 sat_sgaE5];
              };
        };

Data.Functor.Product.$w$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     Data.Functor.Product.Product f g (a, b)
     -> (# Data.Functor.Product.Product f g a,
           Data.Functor.Product.Product f g b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaE6 w1_sgaE7 w2_sgaE8]
        let {
          $dMonad_sgaE9 [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_sg4WQ
          [LclId] =
              [w_sgaE6] \u [] Control.Monad.Zip.$p1MonadZip w_sgaE6; } in
        let {
          $dMonad1_sgaEa [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_sg4WR
          [LclId] =
              [w1_sgaE7] \u [] Control.Monad.Zip.$p1MonadZip w1_sgaE7; } in
        let {
          sat_sgaEO [Occ=Once]
            :: Data.Functor.Product.Product f_sg4WQ g_sg4WR b_sg4WV
          [LclId] =
              [w2_sgaE8 $dMonad_sgaE9 $dMonad1_sgaEa] \u []
                  case w2_sgaE8 of {
                    Data.Functor.Product.Pair m_sgaEw [Occ=Once] n_sgaEx [Occ=Once] ->
                        let {
                          sat_sgaEN [Occ=Once] :: g_sg4WR b_sg4WV
                          [LclId] =
                              [$dMonad1_sgaEa n_sgaEx] \u []
                                  let {
                                    lvl9_sgaEG [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative g_sg4WR
                                    [LclId] =
                                        [$dMonad1_sgaEa] \u []
                                            GHC.Base.$p1Monad $dMonad1_sgaEa; } in
                                  let {
                                    sat_sgaEM [Occ=Once] :: (a_sg4WU, b_sg4WV) -> g_sg4WR b_sg4WV
                                    [LclId] =
                                        [lvl9_sgaEG] \r [x_sgaEH]
                                            let {
                                              sat_sgaEL [Occ=Once] :: b_sg4WV
                                              [LclId] =
                                                  [x_sgaEH] \u []
                                                      case x_sgaEH of {
                                                        (,) _ [Occ=Dead] y_sgaEK [Occ=Once] ->
                                                            y_sgaEK;
                                                      };
                                            } in  GHC.Base.pure lvl9_sgaEG sat_sgaEL;
                                  } in  GHC.Base.>>= $dMonad1_sgaEa n_sgaEx sat_sgaEM; } in
                        let {
                          sat_sgaEF [Occ=Once] :: f_sg4WQ b_sg4WV
                          [LclId] =
                              [$dMonad_sgaE9 m_sgaEw] \u []
                                  let {
                                    lvl9_sgaEy [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative f_sg4WQ
                                    [LclId] =
                                        [$dMonad_sgaE9] \u [] GHC.Base.$p1Monad $dMonad_sgaE9; } in
                                  let {
                                    sat_sgaEE [Occ=Once] :: (a_sg4WU, b_sg4WV) -> f_sg4WQ b_sg4WV
                                    [LclId] =
                                        [lvl9_sgaEy] \r [x_sgaEz]
                                            let {
                                              sat_sgaED [Occ=Once] :: b_sg4WV
                                              [LclId] =
                                                  [x_sgaEz] \u []
                                                      case x_sgaEz of {
                                                        (,) _ [Occ=Dead] y_sgaEC [Occ=Once] ->
                                                            y_sgaEC;
                                                      };
                                            } in  GHC.Base.pure lvl9_sgaEy sat_sgaED;
                                  } in  GHC.Base.>>= $dMonad_sgaE9 m_sgaEw sat_sgaEE;
                        } in  Data.Functor.Product.Pair [sat_sgaEF sat_sgaEN];
                  }; } in
        let {
          sat_sgaEu [Occ=Once]
            :: Data.Functor.Product.Product f_sg4WQ g_sg4WR a_sg4WU
          [LclId] =
              [w2_sgaE8 $dMonad_sgaE9 $dMonad1_sgaEa] \u []
                  case w2_sgaE8 of {
                    Data.Functor.Product.Pair m_sgaEc [Occ=Once] n_sgaEd [Occ=Once] ->
                        let {
                          sat_sgaEt [Occ=Once] :: g_sg4WR a_sg4WU
                          [LclId] =
                              [$dMonad1_sgaEa n_sgaEd] \u []
                                  let {
                                    lvl9_sgaEm [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative g_sg4WR
                                    [LclId] =
                                        [$dMonad1_sgaEa] \u []
                                            GHC.Base.$p1Monad $dMonad1_sgaEa; } in
                                  let {
                                    sat_sgaEs [Occ=Once] :: (a_sg4WU, b_sg4WV) -> g_sg4WR a_sg4WU
                                    [LclId] =
                                        [lvl9_sgaEm] \r [x_sgaEn]
                                            let {
                                              sat_sgaEr [Occ=Once] :: a_sg4WU
                                              [LclId] =
                                                  [x_sgaEn] \u []
                                                      case x_sgaEn of {
                                                        (,) x1_sgaEp [Occ=Once] _ [Occ=Dead] ->
                                                            x1_sgaEp;
                                                      };
                                            } in  GHC.Base.pure lvl9_sgaEm sat_sgaEr;
                                  } in  GHC.Base.>>= $dMonad1_sgaEa n_sgaEd sat_sgaEs; } in
                        let {
                          sat_sgaEl [Occ=Once] :: f_sg4WQ a_sg4WU
                          [LclId] =
                              [$dMonad_sgaE9 m_sgaEc] \u []
                                  let {
                                    lvl9_sgaEe [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative f_sg4WQ
                                    [LclId] =
                                        [$dMonad_sgaE9] \u [] GHC.Base.$p1Monad $dMonad_sgaE9; } in
                                  let {
                                    sat_sgaEk [Occ=Once] :: (a_sg4WU, b_sg4WV) -> f_sg4WQ a_sg4WU
                                    [LclId] =
                                        [lvl9_sgaEe] \r [x_sgaEf]
                                            let {
                                              sat_sgaEj [Occ=Once] :: a_sg4WU
                                              [LclId] =
                                                  [x_sgaEf] \u []
                                                      case x_sgaEf of {
                                                        (,) x1_sgaEh [Occ=Once] _ [Occ=Dead] ->
                                                            x1_sgaEh;
                                                      };
                                            } in  GHC.Base.pure lvl9_sgaEe sat_sgaEj;
                                  } in  GHC.Base.>>= $dMonad_sgaE9 m_sgaEc sat_sgaEk;
                        } in  Data.Functor.Product.Pair [sat_sgaEl sat_sgaEt];
                  };
        } in  (#,#) [sat_sgaEu sat_sgaEO];

Data.Functor.Product.$fMonadZipProduct_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     Data.Functor.Product.Product f g (a, b)
     -> (Data.Functor.Product.Product f g a,
         Data.Functor.Product.Product f g b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgaEP w1_sgaEQ w2_sgaER]
        case Data.Functor.Product.$w$cmunzip w_sgaEP w1_sgaEQ w2_sgaER of {
          (#,#) ww1_sgaET [Occ=Once] ww2_sgaEU [Occ=Once] ->
              (,) [ww1_sgaET ww2_sgaEU];
        };

Data.Functor.Product.$fMonadZipProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     Control.Monad.Zip.MonadZip (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)><L,U(U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sgaEV $dMonadZip1_sgaEW]
        let {
          sat_sgaF0 [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Rw g_ag3Rx (a, b)
               -> (Data.Functor.Product.Product f_ag3Rw g_ag3Rx a,
                   Data.Functor.Product.Product f_ag3Rw g_ag3Rx b)
          [LclId] =
              [$dMonadZip_sgaEV $dMonadZip1_sgaEW] \r [eta_B1]
                  Data.Functor.Product.$fMonadZipProduct_$cmunzip
                      $dMonadZip_sgaEV $dMonadZip1_sgaEW eta_B1; } in
        let {
          sat_sgaEZ [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx a
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx b
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx c
          [LclId] =
              [$dMonadZip_sgaEV $dMonadZip1_sgaEW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadZipProduct_$cmzipWith
                      $dMonadZip_sgaEV $dMonadZip1_sgaEW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgaEY [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Rw g_ag3Rx a
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx b
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx (a, b)
          [LclId] =
              [$dMonadZip_sgaEV $dMonadZip1_sgaEW] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadZipProduct_$cmzip
                      $dMonadZip_sgaEV $dMonadZip1_sgaEW eta_B2 eta_B1; } in
        let {
          sat_sgaEX [Occ=Once]
            :: GHC.Base.Monad (Data.Functor.Product.Product f_ag3Rw g_ag3Rx)
          [LclId] =
              [$dMonadZip_sgaEV $dMonadZip1_sgaEW] \u []
                  Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip
                      $dMonadZip_sgaEV $dMonadZip1_sgaEW;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sgaEX
                                        sat_sgaEY
                                        sat_sgaEZ
                                        sat_sgaF0];

Data.Functor.Product.$fGeneric1Product_$cto1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Data.Functor.Product.Product f g) a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgaF1]
        case ds_sgaF1 of {
          GHC.Generics.:*: ds1_sgaF3 [Occ=Once] ds2_sgaF4 [Occ=Once] ->
              Data.Functor.Product.Pair [ds1_sgaF3 ds2_sgaF4];
        };

Data.Functor.Product.$fGeneric1Product1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Product.Product f g a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Pair" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.Rec1 f)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.Rec1 g))
          a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_sgaF5]
        case x_sgaF5 of {
          Data.Functor.Product.Pair g1_sgaF7 [Occ=Once]
                                    g2_sgaF8 [Occ=Once] ->
              GHC.Generics.:*: [g1_sgaF7 g2_sgaF8];
        };

Data.Functor.Product.$fGeneric1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *).
     GHC.Generics.Generic1 (Data.Functor.Product.Product f g)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Functor.Product.$fGeneric1Product1
                                            Data.Functor.Product.$fGeneric1Product_$cto1];

Data.Functor.Product.$fGenericProduct_$cto
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Data.Functor.Product.Product f g a) x
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgaF9]
        case ds_sgaF9 of {
          GHC.Generics.:*: ds1_sgaFb [Occ=Once] ds2_sgaFc [Occ=Once] ->
              Data.Functor.Product.Pair [ds1_sgaFb ds2_sgaFc];
        };

Data.Functor.Product.$fGenericProduct1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     Data.Functor.Product.Product f g a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Pair" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R (f a))
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.K1 GHC.Generics.R (g a)))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x1_sgaFd]
        case x1_sgaFd of {
          Data.Functor.Product.Pair g1_sgaFf [Occ=Once]
                                    g2_sgaFg [Occ=Once] ->
              GHC.Generics.:*: [g1_sgaFf g2_sgaFg];
        };

Data.Functor.Product.$fGenericProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Generic (Data.Functor.Product.Product f g a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Product.$fGenericProduct1
                                           Data.Functor.Product.$fGenericProduct_$cto];

Data.Functor.Product.$fDataProduct_$cgfoldl
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g1. g1 -> c g1)
     -> Data.Functor.Product.Product f g a
     -> c (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgaFh
           $dTypeable1_sgaFi
           $dTypeable2_sgaFj
           $dTypeable3_sgaFk
           $dData_sgaFl
           $dData1_sgaFm
           k1_sgaFn
           z_sgaFo
           ds_sgaFp]
        case ds_sgaFp of {
          Data.Functor.Product.Pair a1_sgaFr [Occ=Once]
                                    a2_sgaFs [Occ=Once] ->
              let {
                sat_sgaFu [Occ=Once]
                  :: c_ag3Ll (g_ag3L6 a_ag3L7
                              -> Data.Functor.Product.Product f_ag3L5 g_ag3L6 a_ag3L7)
                [LclId] =
                    [$dData_sgaFl k1_sgaFn z_sgaFo a1_sgaFr] \u []
                        let {
                          sat_sgaFt [Occ=Once]
                            :: c_ag3Ll (f_ag3L5 a_ag3L7
                                        -> g_ag3L6 a_ag3L7
                                        -> Data.Functor.Product.Product f_ag3L5 g_ag3L6 a_ag3L7)
                          [LclId] =
                              [z_sgaFo] \u [] z_sgaFo Data.Functor.Product.Pair;
                        } in  k1_sgaFn $dData_sgaFl sat_sgaFt a1_sgaFr;
              } in  k1_sgaFn $dData1_sgaFm sat_sgaFu a2_sgaFs;
        };

Data.Functor.Product.$fDataProduct6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Product"#;

Data.Functor.Product.$fDataProduct5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Product.$fDataProduct6;

go61_rg5o2
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgaFv _ys_sgaFw]
        case ds2_sgaFv of {
          [] -> GHC.List.badHead;
          : ipv_sgaFy [Occ=Once!] ipv1_sgaFz [Occ=Once] ->
              case _ys_sgaFw of {
                [] -> GHC.List.badHead;
                : ipv2_sgaFB [Occ=Once] ipv3_sgaFC [Occ=Once] ->
                    case ipv_sgaFy of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgaFF [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case
                              GHC.Base.eqString ds4_sgaFF Data.Functor.Product.$fRead1Product2
                          of
                          { GHC.Types.False -> go61_rg5o2 ipv1_sgaFz ipv3_sgaFC;
                            GHC.Types.True -> ipv2_sgaFB;
                          };
                    };
              };
        };

$cPair1_rg5o3 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cPair2_rg5o4];
Data.Functor.Product.$fDataProduct4 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Product.$cPair GHC.Types.[]];
Data.Functor.Product.$fDataProduct3 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Functor.Product.$fDataProduct4];
Data.Functor.Product.$tProduct :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Functor.Product.$fDataProduct5
                                       Data.Functor.Product.$fDataProduct3];
Data.Functor.Product.$cPair [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cPair1_rg5o3
                                     Data.Functor.Product.$fRead1Product2
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Functor.Product.$tProduct];
$cPair2_rg5o4 :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rg5o2 Data.Functor.Product.$fDataProduct4 Data.Data.mkConstr1;

Data.Functor.Product.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Product.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$trModule4];

Data.Functor.Product.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Product"#;

Data.Functor.Product.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$trModule2];

Data.Functor.Product.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Product.$trModule3
                                     Data.Functor.Product.$trModule1];

$krep_rg5o5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_rg5o6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rg5o5 GHC.Types.krep$*];

$krep2_rg5o7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rg5o6 $krep1_rg5o6];

Data.Functor.Product.$fDataProduct8 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rg5o6 $krep2_rg5o7];

$krep3_rg5o8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep4_rg5o9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_rg5oa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [3#];

$krep6_rg5ob :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rg5o9 $krep5_rg5oa];

$krep7_rg5oc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep3_rg5o8 $krep5_rg5oa];

Data.Functor.Product.$fDataProduct9 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$fDataProduct6];

Data.Functor.Product.$tcProduct :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9904636435990105341##
                                    16069493191308336164##
                                    Data.Functor.Product.$trModule
                                    Data.Functor.Product.$fDataProduct9
                                    1#
                                    Data.Functor.Product.$fDataProduct8];

$krep8_rg5od :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep5_rg5oa GHC.Types.[]];

$krep9_rg5oe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rg5o8 $krep8_rg5od];

$krep10_rg5of :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rg5o9 $krep9_rg5oe];

$krep11_rg5og :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rg5o5 $krep10_rg5of];

$krep12_rg5oh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Product.$tcProduct
                                              $krep11_rg5og];

$krep13_rg5oi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_rg5oc $krep12_rg5oh];

Data.Functor.Product.$tc'Pair1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rg5ob $krep13_rg5oi];

Data.Functor.Product.$tc'Pair3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Pair"#;

Data.Functor.Product.$tc'Pair2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$tc'Pair3];

Data.Functor.Product.$tc'Pair :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11374113252541295849##
                                    18011678063065699923##
                                    Data.Functor.Product.$trModule
                                    Data.Functor.Product.$tc'Pair2
                                    4#
                                    Data.Functor.Product.$tc'Pair1];

Data.Functor.Product.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Product.Product f g a)
[GblId, Arity=4, Str=<S,U><S,U><S,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sgaFK w1_sgaFL w2_sgaFM w3_sgaFN]
        let {
          sat_sgaFO [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w3_sgaFN]; } in
        let {
          sat_sgaFP [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sgaFO GHC.Types.[]];
        } in 
          case
              Data.Typeable.Internal.$wmkTrCon
                  9904636435990105341##
                  16069493191308336164##
                  Data.Functor.Product.$trModule
                  Data.Functor.Product.$fDataProduct9
                  1#
                  Data.Functor.Product.$fDataProduct8
                  sat_sgaFP
          of
          { (#,,,,#) ww8_sgaFR [Occ=Once]
                     ww9_sgaFS [Occ=Once]
                     ww10_sgaFT [Occ=Once]
                     ww11_sgaFU [Occ=Once]
                     ww12_sgaFV [Occ=Once] ->
                let {
                  sat_sgaFW [Occ=Once]
                    :: Data.Typeable.Internal.TypeRep Data.Functor.Product.Product
                  [LclId] =
                      CCCS Data.Typeable.Internal.TrTyCon! [ww8_sgaFR
                                                            ww9_sgaFS
                                                            ww10_sgaFT
                                                            ww11_sgaFU
                                                            ww12_sgaFV];
                } in 
                  case
                      Data.Typeable.Internal.mkTrApp sat_sgaFW w1_sgaFL
                  of
                  sat_sgaFX
                  { __DEFAULT ->
                        case
                            Data.Typeable.Internal.mkTrApp sat_sgaFX w2_sgaFM
                        of
                        sat_sgaFY
                        { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sgaFY w_sgaFK;
                        };
                  };
          };

Data.Functor.Product.$fDataProduct7 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Product.Product f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sgaFZ w1_sgaG0 w2_sgaG1 w3_sgaG2 w4_sgaG3 w5_sgaG4]
        Data.Functor.Product.$w$cp1Data w_sgaFZ w1_sgaG0 w2_sgaG1 w3_sgaG2;

Data.Functor.Product.$fDataProduct1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (f a -> g a -> Data.Functor.Product.Product f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Product.Pair GHC.Types.False];

Data.Functor.Product.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaG5 w1_sgaG6 w2_sgaG7 w3_sgaG8 w4_sgaG9]
        let {
          lvl9_sgaGa [Occ=OnceL]
            :: m_sg4Xt (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm)
          [LclId] =
              [w2_sgaG7] \u [] GHC.Base.mzero w2_sgaG7;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sgaG7
          of
          $dMonad_sgaGb [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgaGF [Occ=Once]
                    :: (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm,
                        GHC.Types.Bool)
                       -> m_sg4Xt (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm)
                  [LclId] =
                      [lvl9_sgaGa $dMonad_sgaGb] \r [ds_sgaGA]
                          case ds_sgaGA of {
                            (,) x'_sgaGC [Occ=Once] b_sgaGD [Occ=Once!] ->
                                case b_sgaGD of {
                                  GHC.Types.False -> lvl9_sgaGa;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgaGb x'_sgaGC;
                                };
                          }; } in
                let {
                  sat_sgaGz [Occ=Once]
                    :: m_sg4Xt (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sgaG5 w1_sgaG6 w2_sgaG7 w3_sgaG8 w4_sgaG9 $dMonad_sgaGb] \u []
                          case w4_sgaG9 of {
                            Data.Functor.Product.Pair a1_sgaGd [Occ=Once]
                                                      a2_sgaGe [Occ=Once] ->
                                let {
                                  k1_sgaGf [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_sg4Xt (d -> b)
                                       -> d -> m_sg4Xt (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [w2_sgaG7 w3_sgaG8 $dMonad_sgaGb] \r [$dData1_sgaGg
                                                                                     ds_sgaGh
                                                                                     y_sgaGi]
                                          let {
                                            lvl10_sgaGj [Occ=OnceL] :: m_sg4Xt d_ae2Ws
                                            [LclId] =
                                                [w3_sgaG8 $dData1_sgaGg y_sgaGi] \u []
                                                    w3_sgaG8 $dData1_sgaGg y_sgaGi; } in
                                          let {
                                            sat_sgaGw [Occ=Once]
                                              :: (d_ae2Ws -> b_ae2Wt, GHC.Types.Bool)
                                                 -> m_sg4Xt (b_ae2Wt, GHC.Types.Bool)
                                            [LclId] =
                                                [w2_sgaG7
                                                 $dMonad_sgaGb
                                                 y_sgaGi
                                                 lvl10_sgaGj] \r [ds1_sgaGk]
                                                    case ds1_sgaGk of {
                                                      (,) h_sgaGm b1_sgaGn [Occ=Once] ->
                                                          let {
                                                            sat_sgaGv [Occ=Once]
                                                              :: m_sg4Xt (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgaGb
                                                                 y_sgaGi
                                                                 h_sgaGm
                                                                 b1_sgaGn] \u []
                                                                    let {
                                                                      sat_sgaGt [Occ=Once]
                                                                        :: b_ae2Wt
                                                                      [LclId] =
                                                                          [y_sgaGi h_sgaGm] \u []
                                                                              h_sgaGm y_sgaGi; } in
                                                                    let {
                                                                      sat_sgaGu [Occ=Once]
                                                                        :: (b_ae2Wt, GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sgaGt
                                                                                     b1_sgaGn];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sgaGb
                                                                          sat_sgaGu; } in
                                                          let {
                                                            sat_sgaGs [Occ=Once]
                                                              :: m_sg4Xt (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgaGb
                                                                 lvl10_sgaGj
                                                                 h_sgaGm] \u []
                                                                    let {
                                                                      sat_sgaGr [Occ=Once]
                                                                        :: d_ae2Ws
                                                                           -> m_sg4Xt (b_ae2Wt,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sgaGb
                                                                           h_sgaGm] \r [y'_sgaGo]
                                                                              let {
                                                                                sat_sgaGp [Occ=Once]
                                                                                  :: b_ae2Wt
                                                                                [LclId] =
                                                                                    [h_sgaGm
                                                                                     y'_sgaGo] \u []
                                                                                        h_sgaGm
                                                                                            y'_sgaGo; } in
                                                                              let {
                                                                                sat_sgaGq [Occ=Once]
                                                                                  :: (b_ae2Wt,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sgaGp
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sgaGb
                                                                                    sat_sgaGq;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sgaGb
                                                                          lvl10_sgaGj
                                                                          sat_sgaGr;
                                                          } in 
                                                            GHC.Base.mplus
                                                                w2_sgaG7 sat_sgaGs sat_sgaGv;
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sgaGb ds_sgaGh sat_sgaGw; } in
                                let {
                                  sat_sgaGy [Occ=Once]
                                    :: Data.Data.Mp
                                         m_sg4Xt
                                         (g_sg4Xl a_sg4Xm
                                          -> Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm)
                                  [LclId] =
                                      [w_sgaG5 $dMonad_sgaGb a1_sgaGd k1_sgaGf] \u []
                                          let {
                                            sat_sgaGx [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_sg4Xt
                                                   (f_sg4Xk a_sg4Xm
                                                    -> g_sg4Xl a_sg4Xm
                                                    -> Data.Functor.Product.Product
                                                         f_sg4Xk g_sg4Xl a_sg4Xm)
                                            [LclId] =
                                                [$dMonad_sgaGb] \u []
                                                    GHC.Base.return
                                                        $dMonad_sgaGb
                                                        Data.Functor.Product.$fDataProduct1;
                                          } in  k1_sgaGf w_sgaG5 sat_sgaGx a1_sgaGd;
                                } in  k1_sgaGf w1_sgaG6 sat_sgaGy a2_sgaGe;
                          };
                } in  GHC.Base.>>= $dMonad_sgaGb sat_sgaGz sat_sgaGF;
          };

Data.Functor.Product.$fDataProduct_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaGG
           w1_sgaGH
           w2_sgaGI
           w3_sgaGJ
           w4_sgaGK
           w5_sgaGL
           w6_sgaGM
           w7_sgaGN
           w8_sgaGO]
        Data.Functor.Product.$w$cgmapMp
            w4_sgaGK w5_sgaGL w6_sgaGM w7_sgaGN w8_sgaGO;

Data.Functor.Product.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> f a -> g a -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaGP w1_sgaGQ w2_sgaGR w3_sgaGS ww_sgaGT ww1_sgaGU]
        let {
          k1_sgaGV [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
            :: forall d b.
               Data.Data.Data d =>
               m_sg4XN (d -> b) -> d -> m_sg4XN b
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w2_sgaGR w3_sgaGS] \r [$dData1_sgaGW c_sgaGX x_sgaGY]
                  let {
                    lvl9_sgaGZ [Occ=OnceL] :: m_sg4XN d_ae2Vh
                    [LclId] =
                        [w3_sgaGS $dData1_sgaGW x_sgaGY] \u []
                            w3_sgaGS $dData1_sgaGW x_sgaGY; } in
                  let {
                    sat_sgaH4 [Occ=Once] :: (d_ae2Vh -> b_ae2Vi) -> m_sg4XN b_ae2Vi
                    [LclId] =
                        [w2_sgaGR lvl9_sgaGZ] \r [c'_sgaH0]
                            let {
                              sat_sgaH3 [Occ=Once] :: d_ae2Vh -> m_sg4XN b_ae2Vi
                              [LclId] =
                                  [w2_sgaGR c'_sgaH0] \r [x'_sgaH1]
                                      let {
                                        sat_sgaH2 [Occ=Once] :: b_ae2Vi
                                        [LclId] =
                                            [c'_sgaH0 x'_sgaH1] \u [] c'_sgaH0 x'_sgaH1;
                                      } in  GHC.Base.return w2_sgaGR sat_sgaH2;
                            } in  GHC.Base.>>= w2_sgaGR lvl9_sgaGZ sat_sgaH3;
                  } in  GHC.Base.>>= w2_sgaGR c_sgaGX sat_sgaH4; } in
        let {
          sat_sgaH6 [Occ=Once]
            :: m_sg4XN (g_sg4XF a_sg4XG
                        -> Data.Functor.Product.Product f_sg4XE g_sg4XF a_sg4XG)
          [LclId] =
              [w_sgaGP w2_sgaGR ww_sgaGT k1_sgaGV] \u []
                  let {
                    sat_sgaH5 [Occ=Once]
                      :: m_sg4XN (f_sg4XE a_sg4XG
                                  -> g_sg4XF a_sg4XG
                                  -> Data.Functor.Product.Product f_sg4XE g_sg4XF a_sg4XG)
                    [LclId] =
                        [w2_sgaGR] \u []
                            GHC.Base.return w2_sgaGR Data.Functor.Product.Pair;
                  } in  k1_sgaGV w_sgaGP sat_sgaH5 ww_sgaGT;
        } in  k1_sgaGV w1_sgaGQ sat_sgaH6 ww1_sgaGU;

Data.Functor.Product.$fDataProduct_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaH7
           w1_sgaH8
           w2_sgaH9
           w3_sgaHa
           w4_sgaHb
           w5_sgaHc
           w6_sgaHd
           w7_sgaHe
           w8_sgaHf]
        case w8_sgaHf of {
          Data.Functor.Product.Pair ww1_sgaHh [Occ=Once]
                                    ww2_sgaHi [Occ=Once] ->
              Data.Functor.Product.$w$cgmapM
                  w4_sgaHb w5_sgaHc w6_sgaHd w7_sgaHe ww1_sgaHh ww2_sgaHi;
        };

Data.Functor.Product.$fDataProduct_$cgmapQi
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Functor.Product.Product f g a
     -> u
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgaHj
           $dTypeable1_sgaHk
           $dTypeable2_sgaHl
           $dTypeable3_sgaHm
           $dData_sgaHn
           $dData1_sgaHo
           ds_sgaHp
           ds1_sgaHq
           x_sgaHr]
        case x_sgaHr of {
          Data.Functor.Product.Pair a1_sgaHt [Occ=Once]
                                    a2_sgaHu [Occ=Once] ->
              case ds_sgaHp of {
                GHC.Types.I# x1_sgaHw [Occ=Once!] ->
                    case x1_sgaHw of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sgaHq $dData_sgaHn a1_sgaHt;
                      1# -> ds1_sgaHq $dData1_sgaHo a2_sgaHu;
                    };
              };
        };

Data.Functor.Product.$fDataProduct_$cgmapQr
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Product.Product f g a
     -> r
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgaHy
           $dTypeable1_sgaHz
           $dTypeable2_sgaHA
           $dTypeable3_sgaHB
           $dData_sgaHC
           $dData1_sgaHD
           ds_sgaHE
           ds1_sgaHF
           ds2_sgaHG
           x0_sgaHH]
        case x0_sgaHH of {
          Data.Functor.Product.Pair a1_sgaHJ [Occ=Once]
                                    a2_sgaHK [Occ=Once] ->
              let {
                sat_sgaHN [Occ=Once] :: r_ag3N9
                [LclId] =
                    [$dData1_sgaHD ds_sgaHE ds1_sgaHF ds2_sgaHG a2_sgaHK] \u []
                        let {
                          sat_sgaHM [Occ=Once] :: r'_ag3Na
                          [LclId] =
                              [$dData1_sgaHD ds2_sgaHG a2_sgaHK] \u []
                                  ds2_sgaHG $dData1_sgaHD a2_sgaHK;
                        } in  ds_sgaHE sat_sgaHM ds1_sgaHF; } in
              let {
                sat_sgaHL [Occ=Once] :: r'_ag3Na
                [LclId] =
                    [$dData_sgaHC ds2_sgaHG a1_sgaHJ] \u []
                        ds2_sgaHG $dData_sgaHC a1_sgaHJ;
              } in  ds_sgaHE sat_sgaHL sat_sgaHN;
        };

Data.Functor.Product.$fDataProduct2
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Const.Const r (Data.Functor.Product.Product f g a)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgaHO
           $dTypeable1_sgaHP
           $dTypeable2_sgaHQ
           $dTypeable3_sgaHR
           $dData_sgaHS
           $dData1_sgaHT
           ds_sgaHU
           ds1_sgaHV
           ds2_sgaHW
           eta_sgaHX]
        case eta_sgaHX of {
          Data.Functor.Product.Pair a1_sgaHZ [Occ=Once]
                                    a2_sgaI0 [Occ=Once] ->
              let {
                sat_sgaI3 [Occ=Once] :: r'_ag3MT
                [LclId] =
                    [$dData1_sgaHT ds2_sgaHW a2_sgaI0] \u []
                        ds2_sgaHW $dData1_sgaHT a2_sgaI0; } in
              let {
                sat_sgaI2 [Occ=Once] :: r_ag3MS
                [LclId] =
                    [$dData_sgaHS ds_sgaHU ds1_sgaHV ds2_sgaHW a1_sgaHZ] \u []
                        let {
                          sat_sgaI1 [Occ=Once] :: r'_ag3MT
                          [LclId] =
                              [$dData_sgaHS ds2_sgaHW a1_sgaHZ] \u []
                                  ds2_sgaHW $dData_sgaHS a1_sgaHZ;
                        } in  ds_sgaHU ds1_sgaHV sat_sgaI1;
              } in  ds_sgaHU sat_sgaI2 sat_sgaI3;
        };

Data.Functor.Product.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaI4 w1_sgaI5 w2_sgaI6 w3_sgaI7 w4_sgaI8]
        let {
          lvl9_sgaI9 [Occ=OnceL]
            :: m_sg4Yc (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
          [LclId] =
              [w2_sgaI6] \u [] GHC.Base.mzero w2_sgaI6;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sgaI6
          of
          $dMonad_sgaIa [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgaIH [Occ=Once]
                    :: (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5,
                        GHC.Types.Bool)
                       -> m_sg4Yc (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
                  [LclId] =
                      [lvl9_sgaI9 $dMonad_sgaIa] \r [ds_sgaIC]
                          case ds_sgaIC of {
                            (,) x'_sgaIE [Occ=Once] b_sgaIF [Occ=Once!] ->
                                case b_sgaIF of {
                                  GHC.Types.False -> lvl9_sgaI9;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgaIa x'_sgaIE;
                                };
                          }; } in
                let {
                  sat_sgaIB [Occ=Once]
                    :: m_sg4Yc (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sgaI4 w1_sgaI5 w2_sgaI6 w3_sgaI7 w4_sgaI8 $dMonad_sgaIa] \u []
                          case w4_sgaI8 of {
                            Data.Functor.Product.Pair a1_sgaIc [Occ=Once]
                                                      a2_sgaId [Occ=Once] ->
                                let {
                                  k1_sgaIe [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_sg4Yc (d -> b)
                                       -> d -> m_sg4Yc (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [w2_sgaI6 w3_sgaI7 $dMonad_sgaIa] \r [$dData1_sgaIf
                                                                                     ds_sgaIg
                                                                                     y_sgaIh]
                                          let {
                                            lvl10_sgaIi [Occ=OnceL] :: m_sg4Yc d_ae2Ya
                                            [LclId] =
                                                [w3_sgaI7 $dData1_sgaIf y_sgaIh] \u []
                                                    w3_sgaI7 $dData1_sgaIf y_sgaIh; } in
                                          let {
                                            sat_sgaIy [Occ=Once]
                                              :: (d_ae2Ya -> b_ae2Yb, GHC.Types.Bool)
                                                 -> m_sg4Yc (b_ae2Yb, GHC.Types.Bool)
                                            [LclId] =
                                                [w2_sgaI6
                                                 $dMonad_sgaIa
                                                 y_sgaIh
                                                 lvl10_sgaIi] \r [ds1_sgaIj]
                                                    case ds1_sgaIj of {
                                                      (,) h_sgaIl b1_sgaIm [Occ=Once!] ->
                                                          case b1_sgaIm of {
                                                            GHC.Types.False ->
                                                                let {
                                                                  sat_sgaIv [Occ=Once]
                                                                    :: m_sg4Yc (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sgaIa
                                                                       y_sgaIh
                                                                       h_sgaIl] \u []
                                                                          let {
                                                                            sat_sgaIt [Occ=Once]
                                                                              :: b_ae2Yb
                                                                            [LclId] =
                                                                                [y_sgaIh
                                                                                 h_sgaIl] \u []
                                                                                    h_sgaIl
                                                                                        y_sgaIh; } in
                                                                          let {
                                                                            sat_sgaIu [Occ=Once]
                                                                              :: (b_ae2Yb,
                                                                                  GHC.Types.Bool)
                                                                            [LclId] =
                                                                                CCCS (,)! [sat_sgaIt
                                                                                           GHC.Types.False];
                                                                          } in 
                                                                            GHC.Base.return
                                                                                $dMonad_sgaIa
                                                                                sat_sgaIu; } in
                                                                let {
                                                                  sat_sgaIs [Occ=Once]
                                                                    :: m_sg4Yc (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sgaIa
                                                                       lvl10_sgaIi
                                                                       h_sgaIl] \u []
                                                                          let {
                                                                            sat_sgaIr [Occ=Once]
                                                                              :: d_ae2Ya
                                                                                 -> m_sg4Yc (b_ae2Yb,
                                                                                             GHC.Types.Bool)
                                                                            [LclId] =
                                                                                [$dMonad_sgaIa
                                                                                 h_sgaIl] \r [y'_sgaIo]
                                                                                    let {
                                                                                      sat_sgaIp [Occ=Once]
                                                                                        :: b_ae2Yb
                                                                                      [LclId] =
                                                                                          [h_sgaIl
                                                                                           y'_sgaIo] \u []
                                                                                              h_sgaIl
                                                                                                  y'_sgaIo; } in
                                                                                    let {
                                                                                      sat_sgaIq [Occ=Once]
                                                                                        :: (b_ae2Yb,
                                                                                            GHC.Types.Bool)
                                                                                      [LclId] =
                                                                                          CCCS (,)! [sat_sgaIp
                                                                                                     GHC.Types.True];
                                                                                    } in 
                                                                                      GHC.Base.return
                                                                                          $dMonad_sgaIa
                                                                                          sat_sgaIq;
                                                                          } in 
                                                                            GHC.Base.>>=
                                                                                $dMonad_sgaIa
                                                                                lvl10_sgaIi
                                                                                sat_sgaIr;
                                                                } in 
                                                                  GHC.Base.mplus
                                                                      w2_sgaI6 sat_sgaIs sat_sgaIv;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_sgaIw [Occ=Once] :: b_ae2Yb
                                                                  [LclId] =
                                                                      [y_sgaIh h_sgaIl] \u []
                                                                          h_sgaIl y_sgaIh; } in
                                                                let {
                                                                  sat_sgaIx [Occ=Once]
                                                                    :: (b_ae2Yb, GHC.Types.Bool)
                                                                  [LclId] =
                                                                      CCCS (,)! [sat_sgaIw
                                                                                 GHC.Types.True];
                                                                } in 
                                                                  GHC.Base.return
                                                                      $dMonad_sgaIa sat_sgaIx;
                                                          };
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sgaIa ds_sgaIg sat_sgaIy; } in
                                let {
                                  sat_sgaIA [Occ=Once]
                                    :: Data.Data.Mp
                                         m_sg4Yc
                                         (g_sg4Y4 a_sg4Y5
                                          -> Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
                                  [LclId] =
                                      [w_sgaI4 $dMonad_sgaIa a1_sgaIc k1_sgaIe] \u []
                                          let {
                                            sat_sgaIz [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_sg4Yc
                                                   (f_sg4Y3 a_sg4Y5
                                                    -> g_sg4Y4 a_sg4Y5
                                                    -> Data.Functor.Product.Product
                                                         f_sg4Y3 g_sg4Y4 a_sg4Y5)
                                            [LclId] =
                                                [$dMonad_sgaIa] \u []
                                                    GHC.Base.return
                                                        $dMonad_sgaIa
                                                        Data.Functor.Product.$fDataProduct1;
                                          } in  k1_sgaIe w_sgaI4 sat_sgaIz a1_sgaIc;
                                } in  k1_sgaIe w1_sgaI5 sat_sgaIA a2_sgaId;
                          };
                } in  GHC.Base.>>= $dMonad_sgaIa sat_sgaIB sat_sgaIH;
          };

Data.Functor.Product.$fDataProduct_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaII
           w1_sgaIJ
           w2_sgaIK
           w3_sgaIL
           w4_sgaIM
           w5_sgaIN
           w6_sgaIO
           w7_sgaIP
           w8_sgaIQ]
        Data.Functor.Product.$w$cgmapMo
            w4_sgaIM w5_sgaIN w6_sgaIO w7_sgaIP w8_sgaIQ;

lvl5_rg5oj
  :: forall k (g :: k -> *) (a :: k) (f :: k -> *).
     Data.Functor.Product.Product f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_sgaIR]
        case ds_sgaIR of {
          Data.Functor.Product.Pair _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Functor.Product.$cPair;
        };

lvl6_rg5ok
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Product.Product f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgaIV] Data.Functor.Product.$tProduct;

lvl7_rg5ol
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Functor.Product.Product f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgaIW ds_sgaIX] GHC.Base.Nothing [];

lvl8_rg5om
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Functor.Product.Product f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgaIY ds_sgaIZ] GHC.Base.Nothing [];

Data.Functor.Product.$fDataProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Data.Data (Data.Functor.Product.Product f g a)
[GblId[DFunId], Arity=6, Str=<L,U><L,U><L,U><L,U><L,U><L,U>] =
    [] \r [$dTypeable_sgaJ0
           $dTypeable1_sgaJ1
           $dTypeable2_sgaJ2
           $dTypeable3_sgaJ3
           $dData_sgaJ4
           $dData1_sgaJ5]
        let {
          sat_sgaJG [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> m (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dData_sgaJ4 $dData1_sgaJ5] \r [w_sgaJD w1_sgaJE w2_sgaJF]
                  Data.Functor.Product.$w$cgmapMo
                      $dData_sgaJ4 $dData1_sgaJ5 w_sgaJD w1_sgaJE w2_sgaJF; } in
        let {
          sat_sgaJC [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> m (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dData_sgaJ4 $dData1_sgaJ5] \r [w_sgaJz w1_sgaJA w2_sgaJB]
                  Data.Functor.Product.$w$cgmapMp
                      $dData_sgaJ4 $dData1_sgaJ5 w_sgaJz w1_sgaJA w2_sgaJB; } in
        let {
          sat_sgaJy [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> m (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dTypeable_sgaJ0
               $dTypeable1_sgaJ1
               $dTypeable2_sgaJ2
               $dTypeable3_sgaJ3
               $dData_sgaJ4
               $dData1_sgaJ5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgmapM
                      $dTypeable_sgaJ0
                      $dTypeable1_sgaJ1
                      $dTypeable2_sgaJ2
                      $dTypeable3_sgaJ3
                      $dData_sgaJ4
                      $dData1_sgaJ5
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sgaJx [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> u
          [LclId] =
              [$dTypeable_sgaJ0
               $dTypeable1_sgaJ1
               $dTypeable2_sgaJ2
               $dTypeable3_sgaJ3
               $dData_sgaJ4
               $dData1_sgaJ5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgmapQi
                      $dTypeable_sgaJ0
                      $dTypeable1_sgaJ1
                      $dTypeable2_sgaJ2
                      $dTypeable3_sgaJ3
                      $dData_sgaJ4
                      $dData1_sgaJ5
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sgaJw [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7 -> [u]
          [LclId] =
              [$dData_sgaJ4 $dData1_sgaJ5] \r [ds_sgaJo x0_sgaJp]
                  case x0_sgaJp of {
                    Data.Functor.Product.Pair a1_sgaJr [Occ=Once]
                                              a2_sgaJs [Occ=Once] ->
                        let {
                          sat_sgaJu [Occ=Once] :: u_ag3Nq
                          [LclId] =
                              [$dData1_sgaJ5 ds_sgaJo a2_sgaJs] \u []
                                  ds_sgaJo $dData1_sgaJ5 a2_sgaJs; } in
                        let {
                          sat_sgaJv [Occ=Once] :: [u_ag3Nq]
                          [LclId] =
                              CCCS :! [sat_sgaJu GHC.Types.[]]; } in
                        let {
                          sat_sgaJt [Occ=Once] :: u_ag3Nq
                          [LclId] =
                              [$dData_sgaJ4 ds_sgaJo a1_sgaJr] \u []
                                  ds_sgaJo $dData_sgaJ4 a1_sgaJr;
                        } in  : [sat_sgaJt sat_sgaJv];
                  }; } in
        let {
          sat_sgaJn [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> r
          [LclId] =
              [$dTypeable_sgaJ0
               $dTypeable1_sgaJ1
               $dTypeable2_sgaJ2
               $dTypeable3_sgaJ3
               $dData_sgaJ4
               $dData1_sgaJ5] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgmapQr
                      $dTypeable_sgaJ0
                      $dTypeable1_sgaJ1
                      $dTypeable2_sgaJ2
                      $dTypeable3_sgaJ3
                      $dData_sgaJ4
                      $dData1_sgaJ5
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sgaJm [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> r
          [LclId] =
              [$dTypeable_sgaJ0
               $dTypeable1_sgaJ1
               $dTypeable2_sgaJ2
               $dTypeable3_sgaJ3
               $dData_sgaJ4
               $dData1_sgaJ5] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct2
                      $dTypeable_sgaJ0
                      $dTypeable1_sgaJ1
                      $dTypeable2_sgaJ2
                      $dTypeable3_sgaJ3
                      $dData_sgaJ4
                      $dData1_sgaJ5
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sgaJl [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
          [LclId] =
              [$dData_sgaJ4 $dData1_sgaJ5] \r [ds_sgaJe x0_sgaJf]
                  case x0_sgaJf of {
                    Data.Functor.Product.Pair a1_sgaJh [Occ=Once]
                                              a2_sgaJi [Occ=Once] ->
                        let {
                          sat_sgaJk [Occ=Once] :: g_Xg3V4 a_Xg3V7
                          [LclId] =
                              [$dData1_sgaJ5 ds_sgaJe a2_sgaJi] \u []
                                  ds_sgaJe $dData1_sgaJ5 a2_sgaJi; } in
                        let {
                          sat_sgaJj [Occ=Once] :: f_Xg3PP a_Xg3V7
                          [LclId] =
                              [$dData_sgaJ4 ds_sgaJe a1_sgaJh] \u []
                                  ds_sgaJe $dData_sgaJ4 a1_sgaJh;
                        } in  Data.Functor.Product.Pair [sat_sgaJj sat_sgaJk];
                  }; } in
        let {
          sat_sgaJd [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dData_sgaJ4 $dData1_sgaJ5] \r [k1_sgaJ8 z_sgaJ9 ds_sgaJa]
                  let {
                    sat_sgaJc [Occ=Once]
                      :: c_ag3LC (g_Xg3V4 a_Xg3V7
                                  -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
                    [LclId] =
                        [$dData_sgaJ4 k1_sgaJ8 z_sgaJ9] \u []
                            let {
                              sat_sgaJb [Occ=Once]
                                :: c_ag3LC (f_Xg3PP a_Xg3V7
                                            -> g_Xg3V4 a_Xg3V7
                                            -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
                              [LclId] =
                                  [z_sgaJ9] \u [] z_sgaJ9 Data.Functor.Product.Pair;
                            } in  k1_sgaJ8 $dData_sgaJ4 sat_sgaJb;
                  } in  k1_sgaJ8 $dData1_sgaJ5 sat_sgaJc; } in
        let {
          sat_sgaJ7 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> c (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dTypeable_sgaJ0
               $dTypeable1_sgaJ1
               $dTypeable2_sgaJ2
               $dTypeable3_sgaJ3
               $dData_sgaJ4
               $dData1_sgaJ5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgfoldl
                      $dTypeable_sgaJ0
                      $dTypeable1_sgaJ1
                      $dTypeable2_sgaJ2
                      $dTypeable3_sgaJ3
                      $dData_sgaJ4
                      $dData1_sgaJ5
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sgaJ6 [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dTypeable_sgaJ0
               $dTypeable1_sgaJ1
               $dTypeable2_sgaJ2
               $dTypeable3_sgaJ3] \u []
                  Data.Functor.Product.$w$cp1Data
                      $dTypeable_sgaJ0
                      $dTypeable1_sgaJ1
                      $dTypeable2_sgaJ2
                      $dTypeable3_sgaJ3;
        } in 
          Data.Data.C:Data [sat_sgaJ6
                            sat_sgaJ7
                            sat_sgaJd
                            lvl5_rg5oj
                            lvl6_rg5ok
                            lvl7_rg5ol
                            lvl8_rg5om
                            sat_sgaJl
                            sat_sgaJm
                            sat_sgaJn
                            sat_sgaJw
                            sat_sgaJx
                            sat_sgaJy
                            sat_sgaJC
                            sat_sgaJG];

Data.Functor.Product.Pair
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     f a -> g a -> Data.Functor.Product.Product f g a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Product.Pair [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:12:03.858886358 UTC

Data.Functor.Product.$fEq1Product_$cliftEq
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sgao2 $dEq2_sgao3 eq_sgao4 ds_sgao5 ds1_sgao6]
        case ds_sgao5 of {
          Data.Functor.Product.Pair x1_sgao8 [Occ=Once]
                                    y1_sgao9 [Occ=Once] ->
              case ds1_sgao6 of {
                Data.Functor.Product.Pair x2_sgaob [Occ=Once]
                                          y2_sgaoc [Occ=Once] ->
                    case $dEq1_sgao2 eq_sgao4 x1_sgao8 x2_sgaob of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> $dEq2_sgao3 eq_sgao4 y1_sgao9 y2_sgaoc;
                    };
              };
        };

Data.Functor.Product.$fEq1Product [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     Data.Functor.Classes.Eq1 (Data.Functor.Product.Product f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Product.$fEq1Product_$cliftEq
            eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Product.$w$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> f a -> g a -> f b -> g b -> GHC.Types.Ordering
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaoe
           w1_sgaof
           w2_sgaog
           ww_sgaoh
           ww1_sgaoi
           ww2_sgaoj
           ww3_sgaok]
        case
            Data.Functor.Classes.liftCompare
                w_sgaoe w2_sgaog ww_sgaoh ww2_sgaoj
        of
        { GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ ->
              Data.Functor.Classes.liftCompare
                  w1_sgaof w2_sgaog ww1_sgaoi ww3_sgaok;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Product.$fOrd1Product_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaom w1_sgaon w2_sgaoo w3_sgaop w4_sgaoq]
        case w3_sgaop of {
          Data.Functor.Product.Pair ww1_sgaos [Occ=Once]
                                    ww2_sgaot [Occ=Once] ->
              case w4_sgaoq of {
                Data.Functor.Product.Pair ww4_sgaov [Occ=Once]
                                          ww5_sgaow [Occ=Once] ->
                    Data.Functor.Product.$w$cliftCompare
                        w_sgaom w1_sgaon w2_sgaoo ww1_sgaos ww2_sgaot ww4_sgaov ww5_sgaow;
              };
        };

Data.Functor.Product.$w$cp1Ord1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> f a -> g a -> f b -> g b -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaox
           w1_sgaoy
           w2_sgaoz
           ww_sgaoA
           ww1_sgaoB
           ww2_sgaoC
           ww3_sgaoD]
        case
            Data.Functor.Classes.$p1Ord1 w_sgaox w2_sgaoz ww_sgaoA ww2_sgaoC
        of
        { GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True ->
              Data.Functor.Classes.$p1Ord1 w1_sgaoy w2_sgaoz ww1_sgaoB ww3_sgaoD;
        };

Data.Functor.Product.$fOrd1Product1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaoF w1_sgaoG w2_sgaoH w3_sgaoI w4_sgaoJ]
        case w3_sgaoI of {
          Data.Functor.Product.Pair ww1_sgaoL [Occ=Once]
                                    ww2_sgaoM [Occ=Once] ->
              case w4_sgaoJ of {
                Data.Functor.Product.Pair ww4_sgaoO [Occ=Once]
                                          ww5_sgaoP [Occ=Once] ->
                    Data.Functor.Product.$w$cp1Ord1
                        w_sgaoF w1_sgaoG w2_sgaoH ww1_sgaoL ww2_sgaoM ww4_sgaoO ww5_sgaoP;
              };
        };

Data.Functor.Product.$fOrd1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     Data.Functor.Classes.Ord1 (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(C1(C1(U))),C(C1(C1(U))))>m] =
    [] \r [$dOrd1_sgaoQ $dOrd2_sgaoR]
        let {
          sat_sgaoT [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Product.Product f_Xg499 g_Xg49b a
               -> Data.Functor.Product.Product f_Xg499 g_Xg49b b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sgaoQ $dOrd2_sgaoR] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fOrd1Product_$cliftCompare
                      $dOrd1_sgaoQ $dOrd2_sgaoR eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgaoS [Occ=Once]
            :: Data.Functor.Classes.Eq1
                 (Data.Functor.Product.Product f_Xg499 g_Xg49b)
          [LclId] =
              [$dOrd1_sgaoQ $dOrd2_sgaoR] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fOrd1Product1
                      $dOrd1_sgaoQ $dOrd2_sgaoR eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sgaoS sat_sgaoT];

Data.Functor.Product.$fRead1Product3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Pair"#;

Data.Functor.Product.$fRead1Product2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Product.$fRead1Product3;

Data.Functor.Product.$fRead1Product1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Product.$fRead1Product2];

Data.Functor.Product.$fRead1Product_lvl3
  :: Text.ParserCombinators.ReadPrec.Prec
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Product.$fRead1Product_$cliftReadPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgaoU $dRead2_sgaoV rp_sgaoW rl_sgaoX]
        let {
          reader_sgaoY [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_ag45N a_ag46b)
          [LclId] =
              [$dRead1_sgaoU rp_sgaoW rl_sgaoX] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead1_sgaoU rp_sgaoW rl_sgaoX; } in
        let {
          reader1_sgaoZ [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (g_ag45O a_ag46b)
          [LclId] =
              [$dRead2_sgaoV rp_sgaoW rl_sgaoX] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead2_sgaoV rp_sgaoW rl_sgaoX; } in
        let {
          $wlvl_sgap0 [InlPrag=NOUSERINLINE[0], Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: GHC.Prim.Int#
               -> forall b.
                  (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46b
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [reader_sgaoY reader1_sgaoZ] \r [ww_sgap1 w_sgap2]
                  case <=# [ww_sgap1 10#] of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                    1# ->
                        let {
                          sat_sgapa [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_sg4P0
                          [LclId] =
                              [reader_sgaoY reader1_sgaoZ w_sgap2] \r [a1_sgap4]
                                  let {
                                    sat_sgap9 [Occ=Once]
                                      :: f_ag45N a_ag46b -> Text.ParserCombinators.ReadP.P b_sg4P0
                                    [LclId] =
                                        [reader1_sgaoZ w_sgap2] \r [a2_sgap5]
                                            let {
                                              sat_sgap8 [Occ=Once]
                                                :: g_ag45O a_ag46b
                                                   -> Text.ParserCombinators.ReadP.P b_sg4P0
                                              [LclId] =
                                                  [w_sgap2 a2_sgap5] \r [a3_sgap6]
                                                      let {
                                                        sat_sgap7 [Occ=Once]
                                                          :: Data.Functor.Product.Product
                                                               f_ag45N g_ag45O a_ag46b
                                                        [LclId] =
                                                            CCCS Data.Functor.Product.Pair! [a2_sgap5
                                                                                             a3_sgap6];
                                                      } in  w_sgap2 sat_sgap7;
                                            } in 
                                              reader1_sgaoZ
                                                  Data.Functor.Product.$fRead1Product_lvl3
                                                  sat_sgap8;
                                  } in 
                                    reader_sgaoY Data.Functor.Product.$fRead1Product_lvl3 sat_sgap9;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Functor.Product.$fRead1Product1 sat_sgapa
                          of
                          { Unit# ww2_sgapc [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_sgapc];
                          };
                  }; } in
        let {
          lvl9_sgapd [InlPrag=NOUSERINLINE[0], Occ=OnceL, Dmd=<L,C(C(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46b
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
              [$wlvl_sgap0] \r [w_sgape w1_sgapf]
                  case w_sgape of {
                    GHC.Types.I# ww1_sgaph [Occ=Once] ->
                        $wlvl_sgap0 ww1_sgaph w1_sgapf;
                  }; } in
        let {
          sat_sgapk [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46b
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [lvl9_sgapd] \r [eta_sgapi eta1_sgapj]
                  GHC.Read.list3 lvl9_sgapd eta_sgapi eta1_sgapj;
        } in  sat_sgapk;

Data.Functor.Product.$fRead1Product_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgapl $dRead2_sgapm rp_sgapn rl_sgapo]
        let {
          ds_sgapp [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag45N g_ag45O a_ag45U)
          [LclId] =
              [$dRead1_sgapl $dRead2_sgapm rp_sgapn rl_sgapo] \u []
                  let {
                    sat_sgapv [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag45U]
                    [LclId] =
                        [rl_sgapo] \r [n_sgapr w1_sgaps]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sgapo w1_sgaps
                            of
                            { Unit# ww1_sgapu [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sgapu];
                            }; } in
                  let {
                    sat_sgapq [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag45U
                    [LclId] =
                        [rp_sgapn] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sgapn eta_B1;
                  } in 
                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                        $dRead1_sgapl $dRead2_sgapm sat_sgapq sat_sgapv; } in
        let {
          sat_sgapy [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag45N g_ag45O a_ag45U)
          [LclId] =
              [ds_sgapp] \r [n_sgapw]
                  let {
                    sat_sgapx [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Product.Product f_ag45N g_ag45O a_ag45U)
                    [LclId] =
                        [ds_sgapp n_sgapw] \u []
                            ds_sgapp
                                n_sgapw Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgapx;
        } in  sat_sgapy;

Data.Functor.Product.$fRead1Product_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Product.Product f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgapz $dRead2_sgapA rp_sgapB rl_sgapC]
        let {
          sat_sgapD [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag45N g_ag45O a_ag46x)
          [LclId] =
              [$dRead1_sgapz $dRead2_sgapA rp_sgapB rl_sgapC] \s []
                  Data.Functor.Product.$fRead1Product_$cliftReadPrec
                      $dRead1_sgapz $dRead2_sgapA rp_sgapB rl_sgapC;
        } in  GHC.Read.list sat_sgapD;

Data.Functor.Product.$fRead1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     Data.Functor.Classes.Read1 (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>m] =
    [] \r [$dRead1_sgapE $dRead2_sgapF]
        let {
          sat_sgapJ [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Product.Product f_ag45N g_ag45O a]
          [LclId] =
              [$dRead1_sgapE $dRead2_sgapF] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fRead1Product_$cliftReadListPrec
                      $dRead1_sgapE $dRead2_sgapF eta_B2 eta_B1; } in
        let {
          sat_sgapI [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Product.Product f_ag45N g_ag45O a)
          [LclId] =
              [$dRead1_sgapE $dRead2_sgapF] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fRead1Product_$cliftReadPrec
                      $dRead1_sgapE $dRead2_sgapF eta_B2 eta_B1; } in
        let {
          sat_sgapH [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Product.Product f_ag45N g_ag45O a]
          [LclId] =
              [$dRead1_sgapE $dRead2_sgapF] \u []
                  Data.Functor.Product.$fRead1Product_$cliftReadList
                      $dRead1_sgapE $dRead2_sgapF; } in
        let {
          sat_sgapG [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag45N g_ag45O a)
          [LclId] =
              [$dRead1_sgapE $dRead2_sgapF] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fRead1Product_$cliftReadsPrec
                      $dRead1_sgapE $dRead2_sgapF eta_B2 eta_B1;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sgapG
                                        sat_sgapH
                                        sat_sgapI
                                        sat_sgapJ];
Data.Functor.Product.$fRead1Product_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Product.Product f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgapK $dRead2_sgapL]
        let {
          sat_sgapM [Occ=Once]
            :: Data.Functor.Classes.Read1
                 (Data.Functor.Product.Product f_ag45N g_ag45O)
          [LclId] =
              [$dRead1_sgapK $dRead2_sgapL] \u []
                  Data.Functor.Product.$fRead1Product $dRead1_sgapK $dRead2_sgapL;
        } in  Data.Functor.Classes.liftReadListDefault sat_sgapM;

Data.Functor.Product.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> f a
     -> g a
     -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgapN
           w1_sgapO
           w2_sgapP
           w3_sgapQ
           ww_sgapR
           ww1_sgapS
           ww2_sgapT]
        let {
          sat_sgapV [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> g_sg4Pq a_sg4Pt -> GHC.Show.ShowS
          [LclId] =
              [w1_sgapO w2_sgapP w3_sgapQ] \s []
                  Data.Functor.Classes.liftShowsPrec w1_sgapO w2_sgapP w3_sgapQ; } in
        let {
          sat_sgapU [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> f_sg4Pp a_sg4Pt -> GHC.Show.ShowS
          [LclId] =
              [w_sgapN w2_sgapP w3_sgapQ] \s []
                  Data.Functor.Classes.liftShowsPrec w_sgapN w2_sgapP w3_sgapQ;
        } in 
          Data.Functor.Classes.$wshowsBinaryWith
              sat_sgapU
              sat_sgapV
              Data.Functor.Product.$fRead1Product2
              ww_sgapR
              ww1_sgapS
              ww2_sgapT;

Data.Functor.Product.$fShow1Product_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Product.Product f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgapW w1_sgapX w2_sgapY w3_sgapZ w4_sgaq0 w5_sgaq1]
        case w4_sgaq0 of {
          GHC.Types.I# ww1_sgaq3 [Occ=Once] ->
              case w5_sgaq1 of {
                Data.Functor.Product.Pair ww3_sgaq5 [Occ=Once]
                                          ww4_sgaq6 [Occ=Once] ->
                    Data.Functor.Product.$w$cliftShowsPrec
                        w_sgapW w1_sgapX w2_sgapY w3_sgapZ ww1_sgaq3 ww3_sgaq5 ww4_sgaq6;
              };
        };

Data.Functor.Product.$fFoldableProduct4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Product.$fShow1Product_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Product.Product f g a]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U><L,U><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgaq7
           $dShow2_sgaq8
           sp_sgaq9
           sl_sgaqa
           eta_sgaqb
           eta1_sgaqc]
        let {
          sat_sgaqh [Occ=Once]
            :: Data.Functor.Product.Product f_ag45l g_ag45m a_ag45G
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgaq7 $dShow2_sgaq8 sp_sgaq9 sl_sgaqa] \r [w_sgaqd]
                  case w_sgaqd of {
                    Data.Functor.Product.Pair ww1_sgaqf [Occ=Once]
                                              ww2_sgaqg [Occ=Once] ->
                        Data.Functor.Product.$w$cliftShowsPrec
                            $dShow1_sgaq7
                            $dShow2_sgaq8
                            sp_sgaq9
                            sl_sgaqa
                            0#
                            ww1_sgaqf
                            ww2_sgaqg;
                  };
        } in  GHC.Show.showList__ sat_sgaqh eta_sgaqb eta1_sgaqc;

Data.Functor.Product.$fShow1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     Data.Functor.Classes.Show1 (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)>m] =
    [] \r [$dShow1_sgaqi $dShow2_sgaqj]
        let {
          sat_sgaql [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Product.Product f_ag45l g_ag45m a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgaqi $dShow2_sgaqj] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fShow1Product_$cliftShowList
                      $dShow1_sgaqi $dShow2_sgaqj eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgaqk [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Product.Product f_ag45l g_ag45m a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgaqi $dShow2_sgaqj] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fShow1Product_$cliftShowsPrec
                      $dShow1_sgaqi $dShow2_sgaqj eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sgaqk sat_sgaql];

Data.Functor.Product.$w$c== [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaqm
           w1_sgaqn
           w2_sgaqo
           ww_sgaqp
           ww1_sgaqq
           ww2_sgaqr
           ww3_sgaqs]
        let {
          eq_sgaqt :: a_sg4PK -> a_sg4PK -> GHC.Types.Bool
          [LclId] =
              [w2_sgaqo] \u [] GHC.Classes.== w2_sgaqo;
        } in 
          case w_sgaqm eq_sgaqt ww_sgaqp ww2_sgaqr of {
            GHC.Types.False -> GHC.Types.False [];
            GHC.Types.True -> w1_sgaqn eq_sgaqt ww1_sgaqq ww3_sgaqs;
          };

Data.Functor.Product.$fEqProduct_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaqv w1_sgaqw w2_sgaqx w3_sgaqy w4_sgaqz]
        case w3_sgaqy of {
          Data.Functor.Product.Pair ww1_sgaqB [Occ=Once]
                                    ww2_sgaqC [Occ=Once] ->
              case w4_sgaqz of {
                Data.Functor.Product.Pair ww4_sgaqE [Occ=Once]
                                          ww5_sgaqF [Occ=Once] ->
                    Data.Functor.Product.$w$c==
                        w_sgaqv w1_sgaqw w2_sgaqx ww1_sgaqB ww2_sgaqC ww4_sgaqE ww5_sgaqF;
              };
        };

Data.Functor.Product.$fEqProduct_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sgaqG $dEq2_sgaqH $dEq_sgaqI eta_sgaqJ eta1_sgaqK]
        case eta_sgaqJ of {
          Data.Functor.Product.Pair ww1_sgaqM [Occ=Once]
                                    ww2_sgaqN [Occ=Once] ->
              case eta1_sgaqK of {
                Data.Functor.Product.Pair ww4_sgaqP [Occ=Once]
                                          ww5_sgaqQ [Occ=Once] ->
                    let {
                      eq_sgaqR :: a_ag452 -> a_ag452 -> GHC.Types.Bool
                      [LclId] =
                          [$dEq_sgaqI] \u [] GHC.Classes.== $dEq_sgaqI;
                    } in 
                      case $dEq1_sgaqG eq_sgaqR ww1_sgaqM ww4_sgaqP of {
                        GHC.Types.False -> GHC.Types.True [];
                        GHC.Types.True ->
                            case $dEq2_sgaqH eq_sgaqR ww2_sgaqN ww5_sgaqQ of {
                              GHC.Types.False -> GHC.Types.True [];
                              GHC.Types.True -> GHC.Types.False [];
                            };
                      };
              };
        };

Data.Functor.Product.$fEqProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     GHC.Classes.Eq (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><L,U(U,A)>m] =
    [] \r [$dEq1_sgaqU $dEq2_sgaqV $dEq_sgaqW]
        let {
          sat_sgaqY [Occ=Once]
            :: Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sgaqU $dEq2_sgaqV $dEq_sgaqW] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fEqProduct_$c/=
                      $dEq1_sgaqU $dEq2_sgaqV $dEq_sgaqW eta_B2 eta_B1; } in
        let {
          sat_sgaqX [Occ=Once]
            :: Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> Data.Functor.Product.Product f_ag450 g_ag451 a_ag452
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sgaqU $dEq2_sgaqV $dEq_sgaqW] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fEqProduct_$c==
                      $dEq1_sgaqU $dEq2_sgaqV $dEq_sgaqW eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sgaqX sat_sgaqY];

Data.Functor.Product.$fOrdProduct_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgaqZ $dOrd2_sgar0 $dOrd_sgar1 eta_sgar2 eta1_sgar3]
        case eta_sgar2 of {
          Data.Functor.Product.Pair ww1_sgar5 [Occ=Once]
                                    ww2_sgar6 [Occ=Once] ->
              case eta1_sgar3 of {
                Data.Functor.Product.Pair ww4_sgar8 [Occ=Once]
                                          ww5_sgar9 [Occ=Once] ->
                    let {
                      w_sgara :: a_ag44e -> a_ag44e -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sgar1] \u [] GHC.Classes.compare $dOrd_sgar1;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sgaqZ w_sgara ww1_sgar5 ww4_sgar8
                      of
                      { GHC.Types.LT -> GHC.Types.LT [];
                        GHC.Types.EQ ->
                            Data.Functor.Classes.liftCompare
                                $dOrd2_sgar0 w_sgara ww2_sgar6 ww5_sgar9;
                        GHC.Types.GT -> GHC.Types.GT [];
                      };
              };
        };

Data.Functor.Product.$fOrdProduct_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Eq (Data.Functor.Product.Product f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgarc $dOrd2_sgard $dOrd_sgare]
        let {
          sat_sgarh [Occ=Once, Dmd=<L,U(U,A)>] :: GHC.Classes.Eq a_ag44e
          [LclId] =
              [$dOrd_sgare] \u [] GHC.Classes.$p1Ord $dOrd_sgare; } in
        let {
          sat_sgarg [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 g_ag44d
          [LclId] =
              [$dOrd2_sgard] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sgard; } in
        let {
          sat_sgarf [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 f_ag44c
          [LclId] =
              [$dOrd1_sgarc] \u [] Data.Functor.Classes.$p1Ord1 $dOrd1_sgarc;
        } in 
          Data.Functor.Product.$fEqProduct sat_sgarf sat_sgarg sat_sgarh;

Data.Functor.Product.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgari
           w1_sgarj
           w2_sgark
           ww_sgarl
           ww1_sgarm
           ww2_sgarn
           ww3_sgaro]
        let {
          comp_sgarp :: a_sg4Q3 -> a_sg4Q3 -> GHC.Types.Ordering
          [LclId] =
              [w2_sgark] \u [] GHC.Classes.compare w2_sgark;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sgari comp_sgarp ww_sgarl ww2_sgarn
          of
          { GHC.Types.LT -> GHC.Types.True [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sgarj comp_sgarp ww1_sgarm ww3_sgaro
                of
                { __DEFAULT -> GHC.Types.False [];
                  GHC.Types.LT -> GHC.Types.True [];
                };
            GHC.Types.GT -> GHC.Types.False [];
          };

Data.Functor.Product.$fOrdProduct_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgars w1_sgart w2_sgaru w3_sgarv w4_sgarw]
        case w3_sgarv of {
          Data.Functor.Product.Pair ww1_sgary [Occ=Once]
                                    ww2_sgarz [Occ=Once] ->
              case w4_sgarw of {
                Data.Functor.Product.Pair ww4_sgarB [Occ=Once]
                                          ww5_sgarC [Occ=Once] ->
                    Data.Functor.Product.$w$c<
                        w_sgars w1_sgart w2_sgaru ww1_sgary ww2_sgarz ww4_sgarB ww5_sgarC;
              };
        };

Data.Functor.Product.$w$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgarD
           w1_sgarE
           w2_sgarF
           ww_sgarG
           ww1_sgarH
           ww2_sgarI
           ww3_sgarJ]
        let {
          comp_sgarK :: a_sg4Qm -> a_sg4Qm -> GHC.Types.Ordering
          [LclId] =
              [w2_sgarF] \u [] GHC.Classes.compare w2_sgarF;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sgarD comp_sgarK ww_sgarG ww2_sgarI
          of
          { GHC.Types.LT -> GHC.Types.False [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sgarE comp_sgarK ww1_sgarH ww3_sgarJ
                of
                { __DEFAULT -> GHC.Types.True [];
                  GHC.Types.LT -> GHC.Types.False [];
                };
            GHC.Types.GT -> GHC.Types.True [];
          };

Data.Functor.Product.$fOrdProduct_$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgarN w1_sgarO w2_sgarP w3_sgarQ w4_sgarR]
        case w3_sgarQ of {
          Data.Functor.Product.Pair ww1_sgarT [Occ=Once]
                                    ww2_sgarU [Occ=Once] ->
              case w4_sgarR of {
                Data.Functor.Product.Pair ww4_sgarW [Occ=Once]
                                          ww5_sgarX [Occ=Once] ->
                    Data.Functor.Product.$w$c>=
                        w_sgarN w1_sgarO w2_sgarP ww1_sgarT ww2_sgarU ww4_sgarW ww5_sgarX;
              };
        };

Data.Functor.Product.$w$c> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgarY
           w1_sgarZ
           w2_sgas0
           ww_sgas1
           ww1_sgas2
           ww2_sgas3
           ww3_sgas4]
        let {
          comp_sgas5 :: a_sg4QF -> a_sg4QF -> GHC.Types.Ordering
          [LclId] =
              [w2_sgas0] \u [] GHC.Classes.compare w2_sgas0;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sgarY comp_sgas5 ww_sgas1 ww2_sgas3
          of
          { GHC.Types.LT -> GHC.Types.False [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sgarZ comp_sgas5 ww1_sgas2 ww3_sgas4
                of
                { __DEFAULT -> GHC.Types.False [];
                  GHC.Types.GT -> GHC.Types.True [];
                };
            GHC.Types.GT -> GHC.Types.True [];
          };

Data.Functor.Product.$fOrdProduct_$c> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgas8 w1_sgas9 w2_sgasa w3_sgasb w4_sgasc]
        case w3_sgasb of {
          Data.Functor.Product.Pair ww1_sgase [Occ=Once]
                                    ww2_sgasf [Occ=Once] ->
              case w4_sgasc of {
                Data.Functor.Product.Pair ww4_sgash [Occ=Once]
                                          ww5_sgasi [Occ=Once] ->
                    Data.Functor.Product.$w$c>
                        w_sgas8 w1_sgas9 w2_sgasa ww1_sgase ww2_sgasf ww4_sgash ww5_sgasi;
              };
        };

Data.Functor.Product.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     f a -> g a -> f a -> g a -> GHC.Types.Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgasj
           w1_sgask
           w2_sgasl
           ww_sgasm
           ww1_sgasn
           ww2_sgaso
           ww3_sgasp]
        let {
          comp_sgasq :: a_sg4QY -> a_sg4QY -> GHC.Types.Ordering
          [LclId] =
              [w2_sgasl] \u [] GHC.Classes.compare w2_sgasl;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  w_sgasj comp_sgasq ww_sgasm ww2_sgaso
          of
          { GHC.Types.LT -> GHC.Types.True [];
            GHC.Types.EQ ->
                case
                    Data.Functor.Classes.liftCompare
                        w1_sgask comp_sgasq ww1_sgasn ww3_sgasp
                of
                { __DEFAULT -> GHC.Types.True [];
                  GHC.Types.GT -> GHC.Types.False [];
                };
            GHC.Types.GT -> GHC.Types.False [];
          };

Data.Functor.Product.$fOrdProduct_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgast w1_sgasu w2_sgasv w3_sgasw w4_sgasx]
        case w3_sgasw of {
          Data.Functor.Product.Pair ww1_sgasz [Occ=Once]
                                    ww2_sgasA [Occ=Once] ->
              case w4_sgasx of {
                Data.Functor.Product.Pair ww4_sgasC [Occ=Once]
                                          ww5_sgasD [Occ=Once] ->
                    Data.Functor.Product.$w$c<=
                        w_sgast w1_sgasu w2_sgasv ww1_sgasz ww2_sgasA ww4_sgasC ww5_sgasD;
              };
        };

Data.Functor.Product.$fOrdProduct_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgasE $dOrd2_sgasF $dOrd_sgasG x_sgasH y_sgasI]
        case x_sgasH of ww_sgasJ {
          Data.Functor.Product.Pair ww1_sgasK [Occ=Once]
                                    ww2_sgasL [Occ=Once] ->
              case y_sgasI of ww3_sgasM {
                Data.Functor.Product.Pair ww4_sgasN [Occ=Once]
                                          ww5_sgasO [Occ=Once] ->
                    let {
                      comp_sgasP :: a_ag44e -> a_ag44e -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sgasG] \u [] GHC.Classes.compare $dOrd_sgasG;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sgasE comp_sgasP ww1_sgasK ww4_sgasN
                      of
                      { GHC.Types.LT -> ww3_sgasM;
                        GHC.Types.EQ ->
                            case
                                Data.Functor.Classes.liftCompare
                                    $dOrd2_sgasF comp_sgasP ww2_sgasL ww5_sgasO
                            of
                            { __DEFAULT -> ww3_sgasM;
                              GHC.Types.GT -> ww_sgasJ;
                            };
                        GHC.Types.GT -> ww_sgasJ;
                      };
              };
        };

Data.Functor.Product.$fOrdProduct_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgasS $dOrd2_sgasT $dOrd_sgasU x_sgasV y_sgasW]
        case x_sgasV of ww_sgasX {
          Data.Functor.Product.Pair ww1_sgasY [Occ=Once]
                                    ww2_sgasZ [Occ=Once] ->
              case y_sgasW of ww3_sgat0 {
                Data.Functor.Product.Pair ww4_sgat1 [Occ=Once]
                                          ww5_sgat2 [Occ=Once] ->
                    let {
                      comp_sgat3 :: a_ag44e -> a_ag44e -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sgasU] \u [] GHC.Classes.compare $dOrd_sgasU;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sgasS comp_sgat3 ww1_sgasY ww4_sgat1
                      of
                      { GHC.Types.LT -> ww_sgasX;
                        GHC.Types.EQ ->
                            case
                                Data.Functor.Classes.liftCompare
                                    $dOrd2_sgasT comp_sgat3 ww2_sgasZ ww5_sgat2
                            of
                            { __DEFAULT -> ww_sgasX;
                              GHC.Types.GT -> ww3_sgat0;
                            };
                        GHC.Types.GT -> ww3_sgat0;
                      };
              };
        };

Data.Functor.Product.$fOrdProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Ord (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m] =
    [] \r [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8]
        let {
          sat_sgatg [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$cmin
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgatf [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$cmax
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgate [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c>=
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgatd [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c>
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgatc [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c<=
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgatb [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$c<
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgata [Occ=Once]
            :: Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fOrdProduct_$ccompare
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8 eta_B2 eta_B1; } in
        let {
          sat_sgat9 [Occ=Once]
            :: GHC.Classes.Eq
                 (Data.Functor.Product.Product f_ag44c g_ag44d a_ag44e)
          [LclId] =
              [$dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8] \u []
                  Data.Functor.Product.$fOrdProduct_$cp1Ord
                      $dOrd1_sgat6 $dOrd2_sgat7 $dOrd_sgat8;
        } in 
          GHC.Classes.C:Ord [sat_sgat9
                             sat_sgata
                             sat_sgatb
                             sat_sgatc
                             sat_sgatd
                             sat_sgate
                             sat_sgatf
                             sat_sgatg];

Data.Functor.Product.$fReadProduct_$creadPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       (Data.Functor.Product.Product f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgath $dRead2_sgati $dRead_sgatj]
        let {
          sat_sgatl [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag43H]
          [LclId] =
              [$dRead_sgatj] \u [] GHC.Read.readListPrec $dRead_sgatj; } in
        let {
          sat_sgatk [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag43H
          [LclId] =
              [$dRead_sgatj] \u [] GHC.Read.readPrec $dRead_sgatj;
        } in 
          Data.Functor.Product.$fRead1Product_$cliftReadPrec
              $dRead1_sgath $dRead2_sgati sat_sgatk sat_sgatl;

Data.Functor.Product.$fReadProduct_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Product.Product f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgatm $dRead2_sgatn $dRead_sgato]
        let {
          ds_sgatp [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sgatm $dRead2_sgatn $dRead_sgato] \u []
                  let {
                    sat_sgatr [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag43H]
                    [LclId] =
                        [$dRead_sgato] \u [] GHC.Read.readListPrec $dRead_sgato; } in
                  let {
                    sat_sgatq [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag43H
                    [LclId] =
                        [$dRead_sgato] \u [] GHC.Read.readPrec $dRead_sgato;
                  } in 
                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                        $dRead1_sgatm $dRead2_sgatn sat_sgatq sat_sgatr; } in
        let {
          sat_sgatu [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [ds_sgatp] \r [n_sgats]
                  let {
                    sat_sgatt [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
                    [LclId] =
                        [ds_sgatp n_sgats] \u []
                            ds_sgatp
                                n_sgats Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgatt;
        } in  sat_sgatu;

Data.Functor.Product.$fReadProduct_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Product.Product f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgatv $dRead2_sgatw $dRead_sgatx]
        let {
          sat_sgatA [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sgatv $dRead2_sgatw $dRead_sgatx] \s []
                  let {
                    sat_sgatz [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag43H]
                    [LclId] =
                        [$dRead_sgatx] \u [] GHC.Read.readListPrec $dRead_sgatx; } in
                  let {
                    sat_sgaty [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag43H
                    [LclId] =
                        [$dRead_sgatx] \u [] GHC.Read.readPrec $dRead_sgatx;
                  } in 
                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                        $dRead1_sgatv $dRead2_sgatw sat_sgaty sat_sgatz;
        } in  GHC.Read.list sat_sgatA;

Data.Functor.Product.$fReadProduct_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Functor.Product.Product f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgatB $dRead2_sgatC $dRead_sgatD]
        let {
          sat_sgatE [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H]
          [LclId] =
              [$dRead1_sgatB $dRead2_sgatC $dRead_sgatD] \u []
                  Data.Functor.Product.$fReadProduct_$creadListPrec
                      $dRead1_sgatB
                      $dRead2_sgatC
                      $dRead_sgatD
                      GHC.Read.$fRead()7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgatE;

Data.Functor.Product.$fReadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Read.Read (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,U,U)>m] =
    [] \r [$dRead1_sgatF $dRead2_sgatG $dRead_sgatH]
        let {
          sat_sgatL [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H]
          [LclId] =
              [$dRead1_sgatF $dRead2_sgatG $dRead_sgatH] \u []
                  Data.Functor.Product.$fReadProduct_$creadListPrec
                      $dRead1_sgatF $dRead2_sgatG $dRead_sgatH; } in
        let {
          sat_sgatK [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sgatF $dRead2_sgatG $dRead_sgatH] \u []
                  Data.Functor.Product.$fReadProduct_$creadPrec
                      $dRead1_sgatF $dRead2_sgatG $dRead_sgatH; } in
        let {
          sat_sgatJ [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H]
          [LclId] =
              [$dRead1_sgatF $dRead2_sgatG $dRead_sgatH] \u []
                  Data.Functor.Product.$fReadProduct_$creadList
                      $dRead1_sgatF $dRead2_sgatG $dRead_sgatH; } in
        let {
          sat_sgatI [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Product.Product f_ag43F g_ag43G a_ag43H)
          [LclId] =
              [$dRead1_sgatF $dRead2_sgatG $dRead_sgatH] \u []
                  Data.Functor.Product.$fReadProduct_$creadsPrec
                      $dRead1_sgatF $dRead2_sgatG $dRead_sgatH;
        } in  GHC.Read.C:Read [sat_sgatI sat_sgatJ sat_sgatK sat_sgatL];

Data.Functor.Product.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Prim.Int# -> f a -> g a -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgatM w1_sgatN w2_sgatO ww_sgatP ww1_sgatQ ww2_sgatR]
        let {
          sp_sgatS :: GHC.Types.Int -> a_sg4Rt -> GHC.Show.ShowS
          [LclId] =
              [w2_sgatO] \u [] GHC.Show.showsPrec w2_sgatO; } in
        let {
          sl_sgatT :: [a_sg4Rt] -> GHC.Show.ShowS
          [LclId] =
              [w2_sgatO] \u [] GHC.Show.showList w2_sgatO; } in
        let {
          sat_sgatV [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> g_sg4Rs a_sg4Rt -> GHC.Show.ShowS
          [LclId] =
              [w1_sgatN sp_sgatS sl_sgatT] \s []
                  Data.Functor.Classes.liftShowsPrec w1_sgatN sp_sgatS sl_sgatT; } in
        let {
          sat_sgatU [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> f_sg4Rr a_sg4Rt -> GHC.Show.ShowS
          [LclId] =
              [w_sgatM sp_sgatS sl_sgatT] \s []
                  Data.Functor.Classes.liftShowsPrec w_sgatM sp_sgatS sl_sgatT;
        } in 
          Data.Functor.Classes.$wshowsBinaryWith
              sat_sgatU
              sat_sgatV
              Data.Functor.Product.$fRead1Product2
              ww_sgatP
              ww1_sgatQ
              ww2_sgatR;

Data.Functor.Product.$fShowProduct_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Types.Int
     -> Data.Functor.Product.Product f g a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgatW w1_sgatX w2_sgatY w3_sgatZ w4_sgau0]
        case w3_sgatZ of {
          GHC.Types.I# ww1_sgau2 [Occ=Once] ->
              case w4_sgau0 of {
                Data.Functor.Product.Pair ww3_sgau4 [Occ=Once]
                                          ww4_sgau5 [Occ=Once] ->
                    Data.Functor.Product.$w$cshowsPrec
                        w_sgatW w1_sgatX w2_sgatY ww1_sgau2 ww3_sgau4 ww4_sgau5;
              };
        };

Data.Functor.Product.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     f a -> g a -> GHC.Base.String
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*U,A,1*U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgau6 w1_sgau7 w2_sgau8 ww_sgau9 ww1_sgaua]
        let {
          sp_sgaub :: GHC.Types.Int -> a_sg4RL -> GHC.Show.ShowS
          [LclId] =
              [w2_sgau8] \u [] GHC.Show.showsPrec w2_sgau8; } in
        let {
          sl_sgauc :: [a_sg4RL] -> GHC.Show.ShowS
          [LclId] =
              [w2_sgau8] \u [] GHC.Show.showList w2_sgau8; } in
        let {
          sat_sgauf [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [w_sgau6 w1_sgau7 ww_sgau9 ww1_sgaua sp_sgaub sl_sgauc] \u []
                  let {
                    sat_sgaud [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [w1_sgau7 ww1_sgaua sp_sgaub sl_sgauc] \u []
                            Data.Functor.Classes.liftShowsPrec
                                w1_sgau7
                                sp_sgaub
                                sl_sgauc
                                Data.Functor.Classes.$fRead1Const1
                                ww1_sgaua
                                GHC.Types.[]; } in
                  let {
                    sat_sgaue [Occ=Once] :: GHC.Base.String
                    [LclId] =
                        CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sgaud];
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w_sgau6
                        sp_sgaub
                        sl_sgauc
                        Data.Functor.Classes.$fRead1Const1
                        ww_sgau9
                        sat_sgaue; } in
        let {
          sat_sgaug [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sgauf];
        } in  GHC.Base.++ Data.Functor.Product.$fRead1Product2 sat_sgaug;

Data.Functor.Product.$fShowProduct_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     Data.Functor.Product.Product f g a -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(U,A,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgauh w1_sgaui w2_sgauj w3_sgauk]
        case w3_sgauk of {
          Data.Functor.Product.Pair ww1_sgaum [Occ=Once]
                                    ww2_sgaun [Occ=Once] ->
              Data.Functor.Product.$w$cshow
                  w_sgauh w1_sgaui w2_sgauj ww1_sgaum ww2_sgaun;
        };

Data.Functor.Product.$fShowProduct_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     [Data.Functor.Product.Product f g a] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgauo $dShow2_sgaup $dShow_sgauq ls_sgaur s_sgaus]
        let {
          lvl9_sgaut [Occ=OnceL]
            :: GHC.Types.Int -> a_ag43h -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgauq] \u [] GHC.Show.showsPrec $dShow_sgauq; } in
        let {
          lvl10_sgauu [Occ=OnceL] :: [a_ag43h] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgauq] \u [] GHC.Show.showList $dShow_sgauq; } in
        let {
          sat_sgauz [Occ=Once]
            :: Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgauo $dShow2_sgaup lvl9_sgaut lvl10_sgauu] \r [eta_sgauv]
                  case eta_sgauv of {
                    Data.Functor.Product.Pair ww1_sgaux [Occ=Once]
                                              ww2_sgauy [Occ=Once] ->
                        Data.Functor.Product.$w$cliftShowsPrec
                            $dShow1_sgauo
                            $dShow2_sgaup
                            lvl9_sgaut
                            lvl10_sgauu
                            0#
                            ww1_sgaux
                            ww2_sgauy;
                  };
        } in  GHC.Show.showList__ sat_sgauz ls_sgaur s_sgaus;

Data.Functor.Product.$fShowProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Show.Show (Data.Functor.Product.Product f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(U,A,U)>m] =
    [] \r [$dShow1_sgauA $dShow2_sgauB $dShow_sgauC]
        let {
          sat_sgauF [Occ=Once]
            :: [Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgauA $dShow2_sgauB $dShow_sgauC] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fShowProduct_$cshowList
                      $dShow1_sgauA $dShow2_sgauB $dShow_sgauC eta_B2 eta_B1; } in
        let {
          sat_sgauE [Occ=Once]
            :: Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h
               -> GHC.Base.String
          [LclId] =
              [$dShow1_sgauA $dShow2_sgauB $dShow_sgauC] \r [eta_B1]
                  Data.Functor.Product.$fShowProduct_$cshow
                      $dShow1_sgauA $dShow2_sgauB $dShow_sgauC eta_B1; } in
        let {
          sat_sgauD [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Product.Product f_ag43f g_ag43g a_ag43h
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgauA $dShow2_sgauB $dShow_sgauC] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fShowProduct_$cshowsPrec
                      $dShow1_sgauA $dShow2_sgauB $dShow_sgauC eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgauD sat_sgauE sat_sgauF];

Data.Functor.Product.$fFunctorProduct_$cfmap
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgauG $dFunctor1_sgauH f1_sgauI ds_sgauJ]
        case ds_sgauJ of {
          Data.Functor.Product.Pair x_sgauL [Occ=Once] y_sgauM [Occ=Once] ->
              let {
                sat_sgauO [Occ=Once] :: g_ag42H b_ag42O
                [LclId] =
                    [$dFunctor1_sgauH f1_sgauI y_sgauM] \u []
                        GHC.Base.fmap $dFunctor1_sgauH f1_sgauI y_sgauM; } in
              let {
                sat_sgauN [Occ=Once] :: f_ag42G b_ag42O
                [LclId] =
                    [$dFunctor_sgauG f1_sgauI x_sgauL] \u []
                        GHC.Base.fmap $dFunctor_sgauG f1_sgauI x_sgauL;
              } in  Data.Functor.Product.Pair [sat_sgauN sat_sgauO];
        };

Data.Functor.Product.$fFunctorProduct_$c<$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgauP w1_sgauQ w2_sgauR w3_sgauS]
        case w3_sgauS of {
          Data.Functor.Product.Pair ww1_sgauU [Occ=Once]
                                    ww2_sgauV [Occ=Once] ->
              let {
                f1_sgauW :: b_sg4S9 -> a_sg4S8
                [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
                    [w2_sgauR] \r [ds_sgauX] w2_sgauR; } in
              let {
                sat_sgauZ [Occ=Once] :: g_sg4S5 a_sg4S8
                [LclId] =
                    [w1_sgauQ ww2_sgauV f1_sgauW] \u []
                        GHC.Base.fmap w1_sgauQ f1_sgauW ww2_sgauV; } in
              let {
                sat_sgauY [Occ=Once] :: f_sg4S4 a_sg4S8
                [LclId] =
                    [w_sgauP ww1_sgauU f1_sgauW] \u []
                        GHC.Base.fmap w_sgauP f1_sgauW ww1_sgauU;
              } in  Data.Functor.Product.Pair [sat_sgauY sat_sgauZ];
        };

Data.Functor.Product.$fFunctorProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     GHC.Base.Functor (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dFunctor_sgav0 $dFunctor1_sgav1]
        let {
          sat_sgav3 [Occ=Once]
            :: forall a b.
               a
               -> Data.Functor.Product.Product f_ag42G g_ag42H b
               -> Data.Functor.Product.Product f_ag42G g_ag42H a
          [LclId] =
              [$dFunctor_sgav0 $dFunctor1_sgav1] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFunctorProduct_$c<$
                      $dFunctor_sgav0 $dFunctor1_sgav1 eta_B2 eta_B1; } in
        let {
          sat_sgav2 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Product.Product f_ag42G g_ag42H a
               -> Data.Functor.Product.Product f_ag42G g_ag42H b
          [LclId] =
              [$dFunctor_sgav0 $dFunctor1_sgav1] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFunctorProduct_$cfmap
                      $dFunctor_sgav0 $dFunctor1_sgav1 eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sgav2 sat_sgav3];

Data.Functor.Product.$w$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> f a -> g a -> m
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgav4 w1_sgav5 w2_sgav6 w3_sgav7 ww_sgav8 ww1_sgav9]
        let {
          sat_sgavb [Occ=Once] :: m_sg4Sp
          [LclId] =
              [w1_sgav5 w2_sgav6 w3_sgav7 ww1_sgav9] \u []
                  Data.Foldable.foldMap w1_sgav5 w2_sgav6 w3_sgav7 ww1_sgav9; } in
        let {
          sat_sgava [Occ=Once] :: m_sg4Sp
          [LclId] =
              [w_sgav4 w2_sgav6 w3_sgav7 ww_sgav8] \u []
                  Data.Foldable.foldMap w_sgav4 w2_sgav6 w3_sgav7 ww_sgav8;
        } in  GHC.Base.mappend w2_sgav6 sat_sgava sat_sgavb;

Data.Functor.Product.$fFoldableProduct_$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Functor.Product.Product f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgavc w1_sgavd w2_sgave w3_sgavf w4_sgavg]
        case w4_sgavg of {
          Data.Functor.Product.Pair ww1_sgavi [Occ=Once]
                                    ww2_sgavj [Occ=Once] ->
              Data.Functor.Product.$w$cfoldMap
                  w_sgavc w1_sgavd w2_sgave w3_sgavf ww1_sgavi ww2_sgavj;
        };

Data.Functor.Product.$fFoldableProduct_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m.
     GHC.Base.Monoid m =>
     Data.Functor.Product.Product f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgavk $dFoldable1_sgavl $dMonoid_sgavm w_sgavn]
        case w_sgavn of {
          Data.Functor.Product.Pair ww1_sgavp [Occ=Once]
                                    ww2_sgavq [Occ=Once] ->
              Data.Functor.Product.$w$cfoldMap
                  $dFoldable_sgavk
                  $dFoldable1_sgavl
                  $dMonoid_sgavm
                  GHC.Base.id
                  ww1_sgavp
                  ww2_sgavq;
        };

Data.Functor.Product.$fFoldableProduct1 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgavr] v_sgavr;

Data.Functor.Product.$fFoldableProduct_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgavs $dFoldable1_sgavt $dNum_sgavu]
        let {
          $dMonoid_sgavv
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_ag42n)
          [LclId] =
              [$dNum_sgavu] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sgavu; } in
        let {
          sat_sgavC [Occ=Once]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag42n
               -> Data.Semigroup.Internal.Sum a_ag42n
          [LclId] =
              [$dFoldable_sgavs
               $dFoldable1_sgavt
               $dNum_sgavu
               $dMonoid_sgavv] \r [ds_sgavw]
                  case ds_sgavw of {
                    Data.Functor.Product.Pair x_sgavy [Occ=Once] y_sgavz [Occ=Once] ->
                        let {
                          sat_sgavB [Occ=Once] :: a_ag42n
                          [LclId] =
                              [$dFoldable1_sgavt $dMonoid_sgavv y_sgavz] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_sgavt
                                      $dMonoid_sgavv
                                      Data.Functor.Product.$fFoldableProduct1
                                      y_sgavz; } in
                        let {
                          sat_sgavA [Occ=Once] :: a_ag42n
                          [LclId] =
                              [$dFoldable_sgavs $dMonoid_sgavv x_sgavy] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_sgavs
                                      $dMonoid_sgavv
                                      Data.Functor.Product.$fFoldableProduct1
                                      x_sgavy;
                        } in  GHC.Num.+ $dNum_sgavu sat_sgavA sat_sgavB;
                  };
        } in  sat_sgavC;

lvl_rg5nW :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Functor.Product.$fFoldableProduct2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rg5nW of sat_sgavD {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgavD;
        };

Data.Functor.Product.$fFoldableProduct_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgavE $dFoldable1_sgavF $dOrd_sgavG]
        let {
          $dMonoid_sgavH :: GHC.Base.Monoid (Data.Functor.Utils.Min a_ag42d)
          [LclId] =
              [$dOrd_sgavG] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_sgavG; } in
        let {
          sat_sgavT [Occ=OnceT[0]]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag42d -> a_ag42d
          [LclId] =
              [$dFoldable_sgavE
               $dFoldable1_sgavF
               $dOrd_sgavG
               $dMonoid_sgavH] \r [x_sgavI]
                  case x_sgavI of {
                    Data.Functor.Product.Pair x1_sgavK [Occ=Once*]
                                              y_sgavL [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sgavF $dMonoid_sgavH GHC.Base.Just y_sgavL
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sgavE $dMonoid_sgavH GHC.Base.Just x1_sgavK
                              of
                              { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct2;
                                GHC.Base.Just v_sgavO [Occ=Once] -> v_sgavO;
                              };
                          GHC.Base.Just ipv_sgavP ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sgavE $dMonoid_sgavH GHC.Base.Just x1_sgavK
                              of
                              { GHC.Base.Nothing -> ipv_sgavP;
                                GHC.Base.Just x2_sgavR ->
                                    case GHC.Classes.<= $dOrd_sgavG x2_sgavR ipv_sgavP of {
                                      GHC.Types.False -> ipv_sgavP;
                                      GHC.Types.True -> x2_sgavR;
                                    };
                              };
                        };
                  };
        } in  sat_sgavT;

lvl1_rg5nX :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Functor.Product.$fFoldableProduct3 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rg5nX of sat_sgavU {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgavU;
        };

Data.Functor.Product.$fFoldableProduct_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgavV $dFoldable1_sgavW $dOrd_sgavX]
        let {
          $dMonoid_sgavY :: GHC.Base.Monoid (Data.Functor.Utils.Max a_ag423)
          [LclId] =
              [$dOrd_sgavX] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_sgavX; } in
        let {
          sat_sgawa [Occ=OnceT[0]]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag423 -> a_ag423
          [LclId] =
              [$dFoldable_sgavV
               $dFoldable1_sgavW
               $dOrd_sgavX
               $dMonoid_sgavY] \r [x_sgavZ]
                  case x_sgavZ of {
                    Data.Functor.Product.Pair x1_sgaw1 [Occ=Once*]
                                              y_sgaw2 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sgavW $dMonoid_sgavY GHC.Base.Just y_sgaw2
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sgavV $dMonoid_sgavY GHC.Base.Just x1_sgaw1
                              of
                              { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct3;
                                GHC.Base.Just v_sgaw5 [Occ=Once] -> v_sgaw5;
                              };
                          GHC.Base.Just ipv_sgaw6 ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_sgavV $dMonoid_sgavY GHC.Base.Just x1_sgaw1
                              of
                              { GHC.Base.Nothing -> ipv_sgaw6;
                                GHC.Base.Just x2_sgaw8 ->
                                    case GHC.Classes.>= $dOrd_sgavX x2_sgaw8 ipv_sgaw6 of {
                                      GHC.Types.False -> ipv_sgaw6;
                                      GHC.Types.True -> x2_sgaw8;
                                    };
                              };
                        };
                  };
        } in  sat_sgawa;

Data.Functor.Product.$fFoldableProduct_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgawb $dFoldable1_sgawc $dEq_sgawd eta_sgawe]
        let {
          f1_sgawf :: a_ag41T -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgawd eta_sgawe] \u []
                  GHC.Classes.== $dEq_sgawd eta_sgawe; } in
        let {
          sat_sgawl [Occ=Once]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag41T
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_sgawb $dFoldable1_sgawc f1_sgawf] \r [ds_sgawg]
                  case ds_sgawg of {
                    Data.Functor.Product.Pair x_sgawi [Occ=Once] y_sgawj [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_sgawb
                                Data.Semigroup.Internal.$fMonoidAny
                                f1_sgawf
                                x_sgawi
                        of
                        { GHC.Types.False ->
                              Data.Foldable.foldMap
                                  $dFoldable1_sgawc
                                  Data.Semigroup.Internal.$fMonoidAny
                                  f1_sgawf
                                  y_sgawj;
                          GHC.Types.True -> GHC.Types.True [];
                        };
                  };
        } in  sat_sgawl;

Data.Functor.Product.$fFoldableProduct8
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Functor.Product.$w$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgawm w1_sgawn w2_sgawo w3_sgawp ww_sgawq ww1_sgawr]
        let {
          f1_sgaws :: a_sg4T4 -> b_sg4T3 -> b_sg4T3
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [w2_sgawo] \r [x_sgawt y_sgawu] w2_sgawo y_sgawu x_sgawt; } in
        let {
          sat_sgawv [Occ=Once] :: b_sg4T3
          [LclId] =
              [w_sgawm w3_sgawp ww_sgawq f1_sgaws] \u []
                  Data.Foldable.foldMap
                      w_sgawm
                      Data.Functor.Product.$fFoldableProduct8
                      f1_sgaws
                      ww_sgawq
                      w3_sgawp;
        } in 
          Data.Foldable.foldMap
              w1_sgawn
              Data.Functor.Product.$fFoldableProduct8
              f1_sgaws
              ww1_sgawr
              sat_sgawv;

Data.Functor.Product.$fFoldableProduct_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaww w1_sgawx w2_sgawy w3_sgawz w4_sgawA]
        case w4_sgawA of {
          Data.Functor.Product.Pair ww1_sgawC [Occ=Once]
                                    ww2_sgawD [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl
                  w_sgaww w1_sgawx w2_sgawy w3_sgawz ww1_sgawC ww2_sgawD;
        };

lvl2_rg5nY :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Functor.Product.$fFoldableProduct7 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rg5nY of sat_sgawE {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgawE;
        };

Data.Functor.Product.$w$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgawF w1_sgawG w2_sgawH ww_sgawI ww1_sgawJ]
        let {
          f1_sgawK
            :: a_sg4Ti -> GHC.Base.Maybe a_sg4Ti -> GHC.Base.Maybe a_sg4Ti
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_sgawH] \r [x_sgawL y_sgawM]
                  let {
                    sat_sgawP [Occ=Once] :: a_sg4Ti
                    [LclId] =
                        [w2_sgawH x_sgawL y_sgawM] \u []
                            case y_sgawM of {
                              GHC.Base.Nothing -> x_sgawL;
                              GHC.Base.Just x1_sgawO [Occ=Once] -> w2_sgawH x1_sgawO x_sgawL;
                            };
                  } in  GHC.Base.Just [sat_sgawP]; } in
        let {
          sat_sgawQ [Occ=Once] :: GHC.Base.Maybe a_sg4Ti
          [LclId] =
              [w_sgawF ww_sgawI f1_sgawK] \u []
                  Data.Foldable.foldMap
                      w_sgawF
                      Data.Functor.Product.$fFoldableProduct8
                      f1_sgawK
                      ww_sgawI
                      GHC.Base.Nothing;
        } in 
          case
              Data.Foldable.foldMap
                  w1_sgawG
                  Data.Functor.Product.$fFoldableProduct8
                  f1_sgawK
                  ww1_sgawJ
                  sat_sgawQ
          of
          { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct7;
            GHC.Base.Just v_sgawS [Occ=Once] -> v_sgawS;
          };

Data.Functor.Product.$fFoldableProduct_$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgawT w1_sgawU w2_sgawV w3_sgawW]
        case w3_sgawW of {
          Data.Functor.Product.Pair ww1_sgawY [Occ=Once]
                                    ww2_sgawZ [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl1
                  w_sgawT w1_sgawU w2_sgawV ww1_sgawY ww2_sgawZ;
        };

Data.Functor.Product.$w$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgax0 w1_sgax1 w2_sgax2 w3_sgax3 ww_sgax4 ww1_sgax5]
        let {
          f1_sgax6 :: a_sg4Tv -> (b_sg4Tw -> b_sg4Tw) -> b_sg4Tw -> b_sg4Tw
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_sgax2] \r [x_sgax7 y_sgax8 z_sgax9]
                  case w2_sgax2 x_sgax7 z_sgax9 of vx_sgaxa {
                    __DEFAULT -> y_sgax8 vx_sgaxa;
                  }; } in
        let {
          sat_sgaxb [Occ=Once] :: b_sg4Tw -> b_sg4Tw
          [LclId] =
              [w_sgax0 ww_sgax4 f1_sgax6] \u []
                  Data.Foldable.foldMap
                      w_sgax0
                      Data.Functor.Product.$fFoldableProduct8
                      f1_sgax6
                      ww_sgax4
                      GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              w1_sgax1
              Data.Functor.Product.$fFoldableProduct8
              f1_sgax6
              ww1_sgax5
              sat_sgaxb
              w3_sgax3;

Data.Functor.Product.$fFoldableProduct_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaxc w1_sgaxd w2_sgaxe w3_sgaxf w4_sgaxg]
        case w4_sgaxg of {
          Data.Functor.Product.Pair ww1_sgaxi [Occ=Once]
                                    ww2_sgaxj [Occ=Once] ->
              Data.Functor.Product.$w$cfoldr'
                  w_sgaxc w1_sgaxd w2_sgaxe w3_sgaxf ww1_sgaxi ww2_sgaxj;
        };

Data.Functor.Product.$w$cfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaxk w1_sgaxl w2_sgaxm w3_sgaxn ww_sgaxo ww1_sgaxp]
        let {
          sat_sgaxq [Occ=Once] :: b_sg4TL
          [LclId] =
              [w1_sgaxl w2_sgaxm w3_sgaxn ww1_sgaxp] \u []
                  Data.Foldable.foldMap
                      w1_sgaxl
                      Data.Semigroup.Internal.$fMonoidEndo
                      w2_sgaxm
                      ww1_sgaxp
                      w3_sgaxn;
        } in 
          Data.Foldable.foldMap
              w_sgaxk
              Data.Semigroup.Internal.$fMonoidEndo
              w2_sgaxm
              ww_sgaxo
              sat_sgaxq;

Data.Functor.Product.$fFoldableProduct_$cfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaxr w1_sgaxs w2_sgaxt w3_sgaxu w4_sgaxv]
        case w4_sgaxv of {
          Data.Functor.Product.Pair ww1_sgaxx [Occ=Once]
                                    ww2_sgaxy [Occ=Once] ->
              Data.Functor.Product.$w$cfoldr
                  w_sgaxr w1_sgaxs w2_sgaxt w3_sgaxu ww1_sgaxx ww2_sgaxy;
        };

Data.Functor.Product.$w$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaxz w1_sgaxA w2_sgaxB w3_sgaxC ww_sgaxD ww1_sgaxE]
        let {
          f1_sgaxF :: a_sg4U0 -> (b_sg4TZ -> b_sg4TZ) -> b_sg4TZ -> b_sg4TZ
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_sgaxB] \r [x_sgaxG k_sgaxH z_sgaxI]
                  case w2_sgaxB z_sgaxI x_sgaxG of vx_sgaxJ {
                    __DEFAULT -> k_sgaxH vx_sgaxJ;
                  }; } in
        let {
          sat_sgaxK [Occ=Once] :: b_sg4TZ -> b_sg4TZ
          [LclId] =
              [w1_sgaxA ww1_sgaxE f1_sgaxF] \u []
                  Data.Foldable.foldMap
                      w1_sgaxA
                      Data.Semigroup.Internal.$fMonoidEndo
                      f1_sgaxF
                      ww1_sgaxE
                      GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              w_sgaxz
              Data.Semigroup.Internal.$fMonoidEndo
              f1_sgaxF
              ww_sgaxD
              sat_sgaxK
              w3_sgaxC;

Data.Functor.Product.$fFoldableProduct_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Product.Product f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaxL w1_sgaxM w2_sgaxN w3_sgaxO w4_sgaxP]
        case w4_sgaxP of {
          Data.Functor.Product.Pair ww1_sgaxR [Occ=Once]
                                    ww2_sgaxS [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl'
                  w_sgaxL w1_sgaxM w2_sgaxN w3_sgaxO ww1_sgaxR ww2_sgaxS;
        };

Data.Functor.Product.$fFoldableProduct5
  :: forall a. GHC.Types.Int -> a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,A>m,
 Unf=OtherCon []] =
    [] \r [c_sgaxT ds_sgaxU]
        case c_sgaxT of {
          GHC.Types.I# x_sgaxW [Occ=Once] ->
              case +# [x_sgaxW 1#] of sat_sgaxX {
                __DEFAULT -> GHC.Types.I# [sat_sgaxX];
              };
        };

Data.Functor.Product.$fFoldableProduct_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Product.Product f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgaxY $dFoldable1_sgaxZ eta_sgay0]
        case eta_sgay0 of {
          Data.Functor.Product.Pair ww1_sgay2 [Occ=Once]
                                    ww2_sgay3 [Occ=Once] ->
              Data.Functor.Product.$w$cfoldl'
                  $dFoldable_sgaxY
                  $dFoldable1_sgaxZ
                  Data.Functor.Product.$fFoldableProduct5
                  Data.Functor.Product.$fFoldableProduct4
                  ww1_sgay2
                  ww2_sgay3;
        };

lvl3_rg5nZ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Functor.Product.$fFoldableProduct9 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_rg5nZ of sat_sgay4 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgay4;
        };

Data.Functor.Product.$w$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgay5 w1_sgay6 w2_sgay7 ww_sgay8 ww1_sgay9]
        let {
          w3_sgaya
            :: a_sg4Ue -> GHC.Base.Maybe a_sg4Ue -> GHC.Base.Maybe a_sg4Ue
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_sgay7] \r [x_sgayb m_sgayc]
                  let {
                    sat_sgayf [Occ=Once] :: a_sg4Ue
                    [LclId] =
                        [w2_sgay7 x_sgayb m_sgayc] \u []
                            case m_sgayc of {
                              GHC.Base.Nothing -> x_sgayb;
                              GHC.Base.Just y_sgaye [Occ=Once] -> w2_sgay7 x_sgayb y_sgaye;
                            };
                  } in  GHC.Base.Just [sat_sgayf]; } in
        let {
          sat_sgayg [Occ=Once] :: GHC.Base.Maybe a_sg4Ue
          [LclId] =
              [w1_sgay6 ww1_sgay9 w3_sgaya] \u []
                  Data.Foldable.foldMap
                      w1_sgay6
                      Data.Semigroup.Internal.$fMonoidEndo
                      w3_sgaya
                      ww1_sgay9
                      GHC.Base.Nothing;
        } in 
          case
              Data.Foldable.foldMap
                  w_sgay5
                  Data.Semigroup.Internal.$fMonoidEndo
                  w3_sgaya
                  ww_sgay8
                  sat_sgayg
          of
          { GHC.Base.Nothing -> Data.Functor.Product.$fFoldableProduct9;
            GHC.Base.Just v_sgayi [Occ=Once] -> v_sgayi;
          };

Data.Functor.Product.$fFoldableProduct_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgayj w1_sgayk w2_sgayl w3_sgaym]
        case w3_sgaym of {
          Data.Functor.Product.Pair ww1_sgayo [Occ=Once]
                                    ww2_sgayp [Occ=Once] ->
              Data.Functor.Product.$w$cfoldr1
                  w_sgayj w1_sgayk w2_sgayl ww1_sgayo ww2_sgayp;
        };

Data.Functor.Product.$fFoldableProduct6
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgayq ds1_sgayr] GHC.Types.False [];

Data.Functor.Product.$fFoldableProduct_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Product.Product f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgays $dFoldable1_sgayt eta_sgayu]
        case eta_sgayu of {
          Data.Functor.Product.Pair ww1_sgayw [Occ=Once]
                                    ww2_sgayx [Occ=Once] ->
              let {
                sat_sgayy [Occ=Once] :: GHC.Types.Bool
                [LclId] =
                    [$dFoldable1_sgayt ww2_sgayx] \u []
                        Data.Foldable.foldMap
                            $dFoldable1_sgayt
                            Data.Semigroup.Internal.$fMonoidEndo
                            Data.Functor.Product.$fFoldableProduct6
                            ww2_sgayx
                            GHC.Types.True;
              } in 
                Data.Foldable.foldMap
                    $dFoldable_sgays
                    Data.Semigroup.Internal.$fMonoidEndo
                    Data.Functor.Product.$fFoldableProduct6
                    ww1_sgayw
                    sat_sgayy;
        };

Data.Functor.Product.$fFoldableProduct_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Product.Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgayz $dFoldable1_sgayA $dNum_sgayB]
        let {
          $dMonoid_sgayC
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_ag42x)
          [LclId] =
              [$dNum_sgayB] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sgayB; } in
        let {
          sat_sgayJ [Occ=Once]
            :: Data.Functor.Product.Product f_ag400 g_ag401 a_ag42x
               -> Data.Semigroup.Internal.Product a_ag42x
          [LclId] =
              [$dFoldable_sgayz
               $dFoldable1_sgayA
               $dNum_sgayB
               $dMonoid_sgayC] \r [ds_sgayD]
                  case ds_sgayD of {
                    Data.Functor.Product.Pair x_sgayF [Occ=Once] y_sgayG [Occ=Once] ->
                        let {
                          sat_sgayI [Occ=Once] :: a_ag42x
                          [LclId] =
                              [$dFoldable1_sgayA $dMonoid_sgayC y_sgayG] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_sgayA
                                      $dMonoid_sgayC
                                      Data.Functor.Product.$fFoldableProduct1
                                      y_sgayG; } in
                        let {
                          sat_sgayH [Occ=Once] :: a_ag42x
                          [LclId] =
                              [$dFoldable_sgayz $dMonoid_sgayC x_sgayF] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_sgayz
                                      $dMonoid_sgayC
                                      Data.Functor.Product.$fFoldableProduct1
                                      x_sgayF;
                        } in  GHC.Num.* $dNum_sgayB sat_sgayH sat_sgayI;
                  };
        } in  sat_sgayJ;

Data.Functor.Product.$fFoldableProduct_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Product.Product f g a -> [a]
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgayK $dFoldable1_sgayL eta_sgayM]
        case eta_sgayM of {
          Data.Functor.Product.Pair ww1_sgayO [Occ=Once]
                                    ww2_sgayP [Occ=Once] ->
              let {
                sat_sgayQ [Occ=Once] :: [a_ag41v]
                [LclId] =
                    [$dFoldable1_sgayL ww2_sgayP] \u []
                        Data.Foldable.foldMap
                            $dFoldable1_sgayL
                            Data.Semigroup.Internal.$fMonoidEndo
                            GHC.Types.:
                            ww2_sgayP
                            GHC.Types.[];
              } in 
                Data.Foldable.foldMap
                    $dFoldable_sgayK
                    Data.Semigroup.Internal.$fMonoidEndo
                    GHC.Types.:
                    ww1_sgayO
                    sat_sgayQ;
        };

Data.Functor.Product.$fFoldableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_sgayR $dFoldable1_sgayS]
        let {
          sat_sgaz8 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cproduct
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz7 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$csum
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz6 [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cminimum
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz5 [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cmaximum
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz4 [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a
               -> Data.Functor.Product.Product f_ag400 g_ag401 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$celem
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B2 eta_B1; } in
        let {
          sat_sgaz3 [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag400 g_ag401 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$clength
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz2 [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag400 g_ag401 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cnull
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz1 [Occ=Once]
            :: forall a. Data.Functor.Product.Product f_ag400 g_ag401 a -> [a]
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$ctoList
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B1; } in
        let {
          sat_sgaz0 [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldl1
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B2 eta_B1; } in
        let {
          sat_sgayZ [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Product.Product f_ag400 g_ag401 a -> a
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldr1
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B2 eta_B1; } in
        let {
          sat_sgayY [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldl'
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgayX [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldl
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgayW [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldr'
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgayV [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Product.Product f_ag400 g_ag401 a -> b
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldr
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgayU [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> Data.Functor.Product.Product f_ag400 g_ag401 a -> m
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfoldMap
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgayT [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               Data.Functor.Product.Product f_ag400 g_ag401 m -> m
          [LclId] =
              [$dFoldable_sgayR $dFoldable1_sgayS] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fFoldableProduct_$cfold
                      $dFoldable_sgayR $dFoldable1_sgayS eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_sgayT
                                    sat_sgayU
                                    sat_sgayV
                                    sat_sgayW
                                    sat_sgayX
                                    sat_sgayY
                                    sat_sgayZ
                                    sat_sgaz0
                                    sat_sgaz1
                                    sat_sgaz2
                                    sat_sgaz3
                                    sat_sgaz4
                                    sat_sgaz5
                                    sat_sgaz6
                                    sat_sgaz7
                                    sat_sgaz8];

Data.Functor.Product.$w$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> f a -> g a -> f1 (Data.Functor.Product.Product f g b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaz9 w1_sgaza w2_sgazb w3_sgazc ww_sgazd ww1_sgaze]
        let {
          sat_sgazg [Occ=Once] :: f1_sg4Ux (g_sg4Uu b_sg4Uz)
          [LclId] =
              [w1_sgaza w2_sgazb w3_sgazc ww1_sgaze] \u []
                  Data.Traversable.traverse
                      w1_sgaza w2_sgazb w3_sgazc ww1_sgaze; } in
        let {
          sat_sgazf [Occ=Once] :: f1_sg4Ux (f_sg4Ut b_sg4Uz)
          [LclId] =
              [w_sgaz9 w2_sgazb w3_sgazc ww_sgazd] \u []
                  Data.Traversable.traverse w_sgaz9 w2_sgazb w3_sgazc ww_sgazd;
        } in 
          GHC.Base.liftA2
              w2_sgazb Data.Functor.Product.Pair sat_sgazf sat_sgazg;

Data.Functor.Product.$fTraversableProduct_$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> Data.Functor.Product.Product f g a
     -> f1 (Data.Functor.Product.Product f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgazh w1_sgazi w2_sgazj w3_sgazk w4_sgazl]
        case w4_sgazl of {
          Data.Functor.Product.Pair ww1_sgazn [Occ=Once]
                                    ww2_sgazo [Occ=Once] ->
              Data.Functor.Product.$w$ctraverse
                  w_sgazh w1_sgazi w2_sgazj w3_sgazk ww1_sgazn ww2_sgazo;
        };

Data.Functor.Product.$fTraversableProduct_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgazp $dTraversable1_sgazq]
        let {
          sat_sgazs [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_ag3YH
          [LclId] =
              [$dTraversable1_sgazq] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sgazq; } in
        let {
          sat_sgazr [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_ag3YG
          [LclId] =
              [$dTraversable_sgazp] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sgazp;
        } in  Data.Functor.Product.$fFoldableProduct sat_sgazr sat_sgazs;

Data.Functor.Product.$fTraversableProduct_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgazt $dTraversable1_sgazu]
        let {
          sat_sgazw [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor g_ag3YH
          [LclId] =
              [$dTraversable1_sgazu] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sgazu; } in
        let {
          sat_sgazv [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_ag3YG
          [LclId] =
              [$dTraversable_sgazt] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sgazt;
        } in  Data.Functor.Product.$fFunctorProduct sat_sgazv sat_sgazw;

Data.Functor.Product.$fTraversableProduct_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     Data.Functor.Product.Product f g (f1 a)
     -> f1 (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgazx
           $dTraversable1_sgazy
           $dApplicative_sgazz
           w_sgazA]
        case w_sgazA of {
          Data.Functor.Product.Pair ww1_sgazC [Occ=Once]
                                    ww2_sgazD [Occ=Once] ->
              Data.Functor.Product.$w$ctraverse
                  $dTraversable_sgazx
                  $dTraversable1_sgazy
                  $dApplicative_sgazz
                  GHC.Base.id
                  ww1_sgazC
                  ww2_sgazD;
        };

Data.Functor.Product.$fTraversableProduct_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgazE
           $dTraversable1_sgazF
           $dMonad_sgazG
           eta_sgazH
           eta1_sgazI]
        case eta1_sgazI of {
          Data.Functor.Product.Pair ww1_sgazK [Occ=Once]
                                    ww2_sgazL [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sgazG of sat_sgazM {
                __DEFAULT ->
                    Data.Functor.Product.$w$ctraverse
                        $dTraversable_sgazE
                        $dTraversable1_sgazF
                        sat_sgazM
                        eta_sgazH
                        ww1_sgazK
                        ww2_sgazL;
              };
        };

Data.Functor.Product.$fTraversableProduct_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Product.Product f g (m a)
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgazN
           $dTraversable1_sgazO
           $dMonad_sgazP
           eta_sgazQ]
        case eta_sgazQ of {
          Data.Functor.Product.Pair ww1_sgazS [Occ=Once]
                                    ww2_sgazT [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sgazP of sat_sgazU {
                __DEFAULT ->
                    Data.Functor.Product.$w$ctraverse
                        $dTraversable_sgazN
                        $dTraversable1_sgazO
                        sat_sgazU
                        GHC.Base.id
                        ww1_sgazS
                        ww2_sgazT;
              };
        };

Data.Functor.Product.$fTraversableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sgazV $dTraversable1_sgazW]
        let {
          sat_sgaA2 [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               Data.Functor.Product.Product f_ag3YG g_ag3YH (m a)
               -> m (Data.Functor.Product.Product f_ag3YG g_ag3YH a)
          [LclId] =
              [$dTraversable_sgazV $dTraversable1_sgazW] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$csequence
                      $dTraversable_sgazV $dTraversable1_sgazW eta_B2 eta_B1; } in
        let {
          sat_sgaA1 [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> Data.Functor.Product.Product f_ag3YG g_ag3YH a
               -> m (Data.Functor.Product.Product f_ag3YG g_ag3YH b)
          [LclId] =
              [$dTraversable_sgazV $dTraversable1_sgazW] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$cmapM
                      $dTraversable_sgazV $dTraversable1_sgazW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgaA0 [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               Data.Functor.Product.Product f_ag3YG g_ag3YH (f a)
               -> f (Data.Functor.Product.Product f_ag3YG g_ag3YH a)
          [LclId] =
              [$dTraversable_sgazV $dTraversable1_sgazW] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$csequenceA
                      $dTraversable_sgazV $dTraversable1_sgazW eta_B2 eta_B1; } in
        let {
          sat_sgazZ [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> Data.Functor.Product.Product f_ag3YG g_ag3YH a
               -> f (Data.Functor.Product.Product f_ag3YG g_ag3YH b)
          [LclId] =
              [$dTraversable_sgazV $dTraversable1_sgazW] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Product.$fTraversableProduct_$ctraverse
                      $dTraversable_sgazV $dTraversable1_sgazW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgazY [Occ=Once]
            :: Data.Foldable.Foldable
                 (Data.Functor.Product.Product f_ag3YG g_ag3YH)
          [LclId] =
              [$dTraversable_sgazV $dTraversable1_sgazW] \u []
                  Data.Functor.Product.$fTraversableProduct_$cp2Traversable
                      $dTraversable_sgazV $dTraversable1_sgazW; } in
        let {
          sat_sgazX [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Product.Product f_ag3YG g_ag3YH)
          [LclId] =
              [$dTraversable_sgazV $dTraversable1_sgazW] \u []
                  Data.Functor.Product.$fTraversableProduct_$cp1Traversable
                      $dTraversable_sgazV $dTraversable1_sgazW;
        } in 
          Data.Traversable.C:Traversable [sat_sgazX
                                          sat_sgazY
                                          sat_sgazZ
                                          sat_sgaA0
                                          sat_sgaA1
                                          sat_sgaA2];

Data.Functor.Product.$fApplicativeProduct_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b c.
     (a -> b -> c)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgaA3 w1_sgaA4 w2_sgaA5 w3_sgaA6 w4_sgaA7]
        case w3_sgaA6 of {
          Data.Functor.Product.Pair ww1_sgaA9 [Occ=Once]
                                    ww2_sgaAa [Occ=Once] ->
              case w4_sgaA7 of {
                Data.Functor.Product.Pair ww4_sgaAc [Occ=Once]
                                          ww5_sgaAd [Occ=Once] ->
                    let {
                      sat_sgaAf [Occ=Once] :: g_sg4UK c_sg4UP
                      [LclId] =
                          [w1_sgaA4 w2_sgaA5 ww2_sgaAa ww5_sgaAd] \u []
                              GHC.Base.liftA2 w1_sgaA4 w2_sgaA5 ww2_sgaAa ww5_sgaAd; } in
                    let {
                      sat_sgaAe [Occ=Once] :: f_sg4UJ c_sg4UP
                      [LclId] =
                          [w_sgaA3 w2_sgaA5 ww1_sgaA9 ww4_sgaAc] \u []
                              GHC.Base.liftA2 w_sgaA3 w2_sgaA5 ww1_sgaA9 ww4_sgaAc;
                    } in  Data.Functor.Product.Pair [sat_sgaAe sat_sgaAf];
              };
        };

Data.Functor.Product.$fApplicativeProduct_$c<*>
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Product.Product f g (a -> b)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgaAg $dApplicative1_sgaAh ds_sgaAi ds1_sgaAj]
        case ds_sgaAi of {
          Data.Functor.Product.Pair f1_sgaAl [Occ=Once]
                                    g1_sgaAm [Occ=Once] ->
              case ds1_sgaAj of {
                Data.Functor.Product.Pair x_sgaAo [Occ=Once] y_sgaAp [Occ=Once] ->
                    let {
                      sat_sgaAr [Occ=Once] :: g_ag3Xi b_ag3XJ
                      [LclId] =
                          [$dApplicative1_sgaAh g1_sgaAm y_sgaAp] \u []
                              GHC.Base.<*> $dApplicative1_sgaAh g1_sgaAm y_sgaAp; } in
                    let {
                      sat_sgaAq [Occ=Once] :: f_ag3Xh b_ag3XJ
                      [LclId] =
                          [$dApplicative_sgaAg f1_sgaAl x_sgaAo] \u []
                              GHC.Base.<*> $dApplicative_sgaAg f1_sgaAl x_sgaAo;
                    } in  Data.Functor.Product.Pair [sat_sgaAq sat_sgaAr];
              };
        };

Data.Functor.Product.$fApplicativeProduct_$cpure
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a. a -> Data.Functor.Product.Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U),A,A,A,A)><L,1*U(A,1*C1(U),A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgaAs $dApplicative1_sgaAt x_sgaAu]
        let {
          sat_sgaAw [Occ=Once] :: g_ag3Xi a_ag3Xs
          [LclId] =
              [$dApplicative1_sgaAt x_sgaAu] \u []
                  GHC.Base.pure $dApplicative1_sgaAt x_sgaAu; } in
        let {
          sat_sgaAv [Occ=Once] :: f_ag3Xh a_ag3Xs
          [LclId] =
              [$dApplicative_sgaAs x_sgaAu] \u []
                  GHC.Base.pure $dApplicative_sgaAs x_sgaAu;
        } in  Data.Functor.Product.Pair [sat_sgaAv sat_sgaAw];

Data.Functor.Product.$fApplicativeProduct_$cp1Applicative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Functor (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgaAx $dApplicative1_sgaAy]
        let {
          sat_sgaAA [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor g_ag3Xi
          [LclId] =
              [$dApplicative1_sgaAy] \u []
                  GHC.Base.$p1Applicative $dApplicative1_sgaAy; } in
        let {
          sat_sgaAz [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_ag3Xh
          [LclId] =
              [$dApplicative_sgaAx] \u []
                  GHC.Base.$p1Applicative $dApplicative_sgaAx;
        } in  Data.Functor.Product.$fFunctorProduct sat_sgaAz sat_sgaAA;

Data.Functor.Product.$fApplicativeProduct1
  :: forall a b. a -> b -> b
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgaAB eta_B1] GHC.Base.breakpoint eta_B1;

Data.Functor.Product.$w$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b. f a -> g a -> f b -> g b -> (# f b, g b #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaAC w1_sgaAD ww_sgaAE ww1_sgaAF ww2_sgaAG ww3_sgaAH]
        let {
          sat_sgaAN [Occ=Once] :: g_sg4V8 b_sg4Vc
          [LclId] =
              [w1_sgaAD ww1_sgaAF ww3_sgaAH] \u []
                  let {
                    sat_sgaAM [Occ=Once] :: g_sg4V8 (b_sg4Vc -> b_sg4Vc)
                    [LclId] =
                        [w1_sgaAD ww1_sgaAF] \u []
                            case GHC.Base.$p1Applicative w1_sgaAD of sat_sgaAL {
                              __DEFAULT ->
                                  GHC.Base.fmap
                                      sat_sgaAL
                                      Data.Functor.Product.$fApplicativeProduct1
                                      ww1_sgaAF;
                            };
                  } in  GHC.Base.<*> w1_sgaAD sat_sgaAM ww3_sgaAH; } in
        let {
          sat_sgaAK [Occ=Once] :: f_sg4V7 b_sg4Vc
          [LclId] =
              [w_sgaAC ww_sgaAE ww2_sgaAG] \u []
                  let {
                    sat_sgaAJ [Occ=Once] :: f_sg4V7 (b_sg4Vc -> b_sg4Vc)
                    [LclId] =
                        [w_sgaAC ww_sgaAE] \u []
                            case GHC.Base.$p1Applicative w_sgaAC of sat_sgaAI {
                              __DEFAULT ->
                                  GHC.Base.fmap
                                      sat_sgaAI Data.Functor.Product.$fApplicativeProduct1 ww_sgaAE;
                            };
                  } in  GHC.Base.<*> w_sgaAC sat_sgaAJ ww2_sgaAG;
        } in  (#,#) [sat_sgaAK sat_sgaAN];

Data.Functor.Product.$fApplicativeProduct_$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgaAO w1_sgaAP w2_sgaAQ w3_sgaAR]
        case w2_sgaAQ of {
          Data.Functor.Product.Pair ww1_sgaAT [Occ=Once]
                                    ww2_sgaAU [Occ=Once] ->
              case w3_sgaAR of {
                Data.Functor.Product.Pair ww4_sgaAW [Occ=Once]
                                          ww5_sgaAX [Occ=Once] ->
                    case
                        Data.Functor.Product.$w$c*>
                            w_sgaAO w1_sgaAP ww1_sgaAT ww2_sgaAU ww4_sgaAW ww5_sgaAX
                    of
                    { (#,#) ww7_sgaAZ [Occ=Once] ww8_sgaB0 [Occ=Once] ->
                          Data.Functor.Product.Pair [ww7_sgaAZ ww8_sgaB0];
                    };
              };
        };

Data.Functor.Product.$fApplicativeProduct_$c<*
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgaB1 $dApplicative1_sgaB2 w_sgaB3 w1_sgaB4]
        case w_sgaB3 of {
          Data.Functor.Product.Pair ww1_sgaB6 [Occ=Once]
                                    ww2_sgaB7 [Occ=Once] ->
              case w1_sgaB4 of {
                Data.Functor.Product.Pair ww4_sgaB9 [Occ=Once]
                                          ww5_sgaBa [Occ=Once] ->
                    let {
                      sat_sgaBc [Occ=Once] :: g_ag3Xi a_ag3Yx
                      [LclId] =
                          [$dApplicative1_sgaB2 ww2_sgaB7 ww5_sgaBa] \u []
                              GHC.Base.liftA2
                                  $dApplicative1_sgaB2 GHC.Base.const ww2_sgaB7 ww5_sgaBa; } in
                    let {
                      sat_sgaBb [Occ=Once] :: f_ag3Xh a_ag3Yx
                      [LclId] =
                          [$dApplicative_sgaB1 ww1_sgaB6 ww4_sgaB9] \u []
                              GHC.Base.liftA2
                                  $dApplicative_sgaB1 GHC.Base.const ww1_sgaB6 ww4_sgaB9;
                    } in  Data.Functor.Product.Pair [sat_sgaBb sat_sgaBc];
              };
        };

Data.Functor.Product.$fApplicativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Applicative (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)><L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>m] =
    [] \r [$dApplicative_sgaBd $dApplicative1_sgaBe]
        let {
          sat_sgaBk [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
          [LclId] =
              [$dApplicative_sgaBd $dApplicative1_sgaBe] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$c<*
                      $dApplicative_sgaBd $dApplicative1_sgaBe eta_B2 eta_B1; } in
        let {
          sat_sgaBj [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
          [LclId] =
              [$dApplicative_sgaBd $dApplicative1_sgaBe] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$c*>
                      $dApplicative_sgaBd $dApplicative1_sgaBe eta_B2 eta_B1; } in
        let {
          sat_sgaBi [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi c
          [LclId] =
              [$dApplicative_sgaBd $dApplicative1_sgaBe] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$cliftA2
                      $dApplicative_sgaBd $dApplicative1_sgaBe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgaBh [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Xh g_ag3Xi (a -> b)
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
               -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi b
          [LclId] =
              [$dApplicative_sgaBd $dApplicative1_sgaBe] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$c<*>
                      $dApplicative_sgaBd $dApplicative1_sgaBe eta_B2 eta_B1; } in
        let {
          sat_sgaBg [Occ=Once]
            :: forall a. a -> Data.Functor.Product.Product f_ag3Xh g_ag3Xi a
          [LclId] =
              [$dApplicative_sgaBd $dApplicative1_sgaBe] \r [eta_B1]
                  Data.Functor.Product.$fApplicativeProduct_$cpure
                      $dApplicative_sgaBd $dApplicative1_sgaBe eta_B1; } in
        let {
          sat_sgaBf [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Product.Product f_ag3Xh g_ag3Xi)
          [LclId] =
              [$dApplicative_sgaBd $dApplicative1_sgaBe] \u []
                  Data.Functor.Product.$fApplicativeProduct_$cp1Applicative
                      $dApplicative_sgaBd $dApplicative1_sgaBe;
        } in 
          GHC.Base.C:Applicative [sat_sgaBf
                                  sat_sgaBg
                                  sat_sgaBh
                                  sat_sgaBi
                                  sat_sgaBj
                                  sat_sgaBk];

Data.Functor.Product.$fAlternativeProduct_$c<|>
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     forall a.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A)><L,1*U(A,A,1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgaBl $dAlternative1_sgaBm ds_sgaBn ds1_sgaBo]
        case ds_sgaBn of {
          Data.Functor.Product.Pair x1_sgaBq [Occ=Once]
                                    y1_sgaBr [Occ=Once] ->
              case ds1_sgaBo of {
                Data.Functor.Product.Pair x2_sgaBt [Occ=Once]
                                          y2_sgaBu [Occ=Once] ->
                    let {
                      sat_sgaBw [Occ=Once] :: g_ag3Wm a_ag3WM
                      [LclId] =
                          [$dAlternative1_sgaBm y1_sgaBr y2_sgaBu] \u []
                              GHC.Base.<|> $dAlternative1_sgaBm y1_sgaBr y2_sgaBu; } in
                    let {
                      sat_sgaBv [Occ=Once] :: f_ag3Wl a_ag3WM
                      [LclId] =
                          [$dAlternative_sgaBl x1_sgaBq x2_sgaBt] \u []
                              GHC.Base.<|> $dAlternative_sgaBl x1_sgaBq x2_sgaBt;
                    } in  Data.Functor.Product.Pair [sat_sgaBv sat_sgaBw];
              };
        };

Data.Functor.Product.$fAlternativeProduct_$cempty
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     forall a. Data.Functor.Product.Product f g a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A,A)><L,1*U(A,1*U,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgaBx $dAlternative1_sgaBy]
        let {
          sat_sgaBA [Occ=Once] :: g_ag3Wm a_ag3Ww
          [LclId] =
              [$dAlternative1_sgaBy] \u []
                  GHC.Base.empty $dAlternative1_sgaBy; } in
        let {
          sat_sgaBz [Occ=Once] :: f_ag3Wl a_ag3Ww
          [LclId] =
              [$dAlternative_sgaBx] \u [] GHC.Base.empty $dAlternative_sgaBx;
        } in  Data.Functor.Product.Pair [sat_sgaBz sat_sgaBA];

Data.Functor.Product.$fAlternativeProduct_$cp1Alternative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     GHC.Base.Applicative (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)><L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgaBB $dAlternative1_sgaBC]
        let {
          sat_sgaBE [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative g_ag3Wm
          [LclId] =
              [$dAlternative1_sgaBC] \u []
                  GHC.Base.$p1Alternative $dAlternative1_sgaBC; } in
        let {
          sat_sgaBD [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative f_ag3Wl
          [LclId] =
              [$dAlternative_sgaBB] \u []
                  GHC.Base.$p1Alternative $dAlternative_sgaBB;
        } in 
          Data.Functor.Product.$fApplicativeProduct sat_sgaBD sat_sgaBE;

poly_some_v_rg5o0
  :: forall (f :: * -> *) (g :: * -> *) a.
     Data.Functor.Product.Product f g [a]
[GblId, Str=b] =
    [] \u [] poly_some_v_rg5o0;

Data.Functor.Product.$fAlternativeProduct_$csome [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     forall a.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g [a]
[GblId, Arity=3, Str=<B,A><B,A><B,1*H>b, Unf=OtherCon []] =
    [] \r [w_sgaBF w1_sgaBG w2_sgaBH]
        case w2_sgaBH of {
          Data.Functor.Product.Pair _ [Occ=Dead] _ [Occ=Dead] ->
              poly_some_v_rg5o0;
        };

Data.Functor.Product.$fAlternativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Alternative g) =>
     GHC.Base.Alternative (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)><L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>m] =
    [] \r [$dAlternative_sgaBL $dAlternative1_sgaBM]
        let {
          sat_sgaBR [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm [a]
          [LclId] =
              [$dAlternative_sgaBL $dAlternative1_sgaBM] \r [eta_B1]
                  Data.Functor.Product.$fAlternativeProduct_$csome
                      $dAlternative_sgaBL $dAlternative1_sgaBM eta_B1; } in
        let {
          sat_sgaBQ [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm [a]
          [LclId] =
              [$dAlternative_sgaBL $dAlternative1_sgaBM] \r [eta_B1]
                  Data.Functor.Product.$fAlternativeProduct_$csome
                      $dAlternative_sgaBL $dAlternative1_sgaBM eta_B1; } in
        let {
          sat_sgaBP [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
               -> Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
          [LclId] =
              [$dAlternative_sgaBL $dAlternative1_sgaBM] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fAlternativeProduct_$c<|>
                      $dAlternative_sgaBL $dAlternative1_sgaBM eta_B2 eta_B1; } in
        let {
          sat_sgaBO [Occ=Once]
            :: forall a. Data.Functor.Product.Product f_ag3Wl g_ag3Wm a
          [LclId] =
              [$dAlternative_sgaBL $dAlternative1_sgaBM] \u []
                  Data.Functor.Product.$fAlternativeProduct_$cempty
                      $dAlternative_sgaBL $dAlternative1_sgaBM; } in
        let {
          sat_sgaBN [Occ=Once]
            :: GHC.Base.Applicative
                 (Data.Functor.Product.Product f_ag3Wl g_ag3Wm)
          [LclId] =
              [$dAlternative_sgaBL $dAlternative1_sgaBM] \u []
                  Data.Functor.Product.$fAlternativeProduct_$cp1Alternative
                      $dAlternative_sgaBL $dAlternative1_sgaBM;
        } in 
          GHC.Base.C:Alternative [sat_sgaBN
                                  sat_sgaBO
                                  sat_sgaBP
                                  sat_sgaBQ
                                  sat_sgaBR];

Data.Functor.Product.$fMonadProduct_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> (a -> Data.Functor.Product.Product f g b)
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><L,C(U(1*U,1*U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgaBS w1_sgaBT w2_sgaBU w3_sgaBV]
        case w2_sgaBU of {
          Data.Functor.Product.Pair ww1_sgaBX [Occ=Once]
                                    ww2_sgaBY [Occ=Once] ->
              let {
                sat_sgaCa [Occ=Once] :: g_sg4VS b_sg4VW
                [LclId] =
                    [w1_sgaBT w3_sgaBV ww2_sgaBY] \u []
                        let {
                          sat_sgaC9 [Occ=Once] :: a_sg4VV -> g_sg4VS b_sg4VW
                          [LclId] =
                              [w3_sgaBV] \r [x_sgaC5]
                                  case w3_sgaBV x_sgaC5 of {
                                    Data.Functor.Product.Pair _ [Occ=Dead] b1_sgaC8 [Occ=Once] ->
                                        b1_sgaC8;
                                  };
                        } in  GHC.Base.>>= w1_sgaBT ww2_sgaBY sat_sgaC9; } in
              let {
                sat_sgaC4 [Occ=Once] :: f_sg4VR b_sg4VW
                [LclId] =
                    [w_sgaBS w3_sgaBV ww1_sgaBX] \u []
                        let {
                          sat_sgaC3 [Occ=Once] :: a_sg4VV -> f_sg4VR b_sg4VW
                          [LclId] =
                              [w3_sgaBV] \r [x_sgaBZ]
                                  case w3_sgaBV x_sgaBZ of {
                                    Data.Functor.Product.Pair a1_sgaC1 [Occ=Once] _ [Occ=Dead] ->
                                        a1_sgaC1;
                                  };
                        } in  GHC.Base.>>= w_sgaBS ww1_sgaBX sat_sgaC3;
              } in  Data.Functor.Product.Pair [sat_sgaC4 sat_sgaCa];
        };

Data.Functor.Product.$fMonadProduct_$cp1Monad
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     GHC.Base.Applicative (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)><L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgaCb $dMonad1_sgaCc]
        let {
          sat_sgaCe [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative g_ag3Uv
          [LclId] =
              [$dMonad1_sgaCc] \u [] GHC.Base.$p1Monad $dMonad1_sgaCc; } in
        let {
          sat_sgaCd [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative f_ag3Uu
          [LclId] =
              [$dMonad_sgaCb] \u [] GHC.Base.$p1Monad $dMonad_sgaCb;
        } in 
          Data.Functor.Product.$fApplicativeProduct sat_sgaCd sat_sgaCe;

Data.Functor.Product.$fMonadProduct_$creturn [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     forall a. a -> Data.Functor.Product.Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgaCf w1_sgaCg w2_sgaCh]
        let {
          sat_sgaCl [Occ=Once] :: g_sg4W9 a_sg4Wc
          [LclId] =
              [w1_sgaCg w2_sgaCh] \u []
                  case GHC.Base.$p1Monad w1_sgaCg of sat_sgaCk {
                    __DEFAULT -> GHC.Base.pure sat_sgaCk w2_sgaCh;
                  }; } in
        let {
          sat_sgaCj [Occ=Once] :: f_sg4W8 a_sg4Wc
          [LclId] =
              [w_sgaCf w2_sgaCh] \u []
                  case GHC.Base.$p1Monad w_sgaCf of sat_sgaCi {
                    __DEFAULT -> GHC.Base.pure sat_sgaCi w2_sgaCh;
                  };
        } in  Data.Functor.Product.Pair [sat_sgaCj sat_sgaCl];

Data.Functor.Product.$fMonadProduct_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgaCm $dMonad1_sgaCn eta_sgaCo eta1_sgaCp]
        case eta_sgaCo of {
          Data.Functor.Product.Pair m_sgaCr [Occ=Once] n_sgaCs [Occ=Once] ->
              let {
                sat_sgaCE [Occ=Once] :: g_ag3Uv b_ag3VX
                [LclId] =
                    [$dMonad1_sgaCn eta1_sgaCp n_sgaCs] \u []
                        let {
                          sat_sgaCD [Occ=Once] :: a_ag3VW -> g_ag3Uv b_ag3VX
                          [LclId] =
                              [eta1_sgaCp] \r [x_sgaCz]
                                  case eta1_sgaCp of {
                                    Data.Functor.Product.Pair _ [Occ=Dead] b1_sgaCC [Occ=Once] ->
                                        b1_sgaCC;
                                  };
                        } in  GHC.Base.>>= $dMonad1_sgaCn n_sgaCs sat_sgaCD; } in
              let {
                sat_sgaCy [Occ=Once] :: f_ag3Uu b_ag3VX
                [LclId] =
                    [$dMonad_sgaCm eta1_sgaCp m_sgaCr] \u []
                        let {
                          sat_sgaCx [Occ=Once] :: a_ag3VW -> f_ag3Uu b_ag3VX
                          [LclId] =
                              [eta1_sgaCp] \r [x_sgaCt]
                                  case eta1_sgaCp of {
                                    Data.Functor.Product.Pair a1_sgaCv [Occ=Once] _ [Occ=Dead] ->
                                        a1_sgaCv;
                                  };
                        } in  GHC.Base.>>= $dMonad_sgaCm m_sgaCr sat_sgaCx;
              } in  Data.Functor.Product.Pair [sat_sgaCy sat_sgaCE];
        };

lvl4_rg5o1
  :: forall (f :: * -> *) (g :: * -> *) a.
     [GHC.Types.Char] -> Data.Functor.Product.Product f g a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sgaCF] GHC.Err.errorWithoutStackTrace eta_sgaCF;

Data.Functor.Product.$fMonadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Monad f, GHC.Base.Monad g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)><L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>m] =
    [] \r [$dMonad_sgaCG $dMonad1_sgaCH]
        let {
          sat_sgaCL [Occ=Once]
            :: forall a. a -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv a
          [LclId] =
              [$dMonad_sgaCG $dMonad1_sgaCH] \r [eta_B1]
                  Data.Functor.Product.$fMonadProduct_$creturn
                      $dMonad_sgaCG $dMonad1_sgaCH eta_B1; } in
        let {
          sat_sgaCK [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Uu g_ag3Uv a
               -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b
               -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b
          [LclId] =
              [$dMonad_sgaCG $dMonad1_sgaCH] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadProduct_$c>>
                      $dMonad_sgaCG $dMonad1_sgaCH eta_B2 eta_B1; } in
        let {
          sat_sgaCJ [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Uu g_ag3Uv a
               -> (a -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b)
               -> Data.Functor.Product.Product f_ag3Uu g_ag3Uv b
          [LclId] =
              [$dMonad_sgaCG $dMonad1_sgaCH] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadProduct_$c>>=
                      $dMonad_sgaCG $dMonad1_sgaCH eta_B2 eta_B1; } in
        let {
          sat_sgaCI [Occ=Once]
            :: GHC.Base.Applicative
                 (Data.Functor.Product.Product f_ag3Uu g_ag3Uv)
          [LclId] =
              [$dMonad_sgaCG $dMonad1_sgaCH] \u []
                  Data.Functor.Product.$fMonadProduct_$cp1Monad
                      $dMonad_sgaCG $dMonad1_sgaCH;
        } in 
          GHC.Base.C:Monad [sat_sgaCI
                            sat_sgaCJ
                            sat_sgaCK
                            sat_sgaCL
                            lvl4_rg5o1];

Data.Functor.Product.$fMonadPlusProduct_$cmplus
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     forall a.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(U)))><L,1*U(A,A,A,1*C1(C1(U)))><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sgaCM $dMonadPlus1_sgaCN ds_sgaCO ds1_sgaCP]
        case ds_sgaCO of {
          Data.Functor.Product.Pair x1_sgaCR [Occ=Once]
                                    y1_sgaCS [Occ=Once] ->
              case ds1_sgaCP of {
                Data.Functor.Product.Pair x2_sgaCU [Occ=Once]
                                          y2_sgaCV [Occ=Once] ->
                    let {
                      sat_sgaCX [Occ=Once] :: g_ag3TL a_ag3Uf
                      [LclId] =
                          [$dMonadPlus1_sgaCN y1_sgaCS y2_sgaCV] \u []
                              GHC.Base.mplus $dMonadPlus1_sgaCN y1_sgaCS y2_sgaCV; } in
                    let {
                      sat_sgaCW [Occ=Once] :: f_ag3TK a_ag3Uf
                      [LclId] =
                          [$dMonadPlus_sgaCM x1_sgaCR x2_sgaCU] \u []
                              GHC.Base.mplus $dMonadPlus_sgaCM x1_sgaCR x2_sgaCU;
                    } in  Data.Functor.Product.Pair [sat_sgaCW sat_sgaCX];
              };
        };

Data.Functor.Product.$fMonadPlusProduct_$cmzero
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     forall a. Data.Functor.Product.Product f g a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*U,A)><L,1*U(A,A,1*U,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sgaCY $dMonadPlus1_sgaCZ]
        let {
          sat_sgaD1 [Occ=Once] :: g_ag3TL a_ag3TZ
          [LclId] =
              [$dMonadPlus1_sgaCZ] \u [] GHC.Base.mzero $dMonadPlus1_sgaCZ; } in
        let {
          sat_sgaD0 [Occ=Once] :: f_ag3TK a_ag3TZ
          [LclId] =
              [$dMonadPlus_sgaCY] \u [] GHC.Base.mzero $dMonadPlus_sgaCY;
        } in  Data.Functor.Product.Pair [sat_sgaD0 sat_sgaD1];

Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A)><L,1*U(A,1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sgaD2 $dMonadPlus1_sgaD3]
        let {
          sat_sgaD5 [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_ag3TL
          [LclId] =
              [$dMonadPlus1_sgaD3] \u []
                  GHC.Base.$p2MonadPlus $dMonadPlus1_sgaD3; } in
        let {
          sat_sgaD4 [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_ag3TK
          [LclId] =
              [$dMonadPlus_sgaD2] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_sgaD2;
        } in  Data.Functor.Product.$fMonadProduct sat_sgaD4 sat_sgaD5;

Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     GHC.Base.Alternative (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sgaD6 $dMonadPlus1_sgaD7]
        let {
          sat_sgaD9 [Occ=Once,
                     Dmd=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>]
            :: GHC.Base.Alternative g_ag3TL
          [LclId] =
              [$dMonadPlus1_sgaD7] \u []
                  GHC.Base.$p1MonadPlus $dMonadPlus1_sgaD7; } in
        let {
          sat_sgaD8 [Occ=Once,
                     Dmd=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>]
            :: GHC.Base.Alternative f_ag3TK
          [LclId] =
              [$dMonadPlus_sgaD6] \u [] GHC.Base.$p1MonadPlus $dMonadPlus_sgaD6;
        } in 
          Data.Functor.Product.$fAlternativeProduct sat_sgaD8 sat_sgaD9;

Data.Functor.Product.$fMonadPlusProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) =>
     GHC.Base.MonadPlus (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),1*U,C(C1(U)))><L,U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),1*U,C(C1(U)))>m] =
    [] \r [$dMonadPlus_sgaDa $dMonadPlus1_sgaDb]
        let {
          sat_sgaDf [Occ=Once]
            :: forall a.
               Data.Functor.Product.Product f_ag3TK g_ag3TL a
               -> Data.Functor.Product.Product f_ag3TK g_ag3TL a
               -> Data.Functor.Product.Product f_ag3TK g_ag3TL a
          [LclId] =
              [$dMonadPlus_sgaDa $dMonadPlus1_sgaDb] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadPlusProduct_$cmplus
                      $dMonadPlus_sgaDa $dMonadPlus1_sgaDb eta_B2 eta_B1; } in
        let {
          sat_sgaDe [Occ=Once]
            :: forall a. Data.Functor.Product.Product f_ag3TK g_ag3TL a
          [LclId] =
              [$dMonadPlus_sgaDa $dMonadPlus1_sgaDb] \u []
                  Data.Functor.Product.$fMonadPlusProduct_$cmzero
                      $dMonadPlus_sgaDa $dMonadPlus1_sgaDb; } in
        let {
          sat_sgaDd [Occ=Once]
            :: GHC.Base.Monad (Data.Functor.Product.Product f_ag3TK g_ag3TL)
          [LclId] =
              [$dMonadPlus_sgaDa $dMonadPlus1_sgaDb] \u []
                  Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus
                      $dMonadPlus_sgaDa $dMonadPlus1_sgaDb; } in
        let {
          sat_sgaDc [Occ=Once]
            :: GHC.Base.Alternative
                 (Data.Functor.Product.Product f_ag3TK g_ag3TL)
          [LclId] =
              [$dMonadPlus_sgaDa $dMonadPlus1_sgaDb] \u []
                  Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus
                      $dMonadPlus_sgaDa $dMonadPlus1_sgaDb;
        } in 
          GHC.Base.C:MonadPlus [sat_sgaDc sat_sgaDd sat_sgaDe sat_sgaDf];

Data.Functor.Product.$fMonadFixProduct_$cmfix [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) =>
     forall a.
     (a -> Data.Functor.Product.Product f g a)
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U))><L,1*U(A,1*C1(U))><L,C(U(1*U,1*U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgaDg w1_sgaDh w2_sgaDi]
        let {
          sat_sgaDu [Occ=Once] :: g_sg4Wj a_sg4Wm
          [LclId] =
              [w1_sgaDh w2_sgaDi] \u []
                  let {
                    sat_sgaDt [Occ=Once] :: a_sg4Wm -> g_sg4Wj a_sg4Wm
                    [LclId] =
                        [w2_sgaDi] \r [x_sgaDp]
                            case w2_sgaDi x_sgaDp of {
                              Data.Functor.Product.Pair _ [Occ=Dead] b_sgaDs [Occ=Once] ->
                                  b_sgaDs;
                            };
                  } in  Control.Monad.Fix.mfix w1_sgaDh sat_sgaDt; } in
        let {
          sat_sgaDo [Occ=Once] :: f_sg4Wi a_sg4Wm
          [LclId] =
              [w_sgaDg w2_sgaDi] \u []
                  let {
                    sat_sgaDn [Occ=Once] :: a_sg4Wm -> f_sg4Wi a_sg4Wm
                    [LclId] =
                        [w2_sgaDi] \r [x_sgaDj]
                            case w2_sgaDi x_sgaDj of {
                              Data.Functor.Product.Pair a1_sgaDl [Occ=Once] _ [Occ=Dead] ->
                                  a1_sgaDl;
                            };
                  } in  Control.Monad.Fix.mfix w_sgaDg sat_sgaDn;
        } in  Data.Functor.Product.Pair [sat_sgaDo sat_sgaDu];

Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A)><L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadFix_sgaDv $dMonadFix1_sgaDw]
        let {
          sat_sgaDy [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_ag3Sn
          [LclId] =
              [$dMonadFix1_sgaDw] \u []
                  Control.Monad.Fix.$p1MonadFix $dMonadFix1_sgaDw; } in
        let {
          sat_sgaDx [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_ag3Sm
          [LclId] =
              [$dMonadFix_sgaDv] \u []
                  Control.Monad.Fix.$p1MonadFix $dMonadFix_sgaDv;
        } in  Data.Functor.Product.$fMonadProduct sat_sgaDx sat_sgaDy;

Data.Functor.Product.$fMonadFixProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) =>
     Control.Monad.Fix.MonadFix (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),C(U))><L,U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),C(U))>m] =
    [] \r [$dMonadFix_sgaDz $dMonadFix1_sgaDA]
        let {
          sat_sgaDC [Occ=Once]
            :: forall a.
               (a -> Data.Functor.Product.Product f_ag3Sm g_ag3Sn a)
               -> Data.Functor.Product.Product f_ag3Sm g_ag3Sn a
          [LclId] =
              [$dMonadFix_sgaDz $dMonadFix1_sgaDA] \r [eta_B1]
                  Data.Functor.Product.$fMonadFixProduct_$cmfix
                      $dMonadFix_sgaDz $dMonadFix1_sgaDA eta_B1; } in
        let {
          sat_sgaDB [Occ=Once]
            :: GHC.Base.Monad (Data.Functor.Product.Product f_ag3Sm g_ag3Sn)
          [LclId] =
              [$dMonadFix_sgaDz $dMonadFix1_sgaDA] \u []
                  Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix
                      $dMonadFix_sgaDz $dMonadFix1_sgaDA;
        } in  Control.Monad.Fix.C:MonadFix [sat_sgaDB sat_sgaDC];

Data.Functor.Product.$fMonadZipProduct_$cmzipWith [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b c.
     (a -> b -> c)
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgaDD w1_sgaDE w2_sgaDF w3_sgaDG w4_sgaDH]
        case w3_sgaDG of {
          Data.Functor.Product.Pair ww1_sgaDJ [Occ=Once]
                                    ww2_sgaDK [Occ=Once] ->
              case w4_sgaDH of {
                Data.Functor.Product.Pair ww4_sgaDM [Occ=Once]
                                          ww5_sgaDN [Occ=Once] ->
                    let {
                      sat_sgaDP [Occ=Once] :: g_sg4Wt c_sg4Wy
                      [LclId] =
                          [w1_sgaDE w2_sgaDF ww2_sgaDK ww5_sgaDN] \u []
                              Control.Monad.Zip.mzipWith
                                  w1_sgaDE w2_sgaDF ww2_sgaDK ww5_sgaDN; } in
                    let {
                      sat_sgaDO [Occ=Once] :: f_sg4Ws c_sg4Wy
                      [LclId] =
                          [w_sgaDD w2_sgaDF ww1_sgaDJ ww4_sgaDM] \u []
                              Control.Monad.Zip.mzipWith w_sgaDD w2_sgaDF ww1_sgaDJ ww4_sgaDM;
                    } in  Data.Functor.Product.Pair [sat_sgaDO sat_sgaDP];
              };
        };

Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     GHC.Base.Monad (Data.Functor.Product.Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sgaDQ $dMonadZip1_sgaDR]
        let {
          sat_sgaDT [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_ag3Rx
          [LclId] =
              [$dMonadZip1_sgaDR] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip1_sgaDR; } in
        let {
          sat_sgaDS [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_ag3Rw
          [LclId] =
              [$dMonadZip_sgaDQ] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sgaDQ;
        } in  Data.Functor.Product.$fMonadProduct sat_sgaDS sat_sgaDT;

Data.Functor.Product.$fMonadZipProduct_$cmzip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     Data.Functor.Product.Product f g a
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sgaDU $dMonadZip1_sgaDV w_sgaDW w1_sgaDX]
        case w_sgaDW of {
          Data.Functor.Product.Pair ww1_sgaDZ [Occ=Once]
                                    ww2_sgaE0 [Occ=Once] ->
              case w1_sgaDX of {
                Data.Functor.Product.Pair ww4_sgaE2 [Occ=Once]
                                          ww5_sgaE3 [Occ=Once] ->
                    let {
                      sat_sgaE5 [Occ=Once] :: g_ag3Rx (a_ag3RH, b_ag3RI)
                      [LclId] =
                          [$dMonadZip1_sgaDV ww2_sgaE0 ww5_sgaE3] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip1_sgaDV GHC.Tuple.(,) ww2_sgaE0 ww5_sgaE3; } in
                    let {
                      sat_sgaE4 [Occ=Once] :: f_ag3Rw (a_ag3RH, b_ag3RI)
                      [LclId] =
                          [$dMonadZip_sgaDU ww1_sgaDZ ww4_sgaE2] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip_sgaDU GHC.Tuple.(,) ww1_sgaDZ ww4_sgaE2;
                    } in  Data.Functor.Product.Pair [sat_sgaE4 sat_sgaE5];
              };
        };

Data.Functor.Product.$w$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     Data.Functor.Product.Product f g (a, b)
     -> (# Data.Functor.Product.Product f g a,
           Data.Functor.Product.Product f g b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaE6 w1_sgaE7 w2_sgaE8]
        let {
          $dMonad_sgaE9 [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_sg4WQ
          [LclId] =
              [w_sgaE6] \u [] Control.Monad.Zip.$p1MonadZip w_sgaE6; } in
        let {
          $dMonad1_sgaEa [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_sg4WR
          [LclId] =
              [w1_sgaE7] \u [] Control.Monad.Zip.$p1MonadZip w1_sgaE7; } in
        let {
          sat_sgaEO [Occ=Once]
            :: Data.Functor.Product.Product f_sg4WQ g_sg4WR b_sg4WV
          [LclId] =
              [w2_sgaE8 $dMonad_sgaE9 $dMonad1_sgaEa] \u []
                  case w2_sgaE8 of {
                    Data.Functor.Product.Pair m_sgaEw [Occ=Once] n_sgaEx [Occ=Once] ->
                        let {
                          sat_sgaEN [Occ=Once] :: g_sg4WR b_sg4WV
                          [LclId] =
                              [$dMonad1_sgaEa n_sgaEx] \u []
                                  let {
                                    lvl9_sgaEG [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative g_sg4WR
                                    [LclId] =
                                        [$dMonad1_sgaEa] \u []
                                            GHC.Base.$p1Monad $dMonad1_sgaEa; } in
                                  let {
                                    sat_sgaEM [Occ=Once] :: (a_sg4WU, b_sg4WV) -> g_sg4WR b_sg4WV
                                    [LclId] =
                                        [lvl9_sgaEG] \r [x_sgaEH]
                                            let {
                                              sat_sgaEL [Occ=Once] :: b_sg4WV
                                              [LclId] =
                                                  [x_sgaEH] \u []
                                                      case x_sgaEH of {
                                                        (,) _ [Occ=Dead] y_sgaEK [Occ=Once] ->
                                                            y_sgaEK;
                                                      };
                                            } in  GHC.Base.pure lvl9_sgaEG sat_sgaEL;
                                  } in  GHC.Base.>>= $dMonad1_sgaEa n_sgaEx sat_sgaEM; } in
                        let {
                          sat_sgaEF [Occ=Once] :: f_sg4WQ b_sg4WV
                          [LclId] =
                              [$dMonad_sgaE9 m_sgaEw] \u []
                                  let {
                                    lvl9_sgaEy [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative f_sg4WQ
                                    [LclId] =
                                        [$dMonad_sgaE9] \u [] GHC.Base.$p1Monad $dMonad_sgaE9; } in
                                  let {
                                    sat_sgaEE [Occ=Once] :: (a_sg4WU, b_sg4WV) -> f_sg4WQ b_sg4WV
                                    [LclId] =
                                        [lvl9_sgaEy] \r [x_sgaEz]
                                            let {
                                              sat_sgaED [Occ=Once] :: b_sg4WV
                                              [LclId] =
                                                  [x_sgaEz] \u []
                                                      case x_sgaEz of {
                                                        (,) _ [Occ=Dead] y_sgaEC [Occ=Once] ->
                                                            y_sgaEC;
                                                      };
                                            } in  GHC.Base.pure lvl9_sgaEy sat_sgaED;
                                  } in  GHC.Base.>>= $dMonad_sgaE9 m_sgaEw sat_sgaEE;
                        } in  Data.Functor.Product.Pair [sat_sgaEF sat_sgaEN];
                  }; } in
        let {
          sat_sgaEu [Occ=Once]
            :: Data.Functor.Product.Product f_sg4WQ g_sg4WR a_sg4WU
          [LclId] =
              [w2_sgaE8 $dMonad_sgaE9 $dMonad1_sgaEa] \u []
                  case w2_sgaE8 of {
                    Data.Functor.Product.Pair m_sgaEc [Occ=Once] n_sgaEd [Occ=Once] ->
                        let {
                          sat_sgaEt [Occ=Once] :: g_sg4WR a_sg4WU
                          [LclId] =
                              [$dMonad1_sgaEa n_sgaEd] \u []
                                  let {
                                    lvl9_sgaEm [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative g_sg4WR
                                    [LclId] =
                                        [$dMonad1_sgaEa] \u []
                                            GHC.Base.$p1Monad $dMonad1_sgaEa; } in
                                  let {
                                    sat_sgaEs [Occ=Once] :: (a_sg4WU, b_sg4WV) -> g_sg4WR a_sg4WU
                                    [LclId] =
                                        [lvl9_sgaEm] \r [x_sgaEn]
                                            let {
                                              sat_sgaEr [Occ=Once] :: a_sg4WU
                                              [LclId] =
                                                  [x_sgaEn] \u []
                                                      case x_sgaEn of {
                                                        (,) x1_sgaEp [Occ=Once] _ [Occ=Dead] ->
                                                            x1_sgaEp;
                                                      };
                                            } in  GHC.Base.pure lvl9_sgaEm sat_sgaEr;
                                  } in  GHC.Base.>>= $dMonad1_sgaEa n_sgaEd sat_sgaEs; } in
                        let {
                          sat_sgaEl [Occ=Once] :: f_sg4WQ a_sg4WU
                          [LclId] =
                              [$dMonad_sgaE9 m_sgaEc] \u []
                                  let {
                                    lvl9_sgaEe [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                                      :: GHC.Base.Applicative f_sg4WQ
                                    [LclId] =
                                        [$dMonad_sgaE9] \u [] GHC.Base.$p1Monad $dMonad_sgaE9; } in
                                  let {
                                    sat_sgaEk [Occ=Once] :: (a_sg4WU, b_sg4WV) -> f_sg4WQ a_sg4WU
                                    [LclId] =
                                        [lvl9_sgaEe] \r [x_sgaEf]
                                            let {
                                              sat_sgaEj [Occ=Once] :: a_sg4WU
                                              [LclId] =
                                                  [x_sgaEf] \u []
                                                      case x_sgaEf of {
                                                        (,) x1_sgaEh [Occ=Once] _ [Occ=Dead] ->
                                                            x1_sgaEh;
                                                      };
                                            } in  GHC.Base.pure lvl9_sgaEe sat_sgaEj;
                                  } in  GHC.Base.>>= $dMonad_sgaE9 m_sgaEc sat_sgaEk;
                        } in  Data.Functor.Product.Pair [sat_sgaEl sat_sgaEt];
                  };
        } in  (#,#) [sat_sgaEu sat_sgaEO];

Data.Functor.Product.$fMonadZipProduct_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     Data.Functor.Product.Product f g (a, b)
     -> (Data.Functor.Product.Product f g a,
         Data.Functor.Product.Product f g b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgaEP w1_sgaEQ w2_sgaER]
        case Data.Functor.Product.$w$cmunzip w_sgaEP w1_sgaEQ w2_sgaER of {
          (#,#) ww1_sgaET [Occ=Once] ww2_sgaEU [Occ=Once] ->
              (,) [ww1_sgaET ww2_sgaEU];
        };

Data.Functor.Product.$fMonadZipProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     Control.Monad.Zip.MonadZip (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)><L,U(U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sgaEV $dMonadZip1_sgaEW]
        let {
          sat_sgaF0 [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Rw g_ag3Rx (a, b)
               -> (Data.Functor.Product.Product f_ag3Rw g_ag3Rx a,
                   Data.Functor.Product.Product f_ag3Rw g_ag3Rx b)
          [LclId] =
              [$dMonadZip_sgaEV $dMonadZip1_sgaEW] \r [eta_B1]
                  Data.Functor.Product.$fMonadZipProduct_$cmunzip
                      $dMonadZip_sgaEV $dMonadZip1_sgaEW eta_B1; } in
        let {
          sat_sgaEZ [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx a
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx b
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx c
          [LclId] =
              [$dMonadZip_sgaEV $dMonadZip1_sgaEW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadZipProduct_$cmzipWith
                      $dMonadZip_sgaEV $dMonadZip1_sgaEW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgaEY [Occ=Once]
            :: forall a b.
               Data.Functor.Product.Product f_ag3Rw g_ag3Rx a
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx b
               -> Data.Functor.Product.Product f_ag3Rw g_ag3Rx (a, b)
          [LclId] =
              [$dMonadZip_sgaEV $dMonadZip1_sgaEW] \r [eta_B2 eta_B1]
                  Data.Functor.Product.$fMonadZipProduct_$cmzip
                      $dMonadZip_sgaEV $dMonadZip1_sgaEW eta_B2 eta_B1; } in
        let {
          sat_sgaEX [Occ=Once]
            :: GHC.Base.Monad (Data.Functor.Product.Product f_ag3Rw g_ag3Rx)
          [LclId] =
              [$dMonadZip_sgaEV $dMonadZip1_sgaEW] \u []
                  Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip
                      $dMonadZip_sgaEV $dMonadZip1_sgaEW;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sgaEX
                                        sat_sgaEY
                                        sat_sgaEZ
                                        sat_sgaF0];

Data.Functor.Product.$fGeneric1Product_$cto1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Data.Functor.Product.Product f g) a
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgaF1]
        case ds_sgaF1 of {
          GHC.Generics.:*: ds1_sgaF3 [Occ=Once] ds2_sgaF4 [Occ=Once] ->
              Data.Functor.Product.Pair [ds1_sgaF3 ds2_sgaF4];
        };

Data.Functor.Product.$fGeneric1Product1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Product.Product f g a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Pair" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.Rec1 f)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.Rec1 g))
          a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_sgaF5]
        case x_sgaF5 of {
          Data.Functor.Product.Pair g1_sgaF7 [Occ=Once]
                                    g2_sgaF8 [Occ=Once] ->
              GHC.Generics.:*: [g1_sgaF7 g2_sgaF8];
        };

Data.Functor.Product.$fGeneric1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *).
     GHC.Generics.Generic1 (Data.Functor.Product.Product f g)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Functor.Product.$fGeneric1Product1
                                            Data.Functor.Product.$fGeneric1Product_$cto1];

Data.Functor.Product.$fGenericProduct_$cto
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Data.Functor.Product.Product f g a) x
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgaF9]
        case ds_sgaF9 of {
          GHC.Generics.:*: ds1_sgaFb [Occ=Once] ds2_sgaFc [Occ=Once] ->
              Data.Functor.Product.Pair [ds1_sgaFb ds2_sgaFc];
        };

Data.Functor.Product.$fGenericProduct1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     Data.Functor.Product.Product f g a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Pair" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R (f a))
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.K1 GHC.Generics.R (g a)))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x1_sgaFd]
        case x1_sgaFd of {
          Data.Functor.Product.Pair g1_sgaFf [Occ=Once]
                                    g2_sgaFg [Occ=Once] ->
              GHC.Generics.:*: [g1_sgaFf g2_sgaFg];
        };

Data.Functor.Product.$fGenericProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Generic (Data.Functor.Product.Product f g a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Product.$fGenericProduct1
                                           Data.Functor.Product.$fGenericProduct_$cto];

Data.Functor.Product.$fDataProduct_$cgfoldl
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g1. g1 -> c g1)
     -> Data.Functor.Product.Product f g a
     -> c (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgaFh
           $dTypeable1_sgaFi
           $dTypeable2_sgaFj
           $dTypeable3_sgaFk
           $dData_sgaFl
           $dData1_sgaFm
           k1_sgaFn
           z_sgaFo
           ds_sgaFp]
        case ds_sgaFp of {
          Data.Functor.Product.Pair a1_sgaFr [Occ=Once]
                                    a2_sgaFs [Occ=Once] ->
              let {
                sat_sgaFu [Occ=Once]
                  :: c_ag3Ll (g_ag3L6 a_ag3L7
                              -> Data.Functor.Product.Product f_ag3L5 g_ag3L6 a_ag3L7)
                [LclId] =
                    [$dData_sgaFl k1_sgaFn z_sgaFo a1_sgaFr] \u []
                        let {
                          sat_sgaFt [Occ=Once]
                            :: c_ag3Ll (f_ag3L5 a_ag3L7
                                        -> g_ag3L6 a_ag3L7
                                        -> Data.Functor.Product.Product f_ag3L5 g_ag3L6 a_ag3L7)
                          [LclId] =
                              [z_sgaFo] \u [] z_sgaFo Data.Functor.Product.Pair;
                        } in  k1_sgaFn $dData_sgaFl sat_sgaFt a1_sgaFr;
              } in  k1_sgaFn $dData1_sgaFm sat_sgaFu a2_sgaFs;
        };

Data.Functor.Product.$fDataProduct6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Product"#;

Data.Functor.Product.$fDataProduct5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Product.$fDataProduct6;

go61_rg5o2
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgaFv _ys_sgaFw]
        case ds2_sgaFv of {
          [] -> GHC.List.badHead;
          : ipv_sgaFy [Occ=Once!] ipv1_sgaFz [Occ=Once] ->
              case _ys_sgaFw of {
                [] -> GHC.List.badHead;
                : ipv2_sgaFB [Occ=Once] ipv3_sgaFC [Occ=Once] ->
                    case ipv_sgaFy of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgaFF [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case
                              GHC.Base.eqString ds4_sgaFF Data.Functor.Product.$fRead1Product2
                          of
                          { GHC.Types.False -> go61_rg5o2 ipv1_sgaFz ipv3_sgaFC;
                            GHC.Types.True -> ipv2_sgaFB;
                          };
                    };
              };
        };

$cPair1_rg5o3 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cPair2_rg5o4];
Data.Functor.Product.$fDataProduct4 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Product.$cPair GHC.Types.[]];
Data.Functor.Product.$fDataProduct3 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Functor.Product.$fDataProduct4];
Data.Functor.Product.$tProduct :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Functor.Product.$fDataProduct5
                                       Data.Functor.Product.$fDataProduct3];
Data.Functor.Product.$cPair [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cPair1_rg5o3
                                     Data.Functor.Product.$fRead1Product2
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Functor.Product.$tProduct];
$cPair2_rg5o4 :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rg5o2 Data.Functor.Product.$fDataProduct4 Data.Data.mkConstr1;

Data.Functor.Product.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Product.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$trModule4];

Data.Functor.Product.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Product"#;

Data.Functor.Product.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$trModule2];

Data.Functor.Product.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Product.$trModule3
                                     Data.Functor.Product.$trModule1];

$krep_rg5o5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_rg5o6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rg5o5 GHC.Types.krep$*];

$krep2_rg5o7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rg5o6 $krep1_rg5o6];

Data.Functor.Product.$fDataProduct8 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rg5o6 $krep2_rg5o7];

$krep3_rg5o8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep4_rg5o9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_rg5oa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [3#];

$krep6_rg5ob :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rg5o9 $krep5_rg5oa];

$krep7_rg5oc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep3_rg5o8 $krep5_rg5oa];

Data.Functor.Product.$fDataProduct9 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$fDataProduct6];

Data.Functor.Product.$tcProduct :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9904636435990105341##
                                    16069493191308336164##
                                    Data.Functor.Product.$trModule
                                    Data.Functor.Product.$fDataProduct9
                                    1#
                                    Data.Functor.Product.$fDataProduct8];

$krep8_rg5od :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep5_rg5oa GHC.Types.[]];

$krep9_rg5oe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rg5o8 $krep8_rg5od];

$krep10_rg5of :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rg5o9 $krep9_rg5oe];

$krep11_rg5og :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rg5o5 $krep10_rg5of];

$krep12_rg5oh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Product.$tcProduct
                                              $krep11_rg5og];

$krep13_rg5oi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_rg5oc $krep12_rg5oh];

Data.Functor.Product.$tc'Pair1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rg5ob $krep13_rg5oi];

Data.Functor.Product.$tc'Pair3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Pair"#;

Data.Functor.Product.$tc'Pair2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Product.$tc'Pair3];

Data.Functor.Product.$tc'Pair :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11374113252541295849##
                                    18011678063065699923##
                                    Data.Functor.Product.$trModule
                                    Data.Functor.Product.$tc'Pair2
                                    4#
                                    Data.Functor.Product.$tc'Pair1];

Data.Functor.Product.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Product.Product f g a)
[GblId, Arity=4, Str=<S,U><S,U><S,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sgaFK w1_sgaFL w2_sgaFM w3_sgaFN]
        let {
          sat_sgaFO [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w3_sgaFN]; } in
        let {
          sat_sgaFP [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sgaFO GHC.Types.[]];
        } in 
          case
              Data.Typeable.Internal.$wmkTrCon
                  9904636435990105341##
                  16069493191308336164##
                  Data.Functor.Product.$trModule
                  Data.Functor.Product.$fDataProduct9
                  1#
                  Data.Functor.Product.$fDataProduct8
                  sat_sgaFP
          of
          { (#,,,,#) ww8_sgaFR [Occ=Once]
                     ww9_sgaFS [Occ=Once]
                     ww10_sgaFT [Occ=Once]
                     ww11_sgaFU [Occ=Once]
                     ww12_sgaFV [Occ=Once] ->
                let {
                  sat_sgaFW [Occ=Once]
                    :: Data.Typeable.Internal.TypeRep Data.Functor.Product.Product
                  [LclId] =
                      CCCS Data.Typeable.Internal.TrTyCon! [ww8_sgaFR
                                                            ww9_sgaFS
                                                            ww10_sgaFT
                                                            ww11_sgaFU
                                                            ww12_sgaFV];
                } in 
                  case
                      Data.Typeable.Internal.mkTrApp sat_sgaFW w1_sgaFL
                  of
                  sat_sgaFX
                  { __DEFAULT ->
                        case
                            Data.Typeable.Internal.mkTrApp sat_sgaFX w2_sgaFM
                        of
                        sat_sgaFY
                        { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sgaFY w_sgaFK;
                        };
                  };
          };

Data.Functor.Product.$fDataProduct7 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Product.Product f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sgaFZ w1_sgaG0 w2_sgaG1 w3_sgaG2 w4_sgaG3 w5_sgaG4]
        Data.Functor.Product.$w$cp1Data w_sgaFZ w1_sgaG0 w2_sgaG1 w3_sgaG2;

Data.Functor.Product.$fDataProduct1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (f a -> g a -> Data.Functor.Product.Product f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Product.Pair GHC.Types.False];

Data.Functor.Product.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaG5 w1_sgaG6 w2_sgaG7 w3_sgaG8 w4_sgaG9]
        let {
          lvl9_sgaGa [Occ=OnceL]
            :: m_sg4Xt (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm)
          [LclId] =
              [w2_sgaG7] \u [] GHC.Base.mzero w2_sgaG7;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sgaG7
          of
          $dMonad_sgaGb [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgaGF [Occ=Once]
                    :: (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm,
                        GHC.Types.Bool)
                       -> m_sg4Xt (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm)
                  [LclId] =
                      [lvl9_sgaGa $dMonad_sgaGb] \r [ds_sgaGA]
                          case ds_sgaGA of {
                            (,) x'_sgaGC [Occ=Once] b_sgaGD [Occ=Once!] ->
                                case b_sgaGD of {
                                  GHC.Types.False -> lvl9_sgaGa;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgaGb x'_sgaGC;
                                };
                          }; } in
                let {
                  sat_sgaGz [Occ=Once]
                    :: m_sg4Xt (Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sgaG5 w1_sgaG6 w2_sgaG7 w3_sgaG8 w4_sgaG9 $dMonad_sgaGb] \u []
                          case w4_sgaG9 of {
                            Data.Functor.Product.Pair a1_sgaGd [Occ=Once]
                                                      a2_sgaGe [Occ=Once] ->
                                let {
                                  k1_sgaGf [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_sg4Xt (d -> b)
                                       -> d -> m_sg4Xt (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [w2_sgaG7 w3_sgaG8 $dMonad_sgaGb] \r [$dData1_sgaGg
                                                                                     ds_sgaGh
                                                                                     y_sgaGi]
                                          let {
                                            lvl10_sgaGj [Occ=OnceL] :: m_sg4Xt d_ae2Ws
                                            [LclId] =
                                                [w3_sgaG8 $dData1_sgaGg y_sgaGi] \u []
                                                    w3_sgaG8 $dData1_sgaGg y_sgaGi; } in
                                          let {
                                            sat_sgaGw [Occ=Once]
                                              :: (d_ae2Ws -> b_ae2Wt, GHC.Types.Bool)
                                                 -> m_sg4Xt (b_ae2Wt, GHC.Types.Bool)
                                            [LclId] =
                                                [w2_sgaG7
                                                 $dMonad_sgaGb
                                                 y_sgaGi
                                                 lvl10_sgaGj] \r [ds1_sgaGk]
                                                    case ds1_sgaGk of {
                                                      (,) h_sgaGm b1_sgaGn [Occ=Once] ->
                                                          let {
                                                            sat_sgaGv [Occ=Once]
                                                              :: m_sg4Xt (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgaGb
                                                                 y_sgaGi
                                                                 h_sgaGm
                                                                 b1_sgaGn] \u []
                                                                    let {
                                                                      sat_sgaGt [Occ=Once]
                                                                        :: b_ae2Wt
                                                                      [LclId] =
                                                                          [y_sgaGi h_sgaGm] \u []
                                                                              h_sgaGm y_sgaGi; } in
                                                                    let {
                                                                      sat_sgaGu [Occ=Once]
                                                                        :: (b_ae2Wt, GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sgaGt
                                                                                     b1_sgaGn];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sgaGb
                                                                          sat_sgaGu; } in
                                                          let {
                                                            sat_sgaGs [Occ=Once]
                                                              :: m_sg4Xt (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgaGb
                                                                 lvl10_sgaGj
                                                                 h_sgaGm] \u []
                                                                    let {
                                                                      sat_sgaGr [Occ=Once]
                                                                        :: d_ae2Ws
                                                                           -> m_sg4Xt (b_ae2Wt,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sgaGb
                                                                           h_sgaGm] \r [y'_sgaGo]
                                                                              let {
                                                                                sat_sgaGp [Occ=Once]
                                                                                  :: b_ae2Wt
                                                                                [LclId] =
                                                                                    [h_sgaGm
                                                                                     y'_sgaGo] \u []
                                                                                        h_sgaGm
                                                                                            y'_sgaGo; } in
                                                                              let {
                                                                                sat_sgaGq [Occ=Once]
                                                                                  :: (b_ae2Wt,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sgaGp
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sgaGb
                                                                                    sat_sgaGq;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sgaGb
                                                                          lvl10_sgaGj
                                                                          sat_sgaGr;
                                                          } in 
                                                            GHC.Base.mplus
                                                                w2_sgaG7 sat_sgaGs sat_sgaGv;
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sgaGb ds_sgaGh sat_sgaGw; } in
                                let {
                                  sat_sgaGy [Occ=Once]
                                    :: Data.Data.Mp
                                         m_sg4Xt
                                         (g_sg4Xl a_sg4Xm
                                          -> Data.Functor.Product.Product f_sg4Xk g_sg4Xl a_sg4Xm)
                                  [LclId] =
                                      [w_sgaG5 $dMonad_sgaGb a1_sgaGd k1_sgaGf] \u []
                                          let {
                                            sat_sgaGx [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_sg4Xt
                                                   (f_sg4Xk a_sg4Xm
                                                    -> g_sg4Xl a_sg4Xm
                                                    -> Data.Functor.Product.Product
                                                         f_sg4Xk g_sg4Xl a_sg4Xm)
                                            [LclId] =
                                                [$dMonad_sgaGb] \u []
                                                    GHC.Base.return
                                                        $dMonad_sgaGb
                                                        Data.Functor.Product.$fDataProduct1;
                                          } in  k1_sgaGf w_sgaG5 sat_sgaGx a1_sgaGd;
                                } in  k1_sgaGf w1_sgaG6 sat_sgaGy a2_sgaGe;
                          };
                } in  GHC.Base.>>= $dMonad_sgaGb sat_sgaGz sat_sgaGF;
          };

Data.Functor.Product.$fDataProduct_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaGG
           w1_sgaGH
           w2_sgaGI
           w3_sgaGJ
           w4_sgaGK
           w5_sgaGL
           w6_sgaGM
           w7_sgaGN
           w8_sgaGO]
        Data.Functor.Product.$w$cgmapMp
            w4_sgaGK w5_sgaGL w6_sgaGM w7_sgaGN w8_sgaGO;

Data.Functor.Product.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> f a -> g a -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgaGP w1_sgaGQ w2_sgaGR w3_sgaGS ww_sgaGT ww1_sgaGU]
        let {
          k1_sgaGV [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
            :: forall d b.
               Data.Data.Data d =>
               m_sg4XN (d -> b) -> d -> m_sg4XN b
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w2_sgaGR w3_sgaGS] \r [$dData1_sgaGW c_sgaGX x_sgaGY]
                  let {
                    lvl9_sgaGZ [Occ=OnceL] :: m_sg4XN d_ae2Vh
                    [LclId] =
                        [w3_sgaGS $dData1_sgaGW x_sgaGY] \u []
                            w3_sgaGS $dData1_sgaGW x_sgaGY; } in
                  let {
                    sat_sgaH4 [Occ=Once] :: (d_ae2Vh -> b_ae2Vi) -> m_sg4XN b_ae2Vi
                    [LclId] =
                        [w2_sgaGR lvl9_sgaGZ] \r [c'_sgaH0]
                            let {
                              sat_sgaH3 [Occ=Once] :: d_ae2Vh -> m_sg4XN b_ae2Vi
                              [LclId] =
                                  [w2_sgaGR c'_sgaH0] \r [x'_sgaH1]
                                      let {
                                        sat_sgaH2 [Occ=Once] :: b_ae2Vi
                                        [LclId] =
                                            [c'_sgaH0 x'_sgaH1] \u [] c'_sgaH0 x'_sgaH1;
                                      } in  GHC.Base.return w2_sgaGR sat_sgaH2;
                            } in  GHC.Base.>>= w2_sgaGR lvl9_sgaGZ sat_sgaH3;
                  } in  GHC.Base.>>= w2_sgaGR c_sgaGX sat_sgaH4; } in
        let {
          sat_sgaH6 [Occ=Once]
            :: m_sg4XN (g_sg4XF a_sg4XG
                        -> Data.Functor.Product.Product f_sg4XE g_sg4XF a_sg4XG)
          [LclId] =
              [w_sgaGP w2_sgaGR ww_sgaGT k1_sgaGV] \u []
                  let {
                    sat_sgaH5 [Occ=Once]
                      :: m_sg4XN (f_sg4XE a_sg4XG
                                  -> g_sg4XF a_sg4XG
                                  -> Data.Functor.Product.Product f_sg4XE g_sg4XF a_sg4XG)
                    [LclId] =
                        [w2_sgaGR] \u []
                            GHC.Base.return w2_sgaGR Data.Functor.Product.Pair;
                  } in  k1_sgaGV w_sgaGP sat_sgaH5 ww_sgaGT;
        } in  k1_sgaGV w1_sgaGQ sat_sgaH6 ww1_sgaGU;

Data.Functor.Product.$fDataProduct_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaH7
           w1_sgaH8
           w2_sgaH9
           w3_sgaHa
           w4_sgaHb
           w5_sgaHc
           w6_sgaHd
           w7_sgaHe
           w8_sgaHf]
        case w8_sgaHf of {
          Data.Functor.Product.Pair ww1_sgaHh [Occ=Once]
                                    ww2_sgaHi [Occ=Once] ->
              Data.Functor.Product.$w$cgmapM
                  w4_sgaHb w5_sgaHc w6_sgaHd w7_sgaHe ww1_sgaHh ww2_sgaHi;
        };

Data.Functor.Product.$fDataProduct_$cgmapQi
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Functor.Product.Product f g a
     -> u
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgaHj
           $dTypeable1_sgaHk
           $dTypeable2_sgaHl
           $dTypeable3_sgaHm
           $dData_sgaHn
           $dData1_sgaHo
           ds_sgaHp
           ds1_sgaHq
           x_sgaHr]
        case x_sgaHr of {
          Data.Functor.Product.Pair a1_sgaHt [Occ=Once]
                                    a2_sgaHu [Occ=Once] ->
              case ds_sgaHp of {
                GHC.Types.I# x1_sgaHw [Occ=Once!] ->
                    case x1_sgaHw of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sgaHq $dData_sgaHn a1_sgaHt;
                      1# -> ds1_sgaHq $dData1_sgaHo a2_sgaHu;
                    };
              };
        };

Data.Functor.Product.$fDataProduct_$cgmapQr
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Product.Product f g a
     -> r
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgaHy
           $dTypeable1_sgaHz
           $dTypeable2_sgaHA
           $dTypeable3_sgaHB
           $dData_sgaHC
           $dData1_sgaHD
           ds_sgaHE
           ds1_sgaHF
           ds2_sgaHG
           x0_sgaHH]
        case x0_sgaHH of {
          Data.Functor.Product.Pair a1_sgaHJ [Occ=Once]
                                    a2_sgaHK [Occ=Once] ->
              let {
                sat_sgaHN [Occ=Once] :: r_ag3N9
                [LclId] =
                    [$dData1_sgaHD ds_sgaHE ds1_sgaHF ds2_sgaHG a2_sgaHK] \u []
                        let {
                          sat_sgaHM [Occ=Once] :: r'_ag3Na
                          [LclId] =
                              [$dData1_sgaHD ds2_sgaHG a2_sgaHK] \u []
                                  ds2_sgaHG $dData1_sgaHD a2_sgaHK;
                        } in  ds_sgaHE sat_sgaHM ds1_sgaHF; } in
              let {
                sat_sgaHL [Occ=Once] :: r'_ag3Na
                [LclId] =
                    [$dData_sgaHC ds2_sgaHG a1_sgaHJ] \u []
                        ds2_sgaHG $dData_sgaHC a1_sgaHJ;
              } in  ds_sgaHE sat_sgaHL sat_sgaHN;
        };

Data.Functor.Product.$fDataProduct2
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Product.Product f g a
     -> Data.Functor.Const.Const r (Data.Functor.Product.Product f g a)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgaHO
           $dTypeable1_sgaHP
           $dTypeable2_sgaHQ
           $dTypeable3_sgaHR
           $dData_sgaHS
           $dData1_sgaHT
           ds_sgaHU
           ds1_sgaHV
           ds2_sgaHW
           eta_sgaHX]
        case eta_sgaHX of {
          Data.Functor.Product.Pair a1_sgaHZ [Occ=Once]
                                    a2_sgaI0 [Occ=Once] ->
              let {
                sat_sgaI3 [Occ=Once] :: r'_ag3MT
                [LclId] =
                    [$dData1_sgaHT ds2_sgaHW a2_sgaI0] \u []
                        ds2_sgaHW $dData1_sgaHT a2_sgaI0; } in
              let {
                sat_sgaI2 [Occ=Once] :: r_ag3MS
                [LclId] =
                    [$dData_sgaHS ds_sgaHU ds1_sgaHV ds2_sgaHW a1_sgaHZ] \u []
                        let {
                          sat_sgaI1 [Occ=Once] :: r'_ag3MT
                          [LclId] =
                              [$dData_sgaHS ds2_sgaHW a1_sgaHZ] \u []
                                  ds2_sgaHW $dData_sgaHS a1_sgaHZ;
                        } in  ds_sgaHU ds1_sgaHV sat_sgaI1;
              } in  ds_sgaHU sat_sgaI2 sat_sgaI3;
        };

Data.Functor.Product.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaI4 w1_sgaI5 w2_sgaI6 w3_sgaI7 w4_sgaI8]
        let {
          lvl9_sgaI9 [Occ=OnceL]
            :: m_sg4Yc (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
          [LclId] =
              [w2_sgaI6] \u [] GHC.Base.mzero w2_sgaI6;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sgaI6
          of
          $dMonad_sgaIa [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgaIH [Occ=Once]
                    :: (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5,
                        GHC.Types.Bool)
                       -> m_sg4Yc (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
                  [LclId] =
                      [lvl9_sgaI9 $dMonad_sgaIa] \r [ds_sgaIC]
                          case ds_sgaIC of {
                            (,) x'_sgaIE [Occ=Once] b_sgaIF [Occ=Once!] ->
                                case b_sgaIF of {
                                  GHC.Types.False -> lvl9_sgaI9;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgaIa x'_sgaIE;
                                };
                          }; } in
                let {
                  sat_sgaIB [Occ=Once]
                    :: m_sg4Yc (Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sgaI4 w1_sgaI5 w2_sgaI6 w3_sgaI7 w4_sgaI8 $dMonad_sgaIa] \u []
                          case w4_sgaI8 of {
                            Data.Functor.Product.Pair a1_sgaIc [Occ=Once]
                                                      a2_sgaId [Occ=Once] ->
                                let {
                                  k1_sgaIe [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_sg4Yc (d -> b)
                                       -> d -> m_sg4Yc (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [w2_sgaI6 w3_sgaI7 $dMonad_sgaIa] \r [$dData1_sgaIf
                                                                                     ds_sgaIg
                                                                                     y_sgaIh]
                                          let {
                                            lvl10_sgaIi [Occ=OnceL] :: m_sg4Yc d_ae2Ya
                                            [LclId] =
                                                [w3_sgaI7 $dData1_sgaIf y_sgaIh] \u []
                                                    w3_sgaI7 $dData1_sgaIf y_sgaIh; } in
                                          let {
                                            sat_sgaIy [Occ=Once]
                                              :: (d_ae2Ya -> b_ae2Yb, GHC.Types.Bool)
                                                 -> m_sg4Yc (b_ae2Yb, GHC.Types.Bool)
                                            [LclId] =
                                                [w2_sgaI6
                                                 $dMonad_sgaIa
                                                 y_sgaIh
                                                 lvl10_sgaIi] \r [ds1_sgaIj]
                                                    case ds1_sgaIj of {
                                                      (,) h_sgaIl b1_sgaIm [Occ=Once!] ->
                                                          case b1_sgaIm of {
                                                            GHC.Types.False ->
                                                                let {
                                                                  sat_sgaIv [Occ=Once]
                                                                    :: m_sg4Yc (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sgaIa
                                                                       y_sgaIh
                                                                       h_sgaIl] \u []
                                                                          let {
                                                                            sat_sgaIt [Occ=Once]
                                                                              :: b_ae2Yb
                                                                            [LclId] =
                                                                                [y_sgaIh
                                                                                 h_sgaIl] \u []
                                                                                    h_sgaIl
                                                                                        y_sgaIh; } in
                                                                          let {
                                                                            sat_sgaIu [Occ=Once]
                                                                              :: (b_ae2Yb,
                                                                                  GHC.Types.Bool)
                                                                            [LclId] =
                                                                                CCCS (,)! [sat_sgaIt
                                                                                           GHC.Types.False];
                                                                          } in 
                                                                            GHC.Base.return
                                                                                $dMonad_sgaIa
                                                                                sat_sgaIu; } in
                                                                let {
                                                                  sat_sgaIs [Occ=Once]
                                                                    :: m_sg4Yc (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sgaIa
                                                                       lvl10_sgaIi
                                                                       h_sgaIl] \u []
                                                                          let {
                                                                            sat_sgaIr [Occ=Once]
                                                                              :: d_ae2Ya
                                                                                 -> m_sg4Yc (b_ae2Yb,
                                                                                             GHC.Types.Bool)
                                                                            [LclId] =
                                                                                [$dMonad_sgaIa
                                                                                 h_sgaIl] \r [y'_sgaIo]
                                                                                    let {
                                                                                      sat_sgaIp [Occ=Once]
                                                                                        :: b_ae2Yb
                                                                                      [LclId] =
                                                                                          [h_sgaIl
                                                                                           y'_sgaIo] \u []
                                                                                              h_sgaIl
                                                                                                  y'_sgaIo; } in
                                                                                    let {
                                                                                      sat_sgaIq [Occ=Once]
                                                                                        :: (b_ae2Yb,
                                                                                            GHC.Types.Bool)
                                                                                      [LclId] =
                                                                                          CCCS (,)! [sat_sgaIp
                                                                                                     GHC.Types.True];
                                                                                    } in 
                                                                                      GHC.Base.return
                                                                                          $dMonad_sgaIa
                                                                                          sat_sgaIq;
                                                                          } in 
                                                                            GHC.Base.>>=
                                                                                $dMonad_sgaIa
                                                                                lvl10_sgaIi
                                                                                sat_sgaIr;
                                                                } in 
                                                                  GHC.Base.mplus
                                                                      w2_sgaI6 sat_sgaIs sat_sgaIv;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_sgaIw [Occ=Once] :: b_ae2Yb
                                                                  [LclId] =
                                                                      [y_sgaIh h_sgaIl] \u []
                                                                          h_sgaIl y_sgaIh; } in
                                                                let {
                                                                  sat_sgaIx [Occ=Once]
                                                                    :: (b_ae2Yb, GHC.Types.Bool)
                                                                  [LclId] =
                                                                      CCCS (,)! [sat_sgaIw
                                                                                 GHC.Types.True];
                                                                } in 
                                                                  GHC.Base.return
                                                                      $dMonad_sgaIa sat_sgaIx;
                                                          };
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sgaIa ds_sgaIg sat_sgaIy; } in
                                let {
                                  sat_sgaIA [Occ=Once]
                                    :: Data.Data.Mp
                                         m_sg4Yc
                                         (g_sg4Y4 a_sg4Y5
                                          -> Data.Functor.Product.Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
                                  [LclId] =
                                      [w_sgaI4 $dMonad_sgaIa a1_sgaIc k1_sgaIe] \u []
                                          let {
                                            sat_sgaIz [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_sg4Yc
                                                   (f_sg4Y3 a_sg4Y5
                                                    -> g_sg4Y4 a_sg4Y5
                                                    -> Data.Functor.Product.Product
                                                         f_sg4Y3 g_sg4Y4 a_sg4Y5)
                                            [LclId] =
                                                [$dMonad_sgaIa] \u []
                                                    GHC.Base.return
                                                        $dMonad_sgaIa
                                                        Data.Functor.Product.$fDataProduct1;
                                          } in  k1_sgaIe w_sgaI4 sat_sgaIz a1_sgaIc;
                                } in  k1_sgaIe w1_sgaI5 sat_sgaIA a2_sgaId;
                          };
                } in  GHC.Base.>>= $dMonad_sgaIa sat_sgaIB sat_sgaIH;
          };

Data.Functor.Product.$fDataProduct_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Product.Product f g a
     -> m (Data.Functor.Product.Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgaII
           w1_sgaIJ
           w2_sgaIK
           w3_sgaIL
           w4_sgaIM
           w5_sgaIN
           w6_sgaIO
           w7_sgaIP
           w8_sgaIQ]
        Data.Functor.Product.$w$cgmapMo
            w4_sgaIM w5_sgaIN w6_sgaIO w7_sgaIP w8_sgaIQ;

lvl5_rg5oj
  :: forall k (g :: k -> *) (a :: k) (f :: k -> *).
     Data.Functor.Product.Product f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_sgaIR]
        case ds_sgaIR of {
          Data.Functor.Product.Pair _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Functor.Product.$cPair;
        };

lvl6_rg5ok
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Product.Product f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgaIV] Data.Functor.Product.$tProduct;

lvl7_rg5ol
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Functor.Product.Product f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgaIW ds_sgaIX] GHC.Base.Nothing [];

lvl8_rg5om
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Functor.Product.Product f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgaIY ds_sgaIZ] GHC.Base.Nothing [];

Data.Functor.Product.$fDataProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Data.Data (Data.Functor.Product.Product f g a)
[GblId[DFunId], Arity=6, Str=<L,U><L,U><L,U><L,U><L,U><L,U>] =
    [] \r [$dTypeable_sgaJ0
           $dTypeable1_sgaJ1
           $dTypeable2_sgaJ2
           $dTypeable3_sgaJ3
           $dData_sgaJ4
           $dData1_sgaJ5]
        let {
          sat_sgaJG [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> m (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dData_sgaJ4 $dData1_sgaJ5] \r [w_sgaJD w1_sgaJE w2_sgaJF]
                  Data.Functor.Product.$w$cgmapMo
                      $dData_sgaJ4 $dData1_sgaJ5 w_sgaJD w1_sgaJE w2_sgaJF; } in
        let {
          sat_sgaJC [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> m (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dData_sgaJ4 $dData1_sgaJ5] \r [w_sgaJz w1_sgaJA w2_sgaJB]
                  Data.Functor.Product.$w$cgmapMp
                      $dData_sgaJ4 $dData1_sgaJ5 w_sgaJz w1_sgaJA w2_sgaJB; } in
        let {
          sat_sgaJy [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> m (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dTypeable_sgaJ0
               $dTypeable1_sgaJ1
               $dTypeable2_sgaJ2
               $dTypeable3_sgaJ3
               $dData_sgaJ4
               $dData1_sgaJ5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgmapM
                      $dTypeable_sgaJ0
                      $dTypeable1_sgaJ1
                      $dTypeable2_sgaJ2
                      $dTypeable3_sgaJ3
                      $dData_sgaJ4
                      $dData1_sgaJ5
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sgaJx [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> u
          [LclId] =
              [$dTypeable_sgaJ0
               $dTypeable1_sgaJ1
               $dTypeable2_sgaJ2
               $dTypeable3_sgaJ3
               $dData_sgaJ4
               $dData1_sgaJ5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgmapQi
                      $dTypeable_sgaJ0
                      $dTypeable1_sgaJ1
                      $dTypeable2_sgaJ2
                      $dTypeable3_sgaJ3
                      $dData_sgaJ4
                      $dData1_sgaJ5
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sgaJw [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7 -> [u]
          [LclId] =
              [$dData_sgaJ4 $dData1_sgaJ5] \r [ds_sgaJo x0_sgaJp]
                  case x0_sgaJp of {
                    Data.Functor.Product.Pair a1_sgaJr [Occ=Once]
                                              a2_sgaJs [Occ=Once] ->
                        let {
                          sat_sgaJu [Occ=Once] :: u_ag3Nq
                          [LclId] =
                              [$dData1_sgaJ5 ds_sgaJo a2_sgaJs] \u []
                                  ds_sgaJo $dData1_sgaJ5 a2_sgaJs; } in
                        let {
                          sat_sgaJv [Occ=Once] :: [u_ag3Nq]
                          [LclId] =
                              CCCS :! [sat_sgaJu GHC.Types.[]]; } in
                        let {
                          sat_sgaJt [Occ=Once] :: u_ag3Nq
                          [LclId] =
                              [$dData_sgaJ4 ds_sgaJo a1_sgaJr] \u []
                                  ds_sgaJo $dData_sgaJ4 a1_sgaJr;
                        } in  : [sat_sgaJt sat_sgaJv];
                  }; } in
        let {
          sat_sgaJn [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> r
          [LclId] =
              [$dTypeable_sgaJ0
               $dTypeable1_sgaJ1
               $dTypeable2_sgaJ2
               $dTypeable3_sgaJ3
               $dData_sgaJ4
               $dData1_sgaJ5] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgmapQr
                      $dTypeable_sgaJ0
                      $dTypeable1_sgaJ1
                      $dTypeable2_sgaJ2
                      $dTypeable3_sgaJ3
                      $dData_sgaJ4
                      $dData1_sgaJ5
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sgaJm [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> r
          [LclId] =
              [$dTypeable_sgaJ0
               $dTypeable1_sgaJ1
               $dTypeable2_sgaJ2
               $dTypeable3_sgaJ3
               $dData_sgaJ4
               $dData1_sgaJ5] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct2
                      $dTypeable_sgaJ0
                      $dTypeable1_sgaJ1
                      $dTypeable2_sgaJ2
                      $dTypeable3_sgaJ3
                      $dData_sgaJ4
                      $dData1_sgaJ5
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sgaJl [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
          [LclId] =
              [$dData_sgaJ4 $dData1_sgaJ5] \r [ds_sgaJe x0_sgaJf]
                  case x0_sgaJf of {
                    Data.Functor.Product.Pair a1_sgaJh [Occ=Once]
                                              a2_sgaJi [Occ=Once] ->
                        let {
                          sat_sgaJk [Occ=Once] :: g_Xg3V4 a_Xg3V7
                          [LclId] =
                              [$dData1_sgaJ5 ds_sgaJe a2_sgaJi] \u []
                                  ds_sgaJe $dData1_sgaJ5 a2_sgaJi; } in
                        let {
                          sat_sgaJj [Occ=Once] :: f_Xg3PP a_Xg3V7
                          [LclId] =
                              [$dData_sgaJ4 ds_sgaJe a1_sgaJh] \u []
                                  ds_sgaJe $dData_sgaJ4 a1_sgaJh;
                        } in  Data.Functor.Product.Pair [sat_sgaJj sat_sgaJk];
                  }; } in
        let {
          sat_sgaJd [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dData_sgaJ4 $dData1_sgaJ5] \r [k1_sgaJ8 z_sgaJ9 ds_sgaJa]
                  let {
                    sat_sgaJc [Occ=Once]
                      :: c_ag3LC (g_Xg3V4 a_Xg3V7
                                  -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
                    [LclId] =
                        [$dData_sgaJ4 k1_sgaJ8 z_sgaJ9] \u []
                            let {
                              sat_sgaJb [Occ=Once]
                                :: c_ag3LC (f_Xg3PP a_Xg3V7
                                            -> g_Xg3V4 a_Xg3V7
                                            -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
                              [LclId] =
                                  [z_sgaJ9] \u [] z_sgaJ9 Data.Functor.Product.Pair;
                            } in  k1_sgaJ8 $dData_sgaJ4 sat_sgaJb;
                  } in  k1_sgaJ8 $dData1_sgaJ5 sat_sgaJc; } in
        let {
          sat_sgaJ7 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7
               -> c (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dTypeable_sgaJ0
               $dTypeable1_sgaJ1
               $dTypeable2_sgaJ2
               $dTypeable3_sgaJ3
               $dData_sgaJ4
               $dData1_sgaJ5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Product.$fDataProduct_$cgfoldl
                      $dTypeable_sgaJ0
                      $dTypeable1_sgaJ1
                      $dTypeable2_sgaJ2
                      $dTypeable3_sgaJ3
                      $dData_sgaJ4
                      $dData1_sgaJ5
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sgaJ6 [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Functor.Product.Product f_Xg3PP g_Xg3V4 a_Xg3V7)
          [LclId] =
              [$dTypeable_sgaJ0
               $dTypeable1_sgaJ1
               $dTypeable2_sgaJ2
               $dTypeable3_sgaJ3] \u []
                  Data.Functor.Product.$w$cp1Data
                      $dTypeable_sgaJ0
                      $dTypeable1_sgaJ1
                      $dTypeable2_sgaJ2
                      $dTypeable3_sgaJ3;
        } in 
          Data.Data.C:Data [sat_sgaJ6
                            sat_sgaJ7
                            sat_sgaJd
                            lvl5_rg5oj
                            lvl6_rg5ok
                            lvl7_rg5ol
                            lvl8_rg5om
                            sat_sgaJl
                            sat_sgaJm
                            sat_sgaJn
                            sat_sgaJw
                            sat_sgaJx
                            sat_sgaJy
                            sat_sgaJC
                            sat_sgaJG];

Data.Functor.Product.Pair
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     f a -> g a -> Data.Functor.Product.Product f g a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Product.Pair [eta_B2 eta_B1];

