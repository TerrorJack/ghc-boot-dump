
==================== Pre unarise: ====================
2018-03-16 16:11:46.817051298 UTC

Data.Functor.Sum.$fEq1Sum_$cliftEq
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sfXPx $dEq2_sfXPy eq_sfXPz ds_sfXPA ds1_sfXPB]
        case ds_sfXPA of {
          Data.Functor.Sum.InL x1_sfXPD [Occ=Once] ->
              case ds1_sfXPB of {
                Data.Functor.Sum.InL x2_sfXPF [Occ=Once] ->
                    $dEq1_sfXPx eq_sfXPz x1_sfXPD x2_sfXPF;
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds2_sfXPH [Occ=Once] ->
              case ds1_sfXPB of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sfXPK [Occ=Once] ->
                    $dEq2_sfXPy eq_sfXPz ds2_sfXPH y2_sfXPK;
              };
        };

Data.Functor.Sum.$fEq1Sum [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Sum.$fEq1Sum_$cliftEq
            eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Sum.$fOrd1Sum_$cliftCompare
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g b
     -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXPL $dOrd2_sfXPM comp_sfXPN ds_sfXPO ds1_sfXPP]
        case ds_sfXPO of {
          Data.Functor.Sum.InL x1_sfXPR [Occ=Once] ->
              case ds1_sfXPP of {
                Data.Functor.Sum.InL x2_sfXPT [Occ=Once] ->
                    Data.Functor.Classes.liftCompare
                        $dOrd1_sfXPL comp_sfXPN x1_sfXPR x2_sfXPT;
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Functor.Sum.InR ds2_sfXPV [Occ=Once] ->
              case ds1_sfXPP of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Functor.Sum.InR y2_sfXPY [Occ=Once] ->
                    Data.Functor.Classes.liftCompare
                        $dOrd2_sfXPM comp_sfXPN ds2_sfXPV y2_sfXPY;
              };
        };

Data.Functor.Sum.$fOrd1Sum1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXPZ $dOrd2_sfXQ0 eta_sfXQ1 eta1_sfXQ2 eta2_sfXQ3]
        case eta1_sfXQ2 of {
          Data.Functor.Sum.InL x1_sfXQ5 [Occ=Once] ->
              case eta2_sfXQ3 of {
                Data.Functor.Sum.InL x2_sfXQ7 [Occ=Once] ->
                    Data.Functor.Classes.$p1Ord1
                        $dOrd1_sfXPZ eta_sfXQ1 x1_sfXQ5 x2_sfXQ7;
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds_sfXQ9 [Occ=Once] ->
              case eta2_sfXQ3 of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sfXQc [Occ=Once] ->
                    Data.Functor.Classes.$p1Ord1
                        $dOrd2_sfXQ0 eta_sfXQ1 ds_sfXQ9 y2_sfXQc;
              };
        };

Data.Functor.Sum.$fOrd1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     Data.Functor.Classes.Ord1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(C1(C1(U))),C(C1(C1(U))))>m] =
    [] \r [$dOrd1_sfXQd $dOrd2_sfXQe]
        let {
          sat_sfXQg [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Sum.Sum f_XfX7u g_XfX7w a
               -> Data.Functor.Sum.Sum f_XfX7u g_XfX7w b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sfXQd $dOrd2_sfXQe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrd1Sum_$cliftCompare
                      $dOrd1_sfXQd $dOrd2_sfXQe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXQf [Occ=Once]
            :: Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f_XfX7u g_XfX7w)
          [LclId] =
              [$dOrd1_sfXQd $dOrd2_sfXQe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrd1Sum1
                      $dOrd1_sfXQd $dOrd2_sfXQe eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sfXQf sat_sfXQg];

Data.Functor.Sum.$fRead1Sum8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "InL"#;

Data.Functor.Sum.$fRead1Sum7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Functor.Sum.$fRead1Sum8;

Data.Functor.Sum.$fRead1Sum4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "InR"#;

Data.Functor.Sum.$fRead1Sum3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Functor.Sum.$fRead1Sum4;

Data.Functor.Sum.$fRead1Sum2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Sum.$fRead1Sum3];

Data.Functor.Sum.$fRead1Sum5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Sum.$fRead1Sum6 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Sum.$fRead1Sum7];

Data.Functor.Sum.$fRead1Sum1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Sum.Sum f g a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXQh $dRead2_sfXQi rp_sfXQj rl_sfXQk]
        let {
          ds_sfXQl [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_afX4G a_afX54)
          [LclId] =
              [$dRead1_sfXQh rp_sfXQj rl_sfXQk] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead1_sfXQh rp_sfXQj rl_sfXQk; } in
        let {
          ds1_sfXQm [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (g_afX4H a_afX54)
          [LclId] =
              [$dRead2_sfXQi rp_sfXQj rl_sfXQk] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead2_sfXQi rp_sfXQj rl_sfXQk; } in
        let {
          $wlvl_sfXQn [InlPrag=NOUSERINLINE[0], Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: GHC.Prim.Int#
               -> forall b.
                  (Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [ds_sfXQl ds1_sfXQm] \r [ww_sfXQo w_sfXQp]
                  case <=# [ww_sfXQo 10#] of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                    1# ->
                        let {
                          sat_sfXQv [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_sfXzb
                          [LclId] =
                              [ds_sfXQl w_sfXQp] \r [a1_sfXQr]
                                  let {
                                    sat_sfXQu [Occ=Once]
                                      :: f_afX4G a_afX54 -> Text.ParserCombinators.ReadP.P b_sfXzb
                                    [LclId] =
                                        [w_sfXQp] \r [a2_sfXQs]
                                            let {
                                              sat_sfXQt [Occ=Once]
                                                :: Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                                              [LclId] =
                                                  CCCS Data.Functor.Sum.InL! [a2_sfXQs];
                                            } in  w_sfXQp sat_sfXQt;
                                  } in  ds_sfXQl Data.Functor.Sum.$fRead1Sum5 sat_sfXQu;
                        } in 
                          case
                              Text.Read.Lex.$wexpect Data.Functor.Sum.$fRead1Sum6 sat_sfXQv
                          of
                          { Unit# ww2_sfXQx [Occ=Once] ->
                                let {
                                  sat_sfXQG [Occ=Once] :: Text.ParserCombinators.ReadP.P b_sfXzb
                                  [LclId] =
                                      [ds1_sfXQm w_sfXQp] \u []
                                          let {
                                            sat_sfXQD [Occ=Once]
                                              :: () -> Text.ParserCombinators.ReadP.P b_sfXzb
                                            [LclId] =
                                                [ds1_sfXQm w_sfXQp] \r [a1_sfXQz]
                                                    let {
                                                      sat_sfXQC [Occ=Once]
                                                        :: g_afX4H a_afX54
                                                           -> Text.ParserCombinators.ReadP.P b_sfXzb
                                                      [LclId] =
                                                          [w_sfXQp] \r [a2_sfXQA]
                                                              let {
                                                                sat_sfXQB [Occ=Once]
                                                                  :: Data.Functor.Sum.Sum
                                                                       f_afX4G g_afX4H a_afX54
                                                                [LclId] =
                                                                    CCCS Data.Functor.Sum.InR! [a2_sfXQA];
                                                              } in  w_sfXQp sat_sfXQB;
                                                    } in 
                                                      ds1_sfXQm
                                                          Data.Functor.Sum.$fRead1Sum5 sat_sfXQC;
                                          } in 
                                            case
                                                Text.Read.Lex.$wexpect
                                                    Data.Functor.Sum.$fRead1Sum2 sat_sfXQD
                                            of
                                            { Unit# ww4_sfXQF [Occ=Once] ->
                                                  Text.ParserCombinators.ReadP.Look [ww4_sfXQF];
                                            }; } in
                                let {
                                  sat_sfXQy [Occ=Once] :: Text.ParserCombinators.ReadP.P b_sfXzb
                                  [LclId] =
                                      CCCS Text.ParserCombinators.ReadP.Look! [ww2_sfXQx];
                                } in 
                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                      sat_sfXQy sat_sfXQG;
                          };
                  }; } in
        let {
          lvl8_sfXQH [InlPrag=NOUSERINLINE[0], Occ=OnceL, Dmd=<L,C(C(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
              [$wlvl_sfXQn] \r [w_sfXQI w1_sfXQJ]
                  case w_sfXQI of {
                    GHC.Types.I# ww1_sfXQL [Occ=Once] ->
                        $wlvl_sfXQn ww1_sfXQL w1_sfXQJ;
                  }; } in
        let {
          sat_sfXQO [Occ=OnceT[0]]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [lvl8_sfXQH] \r [eta_sfXQM eta1_sfXQN]
                  GHC.Read.list3 lvl8_sfXQH eta_sfXQM eta1_sfXQN;
        } in  sat_sfXQO;

Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXQP $dRead2_sfXQQ rp_sfXQR rl_sfXQS]
        let {
          ds_sfXQT [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_XfX6H g_XfX6J a_afX4N
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead1_sfXQP $dRead2_sfXQQ rp_sfXQR rl_sfXQS] \u []
                  let {
                    sat_sfXQZ [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_afX4N]
                    [LclId] =
                        [rl_sfXQS] \r [n_sfXQV w1_sfXQW]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sfXQS w1_sfXQW
                            of
                            { Unit# ww1_sfXQY [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sfXQY];
                            }; } in
                  let {
                    sat_sfXQU [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_afX4N
                    [LclId] =
                        [rp_sfXQR] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sfXQR eta_B1;
                  } in 
                    Data.Functor.Sum.$fRead1Sum1
                        $dRead1_sfXQP $dRead2_sfXQQ sat_sfXQU sat_sfXQZ; } in
        let {
          sat_sfXR2 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX6H g_XfX6J a_afX4N)
          [LclId] =
              [ds_sfXQT] \r [n_sfXR0]
                  let {
                    sat_sfXR1 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Sum.Sum f_XfX6H g_XfX6J a_afX4N)
                    [LclId] =
                        [ds_sfXQT n_sfXR0] \u []
                            ds_sfXQT
                                n_sfXR0 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfXR1;
        } in  sat_sfXR2;

Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXR3 $dRead2_sfXR4 rp_sfXR5 rl_sfXR6]
        let {
          sat_sfXR7 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Sum.Sum f_XfX6F g_XfX6H a_afX5y)
          [LclId] =
              [$dRead1_sfXR3 $dRead2_sfXR4 rp_sfXR5 rl_sfXR6] \s []
                  Data.Functor.Sum.$fRead1Sum1
                      $dRead1_sfXR3 $dRead2_sfXR4 rp_sfXR5 rl_sfXR6;
        } in  GHC.Read.list sat_sfXR7;

Data.Functor.Sum.$fRead1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     Data.Functor.Classes.Read1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>m] =
    [] \r [$dRead1_sfXR8 $dRead2_sfXR9]
        let {
          sat_sfXRd [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Sum.Sum f_XfX6E g_XfX6G a]
          [LclId] =
              [$dRead1_sfXR8 $dRead2_sfXR9] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec
                      $dRead1_sfXR8 $dRead2_sfXR9 eta_B2 eta_B1; } in
        let {
          sat_sfXRc [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Sum.Sum f_XfX6E g_XfX6G a)
          [LclId] =
              [$dRead1_sfXR8 $dRead2_sfXR9] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fRead1Sum1
                      $dRead1_sfXR8 $dRead2_sfXR9 eta_B2 eta_B1; } in
        let {
          sat_sfXRb [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Sum.Sum f_XfX6E g_XfX6G a]
          [LclId] =
              [$dRead1_sfXR8 $dRead2_sfXR9] \u []
                  Data.Functor.Sum.$fRead1Sum_$cliftReadList
                      $dRead1_sfXR8 $dRead2_sfXR9; } in
        let {
          sat_sfXRa [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX6E g_XfX6G a)
          [LclId] =
              [$dRead1_sfXR8 $dRead2_sfXR9] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec
                      $dRead1_sfXR8 $dRead2_sfXR9 eta_B2 eta_B1;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sfXRa
                                        sat_sfXRb
                                        sat_sfXRc
                                        sat_sfXRd];
Data.Functor.Sum.$fRead1Sum_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXRe $dRead2_sfXRf]
        let {
          sat_sfXRg [Occ=Once]
            :: Data.Functor.Classes.Read1
                 (Data.Functor.Sum.Sum f_XfX6G g_XfX6I)
          [LclId] =
              [$dRead1_sfXRe $dRead2_sfXRf] \u []
                  Data.Functor.Sum.$fRead1Sum $dRead1_sfXRe $dRead2_sfXRf;
        } in  Data.Functor.Classes.liftReadListDefault sat_sfXRg;

Data.Functor.Sum.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> Data.Functor.Sum.Sum f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfXRh w1_sfXRi w2_sfXRj w3_sfXRk ww_sfXRl w4_sfXRm]
        case w4_sfXRm of {
          Data.Functor.Sum.InL x_sfXRo [Occ=Once] ->
              let {
                sat_sfXRp [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> f_sfXzA a_sfXzE -> GHC.Show.ShowS
                [LclId] =
                    [w_sfXRh w2_sfXRj w3_sfXRk] \s []
                        Data.Functor.Classes.liftShowsPrec w_sfXRh w2_sfXRj w3_sfXRk;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sfXRp Data.Functor.Sum.$fRead1Sum7 ww_sfXRl x_sfXRo;
          Data.Functor.Sum.InR y_sfXRq [Occ=Once] ->
              let {
                sat_sfXRr [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> g_sfXzB a_sfXzE -> GHC.Show.ShowS
                [LclId] =
                    [w1_sfXRi w2_sfXRj w3_sfXRk] \s []
                        Data.Functor.Classes.liftShowsPrec w1_sfXRi w2_sfXRj w3_sfXRk;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sfXRr Data.Functor.Sum.$fRead1Sum3 ww_sfXRl y_sfXRq;
        };

Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Sum.Sum f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfXRs w1_sfXRt w2_sfXRu w3_sfXRv w4_sfXRw w5_sfXRx]
        case w4_sfXRw of {
          GHC.Types.I# ww1_sfXRz [Occ=Once] ->
              Data.Functor.Sum.$w$cliftShowsPrec
                  w_sfXRs w1_sfXRt w2_sfXRu w3_sfXRv ww1_sfXRz w5_sfXRx;
        };

Data.Functor.Sum.$fFoldableSum6 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Sum.$fShow1Sum_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Sum.Sum f g a]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U><L,U><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sfXRA
           $dShow2_sfXRB
           sp_sfXRC
           sl_sfXRD
           eta_sfXRE
           eta1_sfXRF]
        let {
          sat_sfXRH [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX4e g_afX4f a_afX4z -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sfXRA $dShow2_sfXRB sp_sfXRC sl_sfXRD] \r [w_sfXRG]
                  Data.Functor.Sum.$w$cliftShowsPrec
                      $dShow1_sfXRA $dShow2_sfXRB sp_sfXRC sl_sfXRD 0# w_sfXRG;
        } in  GHC.Show.showList__ sat_sfXRH eta_sfXRE eta1_sfXRF;

Data.Functor.Sum.$fShow1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     Data.Functor.Classes.Show1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)>m] =
    [] \r [$dShow1_sfXRI $dShow2_sfXRJ]
        let {
          sat_sfXRL [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Sum.Sum f_afX4e g_afX4f a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sfXRI $dShow2_sfXRJ] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fShow1Sum_$cliftShowList
                      $dShow1_sfXRI $dShow2_sfXRJ eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXRK [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Sum.Sum f_afX4e g_afX4f a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sfXRI $dShow2_sfXRJ] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec
                      $dShow1_sfXRI $dShow2_sfXRJ eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sfXRK sat_sfXRL];

Data.Functor.Sum.$fEqSum_$c==
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sfXRM $dEq2_sfXRN $dEq_sfXRO eta_sfXRP eta1_sfXRQ]
        let {
          sat_sfXRR [Occ=Once] :: a_afX3V -> a_afX3V -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfXRO] \u [] GHC.Classes.== $dEq_sfXRO;
        } in 
          Data.Functor.Sum.$fEq1Sum_$cliftEq
              $dEq1_sfXRM $dEq2_sfXRN sat_sfXRR eta_sfXRP eta1_sfXRQ;

Data.Functor.Sum.$fEqSum_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sfXRS $dEq2_sfXRT $dEq_sfXRU eta_sfXRV eta1_sfXRW]
        case eta_sfXRV of {
          Data.Functor.Sum.InL x1_sfXRY [Occ=Once] ->
              case eta1_sfXRW of {
                Data.Functor.Sum.InL x2_sfXS0 [Occ=Once] ->
                    let {
                      sat_sfXS1 [Occ=Once] :: a_afX3V -> a_afX3V -> GHC.Types.Bool
                      [LclId] =
                          [$dEq_sfXRU] \u [] GHC.Classes.== $dEq_sfXRU;
                    } in 
                      case $dEq1_sfXRS sat_sfXS1 x1_sfXRY x2_sfXS0 of {
                        GHC.Types.False -> GHC.Types.True [];
                        GHC.Types.True -> GHC.Types.False [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Functor.Sum.InR ds_sfXS4 [Occ=Once] ->
              case eta1_sfXRW of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.True [];
                Data.Functor.Sum.InR y2_sfXS7 [Occ=Once] ->
                    let {
                      sat_sfXS8 [Occ=Once] :: a_afX3V -> a_afX3V -> GHC.Types.Bool
                      [LclId] =
                          [$dEq_sfXRU] \u [] GHC.Classes.== $dEq_sfXRU;
                    } in 
                      case $dEq2_sfXRT sat_sfXS8 ds_sfXS4 y2_sfXS7 of {
                        GHC.Types.False -> GHC.Types.True [];
                        GHC.Types.True -> GHC.Types.False [];
                      };
              };
        };

Data.Functor.Sum.$fEqSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     GHC.Classes.Eq (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><L,U(U,A)>m] =
    [] \r [$dEq1_sfXSa $dEq2_sfXSb $dEq_sfXSc]
        let {
          sat_sfXSe [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V
               -> Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sfXSa $dEq2_sfXSb $dEq_sfXSc] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fEqSum_$c/=
                      $dEq1_sfXSa $dEq2_sfXSb $dEq_sfXSc eta_B2 eta_B1; } in
        let {
          sat_sfXSd [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V
               -> Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sfXSa $dEq2_sfXSb $dEq_sfXSc] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fEqSum_$c==
                      $dEq1_sfXSa $dEq2_sfXSb $dEq_sfXSc eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sfXSd sat_sfXSe];

Data.Functor.Sum.$fOrdSum_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXSf $dOrd2_sfXSg $dOrd_sfXSh eta_sfXSi eta1_sfXSj]
        let {
          sat_sfXSk [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfXSh] \u [] GHC.Classes.compare $dOrd_sfXSh;
        } in 
          Data.Functor.Sum.$fOrd1Sum_$cliftCompare
              $dOrd1_sfXSf $dOrd2_sfXSg sat_sfXSk eta_sfXSi eta1_sfXSj;

Data.Functor.Sum.$fOrdSum_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Eq (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXSl $dOrd2_sfXSm $dOrd_sfXSn]
        let {
          sat_sfXSq [Occ=Once, Dmd=<L,U(U,A)>] :: GHC.Classes.Eq a_afX37
          [LclId] =
              [$dOrd_sfXSn] \u [] GHC.Classes.$p1Ord $dOrd_sfXSn; } in
        let {
          sat_sfXSp [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 g_afX36
          [LclId] =
              [$dOrd2_sfXSm] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sfXSm; } in
        let {
          sat_sfXSo [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 f_afX35
          [LclId] =
              [$dOrd1_sfXSl] \u [] Data.Functor.Classes.$p1Ord1 $dOrd1_sfXSl;
        } in  Data.Functor.Sum.$fEqSum sat_sfXSo sat_sfXSp sat_sfXSq;

Data.Functor.Sum.$fOrdSum_$c<
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXSr $dOrd2_sfXSs $dOrd_sfXSt x_sfXSu y_sfXSv]
        case x_sfXSu of {
          Data.Functor.Sum.InL x1_sfXSx [Occ=Once] ->
              case y_sfXSv of {
                Data.Functor.Sum.InL x2_sfXSz [Occ=Once] ->
                    let {
                      sat_sfXSA [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXSt] \u [] GHC.Classes.compare $dOrd_sfXSt;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sfXSr sat_sfXSA x1_sfXSx x2_sfXSz
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.LT -> GHC.Types.True [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Functor.Sum.InR ds_sfXSD [Occ=Once] ->
              case y_sfXSv of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sfXSG [Occ=Once] ->
                    let {
                      sat_sfXSH [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXSt] \u [] GHC.Classes.compare $dOrd_sfXSt;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sfXSs sat_sfXSH ds_sfXSD y2_sfXSG
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.LT -> GHC.Types.True [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$c>=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXSJ $dOrd2_sfXSK $dOrd_sfXSL x_sfXSM y_sfXSN]
        case x_sfXSM of {
          Data.Functor.Sum.InL x1_sfXSP [Occ=Once] ->
              case y_sfXSN of {
                Data.Functor.Sum.InL x2_sfXSR [Occ=Once] ->
                    let {
                      sat_sfXSS [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXSL] \u [] GHC.Classes.compare $dOrd_sfXSL;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sfXSJ sat_sfXSS x1_sfXSP x2_sfXSR
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.LT -> GHC.Types.False [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds_sfXSV [Occ=Once] ->
              case y_sfXSN of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.True [];
                Data.Functor.Sum.InR y2_sfXSY [Occ=Once] ->
                    let {
                      sat_sfXSZ [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXSL] \u [] GHC.Classes.compare $dOrd_sfXSL;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sfXSK sat_sfXSZ ds_sfXSV y2_sfXSY
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.LT -> GHC.Types.False [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$c>
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXT1 $dOrd2_sfXT2 $dOrd_sfXT3 x_sfXT4 y_sfXT5]
        case x_sfXT4 of {
          Data.Functor.Sum.InL x1_sfXT7 [Occ=Once] ->
              case y_sfXT5 of {
                Data.Functor.Sum.InL x2_sfXT9 [Occ=Once] ->
                    let {
                      sat_sfXTa [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXT3] \u [] GHC.Classes.compare $dOrd_sfXT3;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sfXT1 sat_sfXTa x1_sfXT7 x2_sfXT9
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.GT -> GHC.Types.True [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds_sfXTd [Occ=Once] ->
              case y_sfXT5 of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.True [];
                Data.Functor.Sum.InR y2_sfXTg [Occ=Once] ->
                    let {
                      sat_sfXTh [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXT3] \u [] GHC.Classes.compare $dOrd_sfXT3;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sfXT2 sat_sfXTh ds_sfXTd y2_sfXTg
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.GT -> GHC.Types.True [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$c<=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXTj $dOrd2_sfXTk $dOrd_sfXTl x_sfXTm y_sfXTn]
        case x_sfXTm of {
          Data.Functor.Sum.InL x1_sfXTp [Occ=Once] ->
              case y_sfXTn of {
                Data.Functor.Sum.InL x2_sfXTr [Occ=Once] ->
                    let {
                      sat_sfXTs [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXTl] \u [] GHC.Classes.compare $dOrd_sfXTl;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sfXTj sat_sfXTs x1_sfXTp x2_sfXTr
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.GT -> GHC.Types.False [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Functor.Sum.InR ds_sfXTv [Occ=Once] ->
              case y_sfXTn of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sfXTy [Occ=Once] ->
                    let {
                      sat_sfXTz [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXTl] \u [] GHC.Classes.compare $dOrd_sfXTl;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sfXTk sat_sfXTz ds_sfXTv y2_sfXTy
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.GT -> GHC.Types.False [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXTB $dOrd2_sfXTC $dOrd_sfXTD x_sfXTE y_sfXTF]
        case
            Data.Functor.Sum.$fOrdSum_$c<=
                $dOrd1_sfXTB $dOrd2_sfXTC $dOrd_sfXTD x_sfXTE y_sfXTF
        of
        { GHC.Types.False -> x_sfXTE;
          GHC.Types.True -> y_sfXTF;
        };

Data.Functor.Sum.$fOrdSum_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXTH $dOrd2_sfXTI $dOrd_sfXTJ x_sfXTK y_sfXTL]
        case
            Data.Functor.Sum.$fOrdSum_$c<=
                $dOrd1_sfXTH $dOrd2_sfXTI $dOrd_sfXTJ x_sfXTK y_sfXTL
        of
        { GHC.Types.False -> y_sfXTL;
          GHC.Types.True -> x_sfXTK;
        };

Data.Functor.Sum.$fOrdSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Ord (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m] =
    [] \r [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP]
        let {
          sat_sfXTX [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$cmin
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTW [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$cmax
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTV [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c>=
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTU [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c>
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTT [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c<=
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTS [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c<
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTR [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$ccompare
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTQ [Occ=Once]
            :: GHC.Classes.Eq (Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37)
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \u []
                  Data.Functor.Sum.$fOrdSum_$cp1Ord
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP;
        } in 
          GHC.Classes.C:Ord [sat_sfXTQ
                             sat_sfXTR
                             sat_sfXTS
                             sat_sfXTT
                             sat_sfXTU
                             sat_sfXTV
                             sat_sfXTW
                             sat_sfXTX];

Data.Functor.Sum.$fReadSum1
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Sum.Sum f g a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXTY $dRead2_sfXTZ $dRead_sfXU0]
        let {
          sat_sfXU2 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_afX2A]
          [LclId] =
              [$dRead_sfXU0] \u [] GHC.Read.readListPrec $dRead_sfXU0; } in
        let {
          sat_sfXU1 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_afX2A
          [LclId] =
              [$dRead_sfXU0] \u [] GHC.Read.readPrec $dRead_sfXU0;
        } in 
          Data.Functor.Sum.$fRead1Sum1
              $dRead1_sfXTY $dRead2_sfXTZ sat_sfXU1 sat_sfXU2;

Data.Functor.Sum.$fReadSum_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXU3 $dRead2_sfXU4 $dRead_sfXU5]
        let {
          ds_sfXU6 [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_XfX50 g_XfX52 a_XfX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead1_sfXU3 $dRead2_sfXU4 $dRead_sfXU5] \u []
                  let {
                    sat_sfXU8 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_XfX54]
                    [LclId] =
                        [$dRead_sfXU5] \u [] GHC.Read.readListPrec $dRead_sfXU5; } in
                  let {
                    sat_sfXU7 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_XfX54
                    [LclId] =
                        [$dRead_sfXU5] \u [] GHC.Read.readPrec $dRead_sfXU5;
                  } in 
                    Data.Functor.Sum.$fRead1Sum1
                        $dRead1_sfXU3 $dRead2_sfXU4 sat_sfXU7 sat_sfXU8; } in
        let {
          sat_sfXUb [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX50 g_XfX52 a_XfX54)
          [LclId] =
              [ds_sfXU6] \r [n_sfXU9]
                  let {
                    sat_sfXUa [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Sum.Sum f_XfX50 g_XfX52 a_XfX54)
                    [LclId] =
                        [ds_sfXU6 n_sfXU9] \u []
                            ds_sfXU6
                                n_sfXU9 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfXUa;
        } in  sat_sfXUb;

Data.Functor.Sum.$fReadSum_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXUc $dRead2_sfXUd $dRead_sfXUe]
        let {
          sat_sfXUh [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Sum.Sum f_XfX4Y g_XfX50 a_XfX52)
          [LclId] =
              [$dRead1_sfXUc $dRead2_sfXUd $dRead_sfXUe] \s []
                  let {
                    sat_sfXUg [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_XfX52]
                    [LclId] =
                        [$dRead_sfXUe] \u [] GHC.Read.readListPrec $dRead_sfXUe; } in
                  let {
                    sat_sfXUf [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_XfX52
                    [LclId] =
                        [$dRead_sfXUe] \u [] GHC.Read.readPrec $dRead_sfXUe;
                  } in 
                    Data.Functor.Sum.$fRead1Sum1
                        $dRead1_sfXUc $dRead2_sfXUd sat_sfXUf sat_sfXUg;
        } in  GHC.Read.list sat_sfXUh;

Data.Functor.Sum.$fReadSum_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadP.ReadS [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXUi $dRead2_sfXUj $dRead_sfXUk]
        let {
          sat_sfXUl [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Sum.Sum f_XfX4Z g_XfX51 a_XfX53]
          [LclId] =
              [$dRead1_sfXUi $dRead2_sfXUj $dRead_sfXUk] \u []
                  Data.Functor.Sum.$fReadSum_$creadListPrec
                      $dRead1_sfXUi
                      $dRead2_sfXUj
                      $dRead_sfXUk
                      GHC.Read.$fRead()7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfXUl;

Data.Functor.Sum.$fReadSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Read.Read (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,U,U)>m] =
    [] \r [$dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo]
        let {
          sat_sfXUs [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51]
          [LclId] =
              [$dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo] \u []
                  Data.Functor.Sum.$fReadSum_$creadListPrec
                      $dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo; } in
        let {
          sat_sfXUr [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51)
          [LclId] =
              [$dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo] \u []
                  Data.Functor.Sum.$fReadSum1
                      $dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo; } in
        let {
          sat_sfXUq [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51]
          [LclId] =
              [$dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo] \u []
                  Data.Functor.Sum.$fReadSum_$creadList
                      $dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo; } in
        let {
          sat_sfXUp [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51)
          [LclId] =
              [$dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo] \u []
                  Data.Functor.Sum.$fReadSum_$creadsPrec
                      $dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo;
        } in  GHC.Read.C:Read [sat_sfXUp sat_sfXUq sat_sfXUr sat_sfXUs];

Data.Functor.Sum.$fShowSum_$cshowsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Types.Int -> Data.Functor.Sum.Sum f g a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sfXUt
           $dShow2_sfXUu
           $dShow_sfXUv
           eta_sfXUw
           eta1_sfXUx]
        case eta_sfXUw of {
          GHC.Types.I# ww1_sfXUz [Occ=Once] ->
              let {
                sat_sfXUB [Occ=Once] :: [a_afX2a] -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sfXUv] \u [] GHC.Show.showList $dShow_sfXUv; } in
              let {
                sat_sfXUA [Occ=Once] :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sfXUv] \u [] GHC.Show.showsPrec $dShow_sfXUv;
              } in 
                Data.Functor.Sum.$w$cliftShowsPrec
                    $dShow1_sfXUt
                    $dShow2_sfXUu
                    sat_sfXUA
                    sat_sfXUB
                    ww1_sfXUz
                    eta1_sfXUx;
        };

Data.Functor.Sum.$fShowSum_$cshow
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     Data.Functor.Sum.Sum f g a -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*U,A,1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sfXUC $dShow2_sfXUD $dShow_sfXUE x_sfXUF]
        case x_sfXUF of {
          Data.Functor.Sum.InL x1_sfXUH [Occ=Once] ->
              let {
                sat_sfXUK [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow1_sfXUC $dShow_sfXUE x1_sfXUH] \u []
                        let {
                          sat_sfXUJ [Occ=Once] :: [a_afX2a] -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sfXUE] \u [] GHC.Show.showList $dShow_sfXUE; } in
                        let {
                          sat_sfXUI [Occ=Once] :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sfXUE] \u [] GHC.Show.showsPrec $dShow_sfXUE;
                        } in 
                          Data.Functor.Classes.liftShowsPrec
                              $dShow1_sfXUC
                              sat_sfXUI
                              sat_sfXUJ
                              Data.Functor.Classes.$fRead1Const1
                              x1_sfXUH
                              GHC.Types.[]; } in
              let {
                sat_sfXUL [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sfXUK];
              } in  GHC.Base.++ Data.Functor.Sum.$fRead1Sum7 sat_sfXUL;
          Data.Functor.Sum.InR y_sfXUM [Occ=Once] ->
              let {
                sat_sfXUP [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow2_sfXUD $dShow_sfXUE y_sfXUM] \u []
                        let {
                          sat_sfXUO [Occ=Once] :: [a_afX2a] -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sfXUE] \u [] GHC.Show.showList $dShow_sfXUE; } in
                        let {
                          sat_sfXUN [Occ=Once] :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sfXUE] \u [] GHC.Show.showsPrec $dShow_sfXUE;
                        } in 
                          Data.Functor.Classes.liftShowsPrec
                              $dShow2_sfXUD
                              sat_sfXUN
                              sat_sfXUO
                              Data.Functor.Classes.$fRead1Const1
                              y_sfXUM
                              GHC.Types.[]; } in
              let {
                sat_sfXUQ [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sfXUP];
              } in  GHC.Base.++ Data.Functor.Sum.$fRead1Sum3 sat_sfXUQ;
        };

Data.Functor.Sum.$fShowSum_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     [Data.Functor.Sum.Sum f g a] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sfXUR $dShow2_sfXUS $dShow_sfXUT ls_sfXUU s_sfXUV]
        let {
          lvl8_sfXUW [Occ=OnceL]
            :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfXUT] \u [] GHC.Show.showsPrec $dShow_sfXUT; } in
        let {
          lvl9_sfXUX [Occ=OnceL] :: [a_afX2a] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfXUT] \u [] GHC.Show.showList $dShow_sfXUT; } in
        let {
          sat_sfXUZ [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sfXUR $dShow2_sfXUS lvl8_sfXUW lvl9_sfXUX] \r [eta_sfXUY]
                  Data.Functor.Sum.$w$cliftShowsPrec
                      $dShow1_sfXUR $dShow2_sfXUS lvl8_sfXUW lvl9_sfXUX 0# eta_sfXUY;
        } in  GHC.Show.showList__ sat_sfXUZ ls_sfXUU s_sfXUV;

Data.Functor.Sum.$fShowSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Show.Show (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(U,A,U)>m] =
    [] \r [$dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2]
        let {
          sat_sfXV5 [Occ=Once]
            :: [Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a] -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fShowSum_$cshowList
                      $dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2 eta_B2 eta_B1; } in
        let {
          sat_sfXV4 [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a -> GHC.Base.String
          [LclId] =
              [$dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2] \r [eta_B1]
                  Data.Functor.Sum.$fShowSum_$cshow
                      $dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2 eta_B1; } in
        let {
          sat_sfXV3 [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fShowSum_$cshowsPrec
                      $dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfXV3 sat_sfXV4 sat_sfXV5];

Data.Functor.Sum.$fFunctorSum_$cfmap
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Sum.Sum f g a -> Data.Functor.Sum.Sum f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sfXV6 $dFunctor1_sfXV7 f1_sfXV8 ds_sfXV9]
        case ds_sfXV9 of {
          Data.Functor.Sum.InL x_sfXVb [Occ=Once] ->
              let {
                sat_sfXVc [Occ=Once] :: f_afX1v b_afX1D
                [LclId] =
                    [$dFunctor_sfXV6 f1_sfXV8 x_sfXVb] \u []
                        GHC.Base.fmap $dFunctor_sfXV6 f1_sfXV8 x_sfXVb;
              } in  Data.Functor.Sum.InL [sat_sfXVc];
          Data.Functor.Sum.InR y_sfXVd [Occ=Once] ->
              let {
                sat_sfXVe [Occ=Once] :: g_afX1w b_afX1D
                [LclId] =
                    [$dFunctor1_sfXV7 f1_sfXV8 y_sfXVd] \u []
                        GHC.Base.fmap $dFunctor1_sfXV7 f1_sfXV8 y_sfXVd;
              } in  Data.Functor.Sum.InR [sat_sfXVe];
        };

Data.Functor.Sum.$fFunctorSum_$c<$
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     a -> Data.Functor.Sum.Sum f g b -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sfXVf $dFunctor1_sfXVg x_sfXVh eta_sfXVi]
        let {
          sat_sfXVk [Occ=Once] :: b_afX20 -> a_afX1Z
          [LclId] =
              [x_sfXVh] \r [ds_sfXVj] x_sfXVh;
        } in 
          Data.Functor.Sum.$fFunctorSum_$cfmap
              $dFunctor_sfXVf $dFunctor1_sfXVg sat_sfXVk eta_sfXVi;

Data.Functor.Sum.$fFunctorSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     GHC.Base.Functor (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dFunctor_sfXVl $dFunctor1_sfXVm]
        let {
          sat_sfXVo [Occ=Once]
            :: forall a b.
               a
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w b
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w a
          [LclId] =
              [$dFunctor_sfXVl $dFunctor1_sfXVm] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFunctorSum_$c<$
                      $dFunctor_sfXVl $dFunctor1_sfXVm eta_B2 eta_B1; } in
        let {
          sat_sfXVn [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w a
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w b
          [LclId] =
              [$dFunctor_sfXVl $dFunctor1_sfXVm] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFunctorSum_$cfmap
                      $dFunctor_sfXVl $dFunctor1_sfXVm eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sfXVn sat_sfXVo];

Data.Functor.Sum.$fFoldableSum_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Functor.Sum.Sum f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXVp
           $dFoldable1_sfXVq
           $dMonoid_sfXVr
           f1_sfXVs
           ds_sfXVt]
        case ds_sfXVt of {
          Data.Functor.Sum.InL x_sfXVv [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_sfXVp $dMonoid_sfXVr f1_sfXVs x_sfXVv;
          Data.Functor.Sum.InR y_sfXVw [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_sfXVq $dMonoid_sfXVr f1_sfXVs y_sfXVw;
        };

Data.Functor.Sum.$fFoldableSum_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => Data.Functor.Sum.Sum f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXVx $dFoldable1_sfXVy $dMonoid_sfXVz ds_sfXVA]
        case ds_sfXVA of {
          Data.Functor.Sum.InL x_sfXVC [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_sfXVx $dMonoid_sfXVz GHC.Base.id x_sfXVC;
          Data.Functor.Sum.InR y_sfXVD [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_sfXVy $dMonoid_sfXVz GHC.Base.id y_sfXVD;
        };

Data.Functor.Sum.$fFoldableSum2 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfXVE] v_sfXVE;

Data.Functor.Sum.$fFoldableSum3
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     Data.Functor.Sum.Sum f g a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXVF $dFoldable1_sfXVG $dNum_sfXVH]
        let {
          $dMonoid_sfXVI [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_afX1c)
          [LclId] =
              [$dNum_sfXVH] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sfXVH; } in
        let {
          sat_sfXVN [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_XfX1N g_XfX1P a_afX1c
               -> Data.Semigroup.Internal.Sum a_afX1c
          [LclId] =
              [$dFoldable_sfXVF $dFoldable1_sfXVG $dMonoid_sfXVI] \r [ds_sfXVJ]
                  case ds_sfXVJ of {
                    Data.Functor.Sum.InL x_sfXVL [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_sfXVF
                            $dMonoid_sfXVI
                            Data.Functor.Sum.$fFoldableSum2
                            x_sfXVL;
                    Data.Functor.Sum.InR y_sfXVM [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_sfXVG
                            $dMonoid_sfXVI
                            Data.Functor.Sum.$fFoldableSum2
                            y_sfXVM;
                  };
        } in  sat_sfXVN;

lvl_rfXP1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Functor.Sum.$fFoldableSum4 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rfXP1 of sat_sfXVO {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfXVO;
        };

Data.Functor.Sum.$fFoldableSum_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXVP $dFoldable1_sfXVQ $dOrd_sfXVR]
        let {
          g1_sfXVS [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_afX12)
          [LclId] =
              [$dOrd_sfXVR] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_sfXVR; } in
        let {
          sat_sfXW1 [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_XfX1M g_XfX1O a_afX12 -> a_afX12
          [LclId] =
              [$dFoldable_sfXVP $dFoldable1_sfXVQ g1_sfXVS] \r [x_sfXVT]
                  case x_sfXVT of {
                    Data.Functor.Sum.InL x1_sfXVV [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_sfXVP g1_sfXVS GHC.Base.Just x1_sfXVV
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum4;
                          GHC.Base.Just v_sfXVX [Occ=Once] -> v_sfXVX;
                        };
                    Data.Functor.Sum.InR y_sfXVY [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sfXVQ g1_sfXVS GHC.Base.Just y_sfXVY
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum4;
                          GHC.Base.Just v_sfXW0 [Occ=Once] -> v_sfXW0;
                        };
                  };
        } in  sat_sfXW1;

lvl1_rfXP2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Functor.Sum.$fFoldableSum5 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rfXP2 of sat_sfXW2 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfXW2;
        };

Data.Functor.Sum.$fFoldableSum_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXW3 $dFoldable1_sfXW4 $dOrd_sfXW5]
        let {
          g1_sfXW6 [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_afX0S)
          [LclId] =
              [$dOrd_sfXW5] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_sfXW5; } in
        let {
          sat_sfXWf [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_XfX1L g_XfX1N a_afX0S -> a_afX0S
          [LclId] =
              [$dFoldable_sfXW3 $dFoldable1_sfXW4 g1_sfXW6] \r [x_sfXW7]
                  case x_sfXW7 of {
                    Data.Functor.Sum.InL x1_sfXW9 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_sfXW3 g1_sfXW6 GHC.Base.Just x1_sfXW9
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum5;
                          GHC.Base.Just v_sfXWb [Occ=Once] -> v_sfXWb;
                        };
                    Data.Functor.Sum.InR y_sfXWc [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sfXW4 g1_sfXW6 GHC.Base.Just y_sfXWc
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum5;
                          GHC.Base.Just v_sfXWe [Occ=Once] -> v_sfXWe;
                        };
                  };
        } in  sat_sfXWf;

Data.Functor.Sum.$fFoldableSum_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXWg $dFoldable1_sfXWh $dEq_sfXWi eta_sfXWj]
        let {
          f1_sfXWk [Occ=OnceL*] :: a_afX0I -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfXWi eta_sfXWj] \u []
                  GHC.Classes.== $dEq_sfXWi eta_sfXWj; } in
        let {
          sat_sfXWp [Occ=Once]
            :: Data.Functor.Sum.Sum f_XfX1K g_XfX1M a_afX0I
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_sfXWg $dFoldable1_sfXWh f1_sfXWk] \r [ds_sfXWl]
                  case ds_sfXWl of {
                    Data.Functor.Sum.InL x_sfXWn [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_sfXWg
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_sfXWk
                            x_sfXWn;
                    Data.Functor.Sum.InR y_sfXWo [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_sfXWh
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_sfXWk
                            y_sfXWo;
                  };
        } in  sat_sfXWp;

Data.Functor.Sum.$fFoldableSum10
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Functor.Sum.$fFoldableSum_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXWq
           $dFoldable1_sfXWr
           f1_sfXWs
           z_sfXWt
           t1_sfXWu]
        let {
          f2_sfXWv [Occ=Once*] :: a_afWZL -> b_afWZK -> b_afWZK
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [f1_sfXWs] \r [x_sfXWw y_sfXWx] f1_sfXWs y_sfXWx x_sfXWw;
        } in 
          case t1_sfXWu of {
            Data.Functor.Sum.InL x_sfXWz [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable_sfXWq
                    Data.Functor.Sum.$fFoldableSum10
                    f2_sfXWv
                    x_sfXWz
                    z_sfXWt;
            Data.Functor.Sum.InR y_sfXWA [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable1_sfXWr
                    Data.Functor.Sum.$fFoldableSum10
                    f2_sfXWv
                    y_sfXWA
                    z_sfXWt;
          };

lvl2_rfXP3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Functor.Sum.$fFoldableSum9 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rfXP3 of sat_sfXWB {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfXWB;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXWC $dFoldable1_sfXWD f1_sfXWE xs_sfXWF]
        case xs_sfXWF of {
          Data.Functor.Sum.InL x_sfXWH [Occ=Once] ->
              let {
                sat_sfXWN [Occ=Once]
                  :: a_afX0c
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_afX0c))
                [LclId] =
                    [f1_sfXWE] \r [x1_sfXWI y_sfXWJ]
                        let {
                          sat_sfXWM [Occ=Once] :: a_afX0c
                          [LclId] =
                              [f1_sfXWE x1_sfXWI y_sfXWJ] \u []
                                  case y_sfXWJ of {
                                    GHC.Base.Nothing -> x1_sfXWI;
                                    GHC.Base.Just x2_sfXWL [Occ=Once] -> f1_sfXWE x2_sfXWL x1_sfXWI;
                                  };
                        } in  GHC.Base.Just [sat_sfXWM];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable_sfXWC
                        Data.Functor.Sum.$fFoldableSum10
                        sat_sfXWN
                        x_sfXWH
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum9;
                  GHC.Base.Just v_sfXWP [Occ=Once] -> v_sfXWP;
                };
          Data.Functor.Sum.InR y_sfXWQ [Occ=Once] ->
              let {
                sat_sfXWW [Occ=Once]
                  :: a_afX0c
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_afX0c))
                [LclId] =
                    [f1_sfXWE] \r [x_sfXWR y1_sfXWS]
                        let {
                          sat_sfXWV [Occ=Once] :: a_afX0c
                          [LclId] =
                              [f1_sfXWE x_sfXWR y1_sfXWS] \u []
                                  case y1_sfXWS of {
                                    GHC.Base.Nothing -> x_sfXWR;
                                    GHC.Base.Just x1_sfXWU [Occ=Once] -> f1_sfXWE x1_sfXWU x_sfXWR;
                                  };
                        } in  GHC.Base.Just [sat_sfXWV];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable1_sfXWD
                        Data.Functor.Sum.$fFoldableSum10
                        sat_sfXWW
                        y_sfXWQ
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum9;
                  GHC.Base.Just v_sfXWY [Occ=Once] -> v_sfXWY;
                };
        };

Data.Functor.Sum.$fFoldableSum_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXWZ
           $dFoldable1_sfXX0
           f1_sfXX1
           z0_sfXX2
           xs_sfXX3]
        case xs_sfXX3 of {
          Data.Functor.Sum.InL x_sfXX5 [Occ=Once] ->
              let {
                sat_sfXXa [Occ=Once]
                  :: a_afWZA
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_afWZB -> b_afWZB))
                [LclId] =
                    [f1_sfXX1] \r [x1_sfXX6 y_sfXX7 z_sfXX8]
                        case f1_sfXX1 x1_sfXX6 z_sfXX8 of vx_sfXX9 {
                          __DEFAULT -> y_sfXX7 vx_sfXX9;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable_sfXWZ
                    Data.Functor.Sum.$fFoldableSum10
                    sat_sfXXa
                    x_sfXX5
                    GHC.Base.id
                    z0_sfXX2;
          Data.Functor.Sum.InR y_sfXXb [Occ=Once] ->
              let {
                sat_sfXXg [Occ=Once]
                  :: a_afWZA
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_afWZB -> b_afWZB))
                [LclId] =
                    [f1_sfXX1] \r [x_sfXXc y1_sfXXd z_sfXXe]
                        case f1_sfXX1 x_sfXXc z_sfXXe of vx_sfXXf {
                          __DEFAULT -> y1_sfXXd vx_sfXXf;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable1_sfXX0
                    Data.Functor.Sum.$fFoldableSum10
                    sat_sfXXg
                    y_sfXXb
                    GHC.Base.id
                    z0_sfXX2;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXXh
           $dFoldable1_sfXXi
           f1_sfXXj
           z_sfXXk
           t1_sfXXl]
        case t1_sfXXl of {
          Data.Functor.Sum.InL x_sfXXn [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_sfXXh
                  Data.Semigroup.Internal.$fMonoidEndo
                  f1_sfXXj
                  x_sfXXn
                  z_sfXXk;
          Data.Functor.Sum.InR y_sfXXo [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_sfXXi
                  Data.Semigroup.Internal.$fMonoidEndo
                  f1_sfXXj
                  y_sfXXo
                  z_sfXXk;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXXp
           $dFoldable1_sfXXq
           f1_sfXXr
           z0_sfXXs
           xs_sfXXt]
        let {
          sat_sfXXy [Occ=Once]
            :: a_afWZV -> (b_afWZU -> b_afWZU) -> b_afWZU -> b_afWZU
          [LclId] =
              [f1_sfXXr] \r [x_sfXXu k_sfXXv z_sfXXw]
                  case f1_sfXXr z_sfXXw x_sfXXu of vx_sfXXx {
                    __DEFAULT -> k_sfXXv vx_sfXXx;
                  };
        } in 
          Data.Functor.Sum.$fFoldableSum_$cfoldr
              $dFoldable_sfXXp
              $dFoldable1_sfXXq
              sat_sfXXy
              GHC.Base.id
              xs_sfXXt
              z0_sfXXs;

Data.Functor.Sum.$fFoldableSum7
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_sfXXz k_sfXXA z_sfXXB]
        case z_sfXXB of {
          GHC.Types.I# x1_sfXXD [Occ=Once] ->
              case +# [x1_sfXXD 1#] of sat_sfXXE {
                __DEFAULT ->
                    let {
                      sat_sfXXF [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sfXXE];
                    } in  k_sfXXA sat_sfXXF;
              };
        };

Data.Functor.Sum.$fFoldableSum_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Sum.Sum f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXXG $dFoldable1_sfXXH eta_sfXXI]
        Data.Functor.Sum.$fFoldableSum_$cfoldr
            $dFoldable_sfXXG
            $dFoldable1_sfXXH
            Data.Functor.Sum.$fFoldableSum7
            GHC.Base.id
            eta_sfXXI
            Data.Functor.Sum.$fFoldableSum6;

lvl3_rfXP4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Functor.Sum.$fFoldableSum11 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_rfXP4 of sat_sfXXJ {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfXXJ;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXXK $dFoldable1_sfXXL f1_sfXXM xs_sfXXN]
        let {
          sat_sfXXT [Occ=Once]
            :: a_afX04 -> GHC.Base.Maybe a_afX04 -> GHC.Base.Maybe a_afX04
          [LclId] =
              [f1_sfXXM] \r [x_sfXXO m_sfXXP]
                  let {
                    sat_sfXXS [Occ=Once] :: a_afX04
                    [LclId] =
                        [f1_sfXXM x_sfXXO m_sfXXP] \u []
                            case m_sfXXP of {
                              GHC.Base.Nothing -> x_sfXXO;
                              GHC.Base.Just y_sfXXR [Occ=Once] -> f1_sfXXM x_sfXXO y_sfXXR;
                            };
                  } in  GHC.Base.Just [sat_sfXXS];
        } in 
          case
              Data.Functor.Sum.$fFoldableSum_$cfoldr
                  $dFoldable_sfXXK
                  $dFoldable1_sfXXL
                  sat_sfXXT
                  GHC.Base.Nothing
                  xs_sfXXN
          of
          { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum11;
            GHC.Base.Just v_sfXXV [Occ=Once] -> v_sfXXV;
          };

Data.Functor.Sum.$fFoldableSum8
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sfXXW ds1_sfXXX] GHC.Types.False [];

Data.Functor.Sum.$fFoldableSum_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXXY $dFoldable1_sfXXZ eta_sfXY0]
        Data.Functor.Sum.$fFoldableSum_$cfoldr
            $dFoldable_sfXXY
            $dFoldable1_sfXXZ
            Data.Functor.Sum.$fFoldableSum8
            GHC.Types.True
            eta_sfXY0;

Data.Functor.Sum.$fFoldableSum1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     Data.Functor.Sum.Sum f g a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXY1 $dFoldable1_sfXY2 $dNum_sfXY3]
        let {
          $dMonoid_sfXY4 [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_afX1m)
          [LclId] =
              [$dNum_sfXY3] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sfXY3; } in
        let {
          sat_sfXY9 [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_afWYR g_afWYS a_afX1m
               -> Data.Semigroup.Internal.Product a_afX1m
          [LclId] =
              [$dFoldable_sfXY1 $dFoldable1_sfXY2 $dMonoid_sfXY4] \r [ds_sfXY5]
                  case ds_sfXY5 of {
                    Data.Functor.Sum.InL x_sfXY7 [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_sfXY1
                            $dMonoid_sfXY4
                            Data.Functor.Sum.$fFoldableSum2
                            x_sfXY7;
                    Data.Functor.Sum.InR y_sfXY8 [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_sfXY2
                            $dMonoid_sfXY4
                            Data.Functor.Sum.$fFoldableSum2
                            y_sfXY8;
                  };
        } in  sat_sfXY9;

Data.Functor.Sum.$fFoldableSum_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Sum.Sum f g a -> [a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXYa $dFoldable1_sfXYb eta_sfXYc]
        Data.Functor.Sum.$fFoldableSum_$cfoldr
            $dFoldable_sfXYa
            $dFoldable1_sfXYb
            GHC.Types.:
            GHC.Types.[]
            eta_sfXYc;

Data.Functor.Sum.$fFoldableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_sfXYd $dFoldable1_sfXYe]
        let {
          sat_sfXYu [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum1
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYt [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum3
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYs [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cminimum
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYr [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cmaximum
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYq [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$celem
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B2 eta_B1; } in
        let {
          sat_sfXYp [Occ=Once]
            :: forall a.
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$clength
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYo [Occ=Once]
            :: forall a.
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cnull
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYn [Occ=Once]
            :: forall a. Data.Functor.Sum.Sum f_afWYR g_afWYS a -> [a]
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$ctoList
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYm [Occ=Once]
            :: forall a.
               (a -> a -> a) -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldl1
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B2 eta_B1; } in
        let {
          sat_sfXYl [Occ=Once]
            :: forall a.
               (a -> a -> a) -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldr1
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B2 eta_B1; } in
        let {
          sat_sfXYk [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldl'
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXYj [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldl
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXYi [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldr'
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXYh [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldr
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXYg [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> m
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldMap
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXYf [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS m -> m
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfold
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_sfXYf
                                    sat_sfXYg
                                    sat_sfXYh
                                    sat_sfXYi
                                    sat_sfXYj
                                    sat_sfXYk
                                    sat_sfXYl
                                    sat_sfXYm
                                    sat_sfXYn
                                    sat_sfXYo
                                    sat_sfXYp
                                    sat_sfXYq
                                    sat_sfXYr
                                    sat_sfXYs
                                    sat_sfXYt
                                    sat_sfXYu];

Data.Functor.Sum.$fTraversableSum_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> Data.Functor.Sum.Sum f g a -> f1 (Data.Functor.Sum.Sum f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sfXYv
           $dTraversable1_sfXYw
           $dApplicative_sfXYx
           eta_sfXYy
           eta1_sfXYz]
        case eta1_sfXYz of {
          Data.Functor.Sum.InL x_sfXYB [Occ=Once] ->
              let {
                sat_sfXYD [Occ=Once] :: f1_afWXF (f_afWXq b_afWXH)
                [LclId] =
                    [$dTraversable_sfXYv $dApplicative_sfXYx eta_sfXYy x_sfXYB] \u []
                        Data.Traversable.traverse
                            $dTraversable_sfXYv $dApplicative_sfXYx eta_sfXYy x_sfXYB;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfXYx of sat_sfXYC {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sfXYC Data.Functor.Sum.InL sat_sfXYD;
                };
          Data.Functor.Sum.InR y_sfXYE [Occ=Once] ->
              let {
                sat_sfXYG [Occ=Once] :: f1_afWXF (g_afWXr b_afWXH)
                [LclId] =
                    [$dTraversable1_sfXYw $dApplicative_sfXYx eta_sfXYy y_sfXYE] \u []
                        Data.Traversable.traverse
                            $dTraversable1_sfXYw $dApplicative_sfXYx eta_sfXYy y_sfXYE;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfXYx of sat_sfXYF {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sfXYF Data.Functor.Sum.InR sat_sfXYG;
                };
        };

Data.Functor.Sum.$fTraversableSum_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (Data.Functor.Sum.Sum f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sfXYH $dTraversable1_sfXYI]
        let {
          sat_sfXYK [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_afWXr
          [LclId] =
              [$dTraversable1_sfXYI] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sfXYI; } in
        let {
          sat_sfXYJ [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_afWXq
          [LclId] =
              [$dTraversable_sfXYH] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sfXYH;
        } in  Data.Functor.Sum.$fFoldableSum sat_sfXYJ sat_sfXYK;

Data.Functor.Sum.$fTraversableSum_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (Data.Functor.Sum.Sum f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sfXYL $dTraversable1_sfXYM]
        let {
          sat_sfXYO [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor g_afWXr
          [LclId] =
              [$dTraversable1_sfXYM] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sfXYM; } in
        let {
          sat_sfXYN [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_afWXq
          [LclId] =
              [$dTraversable_sfXYL] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sfXYL;
        } in  Data.Functor.Sum.$fFunctorSum sat_sfXYN sat_sfXYO;

Data.Functor.Sum.$fTraversableSum_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     Data.Functor.Sum.Sum f g (f1 a) -> f1 (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sfXYP
           $dTraversable1_sfXYQ
           $dApplicative_sfXYR
           eta_B1]
        Data.Functor.Sum.$fTraversableSum_$ctraverse
            $dTraversable_sfXYP
            $dTraversable1_sfXYQ
            $dApplicative_sfXYR
            GHC.Base.id
            eta_B1;

Data.Functor.Sum.$fTraversableSum_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sfXYS
           $dTraversable1_sfXYT
           $dMonad_sfXYU
           eta_sfXYV
           eta1_sfXYW]
        case GHC.Base.$p1Monad $dMonad_sfXYU of sat_sfXYX {
          __DEFAULT ->
              Data.Functor.Sum.$fTraversableSum_$ctraverse
                  $dTraversable_sfXYS
                  $dTraversable1_sfXYT
                  sat_sfXYX
                  eta_sfXYV
                  eta1_sfXYW;
        };

Data.Functor.Sum.$fTraversableSum_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Sum.Sum f g (m a) -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sfXYY
           $dTraversable1_sfXYZ
           $dMonad_sfXZ0
           eta_sfXZ1]
        case GHC.Base.$p1Monad $dMonad_sfXZ0 of sat_sfXZ2 {
          __DEFAULT ->
              Data.Functor.Sum.$fTraversableSum_$ctraverse
                  $dTraversable_sfXYY
                  $dTraversable1_sfXYZ
                  sat_sfXZ2
                  GHC.Base.id
                  eta_sfXZ1;
        };

Data.Functor.Sum.$fTraversableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sfXZ3 $dTraversable1_sfXZ4]
        let {
          sat_sfXZa [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               Data.Functor.Sum.Sum f_afWXq g_afWXr (m a)
               -> m (Data.Functor.Sum.Sum f_afWXq g_afWXr a)
          [LclId] =
              [$dTraversable_sfXZ3 $dTraversable1_sfXZ4] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$csequence
                      $dTraversable_sfXZ3 $dTraversable1_sfXZ4 eta_B2 eta_B1; } in
        let {
          sat_sfXZ9 [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> Data.Functor.Sum.Sum f_afWXq g_afWXr a
               -> m (Data.Functor.Sum.Sum f_afWXq g_afWXr b)
          [LclId] =
              [$dTraversable_sfXZ3 $dTraversable1_sfXZ4] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$cmapM
                      $dTraversable_sfXZ3 $dTraversable1_sfXZ4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXZ8 [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               Data.Functor.Sum.Sum f_afWXq g_afWXr (f a)
               -> f (Data.Functor.Sum.Sum f_afWXq g_afWXr a)
          [LclId] =
              [$dTraversable_sfXZ3 $dTraversable1_sfXZ4] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$csequenceA
                      $dTraversable_sfXZ3 $dTraversable1_sfXZ4 eta_B2 eta_B1; } in
        let {
          sat_sfXZ7 [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> Data.Functor.Sum.Sum f_afWXq g_afWXr a
               -> f (Data.Functor.Sum.Sum f_afWXq g_afWXr b)
          [LclId] =
              [$dTraversable_sfXZ3 $dTraversable1_sfXZ4] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$ctraverse
                      $dTraversable_sfXZ3 $dTraversable1_sfXZ4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXZ6 [Occ=Once]
            :: Data.Foldable.Foldable (Data.Functor.Sum.Sum f_afWXq g_afWXr)
          [LclId] =
              [$dTraversable_sfXZ3 $dTraversable1_sfXZ4] \u []
                  Data.Functor.Sum.$fTraversableSum_$cp2Traversable
                      $dTraversable_sfXZ3 $dTraversable1_sfXZ4; } in
        let {
          sat_sfXZ5 [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Sum.Sum f_afWXq g_afWXr)
          [LclId] =
              [$dTraversable_sfXZ3 $dTraversable1_sfXZ4] \u []
                  Data.Functor.Sum.$fTraversableSum_$cp1Traversable
                      $dTraversable_sfXZ3 $dTraversable1_sfXZ4;
        } in 
          Data.Traversable.C:Traversable [sat_sfXZ5
                                          sat_sfXZ6
                                          sat_sfXZ7
                                          sat_sfXZ8
                                          sat_sfXZ9
                                          sat_sfXZa];

Data.Functor.Sum.$fGeneric1Sum_$cto1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Data.Functor.Sum.Sum f g) a
     -> Data.Functor.Sum.Sum f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfXZb]
        case ds_sfXZb of {
          GHC.Generics.L1 ds1_sfXZd [Occ=Once] ->
              Data.Functor.Sum.InL [ds1_sfXZd];
          GHC.Generics.R1 ds1_sfXZe [Occ=Once] ->
              Data.Functor.Sum.InR [ds1_sfXZe];
        };

Data.Functor.Sum.$fGeneric1Sum1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Sum.Sum f g a
     -> (GHC.Generics.:+:)
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InL" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.Rec1 f)))
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InR" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.Rec1 g)))
          a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfXZf]
        case x_sfXZf of {
          Data.Functor.Sum.InL g1_sfXZh [Occ=Once] ->
              GHC.Generics.L1 [g1_sfXZh];
          Data.Functor.Sum.InR g1_sfXZi [Occ=Once] ->
              GHC.Generics.R1 [g1_sfXZi];
        };

Data.Functor.Sum.$fGeneric1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *).
     GHC.Generics.Generic1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Functor.Sum.$fGeneric1Sum1
                                            Data.Functor.Sum.$fGeneric1Sum_$cto1];

Data.Functor.Sum.$fGenericSum_$cto
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Data.Functor.Sum.Sum f g a) x
     -> Data.Functor.Sum.Sum f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfXZj]
        case ds_sfXZj of {
          GHC.Generics.L1 ds1_sfXZl [Occ=Once] ->
              Data.Functor.Sum.InL [ds1_sfXZl];
          GHC.Generics.R1 ds1_sfXZm [Occ=Once] ->
              Data.Functor.Sum.InR [ds1_sfXZm];
        };

Data.Functor.Sum.$fGenericSum1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     Data.Functor.Sum.Sum f g a
     -> (GHC.Generics.:+:)
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InL" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.K1 GHC.Generics.R (f a))))
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InR" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.K1 GHC.Generics.R (g a))))
          x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfXZn]
        case x1_sfXZn of {
          Data.Functor.Sum.InL g1_sfXZp [Occ=Once] ->
              GHC.Generics.L1 [g1_sfXZp];
          Data.Functor.Sum.InR g1_sfXZq [Occ=Once] ->
              GHC.Generics.R1 [g1_sfXZq];
        };

Data.Functor.Sum.$fGenericSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Generic (Data.Functor.Sum.Sum f g a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Sum.$fGenericSum1
                                           Data.Functor.Sum.$fGenericSum_$cto];

Data.Functor.Sum.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.ConstrRep
     -> Data.Data.DataType
     -> c (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=6,
 Str=<L,U><L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [w_sfXZr w1_sfXZs w2_sfXZt w3_sfXZu ww_sfXZv ww1_sfXZw]
        case ww_sfXZv of {
          __DEFAULT ->
              case ww1_sfXZw of {
                Data.Data.DataType ww7_sfXZz [Occ=Once] _ [Occ=Dead] ->
                    Data.Data.$wlvl ww7_sfXZz;
              };
          Data.Data.AlgConstr idx_sfXZC [Occ=Once!] ->
              case idx_sfXZC of {
                GHC.Types.I# ds_sfXZE [Occ=Once!] ->
                    case ds_sfXZE of {
                      __DEFAULT ->
                          let {
                            sat_sfXZG [Occ=Once]
                              :: c_sfXCk (g_sfXCc a_sfXCd
                                          -> Data.Functor.Sum.Sum f_sfXCb g_sfXCc a_sfXCd)
                            [LclId] =
                                [w3_sfXZu] \u [] w3_sfXZu Data.Functor.Sum.InR;
                          } in  w2_sfXZt w1_sfXZs sat_sfXZG;
                      1# ->
                          let {
                            sat_sfXZH [Occ=Once]
                              :: c_sfXCk (f_sfXCb a_sfXCd
                                          -> Data.Functor.Sum.Sum f_sfXCb g_sfXCc a_sfXCd)
                            [LclId] =
                                [w3_sfXZu] \u [] w3_sfXZu Data.Functor.Sum.InL;
                          } in  w2_sfXZt w_sfXZr sat_sfXZH;
                    };
              };
        };

Data.Functor.Sum.$fDataSum_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=OtherCon []] =
    [] \r [w_sfXZI
           w1_sfXZJ
           w2_sfXZK
           w3_sfXZL
           w4_sfXZM
           w5_sfXZN
           w6_sfXZO
           w7_sfXZP
           w8_sfXZQ]
        case w8_sfXZQ of {
          Data.Data.Constr ww1_sfXZS [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           ww5_sfXZW [Occ=Once] ->
              Data.Functor.Sum.$w$cgunfold
                  w4_sfXZM w5_sfXZN w6_sfXZO w7_sfXZP ww1_sfXZS ww5_sfXZW;
        };

Data.Functor.Sum.$fDataSum_$cgfoldl
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g1. g1 -> c g1)
     -> Data.Functor.Sum.Sum f g a
     -> c (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sfXZX
           $dTypeable1_sfXZY
           $dTypeable2_sfXZZ
           $dTypeable3_sfY00
           $dData_sfY01
           $dData1_sfY02
           k1_sfY03
           z_sfY04
           ds_sfY05]
        case ds_sfY05 of {
          Data.Functor.Sum.InL a1_sfY07 [Occ=Once] ->
              let {
                sat_sfY08 [Occ=Once]
                  :: c_afWQl (f_afWQ5 a_afWQ7
                              -> Data.Functor.Sum.Sum f_afWQ5 g_afWQ6 a_afWQ7)
                [LclId] =
                    [z_sfY04] \u [] z_sfY04 Data.Functor.Sum.InL;
              } in  k1_sfY03 $dData_sfY01 sat_sfY08 a1_sfY07;
          Data.Functor.Sum.InR a1_sfY09 [Occ=Once] ->
              let {
                sat_sfY0a [Occ=Once]
                  :: c_afWQl (g_afWQ6 a_afWQ7
                              -> Data.Functor.Sum.Sum f_afWQ5 g_afWQ6 a_afWQ7)
                [LclId] =
                    [z_sfY04] \u [] z_sfY04 Data.Functor.Sum.InR;
              } in  k1_sfY03 $dData1_sfY02 sat_sfY0a a1_sfY09;
        };

Data.Functor.Sum.$fDataSum8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Sum"#;

$tSum1_rfXP5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Functor.Sum.$fDataSum8;

go61_rfXP6
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfY0b _ys_sfY0c]
        case ds2_sfY0b of {
          [] -> GHC.List.badHead;
          : ipv_sfY0e [Occ=Once!] ipv1_sfY0f [Occ=Once] ->
              case _ys_sfY0c of {
                [] -> GHC.List.badHead;
                : ipv2_sfY0h [Occ=Once] ipv3_sfY0i [Occ=Once] ->
                    case ipv_sfY0e of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfY0l [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfY0l Data.Functor.Sum.$fRead1Sum7 of {
                            GHC.Types.False -> go61_rfXP6 ipv1_sfY0f ipv3_sfY0i;
                            GHC.Types.True -> ipv2_sfY0h;
                          };
                    };
              };
        };

go1_rfXP7
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfY0q _ys_sfY0r]
        case ds2_sfY0q of {
          [] -> GHC.List.badHead;
          : ipv_sfY0t [Occ=Once!] ipv1_sfY0u [Occ=Once] ->
              case _ys_sfY0r of {
                [] -> GHC.List.badHead;
                : ipv2_sfY0w [Occ=Once] ipv3_sfY0x [Occ=Once] ->
                    case ipv_sfY0t of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfY0A [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfY0A Data.Functor.Sum.$fRead1Sum3 of {
                            GHC.Types.False -> go1_rfXP7 ipv1_sfY0u ipv3_sfY0x;
                            GHC.Types.True -> ipv2_sfY0w;
                          };
                    };
              };
        };

$cInL1_rfXP8 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cInL2_rfXPe];
$cInR1_rfXP9 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cInR2_rfXPd];
Data.Functor.Sum.$cInL [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cInL1_rfXP8
                                     Data.Functor.Sum.$fRead1Sum7
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Functor.Sum.$tSum];
$tSum2_rfXPa :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Sum.$cInR GHC.Types.[]];
$tSum3_rfXPb :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Sum.$cInL $tSum2_rfXPa];
$tSum4_rfXPc :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [$tSum3_rfXPb];
Data.Functor.Sum.$tSum [Occ=LoopBreaker] :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [$tSum1_rfXP5 $tSum4_rfXPc];
Data.Functor.Sum.$cInR [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cInR1_rfXP9
                                     Data.Functor.Sum.$fRead1Sum3
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Functor.Sum.$tSum];
$cInR2_rfXPd :: Data.Data.ConIndex
[GblId] =
    [] \u [] go1_rfXP7 $tSum3_rfXPb Data.Data.mkConstr1;
$cInL2_rfXPe :: Data.Data.ConIndex
[GblId] =
    [] \u [] go61_rfXP6 $tSum3_rfXPb Data.Data.mkConstr1;

Data.Functor.Sum.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Sum.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$trModule4];

Data.Functor.Sum.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Sum"#;

Data.Functor.Sum.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$trModule2];

Data.Functor.Sum.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Sum.$trModule3
                                     Data.Functor.Sum.$trModule1];

$krep_rfXPf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_rfXPg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rfXPf GHC.Types.krep$*];

$krep2_rfXPh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfXPg $krep1_rfXPg];

Data.Functor.Sum.$fDataSum6 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfXPg $krep2_rfXPh];

$krep3_rfXPi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep4_rfXPj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_rfXPk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [3#];

$krep6_rfXPl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rfXPj $krep5_rfXPk];

$krep7_rfXPm :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep3_rfXPi $krep5_rfXPk];

Data.Functor.Sum.$fDataSum7 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$fDataSum8];

Data.Functor.Sum.$tcSum :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6345190594862254730##
                                    1236278515871186010##
                                    Data.Functor.Sum.$trModule
                                    Data.Functor.Sum.$fDataSum7
                                    1#
                                    Data.Functor.Sum.$fDataSum6];

$krep8_rfXPn :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep5_rfXPk GHC.Types.[]];

$krep9_rfXPo :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rfXPi $krep8_rfXPn];

$krep10_rfXPp :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rfXPj $krep9_rfXPo];

$krep11_rfXPq :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rfXPf $krep10_rfXPp];

$krep12_rfXPr :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Sum.$tcSum
                                              $krep11_rfXPq];

Data.Functor.Sum.$tc'InL1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rfXPl $krep12_rfXPr];

Data.Functor.Sum.$tc'InL3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'InL"#;

Data.Functor.Sum.$tc'InL2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$tc'InL3];

Data.Functor.Sum.$tc'InL :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7951421854502432011##
                                    12303552236073891860##
                                    Data.Functor.Sum.$trModule
                                    Data.Functor.Sum.$tc'InL2
                                    4#
                                    Data.Functor.Sum.$tc'InL1];

Data.Functor.Sum.$tc'InR1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_rfXPm $krep12_rfXPr];

Data.Functor.Sum.$tc'InR3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'InR"#;

Data.Functor.Sum.$tc'InR2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$tc'InR3];

Data.Functor.Sum.$tc'InR :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12078304815884238110##
                                    12377490770432979855##
                                    Data.Functor.Sum.$trModule
                                    Data.Functor.Sum.$tc'InR2
                                    4#
                                    Data.Functor.Sum.$tc'InR1];

Data.Functor.Sum.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Sum.Sum f g a)
[GblId, Arity=4, Str=<S,U><S,U><S,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sfY0F w1_sfY0G w2_sfY0H w3_sfY0I]
        let {
          sat_sfY0J [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w3_sfY0I]; } in
        let {
          sat_sfY0K [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sfY0J GHC.Types.[]];
        } in 
          case
              Data.Typeable.Internal.$wmkTrCon
                  6345190594862254730##
                  1236278515871186010##
                  Data.Functor.Sum.$trModule
                  Data.Functor.Sum.$fDataSum7
                  1#
                  Data.Functor.Sum.$fDataSum6
                  sat_sfY0K
          of
          { (#,,,,#) ww8_sfY0M [Occ=Once]
                     ww9_sfY0N [Occ=Once]
                     ww10_sfY0O [Occ=Once]
                     ww11_sfY0P [Occ=Once]
                     ww12_sfY0Q [Occ=Once] ->
                let {
                  sat_sfY0R [Occ=Once]
                    :: Data.Typeable.Internal.TypeRep Data.Functor.Sum.Sum
                  [LclId] =
                      CCCS Data.Typeable.Internal.TrTyCon! [ww8_sfY0M
                                                            ww9_sfY0N
                                                            ww10_sfY0O
                                                            ww11_sfY0P
                                                            ww12_sfY0Q];
                } in 
                  case
                      Data.Typeable.Internal.mkTrApp sat_sfY0R w1_sfY0G
                  of
                  sat_sfY0S
                  { __DEFAULT ->
                        case
                            Data.Typeable.Internal.mkTrApp sat_sfY0S w2_sfY0H
                        of
                        sat_sfY0T
                        { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sfY0T w_sfY0F;
                        };
                  };
          };

Data.Functor.Sum.$fDataSum5 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sfY0U w1_sfY0V w2_sfY0W w3_sfY0X w4_sfY0Y w5_sfY0Z]
        Data.Functor.Sum.$w$cp1Data w_sfY0U w1_sfY0V w2_sfY0W w3_sfY0X;

Data.Functor.Sum.$fDataSum2
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (f a -> Data.Functor.Sum.Sum f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Sum.InL GHC.Types.False];

Data.Functor.Sum.$fDataSum1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (g a -> Data.Functor.Sum.Sum f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Sum.InR GHC.Types.False];

Data.Functor.Sum.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfY10 w1_sfY11 w2_sfY12 w3_sfY13 w4_sfY14]
        let {
          lvl8_sfY15 [Occ=OnceL]
            :: m_sfXD1 (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
          [LclId] =
              [w2_sfY12] \u [] GHC.Base.mzero w2_sfY12;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sfY12
          of
          $dMonad_sfY16 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfY1A [Occ=Once]
                    :: (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU, GHC.Types.Bool)
                       -> m_sfXD1 (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
                  [LclId] =
                      [lvl8_sfY15 $dMonad_sfY16] \r [ds_sfY1v]
                          case ds_sfY1v of {
                            (,) x'_sfY1x [Occ=Once] b_sfY1y [Occ=Once!] ->
                                case b_sfY1y of {
                                  GHC.Types.False -> lvl8_sfY15;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfY16 x'_sfY1x;
                                };
                          }; } in
                let {
                  sat_sfY1u [Occ=Once]
                    :: m_sfXD1 (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sfY10 w1_sfY11 w2_sfY12 w3_sfY13 w4_sfY14 $dMonad_sfY16] \u []
                          let {
                            k1_sfY17 [Occ=Once*!, Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
                              :: forall d b.
                                 Data.Data.Data d =>
                                 Data.Data.Mp m_sfXD1 (d -> b) -> d -> m_sfXD1 (b, GHC.Types.Bool)
                            [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                sat-only [w2_sfY12 w3_sfY13 $dMonad_sfY16] \r [$dData1_sfY18
                                                                               ds_sfY19
                                                                               y_sfY1a]
                                    let {
                                      lvl9_sfY1b [Occ=OnceL] :: m_sfXD1 d_ae2Ws
                                      [LclId] =
                                          [w3_sfY13 $dData1_sfY18 y_sfY1a] \u []
                                              w3_sfY13 $dData1_sfY18 y_sfY1a; } in
                                    let {
                                      sat_sfY1o [Occ=Once]
                                        :: (d_ae2Ws -> b_ae2Wt, GHC.Types.Bool)
                                           -> m_sfXD1 (b_ae2Wt, GHC.Types.Bool)
                                      [LclId] =
                                          [w2_sfY12 $dMonad_sfY16 y_sfY1a lvl9_sfY1b] \r [ds1_sfY1c]
                                              case ds1_sfY1c of {
                                                (,) h_sfY1e b1_sfY1f [Occ=Once] ->
                                                    let {
                                                      sat_sfY1n [Occ=Once]
                                                        :: m_sfXD1 (b_ae2Wt, GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfY16
                                                           y_sfY1a
                                                           h_sfY1e
                                                           b1_sfY1f] \u []
                                                              let {
                                                                sat_sfY1l [Occ=Once] :: b_ae2Wt
                                                                [LclId] =
                                                                    [y_sfY1a h_sfY1e] \u []
                                                                        h_sfY1e y_sfY1a; } in
                                                              let {
                                                                sat_sfY1m [Occ=Once]
                                                                  :: (b_ae2Wt, GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfY1l b1_sfY1f];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfY16 sat_sfY1m; } in
                                                    let {
                                                      sat_sfY1k [Occ=Once]
                                                        :: m_sfXD1 (b_ae2Wt, GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfY16 lvl9_sfY1b h_sfY1e] \u []
                                                              let {
                                                                sat_sfY1j [Occ=Once]
                                                                  :: d_ae2Ws
                                                                     -> m_sfXD1 (b_ae2Wt,
                                                                                 GHC.Types.Bool)
                                                                [LclId] =
                                                                    [$dMonad_sfY16
                                                                     h_sfY1e] \r [y'_sfY1g]
                                                                        let {
                                                                          sat_sfY1h [Occ=Once]
                                                                            :: b_ae2Wt
                                                                          [LclId] =
                                                                              [h_sfY1e
                                                                               y'_sfY1g] \u []
                                                                                  h_sfY1e
                                                                                      y'_sfY1g; } in
                                                                        let {
                                                                          sat_sfY1i [Occ=Once]
                                                                            :: (b_ae2Wt,
                                                                                GHC.Types.Bool)
                                                                          [LclId] =
                                                                              CCCS (,)! [sat_sfY1h
                                                                                         GHC.Types.True];
                                                                        } in 
                                                                          GHC.Base.return
                                                                              $dMonad_sfY16
                                                                              sat_sfY1i;
                                                              } in 
                                                                GHC.Base.>>=
                                                                    $dMonad_sfY16
                                                                    lvl9_sfY1b
                                                                    sat_sfY1j;
                                                    } in 
                                                      GHC.Base.mplus w2_sfY12 sat_sfY1k sat_sfY1n;
                                              };
                                    } in  GHC.Base.>>= $dMonad_sfY16 ds_sfY19 sat_sfY1o;
                          } in 
                            case w4_sfY14 of {
                              Data.Functor.Sum.InL a1_sfY1q [Occ=Once] ->
                                  let {
                                    sat_sfY1r [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXD1
                                           (f_sfXCS a_sfXCU
                                            -> Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
                                    [LclId] =
                                        [$dMonad_sfY16] \u []
                                            GHC.Base.return
                                                $dMonad_sfY16 Data.Functor.Sum.$fDataSum2;
                                  } in  k1_sfY17 w_sfY10 sat_sfY1r a1_sfY1q;
                              Data.Functor.Sum.InR a1_sfY1s [Occ=Once] ->
                                  let {
                                    sat_sfY1t [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXD1
                                           (g_sfXCT a_sfXCU
                                            -> Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
                                    [LclId] =
                                        [$dMonad_sfY16] \u []
                                            GHC.Base.return
                                                $dMonad_sfY16 Data.Functor.Sum.$fDataSum1;
                                  } in  k1_sfY17 w1_sfY11 sat_sfY1t a1_sfY1s;
                            };
                } in  GHC.Base.>>= $dMonad_sfY16 sat_sfY1u sat_sfY1A;
          };

Data.Functor.Sum.$fDataSum_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfY1B
           w1_sfY1C
           w2_sfY1D
           w3_sfY1E
           w4_sfY1F
           w5_sfY1G
           w6_sfY1H
           w7_sfY1I
           w8_sfY1J]
        Data.Functor.Sum.$w$cgmapMp
            w4_sfY1F w5_sfY1G w6_sfY1H w7_sfY1I w8_sfY1J;

Data.Functor.Sum.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfY1K w1_sfY1L w2_sfY1M w3_sfY1N w4_sfY1O]
        let {
          k1_sfY1P [Occ=Once*!, Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
            :: forall d b.
               Data.Data.Data d =>
               m_sfXDl (d -> b) -> d -> m_sfXDl b
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w2_sfY1M w3_sfY1N] \r [$dData1_sfY1Q c_sfY1R x_sfY1S]
                  let {
                    lvl8_sfY1T [Occ=OnceL] :: m_sfXDl d_ae2Vh
                    [LclId] =
                        [w3_sfY1N $dData1_sfY1Q x_sfY1S] \u []
                            w3_sfY1N $dData1_sfY1Q x_sfY1S; } in
                  let {
                    sat_sfY1Y [Occ=Once] :: (d_ae2Vh -> b_ae2Vi) -> m_sfXDl b_ae2Vi
                    [LclId] =
                        [w2_sfY1M lvl8_sfY1T] \r [c'_sfY1U]
                            let {
                              sat_sfY1X [Occ=Once] :: d_ae2Vh -> m_sfXDl b_ae2Vi
                              [LclId] =
                                  [w2_sfY1M c'_sfY1U] \r [x'_sfY1V]
                                      let {
                                        sat_sfY1W [Occ=Once] :: b_ae2Vi
                                        [LclId] =
                                            [c'_sfY1U x'_sfY1V] \u [] c'_sfY1U x'_sfY1V;
                                      } in  GHC.Base.return w2_sfY1M sat_sfY1W;
                            } in  GHC.Base.>>= w2_sfY1M lvl8_sfY1T sat_sfY1X;
                  } in  GHC.Base.>>= w2_sfY1M c_sfY1R sat_sfY1Y;
        } in 
          case w4_sfY1O of {
            Data.Functor.Sum.InL a1_sfY20 [Occ=Once] ->
                let {
                  sat_sfY21 [Occ=Once]
                    :: m_sfXDl (f_sfXDc a_sfXDe
                                -> Data.Functor.Sum.Sum f_sfXDc g_sfXDd a_sfXDe)
                  [LclId] =
                      [w2_sfY1M] \u [] GHC.Base.return w2_sfY1M Data.Functor.Sum.InL;
                } in  k1_sfY1P w_sfY1K sat_sfY21 a1_sfY20;
            Data.Functor.Sum.InR a1_sfY22 [Occ=Once] ->
                let {
                  sat_sfY23 [Occ=Once]
                    :: m_sfXDl (g_sfXDd a_sfXDe
                                -> Data.Functor.Sum.Sum f_sfXDc g_sfXDd a_sfXDe)
                  [LclId] =
                      [w2_sfY1M] \u [] GHC.Base.return w2_sfY1M Data.Functor.Sum.InR;
                } in  k1_sfY1P w1_sfY1L sat_sfY23 a1_sfY22;
          };

Data.Functor.Sum.$fDataSum_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfY24
           w1_sfY25
           w2_sfY26
           w3_sfY27
           w4_sfY28
           w5_sfY29
           w6_sfY2a
           w7_sfY2b
           w8_sfY2c]
        Data.Functor.Sum.$w$cgmapM
            w4_sfY28 w5_sfY29 w6_sfY2a w7_sfY2b w8_sfY2c;

Data.Functor.Sum.$fDataSum_$cgmapQi
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Functor.Sum.Sum f g a
     -> u
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sfY2d
           $dTypeable1_sfY2e
           $dTypeable2_sfY2f
           $dTypeable3_sfY2g
           $dData_sfY2h
           $dData1_sfY2i
           ds_sfY2j
           ds1_sfY2k
           x_sfY2l]
        case x_sfY2l of {
          Data.Functor.Sum.InL a1_sfY2n [Occ=Once] ->
              case ds_sfY2j of {
                GHC.Types.I# x1_sfY2p [Occ=Once!] ->
                    case x1_sfY2p of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sfY2k $dData_sfY2h a1_sfY2n;
                    };
              };
          Data.Functor.Sum.InR a1_sfY2r [Occ=Once] ->
              case ds_sfY2j of {
                GHC.Types.I# x1_sfY2t [Occ=Once!] ->
                    case x1_sfY2t of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sfY2k $dData1_sfY2i a1_sfY2r;
                    };
              };
        };

Data.Functor.Sum.$fDataSum_$cgmapQr
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Sum.Sum f g a
     -> r
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sfY2v
           $dTypeable1_sfY2w
           $dTypeable2_sfY2x
           $dTypeable3_sfY2y
           $dData_sfY2z
           $dData1_sfY2A
           ds_sfY2B
           ds1_sfY2C
           ds2_sfY2D
           x0_sfY2E]
        case x0_sfY2E of {
          Data.Functor.Sum.InL a1_sfY2G [Occ=Once] ->
              let {
                sat_sfY2H [Occ=Once] :: r'_afWSm
                [LclId] =
                    [$dData_sfY2z ds2_sfY2D a1_sfY2G] \u []
                        ds2_sfY2D $dData_sfY2z a1_sfY2G;
              } in  ds_sfY2B sat_sfY2H ds1_sfY2C;
          Data.Functor.Sum.InR a1_sfY2I [Occ=Once] ->
              let {
                sat_sfY2J [Occ=Once] :: r'_afWSm
                [LclId] =
                    [$dData1_sfY2A ds2_sfY2D a1_sfY2I] \u []
                        ds2_sfY2D $dData1_sfY2A a1_sfY2I;
              } in  ds_sfY2B sat_sfY2J ds1_sfY2C;
        };

Data.Functor.Sum.$fDataSum_$cgmapQ
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Functor.Sum.Sum f g a -> [u]
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><L,1*C1(C1(U))><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sfY2K
           $dTypeable1_sfY2L
           $dTypeable2_sfY2M
           $dTypeable3_sfY2N
           $dData_sfY2O
           $dData1_sfY2P
           ds_sfY2Q
           x0_sfY2R]
        case x0_sfY2R of {
          Data.Functor.Sum.InL a1_sfY2T [Occ=Once] ->
              let {
                sat_sfY2U [Occ=Once] :: u_afWSC
                [LclId] =
                    [$dData_sfY2O ds_sfY2Q a1_sfY2T] \u []
                        ds_sfY2Q $dData_sfY2O a1_sfY2T;
              } in  : [sat_sfY2U GHC.Types.[]];
          Data.Functor.Sum.InR a1_sfY2V [Occ=Once] ->
              let {
                sat_sfY2W [Occ=Once] :: u_afWSC
                [LclId] =
                    [$dData1_sfY2P ds_sfY2Q a1_sfY2V] \u []
                        ds_sfY2Q $dData1_sfY2P a1_sfY2V;
              } in  : [sat_sfY2W GHC.Types.[]];
        };

Data.Functor.Sum.$fDataSum3
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Const.Const r (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sfY2X
           $dTypeable1_sfY2Y
           $dTypeable2_sfY2Z
           $dTypeable3_sfY30
           $dData_sfY31
           $dData1_sfY32
           ds_sfY33
           ds1_sfY34
           ds2_sfY35
           eta_sfY36]
        case eta_sfY36 of {
          Data.Functor.Sum.InL a1_sfY38 [Occ=Once] ->
              let {
                sat_sfY39 [Occ=Once] :: r'_afWS5
                [LclId] =
                    [$dData_sfY31 ds2_sfY35 a1_sfY38] \u []
                        ds2_sfY35 $dData_sfY31 a1_sfY38;
              } in  ds_sfY33 ds1_sfY34 sat_sfY39;
          Data.Functor.Sum.InR a1_sfY3a [Occ=Once] ->
              let {
                sat_sfY3b [Occ=Once] :: r'_afWS5
                [LclId] =
                    [$dData1_sfY32 ds2_sfY35 a1_sfY3a] \u []
                        ds2_sfY35 $dData1_sfY32 a1_sfY3a;
              } in  ds_sfY33 ds1_sfY34 sat_sfY3b;
        };

Data.Functor.Sum.$fDataSum4
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Identity.Identity (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sfY3c
           $dTypeable1_sfY3d
           $dTypeable2_sfY3e
           $dTypeable3_sfY3f
           $dData_sfY3g
           $dData1_sfY3h
           ds_sfY3i
           x0_sfY3j]
        case x0_sfY3j of {
          Data.Functor.Sum.InL a1_sfY3l [Occ=Once] ->
              let {
                sat_sfY3m [Occ=Once] :: f_XfWUu a_XfWUy
                [LclId] =
                    [$dData_sfY3g ds_sfY3i a1_sfY3l] \u []
                        ds_sfY3i $dData_sfY3g a1_sfY3l;
              } in  Data.Functor.Sum.InL [sat_sfY3m];
          Data.Functor.Sum.InR a1_sfY3n [Occ=Once] ->
              let {
                sat_sfY3o [Occ=Once] :: g_XfWUw a_XfWUy
                [LclId] =
                    [$dData1_sfY3h ds_sfY3i a1_sfY3n] \u []
                        ds_sfY3i $dData1_sfY3h a1_sfY3n;
              } in  Data.Functor.Sum.InR [sat_sfY3o];
        };

Data.Functor.Sum.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfY3p w1_sfY3q w2_sfY3r w3_sfY3s w4_sfY3t]
        let {
          lvl8_sfY3u [Occ=OnceL]
            :: m_sfXDF (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
          [LclId] =
              [w2_sfY3r] \u [] GHC.Base.mzero w2_sfY3r;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sfY3r
          of
          $dMonad_sfY3v [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfY42 [Occ=Once]
                    :: (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy, GHC.Types.Bool)
                       -> m_sfXDF (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
                  [LclId] =
                      [lvl8_sfY3u $dMonad_sfY3v] \r [ds_sfY3X]
                          case ds_sfY3X of {
                            (,) x'_sfY3Z [Occ=Once] b_sfY40 [Occ=Once!] ->
                                case b_sfY40 of {
                                  GHC.Types.False -> lvl8_sfY3u;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfY3v x'_sfY3Z;
                                };
                          }; } in
                let {
                  sat_sfY3W [Occ=Once]
                    :: m_sfXDF (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sfY3p w1_sfY3q w2_sfY3r w3_sfY3s w4_sfY3t $dMonad_sfY3v] \u []
                          let {
                            k1_sfY3w [Occ=Once*!, Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
                              :: forall d b.
                                 Data.Data.Data d =>
                                 Data.Data.Mp m_sfXDF (d -> b) -> d -> m_sfXDF (b, GHC.Types.Bool)
                            [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                sat-only [w2_sfY3r w3_sfY3s $dMonad_sfY3v] \r [$dData1_sfY3x
                                                                               ds_sfY3y
                                                                               y_sfY3z]
                                    let {
                                      lvl9_sfY3A [Occ=OnceL] :: m_sfXDF d_ae2Ya
                                      [LclId] =
                                          [w3_sfY3s $dData1_sfY3x y_sfY3z] \u []
                                              w3_sfY3s $dData1_sfY3x y_sfY3z; } in
                                    let {
                                      sat_sfY3Q [Occ=Once]
                                        :: (d_ae2Ya -> b_ae2Yb, GHC.Types.Bool)
                                           -> m_sfXDF (b_ae2Yb, GHC.Types.Bool)
                                      [LclId] =
                                          [w2_sfY3r $dMonad_sfY3v y_sfY3z lvl9_sfY3A] \r [ds1_sfY3B]
                                              case ds1_sfY3B of {
                                                (,) h_sfY3D b1_sfY3E [Occ=Once!] ->
                                                    case b1_sfY3E of {
                                                      GHC.Types.False ->
                                                          let {
                                                            sat_sfY3N [Occ=Once]
                                                              :: m_sfXDF (b_ae2Yb, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfY3v
                                                                 y_sfY3z
                                                                 h_sfY3D] \u []
                                                                    let {
                                                                      sat_sfY3L [Occ=Once]
                                                                        :: b_ae2Yb
                                                                      [LclId] =
                                                                          [y_sfY3z h_sfY3D] \u []
                                                                              h_sfY3D y_sfY3z; } in
                                                                    let {
                                                                      sat_sfY3M [Occ=Once]
                                                                        :: (b_ae2Yb, GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfY3L
                                                                                     GHC.Types.False];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfY3v
                                                                          sat_sfY3M; } in
                                                          let {
                                                            sat_sfY3K [Occ=Once]
                                                              :: m_sfXDF (b_ae2Yb, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfY3v
                                                                 lvl9_sfY3A
                                                                 h_sfY3D] \u []
                                                                    let {
                                                                      sat_sfY3J [Occ=Once]
                                                                        :: d_ae2Ya
                                                                           -> m_sfXDF (b_ae2Yb,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sfY3v
                                                                           h_sfY3D] \r [y'_sfY3G]
                                                                              let {
                                                                                sat_sfY3H [Occ=Once]
                                                                                  :: b_ae2Yb
                                                                                [LclId] =
                                                                                    [h_sfY3D
                                                                                     y'_sfY3G] \u []
                                                                                        h_sfY3D
                                                                                            y'_sfY3G; } in
                                                                              let {
                                                                                sat_sfY3I [Occ=Once]
                                                                                  :: (b_ae2Yb,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sfY3H
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sfY3v
                                                                                    sat_sfY3I;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sfY3v
                                                                          lvl9_sfY3A
                                                                          sat_sfY3J;
                                                          } in 
                                                            GHC.Base.mplus
                                                                w2_sfY3r sat_sfY3K sat_sfY3N;
                                                      GHC.Types.True ->
                                                          let {
                                                            sat_sfY3O [Occ=Once] :: b_ae2Yb
                                                            [LclId] =
                                                                [y_sfY3z h_sfY3D] \u []
                                                                    h_sfY3D y_sfY3z; } in
                                                          let {
                                                            sat_sfY3P [Occ=Once]
                                                              :: (b_ae2Yb, GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfY3O
                                                                           GHC.Types.True];
                                                          } in 
                                                            GHC.Base.return $dMonad_sfY3v sat_sfY3P;
                                                    };
                                              };
                                    } in  GHC.Base.>>= $dMonad_sfY3v ds_sfY3y sat_sfY3Q;
                          } in 
                            case w4_sfY3t of {
                              Data.Functor.Sum.InL a1_sfY3S [Occ=Once] ->
                                  let {
                                    sat_sfY3T [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXDF
                                           (f_sfXDw a_sfXDy
                                            -> Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
                                    [LclId] =
                                        [$dMonad_sfY3v] \u []
                                            GHC.Base.return
                                                $dMonad_sfY3v Data.Functor.Sum.$fDataSum2;
                                  } in  k1_sfY3w w_sfY3p sat_sfY3T a1_sfY3S;
                              Data.Functor.Sum.InR a1_sfY3U [Occ=Once] ->
                                  let {
                                    sat_sfY3V [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXDF
                                           (g_sfXDx a_sfXDy
                                            -> Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
                                    [LclId] =
                                        [$dMonad_sfY3v] \u []
                                            GHC.Base.return
                                                $dMonad_sfY3v Data.Functor.Sum.$fDataSum1;
                                  } in  k1_sfY3w w1_sfY3q sat_sfY3V a1_sfY3U;
                            };
                } in  GHC.Base.>>= $dMonad_sfY3v sat_sfY3W sat_sfY42;
          };

Data.Functor.Sum.$fDataSum_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfY43
           w1_sfY44
           w2_sfY45
           w3_sfY46
           w4_sfY47
           w5_sfY48
           w6_sfY49
           w7_sfY4a
           w8_sfY4b]
        Data.Functor.Sum.$w$cgmapMo
            w4_sfY47 w5_sfY48 w6_sfY49 w7_sfY4a w8_sfY4b;

lvl4_rfXPs
  :: forall k (g :: k -> *) (a :: k) (f :: k -> *).
     Data.Functor.Sum.Sum f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sfY4c]
        case ds_sfY4c of {
          Data.Functor.Sum.InL _ [Occ=Dead] -> Data.Functor.Sum.$cInL;
          Data.Functor.Sum.InR _ [Occ=Dead] -> Data.Functor.Sum.$cInR;
        };

lvl5_rfXPt
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Sum.Sum f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfY4g] Data.Functor.Sum.$tSum;

lvl6_rfXPu
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Functor.Sum.Sum f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfY4h ds_sfY4i] GHC.Base.Nothing [];

lvl7_rfXPv
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Functor.Sum.Sum f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfY4j ds_sfY4k] GHC.Base.Nothing [];

Data.Functor.Sum.$fDataSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Data.Data (Data.Functor.Sum.Sum f g a)
[GblId[DFunId], Arity=6, Str=<L,U><L,U><L,U><L,U><L,U><L,U>] =
    [] \r [$dTypeable_sfY4l
           $dTypeable1_sfY4m
           $dTypeable2_sfY4n
           $dTypeable3_sfY4o
           $dData_sfY4p
           $dData1_sfY4q]
        let {
          sat_sfY4K [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> m (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dData_sfY4p $dData1_sfY4q] \r [w_sfY4H w1_sfY4I w2_sfY4J]
                  Data.Functor.Sum.$w$cgmapMo
                      $dData_sfY4p $dData1_sfY4q w_sfY4H w1_sfY4I w2_sfY4J; } in
        let {
          sat_sfY4G [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> m (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dData_sfY4p $dData1_sfY4q] \r [w_sfY4D w1_sfY4E w2_sfY4F]
                  Data.Functor.Sum.$w$cgmapMp
                      $dData_sfY4p $dData1_sfY4q w_sfY4D w1_sfY4E w2_sfY4F; } in
        let {
          sat_sfY4C [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> m (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dData_sfY4p $dData1_sfY4q] \r [w_sfY4z w1_sfY4A w2_sfY4B]
                  Data.Functor.Sum.$w$cgmapM
                      $dData_sfY4p $dData1_sfY4q w_sfY4z w1_sfY4A w2_sfY4B; } in
        let {
          sat_sfY4y [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> u
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgmapQi
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4x [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ -> [u]
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgmapQ
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4w [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> r
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgmapQr
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4v [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> r
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum3
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4u [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum4
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4t [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgunfold
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4s [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> c (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgfoldl
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4r [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o] \u []
                  Data.Functor.Sum.$w$cp1Data
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o;
        } in 
          Data.Data.C:Data [sat_sfY4r
                            sat_sfY4s
                            sat_sfY4t
                            lvl4_rfXPs
                            lvl5_rfXPt
                            lvl6_rfXPu
                            lvl7_rfXPv
                            sat_sfY4u
                            sat_sfY4v
                            sat_sfY4w
                            sat_sfY4x
                            sat_sfY4y
                            sat_sfY4C
                            sat_sfY4G
                            sat_sfY4K];

Data.Functor.Sum.InL
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     f a -> Data.Functor.Sum.Sum f g a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Sum.InL [eta_B1];

Data.Functor.Sum.InR
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     g a -> Data.Functor.Sum.Sum f g a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Sum.InR [eta_B1];


==================== STG syntax: ====================
2018-03-16 16:11:46.883226163 UTC

Data.Functor.Sum.$fEq1Sum_$cliftEq
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sfXPx $dEq2_sfXPy eq_sfXPz ds_sfXPA ds1_sfXPB]
        case ds_sfXPA of {
          Data.Functor.Sum.InL x1_sfXPD [Occ=Once] ->
              case ds1_sfXPB of {
                Data.Functor.Sum.InL x2_sfXPF [Occ=Once] ->
                    $dEq1_sfXPx eq_sfXPz x1_sfXPD x2_sfXPF;
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds2_sfXPH [Occ=Once] ->
              case ds1_sfXPB of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sfXPK [Occ=Once] ->
                    $dEq2_sfXPy eq_sfXPz ds2_sfXPH y2_sfXPK;
              };
        };

Data.Functor.Sum.$fEq1Sum [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Sum.$fEq1Sum_$cliftEq
            eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Sum.$fOrd1Sum_$cliftCompare
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g b
     -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXPL $dOrd2_sfXPM comp_sfXPN ds_sfXPO ds1_sfXPP]
        case ds_sfXPO of {
          Data.Functor.Sum.InL x1_sfXPR [Occ=Once] ->
              case ds1_sfXPP of {
                Data.Functor.Sum.InL x2_sfXPT [Occ=Once] ->
                    Data.Functor.Classes.liftCompare
                        $dOrd1_sfXPL comp_sfXPN x1_sfXPR x2_sfXPT;
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Functor.Sum.InR ds2_sfXPV [Occ=Once] ->
              case ds1_sfXPP of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Functor.Sum.InR y2_sfXPY [Occ=Once] ->
                    Data.Functor.Classes.liftCompare
                        $dOrd2_sfXPM comp_sfXPN ds2_sfXPV y2_sfXPY;
              };
        };

Data.Functor.Sum.$fOrd1Sum1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXPZ $dOrd2_sfXQ0 eta_sfXQ1 eta1_sfXQ2 eta2_sfXQ3]
        case eta1_sfXQ2 of {
          Data.Functor.Sum.InL x1_sfXQ5 [Occ=Once] ->
              case eta2_sfXQ3 of {
                Data.Functor.Sum.InL x2_sfXQ7 [Occ=Once] ->
                    Data.Functor.Classes.$p1Ord1
                        $dOrd1_sfXPZ eta_sfXQ1 x1_sfXQ5 x2_sfXQ7;
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds_sfXQ9 [Occ=Once] ->
              case eta2_sfXQ3 of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sfXQc [Occ=Once] ->
                    Data.Functor.Classes.$p1Ord1
                        $dOrd2_sfXQ0 eta_sfXQ1 ds_sfXQ9 y2_sfXQc;
              };
        };

Data.Functor.Sum.$fOrd1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     Data.Functor.Classes.Ord1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(C1(C1(U))),C(C1(C1(U))))>m] =
    [] \r [$dOrd1_sfXQd $dOrd2_sfXQe]
        let {
          sat_sfXQg [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Sum.Sum f_XfX7u g_XfX7w a
               -> Data.Functor.Sum.Sum f_XfX7u g_XfX7w b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sfXQd $dOrd2_sfXQe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrd1Sum_$cliftCompare
                      $dOrd1_sfXQd $dOrd2_sfXQe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXQf [Occ=Once]
            :: Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f_XfX7u g_XfX7w)
          [LclId] =
              [$dOrd1_sfXQd $dOrd2_sfXQe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrd1Sum1
                      $dOrd1_sfXQd $dOrd2_sfXQe eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sfXQf sat_sfXQg];

Data.Functor.Sum.$fRead1Sum8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "InL"#;

Data.Functor.Sum.$fRead1Sum7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Functor.Sum.$fRead1Sum8;

Data.Functor.Sum.$fRead1Sum4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "InR"#;

Data.Functor.Sum.$fRead1Sum3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Functor.Sum.$fRead1Sum4;

Data.Functor.Sum.$fRead1Sum2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Sum.$fRead1Sum3];

Data.Functor.Sum.$fRead1Sum5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Sum.$fRead1Sum6 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Sum.$fRead1Sum7];

Data.Functor.Sum.$fRead1Sum1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Sum.Sum f g a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXQh $dRead2_sfXQi rp_sfXQj rl_sfXQk]
        let {
          ds_sfXQl [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_afX4G a_afX54)
          [LclId] =
              [$dRead1_sfXQh rp_sfXQj rl_sfXQk] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead1_sfXQh rp_sfXQj rl_sfXQk; } in
        let {
          ds1_sfXQm [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (g_afX4H a_afX54)
          [LclId] =
              [$dRead2_sfXQi rp_sfXQj rl_sfXQk] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead2_sfXQi rp_sfXQj rl_sfXQk; } in
        let {
          $wlvl_sfXQn [InlPrag=NOUSERINLINE[0], Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: GHC.Prim.Int#
               -> forall b.
                  (Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [ds_sfXQl ds1_sfXQm] \r [ww_sfXQo w_sfXQp]
                  case <=# [ww_sfXQo 10#] of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                    1# ->
                        let {
                          sat_sfXQv [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_sfXzb
                          [LclId] =
                              [ds_sfXQl w_sfXQp] \r [a1_sfXQr]
                                  let {
                                    sat_sfXQu [Occ=Once]
                                      :: f_afX4G a_afX54 -> Text.ParserCombinators.ReadP.P b_sfXzb
                                    [LclId] =
                                        [w_sfXQp] \r [a2_sfXQs]
                                            let {
                                              sat_sfXQt [Occ=Once]
                                                :: Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                                              [LclId] =
                                                  CCCS Data.Functor.Sum.InL! [a2_sfXQs];
                                            } in  w_sfXQp sat_sfXQt;
                                  } in  ds_sfXQl Data.Functor.Sum.$fRead1Sum5 sat_sfXQu;
                        } in 
                          case
                              Text.Read.Lex.$wexpect Data.Functor.Sum.$fRead1Sum6 sat_sfXQv
                          of
                          { Unit# ww2_sfXQx [Occ=Once] ->
                                let {
                                  sat_sfXQG [Occ=Once] :: Text.ParserCombinators.ReadP.P b_sfXzb
                                  [LclId] =
                                      [ds1_sfXQm w_sfXQp] \u []
                                          let {
                                            sat_sfXQD [Occ=Once]
                                              :: () -> Text.ParserCombinators.ReadP.P b_sfXzb
                                            [LclId] =
                                                [ds1_sfXQm w_sfXQp] \r [a1_sfXQz]
                                                    let {
                                                      sat_sfXQC [Occ=Once]
                                                        :: g_afX4H a_afX54
                                                           -> Text.ParserCombinators.ReadP.P b_sfXzb
                                                      [LclId] =
                                                          [w_sfXQp] \r [a2_sfXQA]
                                                              let {
                                                                sat_sfXQB [Occ=Once]
                                                                  :: Data.Functor.Sum.Sum
                                                                       f_afX4G g_afX4H a_afX54
                                                                [LclId] =
                                                                    CCCS Data.Functor.Sum.InR! [a2_sfXQA];
                                                              } in  w_sfXQp sat_sfXQB;
                                                    } in 
                                                      ds1_sfXQm
                                                          Data.Functor.Sum.$fRead1Sum5 sat_sfXQC;
                                          } in 
                                            case
                                                Text.Read.Lex.$wexpect
                                                    Data.Functor.Sum.$fRead1Sum2 sat_sfXQD
                                            of
                                            { Unit# ww4_sfXQF [Occ=Once] ->
                                                  Text.ParserCombinators.ReadP.Look [ww4_sfXQF];
                                            }; } in
                                let {
                                  sat_sfXQy [Occ=Once] :: Text.ParserCombinators.ReadP.P b_sfXzb
                                  [LclId] =
                                      CCCS Text.ParserCombinators.ReadP.Look! [ww2_sfXQx];
                                } in 
                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                      sat_sfXQy sat_sfXQG;
                          };
                  }; } in
        let {
          lvl8_sfXQH [InlPrag=NOUSERINLINE[0], Occ=OnceL, Dmd=<L,C(C(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
              [$wlvl_sfXQn] \r [w_sfXQI w1_sfXQJ]
                  case w_sfXQI of {
                    GHC.Types.I# ww1_sfXQL [Occ=Once] ->
                        $wlvl_sfXQn ww1_sfXQL w1_sfXQJ;
                  }; } in
        let {
          sat_sfXQO [Occ=OnceT[0]]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [lvl8_sfXQH] \r [eta_sfXQM eta1_sfXQN]
                  GHC.Read.list3 lvl8_sfXQH eta_sfXQM eta1_sfXQN;
        } in  sat_sfXQO;

Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXQP $dRead2_sfXQQ rp_sfXQR rl_sfXQS]
        let {
          ds_sfXQT [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_XfX6H g_XfX6J a_afX4N
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead1_sfXQP $dRead2_sfXQQ rp_sfXQR rl_sfXQS] \u []
                  let {
                    sat_sfXQZ [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_afX4N]
                    [LclId] =
                        [rl_sfXQS] \r [n_sfXQV w1_sfXQW]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sfXQS w1_sfXQW
                            of
                            { Unit# ww1_sfXQY [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sfXQY];
                            }; } in
                  let {
                    sat_sfXQU [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_afX4N
                    [LclId] =
                        [rp_sfXQR] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sfXQR eta_B1;
                  } in 
                    Data.Functor.Sum.$fRead1Sum1
                        $dRead1_sfXQP $dRead2_sfXQQ sat_sfXQU sat_sfXQZ; } in
        let {
          sat_sfXR2 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX6H g_XfX6J a_afX4N)
          [LclId] =
              [ds_sfXQT] \r [n_sfXR0]
                  let {
                    sat_sfXR1 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Sum.Sum f_XfX6H g_XfX6J a_afX4N)
                    [LclId] =
                        [ds_sfXQT n_sfXR0] \u []
                            ds_sfXQT
                                n_sfXR0 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfXR1;
        } in  sat_sfXR2;

Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXR3 $dRead2_sfXR4 rp_sfXR5 rl_sfXR6]
        let {
          sat_sfXR7 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Sum.Sum f_XfX6F g_XfX6H a_afX5y)
          [LclId] =
              [$dRead1_sfXR3 $dRead2_sfXR4 rp_sfXR5 rl_sfXR6] \s []
                  Data.Functor.Sum.$fRead1Sum1
                      $dRead1_sfXR3 $dRead2_sfXR4 rp_sfXR5 rl_sfXR6;
        } in  GHC.Read.list sat_sfXR7;

Data.Functor.Sum.$fRead1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     Data.Functor.Classes.Read1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>m] =
    [] \r [$dRead1_sfXR8 $dRead2_sfXR9]
        let {
          sat_sfXRd [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Sum.Sum f_XfX6E g_XfX6G a]
          [LclId] =
              [$dRead1_sfXR8 $dRead2_sfXR9] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec
                      $dRead1_sfXR8 $dRead2_sfXR9 eta_B2 eta_B1; } in
        let {
          sat_sfXRc [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Sum.Sum f_XfX6E g_XfX6G a)
          [LclId] =
              [$dRead1_sfXR8 $dRead2_sfXR9] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fRead1Sum1
                      $dRead1_sfXR8 $dRead2_sfXR9 eta_B2 eta_B1; } in
        let {
          sat_sfXRb [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Sum.Sum f_XfX6E g_XfX6G a]
          [LclId] =
              [$dRead1_sfXR8 $dRead2_sfXR9] \u []
                  Data.Functor.Sum.$fRead1Sum_$cliftReadList
                      $dRead1_sfXR8 $dRead2_sfXR9; } in
        let {
          sat_sfXRa [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX6E g_XfX6G a)
          [LclId] =
              [$dRead1_sfXR8 $dRead2_sfXR9] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec
                      $dRead1_sfXR8 $dRead2_sfXR9 eta_B2 eta_B1;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sfXRa
                                        sat_sfXRb
                                        sat_sfXRc
                                        sat_sfXRd];
Data.Functor.Sum.$fRead1Sum_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXRe $dRead2_sfXRf]
        let {
          sat_sfXRg [Occ=Once]
            :: Data.Functor.Classes.Read1
                 (Data.Functor.Sum.Sum f_XfX6G g_XfX6I)
          [LclId] =
              [$dRead1_sfXRe $dRead2_sfXRf] \u []
                  Data.Functor.Sum.$fRead1Sum $dRead1_sfXRe $dRead2_sfXRf;
        } in  Data.Functor.Classes.liftReadListDefault sat_sfXRg;

Data.Functor.Sum.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> Data.Functor.Sum.Sum f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfXRh w1_sfXRi w2_sfXRj w3_sfXRk ww_sfXRl w4_sfXRm]
        case w4_sfXRm of {
          Data.Functor.Sum.InL x_sfXRo [Occ=Once] ->
              let {
                sat_sfXRp [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> f_sfXzA a_sfXzE -> GHC.Show.ShowS
                [LclId] =
                    [w_sfXRh w2_sfXRj w3_sfXRk] \s []
                        Data.Functor.Classes.liftShowsPrec w_sfXRh w2_sfXRj w3_sfXRk;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sfXRp Data.Functor.Sum.$fRead1Sum7 ww_sfXRl x_sfXRo;
          Data.Functor.Sum.InR y_sfXRq [Occ=Once] ->
              let {
                sat_sfXRr [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> g_sfXzB a_sfXzE -> GHC.Show.ShowS
                [LclId] =
                    [w1_sfXRi w2_sfXRj w3_sfXRk] \s []
                        Data.Functor.Classes.liftShowsPrec w1_sfXRi w2_sfXRj w3_sfXRk;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sfXRr Data.Functor.Sum.$fRead1Sum3 ww_sfXRl y_sfXRq;
        };

Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Sum.Sum f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfXRs w1_sfXRt w2_sfXRu w3_sfXRv w4_sfXRw w5_sfXRx]
        case w4_sfXRw of {
          GHC.Types.I# ww1_sfXRz [Occ=Once] ->
              Data.Functor.Sum.$w$cliftShowsPrec
                  w_sfXRs w1_sfXRt w2_sfXRu w3_sfXRv ww1_sfXRz w5_sfXRx;
        };

Data.Functor.Sum.$fFoldableSum6 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Sum.$fShow1Sum_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Sum.Sum f g a]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U><L,U><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sfXRA
           $dShow2_sfXRB
           sp_sfXRC
           sl_sfXRD
           eta_sfXRE
           eta1_sfXRF]
        let {
          sat_sfXRH [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX4e g_afX4f a_afX4z -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sfXRA $dShow2_sfXRB sp_sfXRC sl_sfXRD] \r [w_sfXRG]
                  Data.Functor.Sum.$w$cliftShowsPrec
                      $dShow1_sfXRA $dShow2_sfXRB sp_sfXRC sl_sfXRD 0# w_sfXRG;
        } in  GHC.Show.showList__ sat_sfXRH eta_sfXRE eta1_sfXRF;

Data.Functor.Sum.$fShow1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     Data.Functor.Classes.Show1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)>m] =
    [] \r [$dShow1_sfXRI $dShow2_sfXRJ]
        let {
          sat_sfXRL [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Sum.Sum f_afX4e g_afX4f a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sfXRI $dShow2_sfXRJ] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fShow1Sum_$cliftShowList
                      $dShow1_sfXRI $dShow2_sfXRJ eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXRK [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Sum.Sum f_afX4e g_afX4f a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sfXRI $dShow2_sfXRJ] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec
                      $dShow1_sfXRI $dShow2_sfXRJ eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sfXRK sat_sfXRL];

Data.Functor.Sum.$fEqSum_$c==
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sfXRM $dEq2_sfXRN $dEq_sfXRO eta_sfXRP eta1_sfXRQ]
        let {
          sat_sfXRR [Occ=Once] :: a_afX3V -> a_afX3V -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfXRO] \u [] GHC.Classes.== $dEq_sfXRO;
        } in 
          Data.Functor.Sum.$fEq1Sum_$cliftEq
              $dEq1_sfXRM $dEq2_sfXRN sat_sfXRR eta_sfXRP eta1_sfXRQ;

Data.Functor.Sum.$fEqSum_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sfXRS $dEq2_sfXRT $dEq_sfXRU eta_sfXRV eta1_sfXRW]
        case eta_sfXRV of {
          Data.Functor.Sum.InL x1_sfXRY [Occ=Once] ->
              case eta1_sfXRW of {
                Data.Functor.Sum.InL x2_sfXS0 [Occ=Once] ->
                    let {
                      sat_sfXS1 [Occ=Once] :: a_afX3V -> a_afX3V -> GHC.Types.Bool
                      [LclId] =
                          [$dEq_sfXRU] \u [] GHC.Classes.== $dEq_sfXRU;
                    } in 
                      case $dEq1_sfXRS sat_sfXS1 x1_sfXRY x2_sfXS0 of {
                        GHC.Types.False -> GHC.Types.True [];
                        GHC.Types.True -> GHC.Types.False [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Functor.Sum.InR ds_sfXS4 [Occ=Once] ->
              case eta1_sfXRW of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.True [];
                Data.Functor.Sum.InR y2_sfXS7 [Occ=Once] ->
                    let {
                      sat_sfXS8 [Occ=Once] :: a_afX3V -> a_afX3V -> GHC.Types.Bool
                      [LclId] =
                          [$dEq_sfXRU] \u [] GHC.Classes.== $dEq_sfXRU;
                    } in 
                      case $dEq2_sfXRT sat_sfXS8 ds_sfXS4 y2_sfXS7 of {
                        GHC.Types.False -> GHC.Types.True [];
                        GHC.Types.True -> GHC.Types.False [];
                      };
              };
        };

Data.Functor.Sum.$fEqSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     GHC.Classes.Eq (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><L,U(U,A)>m] =
    [] \r [$dEq1_sfXSa $dEq2_sfXSb $dEq_sfXSc]
        let {
          sat_sfXSe [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V
               -> Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sfXSa $dEq2_sfXSb $dEq_sfXSc] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fEqSum_$c/=
                      $dEq1_sfXSa $dEq2_sfXSb $dEq_sfXSc eta_B2 eta_B1; } in
        let {
          sat_sfXSd [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V
               -> Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sfXSa $dEq2_sfXSb $dEq_sfXSc] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fEqSum_$c==
                      $dEq1_sfXSa $dEq2_sfXSb $dEq_sfXSc eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sfXSd sat_sfXSe];

Data.Functor.Sum.$fOrdSum_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXSf $dOrd2_sfXSg $dOrd_sfXSh eta_sfXSi eta1_sfXSj]
        let {
          sat_sfXSk [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfXSh] \u [] GHC.Classes.compare $dOrd_sfXSh;
        } in 
          Data.Functor.Sum.$fOrd1Sum_$cliftCompare
              $dOrd1_sfXSf $dOrd2_sfXSg sat_sfXSk eta_sfXSi eta1_sfXSj;

Data.Functor.Sum.$fOrdSum_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Eq (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXSl $dOrd2_sfXSm $dOrd_sfXSn]
        let {
          sat_sfXSq [Occ=Once, Dmd=<L,U(U,A)>] :: GHC.Classes.Eq a_afX37
          [LclId] =
              [$dOrd_sfXSn] \u [] GHC.Classes.$p1Ord $dOrd_sfXSn; } in
        let {
          sat_sfXSp [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 g_afX36
          [LclId] =
              [$dOrd2_sfXSm] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sfXSm; } in
        let {
          sat_sfXSo [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 f_afX35
          [LclId] =
              [$dOrd1_sfXSl] \u [] Data.Functor.Classes.$p1Ord1 $dOrd1_sfXSl;
        } in  Data.Functor.Sum.$fEqSum sat_sfXSo sat_sfXSp sat_sfXSq;

Data.Functor.Sum.$fOrdSum_$c<
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXSr $dOrd2_sfXSs $dOrd_sfXSt x_sfXSu y_sfXSv]
        case x_sfXSu of {
          Data.Functor.Sum.InL x1_sfXSx [Occ=Once] ->
              case y_sfXSv of {
                Data.Functor.Sum.InL x2_sfXSz [Occ=Once] ->
                    let {
                      sat_sfXSA [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXSt] \u [] GHC.Classes.compare $dOrd_sfXSt;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sfXSr sat_sfXSA x1_sfXSx x2_sfXSz
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.LT -> GHC.Types.True [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Functor.Sum.InR ds_sfXSD [Occ=Once] ->
              case y_sfXSv of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sfXSG [Occ=Once] ->
                    let {
                      sat_sfXSH [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXSt] \u [] GHC.Classes.compare $dOrd_sfXSt;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sfXSs sat_sfXSH ds_sfXSD y2_sfXSG
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.LT -> GHC.Types.True [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$c>=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXSJ $dOrd2_sfXSK $dOrd_sfXSL x_sfXSM y_sfXSN]
        case x_sfXSM of {
          Data.Functor.Sum.InL x1_sfXSP [Occ=Once] ->
              case y_sfXSN of {
                Data.Functor.Sum.InL x2_sfXSR [Occ=Once] ->
                    let {
                      sat_sfXSS [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXSL] \u [] GHC.Classes.compare $dOrd_sfXSL;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sfXSJ sat_sfXSS x1_sfXSP x2_sfXSR
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.LT -> GHC.Types.False [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds_sfXSV [Occ=Once] ->
              case y_sfXSN of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.True [];
                Data.Functor.Sum.InR y2_sfXSY [Occ=Once] ->
                    let {
                      sat_sfXSZ [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXSL] \u [] GHC.Classes.compare $dOrd_sfXSL;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sfXSK sat_sfXSZ ds_sfXSV y2_sfXSY
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.LT -> GHC.Types.False [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$c>
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXT1 $dOrd2_sfXT2 $dOrd_sfXT3 x_sfXT4 y_sfXT5]
        case x_sfXT4 of {
          Data.Functor.Sum.InL x1_sfXT7 [Occ=Once] ->
              case y_sfXT5 of {
                Data.Functor.Sum.InL x2_sfXT9 [Occ=Once] ->
                    let {
                      sat_sfXTa [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXT3] \u [] GHC.Classes.compare $dOrd_sfXT3;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sfXT1 sat_sfXTa x1_sfXT7 x2_sfXT9
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.GT -> GHC.Types.True [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds_sfXTd [Occ=Once] ->
              case y_sfXT5 of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.True [];
                Data.Functor.Sum.InR y2_sfXTg [Occ=Once] ->
                    let {
                      sat_sfXTh [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXT3] \u [] GHC.Classes.compare $dOrd_sfXT3;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sfXT2 sat_sfXTh ds_sfXTd y2_sfXTg
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.GT -> GHC.Types.True [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$c<=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXTj $dOrd2_sfXTk $dOrd_sfXTl x_sfXTm y_sfXTn]
        case x_sfXTm of {
          Data.Functor.Sum.InL x1_sfXTp [Occ=Once] ->
              case y_sfXTn of {
                Data.Functor.Sum.InL x2_sfXTr [Occ=Once] ->
                    let {
                      sat_sfXTs [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXTl] \u [] GHC.Classes.compare $dOrd_sfXTl;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sfXTj sat_sfXTs x1_sfXTp x2_sfXTr
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.GT -> GHC.Types.False [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Functor.Sum.InR ds_sfXTv [Occ=Once] ->
              case y_sfXTn of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sfXTy [Occ=Once] ->
                    let {
                      sat_sfXTz [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sfXTl] \u [] GHC.Classes.compare $dOrd_sfXTl;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sfXTk sat_sfXTz ds_sfXTv y2_sfXTy
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.GT -> GHC.Types.False [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXTB $dOrd2_sfXTC $dOrd_sfXTD x_sfXTE y_sfXTF]
        case
            Data.Functor.Sum.$fOrdSum_$c<=
                $dOrd1_sfXTB $dOrd2_sfXTC $dOrd_sfXTD x_sfXTE y_sfXTF
        of
        { GHC.Types.False -> x_sfXTE;
          GHC.Types.True -> y_sfXTF;
        };

Data.Functor.Sum.$fOrdSum_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sfXTH $dOrd2_sfXTI $dOrd_sfXTJ x_sfXTK y_sfXTL]
        case
            Data.Functor.Sum.$fOrdSum_$c<=
                $dOrd1_sfXTH $dOrd2_sfXTI $dOrd_sfXTJ x_sfXTK y_sfXTL
        of
        { GHC.Types.False -> y_sfXTL;
          GHC.Types.True -> x_sfXTK;
        };

Data.Functor.Sum.$fOrdSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Ord (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m] =
    [] \r [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP]
        let {
          sat_sfXTX [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$cmin
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTW [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$cmax
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTV [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c>=
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTU [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c>
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTT [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c<=
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTS [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c<
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTR [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$ccompare
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP eta_B2 eta_B1; } in
        let {
          sat_sfXTQ [Occ=Once]
            :: GHC.Classes.Eq (Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37)
          [LclId] =
              [$dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP] \u []
                  Data.Functor.Sum.$fOrdSum_$cp1Ord
                      $dOrd1_sfXTN $dOrd2_sfXTO $dOrd_sfXTP;
        } in 
          GHC.Classes.C:Ord [sat_sfXTQ
                             sat_sfXTR
                             sat_sfXTS
                             sat_sfXTT
                             sat_sfXTU
                             sat_sfXTV
                             sat_sfXTW
                             sat_sfXTX];

Data.Functor.Sum.$fReadSum1
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Sum.Sum f g a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXTY $dRead2_sfXTZ $dRead_sfXU0]
        let {
          sat_sfXU2 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_afX2A]
          [LclId] =
              [$dRead_sfXU0] \u [] GHC.Read.readListPrec $dRead_sfXU0; } in
        let {
          sat_sfXU1 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_afX2A
          [LclId] =
              [$dRead_sfXU0] \u [] GHC.Read.readPrec $dRead_sfXU0;
        } in 
          Data.Functor.Sum.$fRead1Sum1
              $dRead1_sfXTY $dRead2_sfXTZ sat_sfXU1 sat_sfXU2;

Data.Functor.Sum.$fReadSum_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXU3 $dRead2_sfXU4 $dRead_sfXU5]
        let {
          ds_sfXU6 [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_XfX50 g_XfX52 a_XfX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead1_sfXU3 $dRead2_sfXU4 $dRead_sfXU5] \u []
                  let {
                    sat_sfXU8 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_XfX54]
                    [LclId] =
                        [$dRead_sfXU5] \u [] GHC.Read.readListPrec $dRead_sfXU5; } in
                  let {
                    sat_sfXU7 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_XfX54
                    [LclId] =
                        [$dRead_sfXU5] \u [] GHC.Read.readPrec $dRead_sfXU5;
                  } in 
                    Data.Functor.Sum.$fRead1Sum1
                        $dRead1_sfXU3 $dRead2_sfXU4 sat_sfXU7 sat_sfXU8; } in
        let {
          sat_sfXUb [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX50 g_XfX52 a_XfX54)
          [LclId] =
              [ds_sfXU6] \r [n_sfXU9]
                  let {
                    sat_sfXUa [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Sum.Sum f_XfX50 g_XfX52 a_XfX54)
                    [LclId] =
                        [ds_sfXU6 n_sfXU9] \u []
                            ds_sfXU6
                                n_sfXU9 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfXUa;
        } in  sat_sfXUb;

Data.Functor.Sum.$fReadSum_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXUc $dRead2_sfXUd $dRead_sfXUe]
        let {
          sat_sfXUh [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Sum.Sum f_XfX4Y g_XfX50 a_XfX52)
          [LclId] =
              [$dRead1_sfXUc $dRead2_sfXUd $dRead_sfXUe] \s []
                  let {
                    sat_sfXUg [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_XfX52]
                    [LclId] =
                        [$dRead_sfXUe] \u [] GHC.Read.readListPrec $dRead_sfXUe; } in
                  let {
                    sat_sfXUf [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_XfX52
                    [LclId] =
                        [$dRead_sfXUe] \u [] GHC.Read.readPrec $dRead_sfXUe;
                  } in 
                    Data.Functor.Sum.$fRead1Sum1
                        $dRead1_sfXUc $dRead2_sfXUd sat_sfXUf sat_sfXUg;
        } in  GHC.Read.list sat_sfXUh;

Data.Functor.Sum.$fReadSum_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadP.ReadS [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sfXUi $dRead2_sfXUj $dRead_sfXUk]
        let {
          sat_sfXUl [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Sum.Sum f_XfX4Z g_XfX51 a_XfX53]
          [LclId] =
              [$dRead1_sfXUi $dRead2_sfXUj $dRead_sfXUk] \u []
                  Data.Functor.Sum.$fReadSum_$creadListPrec
                      $dRead1_sfXUi
                      $dRead2_sfXUj
                      $dRead_sfXUk
                      GHC.Read.$fRead()7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfXUl;

Data.Functor.Sum.$fReadSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Read.Read (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,U,U)>m] =
    [] \r [$dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo]
        let {
          sat_sfXUs [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51]
          [LclId] =
              [$dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo] \u []
                  Data.Functor.Sum.$fReadSum_$creadListPrec
                      $dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo; } in
        let {
          sat_sfXUr [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51)
          [LclId] =
              [$dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo] \u []
                  Data.Functor.Sum.$fReadSum1
                      $dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo; } in
        let {
          sat_sfXUq [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51]
          [LclId] =
              [$dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo] \u []
                  Data.Functor.Sum.$fReadSum_$creadList
                      $dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo; } in
        let {
          sat_sfXUp [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51)
          [LclId] =
              [$dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo] \u []
                  Data.Functor.Sum.$fReadSum_$creadsPrec
                      $dRead1_sfXUm $dRead2_sfXUn $dRead_sfXUo;
        } in  GHC.Read.C:Read [sat_sfXUp sat_sfXUq sat_sfXUr sat_sfXUs];

Data.Functor.Sum.$fShowSum_$cshowsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Types.Int -> Data.Functor.Sum.Sum f g a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sfXUt
           $dShow2_sfXUu
           $dShow_sfXUv
           eta_sfXUw
           eta1_sfXUx]
        case eta_sfXUw of {
          GHC.Types.I# ww1_sfXUz [Occ=Once] ->
              let {
                sat_sfXUB [Occ=Once] :: [a_afX2a] -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sfXUv] \u [] GHC.Show.showList $dShow_sfXUv; } in
              let {
                sat_sfXUA [Occ=Once] :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sfXUv] \u [] GHC.Show.showsPrec $dShow_sfXUv;
              } in 
                Data.Functor.Sum.$w$cliftShowsPrec
                    $dShow1_sfXUt
                    $dShow2_sfXUu
                    sat_sfXUA
                    sat_sfXUB
                    ww1_sfXUz
                    eta1_sfXUx;
        };

Data.Functor.Sum.$fShowSum_$cshow
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     Data.Functor.Sum.Sum f g a -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*U,A,1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sfXUC $dShow2_sfXUD $dShow_sfXUE x_sfXUF]
        case x_sfXUF of {
          Data.Functor.Sum.InL x1_sfXUH [Occ=Once] ->
              let {
                sat_sfXUK [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow1_sfXUC $dShow_sfXUE x1_sfXUH] \u []
                        let {
                          sat_sfXUJ [Occ=Once] :: [a_afX2a] -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sfXUE] \u [] GHC.Show.showList $dShow_sfXUE; } in
                        let {
                          sat_sfXUI [Occ=Once] :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sfXUE] \u [] GHC.Show.showsPrec $dShow_sfXUE;
                        } in 
                          Data.Functor.Classes.liftShowsPrec
                              $dShow1_sfXUC
                              sat_sfXUI
                              sat_sfXUJ
                              Data.Functor.Classes.$fRead1Const1
                              x1_sfXUH
                              GHC.Types.[]; } in
              let {
                sat_sfXUL [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sfXUK];
              } in  GHC.Base.++ Data.Functor.Sum.$fRead1Sum7 sat_sfXUL;
          Data.Functor.Sum.InR y_sfXUM [Occ=Once] ->
              let {
                sat_sfXUP [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow2_sfXUD $dShow_sfXUE y_sfXUM] \u []
                        let {
                          sat_sfXUO [Occ=Once] :: [a_afX2a] -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sfXUE] \u [] GHC.Show.showList $dShow_sfXUE; } in
                        let {
                          sat_sfXUN [Occ=Once] :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sfXUE] \u [] GHC.Show.showsPrec $dShow_sfXUE;
                        } in 
                          Data.Functor.Classes.liftShowsPrec
                              $dShow2_sfXUD
                              sat_sfXUN
                              sat_sfXUO
                              Data.Functor.Classes.$fRead1Const1
                              y_sfXUM
                              GHC.Types.[]; } in
              let {
                sat_sfXUQ [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sfXUP];
              } in  GHC.Base.++ Data.Functor.Sum.$fRead1Sum3 sat_sfXUQ;
        };

Data.Functor.Sum.$fShowSum_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     [Data.Functor.Sum.Sum f g a] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sfXUR $dShow2_sfXUS $dShow_sfXUT ls_sfXUU s_sfXUV]
        let {
          lvl8_sfXUW [Occ=OnceL]
            :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfXUT] \u [] GHC.Show.showsPrec $dShow_sfXUT; } in
        let {
          lvl9_sfXUX [Occ=OnceL] :: [a_afX2a] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfXUT] \u [] GHC.Show.showList $dShow_sfXUT; } in
        let {
          sat_sfXUZ [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sfXUR $dShow2_sfXUS lvl8_sfXUW lvl9_sfXUX] \r [eta_sfXUY]
                  Data.Functor.Sum.$w$cliftShowsPrec
                      $dShow1_sfXUR $dShow2_sfXUS lvl8_sfXUW lvl9_sfXUX 0# eta_sfXUY;
        } in  GHC.Show.showList__ sat_sfXUZ ls_sfXUU s_sfXUV;

Data.Functor.Sum.$fShowSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Show.Show (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(U,A,U)>m] =
    [] \r [$dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2]
        let {
          sat_sfXV5 [Occ=Once]
            :: [Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a] -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fShowSum_$cshowList
                      $dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2 eta_B2 eta_B1; } in
        let {
          sat_sfXV4 [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a -> GHC.Base.String
          [LclId] =
              [$dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2] \r [eta_B1]
                  Data.Functor.Sum.$fShowSum_$cshow
                      $dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2 eta_B1; } in
        let {
          sat_sfXV3 [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fShowSum_$cshowsPrec
                      $dShow1_sfXV0 $dShow2_sfXV1 $dShow_sfXV2 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfXV3 sat_sfXV4 sat_sfXV5];

Data.Functor.Sum.$fFunctorSum_$cfmap
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Sum.Sum f g a -> Data.Functor.Sum.Sum f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sfXV6 $dFunctor1_sfXV7 f1_sfXV8 ds_sfXV9]
        case ds_sfXV9 of {
          Data.Functor.Sum.InL x_sfXVb [Occ=Once] ->
              let {
                sat_sfXVc [Occ=Once] :: f_afX1v b_afX1D
                [LclId] =
                    [$dFunctor_sfXV6 f1_sfXV8 x_sfXVb] \u []
                        GHC.Base.fmap $dFunctor_sfXV6 f1_sfXV8 x_sfXVb;
              } in  Data.Functor.Sum.InL [sat_sfXVc];
          Data.Functor.Sum.InR y_sfXVd [Occ=Once] ->
              let {
                sat_sfXVe [Occ=Once] :: g_afX1w b_afX1D
                [LclId] =
                    [$dFunctor1_sfXV7 f1_sfXV8 y_sfXVd] \u []
                        GHC.Base.fmap $dFunctor1_sfXV7 f1_sfXV8 y_sfXVd;
              } in  Data.Functor.Sum.InR [sat_sfXVe];
        };

Data.Functor.Sum.$fFunctorSum_$c<$
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     a -> Data.Functor.Sum.Sum f g b -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sfXVf $dFunctor1_sfXVg x_sfXVh eta_sfXVi]
        let {
          sat_sfXVk [Occ=Once] :: b_afX20 -> a_afX1Z
          [LclId] =
              [x_sfXVh] \r [ds_sfXVj] x_sfXVh;
        } in 
          Data.Functor.Sum.$fFunctorSum_$cfmap
              $dFunctor_sfXVf $dFunctor1_sfXVg sat_sfXVk eta_sfXVi;

Data.Functor.Sum.$fFunctorSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     GHC.Base.Functor (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dFunctor_sfXVl $dFunctor1_sfXVm]
        let {
          sat_sfXVo [Occ=Once]
            :: forall a b.
               a
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w b
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w a
          [LclId] =
              [$dFunctor_sfXVl $dFunctor1_sfXVm] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFunctorSum_$c<$
                      $dFunctor_sfXVl $dFunctor1_sfXVm eta_B2 eta_B1; } in
        let {
          sat_sfXVn [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w a
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w b
          [LclId] =
              [$dFunctor_sfXVl $dFunctor1_sfXVm] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFunctorSum_$cfmap
                      $dFunctor_sfXVl $dFunctor1_sfXVm eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sfXVn sat_sfXVo];

Data.Functor.Sum.$fFoldableSum_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Functor.Sum.Sum f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXVp
           $dFoldable1_sfXVq
           $dMonoid_sfXVr
           f1_sfXVs
           ds_sfXVt]
        case ds_sfXVt of {
          Data.Functor.Sum.InL x_sfXVv [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_sfXVp $dMonoid_sfXVr f1_sfXVs x_sfXVv;
          Data.Functor.Sum.InR y_sfXVw [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_sfXVq $dMonoid_sfXVr f1_sfXVs y_sfXVw;
        };

Data.Functor.Sum.$fFoldableSum_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => Data.Functor.Sum.Sum f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXVx $dFoldable1_sfXVy $dMonoid_sfXVz ds_sfXVA]
        case ds_sfXVA of {
          Data.Functor.Sum.InL x_sfXVC [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_sfXVx $dMonoid_sfXVz GHC.Base.id x_sfXVC;
          Data.Functor.Sum.InR y_sfXVD [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_sfXVy $dMonoid_sfXVz GHC.Base.id y_sfXVD;
        };

Data.Functor.Sum.$fFoldableSum2 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfXVE] v_sfXVE;

Data.Functor.Sum.$fFoldableSum3
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     Data.Functor.Sum.Sum f g a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXVF $dFoldable1_sfXVG $dNum_sfXVH]
        let {
          $dMonoid_sfXVI [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_afX1c)
          [LclId] =
              [$dNum_sfXVH] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sfXVH; } in
        let {
          sat_sfXVN [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_XfX1N g_XfX1P a_afX1c
               -> Data.Semigroup.Internal.Sum a_afX1c
          [LclId] =
              [$dFoldable_sfXVF $dFoldable1_sfXVG $dMonoid_sfXVI] \r [ds_sfXVJ]
                  case ds_sfXVJ of {
                    Data.Functor.Sum.InL x_sfXVL [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_sfXVF
                            $dMonoid_sfXVI
                            Data.Functor.Sum.$fFoldableSum2
                            x_sfXVL;
                    Data.Functor.Sum.InR y_sfXVM [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_sfXVG
                            $dMonoid_sfXVI
                            Data.Functor.Sum.$fFoldableSum2
                            y_sfXVM;
                  };
        } in  sat_sfXVN;

lvl_rfXP1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Functor.Sum.$fFoldableSum4 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rfXP1 of sat_sfXVO {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfXVO;
        };

Data.Functor.Sum.$fFoldableSum_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXVP $dFoldable1_sfXVQ $dOrd_sfXVR]
        let {
          g1_sfXVS [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_afX12)
          [LclId] =
              [$dOrd_sfXVR] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_sfXVR; } in
        let {
          sat_sfXW1 [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_XfX1M g_XfX1O a_afX12 -> a_afX12
          [LclId] =
              [$dFoldable_sfXVP $dFoldable1_sfXVQ g1_sfXVS] \r [x_sfXVT]
                  case x_sfXVT of {
                    Data.Functor.Sum.InL x1_sfXVV [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_sfXVP g1_sfXVS GHC.Base.Just x1_sfXVV
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum4;
                          GHC.Base.Just v_sfXVX [Occ=Once] -> v_sfXVX;
                        };
                    Data.Functor.Sum.InR y_sfXVY [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sfXVQ g1_sfXVS GHC.Base.Just y_sfXVY
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum4;
                          GHC.Base.Just v_sfXW0 [Occ=Once] -> v_sfXW0;
                        };
                  };
        } in  sat_sfXW1;

lvl1_rfXP2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Functor.Sum.$fFoldableSum5 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rfXP2 of sat_sfXW2 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfXW2;
        };

Data.Functor.Sum.$fFoldableSum_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXW3 $dFoldable1_sfXW4 $dOrd_sfXW5]
        let {
          g1_sfXW6 [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_afX0S)
          [LclId] =
              [$dOrd_sfXW5] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_sfXW5; } in
        let {
          sat_sfXWf [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_XfX1L g_XfX1N a_afX0S -> a_afX0S
          [LclId] =
              [$dFoldable_sfXW3 $dFoldable1_sfXW4 g1_sfXW6] \r [x_sfXW7]
                  case x_sfXW7 of {
                    Data.Functor.Sum.InL x1_sfXW9 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_sfXW3 g1_sfXW6 GHC.Base.Just x1_sfXW9
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum5;
                          GHC.Base.Just v_sfXWb [Occ=Once] -> v_sfXWb;
                        };
                    Data.Functor.Sum.InR y_sfXWc [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sfXW4 g1_sfXW6 GHC.Base.Just y_sfXWc
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum5;
                          GHC.Base.Just v_sfXWe [Occ=Once] -> v_sfXWe;
                        };
                  };
        } in  sat_sfXWf;

Data.Functor.Sum.$fFoldableSum_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXWg $dFoldable1_sfXWh $dEq_sfXWi eta_sfXWj]
        let {
          f1_sfXWk [Occ=OnceL*] :: a_afX0I -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfXWi eta_sfXWj] \u []
                  GHC.Classes.== $dEq_sfXWi eta_sfXWj; } in
        let {
          sat_sfXWp [Occ=Once]
            :: Data.Functor.Sum.Sum f_XfX1K g_XfX1M a_afX0I
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_sfXWg $dFoldable1_sfXWh f1_sfXWk] \r [ds_sfXWl]
                  case ds_sfXWl of {
                    Data.Functor.Sum.InL x_sfXWn [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_sfXWg
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_sfXWk
                            x_sfXWn;
                    Data.Functor.Sum.InR y_sfXWo [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_sfXWh
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_sfXWk
                            y_sfXWo;
                  };
        } in  sat_sfXWp;

Data.Functor.Sum.$fFoldableSum10
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Functor.Sum.$fFoldableSum_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXWq
           $dFoldable1_sfXWr
           f1_sfXWs
           z_sfXWt
           t1_sfXWu]
        let {
          f2_sfXWv [Occ=Once*] :: a_afWZL -> b_afWZK -> b_afWZK
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [f1_sfXWs] \r [x_sfXWw y_sfXWx] f1_sfXWs y_sfXWx x_sfXWw;
        } in 
          case t1_sfXWu of {
            Data.Functor.Sum.InL x_sfXWz [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable_sfXWq
                    Data.Functor.Sum.$fFoldableSum10
                    f2_sfXWv
                    x_sfXWz
                    z_sfXWt;
            Data.Functor.Sum.InR y_sfXWA [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable1_sfXWr
                    Data.Functor.Sum.$fFoldableSum10
                    f2_sfXWv
                    y_sfXWA
                    z_sfXWt;
          };

lvl2_rfXP3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Functor.Sum.$fFoldableSum9 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rfXP3 of sat_sfXWB {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfXWB;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXWC $dFoldable1_sfXWD f1_sfXWE xs_sfXWF]
        case xs_sfXWF of {
          Data.Functor.Sum.InL x_sfXWH [Occ=Once] ->
              let {
                sat_sfXWN [Occ=Once]
                  :: a_afX0c
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_afX0c))
                [LclId] =
                    [f1_sfXWE] \r [x1_sfXWI y_sfXWJ]
                        let {
                          sat_sfXWM [Occ=Once] :: a_afX0c
                          [LclId] =
                              [f1_sfXWE x1_sfXWI y_sfXWJ] \u []
                                  case y_sfXWJ of {
                                    GHC.Base.Nothing -> x1_sfXWI;
                                    GHC.Base.Just x2_sfXWL [Occ=Once] -> f1_sfXWE x2_sfXWL x1_sfXWI;
                                  };
                        } in  GHC.Base.Just [sat_sfXWM];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable_sfXWC
                        Data.Functor.Sum.$fFoldableSum10
                        sat_sfXWN
                        x_sfXWH
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum9;
                  GHC.Base.Just v_sfXWP [Occ=Once] -> v_sfXWP;
                };
          Data.Functor.Sum.InR y_sfXWQ [Occ=Once] ->
              let {
                sat_sfXWW [Occ=Once]
                  :: a_afX0c
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_afX0c))
                [LclId] =
                    [f1_sfXWE] \r [x_sfXWR y1_sfXWS]
                        let {
                          sat_sfXWV [Occ=Once] :: a_afX0c
                          [LclId] =
                              [f1_sfXWE x_sfXWR y1_sfXWS] \u []
                                  case y1_sfXWS of {
                                    GHC.Base.Nothing -> x_sfXWR;
                                    GHC.Base.Just x1_sfXWU [Occ=Once] -> f1_sfXWE x1_sfXWU x_sfXWR;
                                  };
                        } in  GHC.Base.Just [sat_sfXWV];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable1_sfXWD
                        Data.Functor.Sum.$fFoldableSum10
                        sat_sfXWW
                        y_sfXWQ
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum9;
                  GHC.Base.Just v_sfXWY [Occ=Once] -> v_sfXWY;
                };
        };

Data.Functor.Sum.$fFoldableSum_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXWZ
           $dFoldable1_sfXX0
           f1_sfXX1
           z0_sfXX2
           xs_sfXX3]
        case xs_sfXX3 of {
          Data.Functor.Sum.InL x_sfXX5 [Occ=Once] ->
              let {
                sat_sfXXa [Occ=Once]
                  :: a_afWZA
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_afWZB -> b_afWZB))
                [LclId] =
                    [f1_sfXX1] \r [x1_sfXX6 y_sfXX7 z_sfXX8]
                        case f1_sfXX1 x1_sfXX6 z_sfXX8 of vx_sfXX9 {
                          __DEFAULT -> y_sfXX7 vx_sfXX9;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable_sfXWZ
                    Data.Functor.Sum.$fFoldableSum10
                    sat_sfXXa
                    x_sfXX5
                    GHC.Base.id
                    z0_sfXX2;
          Data.Functor.Sum.InR y_sfXXb [Occ=Once] ->
              let {
                sat_sfXXg [Occ=Once]
                  :: a_afWZA
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_afWZB -> b_afWZB))
                [LclId] =
                    [f1_sfXX1] \r [x_sfXXc y1_sfXXd z_sfXXe]
                        case f1_sfXX1 x_sfXXc z_sfXXe of vx_sfXXf {
                          __DEFAULT -> y1_sfXXd vx_sfXXf;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable1_sfXX0
                    Data.Functor.Sum.$fFoldableSum10
                    sat_sfXXg
                    y_sfXXb
                    GHC.Base.id
                    z0_sfXX2;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXXh
           $dFoldable1_sfXXi
           f1_sfXXj
           z_sfXXk
           t1_sfXXl]
        case t1_sfXXl of {
          Data.Functor.Sum.InL x_sfXXn [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_sfXXh
                  Data.Semigroup.Internal.$fMonoidEndo
                  f1_sfXXj
                  x_sfXXn
                  z_sfXXk;
          Data.Functor.Sum.InR y_sfXXo [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_sfXXi
                  Data.Semigroup.Internal.$fMonoidEndo
                  f1_sfXXj
                  y_sfXXo
                  z_sfXXk;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXXp
           $dFoldable1_sfXXq
           f1_sfXXr
           z0_sfXXs
           xs_sfXXt]
        let {
          sat_sfXXy [Occ=Once]
            :: a_afWZV -> (b_afWZU -> b_afWZU) -> b_afWZU -> b_afWZU
          [LclId] =
              [f1_sfXXr] \r [x_sfXXu k_sfXXv z_sfXXw]
                  case f1_sfXXr z_sfXXw x_sfXXu of vx_sfXXx {
                    __DEFAULT -> k_sfXXv vx_sfXXx;
                  };
        } in 
          Data.Functor.Sum.$fFoldableSum_$cfoldr
              $dFoldable_sfXXp
              $dFoldable1_sfXXq
              sat_sfXXy
              GHC.Base.id
              xs_sfXXt
              z0_sfXXs;

Data.Functor.Sum.$fFoldableSum7
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_sfXXz k_sfXXA z_sfXXB]
        case z_sfXXB of {
          GHC.Types.I# x1_sfXXD [Occ=Once] ->
              case +# [x1_sfXXD 1#] of sat_sfXXE {
                __DEFAULT ->
                    let {
                      sat_sfXXF [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sfXXE];
                    } in  k_sfXXA sat_sfXXF;
              };
        };

Data.Functor.Sum.$fFoldableSum_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Sum.Sum f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXXG $dFoldable1_sfXXH eta_sfXXI]
        Data.Functor.Sum.$fFoldableSum_$cfoldr
            $dFoldable_sfXXG
            $dFoldable1_sfXXH
            Data.Functor.Sum.$fFoldableSum7
            GHC.Base.id
            eta_sfXXI
            Data.Functor.Sum.$fFoldableSum6;

lvl3_rfXP4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Functor.Sum.$fFoldableSum11 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_rfXP4 of sat_sfXXJ {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfXXJ;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXXK $dFoldable1_sfXXL f1_sfXXM xs_sfXXN]
        let {
          sat_sfXXT [Occ=Once]
            :: a_afX04 -> GHC.Base.Maybe a_afX04 -> GHC.Base.Maybe a_afX04
          [LclId] =
              [f1_sfXXM] \r [x_sfXXO m_sfXXP]
                  let {
                    sat_sfXXS [Occ=Once] :: a_afX04
                    [LclId] =
                        [f1_sfXXM x_sfXXO m_sfXXP] \u []
                            case m_sfXXP of {
                              GHC.Base.Nothing -> x_sfXXO;
                              GHC.Base.Just y_sfXXR [Occ=Once] -> f1_sfXXM x_sfXXO y_sfXXR;
                            };
                  } in  GHC.Base.Just [sat_sfXXS];
        } in 
          case
              Data.Functor.Sum.$fFoldableSum_$cfoldr
                  $dFoldable_sfXXK
                  $dFoldable1_sfXXL
                  sat_sfXXT
                  GHC.Base.Nothing
                  xs_sfXXN
          of
          { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum11;
            GHC.Base.Just v_sfXXV [Occ=Once] -> v_sfXXV;
          };

Data.Functor.Sum.$fFoldableSum8
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sfXXW ds1_sfXXX] GHC.Types.False [];

Data.Functor.Sum.$fFoldableSum_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXXY $dFoldable1_sfXXZ eta_sfXY0]
        Data.Functor.Sum.$fFoldableSum_$cfoldr
            $dFoldable_sfXXY
            $dFoldable1_sfXXZ
            Data.Functor.Sum.$fFoldableSum8
            GHC.Types.True
            eta_sfXY0;

Data.Functor.Sum.$fFoldableSum1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     Data.Functor.Sum.Sum f g a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXY1 $dFoldable1_sfXY2 $dNum_sfXY3]
        let {
          $dMonoid_sfXY4 [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_afX1m)
          [LclId] =
              [$dNum_sfXY3] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sfXY3; } in
        let {
          sat_sfXY9 [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_afWYR g_afWYS a_afX1m
               -> Data.Semigroup.Internal.Product a_afX1m
          [LclId] =
              [$dFoldable_sfXY1 $dFoldable1_sfXY2 $dMonoid_sfXY4] \r [ds_sfXY5]
                  case ds_sfXY5 of {
                    Data.Functor.Sum.InL x_sfXY7 [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_sfXY1
                            $dMonoid_sfXY4
                            Data.Functor.Sum.$fFoldableSum2
                            x_sfXY7;
                    Data.Functor.Sum.InR y_sfXY8 [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_sfXY2
                            $dMonoid_sfXY4
                            Data.Functor.Sum.$fFoldableSum2
                            y_sfXY8;
                  };
        } in  sat_sfXY9;

Data.Functor.Sum.$fFoldableSum_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Sum.Sum f g a -> [a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sfXYa $dFoldable1_sfXYb eta_sfXYc]
        Data.Functor.Sum.$fFoldableSum_$cfoldr
            $dFoldable_sfXYa
            $dFoldable1_sfXYb
            GHC.Types.:
            GHC.Types.[]
            eta_sfXYc;

Data.Functor.Sum.$fFoldableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_sfXYd $dFoldable1_sfXYe]
        let {
          sat_sfXYu [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum1
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYt [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum3
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYs [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cminimum
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYr [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cmaximum
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYq [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$celem
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B2 eta_B1; } in
        let {
          sat_sfXYp [Occ=Once]
            :: forall a.
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$clength
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYo [Occ=Once]
            :: forall a.
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cnull
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYn [Occ=Once]
            :: forall a. Data.Functor.Sum.Sum f_afWYR g_afWYS a -> [a]
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$ctoList
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B1; } in
        let {
          sat_sfXYm [Occ=Once]
            :: forall a.
               (a -> a -> a) -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldl1
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B2 eta_B1; } in
        let {
          sat_sfXYl [Occ=Once]
            :: forall a.
               (a -> a -> a) -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldr1
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B2 eta_B1; } in
        let {
          sat_sfXYk [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldl'
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXYj [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldl
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXYi [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldr'
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXYh [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldr
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXYg [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> m
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldMap
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXYf [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS m -> m
          [LclId] =
              [$dFoldable_sfXYd $dFoldable1_sfXYe] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfold
                      $dFoldable_sfXYd $dFoldable1_sfXYe eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_sfXYf
                                    sat_sfXYg
                                    sat_sfXYh
                                    sat_sfXYi
                                    sat_sfXYj
                                    sat_sfXYk
                                    sat_sfXYl
                                    sat_sfXYm
                                    sat_sfXYn
                                    sat_sfXYo
                                    sat_sfXYp
                                    sat_sfXYq
                                    sat_sfXYr
                                    sat_sfXYs
                                    sat_sfXYt
                                    sat_sfXYu];

Data.Functor.Sum.$fTraversableSum_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> Data.Functor.Sum.Sum f g a -> f1 (Data.Functor.Sum.Sum f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sfXYv
           $dTraversable1_sfXYw
           $dApplicative_sfXYx
           eta_sfXYy
           eta1_sfXYz]
        case eta1_sfXYz of {
          Data.Functor.Sum.InL x_sfXYB [Occ=Once] ->
              let {
                sat_sfXYD [Occ=Once] :: f1_afWXF (f_afWXq b_afWXH)
                [LclId] =
                    [$dTraversable_sfXYv $dApplicative_sfXYx eta_sfXYy x_sfXYB] \u []
                        Data.Traversable.traverse
                            $dTraversable_sfXYv $dApplicative_sfXYx eta_sfXYy x_sfXYB;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfXYx of sat_sfXYC {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sfXYC Data.Functor.Sum.InL sat_sfXYD;
                };
          Data.Functor.Sum.InR y_sfXYE [Occ=Once] ->
              let {
                sat_sfXYG [Occ=Once] :: f1_afWXF (g_afWXr b_afWXH)
                [LclId] =
                    [$dTraversable1_sfXYw $dApplicative_sfXYx eta_sfXYy y_sfXYE] \u []
                        Data.Traversable.traverse
                            $dTraversable1_sfXYw $dApplicative_sfXYx eta_sfXYy y_sfXYE;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfXYx of sat_sfXYF {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sfXYF Data.Functor.Sum.InR sat_sfXYG;
                };
        };

Data.Functor.Sum.$fTraversableSum_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (Data.Functor.Sum.Sum f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sfXYH $dTraversable1_sfXYI]
        let {
          sat_sfXYK [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_afWXr
          [LclId] =
              [$dTraversable1_sfXYI] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sfXYI; } in
        let {
          sat_sfXYJ [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_afWXq
          [LclId] =
              [$dTraversable_sfXYH] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sfXYH;
        } in  Data.Functor.Sum.$fFoldableSum sat_sfXYJ sat_sfXYK;

Data.Functor.Sum.$fTraversableSum_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (Data.Functor.Sum.Sum f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sfXYL $dTraversable1_sfXYM]
        let {
          sat_sfXYO [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor g_afWXr
          [LclId] =
              [$dTraversable1_sfXYM] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sfXYM; } in
        let {
          sat_sfXYN [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_afWXq
          [LclId] =
              [$dTraversable_sfXYL] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sfXYL;
        } in  Data.Functor.Sum.$fFunctorSum sat_sfXYN sat_sfXYO;

Data.Functor.Sum.$fTraversableSum_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     Data.Functor.Sum.Sum f g (f1 a) -> f1 (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sfXYP
           $dTraversable1_sfXYQ
           $dApplicative_sfXYR
           eta_B1]
        Data.Functor.Sum.$fTraversableSum_$ctraverse
            $dTraversable_sfXYP
            $dTraversable1_sfXYQ
            $dApplicative_sfXYR
            GHC.Base.id
            eta_B1;

Data.Functor.Sum.$fTraversableSum_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sfXYS
           $dTraversable1_sfXYT
           $dMonad_sfXYU
           eta_sfXYV
           eta1_sfXYW]
        case GHC.Base.$p1Monad $dMonad_sfXYU of sat_sfXYX {
          __DEFAULT ->
              Data.Functor.Sum.$fTraversableSum_$ctraverse
                  $dTraversable_sfXYS
                  $dTraversable1_sfXYT
                  sat_sfXYX
                  eta_sfXYV
                  eta1_sfXYW;
        };

Data.Functor.Sum.$fTraversableSum_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Sum.Sum f g (m a) -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sfXYY
           $dTraversable1_sfXYZ
           $dMonad_sfXZ0
           eta_sfXZ1]
        case GHC.Base.$p1Monad $dMonad_sfXZ0 of sat_sfXZ2 {
          __DEFAULT ->
              Data.Functor.Sum.$fTraversableSum_$ctraverse
                  $dTraversable_sfXYY
                  $dTraversable1_sfXYZ
                  sat_sfXZ2
                  GHC.Base.id
                  eta_sfXZ1;
        };

Data.Functor.Sum.$fTraversableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sfXZ3 $dTraversable1_sfXZ4]
        let {
          sat_sfXZa [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               Data.Functor.Sum.Sum f_afWXq g_afWXr (m a)
               -> m (Data.Functor.Sum.Sum f_afWXq g_afWXr a)
          [LclId] =
              [$dTraversable_sfXZ3 $dTraversable1_sfXZ4] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$csequence
                      $dTraversable_sfXZ3 $dTraversable1_sfXZ4 eta_B2 eta_B1; } in
        let {
          sat_sfXZ9 [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> Data.Functor.Sum.Sum f_afWXq g_afWXr a
               -> m (Data.Functor.Sum.Sum f_afWXq g_afWXr b)
          [LclId] =
              [$dTraversable_sfXZ3 $dTraversable1_sfXZ4] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$cmapM
                      $dTraversable_sfXZ3 $dTraversable1_sfXZ4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXZ8 [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               Data.Functor.Sum.Sum f_afWXq g_afWXr (f a)
               -> f (Data.Functor.Sum.Sum f_afWXq g_afWXr a)
          [LclId] =
              [$dTraversable_sfXZ3 $dTraversable1_sfXZ4] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$csequenceA
                      $dTraversable_sfXZ3 $dTraversable1_sfXZ4 eta_B2 eta_B1; } in
        let {
          sat_sfXZ7 [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> Data.Functor.Sum.Sum f_afWXq g_afWXr a
               -> f (Data.Functor.Sum.Sum f_afWXq g_afWXr b)
          [LclId] =
              [$dTraversable_sfXZ3 $dTraversable1_sfXZ4] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$ctraverse
                      $dTraversable_sfXZ3 $dTraversable1_sfXZ4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfXZ6 [Occ=Once]
            :: Data.Foldable.Foldable (Data.Functor.Sum.Sum f_afWXq g_afWXr)
          [LclId] =
              [$dTraversable_sfXZ3 $dTraversable1_sfXZ4] \u []
                  Data.Functor.Sum.$fTraversableSum_$cp2Traversable
                      $dTraversable_sfXZ3 $dTraversable1_sfXZ4; } in
        let {
          sat_sfXZ5 [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Sum.Sum f_afWXq g_afWXr)
          [LclId] =
              [$dTraversable_sfXZ3 $dTraversable1_sfXZ4] \u []
                  Data.Functor.Sum.$fTraversableSum_$cp1Traversable
                      $dTraversable_sfXZ3 $dTraversable1_sfXZ4;
        } in 
          Data.Traversable.C:Traversable [sat_sfXZ5
                                          sat_sfXZ6
                                          sat_sfXZ7
                                          sat_sfXZ8
                                          sat_sfXZ9
                                          sat_sfXZa];

Data.Functor.Sum.$fGeneric1Sum_$cto1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Data.Functor.Sum.Sum f g) a
     -> Data.Functor.Sum.Sum f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfXZb]
        case ds_sfXZb of {
          GHC.Generics.L1 ds1_sfXZd [Occ=Once] ->
              Data.Functor.Sum.InL [ds1_sfXZd];
          GHC.Generics.R1 ds1_sfXZe [Occ=Once] ->
              Data.Functor.Sum.InR [ds1_sfXZe];
        };

Data.Functor.Sum.$fGeneric1Sum1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Sum.Sum f g a
     -> (GHC.Generics.:+:)
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InL" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.Rec1 f)))
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InR" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.Rec1 g)))
          a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfXZf]
        case x_sfXZf of {
          Data.Functor.Sum.InL g1_sfXZh [Occ=Once] ->
              GHC.Generics.L1 [g1_sfXZh];
          Data.Functor.Sum.InR g1_sfXZi [Occ=Once] ->
              GHC.Generics.R1 [g1_sfXZi];
        };

Data.Functor.Sum.$fGeneric1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *).
     GHC.Generics.Generic1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Functor.Sum.$fGeneric1Sum1
                                            Data.Functor.Sum.$fGeneric1Sum_$cto1];

Data.Functor.Sum.$fGenericSum_$cto
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Data.Functor.Sum.Sum f g a) x
     -> Data.Functor.Sum.Sum f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfXZj]
        case ds_sfXZj of {
          GHC.Generics.L1 ds1_sfXZl [Occ=Once] ->
              Data.Functor.Sum.InL [ds1_sfXZl];
          GHC.Generics.R1 ds1_sfXZm [Occ=Once] ->
              Data.Functor.Sum.InR [ds1_sfXZm];
        };

Data.Functor.Sum.$fGenericSum1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     Data.Functor.Sum.Sum f g a
     -> (GHC.Generics.:+:)
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InL" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.K1 GHC.Generics.R (f a))))
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InR" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.K1 GHC.Generics.R (g a))))
          x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfXZn]
        case x1_sfXZn of {
          Data.Functor.Sum.InL g1_sfXZp [Occ=Once] ->
              GHC.Generics.L1 [g1_sfXZp];
          Data.Functor.Sum.InR g1_sfXZq [Occ=Once] ->
              GHC.Generics.R1 [g1_sfXZq];
        };

Data.Functor.Sum.$fGenericSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Generic (Data.Functor.Sum.Sum f g a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Sum.$fGenericSum1
                                           Data.Functor.Sum.$fGenericSum_$cto];

Data.Functor.Sum.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.ConstrRep
     -> Data.Data.DataType
     -> c (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=6,
 Str=<L,U><L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [w_sfXZr w1_sfXZs w2_sfXZt w3_sfXZu ww_sfXZv ww1_sfXZw]
        case ww_sfXZv of {
          __DEFAULT ->
              case ww1_sfXZw of {
                Data.Data.DataType ww7_sfXZz [Occ=Once] _ [Occ=Dead] ->
                    Data.Data.$wlvl ww7_sfXZz;
              };
          Data.Data.AlgConstr idx_sfXZC [Occ=Once!] ->
              case idx_sfXZC of {
                GHC.Types.I# ds_sfXZE [Occ=Once!] ->
                    case ds_sfXZE of {
                      __DEFAULT ->
                          let {
                            sat_sfXZG [Occ=Once]
                              :: c_sfXCk (g_sfXCc a_sfXCd
                                          -> Data.Functor.Sum.Sum f_sfXCb g_sfXCc a_sfXCd)
                            [LclId] =
                                [w3_sfXZu] \u [] w3_sfXZu Data.Functor.Sum.InR;
                          } in  w2_sfXZt w1_sfXZs sat_sfXZG;
                      1# ->
                          let {
                            sat_sfXZH [Occ=Once]
                              :: c_sfXCk (f_sfXCb a_sfXCd
                                          -> Data.Functor.Sum.Sum f_sfXCb g_sfXCc a_sfXCd)
                            [LclId] =
                                [w3_sfXZu] \u [] w3_sfXZu Data.Functor.Sum.InL;
                          } in  w2_sfXZt w_sfXZr sat_sfXZH;
                    };
              };
        };

Data.Functor.Sum.$fDataSum_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=OtherCon []] =
    [] \r [w_sfXZI
           w1_sfXZJ
           w2_sfXZK
           w3_sfXZL
           w4_sfXZM
           w5_sfXZN
           w6_sfXZO
           w7_sfXZP
           w8_sfXZQ]
        case w8_sfXZQ of {
          Data.Data.Constr ww1_sfXZS [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           ww5_sfXZW [Occ=Once] ->
              Data.Functor.Sum.$w$cgunfold
                  w4_sfXZM w5_sfXZN w6_sfXZO w7_sfXZP ww1_sfXZS ww5_sfXZW;
        };

Data.Functor.Sum.$fDataSum_$cgfoldl
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g1. g1 -> c g1)
     -> Data.Functor.Sum.Sum f g a
     -> c (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sfXZX
           $dTypeable1_sfXZY
           $dTypeable2_sfXZZ
           $dTypeable3_sfY00
           $dData_sfY01
           $dData1_sfY02
           k1_sfY03
           z_sfY04
           ds_sfY05]
        case ds_sfY05 of {
          Data.Functor.Sum.InL a1_sfY07 [Occ=Once] ->
              let {
                sat_sfY08 [Occ=Once]
                  :: c_afWQl (f_afWQ5 a_afWQ7
                              -> Data.Functor.Sum.Sum f_afWQ5 g_afWQ6 a_afWQ7)
                [LclId] =
                    [z_sfY04] \u [] z_sfY04 Data.Functor.Sum.InL;
              } in  k1_sfY03 $dData_sfY01 sat_sfY08 a1_sfY07;
          Data.Functor.Sum.InR a1_sfY09 [Occ=Once] ->
              let {
                sat_sfY0a [Occ=Once]
                  :: c_afWQl (g_afWQ6 a_afWQ7
                              -> Data.Functor.Sum.Sum f_afWQ5 g_afWQ6 a_afWQ7)
                [LclId] =
                    [z_sfY04] \u [] z_sfY04 Data.Functor.Sum.InR;
              } in  k1_sfY03 $dData1_sfY02 sat_sfY0a a1_sfY09;
        };

Data.Functor.Sum.$fDataSum8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Sum"#;

$tSum1_rfXP5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Functor.Sum.$fDataSum8;

go61_rfXP6
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfY0b _ys_sfY0c]
        case ds2_sfY0b of {
          [] -> GHC.List.badHead;
          : ipv_sfY0e [Occ=Once!] ipv1_sfY0f [Occ=Once] ->
              case _ys_sfY0c of {
                [] -> GHC.List.badHead;
                : ipv2_sfY0h [Occ=Once] ipv3_sfY0i [Occ=Once] ->
                    case ipv_sfY0e of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfY0l [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfY0l Data.Functor.Sum.$fRead1Sum7 of {
                            GHC.Types.False -> go61_rfXP6 ipv1_sfY0f ipv3_sfY0i;
                            GHC.Types.True -> ipv2_sfY0h;
                          };
                    };
              };
        };

go1_rfXP7
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfY0q _ys_sfY0r]
        case ds2_sfY0q of {
          [] -> GHC.List.badHead;
          : ipv_sfY0t [Occ=Once!] ipv1_sfY0u [Occ=Once] ->
              case _ys_sfY0r of {
                [] -> GHC.List.badHead;
                : ipv2_sfY0w [Occ=Once] ipv3_sfY0x [Occ=Once] ->
                    case ipv_sfY0t of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfY0A [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfY0A Data.Functor.Sum.$fRead1Sum3 of {
                            GHC.Types.False -> go1_rfXP7 ipv1_sfY0u ipv3_sfY0x;
                            GHC.Types.True -> ipv2_sfY0w;
                          };
                    };
              };
        };

$cInL1_rfXP8 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cInL2_rfXPe];
$cInR1_rfXP9 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cInR2_rfXPd];
Data.Functor.Sum.$cInL [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cInL1_rfXP8
                                     Data.Functor.Sum.$fRead1Sum7
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Functor.Sum.$tSum];
$tSum2_rfXPa :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Sum.$cInR GHC.Types.[]];
$tSum3_rfXPb :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Sum.$cInL $tSum2_rfXPa];
$tSum4_rfXPc :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [$tSum3_rfXPb];
Data.Functor.Sum.$tSum [Occ=LoopBreaker] :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [$tSum1_rfXP5 $tSum4_rfXPc];
Data.Functor.Sum.$cInR [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cInR1_rfXP9
                                     Data.Functor.Sum.$fRead1Sum3
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Functor.Sum.$tSum];
$cInR2_rfXPd :: Data.Data.ConIndex
[GblId] =
    [] \u [] go1_rfXP7 $tSum3_rfXPb Data.Data.mkConstr1;
$cInL2_rfXPe :: Data.Data.ConIndex
[GblId] =
    [] \u [] go61_rfXP6 $tSum3_rfXPb Data.Data.mkConstr1;

Data.Functor.Sum.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Sum.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$trModule4];

Data.Functor.Sum.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Sum"#;

Data.Functor.Sum.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$trModule2];

Data.Functor.Sum.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Sum.$trModule3
                                     Data.Functor.Sum.$trModule1];

$krep_rfXPf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_rfXPg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rfXPf GHC.Types.krep$*];

$krep2_rfXPh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfXPg $krep1_rfXPg];

Data.Functor.Sum.$fDataSum6 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfXPg $krep2_rfXPh];

$krep3_rfXPi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep4_rfXPj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_rfXPk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [3#];

$krep6_rfXPl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rfXPj $krep5_rfXPk];

$krep7_rfXPm :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep3_rfXPi $krep5_rfXPk];

Data.Functor.Sum.$fDataSum7 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$fDataSum8];

Data.Functor.Sum.$tcSum :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6345190594862254730##
                                    1236278515871186010##
                                    Data.Functor.Sum.$trModule
                                    Data.Functor.Sum.$fDataSum7
                                    1#
                                    Data.Functor.Sum.$fDataSum6];

$krep8_rfXPn :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep5_rfXPk GHC.Types.[]];

$krep9_rfXPo :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rfXPi $krep8_rfXPn];

$krep10_rfXPp :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rfXPj $krep9_rfXPo];

$krep11_rfXPq :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rfXPf $krep10_rfXPp];

$krep12_rfXPr :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Sum.$tcSum
                                              $krep11_rfXPq];

Data.Functor.Sum.$tc'InL1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rfXPl $krep12_rfXPr];

Data.Functor.Sum.$tc'InL3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'InL"#;

Data.Functor.Sum.$tc'InL2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$tc'InL3];

Data.Functor.Sum.$tc'InL :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7951421854502432011##
                                    12303552236073891860##
                                    Data.Functor.Sum.$trModule
                                    Data.Functor.Sum.$tc'InL2
                                    4#
                                    Data.Functor.Sum.$tc'InL1];

Data.Functor.Sum.$tc'InR1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_rfXPm $krep12_rfXPr];

Data.Functor.Sum.$tc'InR3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'InR"#;

Data.Functor.Sum.$tc'InR2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$tc'InR3];

Data.Functor.Sum.$tc'InR :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12078304815884238110##
                                    12377490770432979855##
                                    Data.Functor.Sum.$trModule
                                    Data.Functor.Sum.$tc'InR2
                                    4#
                                    Data.Functor.Sum.$tc'InR1];

Data.Functor.Sum.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Sum.Sum f g a)
[GblId, Arity=4, Str=<S,U><S,U><S,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sfY0F w1_sfY0G w2_sfY0H w3_sfY0I]
        let {
          sat_sfY0J [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w3_sfY0I]; } in
        let {
          sat_sfY0K [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sfY0J GHC.Types.[]];
        } in 
          case
              Data.Typeable.Internal.$wmkTrCon
                  6345190594862254730##
                  1236278515871186010##
                  Data.Functor.Sum.$trModule
                  Data.Functor.Sum.$fDataSum7
                  1#
                  Data.Functor.Sum.$fDataSum6
                  sat_sfY0K
          of
          { (#,,,,#) ww8_sfY0M [Occ=Once]
                     ww9_sfY0N [Occ=Once]
                     ww10_sfY0O [Occ=Once]
                     ww11_sfY0P [Occ=Once]
                     ww12_sfY0Q [Occ=Once] ->
                let {
                  sat_sfY0R [Occ=Once]
                    :: Data.Typeable.Internal.TypeRep Data.Functor.Sum.Sum
                  [LclId] =
                      CCCS Data.Typeable.Internal.TrTyCon! [ww8_sfY0M
                                                            ww9_sfY0N
                                                            ww10_sfY0O
                                                            ww11_sfY0P
                                                            ww12_sfY0Q];
                } in 
                  case
                      Data.Typeable.Internal.mkTrApp sat_sfY0R w1_sfY0G
                  of
                  sat_sfY0S
                  { __DEFAULT ->
                        case
                            Data.Typeable.Internal.mkTrApp sat_sfY0S w2_sfY0H
                        of
                        sat_sfY0T
                        { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sfY0T w_sfY0F;
                        };
                  };
          };

Data.Functor.Sum.$fDataSum5 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sfY0U w1_sfY0V w2_sfY0W w3_sfY0X w4_sfY0Y w5_sfY0Z]
        Data.Functor.Sum.$w$cp1Data w_sfY0U w1_sfY0V w2_sfY0W w3_sfY0X;

Data.Functor.Sum.$fDataSum2
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (f a -> Data.Functor.Sum.Sum f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Sum.InL GHC.Types.False];

Data.Functor.Sum.$fDataSum1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (g a -> Data.Functor.Sum.Sum f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Sum.InR GHC.Types.False];

Data.Functor.Sum.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfY10 w1_sfY11 w2_sfY12 w3_sfY13 w4_sfY14]
        let {
          lvl8_sfY15 [Occ=OnceL]
            :: m_sfXD1 (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
          [LclId] =
              [w2_sfY12] \u [] GHC.Base.mzero w2_sfY12;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sfY12
          of
          $dMonad_sfY16 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfY1A [Occ=Once]
                    :: (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU, GHC.Types.Bool)
                       -> m_sfXD1 (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
                  [LclId] =
                      [lvl8_sfY15 $dMonad_sfY16] \r [ds_sfY1v]
                          case ds_sfY1v of {
                            (,) x'_sfY1x [Occ=Once] b_sfY1y [Occ=Once!] ->
                                case b_sfY1y of {
                                  GHC.Types.False -> lvl8_sfY15;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfY16 x'_sfY1x;
                                };
                          }; } in
                let {
                  sat_sfY1u [Occ=Once]
                    :: m_sfXD1 (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sfY10 w1_sfY11 w2_sfY12 w3_sfY13 w4_sfY14 $dMonad_sfY16] \u []
                          let {
                            k1_sfY17 [Occ=Once*!, Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
                              :: forall d b.
                                 Data.Data.Data d =>
                                 Data.Data.Mp m_sfXD1 (d -> b) -> d -> m_sfXD1 (b, GHC.Types.Bool)
                            [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                sat-only [w2_sfY12 w3_sfY13 $dMonad_sfY16] \r [$dData1_sfY18
                                                                               ds_sfY19
                                                                               y_sfY1a]
                                    let {
                                      lvl9_sfY1b [Occ=OnceL] :: m_sfXD1 d_ae2Ws
                                      [LclId] =
                                          [w3_sfY13 $dData1_sfY18 y_sfY1a] \u []
                                              w3_sfY13 $dData1_sfY18 y_sfY1a; } in
                                    let {
                                      sat_sfY1o [Occ=Once]
                                        :: (d_ae2Ws -> b_ae2Wt, GHC.Types.Bool)
                                           -> m_sfXD1 (b_ae2Wt, GHC.Types.Bool)
                                      [LclId] =
                                          [w2_sfY12 $dMonad_sfY16 y_sfY1a lvl9_sfY1b] \r [ds1_sfY1c]
                                              case ds1_sfY1c of {
                                                (,) h_sfY1e b1_sfY1f [Occ=Once] ->
                                                    let {
                                                      sat_sfY1n [Occ=Once]
                                                        :: m_sfXD1 (b_ae2Wt, GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfY16
                                                           y_sfY1a
                                                           h_sfY1e
                                                           b1_sfY1f] \u []
                                                              let {
                                                                sat_sfY1l [Occ=Once] :: b_ae2Wt
                                                                [LclId] =
                                                                    [y_sfY1a h_sfY1e] \u []
                                                                        h_sfY1e y_sfY1a; } in
                                                              let {
                                                                sat_sfY1m [Occ=Once]
                                                                  :: (b_ae2Wt, GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfY1l b1_sfY1f];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfY16 sat_sfY1m; } in
                                                    let {
                                                      sat_sfY1k [Occ=Once]
                                                        :: m_sfXD1 (b_ae2Wt, GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfY16 lvl9_sfY1b h_sfY1e] \u []
                                                              let {
                                                                sat_sfY1j [Occ=Once]
                                                                  :: d_ae2Ws
                                                                     -> m_sfXD1 (b_ae2Wt,
                                                                                 GHC.Types.Bool)
                                                                [LclId] =
                                                                    [$dMonad_sfY16
                                                                     h_sfY1e] \r [y'_sfY1g]
                                                                        let {
                                                                          sat_sfY1h [Occ=Once]
                                                                            :: b_ae2Wt
                                                                          [LclId] =
                                                                              [h_sfY1e
                                                                               y'_sfY1g] \u []
                                                                                  h_sfY1e
                                                                                      y'_sfY1g; } in
                                                                        let {
                                                                          sat_sfY1i [Occ=Once]
                                                                            :: (b_ae2Wt,
                                                                                GHC.Types.Bool)
                                                                          [LclId] =
                                                                              CCCS (,)! [sat_sfY1h
                                                                                         GHC.Types.True];
                                                                        } in 
                                                                          GHC.Base.return
                                                                              $dMonad_sfY16
                                                                              sat_sfY1i;
                                                              } in 
                                                                GHC.Base.>>=
                                                                    $dMonad_sfY16
                                                                    lvl9_sfY1b
                                                                    sat_sfY1j;
                                                    } in 
                                                      GHC.Base.mplus w2_sfY12 sat_sfY1k sat_sfY1n;
                                              };
                                    } in  GHC.Base.>>= $dMonad_sfY16 ds_sfY19 sat_sfY1o;
                          } in 
                            case w4_sfY14 of {
                              Data.Functor.Sum.InL a1_sfY1q [Occ=Once] ->
                                  let {
                                    sat_sfY1r [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXD1
                                           (f_sfXCS a_sfXCU
                                            -> Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
                                    [LclId] =
                                        [$dMonad_sfY16] \u []
                                            GHC.Base.return
                                                $dMonad_sfY16 Data.Functor.Sum.$fDataSum2;
                                  } in  k1_sfY17 w_sfY10 sat_sfY1r a1_sfY1q;
                              Data.Functor.Sum.InR a1_sfY1s [Occ=Once] ->
                                  let {
                                    sat_sfY1t [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXD1
                                           (g_sfXCT a_sfXCU
                                            -> Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
                                    [LclId] =
                                        [$dMonad_sfY16] \u []
                                            GHC.Base.return
                                                $dMonad_sfY16 Data.Functor.Sum.$fDataSum1;
                                  } in  k1_sfY17 w1_sfY11 sat_sfY1t a1_sfY1s;
                            };
                } in  GHC.Base.>>= $dMonad_sfY16 sat_sfY1u sat_sfY1A;
          };

Data.Functor.Sum.$fDataSum_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfY1B
           w1_sfY1C
           w2_sfY1D
           w3_sfY1E
           w4_sfY1F
           w5_sfY1G
           w6_sfY1H
           w7_sfY1I
           w8_sfY1J]
        Data.Functor.Sum.$w$cgmapMp
            w4_sfY1F w5_sfY1G w6_sfY1H w7_sfY1I w8_sfY1J;

Data.Functor.Sum.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfY1K w1_sfY1L w2_sfY1M w3_sfY1N w4_sfY1O]
        let {
          k1_sfY1P [Occ=Once*!, Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
            :: forall d b.
               Data.Data.Data d =>
               m_sfXDl (d -> b) -> d -> m_sfXDl b
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w2_sfY1M w3_sfY1N] \r [$dData1_sfY1Q c_sfY1R x_sfY1S]
                  let {
                    lvl8_sfY1T [Occ=OnceL] :: m_sfXDl d_ae2Vh
                    [LclId] =
                        [w3_sfY1N $dData1_sfY1Q x_sfY1S] \u []
                            w3_sfY1N $dData1_sfY1Q x_sfY1S; } in
                  let {
                    sat_sfY1Y [Occ=Once] :: (d_ae2Vh -> b_ae2Vi) -> m_sfXDl b_ae2Vi
                    [LclId] =
                        [w2_sfY1M lvl8_sfY1T] \r [c'_sfY1U]
                            let {
                              sat_sfY1X [Occ=Once] :: d_ae2Vh -> m_sfXDl b_ae2Vi
                              [LclId] =
                                  [w2_sfY1M c'_sfY1U] \r [x'_sfY1V]
                                      let {
                                        sat_sfY1W [Occ=Once] :: b_ae2Vi
                                        [LclId] =
                                            [c'_sfY1U x'_sfY1V] \u [] c'_sfY1U x'_sfY1V;
                                      } in  GHC.Base.return w2_sfY1M sat_sfY1W;
                            } in  GHC.Base.>>= w2_sfY1M lvl8_sfY1T sat_sfY1X;
                  } in  GHC.Base.>>= w2_sfY1M c_sfY1R sat_sfY1Y;
        } in 
          case w4_sfY1O of {
            Data.Functor.Sum.InL a1_sfY20 [Occ=Once] ->
                let {
                  sat_sfY21 [Occ=Once]
                    :: m_sfXDl (f_sfXDc a_sfXDe
                                -> Data.Functor.Sum.Sum f_sfXDc g_sfXDd a_sfXDe)
                  [LclId] =
                      [w2_sfY1M] \u [] GHC.Base.return w2_sfY1M Data.Functor.Sum.InL;
                } in  k1_sfY1P w_sfY1K sat_sfY21 a1_sfY20;
            Data.Functor.Sum.InR a1_sfY22 [Occ=Once] ->
                let {
                  sat_sfY23 [Occ=Once]
                    :: m_sfXDl (g_sfXDd a_sfXDe
                                -> Data.Functor.Sum.Sum f_sfXDc g_sfXDd a_sfXDe)
                  [LclId] =
                      [w2_sfY1M] \u [] GHC.Base.return w2_sfY1M Data.Functor.Sum.InR;
                } in  k1_sfY1P w1_sfY1L sat_sfY23 a1_sfY22;
          };

Data.Functor.Sum.$fDataSum_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfY24
           w1_sfY25
           w2_sfY26
           w3_sfY27
           w4_sfY28
           w5_sfY29
           w6_sfY2a
           w7_sfY2b
           w8_sfY2c]
        Data.Functor.Sum.$w$cgmapM
            w4_sfY28 w5_sfY29 w6_sfY2a w7_sfY2b w8_sfY2c;

Data.Functor.Sum.$fDataSum_$cgmapQi
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Functor.Sum.Sum f g a
     -> u
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sfY2d
           $dTypeable1_sfY2e
           $dTypeable2_sfY2f
           $dTypeable3_sfY2g
           $dData_sfY2h
           $dData1_sfY2i
           ds_sfY2j
           ds1_sfY2k
           x_sfY2l]
        case x_sfY2l of {
          Data.Functor.Sum.InL a1_sfY2n [Occ=Once] ->
              case ds_sfY2j of {
                GHC.Types.I# x1_sfY2p [Occ=Once!] ->
                    case x1_sfY2p of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sfY2k $dData_sfY2h a1_sfY2n;
                    };
              };
          Data.Functor.Sum.InR a1_sfY2r [Occ=Once] ->
              case ds_sfY2j of {
                GHC.Types.I# x1_sfY2t [Occ=Once!] ->
                    case x1_sfY2t of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sfY2k $dData1_sfY2i a1_sfY2r;
                    };
              };
        };

Data.Functor.Sum.$fDataSum_$cgmapQr
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Sum.Sum f g a
     -> r
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sfY2v
           $dTypeable1_sfY2w
           $dTypeable2_sfY2x
           $dTypeable3_sfY2y
           $dData_sfY2z
           $dData1_sfY2A
           ds_sfY2B
           ds1_sfY2C
           ds2_sfY2D
           x0_sfY2E]
        case x0_sfY2E of {
          Data.Functor.Sum.InL a1_sfY2G [Occ=Once] ->
              let {
                sat_sfY2H [Occ=Once] :: r'_afWSm
                [LclId] =
                    [$dData_sfY2z ds2_sfY2D a1_sfY2G] \u []
                        ds2_sfY2D $dData_sfY2z a1_sfY2G;
              } in  ds_sfY2B sat_sfY2H ds1_sfY2C;
          Data.Functor.Sum.InR a1_sfY2I [Occ=Once] ->
              let {
                sat_sfY2J [Occ=Once] :: r'_afWSm
                [LclId] =
                    [$dData1_sfY2A ds2_sfY2D a1_sfY2I] \u []
                        ds2_sfY2D $dData1_sfY2A a1_sfY2I;
              } in  ds_sfY2B sat_sfY2J ds1_sfY2C;
        };

Data.Functor.Sum.$fDataSum_$cgmapQ
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Functor.Sum.Sum f g a -> [u]
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><L,1*C1(C1(U))><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sfY2K
           $dTypeable1_sfY2L
           $dTypeable2_sfY2M
           $dTypeable3_sfY2N
           $dData_sfY2O
           $dData1_sfY2P
           ds_sfY2Q
           x0_sfY2R]
        case x0_sfY2R of {
          Data.Functor.Sum.InL a1_sfY2T [Occ=Once] ->
              let {
                sat_sfY2U [Occ=Once] :: u_afWSC
                [LclId] =
                    [$dData_sfY2O ds_sfY2Q a1_sfY2T] \u []
                        ds_sfY2Q $dData_sfY2O a1_sfY2T;
              } in  : [sat_sfY2U GHC.Types.[]];
          Data.Functor.Sum.InR a1_sfY2V [Occ=Once] ->
              let {
                sat_sfY2W [Occ=Once] :: u_afWSC
                [LclId] =
                    [$dData1_sfY2P ds_sfY2Q a1_sfY2V] \u []
                        ds_sfY2Q $dData1_sfY2P a1_sfY2V;
              } in  : [sat_sfY2W GHC.Types.[]];
        };

Data.Functor.Sum.$fDataSum3
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Const.Const r (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sfY2X
           $dTypeable1_sfY2Y
           $dTypeable2_sfY2Z
           $dTypeable3_sfY30
           $dData_sfY31
           $dData1_sfY32
           ds_sfY33
           ds1_sfY34
           ds2_sfY35
           eta_sfY36]
        case eta_sfY36 of {
          Data.Functor.Sum.InL a1_sfY38 [Occ=Once] ->
              let {
                sat_sfY39 [Occ=Once] :: r'_afWS5
                [LclId] =
                    [$dData_sfY31 ds2_sfY35 a1_sfY38] \u []
                        ds2_sfY35 $dData_sfY31 a1_sfY38;
              } in  ds_sfY33 ds1_sfY34 sat_sfY39;
          Data.Functor.Sum.InR a1_sfY3a [Occ=Once] ->
              let {
                sat_sfY3b [Occ=Once] :: r'_afWS5
                [LclId] =
                    [$dData1_sfY32 ds2_sfY35 a1_sfY3a] \u []
                        ds2_sfY35 $dData1_sfY32 a1_sfY3a;
              } in  ds_sfY33 ds1_sfY34 sat_sfY3b;
        };

Data.Functor.Sum.$fDataSum4
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Identity.Identity (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sfY3c
           $dTypeable1_sfY3d
           $dTypeable2_sfY3e
           $dTypeable3_sfY3f
           $dData_sfY3g
           $dData1_sfY3h
           ds_sfY3i
           x0_sfY3j]
        case x0_sfY3j of {
          Data.Functor.Sum.InL a1_sfY3l [Occ=Once] ->
              let {
                sat_sfY3m [Occ=Once] :: f_XfWUu a_XfWUy
                [LclId] =
                    [$dData_sfY3g ds_sfY3i a1_sfY3l] \u []
                        ds_sfY3i $dData_sfY3g a1_sfY3l;
              } in  Data.Functor.Sum.InL [sat_sfY3m];
          Data.Functor.Sum.InR a1_sfY3n [Occ=Once] ->
              let {
                sat_sfY3o [Occ=Once] :: g_XfWUw a_XfWUy
                [LclId] =
                    [$dData1_sfY3h ds_sfY3i a1_sfY3n] \u []
                        ds_sfY3i $dData1_sfY3h a1_sfY3n;
              } in  Data.Functor.Sum.InR [sat_sfY3o];
        };

Data.Functor.Sum.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfY3p w1_sfY3q w2_sfY3r w3_sfY3s w4_sfY3t]
        let {
          lvl8_sfY3u [Occ=OnceL]
            :: m_sfXDF (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
          [LclId] =
              [w2_sfY3r] \u [] GHC.Base.mzero w2_sfY3r;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sfY3r
          of
          $dMonad_sfY3v [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfY42 [Occ=Once]
                    :: (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy, GHC.Types.Bool)
                       -> m_sfXDF (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
                  [LclId] =
                      [lvl8_sfY3u $dMonad_sfY3v] \r [ds_sfY3X]
                          case ds_sfY3X of {
                            (,) x'_sfY3Z [Occ=Once] b_sfY40 [Occ=Once!] ->
                                case b_sfY40 of {
                                  GHC.Types.False -> lvl8_sfY3u;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfY3v x'_sfY3Z;
                                };
                          }; } in
                let {
                  sat_sfY3W [Occ=Once]
                    :: m_sfXDF (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sfY3p w1_sfY3q w2_sfY3r w3_sfY3s w4_sfY3t $dMonad_sfY3v] \u []
                          let {
                            k1_sfY3w [Occ=Once*!, Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
                              :: forall d b.
                                 Data.Data.Data d =>
                                 Data.Data.Mp m_sfXDF (d -> b) -> d -> m_sfXDF (b, GHC.Types.Bool)
                            [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                sat-only [w2_sfY3r w3_sfY3s $dMonad_sfY3v] \r [$dData1_sfY3x
                                                                               ds_sfY3y
                                                                               y_sfY3z]
                                    let {
                                      lvl9_sfY3A [Occ=OnceL] :: m_sfXDF d_ae2Ya
                                      [LclId] =
                                          [w3_sfY3s $dData1_sfY3x y_sfY3z] \u []
                                              w3_sfY3s $dData1_sfY3x y_sfY3z; } in
                                    let {
                                      sat_sfY3Q [Occ=Once]
                                        :: (d_ae2Ya -> b_ae2Yb, GHC.Types.Bool)
                                           -> m_sfXDF (b_ae2Yb, GHC.Types.Bool)
                                      [LclId] =
                                          [w2_sfY3r $dMonad_sfY3v y_sfY3z lvl9_sfY3A] \r [ds1_sfY3B]
                                              case ds1_sfY3B of {
                                                (,) h_sfY3D b1_sfY3E [Occ=Once!] ->
                                                    case b1_sfY3E of {
                                                      GHC.Types.False ->
                                                          let {
                                                            sat_sfY3N [Occ=Once]
                                                              :: m_sfXDF (b_ae2Yb, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfY3v
                                                                 y_sfY3z
                                                                 h_sfY3D] \u []
                                                                    let {
                                                                      sat_sfY3L [Occ=Once]
                                                                        :: b_ae2Yb
                                                                      [LclId] =
                                                                          [y_sfY3z h_sfY3D] \u []
                                                                              h_sfY3D y_sfY3z; } in
                                                                    let {
                                                                      sat_sfY3M [Occ=Once]
                                                                        :: (b_ae2Yb, GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfY3L
                                                                                     GHC.Types.False];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfY3v
                                                                          sat_sfY3M; } in
                                                          let {
                                                            sat_sfY3K [Occ=Once]
                                                              :: m_sfXDF (b_ae2Yb, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfY3v
                                                                 lvl9_sfY3A
                                                                 h_sfY3D] \u []
                                                                    let {
                                                                      sat_sfY3J [Occ=Once]
                                                                        :: d_ae2Ya
                                                                           -> m_sfXDF (b_ae2Yb,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sfY3v
                                                                           h_sfY3D] \r [y'_sfY3G]
                                                                              let {
                                                                                sat_sfY3H [Occ=Once]
                                                                                  :: b_ae2Yb
                                                                                [LclId] =
                                                                                    [h_sfY3D
                                                                                     y'_sfY3G] \u []
                                                                                        h_sfY3D
                                                                                            y'_sfY3G; } in
                                                                              let {
                                                                                sat_sfY3I [Occ=Once]
                                                                                  :: (b_ae2Yb,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sfY3H
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sfY3v
                                                                                    sat_sfY3I;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sfY3v
                                                                          lvl9_sfY3A
                                                                          sat_sfY3J;
                                                          } in 
                                                            GHC.Base.mplus
                                                                w2_sfY3r sat_sfY3K sat_sfY3N;
                                                      GHC.Types.True ->
                                                          let {
                                                            sat_sfY3O [Occ=Once] :: b_ae2Yb
                                                            [LclId] =
                                                                [y_sfY3z h_sfY3D] \u []
                                                                    h_sfY3D y_sfY3z; } in
                                                          let {
                                                            sat_sfY3P [Occ=Once]
                                                              :: (b_ae2Yb, GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfY3O
                                                                           GHC.Types.True];
                                                          } in 
                                                            GHC.Base.return $dMonad_sfY3v sat_sfY3P;
                                                    };
                                              };
                                    } in  GHC.Base.>>= $dMonad_sfY3v ds_sfY3y sat_sfY3Q;
                          } in 
                            case w4_sfY3t of {
                              Data.Functor.Sum.InL a1_sfY3S [Occ=Once] ->
                                  let {
                                    sat_sfY3T [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXDF
                                           (f_sfXDw a_sfXDy
                                            -> Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
                                    [LclId] =
                                        [$dMonad_sfY3v] \u []
                                            GHC.Base.return
                                                $dMonad_sfY3v Data.Functor.Sum.$fDataSum2;
                                  } in  k1_sfY3w w_sfY3p sat_sfY3T a1_sfY3S;
                              Data.Functor.Sum.InR a1_sfY3U [Occ=Once] ->
                                  let {
                                    sat_sfY3V [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXDF
                                           (g_sfXDx a_sfXDy
                                            -> Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
                                    [LclId] =
                                        [$dMonad_sfY3v] \u []
                                            GHC.Base.return
                                                $dMonad_sfY3v Data.Functor.Sum.$fDataSum1;
                                  } in  k1_sfY3w w1_sfY3q sat_sfY3V a1_sfY3U;
                            };
                } in  GHC.Base.>>= $dMonad_sfY3v sat_sfY3W sat_sfY42;
          };

Data.Functor.Sum.$fDataSum_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfY43
           w1_sfY44
           w2_sfY45
           w3_sfY46
           w4_sfY47
           w5_sfY48
           w6_sfY49
           w7_sfY4a
           w8_sfY4b]
        Data.Functor.Sum.$w$cgmapMo
            w4_sfY47 w5_sfY48 w6_sfY49 w7_sfY4a w8_sfY4b;

lvl4_rfXPs
  :: forall k (g :: k -> *) (a :: k) (f :: k -> *).
     Data.Functor.Sum.Sum f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sfY4c]
        case ds_sfY4c of {
          Data.Functor.Sum.InL _ [Occ=Dead] -> Data.Functor.Sum.$cInL;
          Data.Functor.Sum.InR _ [Occ=Dead] -> Data.Functor.Sum.$cInR;
        };

lvl5_rfXPt
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Sum.Sum f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfY4g] Data.Functor.Sum.$tSum;

lvl6_rfXPu
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Functor.Sum.Sum f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfY4h ds_sfY4i] GHC.Base.Nothing [];

lvl7_rfXPv
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Functor.Sum.Sum f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfY4j ds_sfY4k] GHC.Base.Nothing [];

Data.Functor.Sum.$fDataSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Data.Data (Data.Functor.Sum.Sum f g a)
[GblId[DFunId], Arity=6, Str=<L,U><L,U><L,U><L,U><L,U><L,U>] =
    [] \r [$dTypeable_sfY4l
           $dTypeable1_sfY4m
           $dTypeable2_sfY4n
           $dTypeable3_sfY4o
           $dData_sfY4p
           $dData1_sfY4q]
        let {
          sat_sfY4K [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> m (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dData_sfY4p $dData1_sfY4q] \r [w_sfY4H w1_sfY4I w2_sfY4J]
                  Data.Functor.Sum.$w$cgmapMo
                      $dData_sfY4p $dData1_sfY4q w_sfY4H w1_sfY4I w2_sfY4J; } in
        let {
          sat_sfY4G [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> m (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dData_sfY4p $dData1_sfY4q] \r [w_sfY4D w1_sfY4E w2_sfY4F]
                  Data.Functor.Sum.$w$cgmapMp
                      $dData_sfY4p $dData1_sfY4q w_sfY4D w1_sfY4E w2_sfY4F; } in
        let {
          sat_sfY4C [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> m (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dData_sfY4p $dData1_sfY4q] \r [w_sfY4z w1_sfY4A w2_sfY4B]
                  Data.Functor.Sum.$w$cgmapM
                      $dData_sfY4p $dData1_sfY4q w_sfY4z w1_sfY4A w2_sfY4B; } in
        let {
          sat_sfY4y [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> u
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgmapQi
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4x [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ -> [u]
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgmapQ
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4w [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> r
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgmapQr
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4v [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> r
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum3
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4u [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum4
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4t [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgunfold
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4s [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> c (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o
               $dData_sfY4p
               $dData1_sfY4q] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgfoldl
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o
                      $dData_sfY4p
                      $dData1_sfY4q
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sfY4r [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dTypeable_sfY4l
               $dTypeable1_sfY4m
               $dTypeable2_sfY4n
               $dTypeable3_sfY4o] \u []
                  Data.Functor.Sum.$w$cp1Data
                      $dTypeable_sfY4l
                      $dTypeable1_sfY4m
                      $dTypeable2_sfY4n
                      $dTypeable3_sfY4o;
        } in 
          Data.Data.C:Data [sat_sfY4r
                            sat_sfY4s
                            sat_sfY4t
                            lvl4_rfXPs
                            lvl5_rfXPt
                            lvl6_rfXPu
                            lvl7_rfXPv
                            sat_sfY4u
                            sat_sfY4v
                            sat_sfY4w
                            sat_sfY4x
                            sat_sfY4y
                            sat_sfY4C
                            sat_sfY4G
                            sat_sfY4K];

Data.Functor.Sum.InL
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     f a -> Data.Functor.Sum.Sum f g a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Sum.InL [eta_B1];

Data.Functor.Sum.InR
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     g a -> Data.Functor.Sum.Sum f g a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Sum.InR [eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:11:52.400285104 UTC

Data.Functor.Sum.$fEq1Sum_$cliftEq
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sg1EO $dEq2_sg1EP eq_sg1EQ ds_sg1ER ds1_sg1ES]
        case ds_sg1ER of {
          Data.Functor.Sum.InL x1_sg1EU [Occ=Once] ->
              case ds1_sg1ES of {
                Data.Functor.Sum.InL x2_sg1EW [Occ=Once] ->
                    $dEq1_sg1EO eq_sg1EQ x1_sg1EU x2_sg1EW;
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds2_sg1EY [Occ=Once] ->
              case ds1_sg1ES of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sg1F1 [Occ=Once] ->
                    $dEq2_sg1EP eq_sg1EQ ds2_sg1EY y2_sg1F1;
              };
        };

Data.Functor.Sum.$fEq1Sum [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Sum.$fEq1Sum_$cliftEq
            eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Sum.$fOrd1Sum_$cliftCompare
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g b
     -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1F2 $dOrd2_sg1F3 comp_sg1F4 ds_sg1F5 ds1_sg1F6]
        case ds_sg1F5 of {
          Data.Functor.Sum.InL x1_sg1F8 [Occ=Once] ->
              case ds1_sg1F6 of {
                Data.Functor.Sum.InL x2_sg1Fa [Occ=Once] ->
                    Data.Functor.Classes.liftCompare
                        $dOrd1_sg1F2 comp_sg1F4 x1_sg1F8 x2_sg1Fa;
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Functor.Sum.InR ds2_sg1Fc [Occ=Once] ->
              case ds1_sg1F6 of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Functor.Sum.InR y2_sg1Ff [Occ=Once] ->
                    Data.Functor.Classes.liftCompare
                        $dOrd2_sg1F3 comp_sg1F4 ds2_sg1Fc y2_sg1Ff;
              };
        };

Data.Functor.Sum.$fOrd1Sum1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1Fg $dOrd2_sg1Fh eta_sg1Fi eta1_sg1Fj eta2_sg1Fk]
        case eta1_sg1Fj of {
          Data.Functor.Sum.InL x1_sg1Fm [Occ=Once] ->
              case eta2_sg1Fk of {
                Data.Functor.Sum.InL x2_sg1Fo [Occ=Once] ->
                    Data.Functor.Classes.$p1Ord1
                        $dOrd1_sg1Fg eta_sg1Fi x1_sg1Fm x2_sg1Fo;
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds_sg1Fq [Occ=Once] ->
              case eta2_sg1Fk of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sg1Ft [Occ=Once] ->
                    Data.Functor.Classes.$p1Ord1
                        $dOrd2_sg1Fh eta_sg1Fi ds_sg1Fq y2_sg1Ft;
              };
        };

Data.Functor.Sum.$fOrd1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     Data.Functor.Classes.Ord1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(C1(C1(U))),C(C1(C1(U))))>m] =
    [] \r [$dOrd1_sg1Fu $dOrd2_sg1Fv]
        let {
          sat_sg1Fx [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Sum.Sum f_XfX7u g_XfX7w a
               -> Data.Functor.Sum.Sum f_XfX7u g_XfX7w b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sg1Fu $dOrd2_sg1Fv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrd1Sum_$cliftCompare
                      $dOrd1_sg1Fu $dOrd2_sg1Fv eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1Fw [Occ=Once]
            :: Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f_XfX7u g_XfX7w)
          [LclId] =
              [$dOrd1_sg1Fu $dOrd2_sg1Fv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrd1Sum1
                      $dOrd1_sg1Fu $dOrd2_sg1Fv eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sg1Fw sat_sg1Fx];

Data.Functor.Sum.$fRead1Sum8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "InL"#;

Data.Functor.Sum.$fRead1Sum7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Functor.Sum.$fRead1Sum8;

Data.Functor.Sum.$fRead1Sum4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "InR"#;

Data.Functor.Sum.$fRead1Sum3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Functor.Sum.$fRead1Sum4;

Data.Functor.Sum.$fRead1Sum2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Sum.$fRead1Sum3];

Data.Functor.Sum.$fRead1Sum5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Sum.$fRead1Sum6 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Sum.$fRead1Sum7];

Data.Functor.Sum.$fRead1Sum1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Sum.Sum f g a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Fy $dRead2_sg1Fz rp_sg1FA rl_sg1FB]
        let {
          ds_sg1FC [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_afX4G a_afX54)
          [LclId] =
              [$dRead1_sg1Fy rp_sg1FA rl_sg1FB] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead1_sg1Fy rp_sg1FA rl_sg1FB; } in
        let {
          ds1_sg1FD [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (g_afX4H a_afX54)
          [LclId] =
              [$dRead2_sg1Fz rp_sg1FA rl_sg1FB] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead2_sg1Fz rp_sg1FA rl_sg1FB; } in
        let {
          $wlvl_sg1FE [InlPrag=NOUSERINLINE[0], Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: GHC.Prim.Int#
               -> forall b.
                  (Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [ds_sg1FC ds1_sg1FD] \r [ww_sg1FF w_sg1FG]
                  case <=# [ww_sg1FF 10#] of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                    1# ->
                        let {
                          sat_sg1FM [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_sfXzb
                          [LclId] =
                              [ds_sg1FC w_sg1FG] \r [a1_sg1FI]
                                  let {
                                    sat_sg1FL [Occ=Once]
                                      :: f_afX4G a_afX54 -> Text.ParserCombinators.ReadP.P b_sfXzb
                                    [LclId] =
                                        [w_sg1FG] \r [a2_sg1FJ]
                                            let {
                                              sat_sg1FK [Occ=Once]
                                                :: Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                                              [LclId] =
                                                  CCCS Data.Functor.Sum.InL! [a2_sg1FJ];
                                            } in  w_sg1FG sat_sg1FK;
                                  } in  ds_sg1FC Data.Functor.Sum.$fRead1Sum5 sat_sg1FL;
                        } in 
                          case
                              Text.Read.Lex.$wexpect Data.Functor.Sum.$fRead1Sum6 sat_sg1FM
                          of
                          { Unit# ww2_sg1FO [Occ=Once] ->
                                let {
                                  sat_sg1FX [Occ=Once] :: Text.ParserCombinators.ReadP.P b_sfXzb
                                  [LclId] =
                                      [ds1_sg1FD w_sg1FG] \u []
                                          let {
                                            sat_sg1FU [Occ=Once]
                                              :: () -> Text.ParserCombinators.ReadP.P b_sfXzb
                                            [LclId] =
                                                [ds1_sg1FD w_sg1FG] \r [a1_sg1FQ]
                                                    let {
                                                      sat_sg1FT [Occ=Once]
                                                        :: g_afX4H a_afX54
                                                           -> Text.ParserCombinators.ReadP.P b_sfXzb
                                                      [LclId] =
                                                          [w_sg1FG] \r [a2_sg1FR]
                                                              let {
                                                                sat_sg1FS [Occ=Once]
                                                                  :: Data.Functor.Sum.Sum
                                                                       f_afX4G g_afX4H a_afX54
                                                                [LclId] =
                                                                    CCCS Data.Functor.Sum.InR! [a2_sg1FR];
                                                              } in  w_sg1FG sat_sg1FS;
                                                    } in 
                                                      ds1_sg1FD
                                                          Data.Functor.Sum.$fRead1Sum5 sat_sg1FT;
                                          } in 
                                            case
                                                Text.Read.Lex.$wexpect
                                                    Data.Functor.Sum.$fRead1Sum2 sat_sg1FU
                                            of
                                            { Unit# ww4_sg1FW [Occ=Once] ->
                                                  Text.ParserCombinators.ReadP.Look [ww4_sg1FW];
                                            }; } in
                                let {
                                  sat_sg1FP [Occ=Once] :: Text.ParserCombinators.ReadP.P b_sfXzb
                                  [LclId] =
                                      CCCS Text.ParserCombinators.ReadP.Look! [ww2_sg1FO];
                                } in 
                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                      sat_sg1FP sat_sg1FX;
                          };
                  }; } in
        let {
          lvl8_sg1FY [InlPrag=NOUSERINLINE[0], Occ=OnceL, Dmd=<L,C(C(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
              [$wlvl_sg1FE] \r [w_sg1FZ w1_sg1G0]
                  case w_sg1FZ of {
                    GHC.Types.I# ww1_sg1G2 [Occ=Once] ->
                        $wlvl_sg1FE ww1_sg1G2 w1_sg1G0;
                  }; } in
        let {
          sat_sg1G5 [Occ=OnceT[0]]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [lvl8_sg1FY] \r [eta_sg1G3 eta1_sg1G4]
                  GHC.Read.list3 lvl8_sg1FY eta_sg1G3 eta1_sg1G4;
        } in  sat_sg1G5;

Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1G6 $dRead2_sg1G7 rp_sg1G8 rl_sg1G9]
        let {
          ds_sg1Ga [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_XfX6H g_XfX6J a_afX4N
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead1_sg1G6 $dRead2_sg1G7 rp_sg1G8 rl_sg1G9] \u []
                  let {
                    sat_sg1Gg [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_afX4N]
                    [LclId] =
                        [rl_sg1G9] \r [n_sg1Gc w1_sg1Gd]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sg1G9 w1_sg1Gd
                            of
                            { Unit# ww1_sg1Gf [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sg1Gf];
                            }; } in
                  let {
                    sat_sg1Gb [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_afX4N
                    [LclId] =
                        [rp_sg1G8] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sg1G8 eta_B1;
                  } in 
                    Data.Functor.Sum.$fRead1Sum1
                        $dRead1_sg1G6 $dRead2_sg1G7 sat_sg1Gb sat_sg1Gg; } in
        let {
          sat_sg1Gj [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX6H g_XfX6J a_afX4N)
          [LclId] =
              [ds_sg1Ga] \r [n_sg1Gh]
                  let {
                    sat_sg1Gi [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Sum.Sum f_XfX6H g_XfX6J a_afX4N)
                    [LclId] =
                        [ds_sg1Ga n_sg1Gh] \u []
                            ds_sg1Ga
                                n_sg1Gh Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sg1Gi;
        } in  sat_sg1Gj;

Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Gk $dRead2_sg1Gl rp_sg1Gm rl_sg1Gn]
        let {
          sat_sg1Go [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Sum.Sum f_XfX6F g_XfX6H a_afX5y)
          [LclId] =
              [$dRead1_sg1Gk $dRead2_sg1Gl rp_sg1Gm rl_sg1Gn] \s []
                  Data.Functor.Sum.$fRead1Sum1
                      $dRead1_sg1Gk $dRead2_sg1Gl rp_sg1Gm rl_sg1Gn;
        } in  GHC.Read.list sat_sg1Go;

Data.Functor.Sum.$fRead1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     Data.Functor.Classes.Read1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>m] =
    [] \r [$dRead1_sg1Gp $dRead2_sg1Gq]
        let {
          sat_sg1Gu [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Sum.Sum f_XfX6E g_XfX6G a]
          [LclId] =
              [$dRead1_sg1Gp $dRead2_sg1Gq] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec
                      $dRead1_sg1Gp $dRead2_sg1Gq eta_B2 eta_B1; } in
        let {
          sat_sg1Gt [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Sum.Sum f_XfX6E g_XfX6G a)
          [LclId] =
              [$dRead1_sg1Gp $dRead2_sg1Gq] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fRead1Sum1
                      $dRead1_sg1Gp $dRead2_sg1Gq eta_B2 eta_B1; } in
        let {
          sat_sg1Gs [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Sum.Sum f_XfX6E g_XfX6G a]
          [LclId] =
              [$dRead1_sg1Gp $dRead2_sg1Gq] \u []
                  Data.Functor.Sum.$fRead1Sum_$cliftReadList
                      $dRead1_sg1Gp $dRead2_sg1Gq; } in
        let {
          sat_sg1Gr [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX6E g_XfX6G a)
          [LclId] =
              [$dRead1_sg1Gp $dRead2_sg1Gq] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec
                      $dRead1_sg1Gp $dRead2_sg1Gq eta_B2 eta_B1;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sg1Gr
                                        sat_sg1Gs
                                        sat_sg1Gt
                                        sat_sg1Gu];
Data.Functor.Sum.$fRead1Sum_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Gv $dRead2_sg1Gw]
        let {
          sat_sg1Gx [Occ=Once]
            :: Data.Functor.Classes.Read1
                 (Data.Functor.Sum.Sum f_XfX6G g_XfX6I)
          [LclId] =
              [$dRead1_sg1Gv $dRead2_sg1Gw] \u []
                  Data.Functor.Sum.$fRead1Sum $dRead1_sg1Gv $dRead2_sg1Gw;
        } in  Data.Functor.Classes.liftReadListDefault sat_sg1Gx;

Data.Functor.Sum.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> Data.Functor.Sum.Sum f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1Gy w1_sg1Gz w2_sg1GA w3_sg1GB ww_sg1GC w4_sg1GD]
        case w4_sg1GD of {
          Data.Functor.Sum.InL x_sg1GF [Occ=Once] ->
              let {
                sat_sg1GG [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> f_sfXzA a_sfXzE -> GHC.Show.ShowS
                [LclId] =
                    [w_sg1Gy w2_sg1GA w3_sg1GB] \s []
                        Data.Functor.Classes.liftShowsPrec w_sg1Gy w2_sg1GA w3_sg1GB;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sg1GG Data.Functor.Sum.$fRead1Sum7 ww_sg1GC x_sg1GF;
          Data.Functor.Sum.InR y_sg1GH [Occ=Once] ->
              let {
                sat_sg1GI [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> g_sfXzB a_sfXzE -> GHC.Show.ShowS
                [LclId] =
                    [w1_sg1Gz w2_sg1GA w3_sg1GB] \s []
                        Data.Functor.Classes.liftShowsPrec w1_sg1Gz w2_sg1GA w3_sg1GB;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sg1GI Data.Functor.Sum.$fRead1Sum3 ww_sg1GC y_sg1GH;
        };

Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Sum.Sum f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1GJ w1_sg1GK w2_sg1GL w3_sg1GM w4_sg1GN w5_sg1GO]
        case w4_sg1GN of {
          GHC.Types.I# ww1_sg1GQ [Occ=Once] ->
              Data.Functor.Sum.$w$cliftShowsPrec
                  w_sg1GJ w1_sg1GK w2_sg1GL w3_sg1GM ww1_sg1GQ w5_sg1GO;
        };

Data.Functor.Sum.$fFoldableSum6 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Sum.$fShow1Sum_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Sum.Sum f g a]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U><L,U><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sg1GR
           $dShow2_sg1GS
           sp_sg1GT
           sl_sg1GU
           eta_sg1GV
           eta1_sg1GW]
        let {
          sat_sg1GY [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX4e g_afX4f a_afX4z -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg1GR $dShow2_sg1GS sp_sg1GT sl_sg1GU] \r [w_sg1GX]
                  Data.Functor.Sum.$w$cliftShowsPrec
                      $dShow1_sg1GR $dShow2_sg1GS sp_sg1GT sl_sg1GU 0# w_sg1GX;
        } in  GHC.Show.showList__ sat_sg1GY eta_sg1GV eta1_sg1GW;

Data.Functor.Sum.$fShow1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     Data.Functor.Classes.Show1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)>m] =
    [] \r [$dShow1_sg1GZ $dShow2_sg1H0]
        let {
          sat_sg1H2 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Sum.Sum f_afX4e g_afX4f a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg1GZ $dShow2_sg1H0] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fShow1Sum_$cliftShowList
                      $dShow1_sg1GZ $dShow2_sg1H0 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1H1 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Sum.Sum f_afX4e g_afX4f a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg1GZ $dShow2_sg1H0] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec
                      $dShow1_sg1GZ $dShow2_sg1H0 eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sg1H1 sat_sg1H2];

Data.Functor.Sum.$fEqSum_$c==
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sg1H3 $dEq2_sg1H4 $dEq_sg1H5 eta_sg1H6 eta1_sg1H7]
        let {
          sat_sg1H8 [Occ=Once] :: a_afX3V -> a_afX3V -> GHC.Types.Bool
          [LclId] =
              [$dEq_sg1H5] \u [] GHC.Classes.== $dEq_sg1H5;
        } in 
          Data.Functor.Sum.$fEq1Sum_$cliftEq
              $dEq1_sg1H3 $dEq2_sg1H4 sat_sg1H8 eta_sg1H6 eta1_sg1H7;

Data.Functor.Sum.$fEqSum_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sg1H9 $dEq2_sg1Ha $dEq_sg1Hb eta_sg1Hc eta1_sg1Hd]
        case eta_sg1Hc of {
          Data.Functor.Sum.InL x1_sg1Hf [Occ=Once] ->
              case eta1_sg1Hd of {
                Data.Functor.Sum.InL x2_sg1Hh [Occ=Once] ->
                    let {
                      sat_sg1Hi [Occ=Once] :: a_afX3V -> a_afX3V -> GHC.Types.Bool
                      [LclId] =
                          [$dEq_sg1Hb] \u [] GHC.Classes.== $dEq_sg1Hb;
                    } in 
                      case $dEq1_sg1H9 sat_sg1Hi x1_sg1Hf x2_sg1Hh of {
                        GHC.Types.False -> GHC.Types.True [];
                        GHC.Types.True -> GHC.Types.False [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Functor.Sum.InR ds_sg1Hl [Occ=Once] ->
              case eta1_sg1Hd of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.True [];
                Data.Functor.Sum.InR y2_sg1Ho [Occ=Once] ->
                    let {
                      sat_sg1Hp [Occ=Once] :: a_afX3V -> a_afX3V -> GHC.Types.Bool
                      [LclId] =
                          [$dEq_sg1Hb] \u [] GHC.Classes.== $dEq_sg1Hb;
                    } in 
                      case $dEq2_sg1Ha sat_sg1Hp ds_sg1Hl y2_sg1Ho of {
                        GHC.Types.False -> GHC.Types.True [];
                        GHC.Types.True -> GHC.Types.False [];
                      };
              };
        };

Data.Functor.Sum.$fEqSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     GHC.Classes.Eq (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><L,U(U,A)>m] =
    [] \r [$dEq1_sg1Hr $dEq2_sg1Hs $dEq_sg1Ht]
        let {
          sat_sg1Hv [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V
               -> Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sg1Hr $dEq2_sg1Hs $dEq_sg1Ht] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fEqSum_$c/=
                      $dEq1_sg1Hr $dEq2_sg1Hs $dEq_sg1Ht eta_B2 eta_B1; } in
        let {
          sat_sg1Hu [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V
               -> Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sg1Hr $dEq2_sg1Hs $dEq_sg1Ht] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fEqSum_$c==
                      $dEq1_sg1Hr $dEq2_sg1Hs $dEq_sg1Ht eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sg1Hu sat_sg1Hv];

Data.Functor.Sum.$fOrdSum_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1Hw $dOrd2_sg1Hx $dOrd_sg1Hy eta_sg1Hz eta1_sg1HA]
        let {
          sat_sg1HB [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sg1Hy] \u [] GHC.Classes.compare $dOrd_sg1Hy;
        } in 
          Data.Functor.Sum.$fOrd1Sum_$cliftCompare
              $dOrd1_sg1Hw $dOrd2_sg1Hx sat_sg1HB eta_sg1Hz eta1_sg1HA;

Data.Functor.Sum.$fOrdSum_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Eq (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1HC $dOrd2_sg1HD $dOrd_sg1HE]
        let {
          sat_sg1HH [Occ=Once, Dmd=<L,U(U,A)>] :: GHC.Classes.Eq a_afX37
          [LclId] =
              [$dOrd_sg1HE] \u [] GHC.Classes.$p1Ord $dOrd_sg1HE; } in
        let {
          sat_sg1HG [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 g_afX36
          [LclId] =
              [$dOrd2_sg1HD] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sg1HD; } in
        let {
          sat_sg1HF [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 f_afX35
          [LclId] =
              [$dOrd1_sg1HC] \u [] Data.Functor.Classes.$p1Ord1 $dOrd1_sg1HC;
        } in  Data.Functor.Sum.$fEqSum sat_sg1HF sat_sg1HG sat_sg1HH;

Data.Functor.Sum.$fOrdSum_$c<
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1HI $dOrd2_sg1HJ $dOrd_sg1HK x_sg1HL y_sg1HM]
        case x_sg1HL of {
          Data.Functor.Sum.InL x1_sg1HO [Occ=Once] ->
              case y_sg1HM of {
                Data.Functor.Sum.InL x2_sg1HQ [Occ=Once] ->
                    let {
                      sat_sg1HR [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1HK] \u [] GHC.Classes.compare $dOrd_sg1HK;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg1HI sat_sg1HR x1_sg1HO x2_sg1HQ
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.LT -> GHC.Types.True [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Functor.Sum.InR ds_sg1HU [Occ=Once] ->
              case y_sg1HM of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sg1HX [Occ=Once] ->
                    let {
                      sat_sg1HY [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1HK] \u [] GHC.Classes.compare $dOrd_sg1HK;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sg1HJ sat_sg1HY ds_sg1HU y2_sg1HX
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.LT -> GHC.Types.True [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$c>=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1I0 $dOrd2_sg1I1 $dOrd_sg1I2 x_sg1I3 y_sg1I4]
        case x_sg1I3 of {
          Data.Functor.Sum.InL x1_sg1I6 [Occ=Once] ->
              case y_sg1I4 of {
                Data.Functor.Sum.InL x2_sg1I8 [Occ=Once] ->
                    let {
                      sat_sg1I9 [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1I2] \u [] GHC.Classes.compare $dOrd_sg1I2;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg1I0 sat_sg1I9 x1_sg1I6 x2_sg1I8
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.LT -> GHC.Types.False [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds_sg1Ic [Occ=Once] ->
              case y_sg1I4 of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.True [];
                Data.Functor.Sum.InR y2_sg1If [Occ=Once] ->
                    let {
                      sat_sg1Ig [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1I2] \u [] GHC.Classes.compare $dOrd_sg1I2;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sg1I1 sat_sg1Ig ds_sg1Ic y2_sg1If
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.LT -> GHC.Types.False [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$c>
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1Ii $dOrd2_sg1Ij $dOrd_sg1Ik x_sg1Il y_sg1Im]
        case x_sg1Il of {
          Data.Functor.Sum.InL x1_sg1Io [Occ=Once] ->
              case y_sg1Im of {
                Data.Functor.Sum.InL x2_sg1Iq [Occ=Once] ->
                    let {
                      sat_sg1Ir [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1Ik] \u [] GHC.Classes.compare $dOrd_sg1Ik;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg1Ii sat_sg1Ir x1_sg1Io x2_sg1Iq
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.GT -> GHC.Types.True [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds_sg1Iu [Occ=Once] ->
              case y_sg1Im of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.True [];
                Data.Functor.Sum.InR y2_sg1Ix [Occ=Once] ->
                    let {
                      sat_sg1Iy [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1Ik] \u [] GHC.Classes.compare $dOrd_sg1Ik;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sg1Ij sat_sg1Iy ds_sg1Iu y2_sg1Ix
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.GT -> GHC.Types.True [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$c<=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1IA $dOrd2_sg1IB $dOrd_sg1IC x_sg1ID y_sg1IE]
        case x_sg1ID of {
          Data.Functor.Sum.InL x1_sg1IG [Occ=Once] ->
              case y_sg1IE of {
                Data.Functor.Sum.InL x2_sg1II [Occ=Once] ->
                    let {
                      sat_sg1IJ [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1IC] \u [] GHC.Classes.compare $dOrd_sg1IC;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg1IA sat_sg1IJ x1_sg1IG x2_sg1II
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.GT -> GHC.Types.False [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Functor.Sum.InR ds_sg1IM [Occ=Once] ->
              case y_sg1IE of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sg1IP [Occ=Once] ->
                    let {
                      sat_sg1IQ [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1IC] \u [] GHC.Classes.compare $dOrd_sg1IC;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sg1IB sat_sg1IQ ds_sg1IM y2_sg1IP
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.GT -> GHC.Types.False [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1IS $dOrd2_sg1IT $dOrd_sg1IU x_sg1IV y_sg1IW]
        case
            Data.Functor.Sum.$fOrdSum_$c<=
                $dOrd1_sg1IS $dOrd2_sg1IT $dOrd_sg1IU x_sg1IV y_sg1IW
        of
        { GHC.Types.False -> x_sg1IV;
          GHC.Types.True -> y_sg1IW;
        };

Data.Functor.Sum.$fOrdSum_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1IY $dOrd2_sg1IZ $dOrd_sg1J0 x_sg1J1 y_sg1J2]
        case
            Data.Functor.Sum.$fOrdSum_$c<=
                $dOrd1_sg1IY $dOrd2_sg1IZ $dOrd_sg1J0 x_sg1J1 y_sg1J2
        of
        { GHC.Types.False -> y_sg1J2;
          GHC.Types.True -> x_sg1J1;
        };

Data.Functor.Sum.$fOrdSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Ord (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m] =
    [] \r [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6]
        let {
          sat_sg1Je [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$cmin
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1Jd [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$cmax
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1Jc [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c>=
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1Jb [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c>
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1Ja [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c<=
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1J9 [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c<
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1J8 [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$ccompare
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1J7 [Occ=Once]
            :: GHC.Classes.Eq (Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37)
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \u []
                  Data.Functor.Sum.$fOrdSum_$cp1Ord
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6;
        } in 
          GHC.Classes.C:Ord [sat_sg1J7
                             sat_sg1J8
                             sat_sg1J9
                             sat_sg1Ja
                             sat_sg1Jb
                             sat_sg1Jc
                             sat_sg1Jd
                             sat_sg1Je];

Data.Functor.Sum.$fReadSum1
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Sum.Sum f g a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Jf $dRead2_sg1Jg $dRead_sg1Jh]
        let {
          sat_sg1Jj [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_afX2A]
          [LclId] =
              [$dRead_sg1Jh] \u [] GHC.Read.readListPrec $dRead_sg1Jh; } in
        let {
          sat_sg1Ji [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_afX2A
          [LclId] =
              [$dRead_sg1Jh] \u [] GHC.Read.readPrec $dRead_sg1Jh;
        } in 
          Data.Functor.Sum.$fRead1Sum1
              $dRead1_sg1Jf $dRead2_sg1Jg sat_sg1Ji sat_sg1Jj;

Data.Functor.Sum.$fReadSum_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Jk $dRead2_sg1Jl $dRead_sg1Jm]
        let {
          ds_sg1Jn [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_XfX50 g_XfX52 a_XfX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead1_sg1Jk $dRead2_sg1Jl $dRead_sg1Jm] \u []
                  let {
                    sat_sg1Jp [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_XfX54]
                    [LclId] =
                        [$dRead_sg1Jm] \u [] GHC.Read.readListPrec $dRead_sg1Jm; } in
                  let {
                    sat_sg1Jo [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_XfX54
                    [LclId] =
                        [$dRead_sg1Jm] \u [] GHC.Read.readPrec $dRead_sg1Jm;
                  } in 
                    Data.Functor.Sum.$fRead1Sum1
                        $dRead1_sg1Jk $dRead2_sg1Jl sat_sg1Jo sat_sg1Jp; } in
        let {
          sat_sg1Js [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX50 g_XfX52 a_XfX54)
          [LclId] =
              [ds_sg1Jn] \r [n_sg1Jq]
                  let {
                    sat_sg1Jr [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Sum.Sum f_XfX50 g_XfX52 a_XfX54)
                    [LclId] =
                        [ds_sg1Jn n_sg1Jq] \u []
                            ds_sg1Jn
                                n_sg1Jq Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sg1Jr;
        } in  sat_sg1Js;

Data.Functor.Sum.$fReadSum_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Jt $dRead2_sg1Ju $dRead_sg1Jv]
        let {
          sat_sg1Jy [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Sum.Sum f_XfX4Y g_XfX50 a_XfX52)
          [LclId] =
              [$dRead1_sg1Jt $dRead2_sg1Ju $dRead_sg1Jv] \s []
                  let {
                    sat_sg1Jx [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_XfX52]
                    [LclId] =
                        [$dRead_sg1Jv] \u [] GHC.Read.readListPrec $dRead_sg1Jv; } in
                  let {
                    sat_sg1Jw [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_XfX52
                    [LclId] =
                        [$dRead_sg1Jv] \u [] GHC.Read.readPrec $dRead_sg1Jv;
                  } in 
                    Data.Functor.Sum.$fRead1Sum1
                        $dRead1_sg1Jt $dRead2_sg1Ju sat_sg1Jw sat_sg1Jx;
        } in  GHC.Read.list sat_sg1Jy;

Data.Functor.Sum.$fReadSum_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadP.ReadS [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Jz $dRead2_sg1JA $dRead_sg1JB]
        let {
          sat_sg1JC [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Sum.Sum f_XfX4Z g_XfX51 a_XfX53]
          [LclId] =
              [$dRead1_sg1Jz $dRead2_sg1JA $dRead_sg1JB] \u []
                  Data.Functor.Sum.$fReadSum_$creadListPrec
                      $dRead1_sg1Jz
                      $dRead2_sg1JA
                      $dRead_sg1JB
                      GHC.Read.$fRead()7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sg1JC;

Data.Functor.Sum.$fReadSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Read.Read (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,U,U)>m] =
    [] \r [$dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF]
        let {
          sat_sg1JJ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51]
          [LclId] =
              [$dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF] \u []
                  Data.Functor.Sum.$fReadSum_$creadListPrec
                      $dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF; } in
        let {
          sat_sg1JI [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51)
          [LclId] =
              [$dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF] \u []
                  Data.Functor.Sum.$fReadSum1
                      $dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF; } in
        let {
          sat_sg1JH [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51]
          [LclId] =
              [$dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF] \u []
                  Data.Functor.Sum.$fReadSum_$creadList
                      $dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF; } in
        let {
          sat_sg1JG [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51)
          [LclId] =
              [$dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF] \u []
                  Data.Functor.Sum.$fReadSum_$creadsPrec
                      $dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF;
        } in  GHC.Read.C:Read [sat_sg1JG sat_sg1JH sat_sg1JI sat_sg1JJ];

Data.Functor.Sum.$fShowSum_$cshowsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Types.Int -> Data.Functor.Sum.Sum f g a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sg1JK
           $dShow2_sg1JL
           $dShow_sg1JM
           eta_sg1JN
           eta1_sg1JO]
        case eta_sg1JN of {
          GHC.Types.I# ww1_sg1JQ [Occ=Once] ->
              let {
                sat_sg1JS [Occ=Once] :: [a_afX2a] -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sg1JM] \u [] GHC.Show.showList $dShow_sg1JM; } in
              let {
                sat_sg1JR [Occ=Once] :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sg1JM] \u [] GHC.Show.showsPrec $dShow_sg1JM;
              } in 
                Data.Functor.Sum.$w$cliftShowsPrec
                    $dShow1_sg1JK
                    $dShow2_sg1JL
                    sat_sg1JR
                    sat_sg1JS
                    ww1_sg1JQ
                    eta1_sg1JO;
        };

Data.Functor.Sum.$fShowSum_$cshow
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     Data.Functor.Sum.Sum f g a -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*U,A,1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sg1JT $dShow2_sg1JU $dShow_sg1JV x_sg1JW]
        case x_sg1JW of {
          Data.Functor.Sum.InL x1_sg1JY [Occ=Once] ->
              let {
                sat_sg1K1 [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow1_sg1JT $dShow_sg1JV x1_sg1JY] \u []
                        let {
                          sat_sg1K0 [Occ=Once] :: [a_afX2a] -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sg1JV] \u [] GHC.Show.showList $dShow_sg1JV; } in
                        let {
                          sat_sg1JZ [Occ=Once] :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sg1JV] \u [] GHC.Show.showsPrec $dShow_sg1JV;
                        } in 
                          Data.Functor.Classes.liftShowsPrec
                              $dShow1_sg1JT
                              sat_sg1JZ
                              sat_sg1K0
                              Data.Functor.Classes.$fRead1Const1
                              x1_sg1JY
                              GHC.Types.[]; } in
              let {
                sat_sg1K2 [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sg1K1];
              } in  GHC.Base.++ Data.Functor.Sum.$fRead1Sum7 sat_sg1K2;
          Data.Functor.Sum.InR y_sg1K3 [Occ=Once] ->
              let {
                sat_sg1K6 [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow2_sg1JU $dShow_sg1JV y_sg1K3] \u []
                        let {
                          sat_sg1K5 [Occ=Once] :: [a_afX2a] -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sg1JV] \u [] GHC.Show.showList $dShow_sg1JV; } in
                        let {
                          sat_sg1K4 [Occ=Once] :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sg1JV] \u [] GHC.Show.showsPrec $dShow_sg1JV;
                        } in 
                          Data.Functor.Classes.liftShowsPrec
                              $dShow2_sg1JU
                              sat_sg1K4
                              sat_sg1K5
                              Data.Functor.Classes.$fRead1Const1
                              y_sg1K3
                              GHC.Types.[]; } in
              let {
                sat_sg1K7 [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sg1K6];
              } in  GHC.Base.++ Data.Functor.Sum.$fRead1Sum3 sat_sg1K7;
        };

Data.Functor.Sum.$fShowSum_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     [Data.Functor.Sum.Sum f g a] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sg1K8 $dShow2_sg1K9 $dShow_sg1Ka ls_sg1Kb s_sg1Kc]
        let {
          lvl8_sg1Kd [Occ=OnceL]
            :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sg1Ka] \u [] GHC.Show.showsPrec $dShow_sg1Ka; } in
        let {
          lvl9_sg1Ke [Occ=OnceL] :: [a_afX2a] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sg1Ka] \u [] GHC.Show.showList $dShow_sg1Ka; } in
        let {
          sat_sg1Kg [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg1K8 $dShow2_sg1K9 lvl8_sg1Kd lvl9_sg1Ke] \r [eta_sg1Kf]
                  Data.Functor.Sum.$w$cliftShowsPrec
                      $dShow1_sg1K8 $dShow2_sg1K9 lvl8_sg1Kd lvl9_sg1Ke 0# eta_sg1Kf;
        } in  GHC.Show.showList__ sat_sg1Kg ls_sg1Kb s_sg1Kc;

Data.Functor.Sum.$fShowSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Show.Show (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(U,A,U)>m] =
    [] \r [$dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj]
        let {
          sat_sg1Km [Occ=Once]
            :: [Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a] -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fShowSum_$cshowList
                      $dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj eta_B2 eta_B1; } in
        let {
          sat_sg1Kl [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a -> GHC.Base.String
          [LclId] =
              [$dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj] \r [eta_B1]
                  Data.Functor.Sum.$fShowSum_$cshow
                      $dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj eta_B1; } in
        let {
          sat_sg1Kk [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fShowSum_$cshowsPrec
                      $dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sg1Kk sat_sg1Kl sat_sg1Km];

Data.Functor.Sum.$fFunctorSum_$cfmap
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Sum.Sum f g a -> Data.Functor.Sum.Sum f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sg1Kn $dFunctor1_sg1Ko f1_sg1Kp ds_sg1Kq]
        case ds_sg1Kq of {
          Data.Functor.Sum.InL x_sg1Ks [Occ=Once] ->
              let {
                sat_sg1Kt [Occ=Once] :: f_afX1v b_afX1D
                [LclId] =
                    [$dFunctor_sg1Kn f1_sg1Kp x_sg1Ks] \u []
                        GHC.Base.fmap $dFunctor_sg1Kn f1_sg1Kp x_sg1Ks;
              } in  Data.Functor.Sum.InL [sat_sg1Kt];
          Data.Functor.Sum.InR y_sg1Ku [Occ=Once] ->
              let {
                sat_sg1Kv [Occ=Once] :: g_afX1w b_afX1D
                [LclId] =
                    [$dFunctor1_sg1Ko f1_sg1Kp y_sg1Ku] \u []
                        GHC.Base.fmap $dFunctor1_sg1Ko f1_sg1Kp y_sg1Ku;
              } in  Data.Functor.Sum.InR [sat_sg1Kv];
        };

Data.Functor.Sum.$fFunctorSum_$c<$
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     a -> Data.Functor.Sum.Sum f g b -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sg1Kw $dFunctor1_sg1Kx x_sg1Ky eta_sg1Kz]
        let {
          sat_sg1KB [Occ=Once] :: b_afX20 -> a_afX1Z
          [LclId] =
              [x_sg1Ky] \r [ds_sg1KA] x_sg1Ky;
        } in 
          Data.Functor.Sum.$fFunctorSum_$cfmap
              $dFunctor_sg1Kw $dFunctor1_sg1Kx sat_sg1KB eta_sg1Kz;

Data.Functor.Sum.$fFunctorSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     GHC.Base.Functor (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dFunctor_sg1KC $dFunctor1_sg1KD]
        let {
          sat_sg1KF [Occ=Once]
            :: forall a b.
               a
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w b
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w a
          [LclId] =
              [$dFunctor_sg1KC $dFunctor1_sg1KD] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFunctorSum_$c<$
                      $dFunctor_sg1KC $dFunctor1_sg1KD eta_B2 eta_B1; } in
        let {
          sat_sg1KE [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w a
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w b
          [LclId] =
              [$dFunctor_sg1KC $dFunctor1_sg1KD] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFunctorSum_$cfmap
                      $dFunctor_sg1KC $dFunctor1_sg1KD eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sg1KE sat_sg1KF];

Data.Functor.Sum.$fFoldableSum_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Functor.Sum.Sum f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1KG
           $dFoldable1_sg1KH
           $dMonoid_sg1KI
           f1_sg1KJ
           ds_sg1KK]
        case ds_sg1KK of {
          Data.Functor.Sum.InL x_sg1KM [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_sg1KG $dMonoid_sg1KI f1_sg1KJ x_sg1KM;
          Data.Functor.Sum.InR y_sg1KN [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_sg1KH $dMonoid_sg1KI f1_sg1KJ y_sg1KN;
        };

Data.Functor.Sum.$fFoldableSum_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => Data.Functor.Sum.Sum f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1KO $dFoldable1_sg1KP $dMonoid_sg1KQ ds_sg1KR]
        case ds_sg1KR of {
          Data.Functor.Sum.InL x_sg1KT [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_sg1KO $dMonoid_sg1KQ GHC.Base.id x_sg1KT;
          Data.Functor.Sum.InR y_sg1KU [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_sg1KP $dMonoid_sg1KQ GHC.Base.id y_sg1KU;
        };

Data.Functor.Sum.$fFoldableSum2 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sg1KV] v_sg1KV;

Data.Functor.Sum.$fFoldableSum3
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     Data.Functor.Sum.Sum f g a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1KW $dFoldable1_sg1KX $dNum_sg1KY]
        let {
          $dMonoid_sg1KZ [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_afX1c)
          [LclId] =
              [$dNum_sg1KY] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sg1KY; } in
        let {
          sat_sg1L4 [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_XfX1N g_XfX1P a_afX1c
               -> Data.Semigroup.Internal.Sum a_afX1c
          [LclId] =
              [$dFoldable_sg1KW $dFoldable1_sg1KX $dMonoid_sg1KZ] \r [ds_sg1L0]
                  case ds_sg1L0 of {
                    Data.Functor.Sum.InL x_sg1L2 [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_sg1KW
                            $dMonoid_sg1KZ
                            Data.Functor.Sum.$fFoldableSum2
                            x_sg1L2;
                    Data.Functor.Sum.InR y_sg1L3 [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_sg1KX
                            $dMonoid_sg1KZ
                            Data.Functor.Sum.$fFoldableSum2
                            y_sg1L3;
                  };
        } in  sat_sg1L4;

lvl_rfXP1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Functor.Sum.$fFoldableSum4 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rfXP1 of sat_sg1L5 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg1L5;
        };

Data.Functor.Sum.$fFoldableSum_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1L6 $dFoldable1_sg1L7 $dOrd_sg1L8]
        let {
          g1_sg1L9 [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_afX12)
          [LclId] =
              [$dOrd_sg1L8] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_sg1L8; } in
        let {
          sat_sg1Li [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_XfX1M g_XfX1O a_afX12 -> a_afX12
          [LclId] =
              [$dFoldable_sg1L6 $dFoldable1_sg1L7 g1_sg1L9] \r [x_sg1La]
                  case x_sg1La of {
                    Data.Functor.Sum.InL x1_sg1Lc [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_sg1L6 g1_sg1L9 GHC.Base.Just x1_sg1Lc
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum4;
                          GHC.Base.Just v_sg1Le [Occ=Once] -> v_sg1Le;
                        };
                    Data.Functor.Sum.InR y_sg1Lf [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sg1L7 g1_sg1L9 GHC.Base.Just y_sg1Lf
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum4;
                          GHC.Base.Just v_sg1Lh [Occ=Once] -> v_sg1Lh;
                        };
                  };
        } in  sat_sg1Li;

lvl1_rfXP2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Functor.Sum.$fFoldableSum5 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rfXP2 of sat_sg1Lj {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg1Lj;
        };

Data.Functor.Sum.$fFoldableSum_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1Lk $dFoldable1_sg1Ll $dOrd_sg1Lm]
        let {
          g1_sg1Ln [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_afX0S)
          [LclId] =
              [$dOrd_sg1Lm] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_sg1Lm; } in
        let {
          sat_sg1Lw [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_XfX1L g_XfX1N a_afX0S -> a_afX0S
          [LclId] =
              [$dFoldable_sg1Lk $dFoldable1_sg1Ll g1_sg1Ln] \r [x_sg1Lo]
                  case x_sg1Lo of {
                    Data.Functor.Sum.InL x1_sg1Lq [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_sg1Lk g1_sg1Ln GHC.Base.Just x1_sg1Lq
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum5;
                          GHC.Base.Just v_sg1Ls [Occ=Once] -> v_sg1Ls;
                        };
                    Data.Functor.Sum.InR y_sg1Lt [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sg1Ll g1_sg1Ln GHC.Base.Just y_sg1Lt
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum5;
                          GHC.Base.Just v_sg1Lv [Occ=Once] -> v_sg1Lv;
                        };
                  };
        } in  sat_sg1Lw;

Data.Functor.Sum.$fFoldableSum_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1Lx $dFoldable1_sg1Ly $dEq_sg1Lz eta_sg1LA]
        let {
          f1_sg1LB [Occ=OnceL*] :: a_afX0I -> GHC.Types.Bool
          [LclId] =
              [$dEq_sg1Lz eta_sg1LA] \u []
                  GHC.Classes.== $dEq_sg1Lz eta_sg1LA; } in
        let {
          sat_sg1LG [Occ=Once]
            :: Data.Functor.Sum.Sum f_XfX1K g_XfX1M a_afX0I
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_sg1Lx $dFoldable1_sg1Ly f1_sg1LB] \r [ds_sg1LC]
                  case ds_sg1LC of {
                    Data.Functor.Sum.InL x_sg1LE [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_sg1Lx
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_sg1LB
                            x_sg1LE;
                    Data.Functor.Sum.InR y_sg1LF [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_sg1Ly
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_sg1LB
                            y_sg1LF;
                  };
        } in  sat_sg1LG;

Data.Functor.Sum.$fFoldableSum10
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Functor.Sum.$fFoldableSum_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1LH
           $dFoldable1_sg1LI
           f1_sg1LJ
           z_sg1LK
           t1_sg1LL]
        let {
          f2_sg1LM [Occ=Once*] :: a_afWZL -> b_afWZK -> b_afWZK
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [f1_sg1LJ] \r [x_sg1LN y_sg1LO] f1_sg1LJ y_sg1LO x_sg1LN;
        } in 
          case t1_sg1LL of {
            Data.Functor.Sum.InL x_sg1LQ [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable_sg1LH
                    Data.Functor.Sum.$fFoldableSum10
                    f2_sg1LM
                    x_sg1LQ
                    z_sg1LK;
            Data.Functor.Sum.InR y_sg1LR [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable1_sg1LI
                    Data.Functor.Sum.$fFoldableSum10
                    f2_sg1LM
                    y_sg1LR
                    z_sg1LK;
          };

lvl2_rfXP3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Functor.Sum.$fFoldableSum9 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rfXP3 of sat_sg1LS {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg1LS;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1LT $dFoldable1_sg1LU f1_sg1LV xs_sg1LW]
        case xs_sg1LW of {
          Data.Functor.Sum.InL x_sg1LY [Occ=Once] ->
              let {
                sat_sg1M4 [Occ=Once]
                  :: a_afX0c
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_afX0c))
                [LclId] =
                    [f1_sg1LV] \r [x1_sg1LZ y_sg1M0]
                        let {
                          sat_sg1M3 [Occ=Once] :: a_afX0c
                          [LclId] =
                              [f1_sg1LV x1_sg1LZ y_sg1M0] \u []
                                  case y_sg1M0 of {
                                    GHC.Base.Nothing -> x1_sg1LZ;
                                    GHC.Base.Just x2_sg1M2 [Occ=Once] -> f1_sg1LV x2_sg1M2 x1_sg1LZ;
                                  };
                        } in  GHC.Base.Just [sat_sg1M3];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable_sg1LT
                        Data.Functor.Sum.$fFoldableSum10
                        sat_sg1M4
                        x_sg1LY
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum9;
                  GHC.Base.Just v_sg1M6 [Occ=Once] -> v_sg1M6;
                };
          Data.Functor.Sum.InR y_sg1M7 [Occ=Once] ->
              let {
                sat_sg1Md [Occ=Once]
                  :: a_afX0c
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_afX0c))
                [LclId] =
                    [f1_sg1LV] \r [x_sg1M8 y1_sg1M9]
                        let {
                          sat_sg1Mc [Occ=Once] :: a_afX0c
                          [LclId] =
                              [f1_sg1LV x_sg1M8 y1_sg1M9] \u []
                                  case y1_sg1M9 of {
                                    GHC.Base.Nothing -> x_sg1M8;
                                    GHC.Base.Just x1_sg1Mb [Occ=Once] -> f1_sg1LV x1_sg1Mb x_sg1M8;
                                  };
                        } in  GHC.Base.Just [sat_sg1Mc];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable1_sg1LU
                        Data.Functor.Sum.$fFoldableSum10
                        sat_sg1Md
                        y_sg1M7
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum9;
                  GHC.Base.Just v_sg1Mf [Occ=Once] -> v_sg1Mf;
                };
        };

Data.Functor.Sum.$fFoldableSum_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1Mg
           $dFoldable1_sg1Mh
           f1_sg1Mi
           z0_sg1Mj
           xs_sg1Mk]
        case xs_sg1Mk of {
          Data.Functor.Sum.InL x_sg1Mm [Occ=Once] ->
              let {
                sat_sg1Mr [Occ=Once]
                  :: a_afWZA
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_afWZB -> b_afWZB))
                [LclId] =
                    [f1_sg1Mi] \r [x1_sg1Mn y_sg1Mo z_sg1Mp]
                        case f1_sg1Mi x1_sg1Mn z_sg1Mp of vx_sg1Mq {
                          __DEFAULT -> y_sg1Mo vx_sg1Mq;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable_sg1Mg
                    Data.Functor.Sum.$fFoldableSum10
                    sat_sg1Mr
                    x_sg1Mm
                    GHC.Base.id
                    z0_sg1Mj;
          Data.Functor.Sum.InR y_sg1Ms [Occ=Once] ->
              let {
                sat_sg1Mx [Occ=Once]
                  :: a_afWZA
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_afWZB -> b_afWZB))
                [LclId] =
                    [f1_sg1Mi] \r [x_sg1Mt y1_sg1Mu z_sg1Mv]
                        case f1_sg1Mi x_sg1Mt z_sg1Mv of vx_sg1Mw {
                          __DEFAULT -> y1_sg1Mu vx_sg1Mw;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable1_sg1Mh
                    Data.Functor.Sum.$fFoldableSum10
                    sat_sg1Mx
                    y_sg1Ms
                    GHC.Base.id
                    z0_sg1Mj;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1My
           $dFoldable1_sg1Mz
           f1_sg1MA
           z_sg1MB
           t1_sg1MC]
        case t1_sg1MC of {
          Data.Functor.Sum.InL x_sg1ME [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_sg1My
                  Data.Semigroup.Internal.$fMonoidEndo
                  f1_sg1MA
                  x_sg1ME
                  z_sg1MB;
          Data.Functor.Sum.InR y_sg1MF [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_sg1Mz
                  Data.Semigroup.Internal.$fMonoidEndo
                  f1_sg1MA
                  y_sg1MF
                  z_sg1MB;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1MG
           $dFoldable1_sg1MH
           f1_sg1MI
           z0_sg1MJ
           xs_sg1MK]
        let {
          sat_sg1MP [Occ=Once]
            :: a_afWZV -> (b_afWZU -> b_afWZU) -> b_afWZU -> b_afWZU
          [LclId] =
              [f1_sg1MI] \r [x_sg1ML k_sg1MM z_sg1MN]
                  case f1_sg1MI z_sg1MN x_sg1ML of vx_sg1MO {
                    __DEFAULT -> k_sg1MM vx_sg1MO;
                  };
        } in 
          Data.Functor.Sum.$fFoldableSum_$cfoldr
              $dFoldable_sg1MG
              $dFoldable1_sg1MH
              sat_sg1MP
              GHC.Base.id
              xs_sg1MK
              z0_sg1MJ;

Data.Functor.Sum.$fFoldableSum7
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_sg1MQ k_sg1MR z_sg1MS]
        case z_sg1MS of {
          GHC.Types.I# x1_sg1MU [Occ=Once] ->
              case +# [x1_sg1MU 1#] of sat_sg1MV {
                __DEFAULT ->
                    let {
                      sat_sg1MW [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sg1MV];
                    } in  k_sg1MR sat_sg1MW;
              };
        };

Data.Functor.Sum.$fFoldableSum_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Sum.Sum f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1MX $dFoldable1_sg1MY eta_sg1MZ]
        Data.Functor.Sum.$fFoldableSum_$cfoldr
            $dFoldable_sg1MX
            $dFoldable1_sg1MY
            Data.Functor.Sum.$fFoldableSum7
            GHC.Base.id
            eta_sg1MZ
            Data.Functor.Sum.$fFoldableSum6;

lvl3_rfXP4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Functor.Sum.$fFoldableSum11 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_rfXP4 of sat_sg1N0 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg1N0;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1N1 $dFoldable1_sg1N2 f1_sg1N3 xs_sg1N4]
        let {
          sat_sg1Na [Occ=Once]
            :: a_afX04 -> GHC.Base.Maybe a_afX04 -> GHC.Base.Maybe a_afX04
          [LclId] =
              [f1_sg1N3] \r [x_sg1N5 m_sg1N6]
                  let {
                    sat_sg1N9 [Occ=Once] :: a_afX04
                    [LclId] =
                        [f1_sg1N3 x_sg1N5 m_sg1N6] \u []
                            case m_sg1N6 of {
                              GHC.Base.Nothing -> x_sg1N5;
                              GHC.Base.Just y_sg1N8 [Occ=Once] -> f1_sg1N3 x_sg1N5 y_sg1N8;
                            };
                  } in  GHC.Base.Just [sat_sg1N9];
        } in 
          case
              Data.Functor.Sum.$fFoldableSum_$cfoldr
                  $dFoldable_sg1N1
                  $dFoldable1_sg1N2
                  sat_sg1Na
                  GHC.Base.Nothing
                  xs_sg1N4
          of
          { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum11;
            GHC.Base.Just v_sg1Nc [Occ=Once] -> v_sg1Nc;
          };

Data.Functor.Sum.$fFoldableSum8
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sg1Nd ds1_sg1Ne] GHC.Types.False [];

Data.Functor.Sum.$fFoldableSum_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1Nf $dFoldable1_sg1Ng eta_sg1Nh]
        Data.Functor.Sum.$fFoldableSum_$cfoldr
            $dFoldable_sg1Nf
            $dFoldable1_sg1Ng
            Data.Functor.Sum.$fFoldableSum8
            GHC.Types.True
            eta_sg1Nh;

Data.Functor.Sum.$fFoldableSum1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     Data.Functor.Sum.Sum f g a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1Ni $dFoldable1_sg1Nj $dNum_sg1Nk]
        let {
          $dMonoid_sg1Nl [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_afX1m)
          [LclId] =
              [$dNum_sg1Nk] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sg1Nk; } in
        let {
          sat_sg1Nq [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_afWYR g_afWYS a_afX1m
               -> Data.Semigroup.Internal.Product a_afX1m
          [LclId] =
              [$dFoldable_sg1Ni $dFoldable1_sg1Nj $dMonoid_sg1Nl] \r [ds_sg1Nm]
                  case ds_sg1Nm of {
                    Data.Functor.Sum.InL x_sg1No [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_sg1Ni
                            $dMonoid_sg1Nl
                            Data.Functor.Sum.$fFoldableSum2
                            x_sg1No;
                    Data.Functor.Sum.InR y_sg1Np [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_sg1Nj
                            $dMonoid_sg1Nl
                            Data.Functor.Sum.$fFoldableSum2
                            y_sg1Np;
                  };
        } in  sat_sg1Nq;

Data.Functor.Sum.$fFoldableSum_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Sum.Sum f g a -> [a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1Nr $dFoldable1_sg1Ns eta_sg1Nt]
        Data.Functor.Sum.$fFoldableSum_$cfoldr
            $dFoldable_sg1Nr
            $dFoldable1_sg1Ns
            GHC.Types.:
            GHC.Types.[]
            eta_sg1Nt;

Data.Functor.Sum.$fFoldableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_sg1Nu $dFoldable1_sg1Nv]
        let {
          sat_sg1NL [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum1
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1NK [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum3
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1NJ [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cminimum
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1NI [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cmaximum
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1NH [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$celem
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B2 eta_B1; } in
        let {
          sat_sg1NG [Occ=Once]
            :: forall a.
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$clength
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1NF [Occ=Once]
            :: forall a.
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cnull
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1NE [Occ=Once]
            :: forall a. Data.Functor.Sum.Sum f_afWYR g_afWYS a -> [a]
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$ctoList
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1ND [Occ=Once]
            :: forall a.
               (a -> a -> a) -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldl1
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B2 eta_B1; } in
        let {
          sat_sg1NC [Occ=Once]
            :: forall a.
               (a -> a -> a) -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldr1
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B2 eta_B1; } in
        let {
          sat_sg1NB [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldl'
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1NA [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldl
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1Nz [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldr'
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1Ny [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldr
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1Nx [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> m
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldMap
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1Nw [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS m -> m
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfold
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_sg1Nw
                                    sat_sg1Nx
                                    sat_sg1Ny
                                    sat_sg1Nz
                                    sat_sg1NA
                                    sat_sg1NB
                                    sat_sg1NC
                                    sat_sg1ND
                                    sat_sg1NE
                                    sat_sg1NF
                                    sat_sg1NG
                                    sat_sg1NH
                                    sat_sg1NI
                                    sat_sg1NJ
                                    sat_sg1NK
                                    sat_sg1NL];

Data.Functor.Sum.$fTraversableSum_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> Data.Functor.Sum.Sum f g a -> f1 (Data.Functor.Sum.Sum f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg1NM
           $dTraversable1_sg1NN
           $dApplicative_sg1NO
           eta_sg1NP
           eta1_sg1NQ]
        case eta1_sg1NQ of {
          Data.Functor.Sum.InL x_sg1NS [Occ=Once] ->
              let {
                sat_sg1NU [Occ=Once] :: f1_afWXF (f_afWXq b_afWXH)
                [LclId] =
                    [$dTraversable_sg1NM $dApplicative_sg1NO eta_sg1NP x_sg1NS] \u []
                        Data.Traversable.traverse
                            $dTraversable_sg1NM $dApplicative_sg1NO eta_sg1NP x_sg1NS;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sg1NO of sat_sg1NT {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sg1NT Data.Functor.Sum.InL sat_sg1NU;
                };
          Data.Functor.Sum.InR y_sg1NV [Occ=Once] ->
              let {
                sat_sg1NX [Occ=Once] :: f1_afWXF (g_afWXr b_afWXH)
                [LclId] =
                    [$dTraversable1_sg1NN $dApplicative_sg1NO eta_sg1NP y_sg1NV] \u []
                        Data.Traversable.traverse
                            $dTraversable1_sg1NN $dApplicative_sg1NO eta_sg1NP y_sg1NV;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sg1NO of sat_sg1NW {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sg1NW Data.Functor.Sum.InR sat_sg1NX;
                };
        };

Data.Functor.Sum.$fTraversableSum_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (Data.Functor.Sum.Sum f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg1NY $dTraversable1_sg1NZ]
        let {
          sat_sg1O1 [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_afWXr
          [LclId] =
              [$dTraversable1_sg1NZ] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sg1NZ; } in
        let {
          sat_sg1O0 [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_afWXq
          [LclId] =
              [$dTraversable_sg1NY] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sg1NY;
        } in  Data.Functor.Sum.$fFoldableSum sat_sg1O0 sat_sg1O1;

Data.Functor.Sum.$fTraversableSum_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (Data.Functor.Sum.Sum f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg1O2 $dTraversable1_sg1O3]
        let {
          sat_sg1O5 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor g_afWXr
          [LclId] =
              [$dTraversable1_sg1O3] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sg1O3; } in
        let {
          sat_sg1O4 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_afWXq
          [LclId] =
              [$dTraversable_sg1O2] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sg1O2;
        } in  Data.Functor.Sum.$fFunctorSum sat_sg1O4 sat_sg1O5;

Data.Functor.Sum.$fTraversableSum_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     Data.Functor.Sum.Sum f g (f1 a) -> f1 (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg1O6
           $dTraversable1_sg1O7
           $dApplicative_sg1O8
           eta_B1]
        Data.Functor.Sum.$fTraversableSum_$ctraverse
            $dTraversable_sg1O6
            $dTraversable1_sg1O7
            $dApplicative_sg1O8
            GHC.Base.id
            eta_B1;

Data.Functor.Sum.$fTraversableSum_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg1O9
           $dTraversable1_sg1Oa
           $dMonad_sg1Ob
           eta_sg1Oc
           eta1_sg1Od]
        case GHC.Base.$p1Monad $dMonad_sg1Ob of sat_sg1Oe {
          __DEFAULT ->
              Data.Functor.Sum.$fTraversableSum_$ctraverse
                  $dTraversable_sg1O9
                  $dTraversable1_sg1Oa
                  sat_sg1Oe
                  eta_sg1Oc
                  eta1_sg1Od;
        };

Data.Functor.Sum.$fTraversableSum_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Sum.Sum f g (m a) -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg1Of
           $dTraversable1_sg1Og
           $dMonad_sg1Oh
           eta_sg1Oi]
        case GHC.Base.$p1Monad $dMonad_sg1Oh of sat_sg1Oj {
          __DEFAULT ->
              Data.Functor.Sum.$fTraversableSum_$ctraverse
                  $dTraversable_sg1Of
                  $dTraversable1_sg1Og
                  sat_sg1Oj
                  GHC.Base.id
                  eta_sg1Oi;
        };

Data.Functor.Sum.$fTraversableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sg1Ok $dTraversable1_sg1Ol]
        let {
          sat_sg1Or [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               Data.Functor.Sum.Sum f_afWXq g_afWXr (m a)
               -> m (Data.Functor.Sum.Sum f_afWXq g_afWXr a)
          [LclId] =
              [$dTraversable_sg1Ok $dTraversable1_sg1Ol] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$csequence
                      $dTraversable_sg1Ok $dTraversable1_sg1Ol eta_B2 eta_B1; } in
        let {
          sat_sg1Oq [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> Data.Functor.Sum.Sum f_afWXq g_afWXr a
               -> m (Data.Functor.Sum.Sum f_afWXq g_afWXr b)
          [LclId] =
              [$dTraversable_sg1Ok $dTraversable1_sg1Ol] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$cmapM
                      $dTraversable_sg1Ok $dTraversable1_sg1Ol eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1Op [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               Data.Functor.Sum.Sum f_afWXq g_afWXr (f a)
               -> f (Data.Functor.Sum.Sum f_afWXq g_afWXr a)
          [LclId] =
              [$dTraversable_sg1Ok $dTraversable1_sg1Ol] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$csequenceA
                      $dTraversable_sg1Ok $dTraversable1_sg1Ol eta_B2 eta_B1; } in
        let {
          sat_sg1Oo [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> Data.Functor.Sum.Sum f_afWXq g_afWXr a
               -> f (Data.Functor.Sum.Sum f_afWXq g_afWXr b)
          [LclId] =
              [$dTraversable_sg1Ok $dTraversable1_sg1Ol] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$ctraverse
                      $dTraversable_sg1Ok $dTraversable1_sg1Ol eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1On [Occ=Once]
            :: Data.Foldable.Foldable (Data.Functor.Sum.Sum f_afWXq g_afWXr)
          [LclId] =
              [$dTraversable_sg1Ok $dTraversable1_sg1Ol] \u []
                  Data.Functor.Sum.$fTraversableSum_$cp2Traversable
                      $dTraversable_sg1Ok $dTraversable1_sg1Ol; } in
        let {
          sat_sg1Om [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Sum.Sum f_afWXq g_afWXr)
          [LclId] =
              [$dTraversable_sg1Ok $dTraversable1_sg1Ol] \u []
                  Data.Functor.Sum.$fTraversableSum_$cp1Traversable
                      $dTraversable_sg1Ok $dTraversable1_sg1Ol;
        } in 
          Data.Traversable.C:Traversable [sat_sg1Om
                                          sat_sg1On
                                          sat_sg1Oo
                                          sat_sg1Op
                                          sat_sg1Oq
                                          sat_sg1Or];

Data.Functor.Sum.$fGeneric1Sum_$cto1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Data.Functor.Sum.Sum f g) a
     -> Data.Functor.Sum.Sum f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sg1Os]
        case ds_sg1Os of {
          GHC.Generics.L1 ds1_sg1Ou [Occ=Once] ->
              Data.Functor.Sum.InL [ds1_sg1Ou];
          GHC.Generics.R1 ds1_sg1Ov [Occ=Once] ->
              Data.Functor.Sum.InR [ds1_sg1Ov];
        };

Data.Functor.Sum.$fGeneric1Sum1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Sum.Sum f g a
     -> (GHC.Generics.:+:)
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InL" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.Rec1 f)))
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InR" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.Rec1 g)))
          a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sg1Ow]
        case x_sg1Ow of {
          Data.Functor.Sum.InL g1_sg1Oy [Occ=Once] ->
              GHC.Generics.L1 [g1_sg1Oy];
          Data.Functor.Sum.InR g1_sg1Oz [Occ=Once] ->
              GHC.Generics.R1 [g1_sg1Oz];
        };

Data.Functor.Sum.$fGeneric1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *).
     GHC.Generics.Generic1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Functor.Sum.$fGeneric1Sum1
                                            Data.Functor.Sum.$fGeneric1Sum_$cto1];

Data.Functor.Sum.$fGenericSum_$cto
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Data.Functor.Sum.Sum f g a) x
     -> Data.Functor.Sum.Sum f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sg1OA]
        case ds_sg1OA of {
          GHC.Generics.L1 ds1_sg1OC [Occ=Once] ->
              Data.Functor.Sum.InL [ds1_sg1OC];
          GHC.Generics.R1 ds1_sg1OD [Occ=Once] ->
              Data.Functor.Sum.InR [ds1_sg1OD];
        };

Data.Functor.Sum.$fGenericSum1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     Data.Functor.Sum.Sum f g a
     -> (GHC.Generics.:+:)
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InL" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.K1 GHC.Generics.R (f a))))
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InR" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.K1 GHC.Generics.R (g a))))
          x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sg1OE]
        case x1_sg1OE of {
          Data.Functor.Sum.InL g1_sg1OG [Occ=Once] ->
              GHC.Generics.L1 [g1_sg1OG];
          Data.Functor.Sum.InR g1_sg1OH [Occ=Once] ->
              GHC.Generics.R1 [g1_sg1OH];
        };

Data.Functor.Sum.$fGenericSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Generic (Data.Functor.Sum.Sum f g a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Sum.$fGenericSum1
                                           Data.Functor.Sum.$fGenericSum_$cto];

Data.Functor.Sum.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.ConstrRep
     -> Data.Data.DataType
     -> c (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=6,
 Str=<L,U><L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [w_sg1OI w1_sg1OJ w2_sg1OK w3_sg1OL ww_sg1OM ww1_sg1ON]
        case ww_sg1OM of {
          __DEFAULT ->
              case ww1_sg1ON of {
                Data.Data.DataType ww7_sg1OQ [Occ=Once] _ [Occ=Dead] ->
                    Data.Data.$wlvl ww7_sg1OQ;
              };
          Data.Data.AlgConstr idx_sg1OT [Occ=Once!] ->
              case idx_sg1OT of {
                GHC.Types.I# ds_sg1OV [Occ=Once!] ->
                    case ds_sg1OV of {
                      __DEFAULT ->
                          let {
                            sat_sg1OX [Occ=Once]
                              :: c_sfXCk (g_sfXCc a_sfXCd
                                          -> Data.Functor.Sum.Sum f_sfXCb g_sfXCc a_sfXCd)
                            [LclId] =
                                [w3_sg1OL] \u [] w3_sg1OL Data.Functor.Sum.InR;
                          } in  w2_sg1OK w1_sg1OJ sat_sg1OX;
                      1# ->
                          let {
                            sat_sg1OY [Occ=Once]
                              :: c_sfXCk (f_sfXCb a_sfXCd
                                          -> Data.Functor.Sum.Sum f_sfXCb g_sfXCc a_sfXCd)
                            [LclId] =
                                [w3_sg1OL] \u [] w3_sg1OL Data.Functor.Sum.InL;
                          } in  w2_sg1OK w_sg1OI sat_sg1OY;
                    };
              };
        };

Data.Functor.Sum.$fDataSum_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=OtherCon []] =
    [] \r [w_sg1OZ
           w1_sg1P0
           w2_sg1P1
           w3_sg1P2
           w4_sg1P3
           w5_sg1P4
           w6_sg1P5
           w7_sg1P6
           w8_sg1P7]
        case w8_sg1P7 of {
          Data.Data.Constr ww1_sg1P9 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           ww5_sg1Pd [Occ=Once] ->
              Data.Functor.Sum.$w$cgunfold
                  w4_sg1P3 w5_sg1P4 w6_sg1P5 w7_sg1P6 ww1_sg1P9 ww5_sg1Pd;
        };

Data.Functor.Sum.$fDataSum_$cgfoldl
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g1. g1 -> c g1)
     -> Data.Functor.Sum.Sum f g a
     -> c (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg1Pe
           $dTypeable1_sg1Pf
           $dTypeable2_sg1Pg
           $dTypeable3_sg1Ph
           $dData_sg1Pi
           $dData1_sg1Pj
           k1_sg1Pk
           z_sg1Pl
           ds_sg1Pm]
        case ds_sg1Pm of {
          Data.Functor.Sum.InL a1_sg1Po [Occ=Once] ->
              let {
                sat_sg1Pp [Occ=Once]
                  :: c_afWQl (f_afWQ5 a_afWQ7
                              -> Data.Functor.Sum.Sum f_afWQ5 g_afWQ6 a_afWQ7)
                [LclId] =
                    [z_sg1Pl] \u [] z_sg1Pl Data.Functor.Sum.InL;
              } in  k1_sg1Pk $dData_sg1Pi sat_sg1Pp a1_sg1Po;
          Data.Functor.Sum.InR a1_sg1Pq [Occ=Once] ->
              let {
                sat_sg1Pr [Occ=Once]
                  :: c_afWQl (g_afWQ6 a_afWQ7
                              -> Data.Functor.Sum.Sum f_afWQ5 g_afWQ6 a_afWQ7)
                [LclId] =
                    [z_sg1Pl] \u [] z_sg1Pl Data.Functor.Sum.InR;
              } in  k1_sg1Pk $dData1_sg1Pj sat_sg1Pr a1_sg1Pq;
        };

Data.Functor.Sum.$fDataSum8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Sum"#;

$tSum1_rfXP5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Functor.Sum.$fDataSum8;

go61_rfXP6
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sg1Ps _ys_sg1Pt]
        case ds2_sg1Ps of {
          [] -> GHC.List.badHead;
          : ipv_sg1Pv [Occ=Once!] ipv1_sg1Pw [Occ=Once] ->
              case _ys_sg1Pt of {
                [] -> GHC.List.badHead;
                : ipv2_sg1Py [Occ=Once] ipv3_sg1Pz [Occ=Once] ->
                    case ipv_sg1Pv of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sg1PC [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sg1PC Data.Functor.Sum.$fRead1Sum7 of {
                            GHC.Types.False -> go61_rfXP6 ipv1_sg1Pw ipv3_sg1Pz;
                            GHC.Types.True -> ipv2_sg1Py;
                          };
                    };
              };
        };

go1_rfXP7
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sg1PH _ys_sg1PI]
        case ds2_sg1PH of {
          [] -> GHC.List.badHead;
          : ipv_sg1PK [Occ=Once!] ipv1_sg1PL [Occ=Once] ->
              case _ys_sg1PI of {
                [] -> GHC.List.badHead;
                : ipv2_sg1PN [Occ=Once] ipv3_sg1PO [Occ=Once] ->
                    case ipv_sg1PK of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sg1PR [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sg1PR Data.Functor.Sum.$fRead1Sum3 of {
                            GHC.Types.False -> go1_rfXP7 ipv1_sg1PL ipv3_sg1PO;
                            GHC.Types.True -> ipv2_sg1PN;
                          };
                    };
              };
        };

$cInL1_rfXP8 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cInL2_rfXPe];
$cInR1_rfXP9 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cInR2_rfXPd];
Data.Functor.Sum.$cInL [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cInL1_rfXP8
                                     Data.Functor.Sum.$fRead1Sum7
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Functor.Sum.$tSum];
$tSum2_rfXPa :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Sum.$cInR GHC.Types.[]];
$tSum3_rfXPb :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Sum.$cInL $tSum2_rfXPa];
$tSum4_rfXPc :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [$tSum3_rfXPb];
Data.Functor.Sum.$tSum [Occ=LoopBreaker] :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [$tSum1_rfXP5 $tSum4_rfXPc];
Data.Functor.Sum.$cInR [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cInR1_rfXP9
                                     Data.Functor.Sum.$fRead1Sum3
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Functor.Sum.$tSum];
$cInR2_rfXPd :: Data.Data.ConIndex
[GblId] =
    [] \u [] go1_rfXP7 $tSum3_rfXPb Data.Data.mkConstr1;
$cInL2_rfXPe :: Data.Data.ConIndex
[GblId] =
    [] \u [] go61_rfXP6 $tSum3_rfXPb Data.Data.mkConstr1;

Data.Functor.Sum.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Sum.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$trModule4];

Data.Functor.Sum.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Sum"#;

Data.Functor.Sum.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$trModule2];

Data.Functor.Sum.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Sum.$trModule3
                                     Data.Functor.Sum.$trModule1];

$krep_rfXPf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_rfXPg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rfXPf GHC.Types.krep$*];

$krep2_rfXPh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfXPg $krep1_rfXPg];

Data.Functor.Sum.$fDataSum6 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfXPg $krep2_rfXPh];

$krep3_rfXPi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep4_rfXPj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_rfXPk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [3#];

$krep6_rfXPl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rfXPj $krep5_rfXPk];

$krep7_rfXPm :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep3_rfXPi $krep5_rfXPk];

Data.Functor.Sum.$fDataSum7 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$fDataSum8];

Data.Functor.Sum.$tcSum :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6345190594862254730##
                                    1236278515871186010##
                                    Data.Functor.Sum.$trModule
                                    Data.Functor.Sum.$fDataSum7
                                    1#
                                    Data.Functor.Sum.$fDataSum6];

$krep8_rfXPn :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep5_rfXPk GHC.Types.[]];

$krep9_rfXPo :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rfXPi $krep8_rfXPn];

$krep10_rfXPp :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rfXPj $krep9_rfXPo];

$krep11_rfXPq :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rfXPf $krep10_rfXPp];

$krep12_rfXPr :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Sum.$tcSum
                                              $krep11_rfXPq];

Data.Functor.Sum.$tc'InL1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rfXPl $krep12_rfXPr];

Data.Functor.Sum.$tc'InL3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'InL"#;

Data.Functor.Sum.$tc'InL2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$tc'InL3];

Data.Functor.Sum.$tc'InL :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7951421854502432011##
                                    12303552236073891860##
                                    Data.Functor.Sum.$trModule
                                    Data.Functor.Sum.$tc'InL2
                                    4#
                                    Data.Functor.Sum.$tc'InL1];

Data.Functor.Sum.$tc'InR1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_rfXPm $krep12_rfXPr];

Data.Functor.Sum.$tc'InR3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'InR"#;

Data.Functor.Sum.$tc'InR2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$tc'InR3];

Data.Functor.Sum.$tc'InR :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12078304815884238110##
                                    12377490770432979855##
                                    Data.Functor.Sum.$trModule
                                    Data.Functor.Sum.$tc'InR2
                                    4#
                                    Data.Functor.Sum.$tc'InR1];

Data.Functor.Sum.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Sum.Sum f g a)
[GblId, Arity=4, Str=<S,U><S,U><S,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sg1PW w1_sg1PX w2_sg1PY w3_sg1PZ]
        let {
          sat_sg1Q0 [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w3_sg1PZ]; } in
        let {
          sat_sg1Q1 [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sg1Q0 GHC.Types.[]];
        } in 
          case
              Data.Typeable.Internal.$wmkTrCon
                  6345190594862254730##
                  1236278515871186010##
                  Data.Functor.Sum.$trModule
                  Data.Functor.Sum.$fDataSum7
                  1#
                  Data.Functor.Sum.$fDataSum6
                  sat_sg1Q1
          of
          { (#,,,,#) ww8_sg1Q3 [Occ=Once]
                     ww9_sg1Q4 [Occ=Once]
                     ww10_sg1Q5 [Occ=Once]
                     ww11_sg1Q6 [Occ=Once]
                     ww12_sg1Q7 [Occ=Once] ->
                let {
                  sat_sg1Q8 [Occ=Once]
                    :: Data.Typeable.Internal.TypeRep Data.Functor.Sum.Sum
                  [LclId] =
                      CCCS Data.Typeable.Internal.TrTyCon! [ww8_sg1Q3
                                                            ww9_sg1Q4
                                                            ww10_sg1Q5
                                                            ww11_sg1Q6
                                                            ww12_sg1Q7];
                } in 
                  case
                      Data.Typeable.Internal.mkTrApp sat_sg1Q8 w1_sg1PX
                  of
                  sat_sg1Q9
                  { __DEFAULT ->
                        case
                            Data.Typeable.Internal.mkTrApp sat_sg1Q9 w2_sg1PY
                        of
                        sat_sg1Qa
                        { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sg1Qa w_sg1PW;
                        };
                  };
          };

Data.Functor.Sum.$fDataSum5 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sg1Qb w1_sg1Qc w2_sg1Qd w3_sg1Qe w4_sg1Qf w5_sg1Qg]
        Data.Functor.Sum.$w$cp1Data w_sg1Qb w1_sg1Qc w2_sg1Qd w3_sg1Qe;

Data.Functor.Sum.$fDataSum2
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (f a -> Data.Functor.Sum.Sum f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Sum.InL GHC.Types.False];

Data.Functor.Sum.$fDataSum1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (g a -> Data.Functor.Sum.Sum f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Sum.InR GHC.Types.False];

Data.Functor.Sum.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1Qh w1_sg1Qi w2_sg1Qj w3_sg1Qk w4_sg1Ql]
        let {
          lvl8_sg1Qm [Occ=OnceL]
            :: m_sfXD1 (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
          [LclId] =
              [w2_sg1Qj] \u [] GHC.Base.mzero w2_sg1Qj;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sg1Qj
          of
          $dMonad_sg1Qn [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sg1QR [Occ=Once]
                    :: (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU, GHC.Types.Bool)
                       -> m_sfXD1 (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
                  [LclId] =
                      [lvl8_sg1Qm $dMonad_sg1Qn] \r [ds_sg1QM]
                          case ds_sg1QM of {
                            (,) x'_sg1QO [Occ=Once] b_sg1QP [Occ=Once!] ->
                                case b_sg1QP of {
                                  GHC.Types.False -> lvl8_sg1Qm;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sg1Qn x'_sg1QO;
                                };
                          }; } in
                let {
                  sat_sg1QL [Occ=Once]
                    :: m_sfXD1 (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sg1Qh w1_sg1Qi w2_sg1Qj w3_sg1Qk w4_sg1Ql $dMonad_sg1Qn] \u []
                          let {
                            k1_sg1Qo [Occ=Once*!, Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
                              :: forall d b.
                                 Data.Data.Data d =>
                                 Data.Data.Mp m_sfXD1 (d -> b) -> d -> m_sfXD1 (b, GHC.Types.Bool)
                            [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                sat-only [w2_sg1Qj w3_sg1Qk $dMonad_sg1Qn] \r [$dData1_sg1Qp
                                                                               ds_sg1Qq
                                                                               y_sg1Qr]
                                    let {
                                      lvl9_sg1Qs [Occ=OnceL] :: m_sfXD1 d_ae2Ws
                                      [LclId] =
                                          [w3_sg1Qk $dData1_sg1Qp y_sg1Qr] \u []
                                              w3_sg1Qk $dData1_sg1Qp y_sg1Qr; } in
                                    let {
                                      sat_sg1QF [Occ=Once]
                                        :: (d_ae2Ws -> b_ae2Wt, GHC.Types.Bool)
                                           -> m_sfXD1 (b_ae2Wt, GHC.Types.Bool)
                                      [LclId] =
                                          [w2_sg1Qj $dMonad_sg1Qn y_sg1Qr lvl9_sg1Qs] \r [ds1_sg1Qt]
                                              case ds1_sg1Qt of {
                                                (,) h_sg1Qv b1_sg1Qw [Occ=Once] ->
                                                    let {
                                                      sat_sg1QE [Occ=Once]
                                                        :: m_sfXD1 (b_ae2Wt, GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sg1Qn
                                                           y_sg1Qr
                                                           h_sg1Qv
                                                           b1_sg1Qw] \u []
                                                              let {
                                                                sat_sg1QC [Occ=Once] :: b_ae2Wt
                                                                [LclId] =
                                                                    [y_sg1Qr h_sg1Qv] \u []
                                                                        h_sg1Qv y_sg1Qr; } in
                                                              let {
                                                                sat_sg1QD [Occ=Once]
                                                                  :: (b_ae2Wt, GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sg1QC b1_sg1Qw];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sg1Qn sat_sg1QD; } in
                                                    let {
                                                      sat_sg1QB [Occ=Once]
                                                        :: m_sfXD1 (b_ae2Wt, GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sg1Qn lvl9_sg1Qs h_sg1Qv] \u []
                                                              let {
                                                                sat_sg1QA [Occ=Once]
                                                                  :: d_ae2Ws
                                                                     -> m_sfXD1 (b_ae2Wt,
                                                                                 GHC.Types.Bool)
                                                                [LclId] =
                                                                    [$dMonad_sg1Qn
                                                                     h_sg1Qv] \r [y'_sg1Qx]
                                                                        let {
                                                                          sat_sg1Qy [Occ=Once]
                                                                            :: b_ae2Wt
                                                                          [LclId] =
                                                                              [h_sg1Qv
                                                                               y'_sg1Qx] \u []
                                                                                  h_sg1Qv
                                                                                      y'_sg1Qx; } in
                                                                        let {
                                                                          sat_sg1Qz [Occ=Once]
                                                                            :: (b_ae2Wt,
                                                                                GHC.Types.Bool)
                                                                          [LclId] =
                                                                              CCCS (,)! [sat_sg1Qy
                                                                                         GHC.Types.True];
                                                                        } in 
                                                                          GHC.Base.return
                                                                              $dMonad_sg1Qn
                                                                              sat_sg1Qz;
                                                              } in 
                                                                GHC.Base.>>=
                                                                    $dMonad_sg1Qn
                                                                    lvl9_sg1Qs
                                                                    sat_sg1QA;
                                                    } in 
                                                      GHC.Base.mplus w2_sg1Qj sat_sg1QB sat_sg1QE;
                                              };
                                    } in  GHC.Base.>>= $dMonad_sg1Qn ds_sg1Qq sat_sg1QF;
                          } in 
                            case w4_sg1Ql of {
                              Data.Functor.Sum.InL a1_sg1QH [Occ=Once] ->
                                  let {
                                    sat_sg1QI [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXD1
                                           (f_sfXCS a_sfXCU
                                            -> Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
                                    [LclId] =
                                        [$dMonad_sg1Qn] \u []
                                            GHC.Base.return
                                                $dMonad_sg1Qn Data.Functor.Sum.$fDataSum2;
                                  } in  k1_sg1Qo w_sg1Qh sat_sg1QI a1_sg1QH;
                              Data.Functor.Sum.InR a1_sg1QJ [Occ=Once] ->
                                  let {
                                    sat_sg1QK [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXD1
                                           (g_sfXCT a_sfXCU
                                            -> Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
                                    [LclId] =
                                        [$dMonad_sg1Qn] \u []
                                            GHC.Base.return
                                                $dMonad_sg1Qn Data.Functor.Sum.$fDataSum1;
                                  } in  k1_sg1Qo w1_sg1Qi sat_sg1QK a1_sg1QJ;
                            };
                } in  GHC.Base.>>= $dMonad_sg1Qn sat_sg1QL sat_sg1QR;
          };

Data.Functor.Sum.$fDataSum_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1QS
           w1_sg1QT
           w2_sg1QU
           w3_sg1QV
           w4_sg1QW
           w5_sg1QX
           w6_sg1QY
           w7_sg1QZ
           w8_sg1R0]
        Data.Functor.Sum.$w$cgmapMp
            w4_sg1QW w5_sg1QX w6_sg1QY w7_sg1QZ w8_sg1R0;

Data.Functor.Sum.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1R1 w1_sg1R2 w2_sg1R3 w3_sg1R4 w4_sg1R5]
        let {
          k1_sg1R6 [Occ=Once*!, Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
            :: forall d b.
               Data.Data.Data d =>
               m_sfXDl (d -> b) -> d -> m_sfXDl b
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w2_sg1R3 w3_sg1R4] \r [$dData1_sg1R7 c_sg1R8 x_sg1R9]
                  let {
                    lvl8_sg1Ra [Occ=OnceL] :: m_sfXDl d_ae2Vh
                    [LclId] =
                        [w3_sg1R4 $dData1_sg1R7 x_sg1R9] \u []
                            w3_sg1R4 $dData1_sg1R7 x_sg1R9; } in
                  let {
                    sat_sg1Rf [Occ=Once] :: (d_ae2Vh -> b_ae2Vi) -> m_sfXDl b_ae2Vi
                    [LclId] =
                        [w2_sg1R3 lvl8_sg1Ra] \r [c'_sg1Rb]
                            let {
                              sat_sg1Re [Occ=Once] :: d_ae2Vh -> m_sfXDl b_ae2Vi
                              [LclId] =
                                  [w2_sg1R3 c'_sg1Rb] \r [x'_sg1Rc]
                                      let {
                                        sat_sg1Rd [Occ=Once] :: b_ae2Vi
                                        [LclId] =
                                            [c'_sg1Rb x'_sg1Rc] \u [] c'_sg1Rb x'_sg1Rc;
                                      } in  GHC.Base.return w2_sg1R3 sat_sg1Rd;
                            } in  GHC.Base.>>= w2_sg1R3 lvl8_sg1Ra sat_sg1Re;
                  } in  GHC.Base.>>= w2_sg1R3 c_sg1R8 sat_sg1Rf;
        } in 
          case w4_sg1R5 of {
            Data.Functor.Sum.InL a1_sg1Rh [Occ=Once] ->
                let {
                  sat_sg1Ri [Occ=Once]
                    :: m_sfXDl (f_sfXDc a_sfXDe
                                -> Data.Functor.Sum.Sum f_sfXDc g_sfXDd a_sfXDe)
                  [LclId] =
                      [w2_sg1R3] \u [] GHC.Base.return w2_sg1R3 Data.Functor.Sum.InL;
                } in  k1_sg1R6 w_sg1R1 sat_sg1Ri a1_sg1Rh;
            Data.Functor.Sum.InR a1_sg1Rj [Occ=Once] ->
                let {
                  sat_sg1Rk [Occ=Once]
                    :: m_sfXDl (g_sfXDd a_sfXDe
                                -> Data.Functor.Sum.Sum f_sfXDc g_sfXDd a_sfXDe)
                  [LclId] =
                      [w2_sg1R3] \u [] GHC.Base.return w2_sg1R3 Data.Functor.Sum.InR;
                } in  k1_sg1R6 w1_sg1R2 sat_sg1Rk a1_sg1Rj;
          };

Data.Functor.Sum.$fDataSum_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1Rl
           w1_sg1Rm
           w2_sg1Rn
           w3_sg1Ro
           w4_sg1Rp
           w5_sg1Rq
           w6_sg1Rr
           w7_sg1Rs
           w8_sg1Rt]
        Data.Functor.Sum.$w$cgmapM
            w4_sg1Rp w5_sg1Rq w6_sg1Rr w7_sg1Rs w8_sg1Rt;

Data.Functor.Sum.$fDataSum_$cgmapQi
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Functor.Sum.Sum f g a
     -> u
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg1Ru
           $dTypeable1_sg1Rv
           $dTypeable2_sg1Rw
           $dTypeable3_sg1Rx
           $dData_sg1Ry
           $dData1_sg1Rz
           ds_sg1RA
           ds1_sg1RB
           x_sg1RC]
        case x_sg1RC of {
          Data.Functor.Sum.InL a1_sg1RE [Occ=Once] ->
              case ds_sg1RA of {
                GHC.Types.I# x1_sg1RG [Occ=Once!] ->
                    case x1_sg1RG of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sg1RB $dData_sg1Ry a1_sg1RE;
                    };
              };
          Data.Functor.Sum.InR a1_sg1RI [Occ=Once] ->
              case ds_sg1RA of {
                GHC.Types.I# x1_sg1RK [Occ=Once!] ->
                    case x1_sg1RK of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sg1RB $dData1_sg1Rz a1_sg1RI;
                    };
              };
        };

Data.Functor.Sum.$fDataSum_$cgmapQr
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Sum.Sum f g a
     -> r
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg1RM
           $dTypeable1_sg1RN
           $dTypeable2_sg1RO
           $dTypeable3_sg1RP
           $dData_sg1RQ
           $dData1_sg1RR
           ds_sg1RS
           ds1_sg1RT
           ds2_sg1RU
           x0_sg1RV]
        case x0_sg1RV of {
          Data.Functor.Sum.InL a1_sg1RX [Occ=Once] ->
              let {
                sat_sg1RY [Occ=Once] :: r'_afWSm
                [LclId] =
                    [$dData_sg1RQ ds2_sg1RU a1_sg1RX] \u []
                        ds2_sg1RU $dData_sg1RQ a1_sg1RX;
              } in  ds_sg1RS sat_sg1RY ds1_sg1RT;
          Data.Functor.Sum.InR a1_sg1RZ [Occ=Once] ->
              let {
                sat_sg1S0 [Occ=Once] :: r'_afWSm
                [LclId] =
                    [$dData1_sg1RR ds2_sg1RU a1_sg1RZ] \u []
                        ds2_sg1RU $dData1_sg1RR a1_sg1RZ;
              } in  ds_sg1RS sat_sg1S0 ds1_sg1RT;
        };

Data.Functor.Sum.$fDataSum_$cgmapQ
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Functor.Sum.Sum f g a -> [u]
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><L,1*C1(C1(U))><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg1S1
           $dTypeable1_sg1S2
           $dTypeable2_sg1S3
           $dTypeable3_sg1S4
           $dData_sg1S5
           $dData1_sg1S6
           ds_sg1S7
           x0_sg1S8]
        case x0_sg1S8 of {
          Data.Functor.Sum.InL a1_sg1Sa [Occ=Once] ->
              let {
                sat_sg1Sb [Occ=Once] :: u_afWSC
                [LclId] =
                    [$dData_sg1S5 ds_sg1S7 a1_sg1Sa] \u []
                        ds_sg1S7 $dData_sg1S5 a1_sg1Sa;
              } in  : [sat_sg1Sb GHC.Types.[]];
          Data.Functor.Sum.InR a1_sg1Sc [Occ=Once] ->
              let {
                sat_sg1Sd [Occ=Once] :: u_afWSC
                [LclId] =
                    [$dData1_sg1S6 ds_sg1S7 a1_sg1Sc] \u []
                        ds_sg1S7 $dData1_sg1S6 a1_sg1Sc;
              } in  : [sat_sg1Sd GHC.Types.[]];
        };

Data.Functor.Sum.$fDataSum3
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Const.Const r (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg1Se
           $dTypeable1_sg1Sf
           $dTypeable2_sg1Sg
           $dTypeable3_sg1Sh
           $dData_sg1Si
           $dData1_sg1Sj
           ds_sg1Sk
           ds1_sg1Sl
           ds2_sg1Sm
           eta_sg1Sn]
        case eta_sg1Sn of {
          Data.Functor.Sum.InL a1_sg1Sp [Occ=Once] ->
              let {
                sat_sg1Sq [Occ=Once] :: r'_afWS5
                [LclId] =
                    [$dData_sg1Si ds2_sg1Sm a1_sg1Sp] \u []
                        ds2_sg1Sm $dData_sg1Si a1_sg1Sp;
              } in  ds_sg1Sk ds1_sg1Sl sat_sg1Sq;
          Data.Functor.Sum.InR a1_sg1Sr [Occ=Once] ->
              let {
                sat_sg1Ss [Occ=Once] :: r'_afWS5
                [LclId] =
                    [$dData1_sg1Sj ds2_sg1Sm a1_sg1Sr] \u []
                        ds2_sg1Sm $dData1_sg1Sj a1_sg1Sr;
              } in  ds_sg1Sk ds1_sg1Sl sat_sg1Ss;
        };

Data.Functor.Sum.$fDataSum4
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Identity.Identity (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg1St
           $dTypeable1_sg1Su
           $dTypeable2_sg1Sv
           $dTypeable3_sg1Sw
           $dData_sg1Sx
           $dData1_sg1Sy
           ds_sg1Sz
           x0_sg1SA]
        case x0_sg1SA of {
          Data.Functor.Sum.InL a1_sg1SC [Occ=Once] ->
              let {
                sat_sg1SD [Occ=Once] :: f_XfWUu a_XfWUy
                [LclId] =
                    [$dData_sg1Sx ds_sg1Sz a1_sg1SC] \u []
                        ds_sg1Sz $dData_sg1Sx a1_sg1SC;
              } in  Data.Functor.Sum.InL [sat_sg1SD];
          Data.Functor.Sum.InR a1_sg1SE [Occ=Once] ->
              let {
                sat_sg1SF [Occ=Once] :: g_XfWUw a_XfWUy
                [LclId] =
                    [$dData1_sg1Sy ds_sg1Sz a1_sg1SE] \u []
                        ds_sg1Sz $dData1_sg1Sy a1_sg1SE;
              } in  Data.Functor.Sum.InR [sat_sg1SF];
        };

Data.Functor.Sum.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1SG w1_sg1SH w2_sg1SI w3_sg1SJ w4_sg1SK]
        let {
          lvl8_sg1SL [Occ=OnceL]
            :: m_sfXDF (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
          [LclId] =
              [w2_sg1SI] \u [] GHC.Base.mzero w2_sg1SI;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sg1SI
          of
          $dMonad_sg1SM [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sg1Tj [Occ=Once]
                    :: (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy, GHC.Types.Bool)
                       -> m_sfXDF (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
                  [LclId] =
                      [lvl8_sg1SL $dMonad_sg1SM] \r [ds_sg1Te]
                          case ds_sg1Te of {
                            (,) x'_sg1Tg [Occ=Once] b_sg1Th [Occ=Once!] ->
                                case b_sg1Th of {
                                  GHC.Types.False -> lvl8_sg1SL;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sg1SM x'_sg1Tg;
                                };
                          }; } in
                let {
                  sat_sg1Td [Occ=Once]
                    :: m_sfXDF (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sg1SG w1_sg1SH w2_sg1SI w3_sg1SJ w4_sg1SK $dMonad_sg1SM] \u []
                          let {
                            k1_sg1SN [Occ=Once*!, Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
                              :: forall d b.
                                 Data.Data.Data d =>
                                 Data.Data.Mp m_sfXDF (d -> b) -> d -> m_sfXDF (b, GHC.Types.Bool)
                            [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                sat-only [w2_sg1SI w3_sg1SJ $dMonad_sg1SM] \r [$dData1_sg1SO
                                                                               ds_sg1SP
                                                                               y_sg1SQ]
                                    let {
                                      lvl9_sg1SR [Occ=OnceL] :: m_sfXDF d_ae2Ya
                                      [LclId] =
                                          [w3_sg1SJ $dData1_sg1SO y_sg1SQ] \u []
                                              w3_sg1SJ $dData1_sg1SO y_sg1SQ; } in
                                    let {
                                      sat_sg1T7 [Occ=Once]
                                        :: (d_ae2Ya -> b_ae2Yb, GHC.Types.Bool)
                                           -> m_sfXDF (b_ae2Yb, GHC.Types.Bool)
                                      [LclId] =
                                          [w2_sg1SI $dMonad_sg1SM y_sg1SQ lvl9_sg1SR] \r [ds1_sg1SS]
                                              case ds1_sg1SS of {
                                                (,) h_sg1SU b1_sg1SV [Occ=Once!] ->
                                                    case b1_sg1SV of {
                                                      GHC.Types.False ->
                                                          let {
                                                            sat_sg1T4 [Occ=Once]
                                                              :: m_sfXDF (b_ae2Yb, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sg1SM
                                                                 y_sg1SQ
                                                                 h_sg1SU] \u []
                                                                    let {
                                                                      sat_sg1T2 [Occ=Once]
                                                                        :: b_ae2Yb
                                                                      [LclId] =
                                                                          [y_sg1SQ h_sg1SU] \u []
                                                                              h_sg1SU y_sg1SQ; } in
                                                                    let {
                                                                      sat_sg1T3 [Occ=Once]
                                                                        :: (b_ae2Yb, GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sg1T2
                                                                                     GHC.Types.False];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sg1SM
                                                                          sat_sg1T3; } in
                                                          let {
                                                            sat_sg1T1 [Occ=Once]
                                                              :: m_sfXDF (b_ae2Yb, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sg1SM
                                                                 lvl9_sg1SR
                                                                 h_sg1SU] \u []
                                                                    let {
                                                                      sat_sg1T0 [Occ=Once]
                                                                        :: d_ae2Ya
                                                                           -> m_sfXDF (b_ae2Yb,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sg1SM
                                                                           h_sg1SU] \r [y'_sg1SX]
                                                                              let {
                                                                                sat_sg1SY [Occ=Once]
                                                                                  :: b_ae2Yb
                                                                                [LclId] =
                                                                                    [h_sg1SU
                                                                                     y'_sg1SX] \u []
                                                                                        h_sg1SU
                                                                                            y'_sg1SX; } in
                                                                              let {
                                                                                sat_sg1SZ [Occ=Once]
                                                                                  :: (b_ae2Yb,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sg1SY
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sg1SM
                                                                                    sat_sg1SZ;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sg1SM
                                                                          lvl9_sg1SR
                                                                          sat_sg1T0;
                                                          } in 
                                                            GHC.Base.mplus
                                                                w2_sg1SI sat_sg1T1 sat_sg1T4;
                                                      GHC.Types.True ->
                                                          let {
                                                            sat_sg1T5 [Occ=Once] :: b_ae2Yb
                                                            [LclId] =
                                                                [y_sg1SQ h_sg1SU] \u []
                                                                    h_sg1SU y_sg1SQ; } in
                                                          let {
                                                            sat_sg1T6 [Occ=Once]
                                                              :: (b_ae2Yb, GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sg1T5
                                                                           GHC.Types.True];
                                                          } in 
                                                            GHC.Base.return $dMonad_sg1SM sat_sg1T6;
                                                    };
                                              };
                                    } in  GHC.Base.>>= $dMonad_sg1SM ds_sg1SP sat_sg1T7;
                          } in 
                            case w4_sg1SK of {
                              Data.Functor.Sum.InL a1_sg1T9 [Occ=Once] ->
                                  let {
                                    sat_sg1Ta [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXDF
                                           (f_sfXDw a_sfXDy
                                            -> Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
                                    [LclId] =
                                        [$dMonad_sg1SM] \u []
                                            GHC.Base.return
                                                $dMonad_sg1SM Data.Functor.Sum.$fDataSum2;
                                  } in  k1_sg1SN w_sg1SG sat_sg1Ta a1_sg1T9;
                              Data.Functor.Sum.InR a1_sg1Tb [Occ=Once] ->
                                  let {
                                    sat_sg1Tc [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXDF
                                           (g_sfXDx a_sfXDy
                                            -> Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
                                    [LclId] =
                                        [$dMonad_sg1SM] \u []
                                            GHC.Base.return
                                                $dMonad_sg1SM Data.Functor.Sum.$fDataSum1;
                                  } in  k1_sg1SN w1_sg1SH sat_sg1Tc a1_sg1Tb;
                            };
                } in  GHC.Base.>>= $dMonad_sg1SM sat_sg1Td sat_sg1Tj;
          };

Data.Functor.Sum.$fDataSum_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1Tk
           w1_sg1Tl
           w2_sg1Tm
           w3_sg1Tn
           w4_sg1To
           w5_sg1Tp
           w6_sg1Tq
           w7_sg1Tr
           w8_sg1Ts]
        Data.Functor.Sum.$w$cgmapMo
            w4_sg1To w5_sg1Tp w6_sg1Tq w7_sg1Tr w8_sg1Ts;

lvl4_rfXPs
  :: forall k (g :: k -> *) (a :: k) (f :: k -> *).
     Data.Functor.Sum.Sum f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sg1Tt]
        case ds_sg1Tt of {
          Data.Functor.Sum.InL _ [Occ=Dead] -> Data.Functor.Sum.$cInL;
          Data.Functor.Sum.InR _ [Occ=Dead] -> Data.Functor.Sum.$cInR;
        };

lvl5_rfXPt
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Sum.Sum f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sg1Tx] Data.Functor.Sum.$tSum;

lvl6_rfXPu
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Functor.Sum.Sum f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sg1Ty ds_sg1Tz] GHC.Base.Nothing [];

lvl7_rfXPv
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Functor.Sum.Sum f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sg1TA ds_sg1TB] GHC.Base.Nothing [];

Data.Functor.Sum.$fDataSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Data.Data (Data.Functor.Sum.Sum f g a)
[GblId[DFunId], Arity=6, Str=<L,U><L,U><L,U><L,U><L,U><L,U>] =
    [] \r [$dTypeable_sg1TC
           $dTypeable1_sg1TD
           $dTypeable2_sg1TE
           $dTypeable3_sg1TF
           $dData_sg1TG
           $dData1_sg1TH]
        let {
          sat_sg1U1 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> m (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dData_sg1TG $dData1_sg1TH] \r [w_sg1TY w1_sg1TZ w2_sg1U0]
                  Data.Functor.Sum.$w$cgmapMo
                      $dData_sg1TG $dData1_sg1TH w_sg1TY w1_sg1TZ w2_sg1U0; } in
        let {
          sat_sg1TX [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> m (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dData_sg1TG $dData1_sg1TH] \r [w_sg1TU w1_sg1TV w2_sg1TW]
                  Data.Functor.Sum.$w$cgmapMp
                      $dData_sg1TG $dData1_sg1TH w_sg1TU w1_sg1TV w2_sg1TW; } in
        let {
          sat_sg1TT [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> m (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dData_sg1TG $dData1_sg1TH] \r [w_sg1TQ w1_sg1TR w2_sg1TS]
                  Data.Functor.Sum.$w$cgmapM
                      $dData_sg1TG $dData1_sg1TH w_sg1TQ w1_sg1TR w2_sg1TS; } in
        let {
          sat_sg1TP [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> u
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgmapQi
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TO [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ -> [u]
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgmapQ
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TN [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> r
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgmapQr
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TM [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> r
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum3
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TL [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum4
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TK [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgunfold
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TJ [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> c (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgfoldl
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TI [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF] \u []
                  Data.Functor.Sum.$w$cp1Data
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF;
        } in 
          Data.Data.C:Data [sat_sg1TI
                            sat_sg1TJ
                            sat_sg1TK
                            lvl4_rfXPs
                            lvl5_rfXPt
                            lvl6_rfXPu
                            lvl7_rfXPv
                            sat_sg1TL
                            sat_sg1TM
                            sat_sg1TN
                            sat_sg1TO
                            sat_sg1TP
                            sat_sg1TT
                            sat_sg1TX
                            sat_sg1U1];

Data.Functor.Sum.InL
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     f a -> Data.Functor.Sum.Sum f g a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Sum.InL [eta_B1];

Data.Functor.Sum.InR
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     g a -> Data.Functor.Sum.Sum f g a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Sum.InR [eta_B1];


==================== STG syntax: ====================
2018-03-16 16:11:52.481985891 UTC

Data.Functor.Sum.$fEq1Sum_$cliftEq
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sg1EO $dEq2_sg1EP eq_sg1EQ ds_sg1ER ds1_sg1ES]
        case ds_sg1ER of {
          Data.Functor.Sum.InL x1_sg1EU [Occ=Once] ->
              case ds1_sg1ES of {
                Data.Functor.Sum.InL x2_sg1EW [Occ=Once] ->
                    $dEq1_sg1EO eq_sg1EQ x1_sg1EU x2_sg1EW;
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds2_sg1EY [Occ=Once] ->
              case ds1_sg1ES of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sg1F1 [Occ=Once] ->
                    $dEq2_sg1EP eq_sg1EQ ds2_sg1EY y2_sg1F1;
              };
        };

Data.Functor.Sum.$fEq1Sum [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Sum.$fEq1Sum_$cliftEq
            eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Sum.$fOrd1Sum_$cliftCompare
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g b
     -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1F2 $dOrd2_sg1F3 comp_sg1F4 ds_sg1F5 ds1_sg1F6]
        case ds_sg1F5 of {
          Data.Functor.Sum.InL x1_sg1F8 [Occ=Once] ->
              case ds1_sg1F6 of {
                Data.Functor.Sum.InL x2_sg1Fa [Occ=Once] ->
                    Data.Functor.Classes.liftCompare
                        $dOrd1_sg1F2 comp_sg1F4 x1_sg1F8 x2_sg1Fa;
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Functor.Sum.InR ds2_sg1Fc [Occ=Once] ->
              case ds1_sg1F6 of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Functor.Sum.InR y2_sg1Ff [Occ=Once] ->
                    Data.Functor.Classes.liftCompare
                        $dOrd2_sg1F3 comp_sg1F4 ds2_sg1Fc y2_sg1Ff;
              };
        };

Data.Functor.Sum.$fOrd1Sum1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1Fg $dOrd2_sg1Fh eta_sg1Fi eta1_sg1Fj eta2_sg1Fk]
        case eta1_sg1Fj of {
          Data.Functor.Sum.InL x1_sg1Fm [Occ=Once] ->
              case eta2_sg1Fk of {
                Data.Functor.Sum.InL x2_sg1Fo [Occ=Once] ->
                    Data.Functor.Classes.$p1Ord1
                        $dOrd1_sg1Fg eta_sg1Fi x1_sg1Fm x2_sg1Fo;
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds_sg1Fq [Occ=Once] ->
              case eta2_sg1Fk of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sg1Ft [Occ=Once] ->
                    Data.Functor.Classes.$p1Ord1
                        $dOrd2_sg1Fh eta_sg1Fi ds_sg1Fq y2_sg1Ft;
              };
        };

Data.Functor.Sum.$fOrd1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     Data.Functor.Classes.Ord1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(C1(C1(U))),C(C1(C1(U))))>m] =
    [] \r [$dOrd1_sg1Fu $dOrd2_sg1Fv]
        let {
          sat_sg1Fx [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Sum.Sum f_XfX7u g_XfX7w a
               -> Data.Functor.Sum.Sum f_XfX7u g_XfX7w b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sg1Fu $dOrd2_sg1Fv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrd1Sum_$cliftCompare
                      $dOrd1_sg1Fu $dOrd2_sg1Fv eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1Fw [Occ=Once]
            :: Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f_XfX7u g_XfX7w)
          [LclId] =
              [$dOrd1_sg1Fu $dOrd2_sg1Fv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrd1Sum1
                      $dOrd1_sg1Fu $dOrd2_sg1Fv eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sg1Fw sat_sg1Fx];

Data.Functor.Sum.$fRead1Sum8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "InL"#;

Data.Functor.Sum.$fRead1Sum7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Functor.Sum.$fRead1Sum8;

Data.Functor.Sum.$fRead1Sum4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "InR"#;

Data.Functor.Sum.$fRead1Sum3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Functor.Sum.$fRead1Sum4;

Data.Functor.Sum.$fRead1Sum2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Sum.$fRead1Sum3];

Data.Functor.Sum.$fRead1Sum5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Sum.$fRead1Sum6 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Sum.$fRead1Sum7];

Data.Functor.Sum.$fRead1Sum1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Sum.Sum f g a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Fy $dRead2_sg1Fz rp_sg1FA rl_sg1FB]
        let {
          ds_sg1FC [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_afX4G a_afX54)
          [LclId] =
              [$dRead1_sg1Fy rp_sg1FA rl_sg1FB] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead1_sg1Fy rp_sg1FA rl_sg1FB; } in
        let {
          ds1_sg1FD [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (g_afX4H a_afX54)
          [LclId] =
              [$dRead2_sg1Fz rp_sg1FA rl_sg1FB] \u []
                  Data.Functor.Classes.liftReadPrec
                      $dRead2_sg1Fz rp_sg1FA rl_sg1FB; } in
        let {
          $wlvl_sg1FE [InlPrag=NOUSERINLINE[0], Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: GHC.Prim.Int#
               -> forall b.
                  (Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [ds_sg1FC ds1_sg1FD] \r [ww_sg1FF w_sg1FG]
                  case <=# [ww_sg1FF 10#] of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                    1# ->
                        let {
                          sat_sg1FM [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_sfXzb
                          [LclId] =
                              [ds_sg1FC w_sg1FG] \r [a1_sg1FI]
                                  let {
                                    sat_sg1FL [Occ=Once]
                                      :: f_afX4G a_afX54 -> Text.ParserCombinators.ReadP.P b_sfXzb
                                    [LclId] =
                                        [w_sg1FG] \r [a2_sg1FJ]
                                            let {
                                              sat_sg1FK [Occ=Once]
                                                :: Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                                              [LclId] =
                                                  CCCS Data.Functor.Sum.InL! [a2_sg1FJ];
                                            } in  w_sg1FG sat_sg1FK;
                                  } in  ds_sg1FC Data.Functor.Sum.$fRead1Sum5 sat_sg1FL;
                        } in 
                          case
                              Text.Read.Lex.$wexpect Data.Functor.Sum.$fRead1Sum6 sat_sg1FM
                          of
                          { Unit# ww2_sg1FO [Occ=Once] ->
                                let {
                                  sat_sg1FX [Occ=Once] :: Text.ParserCombinators.ReadP.P b_sfXzb
                                  [LclId] =
                                      [ds1_sg1FD w_sg1FG] \u []
                                          let {
                                            sat_sg1FU [Occ=Once]
                                              :: () -> Text.ParserCombinators.ReadP.P b_sfXzb
                                            [LclId] =
                                                [ds1_sg1FD w_sg1FG] \r [a1_sg1FQ]
                                                    let {
                                                      sat_sg1FT [Occ=Once]
                                                        :: g_afX4H a_afX54
                                                           -> Text.ParserCombinators.ReadP.P b_sfXzb
                                                      [LclId] =
                                                          [w_sg1FG] \r [a2_sg1FR]
                                                              let {
                                                                sat_sg1FS [Occ=Once]
                                                                  :: Data.Functor.Sum.Sum
                                                                       f_afX4G g_afX4H a_afX54
                                                                [LclId] =
                                                                    CCCS Data.Functor.Sum.InR! [a2_sg1FR];
                                                              } in  w_sg1FG sat_sg1FS;
                                                    } in 
                                                      ds1_sg1FD
                                                          Data.Functor.Sum.$fRead1Sum5 sat_sg1FT;
                                          } in 
                                            case
                                                Text.Read.Lex.$wexpect
                                                    Data.Functor.Sum.$fRead1Sum2 sat_sg1FU
                                            of
                                            { Unit# ww4_sg1FW [Occ=Once] ->
                                                  Text.ParserCombinators.ReadP.Look [ww4_sg1FW];
                                            }; } in
                                let {
                                  sat_sg1FP [Occ=Once] :: Text.ParserCombinators.ReadP.P b_sfXzb
                                  [LclId] =
                                      CCCS Text.ParserCombinators.ReadP.Look! [ww2_sg1FO];
                                } in 
                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                      sat_sg1FP sat_sg1FX;
                          };
                  }; } in
        let {
          lvl8_sg1FY [InlPrag=NOUSERINLINE[0], Occ=OnceL, Dmd=<L,C(C(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
              [$wlvl_sg1FE] \r [w_sg1FZ w1_sg1G0]
                  case w_sg1FZ of {
                    GHC.Types.I# ww1_sg1G2 [Occ=Once] ->
                        $wlvl_sg1FE ww1_sg1G2 w1_sg1G0;
                  }; } in
        let {
          sat_sg1G5 [Occ=OnceT[0]]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_afX4G g_afX4H a_afX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [lvl8_sg1FY] \r [eta_sg1G3 eta1_sg1G4]
                  GHC.Read.list3 lvl8_sg1FY eta_sg1G3 eta1_sg1G4;
        } in  sat_sg1G5;

Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1G6 $dRead2_sg1G7 rp_sg1G8 rl_sg1G9]
        let {
          ds_sg1Ga [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_XfX6H g_XfX6J a_afX4N
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead1_sg1G6 $dRead2_sg1G7 rp_sg1G8 rl_sg1G9] \u []
                  let {
                    sat_sg1Gg [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_afX4N]
                    [LclId] =
                        [rl_sg1G9] \r [n_sg1Gc w1_sg1Gd]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sg1G9 w1_sg1Gd
                            of
                            { Unit# ww1_sg1Gf [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sg1Gf];
                            }; } in
                  let {
                    sat_sg1Gb [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_afX4N
                    [LclId] =
                        [rp_sg1G8] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sg1G8 eta_B1;
                  } in 
                    Data.Functor.Sum.$fRead1Sum1
                        $dRead1_sg1G6 $dRead2_sg1G7 sat_sg1Gb sat_sg1Gg; } in
        let {
          sat_sg1Gj [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX6H g_XfX6J a_afX4N)
          [LclId] =
              [ds_sg1Ga] \r [n_sg1Gh]
                  let {
                    sat_sg1Gi [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Sum.Sum f_XfX6H g_XfX6J a_afX4N)
                    [LclId] =
                        [ds_sg1Ga n_sg1Gh] \u []
                            ds_sg1Ga
                                n_sg1Gh Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sg1Gi;
        } in  sat_sg1Gj;

Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Gk $dRead2_sg1Gl rp_sg1Gm rl_sg1Gn]
        let {
          sat_sg1Go [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Sum.Sum f_XfX6F g_XfX6H a_afX5y)
          [LclId] =
              [$dRead1_sg1Gk $dRead2_sg1Gl rp_sg1Gm rl_sg1Gn] \s []
                  Data.Functor.Sum.$fRead1Sum1
                      $dRead1_sg1Gk $dRead2_sg1Gl rp_sg1Gm rl_sg1Gn;
        } in  GHC.Read.list sat_sg1Go;

Data.Functor.Sum.$fRead1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     Data.Functor.Classes.Read1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>m] =
    [] \r [$dRead1_sg1Gp $dRead2_sg1Gq]
        let {
          sat_sg1Gu [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Sum.Sum f_XfX6E g_XfX6G a]
          [LclId] =
              [$dRead1_sg1Gp $dRead2_sg1Gq] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fRead1Sum_$cliftReadListPrec
                      $dRead1_sg1Gp $dRead2_sg1Gq eta_B2 eta_B1; } in
        let {
          sat_sg1Gt [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Sum.Sum f_XfX6E g_XfX6G a)
          [LclId] =
              [$dRead1_sg1Gp $dRead2_sg1Gq] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fRead1Sum1
                      $dRead1_sg1Gp $dRead2_sg1Gq eta_B2 eta_B1; } in
        let {
          sat_sg1Gs [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Sum.Sum f_XfX6E g_XfX6G a]
          [LclId] =
              [$dRead1_sg1Gp $dRead2_sg1Gq] \u []
                  Data.Functor.Sum.$fRead1Sum_$cliftReadList
                      $dRead1_sg1Gp $dRead2_sg1Gq; } in
        let {
          sat_sg1Gr [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX6E g_XfX6G a)
          [LclId] =
              [$dRead1_sg1Gp $dRead2_sg1Gq] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fRead1Sum_$cliftReadsPrec
                      $dRead1_sg1Gp $dRead2_sg1Gq eta_B2 eta_B1;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sg1Gr
                                        sat_sg1Gs
                                        sat_sg1Gt
                                        sat_sg1Gu];
Data.Functor.Sum.$fRead1Sum_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Gv $dRead2_sg1Gw]
        let {
          sat_sg1Gx [Occ=Once]
            :: Data.Functor.Classes.Read1
                 (Data.Functor.Sum.Sum f_XfX6G g_XfX6I)
          [LclId] =
              [$dRead1_sg1Gv $dRead2_sg1Gw] \u []
                  Data.Functor.Sum.$fRead1Sum $dRead1_sg1Gv $dRead2_sg1Gw;
        } in  Data.Functor.Classes.liftReadListDefault sat_sg1Gx;

Data.Functor.Sum.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> Data.Functor.Sum.Sum f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1Gy w1_sg1Gz w2_sg1GA w3_sg1GB ww_sg1GC w4_sg1GD]
        case w4_sg1GD of {
          Data.Functor.Sum.InL x_sg1GF [Occ=Once] ->
              let {
                sat_sg1GG [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> f_sfXzA a_sfXzE -> GHC.Show.ShowS
                [LclId] =
                    [w_sg1Gy w2_sg1GA w3_sg1GB] \s []
                        Data.Functor.Classes.liftShowsPrec w_sg1Gy w2_sg1GA w3_sg1GB;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sg1GG Data.Functor.Sum.$fRead1Sum7 ww_sg1GC x_sg1GF;
          Data.Functor.Sum.InR y_sg1GH [Occ=Once] ->
              let {
                sat_sg1GI [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> g_sfXzB a_sfXzE -> GHC.Show.ShowS
                [LclId] =
                    [w1_sg1Gz w2_sg1GA w3_sg1GB] \s []
                        Data.Functor.Classes.liftShowsPrec w1_sg1Gz w2_sg1GA w3_sg1GB;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sg1GI Data.Functor.Sum.$fRead1Sum3 ww_sg1GC y_sg1GH;
        };

Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Sum.Sum f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1GJ w1_sg1GK w2_sg1GL w3_sg1GM w4_sg1GN w5_sg1GO]
        case w4_sg1GN of {
          GHC.Types.I# ww1_sg1GQ [Occ=Once] ->
              Data.Functor.Sum.$w$cliftShowsPrec
                  w_sg1GJ w1_sg1GK w2_sg1GL w3_sg1GM ww1_sg1GQ w5_sg1GO;
        };

Data.Functor.Sum.$fFoldableSum6 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Sum.$fShow1Sum_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Sum.Sum f g a]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U><L,U><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sg1GR
           $dShow2_sg1GS
           sp_sg1GT
           sl_sg1GU
           eta_sg1GV
           eta1_sg1GW]
        let {
          sat_sg1GY [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX4e g_afX4f a_afX4z -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg1GR $dShow2_sg1GS sp_sg1GT sl_sg1GU] \r [w_sg1GX]
                  Data.Functor.Sum.$w$cliftShowsPrec
                      $dShow1_sg1GR $dShow2_sg1GS sp_sg1GT sl_sg1GU 0# w_sg1GX;
        } in  GHC.Show.showList__ sat_sg1GY eta_sg1GV eta1_sg1GW;

Data.Functor.Sum.$fShow1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     Data.Functor.Classes.Show1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)>m] =
    [] \r [$dShow1_sg1GZ $dShow2_sg1H0]
        let {
          sat_sg1H2 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Sum.Sum f_afX4e g_afX4f a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg1GZ $dShow2_sg1H0] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fShow1Sum_$cliftShowList
                      $dShow1_sg1GZ $dShow2_sg1H0 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1H1 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Sum.Sum f_afX4e g_afX4f a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg1GZ $dShow2_sg1H0] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fShow1Sum_$cliftShowsPrec
                      $dShow1_sg1GZ $dShow2_sg1H0 eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sg1H1 sat_sg1H2];

Data.Functor.Sum.$fEqSum_$c==
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sg1H3 $dEq2_sg1H4 $dEq_sg1H5 eta_sg1H6 eta1_sg1H7]
        let {
          sat_sg1H8 [Occ=Once] :: a_afX3V -> a_afX3V -> GHC.Types.Bool
          [LclId] =
              [$dEq_sg1H5] \u [] GHC.Classes.== $dEq_sg1H5;
        } in 
          Data.Functor.Sum.$fEq1Sum_$cliftEq
              $dEq1_sg1H3 $dEq2_sg1H4 sat_sg1H8 eta_sg1H6 eta1_sg1H7;

Data.Functor.Sum.$fEqSum_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sg1H9 $dEq2_sg1Ha $dEq_sg1Hb eta_sg1Hc eta1_sg1Hd]
        case eta_sg1Hc of {
          Data.Functor.Sum.InL x1_sg1Hf [Occ=Once] ->
              case eta1_sg1Hd of {
                Data.Functor.Sum.InL x2_sg1Hh [Occ=Once] ->
                    let {
                      sat_sg1Hi [Occ=Once] :: a_afX3V -> a_afX3V -> GHC.Types.Bool
                      [LclId] =
                          [$dEq_sg1Hb] \u [] GHC.Classes.== $dEq_sg1Hb;
                    } in 
                      case $dEq1_sg1H9 sat_sg1Hi x1_sg1Hf x2_sg1Hh of {
                        GHC.Types.False -> GHC.Types.True [];
                        GHC.Types.True -> GHC.Types.False [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Functor.Sum.InR ds_sg1Hl [Occ=Once] ->
              case eta1_sg1Hd of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.True [];
                Data.Functor.Sum.InR y2_sg1Ho [Occ=Once] ->
                    let {
                      sat_sg1Hp [Occ=Once] :: a_afX3V -> a_afX3V -> GHC.Types.Bool
                      [LclId] =
                          [$dEq_sg1Hb] \u [] GHC.Classes.== $dEq_sg1Hb;
                    } in 
                      case $dEq2_sg1Ha sat_sg1Hp ds_sg1Hl y2_sg1Ho of {
                        GHC.Types.False -> GHC.Types.True [];
                        GHC.Types.True -> GHC.Types.False [];
                      };
              };
        };

Data.Functor.Sum.$fEqSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     GHC.Classes.Eq (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><L,U(U,A)>m] =
    [] \r [$dEq1_sg1Hr $dEq2_sg1Hs $dEq_sg1Ht]
        let {
          sat_sg1Hv [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V
               -> Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sg1Hr $dEq2_sg1Hs $dEq_sg1Ht] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fEqSum_$c/=
                      $dEq1_sg1Hr $dEq2_sg1Hs $dEq_sg1Ht eta_B2 eta_B1; } in
        let {
          sat_sg1Hu [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V
               -> Data.Functor.Sum.Sum f_afX3T g_afX3U a_afX3V -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sg1Hr $dEq2_sg1Hs $dEq_sg1Ht] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fEqSum_$c==
                      $dEq1_sg1Hr $dEq2_sg1Hs $dEq_sg1Ht eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sg1Hu sat_sg1Hv];

Data.Functor.Sum.$fOrdSum_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1Hw $dOrd2_sg1Hx $dOrd_sg1Hy eta_sg1Hz eta1_sg1HA]
        let {
          sat_sg1HB [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sg1Hy] \u [] GHC.Classes.compare $dOrd_sg1Hy;
        } in 
          Data.Functor.Sum.$fOrd1Sum_$cliftCompare
              $dOrd1_sg1Hw $dOrd2_sg1Hx sat_sg1HB eta_sg1Hz eta1_sg1HA;

Data.Functor.Sum.$fOrdSum_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Eq (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1HC $dOrd2_sg1HD $dOrd_sg1HE]
        let {
          sat_sg1HH [Occ=Once, Dmd=<L,U(U,A)>] :: GHC.Classes.Eq a_afX37
          [LclId] =
              [$dOrd_sg1HE] \u [] GHC.Classes.$p1Ord $dOrd_sg1HE; } in
        let {
          sat_sg1HG [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 g_afX36
          [LclId] =
              [$dOrd2_sg1HD] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sg1HD; } in
        let {
          sat_sg1HF [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 f_afX35
          [LclId] =
              [$dOrd1_sg1HC] \u [] Data.Functor.Classes.$p1Ord1 $dOrd1_sg1HC;
        } in  Data.Functor.Sum.$fEqSum sat_sg1HF sat_sg1HG sat_sg1HH;

Data.Functor.Sum.$fOrdSum_$c<
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1HI $dOrd2_sg1HJ $dOrd_sg1HK x_sg1HL y_sg1HM]
        case x_sg1HL of {
          Data.Functor.Sum.InL x1_sg1HO [Occ=Once] ->
              case y_sg1HM of {
                Data.Functor.Sum.InL x2_sg1HQ [Occ=Once] ->
                    let {
                      sat_sg1HR [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1HK] \u [] GHC.Classes.compare $dOrd_sg1HK;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg1HI sat_sg1HR x1_sg1HO x2_sg1HQ
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.LT -> GHC.Types.True [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Functor.Sum.InR ds_sg1HU [Occ=Once] ->
              case y_sg1HM of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sg1HX [Occ=Once] ->
                    let {
                      sat_sg1HY [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1HK] \u [] GHC.Classes.compare $dOrd_sg1HK;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sg1HJ sat_sg1HY ds_sg1HU y2_sg1HX
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.LT -> GHC.Types.True [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$c>=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1I0 $dOrd2_sg1I1 $dOrd_sg1I2 x_sg1I3 y_sg1I4]
        case x_sg1I3 of {
          Data.Functor.Sum.InL x1_sg1I6 [Occ=Once] ->
              case y_sg1I4 of {
                Data.Functor.Sum.InL x2_sg1I8 [Occ=Once] ->
                    let {
                      sat_sg1I9 [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1I2] \u [] GHC.Classes.compare $dOrd_sg1I2;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg1I0 sat_sg1I9 x1_sg1I6 x2_sg1I8
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.LT -> GHC.Types.False [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds_sg1Ic [Occ=Once] ->
              case y_sg1I4 of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.True [];
                Data.Functor.Sum.InR y2_sg1If [Occ=Once] ->
                    let {
                      sat_sg1Ig [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1I2] \u [] GHC.Classes.compare $dOrd_sg1I2;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sg1I1 sat_sg1Ig ds_sg1Ic y2_sg1If
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.LT -> GHC.Types.False [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$c>
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1Ii $dOrd2_sg1Ij $dOrd_sg1Ik x_sg1Il y_sg1Im]
        case x_sg1Il of {
          Data.Functor.Sum.InL x1_sg1Io [Occ=Once] ->
              case y_sg1Im of {
                Data.Functor.Sum.InL x2_sg1Iq [Occ=Once] ->
                    let {
                      sat_sg1Ir [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1Ik] \u [] GHC.Classes.compare $dOrd_sg1Ik;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg1Ii sat_sg1Ir x1_sg1Io x2_sg1Iq
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.GT -> GHC.Types.True [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Functor.Sum.InR ds_sg1Iu [Occ=Once] ->
              case y_sg1Im of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.True [];
                Data.Functor.Sum.InR y2_sg1Ix [Occ=Once] ->
                    let {
                      sat_sg1Iy [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1Ik] \u [] GHC.Classes.compare $dOrd_sg1Ik;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sg1Ij sat_sg1Iy ds_sg1Iu y2_sg1Ix
                      of
                      { __DEFAULT -> GHC.Types.False [];
                        GHC.Types.GT -> GHC.Types.True [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$c<=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1IA $dOrd2_sg1IB $dOrd_sg1IC x_sg1ID y_sg1IE]
        case x_sg1ID of {
          Data.Functor.Sum.InL x1_sg1IG [Occ=Once] ->
              case y_sg1IE of {
                Data.Functor.Sum.InL x2_sg1II [Occ=Once] ->
                    let {
                      sat_sg1IJ [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1IC] \u [] GHC.Classes.compare $dOrd_sg1IC;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd1_sg1IA sat_sg1IJ x1_sg1IG x2_sg1II
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.GT -> GHC.Types.False [];
                      };
                Data.Functor.Sum.InR _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Functor.Sum.InR ds_sg1IM [Occ=Once] ->
              case y_sg1IE of {
                Data.Functor.Sum.InL _ [Occ=Dead] -> GHC.Types.False [];
                Data.Functor.Sum.InR y2_sg1IP [Occ=Once] ->
                    let {
                      sat_sg1IQ [Occ=Once] :: a_afX37 -> a_afX37 -> GHC.Types.Ordering
                      [LclId] =
                          [$dOrd_sg1IC] \u [] GHC.Classes.compare $dOrd_sg1IC;
                    } in 
                      case
                          Data.Functor.Classes.liftCompare
                              $dOrd2_sg1IB sat_sg1IQ ds_sg1IM y2_sg1IP
                      of
                      { __DEFAULT -> GHC.Types.True [];
                        GHC.Types.GT -> GHC.Types.False [];
                      };
              };
        };

Data.Functor.Sum.$fOrdSum_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1IS $dOrd2_sg1IT $dOrd_sg1IU x_sg1IV y_sg1IW]
        case
            Data.Functor.Sum.$fOrdSum_$c<=
                $dOrd1_sg1IS $dOrd2_sg1IT $dOrd_sg1IU x_sg1IV y_sg1IW
        of
        { GHC.Types.False -> x_sg1IV;
          GHC.Types.True -> y_sg1IW;
        };

Data.Functor.Sum.$fOrdSum_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Sum.Sum f g a
     -> Data.Functor.Sum.Sum f g a -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sg1IY $dOrd2_sg1IZ $dOrd_sg1J0 x_sg1J1 y_sg1J2]
        case
            Data.Functor.Sum.$fOrdSum_$c<=
                $dOrd1_sg1IY $dOrd2_sg1IZ $dOrd_sg1J0 x_sg1J1 y_sg1J2
        of
        { GHC.Types.False -> y_sg1J2;
          GHC.Types.True -> x_sg1J1;
        };

Data.Functor.Sum.$fOrdSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Ord (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m] =
    [] \r [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6]
        let {
          sat_sg1Je [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$cmin
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1Jd [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$cmax
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1Jc [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c>=
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1Jb [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c>
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1Ja [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c<=
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1J9 [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37 -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$c<
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1J8 [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fOrdSum_$ccompare
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6 eta_B2 eta_B1; } in
        let {
          sat_sg1J7 [Occ=Once]
            :: GHC.Classes.Eq (Data.Functor.Sum.Sum f_afX35 g_afX36 a_afX37)
          [LclId] =
              [$dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6] \u []
                  Data.Functor.Sum.$fOrdSum_$cp1Ord
                      $dOrd1_sg1J4 $dOrd2_sg1J5 $dOrd_sg1J6;
        } in 
          GHC.Classes.C:Ord [sat_sg1J7
                             sat_sg1J8
                             sat_sg1J9
                             sat_sg1Ja
                             sat_sg1Jb
                             sat_sg1Jc
                             sat_sg1Jd
                             sat_sg1Je];

Data.Functor.Sum.$fReadSum1
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Sum.Sum f g a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Jf $dRead2_sg1Jg $dRead_sg1Jh]
        let {
          sat_sg1Jj [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_afX2A]
          [LclId] =
              [$dRead_sg1Jh] \u [] GHC.Read.readListPrec $dRead_sg1Jh; } in
        let {
          sat_sg1Ji [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_afX2A
          [LclId] =
              [$dRead_sg1Jh] \u [] GHC.Read.readPrec $dRead_sg1Jh;
        } in 
          Data.Functor.Sum.$fRead1Sum1
              $dRead1_sg1Jf $dRead2_sg1Jg sat_sg1Ji sat_sg1Jj;

Data.Functor.Sum.$fReadSum_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Jk $dRead2_sg1Jl $dRead_sg1Jm]
        let {
          ds_sg1Jn [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Sum.Sum f_XfX50 g_XfX52 a_XfX54
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead1_sg1Jk $dRead2_sg1Jl $dRead_sg1Jm] \u []
                  let {
                    sat_sg1Jp [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_XfX54]
                    [LclId] =
                        [$dRead_sg1Jm] \u [] GHC.Read.readListPrec $dRead_sg1Jm; } in
                  let {
                    sat_sg1Jo [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_XfX54
                    [LclId] =
                        [$dRead_sg1Jm] \u [] GHC.Read.readPrec $dRead_sg1Jm;
                  } in 
                    Data.Functor.Sum.$fRead1Sum1
                        $dRead1_sg1Jk $dRead2_sg1Jl sat_sg1Jo sat_sg1Jp; } in
        let {
          sat_sg1Js [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX50 g_XfX52 a_XfX54)
          [LclId] =
              [ds_sg1Jn] \r [n_sg1Jq]
                  let {
                    sat_sg1Jr [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Sum.Sum f_XfX50 g_XfX52 a_XfX54)
                    [LclId] =
                        [ds_sg1Jn n_sg1Jq] \u []
                            ds_sg1Jn
                                n_sg1Jq Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sg1Jr;
        } in  sat_sg1Js;

Data.Functor.Sum.$fReadSum_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Jt $dRead2_sg1Ju $dRead_sg1Jv]
        let {
          sat_sg1Jy [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Sum.Sum f_XfX4Y g_XfX50 a_XfX52)
          [LclId] =
              [$dRead1_sg1Jt $dRead2_sg1Ju $dRead_sg1Jv] \s []
                  let {
                    sat_sg1Jx [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_XfX52]
                    [LclId] =
                        [$dRead_sg1Jv] \u [] GHC.Read.readListPrec $dRead_sg1Jv; } in
                  let {
                    sat_sg1Jw [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_XfX52
                    [LclId] =
                        [$dRead_sg1Jv] \u [] GHC.Read.readPrec $dRead_sg1Jv;
                  } in 
                    Data.Functor.Sum.$fRead1Sum1
                        $dRead1_sg1Jt $dRead2_sg1Ju sat_sg1Jw sat_sg1Jx;
        } in  GHC.Read.list sat_sg1Jy;

Data.Functor.Sum.$fReadSum_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadP.ReadS [Data.Functor.Sum.Sum f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sg1Jz $dRead2_sg1JA $dRead_sg1JB]
        let {
          sat_sg1JC [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Sum.Sum f_XfX4Z g_XfX51 a_XfX53]
          [LclId] =
              [$dRead1_sg1Jz $dRead2_sg1JA $dRead_sg1JB] \u []
                  Data.Functor.Sum.$fReadSum_$creadListPrec
                      $dRead1_sg1Jz
                      $dRead2_sg1JA
                      $dRead_sg1JB
                      GHC.Read.$fRead()7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sg1JC;

Data.Functor.Sum.$fReadSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Read.Read (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,U,U)>m] =
    [] \r [$dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF]
        let {
          sat_sg1JJ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51]
          [LclId] =
              [$dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF] \u []
                  Data.Functor.Sum.$fReadSum_$creadListPrec
                      $dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF; } in
        let {
          sat_sg1JI [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51)
          [LclId] =
              [$dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF] \u []
                  Data.Functor.Sum.$fReadSum1
                      $dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF; } in
        let {
          sat_sg1JH [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51]
          [LclId] =
              [$dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF] \u []
                  Data.Functor.Sum.$fReadSum_$creadList
                      $dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF; } in
        let {
          sat_sg1JG [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Sum.Sum f_XfX4X g_XfX4Z a_XfX51)
          [LclId] =
              [$dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF] \u []
                  Data.Functor.Sum.$fReadSum_$creadsPrec
                      $dRead1_sg1JD $dRead2_sg1JE $dRead_sg1JF;
        } in  GHC.Read.C:Read [sat_sg1JG sat_sg1JH sat_sg1JI sat_sg1JJ];

Data.Functor.Sum.$fShowSum_$cshowsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Types.Int -> Data.Functor.Sum.Sum f g a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sg1JK
           $dShow2_sg1JL
           $dShow_sg1JM
           eta_sg1JN
           eta1_sg1JO]
        case eta_sg1JN of {
          GHC.Types.I# ww1_sg1JQ [Occ=Once] ->
              let {
                sat_sg1JS [Occ=Once] :: [a_afX2a] -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sg1JM] \u [] GHC.Show.showList $dShow_sg1JM; } in
              let {
                sat_sg1JR [Occ=Once] :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sg1JM] \u [] GHC.Show.showsPrec $dShow_sg1JM;
              } in 
                Data.Functor.Sum.$w$cliftShowsPrec
                    $dShow1_sg1JK
                    $dShow2_sg1JL
                    sat_sg1JR
                    sat_sg1JS
                    ww1_sg1JQ
                    eta1_sg1JO;
        };

Data.Functor.Sum.$fShowSum_$cshow
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     Data.Functor.Sum.Sum f g a -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*U,A,1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sg1JT $dShow2_sg1JU $dShow_sg1JV x_sg1JW]
        case x_sg1JW of {
          Data.Functor.Sum.InL x1_sg1JY [Occ=Once] ->
              let {
                sat_sg1K1 [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow1_sg1JT $dShow_sg1JV x1_sg1JY] \u []
                        let {
                          sat_sg1K0 [Occ=Once] :: [a_afX2a] -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sg1JV] \u [] GHC.Show.showList $dShow_sg1JV; } in
                        let {
                          sat_sg1JZ [Occ=Once] :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sg1JV] \u [] GHC.Show.showsPrec $dShow_sg1JV;
                        } in 
                          Data.Functor.Classes.liftShowsPrec
                              $dShow1_sg1JT
                              sat_sg1JZ
                              sat_sg1K0
                              Data.Functor.Classes.$fRead1Const1
                              x1_sg1JY
                              GHC.Types.[]; } in
              let {
                sat_sg1K2 [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sg1K1];
              } in  GHC.Base.++ Data.Functor.Sum.$fRead1Sum7 sat_sg1K2;
          Data.Functor.Sum.InR y_sg1K3 [Occ=Once] ->
              let {
                sat_sg1K6 [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow2_sg1JU $dShow_sg1JV y_sg1K3] \u []
                        let {
                          sat_sg1K5 [Occ=Once] :: [a_afX2a] -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sg1JV] \u [] GHC.Show.showList $dShow_sg1JV; } in
                        let {
                          sat_sg1K4 [Occ=Once] :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
                          [LclId] =
                              [$dShow_sg1JV] \u [] GHC.Show.showsPrec $dShow_sg1JV;
                        } in 
                          Data.Functor.Classes.liftShowsPrec
                              $dShow2_sg1JU
                              sat_sg1K4
                              sat_sg1K5
                              Data.Functor.Classes.$fRead1Const1
                              y_sg1K3
                              GHC.Types.[]; } in
              let {
                sat_sg1K7 [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sg1K6];
              } in  GHC.Base.++ Data.Functor.Sum.$fRead1Sum3 sat_sg1K7;
        };

Data.Functor.Sum.$fShowSum_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     [Data.Functor.Sum.Sum f g a] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sg1K8 $dShow2_sg1K9 $dShow_sg1Ka ls_sg1Kb s_sg1Kc]
        let {
          lvl8_sg1Kd [Occ=OnceL]
            :: GHC.Types.Int -> a_afX2a -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sg1Ka] \u [] GHC.Show.showsPrec $dShow_sg1Ka; } in
        let {
          lvl9_sg1Ke [Occ=OnceL] :: [a_afX2a] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sg1Ka] \u [] GHC.Show.showList $dShow_sg1Ka; } in
        let {
          sat_sg1Kg [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg1K8 $dShow2_sg1K9 lvl8_sg1Kd lvl9_sg1Ke] \r [eta_sg1Kf]
                  Data.Functor.Sum.$w$cliftShowsPrec
                      $dShow1_sg1K8 $dShow2_sg1K9 lvl8_sg1Kd lvl9_sg1Ke 0# eta_sg1Kf;
        } in  GHC.Show.showList__ sat_sg1Kg ls_sg1Kb s_sg1Kc;

Data.Functor.Sum.$fShowSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Show.Show (Data.Functor.Sum.Sum f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(U,A,U)>m] =
    [] \r [$dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj]
        let {
          sat_sg1Km [Occ=Once]
            :: [Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a] -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fShowSum_$cshowList
                      $dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj eta_B2 eta_B1; } in
        let {
          sat_sg1Kl [Occ=Once]
            :: Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a -> GHC.Base.String
          [LclId] =
              [$dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj] \r [eta_B1]
                  Data.Functor.Sum.$fShowSum_$cshow
                      $dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj eta_B1; } in
        let {
          sat_sg1Kk [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Sum.Sum f_afX28 g_afX29 a_afX2a -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fShowSum_$cshowsPrec
                      $dShow1_sg1Kh $dShow2_sg1Ki $dShow_sg1Kj eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sg1Kk sat_sg1Kl sat_sg1Km];

Data.Functor.Sum.$fFunctorSum_$cfmap
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Sum.Sum f g a -> Data.Functor.Sum.Sum f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sg1Kn $dFunctor1_sg1Ko f1_sg1Kp ds_sg1Kq]
        case ds_sg1Kq of {
          Data.Functor.Sum.InL x_sg1Ks [Occ=Once] ->
              let {
                sat_sg1Kt [Occ=Once] :: f_afX1v b_afX1D
                [LclId] =
                    [$dFunctor_sg1Kn f1_sg1Kp x_sg1Ks] \u []
                        GHC.Base.fmap $dFunctor_sg1Kn f1_sg1Kp x_sg1Ks;
              } in  Data.Functor.Sum.InL [sat_sg1Kt];
          Data.Functor.Sum.InR y_sg1Ku [Occ=Once] ->
              let {
                sat_sg1Kv [Occ=Once] :: g_afX1w b_afX1D
                [LclId] =
                    [$dFunctor1_sg1Ko f1_sg1Kp y_sg1Ku] \u []
                        GHC.Base.fmap $dFunctor1_sg1Ko f1_sg1Kp y_sg1Ku;
              } in  Data.Functor.Sum.InR [sat_sg1Kv];
        };

Data.Functor.Sum.$fFunctorSum_$c<$
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     a -> Data.Functor.Sum.Sum f g b -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sg1Kw $dFunctor1_sg1Kx x_sg1Ky eta_sg1Kz]
        let {
          sat_sg1KB [Occ=Once] :: b_afX20 -> a_afX1Z
          [LclId] =
              [x_sg1Ky] \r [ds_sg1KA] x_sg1Ky;
        } in 
          Data.Functor.Sum.$fFunctorSum_$cfmap
              $dFunctor_sg1Kw $dFunctor1_sg1Kx sat_sg1KB eta_sg1Kz;

Data.Functor.Sum.$fFunctorSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     GHC.Base.Functor (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dFunctor_sg1KC $dFunctor1_sg1KD]
        let {
          sat_sg1KF [Occ=Once]
            :: forall a b.
               a
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w b
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w a
          [LclId] =
              [$dFunctor_sg1KC $dFunctor1_sg1KD] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFunctorSum_$c<$
                      $dFunctor_sg1KC $dFunctor1_sg1KD eta_B2 eta_B1; } in
        let {
          sat_sg1KE [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w a
               -> Data.Functor.Sum.Sum f_afX1v g_afX1w b
          [LclId] =
              [$dFunctor_sg1KC $dFunctor1_sg1KD] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFunctorSum_$cfmap
                      $dFunctor_sg1KC $dFunctor1_sg1KD eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sg1KE sat_sg1KF];

Data.Functor.Sum.$fFoldableSum_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Functor.Sum.Sum f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1KG
           $dFoldable1_sg1KH
           $dMonoid_sg1KI
           f1_sg1KJ
           ds_sg1KK]
        case ds_sg1KK of {
          Data.Functor.Sum.InL x_sg1KM [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_sg1KG $dMonoid_sg1KI f1_sg1KJ x_sg1KM;
          Data.Functor.Sum.InR y_sg1KN [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_sg1KH $dMonoid_sg1KI f1_sg1KJ y_sg1KN;
        };

Data.Functor.Sum.$fFoldableSum_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => Data.Functor.Sum.Sum f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1KO $dFoldable1_sg1KP $dMonoid_sg1KQ ds_sg1KR]
        case ds_sg1KR of {
          Data.Functor.Sum.InL x_sg1KT [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_sg1KO $dMonoid_sg1KQ GHC.Base.id x_sg1KT;
          Data.Functor.Sum.InR y_sg1KU [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_sg1KP $dMonoid_sg1KQ GHC.Base.id y_sg1KU;
        };

Data.Functor.Sum.$fFoldableSum2 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sg1KV] v_sg1KV;

Data.Functor.Sum.$fFoldableSum3
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     Data.Functor.Sum.Sum f g a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1KW $dFoldable1_sg1KX $dNum_sg1KY]
        let {
          $dMonoid_sg1KZ [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_afX1c)
          [LclId] =
              [$dNum_sg1KY] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sg1KY; } in
        let {
          sat_sg1L4 [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_XfX1N g_XfX1P a_afX1c
               -> Data.Semigroup.Internal.Sum a_afX1c
          [LclId] =
              [$dFoldable_sg1KW $dFoldable1_sg1KX $dMonoid_sg1KZ] \r [ds_sg1L0]
                  case ds_sg1L0 of {
                    Data.Functor.Sum.InL x_sg1L2 [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_sg1KW
                            $dMonoid_sg1KZ
                            Data.Functor.Sum.$fFoldableSum2
                            x_sg1L2;
                    Data.Functor.Sum.InR y_sg1L3 [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_sg1KX
                            $dMonoid_sg1KZ
                            Data.Functor.Sum.$fFoldableSum2
                            y_sg1L3;
                  };
        } in  sat_sg1L4;

lvl_rfXP1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Functor.Sum.$fFoldableSum4 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rfXP1 of sat_sg1L5 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg1L5;
        };

Data.Functor.Sum.$fFoldableSum_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1L6 $dFoldable1_sg1L7 $dOrd_sg1L8]
        let {
          g1_sg1L9 [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_afX12)
          [LclId] =
              [$dOrd_sg1L8] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_sg1L8; } in
        let {
          sat_sg1Li [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_XfX1M g_XfX1O a_afX12 -> a_afX12
          [LclId] =
              [$dFoldable_sg1L6 $dFoldable1_sg1L7 g1_sg1L9] \r [x_sg1La]
                  case x_sg1La of {
                    Data.Functor.Sum.InL x1_sg1Lc [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_sg1L6 g1_sg1L9 GHC.Base.Just x1_sg1Lc
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum4;
                          GHC.Base.Just v_sg1Le [Occ=Once] -> v_sg1Le;
                        };
                    Data.Functor.Sum.InR y_sg1Lf [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sg1L7 g1_sg1L9 GHC.Base.Just y_sg1Lf
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum4;
                          GHC.Base.Just v_sg1Lh [Occ=Once] -> v_sg1Lh;
                        };
                  };
        } in  sat_sg1Li;

lvl1_rfXP2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Functor.Sum.$fFoldableSum5 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rfXP2 of sat_sg1Lj {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg1Lj;
        };

Data.Functor.Sum.$fFoldableSum_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1Lk $dFoldable1_sg1Ll $dOrd_sg1Lm]
        let {
          g1_sg1Ln [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_afX0S)
          [LclId] =
              [$dOrd_sg1Lm] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_sg1Lm; } in
        let {
          sat_sg1Lw [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_XfX1L g_XfX1N a_afX0S -> a_afX0S
          [LclId] =
              [$dFoldable_sg1Lk $dFoldable1_sg1Ll g1_sg1Ln] \r [x_sg1Lo]
                  case x_sg1Lo of {
                    Data.Functor.Sum.InL x1_sg1Lq [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_sg1Lk g1_sg1Ln GHC.Base.Just x1_sg1Lq
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum5;
                          GHC.Base.Just v_sg1Ls [Occ=Once] -> v_sg1Ls;
                        };
                    Data.Functor.Sum.InR y_sg1Lt [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_sg1Ll g1_sg1Ln GHC.Base.Just y_sg1Lt
                        of
                        { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum5;
                          GHC.Base.Just v_sg1Lv [Occ=Once] -> v_sg1Lv;
                        };
                  };
        } in  sat_sg1Lw;

Data.Functor.Sum.$fFoldableSum_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1Lx $dFoldable1_sg1Ly $dEq_sg1Lz eta_sg1LA]
        let {
          f1_sg1LB [Occ=OnceL*] :: a_afX0I -> GHC.Types.Bool
          [LclId] =
              [$dEq_sg1Lz eta_sg1LA] \u []
                  GHC.Classes.== $dEq_sg1Lz eta_sg1LA; } in
        let {
          sat_sg1LG [Occ=Once]
            :: Data.Functor.Sum.Sum f_XfX1K g_XfX1M a_afX0I
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_sg1Lx $dFoldable1_sg1Ly f1_sg1LB] \r [ds_sg1LC]
                  case ds_sg1LC of {
                    Data.Functor.Sum.InL x_sg1LE [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_sg1Lx
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_sg1LB
                            x_sg1LE;
                    Data.Functor.Sum.InR y_sg1LF [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_sg1Ly
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_sg1LB
                            y_sg1LF;
                  };
        } in  sat_sg1LG;

Data.Functor.Sum.$fFoldableSum10
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Functor.Sum.$fFoldableSum_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1LH
           $dFoldable1_sg1LI
           f1_sg1LJ
           z_sg1LK
           t1_sg1LL]
        let {
          f2_sg1LM [Occ=Once*] :: a_afWZL -> b_afWZK -> b_afWZK
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [f1_sg1LJ] \r [x_sg1LN y_sg1LO] f1_sg1LJ y_sg1LO x_sg1LN;
        } in 
          case t1_sg1LL of {
            Data.Functor.Sum.InL x_sg1LQ [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable_sg1LH
                    Data.Functor.Sum.$fFoldableSum10
                    f2_sg1LM
                    x_sg1LQ
                    z_sg1LK;
            Data.Functor.Sum.InR y_sg1LR [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable1_sg1LI
                    Data.Functor.Sum.$fFoldableSum10
                    f2_sg1LM
                    y_sg1LR
                    z_sg1LK;
          };

lvl2_rfXP3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Functor.Sum.$fFoldableSum9 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rfXP3 of sat_sg1LS {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg1LS;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1LT $dFoldable1_sg1LU f1_sg1LV xs_sg1LW]
        case xs_sg1LW of {
          Data.Functor.Sum.InL x_sg1LY [Occ=Once] ->
              let {
                sat_sg1M4 [Occ=Once]
                  :: a_afX0c
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_afX0c))
                [LclId] =
                    [f1_sg1LV] \r [x1_sg1LZ y_sg1M0]
                        let {
                          sat_sg1M3 [Occ=Once] :: a_afX0c
                          [LclId] =
                              [f1_sg1LV x1_sg1LZ y_sg1M0] \u []
                                  case y_sg1M0 of {
                                    GHC.Base.Nothing -> x1_sg1LZ;
                                    GHC.Base.Just x2_sg1M2 [Occ=Once] -> f1_sg1LV x2_sg1M2 x1_sg1LZ;
                                  };
                        } in  GHC.Base.Just [sat_sg1M3];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable_sg1LT
                        Data.Functor.Sum.$fFoldableSum10
                        sat_sg1M4
                        x_sg1LY
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum9;
                  GHC.Base.Just v_sg1M6 [Occ=Once] -> v_sg1M6;
                };
          Data.Functor.Sum.InR y_sg1M7 [Occ=Once] ->
              let {
                sat_sg1Md [Occ=Once]
                  :: a_afX0c
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_afX0c))
                [LclId] =
                    [f1_sg1LV] \r [x_sg1M8 y1_sg1M9]
                        let {
                          sat_sg1Mc [Occ=Once] :: a_afX0c
                          [LclId] =
                              [f1_sg1LV x_sg1M8 y1_sg1M9] \u []
                                  case y1_sg1M9 of {
                                    GHC.Base.Nothing -> x_sg1M8;
                                    GHC.Base.Just x1_sg1Mb [Occ=Once] -> f1_sg1LV x1_sg1Mb x_sg1M8;
                                  };
                        } in  GHC.Base.Just [sat_sg1Mc];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable1_sg1LU
                        Data.Functor.Sum.$fFoldableSum10
                        sat_sg1Md
                        y_sg1M7
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum9;
                  GHC.Base.Just v_sg1Mf [Occ=Once] -> v_sg1Mf;
                };
        };

Data.Functor.Sum.$fFoldableSum_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1Mg
           $dFoldable1_sg1Mh
           f1_sg1Mi
           z0_sg1Mj
           xs_sg1Mk]
        case xs_sg1Mk of {
          Data.Functor.Sum.InL x_sg1Mm [Occ=Once] ->
              let {
                sat_sg1Mr [Occ=Once]
                  :: a_afWZA
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_afWZB -> b_afWZB))
                [LclId] =
                    [f1_sg1Mi] \r [x1_sg1Mn y_sg1Mo z_sg1Mp]
                        case f1_sg1Mi x1_sg1Mn z_sg1Mp of vx_sg1Mq {
                          __DEFAULT -> y_sg1Mo vx_sg1Mq;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable_sg1Mg
                    Data.Functor.Sum.$fFoldableSum10
                    sat_sg1Mr
                    x_sg1Mm
                    GHC.Base.id
                    z0_sg1Mj;
          Data.Functor.Sum.InR y_sg1Ms [Occ=Once] ->
              let {
                sat_sg1Mx [Occ=Once]
                  :: a_afWZA
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_afWZB -> b_afWZB))
                [LclId] =
                    [f1_sg1Mi] \r [x_sg1Mt y1_sg1Mu z_sg1Mv]
                        case f1_sg1Mi x_sg1Mt z_sg1Mv of vx_sg1Mw {
                          __DEFAULT -> y1_sg1Mu vx_sg1Mw;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable1_sg1Mh
                    Data.Functor.Sum.$fFoldableSum10
                    sat_sg1Mx
                    y_sg1Ms
                    GHC.Base.id
                    z0_sg1Mj;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1My
           $dFoldable1_sg1Mz
           f1_sg1MA
           z_sg1MB
           t1_sg1MC]
        case t1_sg1MC of {
          Data.Functor.Sum.InL x_sg1ME [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_sg1My
                  Data.Semigroup.Internal.$fMonoidEndo
                  f1_sg1MA
                  x_sg1ME
                  z_sg1MB;
          Data.Functor.Sum.InR y_sg1MF [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_sg1Mz
                  Data.Semigroup.Internal.$fMonoidEndo
                  f1_sg1MA
                  y_sg1MF
                  z_sg1MB;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> Data.Functor.Sum.Sum f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1MG
           $dFoldable1_sg1MH
           f1_sg1MI
           z0_sg1MJ
           xs_sg1MK]
        let {
          sat_sg1MP [Occ=Once]
            :: a_afWZV -> (b_afWZU -> b_afWZU) -> b_afWZU -> b_afWZU
          [LclId] =
              [f1_sg1MI] \r [x_sg1ML k_sg1MM z_sg1MN]
                  case f1_sg1MI z_sg1MN x_sg1ML of vx_sg1MO {
                    __DEFAULT -> k_sg1MM vx_sg1MO;
                  };
        } in 
          Data.Functor.Sum.$fFoldableSum_$cfoldr
              $dFoldable_sg1MG
              $dFoldable1_sg1MH
              sat_sg1MP
              GHC.Base.id
              xs_sg1MK
              z0_sg1MJ;

Data.Functor.Sum.$fFoldableSum7
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_sg1MQ k_sg1MR z_sg1MS]
        case z_sg1MS of {
          GHC.Types.I# x1_sg1MU [Occ=Once] ->
              case +# [x1_sg1MU 1#] of sat_sg1MV {
                __DEFAULT ->
                    let {
                      sat_sg1MW [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sg1MV];
                    } in  k_sg1MR sat_sg1MW;
              };
        };

Data.Functor.Sum.$fFoldableSum_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Sum.Sum f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1MX $dFoldable1_sg1MY eta_sg1MZ]
        Data.Functor.Sum.$fFoldableSum_$cfoldr
            $dFoldable_sg1MX
            $dFoldable1_sg1MY
            Data.Functor.Sum.$fFoldableSum7
            GHC.Base.id
            eta_sg1MZ
            Data.Functor.Sum.$fFoldableSum6;

lvl3_rfXP4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Functor.Sum.$fFoldableSum11 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_rfXP4 of sat_sg1N0 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sg1N0;
        };

Data.Functor.Sum.$fFoldableSum_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Sum.Sum f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1N1 $dFoldable1_sg1N2 f1_sg1N3 xs_sg1N4]
        let {
          sat_sg1Na [Occ=Once]
            :: a_afX04 -> GHC.Base.Maybe a_afX04 -> GHC.Base.Maybe a_afX04
          [LclId] =
              [f1_sg1N3] \r [x_sg1N5 m_sg1N6]
                  let {
                    sat_sg1N9 [Occ=Once] :: a_afX04
                    [LclId] =
                        [f1_sg1N3 x_sg1N5 m_sg1N6] \u []
                            case m_sg1N6 of {
                              GHC.Base.Nothing -> x_sg1N5;
                              GHC.Base.Just y_sg1N8 [Occ=Once] -> f1_sg1N3 x_sg1N5 y_sg1N8;
                            };
                  } in  GHC.Base.Just [sat_sg1N9];
        } in 
          case
              Data.Functor.Sum.$fFoldableSum_$cfoldr
                  $dFoldable_sg1N1
                  $dFoldable1_sg1N2
                  sat_sg1Na
                  GHC.Base.Nothing
                  xs_sg1N4
          of
          { GHC.Base.Nothing -> Data.Functor.Sum.$fFoldableSum11;
            GHC.Base.Just v_sg1Nc [Occ=Once] -> v_sg1Nc;
          };

Data.Functor.Sum.$fFoldableSum8
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sg1Nd ds1_sg1Ne] GHC.Types.False [];

Data.Functor.Sum.$fFoldableSum_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Sum.Sum f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1Nf $dFoldable1_sg1Ng eta_sg1Nh]
        Data.Functor.Sum.$fFoldableSum_$cfoldr
            $dFoldable_sg1Nf
            $dFoldable1_sg1Ng
            Data.Functor.Sum.$fFoldableSum8
            GHC.Types.True
            eta_sg1Nh;

Data.Functor.Sum.$fFoldableSum1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     Data.Functor.Sum.Sum f g a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1Ni $dFoldable1_sg1Nj $dNum_sg1Nk]
        let {
          $dMonoid_sg1Nl [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_afX1m)
          [LclId] =
              [$dNum_sg1Nk] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sg1Nk; } in
        let {
          sat_sg1Nq [Occ=OnceT[0]]
            :: Data.Functor.Sum.Sum f_afWYR g_afWYS a_afX1m
               -> Data.Semigroup.Internal.Product a_afX1m
          [LclId] =
              [$dFoldable_sg1Ni $dFoldable1_sg1Nj $dMonoid_sg1Nl] \r [ds_sg1Nm]
                  case ds_sg1Nm of {
                    Data.Functor.Sum.InL x_sg1No [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_sg1Ni
                            $dMonoid_sg1Nl
                            Data.Functor.Sum.$fFoldableSum2
                            x_sg1No;
                    Data.Functor.Sum.InR y_sg1Np [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_sg1Nj
                            $dMonoid_sg1Nl
                            Data.Functor.Sum.$fFoldableSum2
                            y_sg1Np;
                  };
        } in  sat_sg1Nq;

Data.Functor.Sum.$fFoldableSum_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Sum.Sum f g a -> [a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sg1Nr $dFoldable1_sg1Ns eta_sg1Nt]
        Data.Functor.Sum.$fFoldableSum_$cfoldr
            $dFoldable_sg1Nr
            $dFoldable1_sg1Ns
            GHC.Types.:
            GHC.Types.[]
            eta_sg1Nt;

Data.Functor.Sum.$fFoldableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_sg1Nu $dFoldable1_sg1Nv]
        let {
          sat_sg1NL [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum1
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1NK [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum3
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1NJ [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cminimum
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1NI [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cmaximum
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1NH [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$celem
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B2 eta_B1; } in
        let {
          sat_sg1NG [Occ=Once]
            :: forall a.
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$clength
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1NF [Occ=Once]
            :: forall a.
               Data.Functor.Sum.Sum f_afWYR g_afWYS a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cnull
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1NE [Occ=Once]
            :: forall a. Data.Functor.Sum.Sum f_afWYR g_afWYS a -> [a]
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$ctoList
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B1; } in
        let {
          sat_sg1ND [Occ=Once]
            :: forall a.
               (a -> a -> a) -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldl1
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B2 eta_B1; } in
        let {
          sat_sg1NC [Occ=Once]
            :: forall a.
               (a -> a -> a) -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> a
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldr1
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B2 eta_B1; } in
        let {
          sat_sg1NB [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldl'
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1NA [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldl
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1Nz [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldr'
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1Ny [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> b
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldr
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1Nx [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> Data.Functor.Sum.Sum f_afWYR g_afWYS a -> m
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfoldMap
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1Nw [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               Data.Functor.Sum.Sum f_afWYR g_afWYS m -> m
          [LclId] =
              [$dFoldable_sg1Nu $dFoldable1_sg1Nv] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fFoldableSum_$cfold
                      $dFoldable_sg1Nu $dFoldable1_sg1Nv eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_sg1Nw
                                    sat_sg1Nx
                                    sat_sg1Ny
                                    sat_sg1Nz
                                    sat_sg1NA
                                    sat_sg1NB
                                    sat_sg1NC
                                    sat_sg1ND
                                    sat_sg1NE
                                    sat_sg1NF
                                    sat_sg1NG
                                    sat_sg1NH
                                    sat_sg1NI
                                    sat_sg1NJ
                                    sat_sg1NK
                                    sat_sg1NL];

Data.Functor.Sum.$fTraversableSum_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> Data.Functor.Sum.Sum f g a -> f1 (Data.Functor.Sum.Sum f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg1NM
           $dTraversable1_sg1NN
           $dApplicative_sg1NO
           eta_sg1NP
           eta1_sg1NQ]
        case eta1_sg1NQ of {
          Data.Functor.Sum.InL x_sg1NS [Occ=Once] ->
              let {
                sat_sg1NU [Occ=Once] :: f1_afWXF (f_afWXq b_afWXH)
                [LclId] =
                    [$dTraversable_sg1NM $dApplicative_sg1NO eta_sg1NP x_sg1NS] \u []
                        Data.Traversable.traverse
                            $dTraversable_sg1NM $dApplicative_sg1NO eta_sg1NP x_sg1NS;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sg1NO of sat_sg1NT {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sg1NT Data.Functor.Sum.InL sat_sg1NU;
                };
          Data.Functor.Sum.InR y_sg1NV [Occ=Once] ->
              let {
                sat_sg1NX [Occ=Once] :: f1_afWXF (g_afWXr b_afWXH)
                [LclId] =
                    [$dTraversable1_sg1NN $dApplicative_sg1NO eta_sg1NP y_sg1NV] \u []
                        Data.Traversable.traverse
                            $dTraversable1_sg1NN $dApplicative_sg1NO eta_sg1NP y_sg1NV;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sg1NO of sat_sg1NW {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sg1NW Data.Functor.Sum.InR sat_sg1NX;
                };
        };

Data.Functor.Sum.$fTraversableSum_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (Data.Functor.Sum.Sum f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg1NY $dTraversable1_sg1NZ]
        let {
          sat_sg1O1 [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_afWXr
          [LclId] =
              [$dTraversable1_sg1NZ] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sg1NZ; } in
        let {
          sat_sg1O0 [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_afWXq
          [LclId] =
              [$dTraversable_sg1NY] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sg1NY;
        } in  Data.Functor.Sum.$fFoldableSum sat_sg1O0 sat_sg1O1;

Data.Functor.Sum.$fTraversableSum_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (Data.Functor.Sum.Sum f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg1O2 $dTraversable1_sg1O3]
        let {
          sat_sg1O5 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor g_afWXr
          [LclId] =
              [$dTraversable1_sg1O3] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sg1O3; } in
        let {
          sat_sg1O4 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_afWXq
          [LclId] =
              [$dTraversable_sg1O2] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sg1O2;
        } in  Data.Functor.Sum.$fFunctorSum sat_sg1O4 sat_sg1O5;

Data.Functor.Sum.$fTraversableSum_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     Data.Functor.Sum.Sum f g (f1 a) -> f1 (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg1O6
           $dTraversable1_sg1O7
           $dApplicative_sg1O8
           eta_B1]
        Data.Functor.Sum.$fTraversableSum_$ctraverse
            $dTraversable_sg1O6
            $dTraversable1_sg1O7
            $dApplicative_sg1O8
            GHC.Base.id
            eta_B1;

Data.Functor.Sum.$fTraversableSum_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg1O9
           $dTraversable1_sg1Oa
           $dMonad_sg1Ob
           eta_sg1Oc
           eta1_sg1Od]
        case GHC.Base.$p1Monad $dMonad_sg1Ob of sat_sg1Oe {
          __DEFAULT ->
              Data.Functor.Sum.$fTraversableSum_$ctraverse
                  $dTraversable_sg1O9
                  $dTraversable1_sg1Oa
                  sat_sg1Oe
                  eta_sg1Oc
                  eta1_sg1Od;
        };

Data.Functor.Sum.$fTraversableSum_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Sum.Sum f g (m a) -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sg1Of
           $dTraversable1_sg1Og
           $dMonad_sg1Oh
           eta_sg1Oi]
        case GHC.Base.$p1Monad $dMonad_sg1Oh of sat_sg1Oj {
          __DEFAULT ->
              Data.Functor.Sum.$fTraversableSum_$ctraverse
                  $dTraversable_sg1Of
                  $dTraversable1_sg1Og
                  sat_sg1Oj
                  GHC.Base.id
                  eta_sg1Oi;
        };

Data.Functor.Sum.$fTraversableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sg1Ok $dTraversable1_sg1Ol]
        let {
          sat_sg1Or [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               Data.Functor.Sum.Sum f_afWXq g_afWXr (m a)
               -> m (Data.Functor.Sum.Sum f_afWXq g_afWXr a)
          [LclId] =
              [$dTraversable_sg1Ok $dTraversable1_sg1Ol] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$csequence
                      $dTraversable_sg1Ok $dTraversable1_sg1Ol eta_B2 eta_B1; } in
        let {
          sat_sg1Oq [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> Data.Functor.Sum.Sum f_afWXq g_afWXr a
               -> m (Data.Functor.Sum.Sum f_afWXq g_afWXr b)
          [LclId] =
              [$dTraversable_sg1Ok $dTraversable1_sg1Ol] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$cmapM
                      $dTraversable_sg1Ok $dTraversable1_sg1Ol eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1Op [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               Data.Functor.Sum.Sum f_afWXq g_afWXr (f a)
               -> f (Data.Functor.Sum.Sum f_afWXq g_afWXr a)
          [LclId] =
              [$dTraversable_sg1Ok $dTraversable1_sg1Ol] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$csequenceA
                      $dTraversable_sg1Ok $dTraversable1_sg1Ol eta_B2 eta_B1; } in
        let {
          sat_sg1Oo [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> Data.Functor.Sum.Sum f_afWXq g_afWXr a
               -> f (Data.Functor.Sum.Sum f_afWXq g_afWXr b)
          [LclId] =
              [$dTraversable_sg1Ok $dTraversable1_sg1Ol] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Sum.$fTraversableSum_$ctraverse
                      $dTraversable_sg1Ok $dTraversable1_sg1Ol eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sg1On [Occ=Once]
            :: Data.Foldable.Foldable (Data.Functor.Sum.Sum f_afWXq g_afWXr)
          [LclId] =
              [$dTraversable_sg1Ok $dTraversable1_sg1Ol] \u []
                  Data.Functor.Sum.$fTraversableSum_$cp2Traversable
                      $dTraversable_sg1Ok $dTraversable1_sg1Ol; } in
        let {
          sat_sg1Om [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Sum.Sum f_afWXq g_afWXr)
          [LclId] =
              [$dTraversable_sg1Ok $dTraversable1_sg1Ol] \u []
                  Data.Functor.Sum.$fTraversableSum_$cp1Traversable
                      $dTraversable_sg1Ok $dTraversable1_sg1Ol;
        } in 
          Data.Traversable.C:Traversable [sat_sg1Om
                                          sat_sg1On
                                          sat_sg1Oo
                                          sat_sg1Op
                                          sat_sg1Oq
                                          sat_sg1Or];

Data.Functor.Sum.$fGeneric1Sum_$cto1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Data.Functor.Sum.Sum f g) a
     -> Data.Functor.Sum.Sum f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sg1Os]
        case ds_sg1Os of {
          GHC.Generics.L1 ds1_sg1Ou [Occ=Once] ->
              Data.Functor.Sum.InL [ds1_sg1Ou];
          GHC.Generics.R1 ds1_sg1Ov [Occ=Once] ->
              Data.Functor.Sum.InR [ds1_sg1Ov];
        };

Data.Functor.Sum.$fGeneric1Sum1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Sum.Sum f g a
     -> (GHC.Generics.:+:)
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InL" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.Rec1 f)))
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InR" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.Rec1 g)))
          a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sg1Ow]
        case x_sg1Ow of {
          Data.Functor.Sum.InL g1_sg1Oy [Occ=Once] ->
              GHC.Generics.L1 [g1_sg1Oy];
          Data.Functor.Sum.InR g1_sg1Oz [Occ=Once] ->
              GHC.Generics.R1 [g1_sg1Oz];
        };

Data.Functor.Sum.$fGeneric1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *).
     GHC.Generics.Generic1 (Data.Functor.Sum.Sum f g)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Functor.Sum.$fGeneric1Sum1
                                            Data.Functor.Sum.$fGeneric1Sum_$cto1];

Data.Functor.Sum.$fGenericSum_$cto
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Data.Functor.Sum.Sum f g a) x
     -> Data.Functor.Sum.Sum f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sg1OA]
        case ds_sg1OA of {
          GHC.Generics.L1 ds1_sg1OC [Occ=Once] ->
              Data.Functor.Sum.InL [ds1_sg1OC];
          GHC.Generics.R1 ds1_sg1OD [Occ=Once] ->
              Data.Functor.Sum.InR [ds1_sg1OD];
        };

Data.Functor.Sum.$fGenericSum1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     Data.Functor.Sum.Sum f g a
     -> (GHC.Generics.:+:)
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InL" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.K1 GHC.Generics.R (f a))))
          (GHC.Generics.M1
             GHC.Generics.C
             ('GHC.Generics.MetaCons
                "InR" 'GHC.Generics.PrefixI 'GHC.Types.False)
             (GHC.Generics.M1
                GHC.Generics.S
                ('GHC.Generics.MetaSel
                   'GHC.Base.Nothing
                   'GHC.Generics.NoSourceUnpackedness
                   'GHC.Generics.NoSourceStrictness
                   'GHC.Generics.DecidedLazy)
                (GHC.Generics.K1 GHC.Generics.R (g a))))
          x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sg1OE]
        case x1_sg1OE of {
          Data.Functor.Sum.InL g1_sg1OG [Occ=Once] ->
              GHC.Generics.L1 [g1_sg1OG];
          Data.Functor.Sum.InR g1_sg1OH [Occ=Once] ->
              GHC.Generics.R1 [g1_sg1OH];
        };

Data.Functor.Sum.$fGenericSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Generic (Data.Functor.Sum.Sum f g a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Sum.$fGenericSum1
                                           Data.Functor.Sum.$fGenericSum_$cto];

Data.Functor.Sum.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.ConstrRep
     -> Data.Data.DataType
     -> c (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=6,
 Str=<L,U><L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [w_sg1OI w1_sg1OJ w2_sg1OK w3_sg1OL ww_sg1OM ww1_sg1ON]
        case ww_sg1OM of {
          __DEFAULT ->
              case ww1_sg1ON of {
                Data.Data.DataType ww7_sg1OQ [Occ=Once] _ [Occ=Dead] ->
                    Data.Data.$wlvl ww7_sg1OQ;
              };
          Data.Data.AlgConstr idx_sg1OT [Occ=Once!] ->
              case idx_sg1OT of {
                GHC.Types.I# ds_sg1OV [Occ=Once!] ->
                    case ds_sg1OV of {
                      __DEFAULT ->
                          let {
                            sat_sg1OX [Occ=Once]
                              :: c_sfXCk (g_sfXCc a_sfXCd
                                          -> Data.Functor.Sum.Sum f_sfXCb g_sfXCc a_sfXCd)
                            [LclId] =
                                [w3_sg1OL] \u [] w3_sg1OL Data.Functor.Sum.InR;
                          } in  w2_sg1OK w1_sg1OJ sat_sg1OX;
                      1# ->
                          let {
                            sat_sg1OY [Occ=Once]
                              :: c_sfXCk (f_sfXCb a_sfXCd
                                          -> Data.Functor.Sum.Sum f_sfXCb g_sfXCc a_sfXCd)
                            [LclId] =
                                [w3_sg1OL] \u [] w3_sg1OL Data.Functor.Sum.InL;
                          } in  w2_sg1OK w_sg1OI sat_sg1OY;
                    };
              };
        };

Data.Functor.Sum.$fDataSum_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=OtherCon []] =
    [] \r [w_sg1OZ
           w1_sg1P0
           w2_sg1P1
           w3_sg1P2
           w4_sg1P3
           w5_sg1P4
           w6_sg1P5
           w7_sg1P6
           w8_sg1P7]
        case w8_sg1P7 of {
          Data.Data.Constr ww1_sg1P9 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           ww5_sg1Pd [Occ=Once] ->
              Data.Functor.Sum.$w$cgunfold
                  w4_sg1P3 w5_sg1P4 w6_sg1P5 w7_sg1P6 ww1_sg1P9 ww5_sg1Pd;
        };

Data.Functor.Sum.$fDataSum_$cgfoldl
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g1. g1 -> c g1)
     -> Data.Functor.Sum.Sum f g a
     -> c (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg1Pe
           $dTypeable1_sg1Pf
           $dTypeable2_sg1Pg
           $dTypeable3_sg1Ph
           $dData_sg1Pi
           $dData1_sg1Pj
           k1_sg1Pk
           z_sg1Pl
           ds_sg1Pm]
        case ds_sg1Pm of {
          Data.Functor.Sum.InL a1_sg1Po [Occ=Once] ->
              let {
                sat_sg1Pp [Occ=Once]
                  :: c_afWQl (f_afWQ5 a_afWQ7
                              -> Data.Functor.Sum.Sum f_afWQ5 g_afWQ6 a_afWQ7)
                [LclId] =
                    [z_sg1Pl] \u [] z_sg1Pl Data.Functor.Sum.InL;
              } in  k1_sg1Pk $dData_sg1Pi sat_sg1Pp a1_sg1Po;
          Data.Functor.Sum.InR a1_sg1Pq [Occ=Once] ->
              let {
                sat_sg1Pr [Occ=Once]
                  :: c_afWQl (g_afWQ6 a_afWQ7
                              -> Data.Functor.Sum.Sum f_afWQ5 g_afWQ6 a_afWQ7)
                [LclId] =
                    [z_sg1Pl] \u [] z_sg1Pl Data.Functor.Sum.InR;
              } in  k1_sg1Pk $dData1_sg1Pj sat_sg1Pr a1_sg1Pq;
        };

Data.Functor.Sum.$fDataSum8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Sum"#;

$tSum1_rfXP5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Functor.Sum.$fDataSum8;

go61_rfXP6
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sg1Ps _ys_sg1Pt]
        case ds2_sg1Ps of {
          [] -> GHC.List.badHead;
          : ipv_sg1Pv [Occ=Once!] ipv1_sg1Pw [Occ=Once] ->
              case _ys_sg1Pt of {
                [] -> GHC.List.badHead;
                : ipv2_sg1Py [Occ=Once] ipv3_sg1Pz [Occ=Once] ->
                    case ipv_sg1Pv of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sg1PC [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sg1PC Data.Functor.Sum.$fRead1Sum7 of {
                            GHC.Types.False -> go61_rfXP6 ipv1_sg1Pw ipv3_sg1Pz;
                            GHC.Types.True -> ipv2_sg1Py;
                          };
                    };
              };
        };

go1_rfXP7
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sg1PH _ys_sg1PI]
        case ds2_sg1PH of {
          [] -> GHC.List.badHead;
          : ipv_sg1PK [Occ=Once!] ipv1_sg1PL [Occ=Once] ->
              case _ys_sg1PI of {
                [] -> GHC.List.badHead;
                : ipv2_sg1PN [Occ=Once] ipv3_sg1PO [Occ=Once] ->
                    case ipv_sg1PK of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sg1PR [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sg1PR Data.Functor.Sum.$fRead1Sum3 of {
                            GHC.Types.False -> go1_rfXP7 ipv1_sg1PL ipv3_sg1PO;
                            GHC.Types.True -> ipv2_sg1PN;
                          };
                    };
              };
        };

$cInL1_rfXP8 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cInL2_rfXPe];
$cInR1_rfXP9 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cInR2_rfXPd];
Data.Functor.Sum.$cInL [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cInL1_rfXP8
                                     Data.Functor.Sum.$fRead1Sum7
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Functor.Sum.$tSum];
$tSum2_rfXPa :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Sum.$cInR GHC.Types.[]];
$tSum3_rfXPb :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Sum.$cInL $tSum2_rfXPa];
$tSum4_rfXPc :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [$tSum3_rfXPb];
Data.Functor.Sum.$tSum [Occ=LoopBreaker] :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [$tSum1_rfXP5 $tSum4_rfXPc];
Data.Functor.Sum.$cInR [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cInR1_rfXP9
                                     Data.Functor.Sum.$fRead1Sum3
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Functor.Sum.$tSum];
$cInR2_rfXPd :: Data.Data.ConIndex
[GblId] =
    [] \u [] go1_rfXP7 $tSum3_rfXPb Data.Data.mkConstr1;
$cInL2_rfXPe :: Data.Data.ConIndex
[GblId] =
    [] \u [] go61_rfXP6 $tSum3_rfXPb Data.Data.mkConstr1;

Data.Functor.Sum.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Sum.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$trModule4];

Data.Functor.Sum.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Sum"#;

Data.Functor.Sum.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$trModule2];

Data.Functor.Sum.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Sum.$trModule3
                                     Data.Functor.Sum.$trModule1];

$krep_rfXPf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_rfXPg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rfXPf GHC.Types.krep$*];

$krep2_rfXPh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfXPg $krep1_rfXPg];

Data.Functor.Sum.$fDataSum6 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfXPg $krep2_rfXPh];

$krep3_rfXPi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep4_rfXPj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_rfXPk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [3#];

$krep6_rfXPl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rfXPj $krep5_rfXPk];

$krep7_rfXPm :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep3_rfXPi $krep5_rfXPk];

Data.Functor.Sum.$fDataSum7 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$fDataSum8];

Data.Functor.Sum.$tcSum :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6345190594862254730##
                                    1236278515871186010##
                                    Data.Functor.Sum.$trModule
                                    Data.Functor.Sum.$fDataSum7
                                    1#
                                    Data.Functor.Sum.$fDataSum6];

$krep8_rfXPn :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep5_rfXPk GHC.Types.[]];

$krep9_rfXPo :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rfXPi $krep8_rfXPn];

$krep10_rfXPp :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rfXPj $krep9_rfXPo];

$krep11_rfXPq :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rfXPf $krep10_rfXPp];

$krep12_rfXPr :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Sum.$tcSum
                                              $krep11_rfXPq];

Data.Functor.Sum.$tc'InL1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rfXPl $krep12_rfXPr];

Data.Functor.Sum.$tc'InL3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'InL"#;

Data.Functor.Sum.$tc'InL2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$tc'InL3];

Data.Functor.Sum.$tc'InL :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7951421854502432011##
                                    12303552236073891860##
                                    Data.Functor.Sum.$trModule
                                    Data.Functor.Sum.$tc'InL2
                                    4#
                                    Data.Functor.Sum.$tc'InL1];

Data.Functor.Sum.$tc'InR1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_rfXPm $krep12_rfXPr];

Data.Functor.Sum.$tc'InR3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'InR"#;

Data.Functor.Sum.$tc'InR2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Sum.$tc'InR3];

Data.Functor.Sum.$tc'InR :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12078304815884238110##
                                    12377490770432979855##
                                    Data.Functor.Sum.$trModule
                                    Data.Functor.Sum.$tc'InR2
                                    4#
                                    Data.Functor.Sum.$tc'InR1];

Data.Functor.Sum.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Sum.Sum f g a)
[GblId, Arity=4, Str=<S,U><S,U><S,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sg1PW w1_sg1PX w2_sg1PY w3_sg1PZ]
        let {
          sat_sg1Q0 [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w3_sg1PZ]; } in
        let {
          sat_sg1Q1 [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sg1Q0 GHC.Types.[]];
        } in 
          case
              Data.Typeable.Internal.$wmkTrCon
                  6345190594862254730##
                  1236278515871186010##
                  Data.Functor.Sum.$trModule
                  Data.Functor.Sum.$fDataSum7
                  1#
                  Data.Functor.Sum.$fDataSum6
                  sat_sg1Q1
          of
          { (#,,,,#) ww8_sg1Q3 [Occ=Once]
                     ww9_sg1Q4 [Occ=Once]
                     ww10_sg1Q5 [Occ=Once]
                     ww11_sg1Q6 [Occ=Once]
                     ww12_sg1Q7 [Occ=Once] ->
                let {
                  sat_sg1Q8 [Occ=Once]
                    :: Data.Typeable.Internal.TypeRep Data.Functor.Sum.Sum
                  [LclId] =
                      CCCS Data.Typeable.Internal.TrTyCon! [ww8_sg1Q3
                                                            ww9_sg1Q4
                                                            ww10_sg1Q5
                                                            ww11_sg1Q6
                                                            ww12_sg1Q7];
                } in 
                  case
                      Data.Typeable.Internal.mkTrApp sat_sg1Q8 w1_sg1PX
                  of
                  sat_sg1Q9
                  { __DEFAULT ->
                        case
                            Data.Typeable.Internal.mkTrApp sat_sg1Q9 w2_sg1PY
                        of
                        sat_sg1Qa
                        { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sg1Qa w_sg1PW;
                        };
                  };
          };

Data.Functor.Sum.$fDataSum5 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sg1Qb w1_sg1Qc w2_sg1Qd w3_sg1Qe w4_sg1Qf w5_sg1Qg]
        Data.Functor.Sum.$w$cp1Data w_sg1Qb w1_sg1Qc w2_sg1Qd w3_sg1Qe;

Data.Functor.Sum.$fDataSum2
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (f a -> Data.Functor.Sum.Sum f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Sum.InL GHC.Types.False];

Data.Functor.Sum.$fDataSum1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (g a -> Data.Functor.Sum.Sum f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Sum.InR GHC.Types.False];

Data.Functor.Sum.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1Qh w1_sg1Qi w2_sg1Qj w3_sg1Qk w4_sg1Ql]
        let {
          lvl8_sg1Qm [Occ=OnceL]
            :: m_sfXD1 (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
          [LclId] =
              [w2_sg1Qj] \u [] GHC.Base.mzero w2_sg1Qj;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sg1Qj
          of
          $dMonad_sg1Qn [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sg1QR [Occ=Once]
                    :: (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU, GHC.Types.Bool)
                       -> m_sfXD1 (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
                  [LclId] =
                      [lvl8_sg1Qm $dMonad_sg1Qn] \r [ds_sg1QM]
                          case ds_sg1QM of {
                            (,) x'_sg1QO [Occ=Once] b_sg1QP [Occ=Once!] ->
                                case b_sg1QP of {
                                  GHC.Types.False -> lvl8_sg1Qm;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sg1Qn x'_sg1QO;
                                };
                          }; } in
                let {
                  sat_sg1QL [Occ=Once]
                    :: m_sfXD1 (Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sg1Qh w1_sg1Qi w2_sg1Qj w3_sg1Qk w4_sg1Ql $dMonad_sg1Qn] \u []
                          let {
                            k1_sg1Qo [Occ=Once*!, Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
                              :: forall d b.
                                 Data.Data.Data d =>
                                 Data.Data.Mp m_sfXD1 (d -> b) -> d -> m_sfXD1 (b, GHC.Types.Bool)
                            [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                sat-only [w2_sg1Qj w3_sg1Qk $dMonad_sg1Qn] \r [$dData1_sg1Qp
                                                                               ds_sg1Qq
                                                                               y_sg1Qr]
                                    let {
                                      lvl9_sg1Qs [Occ=OnceL] :: m_sfXD1 d_ae2Ws
                                      [LclId] =
                                          [w3_sg1Qk $dData1_sg1Qp y_sg1Qr] \u []
                                              w3_sg1Qk $dData1_sg1Qp y_sg1Qr; } in
                                    let {
                                      sat_sg1QF [Occ=Once]
                                        :: (d_ae2Ws -> b_ae2Wt, GHC.Types.Bool)
                                           -> m_sfXD1 (b_ae2Wt, GHC.Types.Bool)
                                      [LclId] =
                                          [w2_sg1Qj $dMonad_sg1Qn y_sg1Qr lvl9_sg1Qs] \r [ds1_sg1Qt]
                                              case ds1_sg1Qt of {
                                                (,) h_sg1Qv b1_sg1Qw [Occ=Once] ->
                                                    let {
                                                      sat_sg1QE [Occ=Once]
                                                        :: m_sfXD1 (b_ae2Wt, GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sg1Qn
                                                           y_sg1Qr
                                                           h_sg1Qv
                                                           b1_sg1Qw] \u []
                                                              let {
                                                                sat_sg1QC [Occ=Once] :: b_ae2Wt
                                                                [LclId] =
                                                                    [y_sg1Qr h_sg1Qv] \u []
                                                                        h_sg1Qv y_sg1Qr; } in
                                                              let {
                                                                sat_sg1QD [Occ=Once]
                                                                  :: (b_ae2Wt, GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sg1QC b1_sg1Qw];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sg1Qn sat_sg1QD; } in
                                                    let {
                                                      sat_sg1QB [Occ=Once]
                                                        :: m_sfXD1 (b_ae2Wt, GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sg1Qn lvl9_sg1Qs h_sg1Qv] \u []
                                                              let {
                                                                sat_sg1QA [Occ=Once]
                                                                  :: d_ae2Ws
                                                                     -> m_sfXD1 (b_ae2Wt,
                                                                                 GHC.Types.Bool)
                                                                [LclId] =
                                                                    [$dMonad_sg1Qn
                                                                     h_sg1Qv] \r [y'_sg1Qx]
                                                                        let {
                                                                          sat_sg1Qy [Occ=Once]
                                                                            :: b_ae2Wt
                                                                          [LclId] =
                                                                              [h_sg1Qv
                                                                               y'_sg1Qx] \u []
                                                                                  h_sg1Qv
                                                                                      y'_sg1Qx; } in
                                                                        let {
                                                                          sat_sg1Qz [Occ=Once]
                                                                            :: (b_ae2Wt,
                                                                                GHC.Types.Bool)
                                                                          [LclId] =
                                                                              CCCS (,)! [sat_sg1Qy
                                                                                         GHC.Types.True];
                                                                        } in 
                                                                          GHC.Base.return
                                                                              $dMonad_sg1Qn
                                                                              sat_sg1Qz;
                                                              } in 
                                                                GHC.Base.>>=
                                                                    $dMonad_sg1Qn
                                                                    lvl9_sg1Qs
                                                                    sat_sg1QA;
                                                    } in 
                                                      GHC.Base.mplus w2_sg1Qj sat_sg1QB sat_sg1QE;
                                              };
                                    } in  GHC.Base.>>= $dMonad_sg1Qn ds_sg1Qq sat_sg1QF;
                          } in 
                            case w4_sg1Ql of {
                              Data.Functor.Sum.InL a1_sg1QH [Occ=Once] ->
                                  let {
                                    sat_sg1QI [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXD1
                                           (f_sfXCS a_sfXCU
                                            -> Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
                                    [LclId] =
                                        [$dMonad_sg1Qn] \u []
                                            GHC.Base.return
                                                $dMonad_sg1Qn Data.Functor.Sum.$fDataSum2;
                                  } in  k1_sg1Qo w_sg1Qh sat_sg1QI a1_sg1QH;
                              Data.Functor.Sum.InR a1_sg1QJ [Occ=Once] ->
                                  let {
                                    sat_sg1QK [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXD1
                                           (g_sfXCT a_sfXCU
                                            -> Data.Functor.Sum.Sum f_sfXCS g_sfXCT a_sfXCU)
                                    [LclId] =
                                        [$dMonad_sg1Qn] \u []
                                            GHC.Base.return
                                                $dMonad_sg1Qn Data.Functor.Sum.$fDataSum1;
                                  } in  k1_sg1Qo w1_sg1Qi sat_sg1QK a1_sg1QJ;
                            };
                } in  GHC.Base.>>= $dMonad_sg1Qn sat_sg1QL sat_sg1QR;
          };

Data.Functor.Sum.$fDataSum_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1QS
           w1_sg1QT
           w2_sg1QU
           w3_sg1QV
           w4_sg1QW
           w5_sg1QX
           w6_sg1QY
           w7_sg1QZ
           w8_sg1R0]
        Data.Functor.Sum.$w$cgmapMp
            w4_sg1QW w5_sg1QX w6_sg1QY w7_sg1QZ w8_sg1R0;

Data.Functor.Sum.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1R1 w1_sg1R2 w2_sg1R3 w3_sg1R4 w4_sg1R5]
        let {
          k1_sg1R6 [Occ=Once*!, Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
            :: forall d b.
               Data.Data.Data d =>
               m_sfXDl (d -> b) -> d -> m_sfXDl b
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w2_sg1R3 w3_sg1R4] \r [$dData1_sg1R7 c_sg1R8 x_sg1R9]
                  let {
                    lvl8_sg1Ra [Occ=OnceL] :: m_sfXDl d_ae2Vh
                    [LclId] =
                        [w3_sg1R4 $dData1_sg1R7 x_sg1R9] \u []
                            w3_sg1R4 $dData1_sg1R7 x_sg1R9; } in
                  let {
                    sat_sg1Rf [Occ=Once] :: (d_ae2Vh -> b_ae2Vi) -> m_sfXDl b_ae2Vi
                    [LclId] =
                        [w2_sg1R3 lvl8_sg1Ra] \r [c'_sg1Rb]
                            let {
                              sat_sg1Re [Occ=Once] :: d_ae2Vh -> m_sfXDl b_ae2Vi
                              [LclId] =
                                  [w2_sg1R3 c'_sg1Rb] \r [x'_sg1Rc]
                                      let {
                                        sat_sg1Rd [Occ=Once] :: b_ae2Vi
                                        [LclId] =
                                            [c'_sg1Rb x'_sg1Rc] \u [] c'_sg1Rb x'_sg1Rc;
                                      } in  GHC.Base.return w2_sg1R3 sat_sg1Rd;
                            } in  GHC.Base.>>= w2_sg1R3 lvl8_sg1Ra sat_sg1Re;
                  } in  GHC.Base.>>= w2_sg1R3 c_sg1R8 sat_sg1Rf;
        } in 
          case w4_sg1R5 of {
            Data.Functor.Sum.InL a1_sg1Rh [Occ=Once] ->
                let {
                  sat_sg1Ri [Occ=Once]
                    :: m_sfXDl (f_sfXDc a_sfXDe
                                -> Data.Functor.Sum.Sum f_sfXDc g_sfXDd a_sfXDe)
                  [LclId] =
                      [w2_sg1R3] \u [] GHC.Base.return w2_sg1R3 Data.Functor.Sum.InL;
                } in  k1_sg1R6 w_sg1R1 sat_sg1Ri a1_sg1Rh;
            Data.Functor.Sum.InR a1_sg1Rj [Occ=Once] ->
                let {
                  sat_sg1Rk [Occ=Once]
                    :: m_sfXDl (g_sfXDd a_sfXDe
                                -> Data.Functor.Sum.Sum f_sfXDc g_sfXDd a_sfXDe)
                  [LclId] =
                      [w2_sg1R3] \u [] GHC.Base.return w2_sg1R3 Data.Functor.Sum.InR;
                } in  k1_sg1R6 w1_sg1R2 sat_sg1Rk a1_sg1Rj;
          };

Data.Functor.Sum.$fDataSum_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1Rl
           w1_sg1Rm
           w2_sg1Rn
           w3_sg1Ro
           w4_sg1Rp
           w5_sg1Rq
           w6_sg1Rr
           w7_sg1Rs
           w8_sg1Rt]
        Data.Functor.Sum.$w$cgmapM
            w4_sg1Rp w5_sg1Rq w6_sg1Rr w7_sg1Rs w8_sg1Rt;

Data.Functor.Sum.$fDataSum_$cgmapQi
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Functor.Sum.Sum f g a
     -> u
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg1Ru
           $dTypeable1_sg1Rv
           $dTypeable2_sg1Rw
           $dTypeable3_sg1Rx
           $dData_sg1Ry
           $dData1_sg1Rz
           ds_sg1RA
           ds1_sg1RB
           x_sg1RC]
        case x_sg1RC of {
          Data.Functor.Sum.InL a1_sg1RE [Occ=Once] ->
              case ds_sg1RA of {
                GHC.Types.I# x1_sg1RG [Occ=Once!] ->
                    case x1_sg1RG of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sg1RB $dData_sg1Ry a1_sg1RE;
                    };
              };
          Data.Functor.Sum.InR a1_sg1RI [Occ=Once] ->
              case ds_sg1RA of {
                GHC.Types.I# x1_sg1RK [Occ=Once!] ->
                    case x1_sg1RK of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sg1RB $dData1_sg1Rz a1_sg1RI;
                    };
              };
        };

Data.Functor.Sum.$fDataSum_$cgmapQr
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Sum.Sum f g a
     -> r
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg1RM
           $dTypeable1_sg1RN
           $dTypeable2_sg1RO
           $dTypeable3_sg1RP
           $dData_sg1RQ
           $dData1_sg1RR
           ds_sg1RS
           ds1_sg1RT
           ds2_sg1RU
           x0_sg1RV]
        case x0_sg1RV of {
          Data.Functor.Sum.InL a1_sg1RX [Occ=Once] ->
              let {
                sat_sg1RY [Occ=Once] :: r'_afWSm
                [LclId] =
                    [$dData_sg1RQ ds2_sg1RU a1_sg1RX] \u []
                        ds2_sg1RU $dData_sg1RQ a1_sg1RX;
              } in  ds_sg1RS sat_sg1RY ds1_sg1RT;
          Data.Functor.Sum.InR a1_sg1RZ [Occ=Once] ->
              let {
                sat_sg1S0 [Occ=Once] :: r'_afWSm
                [LclId] =
                    [$dData1_sg1RR ds2_sg1RU a1_sg1RZ] \u []
                        ds2_sg1RU $dData1_sg1RR a1_sg1RZ;
              } in  ds_sg1RS sat_sg1S0 ds1_sg1RT;
        };

Data.Functor.Sum.$fDataSum_$cgmapQ
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Functor.Sum.Sum f g a -> [u]
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><L,1*C1(C1(U))><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg1S1
           $dTypeable1_sg1S2
           $dTypeable2_sg1S3
           $dTypeable3_sg1S4
           $dData_sg1S5
           $dData1_sg1S6
           ds_sg1S7
           x0_sg1S8]
        case x0_sg1S8 of {
          Data.Functor.Sum.InL a1_sg1Sa [Occ=Once] ->
              let {
                sat_sg1Sb [Occ=Once] :: u_afWSC
                [LclId] =
                    [$dData_sg1S5 ds_sg1S7 a1_sg1Sa] \u []
                        ds_sg1S7 $dData_sg1S5 a1_sg1Sa;
              } in  : [sat_sg1Sb GHC.Types.[]];
          Data.Functor.Sum.InR a1_sg1Sc [Occ=Once] ->
              let {
                sat_sg1Sd [Occ=Once] :: u_afWSC
                [LclId] =
                    [$dData1_sg1S6 ds_sg1S7 a1_sg1Sc] \u []
                        ds_sg1S7 $dData1_sg1S6 a1_sg1Sc;
              } in  : [sat_sg1Sd GHC.Types.[]];
        };

Data.Functor.Sum.$fDataSum3
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Const.Const r (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg1Se
           $dTypeable1_sg1Sf
           $dTypeable2_sg1Sg
           $dTypeable3_sg1Sh
           $dData_sg1Si
           $dData1_sg1Sj
           ds_sg1Sk
           ds1_sg1Sl
           ds2_sg1Sm
           eta_sg1Sn]
        case eta_sg1Sn of {
          Data.Functor.Sum.InL a1_sg1Sp [Occ=Once] ->
              let {
                sat_sg1Sq [Occ=Once] :: r'_afWS5
                [LclId] =
                    [$dData_sg1Si ds2_sg1Sm a1_sg1Sp] \u []
                        ds2_sg1Sm $dData_sg1Si a1_sg1Sp;
              } in  ds_sg1Sk ds1_sg1Sl sat_sg1Sq;
          Data.Functor.Sum.InR a1_sg1Sr [Occ=Once] ->
              let {
                sat_sg1Ss [Occ=Once] :: r'_afWS5
                [LclId] =
                    [$dData1_sg1Sj ds2_sg1Sm a1_sg1Sr] \u []
                        ds2_sg1Sm $dData1_sg1Sj a1_sg1Sr;
              } in  ds_sg1Sk ds1_sg1Sl sat_sg1Ss;
        };

Data.Functor.Sum.$fDataSum4
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Functor.Sum.Sum f g a
     -> Data.Functor.Identity.Identity (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sg1St
           $dTypeable1_sg1Su
           $dTypeable2_sg1Sv
           $dTypeable3_sg1Sw
           $dData_sg1Sx
           $dData1_sg1Sy
           ds_sg1Sz
           x0_sg1SA]
        case x0_sg1SA of {
          Data.Functor.Sum.InL a1_sg1SC [Occ=Once] ->
              let {
                sat_sg1SD [Occ=Once] :: f_XfWUu a_XfWUy
                [LclId] =
                    [$dData_sg1Sx ds_sg1Sz a1_sg1SC] \u []
                        ds_sg1Sz $dData_sg1Sx a1_sg1SC;
              } in  Data.Functor.Sum.InL [sat_sg1SD];
          Data.Functor.Sum.InR a1_sg1SE [Occ=Once] ->
              let {
                sat_sg1SF [Occ=Once] :: g_XfWUw a_XfWUy
                [LclId] =
                    [$dData1_sg1Sy ds_sg1Sz a1_sg1SE] \u []
                        ds_sg1Sz $dData1_sg1Sy a1_sg1SE;
              } in  Data.Functor.Sum.InR [sat_sg1SF];
        };

Data.Functor.Sum.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Data.Data (f a), Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1SG w1_sg1SH w2_sg1SI w3_sg1SJ w4_sg1SK]
        let {
          lvl8_sg1SL [Occ=OnceL]
            :: m_sfXDF (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
          [LclId] =
              [w2_sg1SI] \u [] GHC.Base.mzero w2_sg1SI;
        } in 
          case
              GHC.Base.$p2MonadPlus w2_sg1SI
          of
          $dMonad_sg1SM [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sg1Tj [Occ=Once]
                    :: (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy, GHC.Types.Bool)
                       -> m_sfXDF (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
                  [LclId] =
                      [lvl8_sg1SL $dMonad_sg1SM] \r [ds_sg1Te]
                          case ds_sg1Te of {
                            (,) x'_sg1Tg [Occ=Once] b_sg1Th [Occ=Once!] ->
                                case b_sg1Th of {
                                  GHC.Types.False -> lvl8_sg1SL;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sg1SM x'_sg1Tg;
                                };
                          }; } in
                let {
                  sat_sg1Td [Occ=Once]
                    :: m_sfXDF (Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sg1SG w1_sg1SH w2_sg1SI w3_sg1SJ w4_sg1SK $dMonad_sg1SM] \u []
                          let {
                            k1_sg1SN [Occ=Once*!, Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
                              :: forall d b.
                                 Data.Data.Data d =>
                                 Data.Data.Mp m_sfXDF (d -> b) -> d -> m_sfXDF (b, GHC.Types.Bool)
                            [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                sat-only [w2_sg1SI w3_sg1SJ $dMonad_sg1SM] \r [$dData1_sg1SO
                                                                               ds_sg1SP
                                                                               y_sg1SQ]
                                    let {
                                      lvl9_sg1SR [Occ=OnceL] :: m_sfXDF d_ae2Ya
                                      [LclId] =
                                          [w3_sg1SJ $dData1_sg1SO y_sg1SQ] \u []
                                              w3_sg1SJ $dData1_sg1SO y_sg1SQ; } in
                                    let {
                                      sat_sg1T7 [Occ=Once]
                                        :: (d_ae2Ya -> b_ae2Yb, GHC.Types.Bool)
                                           -> m_sfXDF (b_ae2Yb, GHC.Types.Bool)
                                      [LclId] =
                                          [w2_sg1SI $dMonad_sg1SM y_sg1SQ lvl9_sg1SR] \r [ds1_sg1SS]
                                              case ds1_sg1SS of {
                                                (,) h_sg1SU b1_sg1SV [Occ=Once!] ->
                                                    case b1_sg1SV of {
                                                      GHC.Types.False ->
                                                          let {
                                                            sat_sg1T4 [Occ=Once]
                                                              :: m_sfXDF (b_ae2Yb, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sg1SM
                                                                 y_sg1SQ
                                                                 h_sg1SU] \u []
                                                                    let {
                                                                      sat_sg1T2 [Occ=Once]
                                                                        :: b_ae2Yb
                                                                      [LclId] =
                                                                          [y_sg1SQ h_sg1SU] \u []
                                                                              h_sg1SU y_sg1SQ; } in
                                                                    let {
                                                                      sat_sg1T3 [Occ=Once]
                                                                        :: (b_ae2Yb, GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sg1T2
                                                                                     GHC.Types.False];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sg1SM
                                                                          sat_sg1T3; } in
                                                          let {
                                                            sat_sg1T1 [Occ=Once]
                                                              :: m_sfXDF (b_ae2Yb, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sg1SM
                                                                 lvl9_sg1SR
                                                                 h_sg1SU] \u []
                                                                    let {
                                                                      sat_sg1T0 [Occ=Once]
                                                                        :: d_ae2Ya
                                                                           -> m_sfXDF (b_ae2Yb,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sg1SM
                                                                           h_sg1SU] \r [y'_sg1SX]
                                                                              let {
                                                                                sat_sg1SY [Occ=Once]
                                                                                  :: b_ae2Yb
                                                                                [LclId] =
                                                                                    [h_sg1SU
                                                                                     y'_sg1SX] \u []
                                                                                        h_sg1SU
                                                                                            y'_sg1SX; } in
                                                                              let {
                                                                                sat_sg1SZ [Occ=Once]
                                                                                  :: (b_ae2Yb,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sg1SY
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sg1SM
                                                                                    sat_sg1SZ;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sg1SM
                                                                          lvl9_sg1SR
                                                                          sat_sg1T0;
                                                          } in 
                                                            GHC.Base.mplus
                                                                w2_sg1SI sat_sg1T1 sat_sg1T4;
                                                      GHC.Types.True ->
                                                          let {
                                                            sat_sg1T5 [Occ=Once] :: b_ae2Yb
                                                            [LclId] =
                                                                [y_sg1SQ h_sg1SU] \u []
                                                                    h_sg1SU y_sg1SQ; } in
                                                          let {
                                                            sat_sg1T6 [Occ=Once]
                                                              :: (b_ae2Yb, GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sg1T5
                                                                           GHC.Types.True];
                                                          } in 
                                                            GHC.Base.return $dMonad_sg1SM sat_sg1T6;
                                                    };
                                              };
                                    } in  GHC.Base.>>= $dMonad_sg1SM ds_sg1SP sat_sg1T7;
                          } in 
                            case w4_sg1SK of {
                              Data.Functor.Sum.InL a1_sg1T9 [Occ=Once] ->
                                  let {
                                    sat_sg1Ta [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXDF
                                           (f_sfXDw a_sfXDy
                                            -> Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
                                    [LclId] =
                                        [$dMonad_sg1SM] \u []
                                            GHC.Base.return
                                                $dMonad_sg1SM Data.Functor.Sum.$fDataSum2;
                                  } in  k1_sg1SN w_sg1SG sat_sg1Ta a1_sg1T9;
                              Data.Functor.Sum.InR a1_sg1Tb [Occ=Once] ->
                                  let {
                                    sat_sg1Tc [Occ=Once]
                                      :: Data.Data.Mp
                                           m_sfXDF
                                           (g_sfXDx a_sfXDy
                                            -> Data.Functor.Sum.Sum f_sfXDw g_sfXDx a_sfXDy)
                                    [LclId] =
                                        [$dMonad_sg1SM] \u []
                                            GHC.Base.return
                                                $dMonad_sg1SM Data.Functor.Sum.$fDataSum1;
                                  } in  k1_sg1SN w1_sg1SH sat_sg1Tc a1_sg1Tb;
                            };
                } in  GHC.Base.>>= $dMonad_sg1SM sat_sg1Td sat_sg1Tj;
          };

Data.Functor.Sum.$fDataSum_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Sum.Sum f g a -> m (Data.Functor.Sum.Sum f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sg1Tk
           w1_sg1Tl
           w2_sg1Tm
           w3_sg1Tn
           w4_sg1To
           w5_sg1Tp
           w6_sg1Tq
           w7_sg1Tr
           w8_sg1Ts]
        Data.Functor.Sum.$w$cgmapMo
            w4_sg1To w5_sg1Tp w6_sg1Tq w7_sg1Tr w8_sg1Ts;

lvl4_rfXPs
  :: forall k (g :: k -> *) (a :: k) (f :: k -> *).
     Data.Functor.Sum.Sum f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sg1Tt]
        case ds_sg1Tt of {
          Data.Functor.Sum.InL _ [Occ=Dead] -> Data.Functor.Sum.$cInL;
          Data.Functor.Sum.InR _ [Occ=Dead] -> Data.Functor.Sum.$cInR;
        };

lvl5_rfXPt
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Data.Functor.Sum.Sum f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sg1Tx] Data.Functor.Sum.$tSum;

lvl6_rfXPu
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Functor.Sum.Sum f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sg1Ty ds_sg1Tz] GHC.Base.Nothing [];

lvl7_rfXPv
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Functor.Sum.Sum f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sg1TA ds_sg1TB] GHC.Base.Nothing [];

Data.Functor.Sum.$fDataSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data.Data.Data (f a),
      Data.Data.Data (g a)) =>
     Data.Data.Data (Data.Functor.Sum.Sum f g a)
[GblId[DFunId], Arity=6, Str=<L,U><L,U><L,U><L,U><L,U><L,U>] =
    [] \r [$dTypeable_sg1TC
           $dTypeable1_sg1TD
           $dTypeable2_sg1TE
           $dTypeable3_sg1TF
           $dData_sg1TG
           $dData1_sg1TH]
        let {
          sat_sg1U1 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> m (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dData_sg1TG $dData1_sg1TH] \r [w_sg1TY w1_sg1TZ w2_sg1U0]
                  Data.Functor.Sum.$w$cgmapMo
                      $dData_sg1TG $dData1_sg1TH w_sg1TY w1_sg1TZ w2_sg1U0; } in
        let {
          sat_sg1TX [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> m (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dData_sg1TG $dData1_sg1TH] \r [w_sg1TU w1_sg1TV w2_sg1TW]
                  Data.Functor.Sum.$w$cgmapMp
                      $dData_sg1TG $dData1_sg1TH w_sg1TU w1_sg1TV w2_sg1TW; } in
        let {
          sat_sg1TT [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> m (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dData_sg1TG $dData1_sg1TH] \r [w_sg1TQ w1_sg1TR w2_sg1TS]
                  Data.Functor.Sum.$w$cgmapM
                      $dData_sg1TG $dData1_sg1TH w_sg1TQ w1_sg1TR w2_sg1TS; } in
        let {
          sat_sg1TP [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> u
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgmapQi
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TO [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ -> [u]
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgmapQ
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TN [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> r
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgmapQr
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TM [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> r
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum3
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B4
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TL [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum4
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TK [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgunfold
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TJ [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ
               -> c (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF
               $dData_sg1TG
               $dData1_sg1TH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Sum.$fDataSum_$cgfoldl
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF
                      $dData_sg1TG
                      $dData1_sg1TH
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_sg1TI [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Functor.Sum.Sum f_XfWUr g_XfWYN a_XfWYQ)
          [LclId] =
              [$dTypeable_sg1TC
               $dTypeable1_sg1TD
               $dTypeable2_sg1TE
               $dTypeable3_sg1TF] \u []
                  Data.Functor.Sum.$w$cp1Data
                      $dTypeable_sg1TC
                      $dTypeable1_sg1TD
                      $dTypeable2_sg1TE
                      $dTypeable3_sg1TF;
        } in 
          Data.Data.C:Data [sat_sg1TI
                            sat_sg1TJ
                            sat_sg1TK
                            lvl4_rfXPs
                            lvl5_rfXPt
                            lvl6_rfXPu
                            lvl7_rfXPv
                            sat_sg1TL
                            sat_sg1TM
                            sat_sg1TN
                            sat_sg1TO
                            sat_sg1TP
                            sat_sg1TT
                            sat_sg1TX
                            sat_sg1U1];

Data.Functor.Sum.InL
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     f a -> Data.Functor.Sum.Sum f g a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Sum.InL [eta_B1];

Data.Functor.Sum.InR
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     g a -> Data.Functor.Sum.Sum f g a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Sum.InR [eta_B1];

