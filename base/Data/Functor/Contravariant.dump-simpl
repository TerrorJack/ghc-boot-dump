
==================== Tidy Core ====================
2018-03-16 16:12:13.055247979 UTC

Result size of Tidy Core
  = {terms: 1,731, types: 3,723, coercions: 1,185, joins: 0/28}

-- RHS size: {terms: 6, types: 27, coercions: 0, joins: 0/0}
contramap
  :: forall (f :: * -> *).
     Contravariant f =>
     forall a b. (a -> b) -> f b -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 RULES: Built in rule for contramap: "Class op contramap"]
contramap
  = \ (@ (f_agiFl :: * -> *)) (v_B1 :: Contravariant f_agiFl) ->
      case v_B1 of v_B1
      { Data.Functor.Contravariant.C:Contravariant v_B2 v_B3 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 27, coercions: 0, joins: 0/0}
>$
  :: forall (f :: * -> *).
     Contravariant f =>
     forall b a. b -> f b -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),U(A,U)>,
 RULES: Built in rule for >$: "Class op >$"]
>$
  = \ (@ (f_agiFl :: * -> *)) (v_B1 :: Contravariant f_agiFl) ->
      case v_B1 of v_B1
      { Data.Functor.Contravariant.C:Contravariant v_B2 v_B3 ->
      v_B3
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Op3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Contravariant.$tc'Op3 = "'Op"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Op2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Contravariant.$tc'Op2
  = GHC.Types.TrNameS Data.Functor.Contravariant.$tc'Op3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcOp2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Contravariant.$tcOp2 = "Op"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcOp1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Contravariant.$tcOp1
  = GHC.Types.TrNameS Data.Functor.Contravariant.$tcOp2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Equivalence3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Functor.Contravariant.$tc'Equivalence3 = "'Equivalence"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Equivalence2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Contravariant.$tc'Equivalence2
  = GHC.Types.TrNameS Data.Functor.Contravariant.$tc'Equivalence3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcEquivalence2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Functor.Contravariant.$tcEquivalence2 = "Equivalence"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcEquivalence1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Contravariant.$tcEquivalence1
  = GHC.Types.TrNameS Data.Functor.Contravariant.$tcEquivalence2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Comparison3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Functor.Contravariant.$tc'Comparison3 = "'Comparison"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Comparison2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Contravariant.$tc'Comparison2
  = GHC.Types.TrNameS Data.Functor.Contravariant.$tc'Comparison3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcComparison2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Functor.Contravariant.$tcComparison2 = "Comparison"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcComparison1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Contravariant.$tcComparison1
  = GHC.Types.TrNameS Data.Functor.Contravariant.$tcComparison2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Predicate3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Functor.Contravariant.$tc'Predicate3 = "'Predicate"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Predicate2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Contravariant.$tc'Predicate2
  = GHC.Types.TrNameS Data.Functor.Contravariant.$tc'Predicate3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcPredicate2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Functor.Contravariant.$tcPredicate2 = "Predicate"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcPredicate1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Contravariant.$tcPredicate1
  = GHC.Types.TrNameS Data.Functor.Contravariant.$tcPredicate2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcContravariant3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Functor.Contravariant.$tcContravariant3 = "Contravariant"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcContravariant2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Contravariant.$tcContravariant2
  = GHC.Types.TrNameS Data.Functor.Contravariant.$tcContravariant3

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep_rgjLa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep_rgjLa = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep1_rgjLb :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep1_rgjLb
  = GHC.Types.:
      @ GHC.Types.KindRep $krep_rgjLa (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2_rgjLc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep2_rgjLc = GHC.Types.KindRepVar 1#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3_rgjLd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep3_rgjLd = GHC.Types.KindRepFun $krep2_rgjLc $krep_rgjLa

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep4_rgjLe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep4_rgjLe
  = GHC.Types.:
      @ GHC.Types.KindRep $krep2_rgjLc (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep5_rgjLf :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep5_rgjLf
  = GHC.Types.: @ GHC.Types.KindRep $krep_rgjLa $krep4_rgjLe

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep6_rgjLg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep6_rgjLg
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcBool (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7_rgjLh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep7_rgjLh = GHC.Types.KindRepFun $krep_rgjLa $krep6_rgjLg

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8_rgjLi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep8_rgjLi = GHC.Types.KindRepFun $krep_rgjLa $krep7_rgjLh

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep9_rgjLj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep9_rgjLj
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcOrdering (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10_rgjLk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep10_rgjLk = GHC.Types.KindRepFun $krep_rgjLa $krep9_rgjLj

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep11_rgjLl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep11_rgjLl = GHC.Types.KindRepFun $krep_rgjLa $krep10_rgjLk

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep12_rgjLm :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep12_rgjLm
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcContravariant1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Contravariant.$tcContravariant1
  = GHC.Types.KindRepFun GHC.Types.krep$*Arr* $krep12_rgjLm

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 0}]
Data.Functor.Contravariant.$trModule2
  = "Data.Functor.Contravariant"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Contravariant.$trModule1
  = GHC.Types.TrNameS Data.Functor.Contravariant.$trModule2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Contravariant.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Contravariant.$trModule3
  = GHC.Types.TrNameS Data.Functor.Contravariant.$trModule4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Functor.Contravariant.$trModule
  = GHC.Types.Module
      Data.Functor.Contravariant.$trModule3
      Data.Functor.Contravariant.$trModule1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcContravariant :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Contravariant.$tcContravariant
  = GHC.Types.TyCon
      1944710495430526909##
      15571985404928937498##
      Data.Functor.Contravariant.$trModule
      Data.Functor.Contravariant.$tcContravariant2
      0#
      Data.Functor.Contravariant.$tcContravariant1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcPredicate :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Contravariant.$tcPredicate
  = GHC.Types.TyCon
      9927645946720114643##
      17478425232619398566##
      Data.Functor.Contravariant.$trModule
      Data.Functor.Contravariant.$tcPredicate1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep13_rgjLn :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep13_rgjLn
  = GHC.Types.KindRepTyConApp
      Data.Functor.Contravariant.$tcPredicate $krep1_rgjLb

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Predicate1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Contravariant.$tc'Predicate1
  = GHC.Types.KindRepFun $krep7_rgjLh $krep13_rgjLn

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Predicate :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Contravariant.$tc'Predicate
  = GHC.Types.TyCon
      10560326927625189840##
      8988710799443424590##
      Data.Functor.Contravariant.$trModule
      Data.Functor.Contravariant.$tc'Predicate2
      1#
      Data.Functor.Contravariant.$tc'Predicate1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcComparison :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Contravariant.$tcComparison
  = GHC.Types.TyCon
      8128667979445988110##
      9034904213662261762##
      Data.Functor.Contravariant.$trModule
      Data.Functor.Contravariant.$tcComparison1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep14_rgjLo :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep14_rgjLo
  = GHC.Types.KindRepTyConApp
      Data.Functor.Contravariant.$tcComparison $krep1_rgjLb

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Comparison1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Contravariant.$tc'Comparison1
  = GHC.Types.KindRepFun $krep11_rgjLl $krep14_rgjLo

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Comparison :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Contravariant.$tc'Comparison
  = GHC.Types.TyCon
      11047345948274903716##
      12707949450550295743##
      Data.Functor.Contravariant.$trModule
      Data.Functor.Contravariant.$tc'Comparison2
      1#
      Data.Functor.Contravariant.$tc'Comparison1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcEquivalence :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Contravariant.$tcEquivalence
  = GHC.Types.TyCon
      9646573079009549553##
      12303965936368510845##
      Data.Functor.Contravariant.$trModule
      Data.Functor.Contravariant.$tcEquivalence1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep15_rgjLp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep15_rgjLp
  = GHC.Types.KindRepTyConApp
      Data.Functor.Contravariant.$tcEquivalence $krep1_rgjLb

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Equivalence1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Contravariant.$tc'Equivalence1
  = GHC.Types.KindRepFun $krep8_rgjLi $krep15_rgjLp

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Equivalence :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Contravariant.$tc'Equivalence
  = GHC.Types.TyCon
      5667737350508967909##
      15093804341312440267##
      Data.Functor.Contravariant.$trModule
      Data.Functor.Contravariant.$tc'Equivalence2
      1#
      Data.Functor.Contravariant.$tc'Equivalence1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tcOp :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Contravariant.$tcOp
  = GHC.Types.TyCon
      13209106975460307324##
      7546944290236364550##
      Data.Functor.Contravariant.$trModule
      Data.Functor.Contravariant.$tcOp1
      0#
      GHC.Types.krep$*->*->*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep16_rgjLq :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep16_rgjLq
  = GHC.Types.KindRepTyConApp
      Data.Functor.Contravariant.$tcOp $krep5_rgjLf

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Op1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Contravariant.$tc'Op1
  = GHC.Types.KindRepFun $krep3_rgjLd $krep16_rgjLq

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$tc'Op :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Contravariant.$tc'Op
  = GHC.Types.TyCon
      12479862397628491530##
      1381176546464080972##
      Data.Functor.Contravariant.$trModule
      Data.Functor.Contravariant.$tc'Op2
      2#
      Data.Functor.Contravariant.$tc'Op1

-- RHS size: {terms: 12, types: 7, coercions: 2, joins: 0/0}
Data.Functor.Contravariant.comparisonEquivalence1
  :: forall a. Comparison a -> a -> a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agiPX)
                 (ds_dgjnG [Occ=Once] :: Comparison a_agiPX)
                 (a1_agiHj [Occ=Once] :: a_agiPX)
                 (b_agiHk [Occ=Once] :: a_agiPX) ->
                 case (ds_dgjnG
                       `cast` (Data.Functor.Contravariant.N:Comparison[0] <a_agiPX>_R
                               :: (Comparison a_agiPX :: *)
                                  ~R# (a_agiPX -> a_agiPX -> Ordering :: *)))
                        a1_agiHj b_agiHk
                 of {
                   __DEFAULT -> GHC.Types.False;
                   EQ -> GHC.Types.True
                 }}]
Data.Functor.Contravariant.comparisonEquivalence1
  = \ (@ a_agiPX)
      (ds_dgjnG :: Comparison a_agiPX)
      (a1_agiHj :: a_agiPX)
      (b_agiHk :: a_agiPX) ->
      case (ds_dgjnG
            `cast` (Data.Functor.Contravariant.N:Comparison[0] <a_agiPX>_R
                    :: (Comparison a_agiPX :: *)
                       ~R# (a_agiPX -> a_agiPX -> Ordering :: *)))
             a1_agiHj b_agiHk
      of {
        __DEFAULT -> GHC.Types.False;
        EQ -> GHC.Types.True
      }

-- RHS size: {terms: 1, types: 0, coercions: 9, joins: 0/0}
comparisonEquivalence :: forall a. Comparison a -> Equivalence a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Contravariant.comparisonEquivalence1
               `cast` (forall (a :: <*>_N).
                       <Comparison a>_R
                       ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0] <a>_R)
                       :: (forall a. Comparison a -> a -> a -> Bool :: *)
                          ~R# (forall a. Comparison a -> Equivalence a :: *))}]
comparisonEquivalence
  = Data.Functor.Contravariant.comparisonEquivalence1
    `cast` (forall (a :: <*>_N).
            <Comparison a>_R
            ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0] <a>_R)
            :: (forall a. Comparison a -> a -> a -> Bool :: *)
               ~R# (forall a. Comparison a -> Equivalence a :: *))

-- RHS size: {terms: 1, types: 0, coercions: 9, joins: 0/0}
defaultEquivalence :: forall a. Eq a => Equivalence a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= ==
               `cast` (forall (a :: <*>_N).
                       <Eq a>_R
                       ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0] <a>_R)
                       :: (forall a. Eq a => a -> a -> Bool :: *)
                          ~R# (forall a. Eq a => Equivalence a :: *))}]
defaultEquivalence
  = ==
    `cast` (forall (a :: <*>_N).
            <Eq a>_R
            ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0] <a>_R)
            :: (forall a. Eq a => a -> a -> Bool :: *)
               ~R# (forall a. Eq a => Equivalence a :: *))

-- RHS size: {terms: 1, types: 0, coercions: 9, joins: 0/0}
defaultComparison :: forall a. Ord a => Comparison a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= compare
               `cast` (forall (a :: <*>_N).
                       <Ord a>_R
                       ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a>_R)
                       :: (forall a. Ord a => a -> a -> Ordering :: *)
                          ~R# (forall a. Ord a => Comparison a :: *))}]
defaultComparison
  = compare
    `cast` (forall (a :: <*>_N).
            <Ord a>_R
            ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a>_R)
            :: (forall a. Ord a => a -> a -> Ordering :: *)
               ~R# (forall a. Ord a => Comparison a :: *))

-- RHS size: {terms: 10, types: 17, coercions: 0, joins: 0/0}
>$$<
  :: forall (f :: * -> *) b a.
     Contravariant f =>
     f b -> (a -> b) -> f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_agiQj :: * -> *))
                 (@ b_agiQk)
                 (@ a_agiQl)
                 ($dContravariant_agiQn [Occ=Once] :: Contravariant f_agiQj)
                 (eta_X7v [Occ=Once] :: f_agiQj b_agiQk)
                 (eta1_XeZ [Occ=Once] :: a_agiQl -> b_agiQk) ->
                 contramap
                   @ f_agiQj
                   $dContravariant_agiQn
                   @ a_agiQl
                   @ b_agiQk
                   eta1_XeZ
                   eta_X7v}]
>$$<
  = \ (@ (f_agiQj :: * -> *))
      (@ b_agiQk)
      (@ a_agiQl)
      ($dContravariant_agiQn :: Contravariant f_agiQj)
      (eta_X7v :: f_agiQj b_agiQk)
      (eta1_XeZ :: a_agiQl -> b_agiQk) ->
      contramap
        @ f_agiQj
        $dContravariant_agiQn
        @ a_agiQl
        @ b_agiQk
        eta1_XeZ
        eta_X7v

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
>$<
  :: forall (f :: * -> *) a b.
     Contravariant f =>
     (a -> b) -> f b -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_agiQw :: * -> *))
                 (@ a_agiQx)
                 (@ b_agiQy)
                 ($dContravariant_agiQA [Occ=Once] :: Contravariant f_agiQw) ->
                 contramap @ f_agiQw $dContravariant_agiQA @ a_agiQx @ b_agiQy}]
>$<
  = \ (@ (f_agiQw :: * -> *))
      (@ a_agiQx)
      (@ b_agiQy)
      ($dContravariant_agiQA :: Contravariant f_agiQw) ->
      contramap @ f_agiQw $dContravariant_agiQA @ a_agiQx @ b_agiQy

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
phantom
  :: forall (f :: * -> *) a b.
     (Functor f, Contravariant f) =>
     f a -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)))><S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_agiQT :: * -> *))
                 (@ a_agiQU)
                 (@ b_agiQV)
                 ($dFunctor_agiQX [Occ=Once] :: Functor f_agiQT)
                 ($dContravariant_agiQY [Occ=Once] :: Contravariant f_agiQT)
                 (x_agiHh [Occ=Once] :: f_agiQT a_agiQU) ->
                 >$
                   @ f_agiQT
                   $dContravariant_agiQY
                   @ ()
                   @ b_agiQV
                   GHC.Tuple.()
                   (<$
                      @ f_agiQT $dFunctor_agiQX @ () @ a_agiQU GHC.Tuple.() x_agiHh)}]
phantom
  = \ (@ (f_agiQT :: * -> *))
      (@ a_agiQU)
      (@ b_agiQV)
      ($dFunctor_agiQX :: Functor f_agiQT)
      ($dContravariant_agiQY :: Contravariant f_agiQT)
      (x_agiHh :: f_agiQT a_agiQU) ->
      >$
        @ f_agiQT
        $dContravariant_agiQY
        @ ()
        @ b_agiQV
        GHC.Tuple.()
        (<$ @ f_agiQT $dFunctor_agiQX @ () @ a_agiQU GHC.Tuple.() x_agiHh)

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
$< :: forall (f :: * -> *) b a. Contravariant f => f b -> b -> f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_agiQG :: * -> *))
                 (@ b_agiQH)
                 (@ a_agiQI)
                 ($dContravariant_agiQK [Occ=Once] :: Contravariant f_agiQG)
                 (eta_X7s [Occ=Once] :: f_agiQG b_agiQH)
                 (eta1_XeT [Occ=Once] :: b_agiQH) ->
                 >$
                   @ f_agiQG
                   $dContravariant_agiQK
                   @ b_agiQH
                   @ a_agiQI
                   eta1_XeT
                   eta_X7s}]
$<
  = \ (@ (f_agiQG :: * -> *))
      (@ b_agiQH)
      (@ a_agiQI)
      ($dContravariant_agiQK :: Contravariant f_agiQG)
      (eta_X7s :: f_agiQG b_agiQH)
      (eta1_XeT :: b_agiQH) ->
      >$
        @ f_agiQG
        $dContravariant_agiQK
        @ b_agiQH
        @ a_agiQI
        eta1_XeT
        eta_X7s

-- RHS size: {terms: 8, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fContravariantOp1
  :: forall a1 b a2. b -> Op a1 b -> a2 -> a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_XgjeK)
                 (@ b_agj7U)
                 (@ a1_agj7V)
                 (x_X7REz [Occ=Once] :: b_agj7U)
                 (eta_X7k [Occ=Once] :: Op a_XgjeK b_agj7U)
                 _ [Occ=Dead] ->
                 (eta_X7k
                  `cast` (Data.Functor.Contravariant.N:Op[0] <a_XgjeK>_R <b_agj7U>_R
                          :: (Op a_XgjeK b_agj7U :: *) ~R# (b_agj7U -> a_XgjeK :: *)))
                   x_X7REz}]
Data.Functor.Contravariant.$fContravariantOp1
  = \ (@ a_XgjeK)
      (@ b_agj7U)
      (@ a1_agj7V)
      (x_X7REz :: b_agj7U)
      (eta_X7k :: Op a_XgjeK b_agj7U)
      _ [Occ=Dead] ->
      (eta_X7k
       `cast` (Data.Functor.Contravariant.N:Op[0] <a_XgjeK>_R <b_agj7U>_R
               :: (Op a_XgjeK b_agj7U :: *) ~R# (b_agj7U -> a_XgjeK :: *)))
        x_X7REz

-- RHS size: {terms: 8, types: 14, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fContravariantOp2
  :: forall a1 a2 b. (a2 -> b) -> Op a1 b -> a2 -> a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agj7w)
                 (@ a1_agj7A)
                 (@ b_agj7B)
                 (f_agiG7 [Occ=Once] :: a1_agj7A -> b_agj7B)
                 (g_agiG8 [Occ=Once] :: Op a_agj7w b_agj7B) ->
                 GHC.Base..
                   @ b_agj7B
                   @ a_agj7w
                   @ a1_agj7A
                   (g_agiG8
                    `cast` (Data.Functor.Contravariant.N:Op[0] <a_agj7w>_R <b_agj7B>_R
                            :: (Op a_agj7w b_agj7B :: *) ~R# (b_agj7B -> a_agj7w :: *)))
                   f_agiG7}]
Data.Functor.Contravariant.$fContravariantOp2
  = \ (@ a_agj7w)
      (@ a1_agj7A)
      (@ b_agj7B)
      (f_agiG7 :: a1_agj7A -> b_agj7B)
      (g_agiG8 :: Op a_agj7w b_agj7B) ->
      GHC.Base..
        @ b_agj7B
        @ a_agj7w
        @ a1_agj7A
        (g_agiG8
         `cast` (Data.Functor.Contravariant.N:Op[0] <a_agj7w>_R <b_agj7B>_R
                 :: (Op a_agj7w b_agj7B :: *) ~R# (b_agj7B -> a_agj7w :: *)))
        f_agiG7

-- RHS size: {terms: 4, types: 6, coercions: 33, joins: 0/0}
Data.Functor.Contravariant.$fContravariantOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Contravariant (Op a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_agiG6) ->
       Data.Functor.Contravariant.C:Contravariant TYPE: Op a_agiG6
                                                  (Data.Functor.Contravariant.$fContravariantOp2
                                                     @ a_agiG6)
                                                  `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                                                          <a1 -> b>_R
                                                          ->_R <Op a_agiG6 b>_R
                                                          ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                                        <a_agiG6>_R <a1>_R)
                                                          :: (forall a1 b.
                                                              (a1 -> b)
                                                              -> Op a_agiG6 b -> a1 -> a_agiG6 :: *)
                                                             ~R# (forall a1 b.
                                                                  (a1 -> b)
                                                                  -> Op a_agiG6 b
                                                                  -> Op a_agiG6 a1 :: *))
                                                  (Data.Functor.Contravariant.$fContravariantOp1
                                                     @ a_agiG6)
                                                  `cast` (forall (b :: <*>_N) (a1 :: <*>_N).
                                                          <b>_R
                                                          ->_R <Op a_agiG6 b>_R
                                                          ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                                        <a_agiG6>_R <a1>_R)
                                                          :: (forall b a1.
                                                              b
                                                              -> Op a_agiG6 b -> a1 -> a_agiG6 :: *)
                                                             ~R# (forall b a1.
                                                                  b
                                                                  -> Op a_agiG6 b
                                                                  -> Op a_agiG6 a1 :: *))]
Data.Functor.Contravariant.$fContravariantOp
  = \ (@ a_XgjeJ) ->
      Data.Functor.Contravariant.C:Contravariant
        @ (Op a_XgjeJ)
        ((Data.Functor.Contravariant.$fContravariantOp2 @ a_XgjeJ)
         `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                 <a1 -> b>_R
                 ->_R <Op a_XgjeJ b>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0] <a_XgjeJ>_R <a1>_R)
                 :: (forall a1 b. (a1 -> b) -> Op a_XgjeJ b -> a1 -> a_XgjeJ :: *)
                    ~R# (forall a1 b.
                         (a1 -> b) -> Op a_XgjeJ b -> Op a_XgjeJ a1 :: *)))
        ((Data.Functor.Contravariant.$fContravariantOp1 @ a_XgjeJ)
         `cast` (forall (b :: <*>_N) (a1 :: <*>_N).
                 <b>_R
                 ->_R <Op a_XgjeJ b>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0] <a_XgjeJ>_R <a1>_R)
                 :: (forall b a1. b -> Op a_XgjeJ b -> a1 -> a_XgjeJ :: *)
                    ~R# (forall b a1. b -> Op a_XgjeJ b -> Op a_XgjeJ a1 :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.getOp1 :: forall a b. Op a b -> Op a b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agiMg)
                 (@ b_agiMh)
                 (ds_dgjnS [Occ=Once] :: Op a_agiMg b_agiMh) ->
                 ds_dgjnS}]
Data.Functor.Contravariant.getOp1
  = \ (@ a_agiMg) (@ b_agiMh) (ds_dgjnS :: Op a_agiMg b_agiMh) ->
      ds_dgjnS

-- RHS size: {terms: 1, types: 0, coercions: 13, joins: 0/0}
getOp :: forall a b. Op a b -> b -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Contravariant.getOp1
               `cast` (forall (a :: <*>_N) (b :: <*>_N).
                       <Op a b>_R ->_R Data.Functor.Contravariant.N:Op[0] <a>_R <b>_R
                       :: (forall a b. Op a b -> Op a b :: *)
                          ~R# (forall a b. Op a b -> b -> a :: *))}]
getOp
  = Data.Functor.Contravariant.getOp1
    `cast` (forall (a :: <*>_N) (b :: <*>_N).
            <Op a b>_R ->_R Data.Functor.Contravariant.N:Op[0] <a>_R <b>_R
            :: (forall a b. Op a b -> Op a b :: *)
               ~R# (forall a b. Op a b -> b -> a :: *))

-- RHS size: {terms: 9, types: 9, coercions: 2, joins: 0/0}
Data.Functor.Contravariant.$fContravariantEquivalence1
  :: forall b a. b -> Equivalence b -> a -> a -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),1*C1(C1(U))><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_agj9C)
                 (@ a_agj9D)
                 (x_X7REo :: b_agj9C)
                 (eta_X7a [Occ=Once] :: Equivalence b_agj9C)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 (eta_X7a
                  `cast` (Data.Functor.Contravariant.N:Equivalence[0] <b_agj9C>_R
                          :: (Equivalence b_agj9C :: *)
                             ~R# (b_agj9C -> b_agj9C -> Bool :: *)))
                   x_X7REo x_X7REo}]
Data.Functor.Contravariant.$fContravariantEquivalence1
  = \ (@ b_agj9C)
      (@ a_agj9D)
      (x_X7REo :: b_agj9C)
      (eta_X7a :: Equivalence b_agj9C)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      (eta_X7a
       `cast` (Data.Functor.Contravariant.N:Equivalence[0] <b_agj9C>_R
               :: (Equivalence b_agj9C :: *)
                  ~R# (b_agj9C -> b_agj9C -> Bool :: *)))
        x_X7REo x_X7REo

-- RHS size: {terms: 11, types: 10, coercions: 2, joins: 0/0}
Data.Functor.Contravariant.$fContravariantEquivalence2
  :: forall a b. (a -> b) -> Equivalence b -> a -> a -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agj9p)
                 (@ b_agj9q)
                 (f_agiGh :: a_agj9p -> b_agj9q)
                 (g_agiGi [Occ=Once] :: Equivalence b_agj9q)
                 (x_idog9 [Occ=Once] :: a_agj9p)
                 (y_idoga [Occ=Once] :: a_agj9p) ->
                 (g_agiGi
                  `cast` (Data.Functor.Contravariant.N:Equivalence[0] <b_agj9q>_R
                          :: (Equivalence b_agj9q :: *)
                             ~R# (b_agj9q -> b_agj9q -> Bool :: *)))
                   (f_agiGh x_idog9) (f_agiGh y_idoga)}]
Data.Functor.Contravariant.$fContravariantEquivalence2
  = \ (@ a_agj9p)
      (@ b_agj9q)
      (f_agiGh :: a_agj9p -> b_agj9q)
      (g_agiGi :: Equivalence b_agj9q)
      (x_idog9 :: a_agj9p)
      (y_idoga :: a_agj9p) ->
      (g_agiGi
       `cast` (Data.Functor.Contravariant.N:Equivalence[0] <b_agj9q>_R
               :: (Equivalence b_agj9q :: *)
                  ~R# (b_agj9q -> b_agj9q -> Bool :: *)))
        (f_agiGh x_idog9) (f_agiGh y_idoga)

-- RHS size: {terms: 3, types: 1, coercions: 29, joins: 0/0}
Data.Functor.Contravariant.$fContravariantEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: Contravariant Equivalence
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Contravariant.C:Contravariant TYPE: Equivalence
                                                  Data.Functor.Contravariant.$fContravariantEquivalence2
                                                  `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                                          <a -> b>_R
                                                          ->_R <Equivalence b>_R
                                                          ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0]
                                                                        <a>_R)
                                                          :: (forall a b.
                                                              (a -> b)
                                                              -> Equivalence b
                                                              -> a
                                                              -> a
                                                              -> Bool :: *)
                                                             ~R# (forall a b.
                                                                  (a -> b)
                                                                  -> Equivalence b
                                                                  -> Equivalence a :: *))
                                                  Data.Functor.Contravariant.$fContravariantEquivalence1
                                                  `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                                          <b>_R
                                                          ->_R <Equivalence b>_R
                                                          ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0]
                                                                        <a>_R)
                                                          :: (forall b a.
                                                              b
                                                              -> Equivalence b
                                                              -> a
                                                              -> a
                                                              -> Bool :: *)
                                                             ~R# (forall b a.
                                                                  b
                                                                  -> Equivalence b
                                                                  -> Equivalence a :: *))]
Data.Functor.Contravariant.$fContravariantEquivalence
  = Data.Functor.Contravariant.C:Contravariant
      @ Equivalence
      (Data.Functor.Contravariant.$fContravariantEquivalence2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R
               ->_R <Equivalence b>_R
               ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0] <a>_R)
               :: (forall a b. (a -> b) -> Equivalence b -> a -> a -> Bool :: *)
                  ~R# (forall a b. (a -> b) -> Equivalence b -> Equivalence a :: *)))
      (Data.Functor.Contravariant.$fContravariantEquivalence1
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b>_R
               ->_R <Equivalence b>_R
               ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0] <a>_R)
               :: (forall b a. b -> Equivalence b -> a -> a -> Bool :: *)
                  ~R# (forall b a. b -> Equivalence b -> Equivalence a :: *)))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.getEquivalence1
  :: forall a. Equivalence a -> Equivalence a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agiLz) (ds_dgjnU [Occ=Once] :: Equivalence a_agiLz) ->
                 ds_dgjnU}]
Data.Functor.Contravariant.getEquivalence1
  = \ (@ a_agiLz) (ds_dgjnU :: Equivalence a_agiLz) -> ds_dgjnU

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getEquivalence :: forall a. Equivalence a -> a -> a -> Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Contravariant.getEquivalence1
               `cast` (forall (a :: <*>_N).
                       <Equivalence a>_R
                       ->_R Data.Functor.Contravariant.N:Equivalence[0] <a>_R
                       :: (forall a. Equivalence a -> Equivalence a :: *)
                          ~R# (forall a. Equivalence a -> a -> a -> Bool :: *))}]
getEquivalence
  = Data.Functor.Contravariant.getEquivalence1
    `cast` (forall (a :: <*>_N).
            <Equivalence a>_R
            ->_R Data.Functor.Contravariant.N:Equivalence[0] <a>_R
            :: (forall a. Equivalence a -> Equivalence a :: *)
               ~R# (forall a. Equivalence a -> a -> a -> Bool :: *))

-- RHS size: {terms: 9, types: 9, coercions: 2, joins: 0/0}
Data.Functor.Contravariant.$fContravariantComparison1
  :: forall b a. b -> Comparison b -> a -> a -> Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),1*C1(C1(U))><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_agja1)
                 (@ a_agja2)
                 (x_X7REe :: b_agja1)
                 (eta_B3 [Occ=Once] :: Comparison b_agja1)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 (eta_B3
                  `cast` (Data.Functor.Contravariant.N:Comparison[0] <b_agja1>_R
                          :: (Comparison b_agja1 :: *)
                             ~R# (b_agja1 -> b_agja1 -> Ordering :: *)))
                   x_X7REe x_X7REe}]
Data.Functor.Contravariant.$fContravariantComparison1
  = \ (@ b_agja1)
      (@ a_agja2)
      (x_X7REe :: b_agja1)
      (eta_B3 :: Comparison b_agja1)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      (eta_B3
       `cast` (Data.Functor.Contravariant.N:Comparison[0] <b_agja1>_R
               :: (Comparison b_agja1 :: *)
                  ~R# (b_agja1 -> b_agja1 -> Ordering :: *)))
        x_X7REe x_X7REe

-- RHS size: {terms: 11, types: 10, coercions: 2, joins: 0/0}
Data.Functor.Contravariant.$fContravariantComparison2
  :: forall a b. (a -> b) -> Comparison b -> a -> a -> Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agj9O)
                 (@ b_agj9P)
                 (f_agiGj :: a_agj9O -> b_agj9P)
                 (g_agiGk [Occ=Once] :: Comparison b_agj9P)
                 (x_idog9 [Occ=Once] :: a_agj9O)
                 (y_idoga [Occ=Once] :: a_agj9O) ->
                 (g_agiGk
                  `cast` (Data.Functor.Contravariant.N:Comparison[0] <b_agj9P>_R
                          :: (Comparison b_agj9P :: *)
                             ~R# (b_agj9P -> b_agj9P -> Ordering :: *)))
                   (f_agiGj x_idog9) (f_agiGj y_idoga)}]
Data.Functor.Contravariant.$fContravariantComparison2
  = \ (@ a_agj9O)
      (@ b_agj9P)
      (f_agiGj :: a_agj9O -> b_agj9P)
      (g_agiGk :: Comparison b_agj9P)
      (x_idog9 :: a_agj9O)
      (y_idoga :: a_agj9O) ->
      (g_agiGk
       `cast` (Data.Functor.Contravariant.N:Comparison[0] <b_agj9P>_R
               :: (Comparison b_agj9P :: *)
                  ~R# (b_agj9P -> b_agj9P -> Ordering :: *)))
        (f_agiGj x_idog9) (f_agiGj y_idoga)

-- RHS size: {terms: 3, types: 1, coercions: 29, joins: 0/0}
Data.Functor.Contravariant.$fContravariantComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: Contravariant Comparison
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Contravariant.C:Contravariant TYPE: Comparison
                                                  Data.Functor.Contravariant.$fContravariantComparison2
                                                  `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                                          <a -> b>_R
                                                          ->_R <Comparison b>_R
                                                          ->_R Sym (Data.Functor.Contravariant.N:Comparison[0]
                                                                        <a>_R)
                                                          :: (forall a b.
                                                              (a -> b)
                                                              -> Comparison b
                                                              -> a
                                                              -> a
                                                              -> Ordering :: *)
                                                             ~R# (forall a b.
                                                                  (a -> b)
                                                                  -> Comparison b
                                                                  -> Comparison a :: *))
                                                  Data.Functor.Contravariant.$fContravariantComparison1
                                                  `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                                          <b>_R
                                                          ->_R <Comparison b>_R
                                                          ->_R Sym (Data.Functor.Contravariant.N:Comparison[0]
                                                                        <a>_R)
                                                          :: (forall b a.
                                                              b
                                                              -> Comparison b
                                                              -> a
                                                              -> a
                                                              -> Ordering :: *)
                                                             ~R# (forall b a.
                                                                  b
                                                                  -> Comparison b
                                                                  -> Comparison a :: *))]
Data.Functor.Contravariant.$fContravariantComparison
  = Data.Functor.Contravariant.C:Contravariant
      @ Comparison
      (Data.Functor.Contravariant.$fContravariantComparison2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R
               ->_R <Comparison b>_R
               ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a>_R)
               :: (forall a b.
                   (a -> b) -> Comparison b -> a -> a -> Ordering :: *)
                  ~R# (forall a b. (a -> b) -> Comparison b -> Comparison a :: *)))
      (Data.Functor.Contravariant.$fContravariantComparison1
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b>_R
               ->_R <Comparison b>_R
               ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a>_R)
               :: (forall b a. b -> Comparison b -> a -> a -> Ordering :: *)
                  ~R# (forall b a. b -> Comparison b -> Comparison a :: *)))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.getComparison1
  :: forall a. Comparison a -> Comparison a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agiL1) (ds_dgjnW [Occ=Once] :: Comparison a_agiL1) ->
                 ds_dgjnW}]
Data.Functor.Contravariant.getComparison1
  = \ (@ a_agiL1) (ds_dgjnW :: Comparison a_agiL1) -> ds_dgjnW

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getComparison :: forall a. Comparison a -> a -> a -> Ordering
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Contravariant.getComparison1
               `cast` (forall (a :: <*>_N).
                       <Comparison a>_R
                       ->_R Data.Functor.Contravariant.N:Comparison[0] <a>_R
                       :: (forall a. Comparison a -> Comparison a :: *)
                          ~R# (forall a. Comparison a -> a -> a -> Ordering :: *))}]
getComparison
  = Data.Functor.Contravariant.getComparison1
    `cast` (forall (a :: <*>_N).
            <Comparison a>_R
            ->_R Data.Functor.Contravariant.N:Comparison[0] <a>_R
            :: (forall a. Comparison a -> Comparison a :: *)
               ~R# (forall a. Comparison a -> a -> a -> Ordering :: *))

-- RHS size: {terms: 7, types: 8, coercions: 2, joins: 0/0}
Data.Functor.Contravariant.$fContravariantPredicate1
  :: forall b a. b -> Predicate b -> a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_agjbm)
                 (@ a_agjbn)
                 (x_X7RE4 [Occ=Once] :: b_agjbm)
                 (eta_B2 [Occ=Once] :: Predicate b_agjbm)
                 _ [Occ=Dead] ->
                 (eta_B2
                  `cast` (Data.Functor.Contravariant.N:Predicate[0] <b_agjbm>_R
                          :: (Predicate b_agjbm :: *) ~R# (b_agjbm -> Bool :: *)))
                   x_X7RE4}]
Data.Functor.Contravariant.$fContravariantPredicate1
  = \ (@ b_agjbm)
      (@ a_agjbn)
      (x_X7RE4 :: b_agjbm)
      (eta_B2 :: Predicate b_agjbm)
      _ [Occ=Dead] ->
      (eta_B2
       `cast` (Data.Functor.Contravariant.N:Predicate[0] <b_agjbm>_R
               :: (Predicate b_agjbm :: *) ~R# (b_agjbm -> Bool :: *)))
        x_X7RE4

-- RHS size: {terms: 7, types: 11, coercions: 2, joins: 0/0}
Data.Functor.Contravariant.$fContravariantPredicate2
  :: forall a b. (a -> b) -> Predicate b -> a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agjb2)
                 (@ b_agjb3)
                 (f_agiGq [Occ=Once] :: a_agjb2 -> b_agjb3)
                 (g_agiGr [Occ=Once] :: Predicate b_agjb3) ->
                 GHC.Base..
                   @ b_agjb3
                   @ Bool
                   @ a_agjb2
                   (g_agiGr
                    `cast` (Data.Functor.Contravariant.N:Predicate[0] <b_agjb3>_R
                            :: (Predicate b_agjb3 :: *) ~R# (b_agjb3 -> Bool :: *)))
                   f_agiGq}]
Data.Functor.Contravariant.$fContravariantPredicate2
  = \ (@ a_agjb2)
      (@ b_agjb3)
      (f_agiGq :: a_agjb2 -> b_agjb3)
      (g_agiGr :: Predicate b_agjb3) ->
      GHC.Base..
        @ b_agjb3
        @ Bool
        @ a_agjb2
        (g_agiGr
         `cast` (Data.Functor.Contravariant.N:Predicate[0] <b_agjb3>_R
                 :: (Predicate b_agjb3 :: *) ~R# (b_agjb3 -> Bool :: *)))
        f_agiGq

-- RHS size: {terms: 3, types: 1, coercions: 29, joins: 0/0}
Data.Functor.Contravariant.$fContravariantPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: Contravariant Predicate
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Contravariant.C:Contravariant TYPE: Predicate
                                                  Data.Functor.Contravariant.$fContravariantPredicate2
                                                  `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                                          <a -> b>_R
                                                          ->_R <Predicate b>_R
                                                          ->_R Sym (Data.Functor.Contravariant.N:Predicate[0]
                                                                        <a>_R)
                                                          :: (forall a b.
                                                              (a -> b)
                                                              -> Predicate b -> a -> Bool :: *)
                                                             ~R# (forall a b.
                                                                  (a -> b)
                                                                  -> Predicate b
                                                                  -> Predicate a :: *))
                                                  Data.Functor.Contravariant.$fContravariantPredicate1
                                                  `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                                          <b>_R
                                                          ->_R <Predicate b>_R
                                                          ->_R Sym (Data.Functor.Contravariant.N:Predicate[0]
                                                                        <a>_R)
                                                          :: (forall b a.
                                                              b -> Predicate b -> a -> Bool :: *)
                                                             ~R# (forall b a.
                                                                  b
                                                                  -> Predicate b
                                                                  -> Predicate a :: *))]
Data.Functor.Contravariant.$fContravariantPredicate
  = Data.Functor.Contravariant.C:Contravariant
      @ Predicate
      (Data.Functor.Contravariant.$fContravariantPredicate2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R
               ->_R <Predicate b>_R
               ->_R Sym (Data.Functor.Contravariant.N:Predicate[0] <a>_R)
               :: (forall a b. (a -> b) -> Predicate b -> a -> Bool :: *)
                  ~R# (forall a b. (a -> b) -> Predicate b -> Predicate a :: *)))
      (Data.Functor.Contravariant.$fContravariantPredicate1
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b>_R
               ->_R <Predicate b>_R
               ->_R Sym (Data.Functor.Contravariant.N:Predicate[0] <a>_R)
               :: (forall b a. b -> Predicate b -> a -> Bool :: *)
                  ~R# (forall b a. b -> Predicate b -> Predicate a :: *)))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.getPredicate1
  :: forall a. Predicate a -> Predicate a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agiKj) (ds_dgjnY [Occ=Once] :: Predicate a_agiKj) ->
                 ds_dgjnY}]
Data.Functor.Contravariant.getPredicate1
  = \ (@ a_agiKj) (ds_dgjnY :: Predicate a_agiKj) -> ds_dgjnY

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getPredicate :: forall a. Predicate a -> a -> Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Contravariant.getPredicate1
               `cast` (forall (a :: <*>_N).
                       <Predicate a>_R
                       ->_R Data.Functor.Contravariant.N:Predicate[0] <a>_R
                       :: (forall a. Predicate a -> Predicate a :: *)
                          ~R# (forall a. Predicate a -> a -> Bool :: *))}]
getPredicate
  = Data.Functor.Contravariant.getPredicate1
    `cast` (forall (a :: <*>_N).
            <Predicate a>_R
            ->_R Data.Functor.Contravariant.N:Predicate[0] <a>_R
            :: (forall a. Predicate a -> Predicate a :: *)
               ~R# (forall a. Predicate a -> a -> Bool :: *))

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantV1_$c>$
  :: forall b a. b -> V1 b -> V1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_agjgC)
                 (@ a_agjgD)
                 _ [Occ=Dead]
                 (x1_agiH1 [Occ=Once] :: V1 b_agjgC) ->
                 case x1_agiH1 of { }}]
Data.Functor.Contravariant.$fContravariantV1_$c>$
  = \ (@ b_agjgC)
      (@ a_agjgD)
      _ [Occ=Dead]
      (x1_agiH1 :: V1 b_agjgC) ->
      case x1_agiH1 of { }

-- RHS size: {terms: 5, types: 12, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantU1_$c>$
  :: forall b a. b -> U1 b -> U1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_agjgi) (@ a_agjgj) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Generics.U1 @ * @ a_agjgj}]
Data.Functor.Contravariant.$fContravariantU1_$c>$
  = \ (@ b_agjgi) (@ a_agjgj) _ [Occ=Dead] _ [Occ=Dead] ->
      GHC.Generics.U1 @ * @ a_agjgj

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantK2
  :: forall b c i. b -> K1 i c b -> K1 i c b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_agjfY)
                 (@ c_Xgjm6)
                 (@ i_Xgjm4)
                 _ [Occ=Dead]
                 (ds_XgjyK [Occ=Once] :: K1 i_Xgjm4 c_Xgjm6 b_agjfY) ->
                 ds_XgjyK}]
Data.Functor.Contravariant.$fContravariantK2
  = \ (@ b_agjfY)
      (@ c_Xgjm6)
      (@ i_Xgjm4)
      _ [Occ=Dead]
      (ds_XgjyK :: K1 i_Xgjm4 c_Xgjm6 b_agjfY) ->
      ds_XgjyK

-- RHS size: {terms: 23, types: 47, coercions: 0, joins: 0/1}
Data.Functor.Contravariant.$fContravariant:*:_$c>$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Contravariant f, Contravariant g) =>
     forall b a. b -> (:*:) f g b -> (:*:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sgjEr :: * -> *))
                 (@ (g_sgjEs :: * -> *))
                 (w_sgjEt [Occ=Once] :: Contravariant f_sgjEr)
                 (w1_sgjEu [Occ=Once] :: Contravariant g_sgjEs)
                 (@ b_sgjEv)
                 (@ a_sgjEw)
                 (w2_sgjEx :: b_sgjEv)
                 (w3_sgjEy [Occ=Once!] :: (:*:) f_sgjEr g_sgjEs b_sgjEv) ->
                 case w3_sgjEy of { :*: ww1_sgjEB [Occ=Once] ww2_sgjEC [Occ=Once] ->
                 let {
                   f1_sgjxi :: a_sgjEw -> b_sgjEv
                   [LclId,
                    Arity=1,
                    Str=<L,A>,
                    Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                            WorkFree=True, Expandable=True,
                            Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                            Tmpl= \ _ [Occ=Dead] -> w2_sgjEx}]
                   f1_sgjxi = \ _ [Occ=Dead] -> w2_sgjEx } in
                 GHC.Generics.:*:
                   @ *
                   @ f_sgjEr
                   @ g_sgjEs
                   @ a_sgjEw
                   (contramap
                      @ f_sgjEr w_sgjEt @ a_sgjEw @ b_sgjEv f1_sgjxi ww1_sgjEB)
                   (contramap
                      @ g_sgjEs w1_sgjEu @ a_sgjEw @ b_sgjEv f1_sgjxi ww2_sgjEC)
                 }}]
Data.Functor.Contravariant.$fContravariant:*:_$c>$
  = \ (@ (f_sgjEr :: * -> *))
      (@ (g_sgjEs :: * -> *))
      (w_sgjEt :: Contravariant f_sgjEr)
      (w1_sgjEu :: Contravariant g_sgjEs)
      (@ b_sgjEv)
      (@ a_sgjEw)
      (w2_sgjEx :: b_sgjEv)
      (w3_sgjEy :: (:*:) f_sgjEr g_sgjEs b_sgjEv) ->
      case w3_sgjEy of { :*: ww1_sgjEB ww2_sgjEC ->
      let {
        f1_sgjxi :: a_sgjEw -> b_sgjEv
        [LclId,
         Arity=1,
         Str=<L,A>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                 Tmpl= \ _ [Occ=Dead] -> w2_sgjEx}]
        f1_sgjxi = \ _ [Occ=Dead] -> w2_sgjEx } in
      GHC.Generics.:*:
        @ *
        @ f_sgjEr
        @ g_sgjEs
        @ a_sgjEw
        (contramap
           @ f_sgjEr w_sgjEt @ a_sgjEw @ b_sgjEv f1_sgjxi ww1_sgjEB)
        (contramap
           @ g_sgjEs w1_sgjEu @ a_sgjEw @ b_sgjEv f1_sgjxi ww2_sgjEC)
      }

-- RHS size: {terms: 15, types: 34, coercions: 8, joins: 0/0}
Data.Functor.Contravariant.$fContravariant:.:1
  :: forall (f :: * -> *) (g :: * -> *).
     (Functor f, Contravariant g) =>
     forall b a. b -> (:.:) f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_XgjkR :: * -> *))
                 (@ (g_XgjkT :: * -> *))
                 ($dFunctor_XgjkV [Occ=Once] :: Functor f_XgjkR)
                 ($dContravariant_XgjkX [Occ=Once] :: Contravariant g_XgjkT)
                 (@ b_agjf1)
                 (@ a_agjf2)
                 (x_X7RDL [Occ=OnceL] :: b_agjf1)
                 (eta_X6v [Occ=Once] :: (:.:) f_XgjkR g_XgjkT b_agjf1) ->
                 fmap
                   @ f_XgjkR
                   $dFunctor_XgjkV
                   @ (g_XgjkT b_agjf1)
                   @ (g_XgjkT a_agjf2)
                   (contramap
                      @ g_XgjkT
                      $dContravariant_XgjkX
                      @ a_agjf2
                      @ b_agjf1
                      (\ _ [Occ=Dead] -> x_X7RDL))
                   (eta_X6v
                    `cast` (GHC.Generics.N::.:[0]
                                <*>_N <*>_N <f_XgjkR>_R <g_XgjkT>_N <b_agjf1>_N
                            :: ((:.:) f_XgjkR g_XgjkT b_agjf1 :: *)
                               ~R# (f_XgjkR (g_XgjkT b_agjf1) :: *)))}]
Data.Functor.Contravariant.$fContravariant:.:1
  = \ (@ (f_XgjkR :: * -> *))
      (@ (g_XgjkT :: * -> *))
      ($dFunctor_XgjkV :: Functor f_XgjkR)
      ($dContravariant_XgjkX :: Contravariant g_XgjkT)
      (@ b_agjf1)
      (@ a_agjf2)
      (x_X7RDL :: b_agjf1)
      (eta_X6v :: (:.:) f_XgjkR g_XgjkT b_agjf1) ->
      fmap
        @ f_XgjkR
        $dFunctor_XgjkV
        @ (g_XgjkT b_agjf1)
        @ (g_XgjkT a_agjf2)
        (contramap
           @ g_XgjkT
           $dContravariant_XgjkX
           @ a_agjf2
           @ b_agjf1
           (\ _ [Occ=Dead] -> x_X7RDL))
        (eta_X6v
         `cast` (GHC.Generics.N::.:[0]
                     <*>_N <*>_N <f_XgjkR>_R <g_XgjkT>_N <b_agjf1>_N
                 :: ((:.:) f_XgjkR g_XgjkT b_agjf1 :: *)
                    ~R# (f_XgjkR (g_XgjkT b_agjf1) :: *)))

-- RHS size: {terms: 23, types: 47, coercions: 0, joins: 0/1}
Data.Functor.Contravariant.$fContravariantProduct_$c>$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Contravariant f, Contravariant g) =>
     forall b a. b -> Product f g b -> Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sgjEI :: * -> *))
                 (@ (g_sgjEJ :: * -> *))
                 (w_sgjEK [Occ=Once] :: Contravariant f_sgjEI)
                 (w1_sgjEL [Occ=Once] :: Contravariant g_sgjEJ)
                 (@ b_sgjEM)
                 (@ a_sgjEN)
                 (w2_sgjEO :: b_sgjEM)
                 (w3_sgjEP [Occ=Once!] :: Product f_sgjEI g_sgjEJ b_sgjEM) ->
                 case w3_sgjEP of
                 { Pair ww1_sgjES [Occ=Once] ww2_sgjET [Occ=Once] ->
                 let {
                   f1_sgjxk :: a_sgjEN -> b_sgjEM
                   [LclId,
                    Arity=1,
                    Str=<L,A>,
                    Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                            WorkFree=True, Expandable=True,
                            Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                            Tmpl= \ _ [Occ=Dead] -> w2_sgjEO}]
                   f1_sgjxk = \ _ [Occ=Dead] -> w2_sgjEO } in
                 Data.Functor.Product.Pair
                   @ *
                   @ f_sgjEI
                   @ g_sgjEJ
                   @ a_sgjEN
                   (contramap
                      @ f_sgjEI w_sgjEK @ a_sgjEN @ b_sgjEM f1_sgjxk ww1_sgjES)
                   (contramap
                      @ g_sgjEJ w1_sgjEL @ a_sgjEN @ b_sgjEM f1_sgjxk ww2_sgjET)
                 }}]
Data.Functor.Contravariant.$fContravariantProduct_$c>$
  = \ (@ (f_sgjEI :: * -> *))
      (@ (g_sgjEJ :: * -> *))
      (w_sgjEK :: Contravariant f_sgjEI)
      (w1_sgjEL :: Contravariant g_sgjEJ)
      (@ b_sgjEM)
      (@ a_sgjEN)
      (w2_sgjEO :: b_sgjEM)
      (w3_sgjEP :: Product f_sgjEI g_sgjEJ b_sgjEM) ->
      case w3_sgjEP of { Pair ww1_sgjES ww2_sgjET ->
      let {
        f1_sgjxk :: a_sgjEN -> b_sgjEM
        [LclId,
         Arity=1,
         Str=<L,A>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                 Tmpl= \ _ [Occ=Dead] -> w2_sgjEO}]
        f1_sgjxk = \ _ [Occ=Dead] -> w2_sgjEO } in
      Data.Functor.Product.Pair
        @ *
        @ f_sgjEI
        @ g_sgjEJ
        @ a_sgjEN
        (contramap
           @ f_sgjEI w_sgjEK @ a_sgjEN @ b_sgjEM f1_sgjxk ww1_sgjES)
        (contramap
           @ g_sgjEJ w1_sgjEL @ a_sgjEN @ b_sgjEM f1_sgjxk ww2_sgjET)
      }

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantConst1
  :: forall b a. b -> Const a b -> Const a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_agjcC)
                 (@ a_Xgjix)
                 _ [Occ=Dead]
                 (ds_Xgjy0 [Occ=Once] :: Const a_Xgjix b_agjcC) ->
                 ds_Xgjy0}]
Data.Functor.Contravariant.$fContravariantConst1
  = \ (@ b_agjcC)
      (@ a_Xgjix)
      _ [Occ=Dead]
      (ds_Xgjy0 :: Const a_Xgjix b_agjcC) ->
      ds_Xgjy0

-- RHS size: {terms: 15, types: 34, coercions: 8, joins: 0/0}
Data.Functor.Contravariant.$fContravariantCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (Functor f, Contravariant g) =>
     forall b a. b -> Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_XgjhV :: * -> *))
                 (@ (g_XgjhX :: * -> *))
                 ($dFunctor_XgjhZ [Occ=Once] :: Functor f_XgjhV)
                 ($dContravariant_Xgji1 [Occ=Once] :: Contravariant g_XgjhX)
                 (@ b_agjcg)
                 (@ a_agjch)
                 (x_i7Rxi [Occ=OnceL] :: b_agjcg)
                 (eta_B1 [Occ=Once] :: Compose f_XgjhV g_XgjhX b_agjcg) ->
                 fmap
                   @ f_XgjhV
                   $dFunctor_XgjhZ
                   @ (g_XgjhX b_agjcg)
                   @ (g_XgjhX a_agjch)
                   (contramap
                      @ g_XgjhX
                      $dContravariant_Xgji1
                      @ a_agjch
                      @ b_agjcg
                      (\ _ [Occ=Dead] -> x_i7Rxi))
                   (eta_B1
                    `cast` (Data.Functor.Compose.N:Compose[0]
                                <*>_N <*>_N <f_XgjhV>_R <g_XgjhX>_N <b_agjcg>_N
                            :: (Compose f_XgjhV g_XgjhX b_agjcg :: *)
                               ~R# (f_XgjhV (g_XgjhX b_agjcg) :: *)))}]
Data.Functor.Contravariant.$fContravariantCompose1
  = \ (@ (f_XgjhV :: * -> *))
      (@ (g_XgjhX :: * -> *))
      ($dFunctor_XgjhZ :: Functor f_XgjhV)
      ($dContravariant_Xgji1 :: Contravariant g_XgjhX)
      (@ b_agjcg)
      (@ a_agjch)
      (x_i7Rxi :: b_agjcg)
      (eta_B1 :: Compose f_XgjhV g_XgjhX b_agjcg) ->
      fmap
        @ f_XgjhV
        $dFunctor_XgjhZ
        @ (g_XgjhX b_agjcg)
        @ (g_XgjhX a_agjch)
        (contramap
           @ g_XgjhX
           $dContravariant_Xgji1
           @ a_agjch
           @ b_agjcg
           (\ _ [Occ=Dead] -> x_i7Rxi))
        (eta_B1
         `cast` (Data.Functor.Compose.N:Compose[0]
                     <*>_N <*>_N <f_XgjhV>_R <g_XgjhX>_N <b_agjcg>_N
                 :: (Compose f_XgjhV g_XgjhX b_agjcg :: *)
                    ~R# (f_XgjhV (g_XgjhX b_agjcg) :: *)))

-- RHS size: {terms: 5, types: 12, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantProxy_$c>$
  :: forall b a. b -> Proxy b -> Proxy a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_agjbG) (@ a_agjbH) _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Proxy.Proxy @ * @ a_agjbH}]
Data.Functor.Contravariant.$fContravariantProxy_$c>$
  = \ (@ b_agjbG) (@ a_agjbH) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Proxy.Proxy @ * @ a_agjbH

-- RHS size: {terms: 9, types: 15, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$dm>$
  :: forall (f :: * -> *).
     Contravariant f =>
     forall b a. b -> f b -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_agiFl :: * -> *))
                 ($dContravariant_agiR8 [Occ=OnceL] :: Contravariant f_agiFl)
                 (@ b_agiRa)
                 (@ a_agiRb) ->
                 let {
                   f1_i7Rxg [Occ=OnceL!]
                     :: (a_agiRb -> b_agiRa) -> f_agiFl b_agiRa -> f_agiFl a_agiRb
                   [LclId]
                   f1_i7Rxg
                     = contramap
                         @ f_agiFl $dContravariant_agiR8 @ a_agiRb @ b_agiRa } in
                 \ (x_i7Rxi [Occ=OnceL] :: b_agiRa) ->
                   f1_i7Rxg (\ _ [Occ=Dead] -> x_i7Rxi)}]
Data.Functor.Contravariant.$dm>$
  = \ (@ (f_agiFl :: * -> *))
      ($dContravariant_agiR8 :: Contravariant f_agiFl)
      (@ b_agiRa)
      (@ a_agiRb)
      (eta_B1 :: b_agiRa) ->
      contramap
        @ f_agiFl
        $dContravariant_agiR8
        @ a_agiRb
        @ b_agiRa
        (\ _ [Occ=Dead] -> eta_B1)

-- RHS size: {terms: 10, types: 15, coercions: 41, joins: 0/0}
Data.Functor.Contravariant.$fSemigroupOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. Semigroup a => Semigroup (Op a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m,
 Unf=DFun: \ (@ a_agiHn) (@ b_agiHo) (v_B1 :: Semigroup a_agiHn) ->
       GHC.Base.C:Semigroup TYPE: Op a_agiHn b_agiHo
                            (GHC.Base.$fSemigroup(->)_$c<> @ a_agiHn @ b_agiHo v_B1)
                            `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                                             <a_agiHn>_R <b_agiHo>_R)
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiHn>_R <b_agiHo>_R)
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiHn>_R <b_agiHo>_R)
                                    :: ((b_agiHo -> a_agiHn)
                                        -> (b_agiHo -> a_agiHn) -> b_agiHo -> a_agiHn :: *)
                                       ~R# (Op a_agiHn b_agiHo
                                            -> Op a_agiHn b_agiHo -> Op a_agiHn b_agiHo :: *))
                            (GHC.Base.$fSemigroup(->)_$csconcat @ a_agiHn @ b_agiHo v_B1)
                            `cast` ((GHC.Base.NonEmpty
                                       (Sym (Data.Functor.Contravariant.N:Op[0]
                                                 <a_agiHn>_R <b_agiHo>_R)))_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiHn>_R <b_agiHo>_R)
                                    :: (GHC.Base.NonEmpty (b_agiHo -> a_agiHn)
                                        -> b_agiHo -> a_agiHn :: *)
                                       ~R# (GHC.Base.NonEmpty (Op a_agiHn b_agiHo)
                                            -> Op a_agiHn b_agiHo :: *))
                            (GHC.Base.$fSemigroup(->)_$cstimes @ a_agiHn @ b_agiHo v_B1)
                            `cast` (forall (b1 :: <*>_N).
                                    <Integral b1>_R
                                    ->_R <b1>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiHn>_R <b_agiHo>_R)
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiHn>_R <b_agiHo>_R)
                                    :: (forall b1.
                                        Integral b1 =>
                                        b1 -> (b_agiHo -> a_agiHn) -> b_agiHo -> a_agiHn :: *)
                                       ~R# (forall b1.
                                            Integral b1 =>
                                            b1 -> Op a_agiHn b_agiHo -> Op a_agiHn b_agiHo :: *))]
Data.Functor.Contravariant.$fSemigroupOp
  = \ (@ a_agiSm)
      (@ b_agiSn)
      ($dSemigroup_agiSo :: Semigroup a_agiSm) ->
      GHC.Base.C:Semigroup
        @ (Op a_agiSm b_agiSn)
        ((GHC.Base.$fSemigroup(->)_$c<>
            @ a_agiSm @ b_agiSn $dSemigroup_agiSo)
         `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                          <a_agiSm>_R <b_agiSn>_R)
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_agiSm>_R <b_agiSn>_R)
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_agiSm>_R <b_agiSn>_R)
                 :: ((b_agiSn -> a_agiSm)
                     -> (b_agiSn -> a_agiSm) -> b_agiSn -> a_agiSm :: *)
                    ~R# (Op a_agiSm b_agiSn
                         -> Op a_agiSm b_agiSn -> Op a_agiSm b_agiSn :: *)))
        ((GHC.Base.$fSemigroup(->)_$csconcat
            @ a_agiSm @ b_agiSn $dSemigroup_agiSo)
         `cast` ((GHC.Base.NonEmpty
                    (Sym (Data.Functor.Contravariant.N:Op[0]
                              <a_agiSm>_R <b_agiSn>_R)))_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_agiSm>_R <b_agiSn>_R)
                 :: (GHC.Base.NonEmpty (b_agiSn -> a_agiSm)
                     -> b_agiSn -> a_agiSm :: *)
                    ~R# (GHC.Base.NonEmpty (Op a_agiSm b_agiSn)
                         -> Op a_agiSm b_agiSn :: *)))
        ((GHC.Base.$fSemigroup(->)_$cstimes
            @ a_agiSm @ b_agiSn $dSemigroup_agiSo)
         `cast` (forall (b1 :: <*>_N).
                 <Integral b1>_R
                 ->_R <b1>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_agiSm>_R <b_agiSn>_R)
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_agiSm>_R <b_agiSn>_R)
                 :: (forall b1.
                     Integral b1 =>
                     b1 -> (b_agiSn -> a_agiSm) -> b_agiSn -> a_agiSm :: *)
                    ~R# (forall b1.
                         Integral b1 =>
                         b1 -> Op a_agiSm b_agiSn -> Op a_agiSm b_agiSn :: *)))

-- RHS size: {terms: 6, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid
  :: forall a b. Monoid a => Semigroup (Op a b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgiXu)
                 (@ b_XgiXw)
                 ($dMonoid_XgiXy [Occ=Once] :: Monoid a_XgiXu) ->
                 Data.Functor.Contravariant.$fSemigroupOp
                   @ a_XgiXu @ b_XgiXw (GHC.Base.$p1Monoid @ a_XgiXu $dMonoid_XgiXy)}]
Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid
  = \ (@ a_XgiXu) (@ b_XgiXw) ($dMonoid_XgiXy :: Monoid a_XgiXu) ->
      Data.Functor.Contravariant.$fSemigroupOp
        @ a_XgiXu @ b_XgiXw (GHC.Base.$p1Monoid @ a_XgiXu $dMonoid_XgiXy)

-- RHS size: {terms: 15, types: 18, coercions: 28, joins: 0/1}
Data.Functor.Contravariant.$fMonoidOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. Monoid a => Monoid (Op a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m,
 Unf=DFun: \ (@ a_agiHl) (@ b_agiHm) (v_B1 :: Monoid a_agiHl) ->
       GHC.Base.C:Monoid TYPE: Op a_agiHl b_agiHm
                         Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid
                           @ a_agiHl @ b_agiHm v_B1
                         (\ _ [Occ=Dead] -> mempty @ a_agiHl v_B1)
                         `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                                          <a_agiHl>_R <b_agiHm>_R)
                                 :: (b_agiHm -> a_agiHl :: *) ~R# (Op a_agiHl b_agiHm :: *))
                         (GHC.Base.$fMonoid(->)_$cmappend @ a_agiHl @ b_agiHm v_B1)
                         `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                                          <a_agiHl>_R <b_agiHm>_R)
                                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                               <a_agiHl>_R <b_agiHm>_R)
                                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                               <a_agiHl>_R <b_agiHm>_R)
                                 :: ((b_agiHm -> a_agiHl)
                                     -> (b_agiHm -> a_agiHl) -> b_agiHm -> a_agiHl :: *)
                                    ~R# (Op a_agiHl b_agiHm
                                         -> Op a_agiHl b_agiHm -> Op a_agiHl b_agiHm :: *))
                         (GHC.Base.$fMonoid(->)_$cmconcat @ a_agiHl @ b_agiHm v_B1)
                         `cast` (([Sym (Data.Functor.Contravariant.N:Op[0]
                                            <a_agiHl>_R <b_agiHm>_R)])_R
                                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                               <a_agiHl>_R <b_agiHm>_R)
                                 :: ([b_agiHm -> a_agiHl] -> b_agiHm -> a_agiHl :: *)
                                    ~R# ([Op a_agiHl b_agiHm] -> Op a_agiHl b_agiHm :: *))]
Data.Functor.Contravariant.$fMonoidOp
  = \ (@ a_XgiXv) (@ b_XgiXx) ($dMonoid_XgiXz :: Monoid a_XgiXv) ->
      let {
        lvl7_sgjzg :: a_XgiXv
        [LclId]
        lvl7_sgjzg = mempty @ a_XgiXv $dMonoid_XgiXz } in
      GHC.Base.C:Monoid
        @ (Op a_XgiXv b_XgiXx)
        (Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid
           @ a_XgiXv @ b_XgiXx $dMonoid_XgiXz)
        ((\ _ [Occ=Dead] -> lvl7_sgjzg)
         `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                          <a_XgiXv>_R <b_XgiXx>_R)
                 :: (b_XgiXx -> a_XgiXv :: *) ~R# (Op a_XgiXv b_XgiXx :: *)))
        ((GHC.Base.$fMonoid(->)_$cmappend
            @ a_XgiXv @ b_XgiXx $dMonoid_XgiXz)
         `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                          <a_XgiXv>_R <b_XgiXx>_R)
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_XgiXv>_R <b_XgiXx>_R)
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_XgiXv>_R <b_XgiXx>_R)
                 :: ((b_XgiXx -> a_XgiXv)
                     -> (b_XgiXx -> a_XgiXv) -> b_XgiXx -> a_XgiXv :: *)
                    ~R# (Op a_XgiXv b_XgiXx
                         -> Op a_XgiXv b_XgiXx -> Op a_XgiXv b_XgiXx :: *)))
        ((GHC.Base.$fMonoid(->)_$cmconcat
            @ a_XgiXv @ b_XgiXx $dMonoid_XgiXz)
         `cast` (([Sym (Data.Functor.Contravariant.N:Op[0]
                            <a_XgiXv>_R <b_XgiXx>_R)])_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_XgiXv>_R <b_XgiXx>_R)
                 :: ([b_XgiXx -> a_XgiXv] -> b_XgiXx -> a_XgiXv :: *)
                    ~R# ([Op a_XgiXv b_XgiXx] -> Op a_XgiXv b_XgiXx :: *)))

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fMonoidComparison3
  :: forall a. a -> a -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agiTx) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.EQ}]
Data.Functor.Contravariant.$fMonoidComparison3
  = \ (@ a_agiTx) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.EQ

-- RHS size: {terms: 21, types: 15, coercions: 0, joins: 0/2}
Data.Functor.Contravariant.$fMonoidComparison2
  :: forall a.
     (a -> a -> Ordering) -> (a -> a -> Ordering) -> a -> a -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60 0] 140 60}]
Data.Functor.Contravariant.$fMonoidComparison2
  = \ (@ a_agiTx)
      (f_XgjAv :: a_agiTx -> a_agiTx -> Ordering)
      (g_XgjAx :: a_agiTx -> a_agiTx -> Ordering)
      (x_XgjAz :: a_agiTx) ->
      let {
        f1_sgjxo [Dmd=<L,C(U)>] :: a_agiTx -> Ordering
        [LclId]
        f1_sgjxo = f_XgjAv x_XgjAz } in
      let {
        g1_sgjxn [Dmd=<L,C(U)>] :: a_agiTx -> Ordering
        [LclId]
        g1_sgjxn = g_XgjAx x_XgjAz } in
      \ (x1_igjub :: a_agiTx) ->
        case f1_sgjxo x1_igjub of {
          LT -> GHC.Types.LT;
          EQ -> g1_sgjxn x1_igjub;
          GT -> GHC.Types.GT
        }

-- RHS size: {terms: 21, types: 15, coercions: 0, joins: 0/2}
Data.Functor.Contravariant.$fSemigroupComparison3
  :: forall a.
     (a -> a -> Ordering) -> (a -> a -> Ordering) -> a -> a -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60 0] 140 60}]
Data.Functor.Contravariant.$fSemigroupComparison3
  = \ (@ a_Xgj0p)
      (f_XgjzR :: a_Xgj0p -> a_Xgj0p -> Ordering)
      (g_XgjzT :: a_Xgj0p -> a_Xgj0p -> Ordering)
      (x_XgjzV :: a_Xgj0p) ->
      let {
        f1_sgjxs [Dmd=<L,C(U)>] :: a_Xgj0p -> Ordering
        [LclId]
        f1_sgjxs = f_XgjzR x_XgjzV } in
      let {
        g1_sgjxr [Dmd=<L,C(U)>] :: a_Xgj0p -> Ordering
        [LclId]
        g1_sgjxr = g_XgjzT x_XgjzV } in
      \ (x1_XgjzX :: a_Xgj0p) ->
        case f1_sgjxs x1_XgjzX of {
          LT -> GHC.Types.LT;
          EQ -> g1_sgjxr x1_XgjzX;
          GT -> GHC.Types.GT
        }

-- RHS size: {terms: 17, types: 18, coercions: 0, joins: 0/2}
Data.Functor.Contravariant.$fSemigroupComparison1
  :: forall a b.
     Integral b =>
     b -> (a -> a -> Ordering) -> a -> a -> Ordering
[GblId,
 Arity=4,
 Str=<L,U><L,U><L,1*C1(C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agiUz)
                 (@ b_agiVn)
                 ($dIntegral_agiVp [Occ=OnceL] :: Integral b_agiVn)
                 (n_igjtO [Occ=OnceL] :: b_agiVn)
                 (f_igjtP [Occ=Once!] :: a_agiUz -> a_agiUz -> Ordering)
                 (e_igjtQ [Occ=Once] :: a_agiUz) ->
                 let {
                   f1_sgjxu [Occ=OnceL!] :: a_agiUz -> Ordering
                   [LclId]
                   f1_sgjxu = f_igjtP e_igjtQ } in
                 \ (e1_XgjzA [Occ=Once] :: a_agiUz) ->
                   GHC.Base.$fSemigroupOrdering_$cstimes
                     @ b_agiVn $dIntegral_agiVp n_igjtO (f1_sgjxu e1_XgjzA)}]
Data.Functor.Contravariant.$fSemigroupComparison1
  = \ (@ a_agiUz)
      (@ b_agiVn)
      ($dIntegral_agiVp :: Integral b_agiVn)
      (n_igjtO :: b_agiVn)
      (f_igjtP :: a_agiUz -> a_agiUz -> Ordering)
      (e_igjtQ :: a_agiUz) ->
      let {
        f1_sgjxu [Dmd=<L,C(U)>] :: a_agiUz -> Ordering
        [LclId]
        f1_sgjxu = f_igjtP e_igjtQ } in
      let {
        lvl7_sgjHs [Dmd=<L,C(C1(U))>] :: b_agiVn -> Ordering -> Ordering
        [LclId]
        lvl7_sgjHs
          = GHC.Base.$fSemigroupOrdering_$cstimes
              @ b_agiVn $dIntegral_agiVp } in
      \ (e1_XgjzA :: a_agiUz) -> lvl7_sgjHs n_igjtO (f1_sgjxu e1_XgjzA)

-- RHS size: {terms: 13, types: 28, coercions: 51, joins: 0/0}
Data.Functor.Contravariant.$fContravariantM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: Meta).
     Contravariant f =>
     Contravariant (M1 i c f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ (f_agiHr :: * -> *))
             (@ i_agiHs)
             (@ (c_agiHt :: Meta))
             (v_B1 :: Contravariant f_agiHr) ->
       Data.Functor.Contravariant.C:Contravariant TYPE: M1
                                                          i_agiHs c_agiHt f_agiHr
                                                  (\ (@ a_Xgj1C) (@ b_Xgj1E) ->
                                                     contramap @ f_agiHr v_B1 @ a_Xgj1C @ b_Xgj1E)
                                                  `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                                          <a -> b>_R
                                                          ->_R Sym (GHC.Generics.N:M1[0]
                                                                        <*>_N
                                                                        <i_agiHs>_P
                                                                        <c_agiHt>_P
                                                                        <f_agiHr>_R) <b>_N
                                                          ->_R Sym (GHC.Generics.N:M1[0]
                                                                        <*>_N
                                                                        <i_agiHs>_P
                                                                        <c_agiHt>_P
                                                                        <f_agiHr>_R) <a>_N
                                                          :: (forall a b.
                                                              (a -> b)
                                                              -> f_agiHr b -> f_agiHr a :: *)
                                                             ~R# (forall a b.
                                                                  (a -> b)
                                                                  -> M1 i_agiHs c_agiHt f_agiHr b
                                                                  -> M1
                                                                       i_agiHs
                                                                       c_agiHt
                                                                       f_agiHr
                                                                       a :: *))
                                                  (\ (@ b_Xgj28) (@ a_Xgj2a) ->
                                                     >$ @ f_agiHr v_B1 @ b_Xgj28 @ a_Xgj2a)
                                                  `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                                          <b>_R
                                                          ->_R Sym (GHC.Generics.N:M1[0]
                                                                        <*>_N
                                                                        <i_agiHs>_P
                                                                        <c_agiHt>_P
                                                                        <f_agiHr>_R) <b>_N
                                                          ->_R Sym (GHC.Generics.N:M1[0]
                                                                        <*>_N
                                                                        <i_agiHs>_P
                                                                        <c_agiHt>_P
                                                                        <f_agiHr>_R) <a>_N
                                                          :: (forall b a.
                                                              b -> f_agiHr b -> f_agiHr a :: *)
                                                             ~R# (forall b a.
                                                                  b
                                                                  -> M1 i_agiHs c_agiHt f_agiHr b
                                                                  -> M1
                                                                       i_agiHs
                                                                       c_agiHt
                                                                       f_agiHr
                                                                       a :: *))]
Data.Functor.Contravariant.$fContravariantM1
  = \ (@ (f_Xgj1r :: * -> *))
      (@ i_Xgj1t)
      (@ (c_Xgj1v :: Meta))
      ($dContravariant_Xgj1x :: Contravariant f_Xgj1r) ->
      Data.Functor.Contravariant.C:Contravariant
        @ (M1 i_Xgj1t c_Xgj1v f_Xgj1r)
        ((\ (@ a_Xgj1C) (@ b_Xgj1E) ->
            contramap @ f_Xgj1r $dContravariant_Xgj1x @ a_Xgj1C @ b_Xgj1E)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R Sym (GHC.Generics.N:M1[0]
                               <*>_N <i_Xgj1t>_P <c_Xgj1v>_P <f_Xgj1r>_R) <b>_N
                 ->_R Sym (GHC.Generics.N:M1[0]
                               <*>_N <i_Xgj1t>_P <c_Xgj1v>_P <f_Xgj1r>_R) <a>_N
                 :: (forall a b. (a -> b) -> f_Xgj1r b -> f_Xgj1r a :: *)
                    ~R# (forall a b.
                         (a -> b)
                         -> M1 i_Xgj1t c_Xgj1v f_Xgj1r b
                         -> M1 i_Xgj1t c_Xgj1v f_Xgj1r a :: *)))
        ((\ (@ b_Xgj28) (@ a_Xgj2a) ->
            >$ @ f_Xgj1r $dContravariant_Xgj1x @ b_Xgj28 @ a_Xgj2a)
         `cast` (forall (b :: <*>_N) (a :: <*>_N).
                 <b>_R
                 ->_R Sym (GHC.Generics.N:M1[0]
                               <*>_N <i_Xgj1t>_P <c_Xgj1v>_P <f_Xgj1r>_R) <b>_N
                 ->_R Sym (GHC.Generics.N:M1[0]
                               <*>_N <i_Xgj1t>_P <c_Xgj1v>_P <f_Xgj1r>_R) <a>_N
                 :: (forall b a. b -> f_Xgj1r b -> f_Xgj1r a :: *)
                    ~R# (forall b a.
                         b
                         -> M1 i_Xgj1t c_Xgj1v f_Xgj1r b
                         -> M1 i_Xgj1t c_Xgj1v f_Xgj1r a :: *)))

-- RHS size: {terms: 7, types: 12, coercions: 43, joins: 0/0}
Data.Functor.Contravariant.$fContravariantRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *). Contravariant f => Contravariant (Rec1 f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ (f_agiHu :: * -> *))
             (v_B1 :: Contravariant f_agiHu) ->
       Data.Functor.Contravariant.C:Contravariant TYPE: Rec1 f_agiHu
                                                  (contramap @ f_agiHu v_B1)
                                                  `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                                          <a -> b>_R
                                                          ->_R Sym (GHC.Generics.N:Rec1[0]
                                                                        <*>_N <f_agiHu>_R) <b>_N
                                                          ->_R Sym (GHC.Generics.N:Rec1[0]
                                                                        <*>_N <f_agiHu>_R) <a>_N
                                                          :: (forall a b.
                                                              (a -> b)
                                                              -> f_agiHu b -> f_agiHu a :: *)
                                                             ~R# (forall a b.
                                                                  (a -> b)
                                                                  -> Rec1 f_agiHu b
                                                                  -> Rec1 f_agiHu a :: *))
                                                  (>$ @ f_agiHu v_B1)
                                                  `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                                          <b>_R
                                                          ->_R Sym (GHC.Generics.N:Rec1[0]
                                                                        <*>_N <f_agiHu>_R) <b>_N
                                                          ->_R Sym (GHC.Generics.N:Rec1[0]
                                                                        <*>_N <f_agiHu>_R) <a>_N
                                                          :: (forall b a.
                                                              b -> f_agiHu b -> f_agiHu a :: *)
                                                             ~R# (forall b a.
                                                                  b
                                                                  -> Rec1 f_agiHu b
                                                                  -> Rec1 f_agiHu a :: *))]
Data.Functor.Contravariant.$fContravariantRec1
  = \ (@ (f_agiX0 :: * -> *))
      ($dContravariant_agiX1 :: Contravariant f_agiX0) ->
      Data.Functor.Contravariant.C:Contravariant
        @ (Rec1 f_agiX0)
        ((contramap @ f_agiX0 $dContravariant_agiX1)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_agiX0>_R) <b>_N
                 ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_agiX0>_R) <a>_N
                 :: (forall a b. (a -> b) -> f_agiX0 b -> f_agiX0 a :: *)
                    ~R# (forall a b.
                         (a -> b) -> Rec1 f_agiX0 b -> Rec1 f_agiX0 a :: *)))
        ((>$ @ f_agiX0 $dContravariant_agiX1)
         `cast` (forall (b :: <*>_N) (a :: <*>_N).
                 <b>_R
                 ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_agiX0>_R) <b>_N
                 ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_agiX0>_R) <a>_N
                 :: (forall b a. b -> f_agiX0 b -> f_agiX0 a :: *)
                    ~R# (forall b a. b -> Rec1 f_agiX0 b -> Rec1 f_agiX0 a :: *)))

-- RHS size: {terms: 7, types: 12, coercions: 43, joins: 0/0}
Data.Functor.Contravariant.$fContravariantAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *). Contravariant f => Contravariant (Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ (f_agiHv :: * -> *))
             (v_B1 :: Contravariant f_agiHv) ->
       Data.Functor.Contravariant.C:Contravariant TYPE: Alt f_agiHv
                                                  (contramap @ f_agiHv v_B1)
                                                  `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                                          <a -> b>_R
                                                          ->_R Sym (Data.Semigroup.Internal.N:Alt[0]
                                                                        <*>_N <f_agiHv>_R) <b>_N
                                                          ->_R Sym (Data.Semigroup.Internal.N:Alt[0]
                                                                        <*>_N <f_agiHv>_R) <a>_N
                                                          :: (forall a b.
                                                              (a -> b)
                                                              -> f_agiHv b -> f_agiHv a :: *)
                                                             ~R# (forall a b.
                                                                  (a -> b)
                                                                  -> Alt f_agiHv b
                                                                  -> Alt f_agiHv a :: *))
                                                  (>$ @ f_agiHv v_B1)
                                                  `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                                          <b>_R
                                                          ->_R Sym (Data.Semigroup.Internal.N:Alt[0]
                                                                        <*>_N <f_agiHv>_R) <b>_N
                                                          ->_R Sym (Data.Semigroup.Internal.N:Alt[0]
                                                                        <*>_N <f_agiHv>_R) <a>_N
                                                          :: (forall b a.
                                                              b -> f_agiHv b -> f_agiHv a :: *)
                                                             ~R# (forall b a.
                                                                  b
                                                                  -> Alt f_agiHv b
                                                                  -> Alt f_agiHv a :: *))]
Data.Functor.Contravariant.$fContravariantAlt
  = \ (@ (f_agiY2 :: * -> *))
      ($dContravariant_agiY3 :: Contravariant f_agiY2) ->
      Data.Functor.Contravariant.C:Contravariant
        @ (Alt f_agiY2)
        ((contramap @ f_agiY2 $dContravariant_agiY3)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Alt[0] <*>_N <f_agiY2>_R) <b>_N
                 ->_R Sym (Data.Semigroup.Internal.N:Alt[0] <*>_N <f_agiY2>_R) <a>_N
                 :: (forall a b. (a -> b) -> f_agiY2 b -> f_agiY2 a :: *)
                    ~R# (forall a b. (a -> b) -> Alt f_agiY2 b -> Alt f_agiY2 a :: *)))
        ((>$ @ f_agiY2 $dContravariant_agiY3)
         `cast` (forall (b :: <*>_N) (a :: <*>_N).
                 <b>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Alt[0] <*>_N <f_agiY2>_R) <b>_N
                 ->_R Sym (Data.Semigroup.Internal.N:Alt[0] <*>_N <f_agiY2>_R) <a>_N
                 :: (forall b a. b -> f_agiY2 b -> f_agiY2 a :: *)
                    ~R# (forall b a. b -> Alt f_agiY2 b -> Alt f_agiY2 a :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_rgjLr :: Integer
[GblId, Unf=OtherCon []]
lvl_rgjLr = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1_rgjLs :: Integer
[GblId, Unf=OtherCon []]
lvl1_rgjLs = 0

-- RHS size: {terms: 31, types: 24, coercions: 7, joins: 0/4}
Data.Functor.Contravariant.$fFloatingOp_$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: forall a b. Floating a => Op a b -> Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_Xgj9N)
                 (@ b_Xgj9Q)
                 ($dFloating_Xgj9T :: Floating a_Xgj9N) ->
                 let {
                   $dNum_sgjtt [Occ=OnceL] :: Fractional a_Xgj9N
                   [LclId]
                   $dNum_sgjtt = GHC.Float.$p1Floating @ a_Xgj9N $dFloating_Xgj9T } in
                 let {
                   $dNum1_sgjtu :: Num a_Xgj9N
                   [LclId]
                   $dNum1_sgjtu = GHC.Real.$p1Fractional @ a_Xgj9N $dNum_sgjtt } in
                 \ (x_igjqb [Occ=OnceL] :: Op a_Xgj9N b_Xgj9Q) ->
                   let {
                     $dFractional_sgjtD [Occ=OnceL] :: Fractional a_Xgj9N
                     [LclId]
                     $dFractional_sgjtD
                       = GHC.Float.$p1Floating @ a_Xgj9N $dFloating_Xgj9T } in
                   let {
                     $dNum2_sgjtE :: Num a_Xgj9N
                     [LclId]
                     $dNum2_sgjtE
                       = GHC.Real.$p1Fractional @ a_Xgj9N $dFractional_sgjtD } in
                   let {
                     x1_i7Sb8 [Occ=OnceL] :: a_Xgj9N
                     [LclId]
                     x1_i7Sb8 = fromInteger @ a_Xgj9N $dNum1_sgjtu 0 } in
                   let {
                     x2_X7Sh7 [Occ=OnceL] :: a_Xgj9N
                     [LclId]
                     x2_X7Sh7 = fromInteger @ a_Xgj9N $dNum2_sgjtE 1 } in
                   (\ (eta_B1 [Occ=Once] :: b_Xgj9Q) ->
                      log
                        @ a_Xgj9N
                        $dFloating_Xgj9T
                        (+ @ a_Xgj9N
                           $dNum2_sgjtE
                           x2_X7Sh7
                           (- @ a_Xgj9N
                              $dNum1_sgjtu
                              x1_i7Sb8
                              (exp
                                 @ a_Xgj9N
                                 $dFloating_Xgj9T
                                 ((x_igjqb
                                   `cast` (Data.Functor.Contravariant.N:Op[0]
                                               <a_Xgj9N>_R <b_Xgj9Q>_R
                                           :: (Op a_Xgj9N b_Xgj9Q :: *)
                                              ~R# (b_Xgj9Q -> a_Xgj9N :: *)))
                                    eta_B1)))))
                   `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                                    <a_Xgj9N>_R <b_Xgj9Q>_R)
                           :: (b_Xgj9Q -> a_Xgj9N :: *) ~R# (Op a_Xgj9N b_Xgj9Q :: *))}]
Data.Functor.Contravariant.$fFloatingOp_$clog1mexp
  = \ (@ a_Xgj9N)
      (@ b_Xgj9Q)
      ($dFloating_Xgj9T :: Floating a_Xgj9N)
      (eta_B1 :: Op a_Xgj9N b_Xgj9Q) ->
      let {
        $dFractional_sgjxG [Dmd=<L,1*U(1*U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),A,A,A)>]
          :: Fractional a_Xgj9N
        [LclId]
        $dFractional_sgjxG
          = GHC.Float.$p1Floating @ a_Xgj9N $dFloating_Xgj9T } in
      let {
        $dNum_sgjxF [Dmd=<L,U(C(C1(U)),C(C1(U)),A,A,A,A,C(U))>]
          :: Num a_Xgj9N
        [LclId]
        $dNum_sgjxF
          = GHC.Real.$p1Fractional @ a_Xgj9N $dFractional_sgjxG } in
      let {
        x_sgjxC :: a_Xgj9N
        [LclId]
        x_sgjxC = fromInteger @ a_Xgj9N $dNum_sgjxF lvl1_rgjLs } in
      let {
        x1_sgjxB :: a_Xgj9N
        [LclId]
        x1_sgjxB = fromInteger @ a_Xgj9N $dNum_sgjxF lvl_rgjLr } in
      (\ (eta1_X60 :: b_Xgj9Q) ->
         log
           @ a_Xgj9N
           $dFloating_Xgj9T
           (+ @ a_Xgj9N
              $dNum_sgjxF
              x1_sgjxB
              (- @ a_Xgj9N
                 $dNum_sgjxF
                 x_sgjxC
                 (exp
                    @ a_Xgj9N
                    $dFloating_Xgj9T
                    ((eta_B1
                      `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9N>_R <b_Xgj9Q>_R
                              :: (Op a_Xgj9N b_Xgj9Q :: *) ~R# (b_Xgj9Q -> a_Xgj9N :: *)))
                       eta1_X60)))))
      `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                       <a_Xgj9N>_R <b_Xgj9Q>_R)
              :: (b_Xgj9Q -> a_Xgj9N :: *) ~R# (Op a_Xgj9N b_Xgj9Q :: *))

-- RHS size: {terms: 22, types: 20, coercions: 7, joins: 0/3}
Data.Functor.Contravariant.$fFloatingOp_$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: forall a b. Floating a => Op a b -> Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(A,C(C1(U)),A,A,A,A,1*C1(U)),A,A,A),A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_Xgj9N)
                 (@ b_Xgj4c)
                 ($dFloating_Xgj4e :: Floating a_Xgj9N) ->
                 let {
                   $dFractional_sgjty [Occ=OnceL] :: Fractional a_Xgj9N
                   [LclId]
                   $dFractional_sgjty
                     = GHC.Float.$p1Floating @ a_Xgj9N $dFloating_Xgj4e } in
                 let {
                   $dNum_sgjtz :: Num a_Xgj9N
                   [LclId]
                   $dNum_sgjtz
                     = GHC.Real.$p1Fractional @ a_Xgj9N $dFractional_sgjty } in
                 \ (x_igjq3 [Occ=OnceL] :: Op a_Xgj9N b_Xgj4c) ->
                   let {
                     x1_i7Sb8 [Occ=OnceL] :: a_Xgj9N
                     [LclId]
                     x1_i7Sb8 = fromInteger @ a_Xgj9N $dNum_sgjtz 1 } in
                   (\ (a1_agiG3 [Occ=Once] :: b_Xgj4c) ->
                      - @ a_Xgj9N
                        $dNum_sgjtz
                        (exp
                           @ a_Xgj9N
                           $dFloating_Xgj4e
                           ((x_igjq3
                             `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9N>_R <b_Xgj4c>_R
                                     :: (Op a_Xgj9N b_Xgj4c :: *) ~R# (b_Xgj4c -> a_Xgj9N :: *)))
                              a1_agiG3))
                        x1_i7Sb8)
                   `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                                    <a_Xgj9N>_R <b_Xgj4c>_R)
                           :: (b_Xgj4c -> a_Xgj9N :: *) ~R# (Op a_Xgj9N b_Xgj4c :: *))}]
Data.Functor.Contravariant.$fFloatingOp_$cexpm1
  = \ (@ a_Xgj9N)
      (@ b_Xgj4c)
      ($dFloating_Xgj4e :: Floating a_Xgj9N)
      (eta_B1 :: Op a_Xgj9N b_Xgj4c) ->
      let {
        $dFractional_sgjxM [Dmd=<L,1*U(1*U(A,C(C1(U)),A,A,A,A,1*C1(U)),A,A,A)>]
          :: Fractional a_Xgj9N
        [LclId]
        $dFractional_sgjxM
          = GHC.Float.$p1Floating @ a_Xgj9N $dFloating_Xgj4e } in
      let {
        $dNum_sgjxL [Dmd=<L,U(A,C(C1(U)),A,A,A,A,1*C1(U))>] :: Num a_Xgj9N
        [LclId]
        $dNum_sgjxL
          = GHC.Real.$p1Fractional @ a_Xgj9N $dFractional_sgjxM } in
      let {
        x_sgjxK :: a_Xgj9N
        [LclId]
        x_sgjxK = fromInteger @ a_Xgj9N $dNum_sgjxL lvl_rgjLr } in
      (\ (a1_agiG3 :: b_Xgj4c) ->
         - @ a_Xgj9N
           $dNum_sgjxL
           (exp
              @ a_Xgj9N
              $dFloating_Xgj4e
              ((eta_B1
                `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9N>_R <b_Xgj4c>_R
                        :: (Op a_Xgj9N b_Xgj4c :: *) ~R# (b_Xgj4c -> a_Xgj9N :: *)))
                 a1_agiG3))
           x_sgjxK)
      `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                       <a_Xgj9N>_R <b_Xgj4c>_R)
              :: (b_Xgj4c -> a_Xgj9N :: *) ~R# (Op a_Xgj9N b_Xgj4c :: *))

-- RHS size: {terms: 24, types: 21, coercions: 7, joins: 0/3}
Data.Functor.Contravariant.$fFloatingOp_$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: forall a b. Floating a => Op a b -> Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_Xgj9N)
                 (@ b_Xgj9Q)
                 ($dFloating_Xgj4f :: Floating a_Xgj9N)
                 (x_igjq6 [Occ=OnceL] :: Op a_Xgj9N b_Xgj9Q) ->
                 let {
                   $dFractional_sgjtD [Occ=OnceL] :: Fractional a_Xgj9N
                   [LclId]
                   $dFractional_sgjtD
                     = GHC.Float.$p1Floating @ a_Xgj9N $dFloating_Xgj4f } in
                 let {
                   $dNum_sgjtE :: Num a_Xgj9N
                   [LclId]
                   $dNum_sgjtE
                     = GHC.Real.$p1Fractional @ a_Xgj9N $dFractional_sgjtD } in
                 let {
                   x1_i7Sb8 [Occ=OnceL] :: a_Xgj9N
                   [LclId]
                   x1_i7Sb8 = fromInteger @ a_Xgj9N $dNum_sgjtE 1 } in
                 (\ (eta_B1 [Occ=Once] :: b_Xgj9Q) ->
                    log
                      @ a_Xgj9N
                      $dFloating_Xgj4f
                      (+ @ a_Xgj9N
                         $dNum_sgjtE
                         x1_i7Sb8
                         (exp
                            @ a_Xgj9N
                            $dFloating_Xgj4f
                            ((x_igjq6
                              `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9N>_R <b_Xgj9Q>_R
                                      :: (Op a_Xgj9N b_Xgj9Q :: *) ~R# (b_Xgj9Q -> a_Xgj9N :: *)))
                               eta_B1))))
                 `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                                  <a_Xgj9N>_R <b_Xgj9Q>_R)
                         :: (b_Xgj9Q -> a_Xgj9N :: *) ~R# (Op a_Xgj9N b_Xgj9Q :: *))}]
Data.Functor.Contravariant.$fFloatingOp_$clog1pexp
  = \ (@ a_Xgj9N)
      (@ b_Xgj9Q)
      ($dFloating_Xgj4f :: Floating a_Xgj9N)
      (eta_B1 :: Op a_Xgj9N b_Xgj9Q) ->
      let {
        $dFractional_sgjxS [Dmd=<L,1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A)>]
          :: Fractional a_Xgj9N
        [LclId]
        $dFractional_sgjxS
          = GHC.Float.$p1Floating @ a_Xgj9N $dFloating_Xgj4f } in
      let {
        $dNum_sgjxR [Dmd=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>] :: Num a_Xgj9N
        [LclId]
        $dNum_sgjxR
          = GHC.Real.$p1Fractional @ a_Xgj9N $dFractional_sgjxS } in
      let {
        x_sgjxQ :: a_Xgj9N
        [LclId]
        x_sgjxQ = fromInteger @ a_Xgj9N $dNum_sgjxR lvl_rgjLr } in
      (\ (eta1_X5Q :: b_Xgj9Q) ->
         log
           @ a_Xgj9N
           $dFloating_Xgj4f
           (+ @ a_Xgj9N
              $dNum_sgjxR
              x_sgjxQ
              (exp
                 @ a_Xgj9N
                 $dFloating_Xgj4f
                 ((eta_B1
                   `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9N>_R <b_Xgj9Q>_R
                           :: (Op a_Xgj9N b_Xgj9Q :: *) ~R# (b_Xgj9Q -> a_Xgj9N :: *)))
                    eta1_X5Q))))
      `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                       <a_Xgj9N>_R <b_Xgj9Q>_R)
              :: (b_Xgj9Q -> a_Xgj9N :: *) ~R# (Op a_Xgj9N b_Xgj9Q :: *))

-- RHS size: {terms: 22, types: 20, coercions: 7, joins: 0/3}
Data.Functor.Contravariant.$fFloatingOp_$clog1p [InlPrag=INLINE (sat-args=1)]
  :: forall a b. Floating a => Op a b -> Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A),A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_Xgj4c)
                 (@ b_Xgj4e)
                 ($dFloating_Xgj4g :: Floating a_Xgj4c) ->
                 let {
                   $dFractional_sgjtD [Occ=OnceL] :: Fractional a_Xgj4c
                   [LclId]
                   $dFractional_sgjtD
                     = GHC.Float.$p1Floating @ a_Xgj4c $dFloating_Xgj4g } in
                 let {
                   $dNum_sgjtE :: Num a_Xgj4c
                   [LclId]
                   $dNum_sgjtE
                     = GHC.Real.$p1Fractional @ a_Xgj4c $dFractional_sgjtD } in
                 \ (x_igjpY [Occ=OnceL] :: Op a_Xgj4c b_Xgj4e) ->
                   let {
                     x1_i7Sb8 [Occ=OnceL] :: a_Xgj4c
                     [LclId]
                     x1_i7Sb8 = fromInteger @ a_Xgj4c $dNum_sgjtE 1 } in
                   (\ (eta_B1 [Occ=Once] :: b_Xgj4e) ->
                      log
                        @ a_Xgj4c
                        $dFloating_Xgj4g
                        (+ @ a_Xgj4c
                           $dNum_sgjtE
                           x1_i7Sb8
                           ((x_igjpY
                             `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj4c>_R <b_Xgj4e>_R
                                     :: (Op a_Xgj4c b_Xgj4e :: *) ~R# (b_Xgj4e -> a_Xgj4c :: *)))
                              eta_B1)))
                   `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                                    <a_Xgj4c>_R <b_Xgj4e>_R)
                           :: (b_Xgj4e -> a_Xgj4c :: *) ~R# (Op a_Xgj4c b_Xgj4e :: *))}]
Data.Functor.Contravariant.$fFloatingOp_$clog1p
  = \ (@ a_Xgj4c)
      (@ b_Xgj4e)
      ($dFloating_Xgj4g :: Floating a_Xgj4c)
      (eta_B1 :: Op a_Xgj4c b_Xgj4e) ->
      let {
        $dFractional_sgjxY [Dmd=<L,1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A)>]
          :: Fractional a_Xgj4c
        [LclId]
        $dFractional_sgjxY
          = GHC.Float.$p1Floating @ a_Xgj4c $dFloating_Xgj4g } in
      let {
        $dNum_sgjxX [Dmd=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>] :: Num a_Xgj4c
        [LclId]
        $dNum_sgjxX
          = GHC.Real.$p1Fractional @ a_Xgj4c $dFractional_sgjxY } in
      let {
        x_sgjxW :: a_Xgj4c
        [LclId]
        x_sgjxW = fromInteger @ a_Xgj4c $dNum_sgjxX lvl_rgjLr } in
      (\ (eta1_X5T :: b_Xgj4e) ->
         log
           @ a_Xgj4c
           $dFloating_Xgj4g
           (+ @ a_Xgj4c
              $dNum_sgjxX
              x_sgjxW
              ((eta_B1
                `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj4c>_R <b_Xgj4e>_R
                        :: (Op a_Xgj4c b_Xgj4e :: *) ~R# (b_Xgj4e -> a_Xgj4c :: *)))
                 eta1_X5T)))
      `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                       <a_Xgj4c>_R <b_Xgj4e>_R)
              :: (b_Xgj4e -> a_Xgj4c :: *) ~R# (Op a_Xgj4c b_Xgj4e :: *))

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp17
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLLLLLLLLLLLLLLLLLLL),1*U(A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgjeT)
                 (@ b_Xgj9x)
                 ($dFloating_Xgj9A [Occ=Once] :: Floating a_XgjeT)
                 (ds_dgjo4 [Occ=Once] :: Op a_XgjeT b_Xgj9x)
                 (eta_B1 [Occ=Once] :: b_Xgj9x) ->
                 exp
                   @ a_XgjeT
                   $dFloating_Xgj9A
                   ((ds_dgjo4
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_XgjeT>_R <b_Xgj9x>_R
                             :: (Op a_XgjeT b_Xgj9x :: *) ~R# (b_Xgj9x -> a_XgjeT :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp17
  = \ (@ a_XgjeT)
      (@ b_Xgj9x)
      ($dFloating_Xgj9A :: Floating a_XgjeT)
      (ds_dgjo4 :: Op a_XgjeT b_Xgj9x)
      (eta_B1 :: b_Xgj9x) ->
      exp
        @ a_XgjeT
        $dFloating_Xgj9A
        ((ds_dgjo4
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_XgjeT>_R <b_Xgj9x>_R
                  :: (Op a_XgjeT b_Xgj9x :: *) ~R# (b_Xgj9x -> a_XgjeT :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp16
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LLLLLLLLLLLLLLLLLLL),1*U(A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj44)
                 (@ b_Xgj46)
                 ($dFloating_Xgj48 [Occ=Once] :: Floating a_Xgj44)
                 (ds_dgjoa [Occ=Once] :: Op a_Xgj44 b_Xgj46)
                 (eta_B1 [Occ=Once] :: b_Xgj46) ->
                 log
                   @ a_Xgj44
                   $dFloating_Xgj48
                   ((ds_dgjoa
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj44>_R <b_Xgj46>_R
                             :: (Op a_Xgj44 b_Xgj46 :: *) ~R# (b_Xgj46 -> a_Xgj44 :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp16
  = \ (@ a_Xgj44)
      (@ b_Xgj46)
      ($dFloating_Xgj48 :: Floating a_Xgj44)
      (ds_dgjoa :: Op a_Xgj44 b_Xgj46)
      (eta_B1 :: b_Xgj46) ->
      log
        @ a_Xgj44
        $dFloating_Xgj48
        ((ds_dgjoa
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj44>_R <b_Xgj46>_R
                  :: (Op a_Xgj44 b_Xgj46 :: *) ~R# (b_Xgj46 -> a_Xgj44 :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp15
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)LLLLLLLLLLLLLLLLLL),1*U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj9g)
                 (@ b_Xgj9j)
                 ($dFloating_Xgj9m [Occ=Once] :: Floating a_Xgj9g)
                 (ds_dgjog [Occ=Once] :: Op a_Xgj9g b_Xgj9j)
                 (eta_B1 [Occ=Once] :: b_Xgj9j) ->
                 sqrt
                   @ a_Xgj9g
                   $dFloating_Xgj9m
                   ((ds_dgjog
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9g>_R <b_Xgj9j>_R
                             :: (Op a_Xgj9g b_Xgj9j :: *) ~R# (b_Xgj9j -> a_Xgj9g :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp15
  = \ (@ a_Xgj9g)
      (@ b_Xgj9j)
      ($dFloating_Xgj9m :: Floating a_Xgj9g)
      (ds_dgjog :: Op a_Xgj9g b_Xgj9j)
      (eta_B1 :: b_Xgj9j) ->
      sqrt
        @ a_Xgj9g
        $dFloating_Xgj9m
        ((ds_dgjog
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9g>_R <b_Xgj9j>_R
                  :: (Op a_Xgj9g b_Xgj9j :: *) ~R# (b_Xgj9j -> a_Xgj9g :: *)))
           eta_B1)

-- RHS size: {terms: 12, types: 14, coercions: 6, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp14
  :: forall a b. Floating a => Op a b -> Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj3W)
                 (@ b_Xgj3Y)
                 ($dFloating_Xgj40 [Occ=Once] :: Floating a_Xgj3W)
                 (ds_dgjom [Occ=Once] :: Op a_Xgj3W b_Xgj3Y)
                 (ds1_dgjon [Occ=Once] :: Op a_Xgj3W b_Xgj3Y)
                 (a1_agiFJ :: b_Xgj3Y) ->
                 **
                   @ a_Xgj3W
                   $dFloating_Xgj40
                   ((ds_dgjom
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3W>_R <b_Xgj3Y>_R
                             :: (Op a_Xgj3W b_Xgj3Y :: *) ~R# (b_Xgj3Y -> a_Xgj3W :: *)))
                      a1_agiFJ)
                   ((ds1_dgjon
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3W>_R <b_Xgj3Y>_R
                             :: (Op a_Xgj3W b_Xgj3Y :: *) ~R# (b_Xgj3Y -> a_Xgj3W :: *)))
                      a1_agiFJ)}]
Data.Functor.Contravariant.$fFloatingOp14
  = \ (@ a_Xgj3W)
      (@ b_Xgj3Y)
      ($dFloating_Xgj40 :: Floating a_Xgj3W)
      (ds_dgjom :: Op a_Xgj3W b_Xgj3Y)
      (ds1_dgjon :: Op a_Xgj3W b_Xgj3Y)
      (a1_agiFJ :: b_Xgj3Y) ->
      **
        @ a_Xgj3W
        $dFloating_Xgj40
        ((ds_dgjom
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3W>_R <b_Xgj3Y>_R
                  :: (Op a_Xgj3W b_Xgj3Y :: *) ~R# (b_Xgj3Y -> a_Xgj3W :: *)))
           a1_agiFJ)
        ((ds1_dgjon
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3W>_R <b_Xgj3Y>_R
                  :: (Op a_Xgj3W b_Xgj3Y :: *) ~R# (b_Xgj3Y -> a_Xgj3W :: *)))
           a1_agiFJ)

-- RHS size: {terms: 12, types: 14, coercions: 6, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp13
  :: forall a b. Floating a => Op a b -> Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj4f)
                 (@ b_Xgj4h)
                 ($dFloating_Xgj4j [Occ=Once] :: Floating a_Xgj4f)
                 (ds_dgjoy [Occ=Once] :: Op a_Xgj4f b_Xgj4h)
                 (ds1_dgjoz [Occ=Once] :: Op a_Xgj4f b_Xgj4h)
                 (a1_agiFM :: b_Xgj4h) ->
                 logBase
                   @ a_Xgj4f
                   $dFloating_Xgj4j
                   ((ds_dgjoy
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj4f>_R <b_Xgj4h>_R
                             :: (Op a_Xgj4f b_Xgj4h :: *) ~R# (b_Xgj4h -> a_Xgj4f :: *)))
                      a1_agiFM)
                   ((ds1_dgjoz
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj4f>_R <b_Xgj4h>_R
                             :: (Op a_Xgj4f b_Xgj4h :: *) ~R# (b_Xgj4h -> a_Xgj4f :: *)))
                      a1_agiFM)}]
Data.Functor.Contravariant.$fFloatingOp13
  = \ (@ a_Xgj4f)
      (@ b_Xgj4h)
      ($dFloating_Xgj4j :: Floating a_Xgj4f)
      (ds_dgjoy :: Op a_Xgj4f b_Xgj4h)
      (ds1_dgjoz :: Op a_Xgj4f b_Xgj4h)
      (a1_agiFM :: b_Xgj4h) ->
      logBase
        @ a_Xgj4f
        $dFloating_Xgj4j
        ((ds_dgjoy
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj4f>_R <b_Xgj4h>_R
                  :: (Op a_Xgj4f b_Xgj4h :: *) ~R# (b_Xgj4h -> a_Xgj4f :: *)))
           a1_agiFM)
        ((ds1_dgjoz
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj4f>_R <b_Xgj4h>_R
                  :: (Op a_Xgj4f b_Xgj4h :: *) ~R# (b_Xgj4h -> a_Xgj4f :: *)))
           a1_agiFM)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp12
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj49)
                 (@ b_Xgj4b)
                 ($dFloating_Xgj4d [Occ=Once] :: Floating a_Xgj49)
                 (ds_dgjoK [Occ=Once] :: Op a_Xgj49 b_Xgj4b)
                 (eta_B1 [Occ=Once] :: b_Xgj4b) ->
                 sin
                   @ a_Xgj49
                   $dFloating_Xgj4d
                   ((ds_dgjoK
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj49>_R <b_Xgj4b>_R
                             :: (Op a_Xgj49 b_Xgj4b :: *) ~R# (b_Xgj4b -> a_Xgj49 :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp12
  = \ (@ a_Xgj49)
      (@ b_Xgj4b)
      ($dFloating_Xgj4d :: Floating a_Xgj49)
      (ds_dgjoK :: Op a_Xgj49 b_Xgj4b)
      (eta_B1 :: b_Xgj4b) ->
      sin
        @ a_Xgj49
        $dFloating_Xgj4d
        ((ds_dgjoK
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj49>_R <b_Xgj4b>_R
                  :: (Op a_Xgj49 b_Xgj4b :: *) ~R# (b_Xgj4b -> a_Xgj49 :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp11
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj43)
                 (@ b_Xgj45)
                 ($dFloating_Xgj47 [Occ=Once] :: Floating a_Xgj43)
                 (ds_dgjoQ [Occ=Once] :: Op a_Xgj43 b_Xgj45)
                 (eta_B1 [Occ=Once] :: b_Xgj45) ->
                 cos
                   @ a_Xgj43
                   $dFloating_Xgj47
                   ((ds_dgjoQ
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj43>_R <b_Xgj45>_R
                             :: (Op a_Xgj43 b_Xgj45 :: *) ~R# (b_Xgj45 -> a_Xgj43 :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp11
  = \ (@ a_Xgj43)
      (@ b_Xgj45)
      ($dFloating_Xgj47 :: Floating a_Xgj43)
      (ds_dgjoQ :: Op a_Xgj43 b_Xgj45)
      (eta_B1 :: b_Xgj45) ->
      cos
        @ a_Xgj43
        $dFloating_Xgj47
        ((ds_dgjoQ
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj43>_R <b_Xgj45>_R
                  :: (Op a_Xgj43 b_Xgj45 :: *) ~R# (b_Xgj45 -> a_Xgj43 :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp10
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(S)LLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj3X)
                 (@ b_Xgj3Z)
                 ($dFloating_Xgj41 [Occ=Once] :: Floating a_Xgj3X)
                 (ds_dgjoW [Occ=Once] :: Op a_Xgj3X b_Xgj3Z)
                 (eta_B1 [Occ=Once] :: b_Xgj3Z) ->
                 tan
                   @ a_Xgj3X
                   $dFloating_Xgj41
                   ((ds_dgjoW
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3X>_R <b_Xgj3Z>_R
                             :: (Op a_Xgj3X b_Xgj3Z :: *) ~R# (b_Xgj3Z -> a_Xgj3X :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp10
  = \ (@ a_Xgj3X)
      (@ b_Xgj3Z)
      ($dFloating_Xgj41 :: Floating a_Xgj3X)
      (ds_dgjoW :: Op a_Xgj3X b_Xgj3Z)
      (eta_B1 :: b_Xgj3Z) ->
      tan
        @ a_Xgj3X
        $dFloating_Xgj41
        ((ds_dgjoW
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3X>_R <b_Xgj3Z>_R
                  :: (Op a_Xgj3X b_Xgj3Z :: *) ~R# (b_Xgj3Z -> a_Xgj3X :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp9
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLC(S)LLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj3R)
                 (@ b_Xgj3T)
                 ($dFloating_Xgj3V [Occ=Once] :: Floating a_Xgj3R)
                 (ds_dgjp2 [Occ=Once] :: Op a_Xgj3R b_Xgj3T)
                 (eta_B1 [Occ=Once] :: b_Xgj3T) ->
                 asin
                   @ a_Xgj3R
                   $dFloating_Xgj3V
                   ((ds_dgjp2
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3R>_R <b_Xgj3T>_R
                             :: (Op a_Xgj3R b_Xgj3T :: *) ~R# (b_Xgj3T -> a_Xgj3R :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp9
  = \ (@ a_Xgj3R)
      (@ b_Xgj3T)
      ($dFloating_Xgj3V :: Floating a_Xgj3R)
      (ds_dgjp2 :: Op a_Xgj3R b_Xgj3T)
      (eta_B1 :: b_Xgj3T) ->
      asin
        @ a_Xgj3R
        $dFloating_Xgj3V
        ((ds_dgjp2
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3R>_R <b_Xgj3T>_R
                  :: (Op a_Xgj3R b_Xgj3T :: *) ~R# (b_Xgj3T -> a_Xgj3R :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp8
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLC(S)LLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj3L)
                 (@ b_Xgj3N)
                 ($dFloating_Xgj3P [Occ=Once] :: Floating a_Xgj3L)
                 (ds_dgjp8 [Occ=Once] :: Op a_Xgj3L b_Xgj3N)
                 (eta_B1 [Occ=Once] :: b_Xgj3N) ->
                 acos
                   @ a_Xgj3L
                   $dFloating_Xgj3P
                   ((ds_dgjp8
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3L>_R <b_Xgj3N>_R
                             :: (Op a_Xgj3L b_Xgj3N :: *) ~R# (b_Xgj3N -> a_Xgj3L :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp8
  = \ (@ a_Xgj3L)
      (@ b_Xgj3N)
      ($dFloating_Xgj3P :: Floating a_Xgj3L)
      (ds_dgjp8 :: Op a_Xgj3L b_Xgj3N)
      (eta_B1 :: b_Xgj3N) ->
      acos
        @ a_Xgj3L
        $dFloating_Xgj3P
        ((ds_dgjp8
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3L>_R <b_Xgj3N>_R
                  :: (Op a_Xgj3L b_Xgj3N :: *) ~R# (b_Xgj3N -> a_Xgj3L :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp7
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLC(S)LLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj3F)
                 (@ b_Xgj3H)
                 ($dFloating_Xgj3J [Occ=Once] :: Floating a_Xgj3F)
                 (ds_dgjpe [Occ=Once] :: Op a_Xgj3F b_Xgj3H)
                 (eta_B1 [Occ=Once] :: b_Xgj3H) ->
                 atan
                   @ a_Xgj3F
                   $dFloating_Xgj3J
                   ((ds_dgjpe
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3F>_R <b_Xgj3H>_R
                             :: (Op a_Xgj3F b_Xgj3H :: *) ~R# (b_Xgj3H -> a_Xgj3F :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp7
  = \ (@ a_Xgj3F)
      (@ b_Xgj3H)
      ($dFloating_Xgj3J :: Floating a_Xgj3F)
      (ds_dgjpe :: Op a_Xgj3F b_Xgj3H)
      (eta_B1 :: b_Xgj3H) ->
      atan
        @ a_Xgj3F
        $dFloating_Xgj3J
        ((ds_dgjpe
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3F>_R <b_Xgj3H>_R
                  :: (Op a_Xgj3F b_Xgj3H :: *) ~R# (b_Xgj3H -> a_Xgj3F :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp6
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLC(S)LLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj3z)
                 (@ b_Xgj3B)
                 ($dFloating_Xgj3D [Occ=Once] :: Floating a_Xgj3z)
                 (ds_dgjpk [Occ=Once] :: Op a_Xgj3z b_Xgj3B)
                 (eta_B1 [Occ=Once] :: b_Xgj3B) ->
                 sinh
                   @ a_Xgj3z
                   $dFloating_Xgj3D
                   ((ds_dgjpk
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3z>_R <b_Xgj3B>_R
                             :: (Op a_Xgj3z b_Xgj3B :: *) ~R# (b_Xgj3B -> a_Xgj3z :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp6
  = \ (@ a_Xgj3z)
      (@ b_Xgj3B)
      ($dFloating_Xgj3D :: Floating a_Xgj3z)
      (ds_dgjpk :: Op a_Xgj3z b_Xgj3B)
      (eta_B1 :: b_Xgj3B) ->
      sinh
        @ a_Xgj3z
        $dFloating_Xgj3D
        ((ds_dgjpk
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3z>_R <b_Xgj3B>_R
                  :: (Op a_Xgj3z b_Xgj3B :: *) ~R# (b_Xgj3B -> a_Xgj3z :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp5
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj3t)
                 (@ b_Xgj3v)
                 ($dFloating_Xgj3x [Occ=Once] :: Floating a_Xgj3t)
                 (ds_dgjpq [Occ=Once] :: Op a_Xgj3t b_Xgj3v)
                 (eta_B1 [Occ=Once] :: b_Xgj3v) ->
                 cosh
                   @ a_Xgj3t
                   $dFloating_Xgj3x
                   ((ds_dgjpq
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3t>_R <b_Xgj3v>_R
                             :: (Op a_Xgj3t b_Xgj3v :: *) ~R# (b_Xgj3v -> a_Xgj3t :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp5
  = \ (@ a_Xgj3t)
      (@ b_Xgj3v)
      ($dFloating_Xgj3x :: Floating a_Xgj3t)
      (ds_dgjpq :: Op a_Xgj3t b_Xgj3v)
      (eta_B1 :: b_Xgj3v) ->
      cosh
        @ a_Xgj3t
        $dFloating_Xgj3x
        ((ds_dgjpq
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3t>_R <b_Xgj3v>_R
                  :: (Op a_Xgj3t b_Xgj3v :: *) ~R# (b_Xgj3v -> a_Xgj3t :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp4
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj3n)
                 (@ b_Xgj3p)
                 ($dFloating_Xgj3r [Occ=Once] :: Floating a_Xgj3n)
                 (ds_dgjpw [Occ=Once] :: Op a_Xgj3n b_Xgj3p)
                 (eta_B1 [Occ=Once] :: b_Xgj3p) ->
                 tanh
                   @ a_Xgj3n
                   $dFloating_Xgj3r
                   ((ds_dgjpw
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3n>_R <b_Xgj3p>_R
                             :: (Op a_Xgj3n b_Xgj3p :: *) ~R# (b_Xgj3p -> a_Xgj3n :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp4
  = \ (@ a_Xgj3n)
      (@ b_Xgj3p)
      ($dFloating_Xgj3r :: Floating a_Xgj3n)
      (ds_dgjpw :: Op a_Xgj3n b_Xgj3p)
      (eta_B1 :: b_Xgj3p) ->
      tanh
        @ a_Xgj3n
        $dFloating_Xgj3r
        ((ds_dgjpw
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3n>_R <b_Xgj3p>_R
                  :: (Op a_Xgj3n b_Xgj3p :: *) ~R# (b_Xgj3p -> a_Xgj3n :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp3
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLC(S)LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj3h)
                 (@ b_Xgj3j)
                 ($dFloating_Xgj3l [Occ=Once] :: Floating a_Xgj3h)
                 (ds_dgjpC [Occ=Once] :: Op a_Xgj3h b_Xgj3j)
                 (eta_B1 [Occ=Once] :: b_Xgj3j) ->
                 asinh
                   @ a_Xgj3h
                   $dFloating_Xgj3l
                   ((ds_dgjpC
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3h>_R <b_Xgj3j>_R
                             :: (Op a_Xgj3h b_Xgj3j :: *) ~R# (b_Xgj3j -> a_Xgj3h :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp3
  = \ (@ a_Xgj3h)
      (@ b_Xgj3j)
      ($dFloating_Xgj3l :: Floating a_Xgj3h)
      (ds_dgjpC :: Op a_Xgj3h b_Xgj3j)
      (eta_B1 :: b_Xgj3j) ->
      asinh
        @ a_Xgj3h
        $dFloating_Xgj3l
        ((ds_dgjpC
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3h>_R <b_Xgj3j>_R
                  :: (Op a_Xgj3h b_Xgj3j :: *) ~R# (b_Xgj3j -> a_Xgj3h :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp2
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLC(S)LLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj3b)
                 (@ b_Xgj3d)
                 ($dFloating_Xgj3f [Occ=Once] :: Floating a_Xgj3b)
                 (ds_dgjpI [Occ=Once] :: Op a_Xgj3b b_Xgj3d)
                 (eta_B1 [Occ=Once] :: b_Xgj3d) ->
                 acosh
                   @ a_Xgj3b
                   $dFloating_Xgj3f
                   ((ds_dgjpI
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3b>_R <b_Xgj3d>_R
                             :: (Op a_Xgj3b b_Xgj3d :: *) ~R# (b_Xgj3d -> a_Xgj3b :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp2
  = \ (@ a_Xgj3b)
      (@ b_Xgj3d)
      ($dFloating_Xgj3f :: Floating a_Xgj3b)
      (ds_dgjpI :: Op a_Xgj3b b_Xgj3d)
      (eta_B1 :: b_Xgj3d) ->
      acosh
        @ a_Xgj3b
        $dFloating_Xgj3f
        ((ds_dgjpI
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj3b>_R <b_Xgj3d>_R
                  :: (Op a_Xgj3b b_Xgj3d :: *) ~R# (b_Xgj3d -> a_Xgj3b :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp1
  :: forall a b. Floating a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLC(S)LLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agiZ4)
                 (@ b_agiZ5)
                 ($dFloating_agiZ6 [Occ=Once] :: Floating a_agiZ4)
                 (ds_dgjpO [Occ=Once] :: Op a_agiZ4 b_agiZ5)
                 (eta_B1 [Occ=Once] :: b_agiZ5) ->
                 atanh
                   @ a_agiZ4
                   $dFloating_agiZ6
                   ((ds_dgjpO
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_agiZ4>_R <b_agiZ5>_R
                             :: (Op a_agiZ4 b_agiZ5 :: *) ~R# (b_agiZ5 -> a_agiZ4 :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFloatingOp1
  = \ (@ a_agiZ4)
      (@ b_agiZ5)
      ($dFloating_agiZ6 :: Floating a_agiZ4)
      (ds_dgjpO :: Op a_agiZ4 b_agiZ5)
      (eta_B1 :: b_agiZ5) ->
      atanh
        @ a_agiZ4
        $dFloating_agiZ6
        ((ds_dgjpO
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_agiZ4>_R <b_agiZ5>_R
                  :: (Op a_agiZ4 b_agiZ5 :: *) ~R# (b_agiZ5 -> a_agiZ4 :: *)))
           eta_B1)

-- RHS size: {terms: 12, types: 14, coercions: 6, joins: 0/0}
Data.Functor.Contravariant.$fFractionalOp2
  :: forall a b. Fractional a => Op a b -> Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LL),1*U(A,1*C1(C1(U)),A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj8K)
                 (@ b_Xgj8M)
                 ($dFractional_Xgj8O [Occ=Once] :: Fractional a_Xgj8K)
                 (ds_dgjqc [Occ=Once] :: Op a_Xgj8K b_Xgj8M)
                 (ds1_dgjqd [Occ=Once] :: Op a_Xgj8K b_Xgj8M)
                 (a1_agiFR :: b_Xgj8M) ->
                 / @ a_Xgj8K
                   $dFractional_Xgj8O
                   ((ds_dgjqc
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj8K>_R <b_Xgj8M>_R
                             :: (Op a_Xgj8K b_Xgj8M :: *) ~R# (b_Xgj8M -> a_Xgj8K :: *)))
                      a1_agiFR)
                   ((ds1_dgjqd
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj8K>_R <b_Xgj8M>_R
                             :: (Op a_Xgj8K b_Xgj8M :: *) ~R# (b_Xgj8M -> a_Xgj8K :: *)))
                      a1_agiFR)}]
Data.Functor.Contravariant.$fFractionalOp2
  = \ (@ a_Xgj8K)
      (@ b_Xgj8M)
      ($dFractional_Xgj8O :: Fractional a_Xgj8K)
      (ds_dgjqc :: Op a_Xgj8K b_Xgj8M)
      (ds1_dgjqd :: Op a_Xgj8K b_Xgj8M)
      (a1_agiFR :: b_Xgj8M) ->
      / @ a_Xgj8K
        $dFractional_Xgj8O
        ((ds_dgjqc
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj8K>_R <b_Xgj8M>_R
                  :: (Op a_Xgj8K b_Xgj8M :: *) ~R# (b_Xgj8M -> a_Xgj8K :: *)))
           a1_agiFR)
        ((ds1_dgjqd
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj8K>_R <b_Xgj8M>_R
                  :: (Op a_Xgj8K b_Xgj8M :: *) ~R# (b_Xgj8M -> a_Xgj8K :: *)))
           a1_agiFR)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fFractionalOp1
  :: forall a b. Fractional a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)L),1*U(A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agj4M)
                 (@ b_agj4N)
                 ($dFractional_agj4O [Occ=Once] :: Fractional a_agj4M)
                 (ds_dgjqm [Occ=Once] :: Op a_agj4M b_agj4N)
                 (eta_B1 [Occ=Once] :: b_agj4N) ->
                 recip
                   @ a_agj4M
                   $dFractional_agj4O
                   ((ds_dgjqm
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_agj4M>_R <b_agj4N>_R
                             :: (Op a_agj4M b_agj4N :: *) ~R# (b_agj4N -> a_agj4M :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fFractionalOp1
  = \ (@ a_agj4M)
      (@ b_agj4N)
      ($dFractional_agj4O :: Fractional a_agj4M)
      (ds_dgjqm :: Op a_agj4M b_agj4N)
      (eta_B1 :: b_agj4N) ->
      recip
        @ a_agj4M
        $dFractional_agj4O
        ((ds_dgjqm
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_agj4M>_R <b_agj4N>_R
                  :: (Op a_agj4M b_agj4N :: *) ~R# (b_agj4N -> a_agj4M :: *)))
           eta_B1)

-- RHS size: {terms: 10, types: 10, coercions: 4, joins: 0/1}
Data.Functor.Contravariant.$fFractionalOp_$cfromRational
  :: forall a b. Fractional a => Rational -> Op a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agj4M)
                 (@ b_agj4N)
                 ($dFractional_agj4O [Occ=Once] :: Fractional a_agj4M)
                 (eta_B1 [Occ=Once] :: Rational) ->
                 let {
                   x_sgjy0 [Occ=OnceL] :: a_agj4M
                   [LclId]
                   x_sgjy0 = fromRational @ a_agj4M $dFractional_agj4O eta_B1 } in
                 (\ _ [Occ=Dead] -> x_sgjy0)
                 `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                                  <a_agj4M>_R <b_agj4N>_R)
                         :: (b_agj4N -> a_agj4M :: *) ~R# (Op a_agj4M b_agj4N :: *))}]
Data.Functor.Contravariant.$fFractionalOp_$cfromRational
  = \ (@ a_agj4M)
      (@ b_agj4N)
      ($dFractional_agj4O :: Fractional a_agj4M)
      (eta_B1 :: Rational) ->
      let {
        x_sgjy0 :: a_agj4M
        [LclId]
        x_sgjy0 = fromRational @ a_agj4M $dFractional_agj4O eta_B1 } in
      (\ _ [Occ=Dead] -> x_sgjy0)
      `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                       <a_agj4M>_R <b_agj4N>_R)
              :: (b_agj4N -> a_agj4M :: *) ~R# (Op a_agj4M b_agj4N :: *))

-- RHS size: {terms: 14, types: 13, coercions: 7, joins: 0/1}
Data.Functor.Contravariant.$fNumOp_$cnegate [InlPrag=INLINE (sat-args=1)]
  :: forall a b. Num a => Op a b -> Op a b
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(U)),A,A,A,A,1*C1(U))><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_Xgjab)
                 (@ b_Xgjad)
                 ($dNum_Xgjaf :: Num a_Xgjab)
                 (x_igjqT [Occ=OnceL] :: Op a_Xgjab b_Xgjad) ->
                 let {
                   x1_i7Sb8 [Occ=OnceL] :: a_Xgjab
                   [LclId]
                   x1_i7Sb8 = fromInteger @ a_Xgjab $dNum_Xgjaf 0 } in
                 (\ (a1_agiG3 [Occ=Once] :: b_Xgjad) ->
                    - @ a_Xgjab
                      $dNum_Xgjaf
                      x1_i7Sb8
                      ((x_igjqT
                        `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgjab>_R <b_Xgjad>_R
                                :: (Op a_Xgjab b_Xgjad :: *) ~R# (b_Xgjad -> a_Xgjab :: *)))
                         a1_agiG3))
                 `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                                  <a_Xgjab>_R <b_Xgjad>_R)
                         :: (b_Xgjad -> a_Xgjab :: *) ~R# (Op a_Xgjab b_Xgjad :: *))}]
Data.Functor.Contravariant.$fNumOp_$cnegate
  = \ (@ a_Xgjab)
      (@ b_Xgjad)
      ($dNum_Xgjaf :: Num a_Xgjab)
      (eta_B1 :: Op a_Xgjab b_Xgjad) ->
      let {
        x_sgjy2 :: a_Xgjab
        [LclId]
        x_sgjy2 = fromInteger @ a_Xgjab $dNum_Xgjaf lvl1_rgjLs } in
      (\ (a1_agiG3 :: b_Xgjad) ->
         - @ a_Xgjab
           $dNum_Xgjaf
           x_sgjy2
           ((eta_B1
             `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgjab>_R <b_Xgjad>_R
                     :: (Op a_Xgjab b_Xgjad :: *) ~R# (b_Xgjad -> a_Xgjab :: *)))
              a1_agiG3))
      `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                       <a_Xgjab>_R <b_Xgjad>_R)
              :: (b_Xgjad -> a_Xgjab :: *) ~R# (Op a_Xgjab b_Xgjad :: *))

-- RHS size: {terms: 12, types: 14, coercions: 6, joins: 0/0}
Data.Functor.Contravariant.$fNumOp5
  :: forall a b. Num a => Op a b -> Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgja3)
                 (@ b_Xgja5)
                 ($dNum_Xgja7 [Occ=Once] :: Num a_Xgja3)
                 (ds_dgjqt [Occ=Once] :: Op a_Xgja3 b_Xgja5)
                 (ds1_dgjqu [Occ=Once] :: Op a_Xgja3 b_Xgja5)
                 (a1_agiFX :: b_Xgja5) ->
                 + @ a_Xgja3
                   $dNum_Xgja7
                   ((ds_dgjqt
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgja3>_R <b_Xgja5>_R
                             :: (Op a_Xgja3 b_Xgja5 :: *) ~R# (b_Xgja5 -> a_Xgja3 :: *)))
                      a1_agiFX)
                   ((ds1_dgjqu
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgja3>_R <b_Xgja5>_R
                             :: (Op a_Xgja3 b_Xgja5 :: *) ~R# (b_Xgja5 -> a_Xgja3 :: *)))
                      a1_agiFX)}]
Data.Functor.Contravariant.$fNumOp5
  = \ (@ a_Xgja3)
      (@ b_Xgja5)
      ($dNum_Xgja7 :: Num a_Xgja3)
      (ds_dgjqt :: Op a_Xgja3 b_Xgja5)
      (ds1_dgjqu :: Op a_Xgja3 b_Xgja5)
      (a1_agiFX :: b_Xgja5) ->
      + @ a_Xgja3
        $dNum_Xgja7
        ((ds_dgjqt
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgja3>_R <b_Xgja5>_R
                  :: (Op a_Xgja3 b_Xgja5 :: *) ~R# (b_Xgja5 -> a_Xgja3 :: *)))
           a1_agiFX)
        ((ds1_dgjqu
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgja3>_R <b_Xgja5>_R
                  :: (Op a_Xgja3 b_Xgja5 :: *) ~R# (b_Xgja5 -> a_Xgja3 :: *)))
           a1_agiFX)

-- RHS size: {terms: 12, types: 14, coercions: 6, joins: 0/0}
Data.Functor.Contravariant.$fNumOp4
  :: forall a b. Num a => Op a b -> Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj9W)
                 (@ b_Xgj9Y)
                 ($dNum_Xgja0 [Occ=Once] :: Num a_Xgj9W)
                 (ds_dgjqB [Occ=Once] :: Op a_Xgj9W b_Xgj9Y)
                 (ds1_dgjqC [Occ=Once] :: Op a_Xgj9W b_Xgj9Y)
                 (a1_agiG3 :: b_Xgj9Y) ->
                 - @ a_Xgj9W
                   $dNum_Xgja0
                   ((ds_dgjqB
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9W>_R <b_Xgj9Y>_R
                             :: (Op a_Xgj9W b_Xgj9Y :: *) ~R# (b_Xgj9Y -> a_Xgj9W :: *)))
                      a1_agiG3)
                   ((ds1_dgjqC
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9W>_R <b_Xgj9Y>_R
                             :: (Op a_Xgj9W b_Xgj9Y :: *) ~R# (b_Xgj9Y -> a_Xgj9W :: *)))
                      a1_agiG3)}]
Data.Functor.Contravariant.$fNumOp4
  = \ (@ a_Xgj9W)
      (@ b_Xgj9Y)
      ($dNum_Xgja0 :: Num a_Xgj9W)
      (ds_dgjqB :: Op a_Xgj9W b_Xgj9Y)
      (ds1_dgjqC :: Op a_Xgj9W b_Xgj9Y)
      (a1_agiG3 :: b_Xgj9Y) ->
      - @ a_Xgj9W
        $dNum_Xgja0
        ((ds_dgjqB
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9W>_R <b_Xgj9Y>_R
                  :: (Op a_Xgj9W b_Xgj9Y :: *) ~R# (b_Xgj9Y -> a_Xgj9W :: *)))
           a1_agiG3)
        ((ds1_dgjqC
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9W>_R <b_Xgj9Y>_R
                  :: (Op a_Xgj9W b_Xgj9Y :: *) ~R# (b_Xgj9Y -> a_Xgj9W :: *)))
           a1_agiG3)

-- RHS size: {terms: 12, types: 14, coercions: 6, joins: 0/0}
Data.Functor.Contravariant.$fNumOp3
  :: forall a b. Num a => Op a b -> Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj9A)
                 (@ b_Xgj9C)
                 ($dNum_Xgj9E [Occ=Once] :: Num a_Xgj9A)
                 (ds_dgjqJ [Occ=Once] :: Op a_Xgj9A b_Xgj9C)
                 (ds1_dgjqK [Occ=Once] :: Op a_Xgj9A b_Xgj9C)
                 (a1_agiG0 :: b_Xgj9C) ->
                 * @ a_Xgj9A
                   $dNum_Xgj9E
                   ((ds_dgjqJ
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9A>_R <b_Xgj9C>_R
                             :: (Op a_Xgj9A b_Xgj9C :: *) ~R# (b_Xgj9C -> a_Xgj9A :: *)))
                      a1_agiG0)
                   ((ds1_dgjqK
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9A>_R <b_Xgj9C>_R
                             :: (Op a_Xgj9A b_Xgj9C :: *) ~R# (b_Xgj9C -> a_Xgj9A :: *)))
                      a1_agiG0)}]
Data.Functor.Contravariant.$fNumOp3
  = \ (@ a_Xgj9A)
      (@ b_Xgj9C)
      ($dNum_Xgj9E :: Num a_Xgj9A)
      (ds_dgjqJ :: Op a_Xgj9A b_Xgj9C)
      (ds1_dgjqK :: Op a_Xgj9A b_Xgj9C)
      (a1_agiG0 :: b_Xgj9C) ->
      * @ a_Xgj9A
        $dNum_Xgj9E
        ((ds_dgjqJ
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9A>_R <b_Xgj9C>_R
                  :: (Op a_Xgj9A b_Xgj9C :: *) ~R# (b_Xgj9C -> a_Xgj9A :: *)))
           a1_agiG0)
        ((ds1_dgjqK
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9A>_R <b_Xgj9C>_R
                  :: (Op a_Xgj9A b_Xgj9C :: *) ~R# (b_Xgj9C -> a_Xgj9A :: *)))
           a1_agiG0)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fNumOp2
  :: forall a b. Num a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)LL),1*U(A,A,A,A,1*C1(U),A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj9u)
                 (@ b_Xgj9w)
                 ($dNum_Xgj9y [Occ=Once] :: Num a_Xgj9u)
                 (ds_dgjqU [Occ=Once] :: Op a_Xgj9u b_Xgj9w)
                 (eta_B1 [Occ=Once] :: b_Xgj9w) ->
                 abs
                   @ a_Xgj9u
                   $dNum_Xgj9y
                   ((ds_dgjqU
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9u>_R <b_Xgj9w>_R
                             :: (Op a_Xgj9u b_Xgj9w :: *) ~R# (b_Xgj9w -> a_Xgj9u :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fNumOp2
  = \ (@ a_Xgj9u)
      (@ b_Xgj9w)
      ($dNum_Xgj9y :: Num a_Xgj9u)
      (ds_dgjqU :: Op a_Xgj9u b_Xgj9w)
      (eta_B1 :: b_Xgj9w) ->
      abs
        @ a_Xgj9u
        $dNum_Xgj9y
        ((ds_dgjqU
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_Xgj9u>_R <b_Xgj9w>_R
                  :: (Op a_Xgj9u b_Xgj9w :: *) ~R# (b_Xgj9w -> a_Xgj9u :: *)))
           eta_B1)

-- RHS size: {terms: 9, types: 11, coercions: 3, joins: 0/0}
Data.Functor.Contravariant.$fNumOp1
  :: forall a b. Num a => Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(S)L),1*U(A,A,A,A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agj5O)
                 (@ b_agj5P)
                 ($dNum_agj5Q [Occ=Once] :: Num a_agj5O)
                 (ds_dgjqY [Occ=Once] :: Op a_agj5O b_agj5P)
                 (eta_B1 [Occ=Once] :: b_agj5P) ->
                 signum
                   @ a_agj5O
                   $dNum_agj5Q
                   ((ds_dgjqY
                     `cast` (Data.Functor.Contravariant.N:Op[0] <a_agj5O>_R <b_agj5P>_R
                             :: (Op a_agj5O b_agj5P :: *) ~R# (b_agj5P -> a_agj5O :: *)))
                      eta_B1)}]
Data.Functor.Contravariant.$fNumOp1
  = \ (@ a_agj5O)
      (@ b_agj5P)
      ($dNum_agj5Q :: Num a_agj5O)
      (ds_dgjqY :: Op a_agj5O b_agj5P)
      (eta_B1 :: b_agj5P) ->
      signum
        @ a_agj5O
        $dNum_agj5Q
        ((ds_dgjqY
          `cast` (Data.Functor.Contravariant.N:Op[0] <a_agj5O>_R <b_agj5P>_R
                  :: (Op a_agj5O b_agj5P :: *) ~R# (b_agj5P -> a_agj5O :: *)))
           eta_B1)

-- RHS size: {terms: 10, types: 10, coercions: 4, joins: 0/1}
Data.Functor.Contravariant.$fNumOp_$cfromInteger
  :: forall a b. Num a => Integer -> Op a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agj5O)
                 (@ b_agj5P)
                 ($dNum_agj5Q [Occ=Once] :: Num a_agj5O)
                 (eta_B1 [Occ=Once] :: Integer) ->
                 let {
                   x_sgjy4 [Occ=OnceL] :: a_agj5O
                   [LclId]
                   x_sgjy4 = fromInteger @ a_agj5O $dNum_agj5Q eta_B1 } in
                 (\ _ [Occ=Dead] -> x_sgjy4)
                 `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                                  <a_agj5O>_R <b_agj5P>_R)
                         :: (b_agj5P -> a_agj5O :: *) ~R# (Op a_agj5O b_agj5P :: *))}]
Data.Functor.Contravariant.$fNumOp_$cfromInteger
  = \ (@ a_agj5O)
      (@ b_agj5P)
      ($dNum_agj5Q :: Num a_agj5O)
      (eta_B1 :: Integer) ->
      let {
        x_sgjy4 :: a_agj5O
        [LclId]
        x_sgjy4 = fromInteger @ a_agj5O $dNum_agj5Q eta_B1 } in
      (\ _ [Occ=Dead] -> x_sgjy4)
      `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                       <a_agj5O>_R <b_agj5P>_R)
              :: (b_agj5P -> a_agj5O :: *) ~R# (Op a_agj5O b_agj5P :: *))

-- RHS size: {terms: 18, types: 23, coercions: 52, joins: 0/0}
Data.Functor.Contravariant.$fNumOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. Num a => Num (Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))>m,
 Unf=DFun: \ (@ a_agiFT) (@ b_agiFU) (v_B1 :: Num a_agiFT) ->
       GHC.Num.C:Num TYPE: Op a_agiFT b_agiFU
                     (Data.Functor.Contravariant.$fNumOp5 @ a_agiFT @ b_agiFU v_B1)
                     `cast` (<Op a_agiFT b_agiFU>_R
                             ->_R <Op a_agiFT b_agiFU>_R
                             ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                           <a_agiFT>_R <b_agiFU>_R)
                             :: (Op a_agiFT b_agiFU
                                 -> Op a_agiFT b_agiFU -> b_agiFU -> a_agiFT :: *)
                                ~R# (Op a_agiFT b_agiFU
                                     -> Op a_agiFT b_agiFU -> Op a_agiFT b_agiFU :: *))
                     (Data.Functor.Contravariant.$fNumOp4 @ a_agiFT @ b_agiFU v_B1)
                     `cast` (<Op a_agiFT b_agiFU>_R
                             ->_R <Op a_agiFT b_agiFU>_R
                             ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                           <a_agiFT>_R <b_agiFU>_R)
                             :: (Op a_agiFT b_agiFU
                                 -> Op a_agiFT b_agiFU -> b_agiFU -> a_agiFT :: *)
                                ~R# (Op a_agiFT b_agiFU
                                     -> Op a_agiFT b_agiFU -> Op a_agiFT b_agiFU :: *))
                     (Data.Functor.Contravariant.$fNumOp3 @ a_agiFT @ b_agiFU v_B1)
                     `cast` (<Op a_agiFT b_agiFU>_R
                             ->_R <Op a_agiFT b_agiFU>_R
                             ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                           <a_agiFT>_R <b_agiFU>_R)
                             :: (Op a_agiFT b_agiFU
                                 -> Op a_agiFT b_agiFU -> b_agiFU -> a_agiFT :: *)
                                ~R# (Op a_agiFT b_agiFU
                                     -> Op a_agiFT b_agiFU -> Op a_agiFT b_agiFU :: *))
                     Data.Functor.Contravariant.$fNumOp_$cnegate
                       @ a_agiFT @ b_agiFU v_B1
                     (Data.Functor.Contravariant.$fNumOp2 @ a_agiFT @ b_agiFU v_B1)
                     `cast` (<Op a_agiFT b_agiFU>_R
                             ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                           <a_agiFT>_R <b_agiFU>_R)
                             :: (Op a_agiFT b_agiFU -> b_agiFU -> a_agiFT :: *)
                                ~R# (Op a_agiFT b_agiFU -> Op a_agiFT b_agiFU :: *))
                     (Data.Functor.Contravariant.$fNumOp1 @ a_agiFT @ b_agiFU v_B1)
                     `cast` (<Op a_agiFT b_agiFU>_R
                             ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                           <a_agiFT>_R <b_agiFU>_R)
                             :: (Op a_agiFT b_agiFU -> b_agiFU -> a_agiFT :: *)
                                ~R# (Op a_agiFT b_agiFU -> Op a_agiFT b_agiFU :: *))
                     Data.Functor.Contravariant.$fNumOp_$cfromInteger
                       @ a_agiFT @ b_agiFU v_B1]
Data.Functor.Contravariant.$fNumOp
  = \ (@ a_Xgjaa) (@ b_Xgjac) ($dNum_Xgjae :: Num a_Xgjaa) ->
      GHC.Num.C:Num
        @ (Op a_Xgjaa b_Xgjac)
        ((Data.Functor.Contravariant.$fNumOp5
            @ a_Xgjaa @ b_Xgjac $dNum_Xgjae)
         `cast` (<Op a_Xgjaa b_Xgjac>_R
                 ->_R <Op a_Xgjaa b_Xgjac>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgjaa>_R <b_Xgjac>_R)
                 :: (Op a_Xgjaa b_Xgjac
                     -> Op a_Xgjaa b_Xgjac -> b_Xgjac -> a_Xgjaa :: *)
                    ~R# (Op a_Xgjaa b_Xgjac
                         -> Op a_Xgjaa b_Xgjac -> Op a_Xgjaa b_Xgjac :: *)))
        ((Data.Functor.Contravariant.$fNumOp4
            @ a_Xgjaa @ b_Xgjac $dNum_Xgjae)
         `cast` (<Op a_Xgjaa b_Xgjac>_R
                 ->_R <Op a_Xgjaa b_Xgjac>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgjaa>_R <b_Xgjac>_R)
                 :: (Op a_Xgjaa b_Xgjac
                     -> Op a_Xgjaa b_Xgjac -> b_Xgjac -> a_Xgjaa :: *)
                    ~R# (Op a_Xgjaa b_Xgjac
                         -> Op a_Xgjaa b_Xgjac -> Op a_Xgjaa b_Xgjac :: *)))
        ((Data.Functor.Contravariant.$fNumOp3
            @ a_Xgjaa @ b_Xgjac $dNum_Xgjae)
         `cast` (<Op a_Xgjaa b_Xgjac>_R
                 ->_R <Op a_Xgjaa b_Xgjac>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgjaa>_R <b_Xgjac>_R)
                 :: (Op a_Xgjaa b_Xgjac
                     -> Op a_Xgjaa b_Xgjac -> b_Xgjac -> a_Xgjaa :: *)
                    ~R# (Op a_Xgjaa b_Xgjac
                         -> Op a_Xgjaa b_Xgjac -> Op a_Xgjaa b_Xgjac :: *)))
        (Data.Functor.Contravariant.$fNumOp_$cnegate
           @ a_Xgjaa @ b_Xgjac $dNum_Xgjae)
        ((Data.Functor.Contravariant.$fNumOp2
            @ a_Xgjaa @ b_Xgjac $dNum_Xgjae)
         `cast` (<Op a_Xgjaa b_Xgjac>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgjaa>_R <b_Xgjac>_R)
                 :: (Op a_Xgjaa b_Xgjac -> b_Xgjac -> a_Xgjaa :: *)
                    ~R# (Op a_Xgjaa b_Xgjac -> Op a_Xgjaa b_Xgjac :: *)))
        ((Data.Functor.Contravariant.$fNumOp1
            @ a_Xgjaa @ b_Xgjac $dNum_Xgjae)
         `cast` (<Op a_Xgjaa b_Xgjac>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgjaa>_R <b_Xgjac>_R)
                 :: (Op a_Xgjaa b_Xgjac -> b_Xgjac -> a_Xgjaa :: *)
                    ~R# (Op a_Xgjaa b_Xgjac -> Op a_Xgjaa b_Xgjac :: *)))
        (Data.Functor.Contravariant.$fNumOp_$cfromInteger
           @ a_Xgjaa @ b_Xgjac $dNum_Xgjae)

-- RHS size: {terms: 6, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional
  :: forall a b. Fractional a => Num (Op a b)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj9j)
                 (@ b_Xgj9l)
                 ($dFractional_Xgj9n [Occ=Once] :: Fractional a_Xgj9j) ->
                 Data.Functor.Contravariant.$fNumOp
                   @ a_Xgj9j
                   @ b_Xgj9l
                   (GHC.Real.$p1Fractional @ a_Xgj9j $dFractional_Xgj9n)}]
Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional
  = \ (@ a_Xgj9j)
      (@ b_Xgj9l)
      ($dFractional_Xgj9n :: Fractional a_Xgj9j) ->
      Data.Functor.Contravariant.$fNumOp
        @ a_Xgj9j
        @ b_Xgj9l
        (GHC.Real.$p1Fractional @ a_Xgj9j $dFractional_Xgj9n)

-- RHS size: {terms: 12, types: 17, coercions: 20, joins: 0/0}
Data.Functor.Contravariant.$fFractionalOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. Fractional a => Fractional (Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U))>m,
 Unf=DFun: \ (@ a_agiFN) (@ b_agiFO) (v_B1 :: Fractional a_agiFN) ->
       GHC.Real.C:Fractional TYPE: Op a_agiFN b_agiFO
                             Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional
                               @ a_agiFN @ b_agiFO v_B1
                             (Data.Functor.Contravariant.$fFractionalOp2
                                @ a_agiFN @ b_agiFO v_B1)
                             `cast` (<Op a_agiFN b_agiFO>_R
                                     ->_R <Op a_agiFN b_agiFO>_R
                                     ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                   <a_agiFN>_R <b_agiFO>_R)
                                     :: (Op a_agiFN b_agiFO
                                         -> Op a_agiFN b_agiFO -> b_agiFO -> a_agiFN :: *)
                                        ~R# (Op a_agiFN b_agiFO
                                             -> Op a_agiFN b_agiFO -> Op a_agiFN b_agiFO :: *))
                             (Data.Functor.Contravariant.$fFractionalOp1
                                @ a_agiFN @ b_agiFO v_B1)
                             `cast` (<Op a_agiFN b_agiFO>_R
                                     ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                   <a_agiFN>_R <b_agiFO>_R)
                                     :: (Op a_agiFN b_agiFO -> b_agiFO -> a_agiFN :: *)
                                        ~R# (Op a_agiFN b_agiFO -> Op a_agiFN b_agiFO :: *))
                             Data.Functor.Contravariant.$fFractionalOp_$cfromRational
                               @ a_agiFN @ b_agiFO v_B1]
Data.Functor.Contravariant.$fFractionalOp
  = \ (@ a_Xgj9k)
      (@ b_Xgj9m)
      ($dFractional_Xgj9o :: Fractional a_Xgj9k) ->
      GHC.Real.C:Fractional
        @ (Op a_Xgj9k b_Xgj9m)
        (Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional
           @ a_Xgj9k @ b_Xgj9m $dFractional_Xgj9o)
        ((Data.Functor.Contravariant.$fFractionalOp2
            @ a_Xgj9k @ b_Xgj9m $dFractional_Xgj9o)
         `cast` (<Op a_Xgj9k b_Xgj9m>_R
                 ->_R <Op a_Xgj9k b_Xgj9m>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9k>_R <b_Xgj9m>_R)
                 :: (Op a_Xgj9k b_Xgj9m
                     -> Op a_Xgj9k b_Xgj9m -> b_Xgj9m -> a_Xgj9k :: *)
                    ~R# (Op a_Xgj9k b_Xgj9m
                         -> Op a_Xgj9k b_Xgj9m -> Op a_Xgj9k b_Xgj9m :: *)))
        ((Data.Functor.Contravariant.$fFractionalOp1
            @ a_Xgj9k @ b_Xgj9m $dFractional_Xgj9o)
         `cast` (<Op a_Xgj9k b_Xgj9m>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9k>_R <b_Xgj9m>_R)
                 :: (Op a_Xgj9k b_Xgj9m -> b_Xgj9m -> a_Xgj9k :: *)
                    ~R# (Op a_Xgj9k b_Xgj9m -> Op a_Xgj9k b_Xgj9m :: *)))
        (Data.Functor.Contravariant.$fFractionalOp_$cfromRational
           @ a_Xgj9k @ b_Xgj9m $dFractional_Xgj9o)

-- RHS size: {terms: 6, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fFloatingOp_$cp1Floating
  :: forall a b. Floating a => Fractional (Op a b)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj9H)
                 (@ b_Xgj9K)
                 ($dFloating_Xgj9N [Occ=Once] :: Floating a_Xgj9H) ->
                 Data.Functor.Contravariant.$fFractionalOp
                   @ a_Xgj9H
                   @ b_Xgj9K
                   (GHC.Float.$p1Floating @ a_Xgj9H $dFloating_Xgj9N)}]
Data.Functor.Contravariant.$fFloatingOp_$cp1Floating
  = \ (@ a_Xgj9H)
      (@ b_Xgj9K)
      ($dFloating_Xgj9N :: Floating a_Xgj9H) ->
      Data.Functor.Contravariant.$fFractionalOp
        @ a_Xgj9H
        @ b_Xgj9K
        (GHC.Float.$p1Floating @ a_Xgj9H $dFloating_Xgj9N)

-- RHS size: {terms: 53, types: 56, coercions: 148, joins: 0/1}
Data.Functor.Contravariant.$fFloatingOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. Floating a => Floating (Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U)),1*U,C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),A,A,A,A)>,
 Unf=DFun: \ (@ a_agiFq) (@ b_agiFr) (v_B1 :: Floating a_agiFq) ->
       GHC.Float.C:Floating TYPE: Op a_agiFq b_agiFr
                            Data.Functor.Contravariant.$fFloatingOp_$cp1Floating
                              @ a_agiFq @ b_agiFr v_B1
                            (\ _ [Occ=Dead] -> pi @ a_agiFq v_B1)
                            `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                                             <a_agiFq>_R <b_agiFr>_R)
                                    :: (b_agiFr -> a_agiFq :: *) ~R# (Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp17
                               @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp16
                               @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp15
                               @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp14
                               @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R <Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr
                                        -> Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr
                                            -> Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp13
                               @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R <Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr
                                        -> Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr
                                            -> Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp12
                               @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp11
                               @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp10
                               @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp9 @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp8 @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp7 @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp6 @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp5 @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp4 @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp3 @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp2 @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            (Data.Functor.Contravariant.$fFloatingOp1 @ a_agiFq @ b_agiFr v_B1)
                            `cast` (<Op a_agiFq b_agiFr>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                                                  <a_agiFq>_R <b_agiFr>_R)
                                    :: (Op a_agiFq b_agiFr -> b_agiFr -> a_agiFq :: *)
                                       ~R# (Op a_agiFq b_agiFr -> Op a_agiFq b_agiFr :: *))
                            Data.Functor.Contravariant.$fFloatingOp_$clog1p
                              @ a_agiFq @ b_agiFr v_B1
                            Data.Functor.Contravariant.$fFloatingOp_$cexpm1
                              @ a_agiFq @ b_agiFr v_B1
                            Data.Functor.Contravariant.$fFloatingOp_$clog1pexp
                              @ a_agiFq @ b_agiFr v_B1
                            Data.Functor.Contravariant.$fFloatingOp_$clog1mexp
                              @ a_agiFq @ b_agiFr v_B1]
Data.Functor.Contravariant.$fFloatingOp
  = \ (@ a_Xgj9N)
      (@ b_Xgj9Q)
      ($dFloating_Xgj4c :: Floating a_Xgj9N) ->
      let {
        lvl7_sgjzf :: a_Xgj9N
        [LclId]
        lvl7_sgjzf = pi @ a_Xgj9N $dFloating_Xgj4c } in
      GHC.Float.C:Floating
        @ (Op a_Xgj9N b_Xgj9Q)
        (Data.Functor.Contravariant.$fFloatingOp_$cp1Floating
           @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
        ((\ _ [Occ=Dead] -> lvl7_sgjzf)
         `cast` (Sym (Data.Functor.Contravariant.N:Op[0]
                          <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (b_Xgj9Q -> a_Xgj9N :: *) ~R# (Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp17
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp16
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp15
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp14
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R <Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q
                     -> Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q
                         -> Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp13
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R <Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q
                     -> Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q
                         -> Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp12
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp11
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp10
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp9
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp8
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp7
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp6
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp5
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp4
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp3
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp2
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        ((Data.Functor.Contravariant.$fFloatingOp1
            @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
         `cast` (<Op a_Xgj9N b_Xgj9Q>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Op[0]
                               <a_Xgj9N>_R <b_Xgj9Q>_R)
                 :: (Op a_Xgj9N b_Xgj9Q -> b_Xgj9Q -> a_Xgj9N :: *)
                    ~R# (Op a_Xgj9N b_Xgj9Q -> Op a_Xgj9N b_Xgj9Q :: *)))
        (Data.Functor.Contravariant.$fFloatingOp_$clog1p
           @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
        (Data.Functor.Contravariant.$fFloatingOp_$cexpm1
           @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
        (Data.Functor.Contravariant.$fFloatingOp_$clog1pexp
           @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)
        (Data.Functor.Contravariant.$fFloatingOp_$clog1mexp
           @ a_Xgj9N @ b_Xgj9Q $dFloating_Xgj4c)

-- RHS size: {terms: 8, types: 15, coercions: 6, joins: 0/0}
Data.Functor.Contravariant.$fCategoryTYPEOp1
  :: forall b c a. Op b c -> Op a b -> c -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_agj8j)
                 (@ c_agj8k)
                 (@ a_agj8l)
                 (ds_dgjr5 [Occ=Once] :: Op b_agj8j c_agj8k)
                 (ds1_dgjr6 [Occ=Once] :: Op a_agj8l b_agj8j) ->
                 GHC.Base..
                   @ b_agj8j
                   @ a_agj8l
                   @ c_agj8k
                   (ds1_dgjr6
                    `cast` (Data.Functor.Contravariant.N:Op[0] <a_agj8l>_R <b_agj8j>_R
                            :: (Op a_agj8l b_agj8j :: *) ~R# (b_agj8j -> a_agj8l :: *)))
                   (ds_dgjr5
                    `cast` (Data.Functor.Contravariant.N:Op[0] <b_agj8j>_R <c_agj8k>_R
                            :: (Op b_agj8j c_agj8k :: *) ~R# (c_agj8k -> b_agj8j :: *)))}]
Data.Functor.Contravariant.$fCategoryTYPEOp1
  = \ (@ b_agj8j)
      (@ c_agj8k)
      (@ a_agj8l)
      (ds_dgjr5 :: Op b_agj8j c_agj8k)
      (ds1_dgjr6 :: Op a_agj8l b_agj8j) ->
      GHC.Base..
        @ b_agj8j
        @ a_agj8l
        @ c_agj8k
        (ds1_dgjr6
         `cast` (Data.Functor.Contravariant.N:Op[0] <a_agj8l>_R <b_agj8j>_R
                 :: (Op a_agj8l b_agj8j :: *) ~R# (b_agj8j -> a_agj8l :: *)))
        (ds_dgjr5
         `cast` (Data.Functor.Contravariant.N:Op[0] <b_agj8j>_R <c_agj8k>_R
                 :: (Op b_agj8j c_agj8k :: *) ~R# (c_agj8k -> b_agj8j :: *)))

-- RHS size: {terms: 3, types: 3, coercions: 28, joins: 0/0}
Data.Functor.Contravariant.$fCategoryTYPEOp [InlPrag=NOUSERINLINE CONLIKE]
  :: Category Op
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Control.Category.C:Category TYPE: *
                                   TYPE: Op
                                   GHC.Base.id
                                   `cast` (forall (a :: <*>_N).
                                           Sym (Data.Functor.Contravariant.N:Op[0] <a>_R <a>_R)
                                           :: (forall a. a -> a :: *) ~R# (forall a. Op a a :: *))
                                   Data.Functor.Contravariant.$fCategoryTYPEOp1
                                   `cast` (forall (b :: <*>_N) (c :: <*>_N) (a :: <*>_N).
                                           <Op b c>_R
                                           ->_R <Op a b>_R
                                           ->_R Sym (Data.Functor.Contravariant.N:Op[0] <a>_R <c>_R)
                                           :: (forall b c a. Op b c -> Op a b -> c -> a :: *)
                                              ~R# (forall b c a. Op b c -> Op a b -> Op a c :: *))]
Data.Functor.Contravariant.$fCategoryTYPEOp
  = Control.Category.C:Category
      @ *
      @ Op
      (GHC.Base.id
       `cast` (forall (a :: <*>_N).
               Sym (Data.Functor.Contravariant.N:Op[0] <a>_R <a>_R)
               :: (forall a. a -> a :: *) ~R# (forall a. Op a a :: *)))
      (Data.Functor.Contravariant.$fCategoryTYPEOp1
       `cast` (forall (b :: <*>_N) (c :: <*>_N) (a :: <*>_N).
               <Op b c>_R
               ->_R <Op a b>_R
               ->_R Sym (Data.Functor.Contravariant.N:Op[0] <a>_R <c>_R)
               :: (forall b c a. Op b c -> Op a b -> c -> a :: *)
                  ~R# (forall b c a. Op b c -> Op a b -> Op a c :: *)))

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fMonoidEquivalence3
  :: forall a. a -> a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agj8B) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.True}]
Data.Functor.Contravariant.$fMonoidEquivalence3
  = \ (@ a_agj8B) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.True

Rec {
-- RHS size: {terms: 24, types: 21, coercions: 7, joins: 0/1}
Data.Functor.Contravariant.$fSemigroupEquivalence1 [Occ=LoopBreaker]
  :: forall a. Equivalence a -> [Equivalence a] -> Equivalence a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,1*U>, Unf=OtherCon []]
Data.Functor.Contravariant.$fSemigroupEquivalence1
  = \ (@ a_XgjcG)
      (b_i9ine :: Equivalence a_XgjcG)
      (ds1_i9inf :: [Equivalence a_XgjcG]) ->
      case ds1_i9inf of {
        [] -> b_i9ine;
        : c_i9inn cs_i9ino ->
          let {
            ds_sgjy8 [Dmd=<L,C(C1(U))>] :: Equivalence a_XgjcG
            [LclId]
            ds_sgjy8
              = Data.Functor.Contravariant.$fSemigroupEquivalence1
                  @ a_XgjcG c_i9inn cs_i9ino } in
          (\ (a1_agiGf :: a_XgjcG) (b1_agiGg :: a_XgjcG) ->
             case (b_i9ine
                   `cast` (Data.Functor.Contravariant.N:Equivalence[0] <a_XgjcG>_R
                           :: (Equivalence a_XgjcG :: *)
                              ~R# (a_XgjcG -> a_XgjcG -> Bool :: *)))
                    a1_agiGf b1_agiGg
             of {
               False -> GHC.Types.False;
               True ->
                 (ds_sgjy8
                  `cast` (Data.Functor.Contravariant.N:Equivalence[0] <a_XgjcG>_R
                          :: (Equivalence a_XgjcG :: *)
                             ~R# (a_XgjcG -> a_XgjcG -> Bool :: *)))
                   a1_agiGf b1_agiGg
             })
          `cast` (Sym (Data.Functor.Contravariant.N:Equivalence[0]
                           <a_XgjcG>_R)
                  :: (a_XgjcG -> a_XgjcG -> Bool :: *)
                     ~R# (Equivalence a_XgjcG :: *))
      }
end Rec }

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat
  :: forall a. GHC.Base.NonEmpty (Equivalence a) -> Equivalence a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgjcG)
                 (ds_i9in9 [Occ=Once!]
                    :: GHC.Base.NonEmpty (Equivalence a_XgjcG)) ->
                 case ds_i9in9 of
                 { GHC.Base.:| a1_i9ing [Occ=Once] as_i9inh [Occ=Once] ->
                 Data.Functor.Contravariant.$fSemigroupEquivalence1
                   @ a_XgjcG a1_i9ing as_i9inh
                 }}]
Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat
  = \ (@ a_XgjcG)
      (ds_i9in9 :: GHC.Base.NonEmpty (Equivalence a_XgjcG)) ->
      case ds_i9in9 of { GHC.Base.:| a1_i9ing as_i9inh ->
      Data.Functor.Contravariant.$fSemigroupEquivalence1
        @ a_XgjcG a1_i9ing as_i9inh
      }

-- RHS size: {terms: 15, types: 9, coercions: 4, joins: 0/0}
Data.Functor.Contravariant.$fMonoidEquivalence2
  :: forall a. Equivalence a -> Equivalence a -> a -> a -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agj8X)
                 (ds_dgjri [Occ=Once] :: Equivalence a_agj8X)
                 (ds1_dgjrj [Occ=Once] :: Equivalence a_agj8X)
                 (a1_agiGf :: a_agj8X)
                 (b_agiGg :: a_agj8X) ->
                 case (ds_dgjri
                       `cast` (Data.Functor.Contravariant.N:Equivalence[0] <a_agj8X>_R
                               :: (Equivalence a_agj8X :: *)
                                  ~R# (a_agj8X -> a_agj8X -> Bool :: *)))
                        a1_agiGf b_agiGg
                 of {
                   False -> GHC.Types.False;
                   True ->
                     (ds1_dgjrj
                      `cast` (Data.Functor.Contravariant.N:Equivalence[0] <a_agj8X>_R
                              :: (Equivalence a_agj8X :: *)
                                 ~R# (a_agj8X -> a_agj8X -> Bool :: *)))
                       a1_agiGf b_agiGg
                 }}]
Data.Functor.Contravariant.$fMonoidEquivalence2
  = \ (@ a_agj8X)
      (ds_dgjri :: Equivalence a_agj8X)
      (ds1_dgjrj :: Equivalence a_agj8X)
      (a1_agiGf :: a_agj8X)
      (b_agiGg :: a_agj8X) ->
      case (ds_dgjri
            `cast` (Data.Functor.Contravariant.N:Equivalence[0] <a_agj8X>_R
                    :: (Equivalence a_agj8X :: *)
                       ~R# (a_agj8X -> a_agj8X -> Bool :: *)))
             a1_agiGf b_agiGg
      of {
        False -> GHC.Types.False;
        True ->
          (ds1_dgjrj
           `cast` (Data.Functor.Contravariant.N:Equivalence[0] <a_agj8X>_R
                   :: (Equivalence a_agj8X :: *)
                      ~R# (a_agj8X -> a_agj8X -> Bool :: *)))
            a1_agiGf b_agiGg
      }

Rec {
-- RHS size: {terms: 5, types: 7, coercions: 9, joins: 0/0}
Data.Functor.Contravariant.$fSemigroupEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup (Equivalence a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_agiGc) ->
       GHC.Base.C:Semigroup TYPE: Equivalence a_agiGc
                            (Data.Functor.Contravariant.$fMonoidEquivalence2 @ a_agiGc)
                            `cast` (<Equivalence a_agiGc>_R
                                    ->_R <Equivalence a_agiGc>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0]
                                                  <a_agiGc>_R)
                                    :: (Equivalence a_agiGc
                                        -> Equivalence a_agiGc -> a_agiGc -> a_agiGc -> Bool :: *)
                                       ~R# (Equivalence a_agiGc
                                            -> Equivalence a_agiGc -> Equivalence a_agiGc :: *))
                            Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat
                              @ a_agiGc
                            Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes
                              @ a_agiGc]
Data.Functor.Contravariant.$fSemigroupEquivalence
  = \ (@ a_XgjcE) ->
      GHC.Base.C:Semigroup
        @ (Equivalence a_XgjcE)
        ((Data.Functor.Contravariant.$fMonoidEquivalence2 @ a_XgjcE)
         `cast` (<Equivalence a_XgjcE>_R
                 ->_R <Equivalence a_XgjcE>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0] <a_XgjcE>_R)
                 :: (Equivalence a_XgjcE
                     -> Equivalence a_XgjcE -> a_XgjcE -> a_XgjcE -> Bool :: *)
                    ~R# (Equivalence a_XgjcE
                         -> Equivalence a_XgjcE -> Equivalence a_XgjcE :: *)))
        (Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat
           @ a_XgjcE)
        (Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes
           @ a_XgjcE)

-- RHS size: {terms: 7, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes [Occ=LoopBreaker]
  :: forall a b. Integral b => b -> Equivalence a -> Equivalence a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []]
Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes
  = \ (@ a_XgjcF)
      (@ b_agj9d)
      ($dIntegral_agj9f :: Integral b_agj9d) ->
      GHC.Magic.noinline
        @ (forall b1 a1. (Integral b1, Semigroup a1) => b1 -> a1 -> a1)
        Data.Semigroup.Internal.stimesDefault
        @ b_agj9d
        @ (Equivalence a_XgjcF)
        $dIntegral_agj9f
        (Data.Functor.Contravariant.$fSemigroupEquivalence @ a_XgjcF)
end Rec }

Rec {
-- RHS size: {terms: 20, types: 17, coercions: 2, joins: 0/0}
Data.Functor.Contravariant.$fMonoidEquivalence1 [Occ=LoopBreaker]
  :: forall a. [Equivalence a] -> a -> a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U><L,U>,
 Unf=OtherCon []]
Data.Functor.Contravariant.$fMonoidEquivalence1
  = \ (@ a_agj8B)
      (ds_i7Jck :: [Equivalence a_agj8B])
      (eta_B2 :: a_agj8B)
      (eta1_B1 :: a_agj8B) ->
      case ds_i7Jck of {
        [] -> GHC.Types.True;
        : y_i7Jcp ys_i7Jcq ->
          case (y_i7Jcp
                `cast` (Data.Functor.Contravariant.N:Equivalence[0] <a_agj8B>_R
                        :: (Equivalence a_agj8B :: *)
                           ~R# (a_agj8B -> a_agj8B -> Bool :: *)))
                 eta_B2 eta1_B1
          of {
            False -> GHC.Types.False;
            True ->
              Data.Functor.Contravariant.$fMonoidEquivalence1
                @ a_agj8B ys_i7Jcq eta_B2 eta1_B1
          }
      }
end Rec }

-- RHS size: {terms: 6, types: 8, coercions: 19, joins: 0/0}
Data.Functor.Contravariant.$fMonoidEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Monoid (Equivalence a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_agiGb) ->
       GHC.Base.C:Monoid TYPE: Equivalence a_agiGb
                         Data.Functor.Contravariant.$fSemigroupEquivalence @ a_agiGb
                         (Data.Functor.Contravariant.$fMonoidEquivalence3 @ a_agiGb)
                         `cast` (Sym (Data.Functor.Contravariant.N:Equivalence[0]
                                          <a_agiGb>_R)
                                 :: (a_agiGb -> a_agiGb -> Bool :: *)
                                    ~R# (Equivalence a_agiGb :: *))
                         (Data.Functor.Contravariant.$fMonoidEquivalence2 @ a_agiGb)
                         `cast` (<Equivalence a_agiGb>_R
                                 ->_R <Equivalence a_agiGb>_R
                                 ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0] <a_agiGb>_R)
                                 :: (Equivalence a_agiGb
                                     -> Equivalence a_agiGb -> a_agiGb -> a_agiGb -> Bool :: *)
                                    ~R# (Equivalence a_agiGb
                                         -> Equivalence a_agiGb -> Equivalence a_agiGb :: *))
                         (Data.Functor.Contravariant.$fMonoidEquivalence1 @ a_agiGb)
                         `cast` (<[Equivalence a_agiGb]>_R
                                 ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0] <a_agiGb>_R)
                                 :: ([Equivalence a_agiGb] -> a_agiGb -> a_agiGb -> Bool :: *)
                                    ~R# ([Equivalence a_agiGb] -> Equivalence a_agiGb :: *))]
Data.Functor.Contravariant.$fMonoidEquivalence
  = \ (@ a_Xgjet) ->
      GHC.Base.C:Monoid
        @ (Equivalence a_Xgjet)
        (Data.Functor.Contravariant.$fSemigroupEquivalence @ a_Xgjet)
        ((Data.Functor.Contravariant.$fMonoidEquivalence3 @ a_Xgjet)
         `cast` (Sym (Data.Functor.Contravariant.N:Equivalence[0]
                          <a_Xgjet>_R)
                 :: (a_Xgjet -> a_Xgjet -> Bool :: *)
                    ~R# (Equivalence a_Xgjet :: *)))
        ((Data.Functor.Contravariant.$fMonoidEquivalence2 @ a_Xgjet)
         `cast` (<Equivalence a_Xgjet>_R
                 ->_R <Equivalence a_Xgjet>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0] <a_Xgjet>_R)
                 :: (Equivalence a_Xgjet
                     -> Equivalence a_Xgjet -> a_Xgjet -> a_Xgjet -> Bool :: *)
                    ~R# (Equivalence a_Xgjet
                         -> Equivalence a_Xgjet -> Equivalence a_Xgjet :: *)))
        ((Data.Functor.Contravariant.$fMonoidEquivalence1 @ a_Xgjet)
         `cast` (<[Equivalence a_Xgjet]>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Equivalence[0] <a_Xgjet>_R)
                 :: ([Equivalence a_Xgjet] -> a_Xgjet -> a_Xgjet -> Bool :: *)
                    ~R# ([Equivalence a_Xgjet] -> Equivalence a_Xgjet :: *)))

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fMonoidPredicate3
  :: forall a. a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agjaa) _ [Occ=Dead] -> GHC.Types.True}]
Data.Functor.Contravariant.$fMonoidPredicate3
  = \ (@ a_agjaa) _ [Occ=Dead] -> GHC.Types.True

Rec {
-- RHS size: {terms: 21, types: 20, coercions: 7, joins: 0/1}
Data.Functor.Contravariant.$fSemigroupPredicate1 [Occ=LoopBreaker]
  :: forall a. Predicate a -> [Predicate a] -> Predicate a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,1*U>, Unf=OtherCon []]
Data.Functor.Contravariant.$fSemigroupPredicate1
  = \ (@ a_Xgje6)
      (b_i9ine :: Predicate a_Xgje6)
      (ds1_i9inf :: [Predicate a_Xgje6]) ->
      case ds1_i9inf of {
        [] -> b_i9ine;
        : c_i9inn cs_i9ino ->
          let {
            ds_sgjyc [Dmd=<L,C(U)>] :: Predicate a_Xgje6
            [LclId]
            ds_sgjyc
              = Data.Functor.Contravariant.$fSemigroupPredicate1
                  @ a_Xgje6 c_i9inn cs_i9ino } in
          (\ (a1_agiGp :: a_Xgje6) ->
             case (b_i9ine
                   `cast` (Data.Functor.Contravariant.N:Predicate[0] <a_Xgje6>_R
                           :: (Predicate a_Xgje6 :: *) ~R# (a_Xgje6 -> Bool :: *)))
                    a1_agiGp
             of {
               False -> GHC.Types.False;
               True ->
                 (ds_sgjyc
                  `cast` (Data.Functor.Contravariant.N:Predicate[0] <a_Xgje6>_R
                          :: (Predicate a_Xgje6 :: *) ~R# (a_Xgje6 -> Bool :: *)))
                   a1_agiGp
             })
          `cast` (Sym (Data.Functor.Contravariant.N:Predicate[0] <a_Xgje6>_R)
                  :: (a_Xgje6 -> Bool :: *) ~R# (Predicate a_Xgje6 :: *))
      }
end Rec }

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat
  :: forall a. GHC.Base.NonEmpty (Predicate a) -> Predicate a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgje6)
                 (ds_i9in9 [Occ=Once!] :: GHC.Base.NonEmpty (Predicate a_Xgje6)) ->
                 case ds_i9in9 of
                 { GHC.Base.:| a1_i9ing [Occ=Once] as_i9inh [Occ=Once] ->
                 Data.Functor.Contravariant.$fSemigroupPredicate1
                   @ a_Xgje6 a1_i9ing as_i9inh
                 }}]
Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat
  = \ (@ a_Xgje6)
      (ds_i9in9 :: GHC.Base.NonEmpty (Predicate a_Xgje6)) ->
      case ds_i9in9 of { GHC.Base.:| a1_i9ing as_i9inh ->
      Data.Functor.Contravariant.$fSemigroupPredicate1
        @ a_Xgje6 a1_i9ing as_i9inh
      }

-- RHS size: {terms: 12, types: 8, coercions: 4, joins: 0/0}
Data.Functor.Contravariant.$fMonoidPredicate2
  :: forall a. Predicate a -> Predicate a -> a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agjaA)
                 (ds_dgjrt [Occ=Once] :: Predicate a_agjaA)
                 (ds1_dgjru [Occ=Once] :: Predicate a_agjaA)
                 (a1_agiGp :: a_agjaA) ->
                 case (ds_dgjrt
                       `cast` (Data.Functor.Contravariant.N:Predicate[0] <a_agjaA>_R
                               :: (Predicate a_agjaA :: *) ~R# (a_agjaA -> Bool :: *)))
                        a1_agiGp
                 of {
                   False -> GHC.Types.False;
                   True ->
                     (ds1_dgjru
                      `cast` (Data.Functor.Contravariant.N:Predicate[0] <a_agjaA>_R
                              :: (Predicate a_agjaA :: *) ~R# (a_agjaA -> Bool :: *)))
                       a1_agiGp
                 }}]
Data.Functor.Contravariant.$fMonoidPredicate2
  = \ (@ a_agjaA)
      (ds_dgjrt :: Predicate a_agjaA)
      (ds1_dgjru :: Predicate a_agjaA)
      (a1_agiGp :: a_agjaA) ->
      case (ds_dgjrt
            `cast` (Data.Functor.Contravariant.N:Predicate[0] <a_agjaA>_R
                    :: (Predicate a_agjaA :: *) ~R# (a_agjaA -> Bool :: *)))
             a1_agiGp
      of {
        False -> GHC.Types.False;
        True ->
          (ds1_dgjru
           `cast` (Data.Functor.Contravariant.N:Predicate[0] <a_agjaA>_R
                   :: (Predicate a_agjaA :: *) ~R# (a_agjaA -> Bool :: *)))
            a1_agiGp
      }

Rec {
-- RHS size: {terms: 5, types: 7, coercions: 9, joins: 0/0}
Data.Functor.Contravariant.$fSemigroupPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup (Predicate a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_agiGm) ->
       GHC.Base.C:Semigroup TYPE: Predicate a_agiGm
                            (Data.Functor.Contravariant.$fMonoidPredicate2 @ a_agiGm)
                            `cast` (<Predicate a_agiGm>_R
                                    ->_R <Predicate a_agiGm>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Predicate[0] <a_agiGm>_R)
                                    :: (Predicate a_agiGm
                                        -> Predicate a_agiGm -> a_agiGm -> Bool :: *)
                                       ~R# (Predicate a_agiGm
                                            -> Predicate a_agiGm -> Predicate a_agiGm :: *))
                            Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat @ a_agiGm
                            Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes @ a_agiGm]
Data.Functor.Contravariant.$fSemigroupPredicate
  = \ (@ a_Xgje4) ->
      GHC.Base.C:Semigroup
        @ (Predicate a_Xgje4)
        ((Data.Functor.Contravariant.$fMonoidPredicate2 @ a_Xgje4)
         `cast` (<Predicate a_Xgje4>_R
                 ->_R <Predicate a_Xgje4>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Predicate[0] <a_Xgje4>_R)
                 :: (Predicate a_Xgje4 -> Predicate a_Xgje4 -> a_Xgje4 -> Bool :: *)
                    ~R# (Predicate a_Xgje4
                         -> Predicate a_Xgje4 -> Predicate a_Xgje4 :: *)))
        (Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat
           @ a_Xgje4)
        (Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes
           @ a_Xgje4)

-- RHS size: {terms: 7, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes [Occ=LoopBreaker]
  :: forall a b. Integral b => b -> Predicate a -> Predicate a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []]
Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes
  = \ (@ a_Xgje5)
      (@ b_agjaQ)
      ($dIntegral_agjaS :: Integral b_agjaQ) ->
      GHC.Magic.noinline
        @ (forall b1 a1. (Integral b1, Semigroup a1) => b1 -> a1 -> a1)
        Data.Semigroup.Internal.stimesDefault
        @ b_agjaQ
        @ (Predicate a_Xgje5)
        $dIntegral_agjaS
        (Data.Functor.Contravariant.$fSemigroupPredicate @ a_Xgje5)
end Rec }

Rec {
-- RHS size: {terms: 17, types: 16, coercions: 2, joins: 0/0}
Data.Functor.Contravariant.$fMonoidPredicate1 [Occ=LoopBreaker]
  :: forall a. [Predicate a] -> a -> Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,1*U><L,U>, Unf=OtherCon []]
Data.Functor.Contravariant.$fMonoidPredicate1
  = \ (@ a_agjaa)
      (ds_X7Jik :: [Predicate a_agjaa])
      (eta_B1 :: a_agjaa) ->
      case ds_X7Jik of {
        [] -> GHC.Types.True;
        : y_i7Jcp ys_i7Jcq ->
          case (y_i7Jcp
                `cast` (Data.Functor.Contravariant.N:Predicate[0] <a_agjaa>_R
                        :: (Predicate a_agjaa :: *) ~R# (a_agjaa -> Bool :: *)))
                 eta_B1
          of {
            False -> GHC.Types.False;
            True ->
              Data.Functor.Contravariant.$fMonoidPredicate1
                @ a_agjaa ys_i7Jcq eta_B1
          }
      }
end Rec }

-- RHS size: {terms: 6, types: 8, coercions: 19, joins: 0/0}
Data.Functor.Contravariant.$fMonoidPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Monoid (Predicate a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_agiGl) ->
       GHC.Base.C:Monoid TYPE: Predicate a_agiGl
                         Data.Functor.Contravariant.$fSemigroupPredicate @ a_agiGl
                         (Data.Functor.Contravariant.$fMonoidPredicate3 @ a_agiGl)
                         `cast` (Sym (Data.Functor.Contravariant.N:Predicate[0] <a_agiGl>_R)
                                 :: (a_agiGl -> Bool :: *) ~R# (Predicate a_agiGl :: *))
                         (Data.Functor.Contravariant.$fMonoidPredicate2 @ a_agiGl)
                         `cast` (<Predicate a_agiGl>_R
                                 ->_R <Predicate a_agiGl>_R
                                 ->_R Sym (Data.Functor.Contravariant.N:Predicate[0] <a_agiGl>_R)
                                 :: (Predicate a_agiGl -> Predicate a_agiGl -> a_agiGl -> Bool :: *)
                                    ~R# (Predicate a_agiGl
                                         -> Predicate a_agiGl -> Predicate a_agiGl :: *))
                         (Data.Functor.Contravariant.$fMonoidPredicate1 @ a_agiGl)
                         `cast` (<[Predicate a_agiGl]>_R
                                 ->_R Sym (Data.Functor.Contravariant.N:Predicate[0] <a_agiGl>_R)
                                 :: ([Predicate a_agiGl] -> a_agiGl -> Bool :: *)
                                    ~R# ([Predicate a_agiGl] -> Predicate a_agiGl :: *))]
Data.Functor.Contravariant.$fMonoidPredicate
  = \ (@ a_Xgjgd) ->
      GHC.Base.C:Monoid
        @ (Predicate a_Xgjgd)
        (Data.Functor.Contravariant.$fSemigroupPredicate @ a_Xgjgd)
        ((Data.Functor.Contravariant.$fMonoidPredicate3 @ a_Xgjgd)
         `cast` (Sym (Data.Functor.Contravariant.N:Predicate[0] <a_Xgjgd>_R)
                 :: (a_Xgjgd -> Bool :: *) ~R# (Predicate a_Xgjgd :: *)))
        ((Data.Functor.Contravariant.$fMonoidPredicate2 @ a_Xgjgd)
         `cast` (<Predicate a_Xgjgd>_R
                 ->_R <Predicate a_Xgjgd>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Predicate[0] <a_Xgjgd>_R)
                 :: (Predicate a_Xgjgd -> Predicate a_Xgjgd -> a_Xgjgd -> Bool :: *)
                    ~R# (Predicate a_Xgjgd
                         -> Predicate a_Xgjgd -> Predicate a_Xgjgd :: *)))
        ((Data.Functor.Contravariant.$fMonoidPredicate1 @ a_Xgjgd)
         `cast` (<[Predicate a_Xgjgd]>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Predicate[0] <a_Xgjgd>_R)
                 :: ([Predicate a_Xgjgd] -> a_Xgjgd -> Bool :: *)
                    ~R# ([Predicate a_Xgjgd] -> Predicate a_Xgjgd :: *)))

-- RHS size: {terms: 5, types: 13, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantProxy_$ccontramap
  :: forall a b. (a -> b) -> Proxy b -> Proxy a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agjby) (@ b_agjbz) _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Proxy.Proxy @ * @ a_agjby}]
Data.Functor.Contravariant.$fContravariantProxy_$ccontramap
  = \ (@ a_agjby) (@ b_agjbz) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Proxy.Proxy @ * @ a_agjby

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Contravariant Proxy
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Contravariant.C:Contravariant TYPE: Proxy
                                                  Data.Functor.Contravariant.$fContravariantProxy_$ccontramap
                                                  Data.Functor.Contravariant.$fContravariantProxy_$c>$]
Data.Functor.Contravariant.$fContravariantProxy
  = Data.Functor.Contravariant.C:Contravariant
      @ Proxy
      Data.Functor.Contravariant.$fContravariantProxy_$ccontramap
      Data.Functor.Contravariant.$fContravariantProxy_$c>$

-- RHS size: {terms: 14, types: 34, coercions: 8, joins: 0/0}
Data.Functor.Contravariant.$fContravariantCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (Functor f, Contravariant g) =>
     forall a b. (a -> b) -> Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_agjbP :: * -> *))
                 (@ (g_agjbQ :: * -> *))
                 ($dFunctor_agjbR [Occ=Once] :: Functor f_agjbP)
                 ($dContravariant_agjbS [Occ=Once] :: Contravariant g_agjbQ)
                 (@ a_agjbW)
                 (@ b_agjbX)
                 (f1_agiGu [Occ=Once] :: a_agjbW -> b_agjbX)
                 (ds_dgjrH [Occ=Once] :: Compose f_agjbP g_agjbQ b_agjbX) ->
                 fmap
                   @ f_agjbP
                   $dFunctor_agjbR
                   @ (g_agjbQ b_agjbX)
                   @ (g_agjbQ a_agjbW)
                   (contramap
                      @ g_agjbQ $dContravariant_agjbS @ a_agjbW @ b_agjbX f1_agiGu)
                   (ds_dgjrH
                    `cast` (Data.Functor.Compose.N:Compose[0]
                                <*>_N <*>_N <f_agjbP>_R <g_agjbQ>_N <b_agjbX>_N
                            :: (Compose f_agjbP g_agjbQ b_agjbX :: *)
                               ~R# (f_agjbP (g_agjbQ b_agjbX) :: *)))}]
Data.Functor.Contravariant.$fContravariantCompose2
  = \ (@ (f_agjbP :: * -> *))
      (@ (g_agjbQ :: * -> *))
      ($dFunctor_agjbR :: Functor f_agjbP)
      ($dContravariant_agjbS :: Contravariant g_agjbQ)
      (@ a_agjbW)
      (@ b_agjbX)
      (f1_agiGu :: a_agjbW -> b_agjbX)
      (ds_dgjrH :: Compose f_agjbP g_agjbQ b_agjbX) ->
      fmap
        @ f_agjbP
        $dFunctor_agjbR
        @ (g_agjbQ b_agjbX)
        @ (g_agjbQ a_agjbW)
        (contramap
           @ g_agjbQ $dContravariant_agjbS @ a_agjbW @ b_agjbX f1_agiGu)
        (ds_dgjrH
         `cast` (Data.Functor.Compose.N:Compose[0]
                     <*>_N <*>_N <f_agjbP>_R <g_agjbQ>_N <b_agjbX>_N
                 :: (Compose f_agjbP g_agjbQ b_agjbX :: *)
                    ~R# (f_agjbP (g_agjbQ b_agjbX) :: *)))

-- RHS size: {terms: 11, types: 23, coercions: 53, joins: 0/0}
Data.Functor.Contravariant.$fContravariantCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Functor f, Contravariant g) =>
     Contravariant (Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m,
 Unf=DFun: \ (@ (f_agiGs :: * -> *))
             (@ (g_agiGt :: * -> *))
             (v_X6g :: Functor f_agiGs)
             (v1_B2 :: Contravariant g_agiGt) ->
       Data.Functor.Contravariant.C:Contravariant TYPE: Compose
                                                          f_agiGs g_agiGt
                                                  (Data.Functor.Contravariant.$fContravariantCompose2
                                                     @ f_agiGs @ g_agiGt v_X6g v1_B2)
                                                  `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                                          <a -> b>_R
                                                          ->_R <Compose f_agiGs g_agiGt b>_R
                                                          ->_R Sym (Data.Functor.Compose.N:Compose[0]
                                                                        <*>_N
                                                                        <*>_N
                                                                        <f_agiGs>_R
                                                                        <g_agiGt>_N
                                                                        <a>_N)
                                                          :: (forall a b.
                                                              (a -> b)
                                                              -> Compose f_agiGs g_agiGt b
                                                              -> f_agiGs (g_agiGt a) :: *)
                                                             ~R# (forall a b.
                                                                  (a -> b)
                                                                  -> Compose f_agiGs g_agiGt b
                                                                  -> Compose
                                                                       f_agiGs g_agiGt a :: *))
                                                  (Data.Functor.Contravariant.$fContravariantCompose1
                                                     @ f_agiGs @ g_agiGt v_X6g v1_B2)
                                                  `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                                          <b>_R
                                                          ->_R <Compose f_agiGs g_agiGt b>_R
                                                          ->_R Sym (Data.Functor.Compose.N:Compose[0]
                                                                        <*>_N
                                                                        <*>_N
                                                                        <f_agiGs>_R
                                                                        <g_agiGt>_N
                                                                        <a>_N)
                                                          :: (forall b a.
                                                              b
                                                              -> Compose f_agiGs g_agiGt b
                                                              -> f_agiGs (g_agiGt a) :: *)
                                                             ~R# (forall b a.
                                                                  b
                                                                  -> Compose f_agiGs g_agiGt b
                                                                  -> Compose
                                                                       f_agiGs g_agiGt a :: *))]
Data.Functor.Contravariant.$fContravariantCompose
  = \ (@ (f_XgjhU :: * -> *))
      (@ (g_XgjhW :: * -> *))
      ($dFunctor_XgjhY :: Functor f_XgjhU)
      ($dContravariant_Xgji0 :: Contravariant g_XgjhW) ->
      Data.Functor.Contravariant.C:Contravariant
        @ (Compose f_XgjhU g_XgjhW)
        ((Data.Functor.Contravariant.$fContravariantCompose2
            @ f_XgjhU @ g_XgjhW $dFunctor_XgjhY $dContravariant_Xgji0)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Compose f_XgjhU g_XgjhW b>_R
                 ->_R Sym (Data.Functor.Compose.N:Compose[0]
                               <*>_N <*>_N <f_XgjhU>_R <g_XgjhW>_N <a>_N)
                 :: (forall a b.
                     (a -> b) -> Compose f_XgjhU g_XgjhW b -> f_XgjhU (g_XgjhW a) :: *)
                    ~R# (forall a b.
                         (a -> b)
                         -> Compose f_XgjhU g_XgjhW b -> Compose f_XgjhU g_XgjhW a :: *)))
        ((Data.Functor.Contravariant.$fContravariantCompose1
            @ f_XgjhU @ g_XgjhW $dFunctor_XgjhY $dContravariant_Xgji0)
         `cast` (forall (b :: <*>_N) (a :: <*>_N).
                 <b>_R
                 ->_R <Compose f_XgjhU g_XgjhW b>_R
                 ->_R Sym (Data.Functor.Compose.N:Compose[0]
                               <*>_N <*>_N <f_XgjhU>_R <g_XgjhW>_N <a>_N)
                 :: (forall b a.
                     b -> Compose f_XgjhU g_XgjhW b -> f_XgjhU (g_XgjhW a) :: *)
                    ~R# (forall b a.
                         b -> Compose f_XgjhU g_XgjhW b -> Compose f_XgjhU g_XgjhW a :: *)))

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantConst2
  :: forall a1 a2 b. (a2 -> b) -> Const a1 b -> Const a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agjcp)
                 (@ a1_agjct)
                 (@ b_agjcu)
                 _ [Occ=Dead]
                 (ds1_dgjrM [Occ=Once] :: Const a_agjcp b_agjcu) ->
                 ds1_dgjrM}]
Data.Functor.Contravariant.$fContravariantConst2
  = \ (@ a_agjcp)
      (@ a1_agjct)
      (@ b_agjcu)
      _ [Occ=Dead]
      (ds1_dgjrM :: Const a_agjcp b_agjcu) ->
      ds1_dgjrM

-- RHS size: {terms: 6, types: 13, coercions: 53, joins: 0/0}
Data.Functor.Contravariant.$fContravariantConst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Contravariant (Const a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_agiGw) ->
       Data.Functor.Contravariant.C:Contravariant TYPE: Const a_agiGw
                                                  (Data.Functor.Contravariant.$fContravariantConst2
                                                     @ a_agiGw)
                                                  `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                                                          <a1 -> b>_R
                                                          ->_R <Const a_agiGw b>_R
                                                          ->_R Data.Functor.Const.N:Const[0]
                                                                   <*>_N
                                                                   <a_agiGw>_R
                                                                   <b>_P ; Sym (Data.Functor.Const.N:Const[0]
                                                                                    <*>_N
                                                                                    <a_agiGw>_R
                                                                                    <a1>_P)
                                                          :: (forall a1 b.
                                                              (a1 -> b)
                                                              -> Const a_agiGw b
                                                              -> Const a_agiGw b :: *)
                                                             ~R# (forall a1 b.
                                                                  (a1 -> b)
                                                                  -> Const a_agiGw b
                                                                  -> Const a_agiGw a1 :: *))
                                                  (\ (@ b_agjcC) (@ a1_agjcD) ->
                                                     Data.Functor.Contravariant.$fContravariantConst1
                                                       @ b_agjcC @ a_agiGw)
                                                  `cast` (forall (b :: <*>_N) (a1 :: <*>_N).
                                                          <b>_R
                                                          ->_R <Const a_agiGw b>_R
                                                          ->_R Data.Functor.Const.N:Const[0]
                                                                   <*>_N
                                                                   <a_agiGw>_R
                                                                   <b>_P ; Sym (Data.Functor.Const.N:Const[0]
                                                                                    <*>_N
                                                                                    <a_agiGw>_R
                                                                                    <a1>_P)
                                                          :: (forall b a1.
                                                              b
                                                              -> Const a_agiGw b
                                                              -> Const a_agiGw b :: *)
                                                             ~R# (forall b a1.
                                                                  b
                                                                  -> Const a_agiGw b
                                                                  -> Const a_agiGw a1 :: *))]
Data.Functor.Contravariant.$fContravariantConst
  = \ (@ a_Xgjiw) ->
      Data.Functor.Contravariant.C:Contravariant
        @ (Const a_Xgjiw)
        ((Data.Functor.Contravariant.$fContravariantConst2 @ a_Xgjiw)
         `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                 <a1 -> b>_R
                 ->_R <Const a_Xgjiw b>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N <a_Xgjiw>_R <b>_P ; Sym (Data.Functor.Const.N:Const[0]
                                                             <*>_N <a_Xgjiw>_R <a1>_P)
                 :: (forall a1 b.
                     (a1 -> b) -> Const a_Xgjiw b -> Const a_Xgjiw b :: *)
                    ~R# (forall a1 b.
                         (a1 -> b) -> Const a_Xgjiw b -> Const a_Xgjiw a1 :: *)))
        ((\ (@ b_agjcC) (@ a1_agjcD) ->
            Data.Functor.Contravariant.$fContravariantConst1
              @ b_agjcC @ a_Xgjiw)
         `cast` (forall (b :: <*>_N) (a1 :: <*>_N).
                 <b>_R
                 ->_R <Const a_Xgjiw b>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N <a_Xgjiw>_R <b>_P ; Sym (Data.Functor.Const.N:Const[0]
                                                             <*>_N <a_Xgjiw>_R <a1>_P)
                 :: (forall b a1. b -> Const a_Xgjiw b -> Const a_Xgjiw b :: *)
                    ~R# (forall b a1. b -> Const a_Xgjiw b -> Const a_Xgjiw a1 :: *)))

-- RHS size: {terms: 20, types: 45, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantProduct_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Contravariant f, Contravariant g) =>
     forall a b. (a -> b) -> Product f g b -> Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_agjcL :: * -> *))
                 (@ (g_agjcM :: * -> *))
                 ($dContravariant_agjcN [Occ=Once] :: Contravariant f_agjcL)
                 ($dContravariant1_agjcO [Occ=Once] :: Contravariant g_agjcM)
                 (@ a_agjcS)
                 (@ b_agjcT)
                 (f1_agiGA :: a_agjcS -> b_agjcT)
                 (ds_dgjrR [Occ=Once!] :: Product f_agjcL g_agjcM b_agjcT) ->
                 case ds_dgjrR of { Pair a1_agiGB [Occ=Once] b1_agiGC [Occ=Once] ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_agjcL
                   @ g_agjcM
                   @ a_agjcS
                   (contramap
                      @ f_agjcL
                      $dContravariant_agjcN
                      @ a_agjcS
                      @ b_agjcT
                      f1_agiGA
                      a1_agiGB)
                   (contramap
                      @ g_agjcM
                      $dContravariant1_agjcO
                      @ a_agjcS
                      @ b_agjcT
                      f1_agiGA
                      b1_agiGC)
                 }}]
Data.Functor.Contravariant.$fContravariantProduct_$ccontramap
  = \ (@ (f_agjcL :: * -> *))
      (@ (g_agjcM :: * -> *))
      ($dContravariant_agjcN :: Contravariant f_agjcL)
      ($dContravariant1_agjcO :: Contravariant g_agjcM)
      (@ a_agjcS)
      (@ b_agjcT)
      (f1_agiGA :: a_agjcS -> b_agjcT)
      (ds_dgjrR :: Product f_agjcL g_agjcM b_agjcT) ->
      case ds_dgjrR of { Pair a1_agiGB b1_agiGC ->
      Data.Functor.Product.Pair
        @ *
        @ f_agjcL
        @ g_agjcM
        @ a_agjcS
        (contramap
           @ f_agjcL
           $dContravariant_agjcN
           @ a_agjcS
           @ b_agjcT
           f1_agiGA
           a1_agiGB)
        (contramap
           @ g_agjcM
           $dContravariant1_agjcO
           @ a_agjcS
           @ b_agjcT
           f1_agiGA
           b1_agiGC)
      }

-- RHS size: {terms: 11, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Contravariant f, Contravariant g) =>
     Contravariant (Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ (f_agiGy :: * -> *))
             (@ (g_agiGz :: * -> *))
             (v_X6l :: Contravariant f_agiGy)
             (v1_B2 :: Contravariant g_agiGz) ->
       Data.Functor.Contravariant.C:Contravariant TYPE: Product
                                                          f_agiGy g_agiGz
                                                  Data.Functor.Contravariant.$fContravariantProduct_$ccontramap
                                                    @ f_agiGy @ g_agiGz v_X6l v1_B2
                                                  Data.Functor.Contravariant.$fContravariantProduct_$c>$
                                                    @ f_agiGy @ g_agiGz v_X6l v1_B2]
Data.Functor.Contravariant.$fContravariantProduct
  = \ (@ (f_agjcL :: * -> *))
      (@ (g_agjcM :: * -> *))
      ($dContravariant_agjcN :: Contravariant f_agjcL)
      ($dContravariant1_agjcO :: Contravariant g_agjcM) ->
      Data.Functor.Contravariant.C:Contravariant
        @ (Product f_agjcL g_agjcM)
        (Data.Functor.Contravariant.$fContravariantProduct_$ccontramap
           @ f_agjcL @ g_agjcM $dContravariant_agjcN $dContravariant1_agjcO)
        (Data.Functor.Contravariant.$fContravariantProduct_$c>$
           @ f_agjcL @ g_agjcM $dContravariant_agjcN $dContravariant1_agjcO)

-- RHS size: {terms: 22, types: 50, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantSum_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Contravariant f, Contravariant g) =>
     forall a b. (a -> b) -> Sum f g b -> Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 80] 120 40}]
Data.Functor.Contravariant.$fContravariantSum_$ccontramap
  = \ (@ (f_agjdk :: * -> *))
      (@ (g_agjdl :: * -> *))
      ($dContravariant_agjdm :: Contravariant f_agjdk)
      ($dContravariant1_agjdn :: Contravariant g_agjdl)
      (@ a_agjdr)
      (@ b_agjds)
      (f1_agiGF :: a_agjdr -> b_agjds)
      (ds_dgjrW :: Sum f_agjdk g_agjdl b_agjds) ->
      case ds_dgjrW of {
        InL xs_agiGG ->
          Data.Functor.Sum.InL
            @ *
            @ f_agjdk
            @ g_agjdl
            @ a_agjdr
            (contramap
               @ f_agjdk
               $dContravariant_agjdm
               @ a_agjdr
               @ b_agjds
               f1_agiGF
               xs_agiGG);
        InR ys_agiGI ->
          Data.Functor.Sum.InR
            @ *
            @ f_agjdk
            @ g_agjdl
            @ a_agjdr
            (contramap
               @ g_agjdl
               $dContravariant1_agjdn
               @ a_agjdr
               @ b_agjds
               f1_agiGF
               ys_agiGI)
      }

-- RHS size: {terms: 14, types: 28, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantSum_$c>$
  :: forall (f :: * -> *) (g :: * -> *).
     (Contravariant f, Contravariant g) =>
     forall b a. b -> Sum f g b -> Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_agjdk :: * -> *))
                 (@ (g_agjdl :: * -> *))
                 ($dContravariant_agjdm [Occ=Once] :: Contravariant f_agjdk)
                 ($dContravariant1_agjdn [Occ=Once] :: Contravariant g_agjdl)
                 (@ b_agjdO)
                 (@ a_agjdP)
                 (x_X7RDH [Occ=OnceL] :: b_agjdO)
                 (eta_X6r [Occ=Once] :: Sum f_agjdk g_agjdl b_agjdO) ->
                 Data.Functor.Contravariant.$fContravariantSum_$ccontramap
                   @ f_agjdk
                   @ g_agjdl
                   $dContravariant_agjdm
                   $dContravariant1_agjdn
                   @ a_agjdP
                   @ b_agjdO
                   (\ _ [Occ=Dead] -> x_X7RDH)
                   eta_X6r}]
Data.Functor.Contravariant.$fContravariantSum_$c>$
  = \ (@ (f_agjdk :: * -> *))
      (@ (g_agjdl :: * -> *))
      ($dContravariant_agjdm :: Contravariant f_agjdk)
      ($dContravariant1_agjdn :: Contravariant g_agjdl)
      (@ b_agjdO)
      (@ a_agjdP)
      (x_X7RDH :: b_agjdO)
      (eta_X6r :: Sum f_agjdk g_agjdl b_agjdO) ->
      Data.Functor.Contravariant.$fContravariantSum_$ccontramap
        @ f_agjdk
        @ g_agjdl
        $dContravariant_agjdm
        $dContravariant1_agjdn
        @ a_agjdP
        @ b_agjdO
        (\ _ [Occ=Dead] -> x_X7RDH)
        eta_X6r

-- RHS size: {terms: 11, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Contravariant f, Contravariant g) =>
     Contravariant (Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ (f_agiGD :: * -> *))
             (@ (g_agiGE :: * -> *))
             (v_X6n :: Contravariant f_agiGD)
             (v1_B2 :: Contravariant g_agiGE) ->
       Data.Functor.Contravariant.C:Contravariant TYPE: Sum
                                                          f_agiGD g_agiGE
                                                  Data.Functor.Contravariant.$fContravariantSum_$ccontramap
                                                    @ f_agiGD @ g_agiGE v_X6n v1_B2
                                                  Data.Functor.Contravariant.$fContravariantSum_$c>$
                                                    @ f_agiGD @ g_agiGE v_X6n v1_B2]
Data.Functor.Contravariant.$fContravariantSum
  = \ (@ (f_agjdk :: * -> *))
      (@ (g_agjdl :: * -> *))
      ($dContravariant_agjdm :: Contravariant f_agjdk)
      ($dContravariant1_agjdn :: Contravariant g_agjdl) ->
      Data.Functor.Contravariant.C:Contravariant
        @ (Sum f_agjdk g_agjdl)
        (Data.Functor.Contravariant.$fContravariantSum_$ccontramap
           @ f_agjdk @ g_agjdl $dContravariant_agjdm $dContravariant1_agjdn)
        (Data.Functor.Contravariant.$fContravariantSum_$c>$
           @ f_agjdk @ g_agjdl $dContravariant_agjdm $dContravariant1_agjdn)

-- RHS size: {terms: 22, types: 50, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Contravariant f, Contravariant g) =>
     forall a b. (a -> b) -> (:+:) f g b -> (:+:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 80] 120 40}]
Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
  = \ (@ (f_agjdX :: * -> *))
      (@ (g_agjdY :: * -> *))
      ($dContravariant_agjdZ :: Contravariant f_agjdX)
      ($dContravariant1_agje0 :: Contravariant g_agjdY)
      (@ a_agje4)
      (@ b_agje5)
      (f1_agiGL :: a_agje4 -> b_agje5)
      (ds_dgjs2 :: (:+:) f_agjdX g_agjdY b_agje5) ->
      case ds_dgjs2 of {
        L1 xs_agiGM ->
          GHC.Generics.L1
            @ *
            @ f_agjdX
            @ g_agjdY
            @ a_agje4
            (contramap
               @ f_agjdX
               $dContravariant_agjdZ
               @ a_agje4
               @ b_agje5
               f1_agiGL
               xs_agiGM);
        R1 ys_agiGO ->
          GHC.Generics.R1
            @ *
            @ f_agjdX
            @ g_agjdY
            @ a_agje4
            (contramap
               @ g_agjdY
               $dContravariant1_agje0
               @ a_agje4
               @ b_agje5
               f1_agiGL
               ys_agiGO)
      }

-- RHS size: {terms: 14, types: 28, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariant:+:_$c>$
  :: forall (f :: * -> *) (g :: * -> *).
     (Contravariant f, Contravariant g) =>
     forall b a. b -> (:+:) f g b -> (:+:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_agjdX :: * -> *))
                 (@ (g_agjdY :: * -> *))
                 ($dContravariant_agjdZ [Occ=Once] :: Contravariant f_agjdX)
                 ($dContravariant1_agje0 [Occ=Once] :: Contravariant g_agjdY)
                 (@ b_agjer)
                 (@ a_agjes)
                 (x_X7RDJ [Occ=OnceL] :: b_agjer)
                 (eta_X6t [Occ=Once] :: (:+:) f_agjdX g_agjdY b_agjer) ->
                 Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
                   @ f_agjdX
                   @ g_agjdY
                   $dContravariant_agjdZ
                   $dContravariant1_agje0
                   @ a_agjes
                   @ b_agjer
                   (\ _ [Occ=Dead] -> x_X7RDJ)
                   eta_X6t}]
Data.Functor.Contravariant.$fContravariant:+:_$c>$
  = \ (@ (f_agjdX :: * -> *))
      (@ (g_agjdY :: * -> *))
      ($dContravariant_agjdZ :: Contravariant f_agjdX)
      ($dContravariant1_agje0 :: Contravariant g_agjdY)
      (@ b_agjer)
      (@ a_agjes)
      (x_X7RDJ :: b_agjer)
      (eta_X6t :: (:+:) f_agjdX g_agjdY b_agjer) ->
      Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
        @ f_agjdX
        @ g_agjdY
        $dContravariant_agjdZ
        $dContravariant1_agje0
        @ a_agjes
        @ b_agjer
        (\ _ [Occ=Dead] -> x_X7RDJ)
        eta_X6t

-- RHS size: {terms: 11, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariant:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Contravariant f, Contravariant g) =>
     Contravariant (f :+: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ (f_agiGJ :: * -> *))
             (@ (g_agiGK :: * -> *))
             (v_X6p :: Contravariant f_agiGJ)
             (v1_B2 :: Contravariant g_agiGK) ->
       Data.Functor.Contravariant.C:Contravariant TYPE: f_agiGJ
                                                        :+: g_agiGK
                                                  Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
                                                    @ f_agiGJ @ g_agiGK v_X6p v1_B2
                                                  Data.Functor.Contravariant.$fContravariant:+:_$c>$
                                                    @ f_agiGJ @ g_agiGK v_X6p v1_B2]
Data.Functor.Contravariant.$fContravariant:+:
  = \ (@ (f_agjdX :: * -> *))
      (@ (g_agjdY :: * -> *))
      ($dContravariant_agjdZ :: Contravariant f_agjdX)
      ($dContravariant1_agje0 :: Contravariant g_agjdY) ->
      Data.Functor.Contravariant.C:Contravariant
        @ (f_agjdX :+: g_agjdY)
        (Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
           @ f_agjdX @ g_agjdY $dContravariant_agjdZ $dContravariant1_agje0)
        (Data.Functor.Contravariant.$fContravariant:+:_$c>$
           @ f_agjdX @ g_agjdY $dContravariant_agjdZ $dContravariant1_agje0)

-- RHS size: {terms: 14, types: 34, coercions: 8, joins: 0/0}
Data.Functor.Contravariant.$fContravariant:.:2
  :: forall (f :: * -> *) (g :: * -> *).
     (Functor f, Contravariant g) =>
     forall a b. (a -> b) -> (:.:) f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_agjeA :: * -> *))
                 (@ (g_agjeB :: * -> *))
                 ($dFunctor_agjeC [Occ=Once] :: Functor f_agjeA)
                 ($dContravariant_agjeD [Occ=Once] :: Contravariant g_agjeB)
                 (@ a_agjeH)
                 (@ b_agjeI)
                 (f1_agiGR [Occ=Once] :: a_agjeH -> b_agjeI)
                 (ds_dgjs8 [Occ=Once] :: (:.:) f_agjeA g_agjeB b_agjeI) ->
                 fmap
                   @ f_agjeA
                   $dFunctor_agjeC
                   @ (g_agjeB b_agjeI)
                   @ (g_agjeB a_agjeH)
                   (contramap
                      @ g_agjeB $dContravariant_agjeD @ a_agjeH @ b_agjeI f1_agiGR)
                   (ds_dgjs8
                    `cast` (GHC.Generics.N::.:[0]
                                <*>_N <*>_N <f_agjeA>_R <g_agjeB>_N <b_agjeI>_N
                            :: ((:.:) f_agjeA g_agjeB b_agjeI :: *)
                               ~R# (f_agjeA (g_agjeB b_agjeI) :: *)))}]
Data.Functor.Contravariant.$fContravariant:.:2
  = \ (@ (f_agjeA :: * -> *))
      (@ (g_agjeB :: * -> *))
      ($dFunctor_agjeC :: Functor f_agjeA)
      ($dContravariant_agjeD :: Contravariant g_agjeB)
      (@ a_agjeH)
      (@ b_agjeI)
      (f1_agiGR :: a_agjeH -> b_agjeI)
      (ds_dgjs8 :: (:.:) f_agjeA g_agjeB b_agjeI) ->
      fmap
        @ f_agjeA
        $dFunctor_agjeC
        @ (g_agjeB b_agjeI)
        @ (g_agjeB a_agjeH)
        (contramap
           @ g_agjeB $dContravariant_agjeD @ a_agjeH @ b_agjeI f1_agiGR)
        (ds_dgjs8
         `cast` (GHC.Generics.N::.:[0]
                     <*>_N <*>_N <f_agjeA>_R <g_agjeB>_N <b_agjeI>_N
                 :: ((:.:) f_agjeA g_agjeB b_agjeI :: *)
                    ~R# (f_agjeA (g_agjeB b_agjeI) :: *)))

-- RHS size: {terms: 11, types: 23, coercions: 53, joins: 0/0}
Data.Functor.Contravariant.$fContravariant:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Functor f, Contravariant g) =>
     Contravariant (f :.: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m,
 Unf=DFun: \ (@ (f_agiGP :: * -> *))
             (@ (g_agiGQ :: * -> *))
             (v_X6A :: Functor f_agiGP)
             (v1_B2 :: Contravariant g_agiGQ) ->
       Data.Functor.Contravariant.C:Contravariant TYPE: f_agiGP
                                                        :.: g_agiGQ
                                                  (Data.Functor.Contravariant.$fContravariant:.:2
                                                     @ f_agiGP @ g_agiGQ v_X6A v1_B2)
                                                  `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                                          <a -> b>_R
                                                          ->_R <(:.:) f_agiGP g_agiGQ b>_R
                                                          ->_R Sym (GHC.Generics.N::.:[0]
                                                                        <*>_N
                                                                        <*>_N
                                                                        <f_agiGP>_R
                                                                        <g_agiGQ>_N
                                                                        <a>_N)
                                                          :: (forall a b.
                                                              (a -> b)
                                                              -> (:.:) f_agiGP g_agiGQ b
                                                              -> f_agiGP (g_agiGQ a) :: *)
                                                             ~R# (forall a b.
                                                                  (a -> b)
                                                                  -> (:.:) f_agiGP g_agiGQ b
                                                                  -> (:.:) f_agiGP g_agiGQ a :: *))
                                                  (Data.Functor.Contravariant.$fContravariant:.:1
                                                     @ f_agiGP @ g_agiGQ v_X6A v1_B2)
                                                  `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                                          <b>_R
                                                          ->_R <(:.:) f_agiGP g_agiGQ b>_R
                                                          ->_R Sym (GHC.Generics.N::.:[0]
                                                                        <*>_N
                                                                        <*>_N
                                                                        <f_agiGP>_R
                                                                        <g_agiGQ>_N
                                                                        <a>_N)
                                                          :: (forall b a.
                                                              b
                                                              -> (:.:) f_agiGP g_agiGQ b
                                                              -> f_agiGP (g_agiGQ a) :: *)
                                                             ~R# (forall b a.
                                                                  b
                                                                  -> (:.:) f_agiGP g_agiGQ b
                                                                  -> (:.:) f_agiGP g_agiGQ a :: *))]
Data.Functor.Contravariant.$fContravariant:.:
  = \ (@ (f_XgjkQ :: * -> *))
      (@ (g_XgjkS :: * -> *))
      ($dFunctor_XgjkU :: Functor f_XgjkQ)
      ($dContravariant_XgjkW :: Contravariant g_XgjkS) ->
      Data.Functor.Contravariant.C:Contravariant
        @ (f_XgjkQ :.: g_XgjkS)
        ((Data.Functor.Contravariant.$fContravariant:.:2
            @ f_XgjkQ @ g_XgjkS $dFunctor_XgjkU $dContravariant_XgjkW)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <(:.:) f_XgjkQ g_XgjkS b>_R
                 ->_R Sym (GHC.Generics.N::.:[0]
                               <*>_N <*>_N <f_XgjkQ>_R <g_XgjkS>_N <a>_N)
                 :: (forall a b.
                     (a -> b) -> (:.:) f_XgjkQ g_XgjkS b -> f_XgjkQ (g_XgjkS a) :: *)
                    ~R# (forall a b.
                         (a -> b)
                         -> (:.:) f_XgjkQ g_XgjkS b -> (:.:) f_XgjkQ g_XgjkS a :: *)))
        ((Data.Functor.Contravariant.$fContravariant:.:1
            @ f_XgjkQ @ g_XgjkS $dFunctor_XgjkU $dContravariant_XgjkW)
         `cast` (forall (b :: <*>_N) (a :: <*>_N).
                 <b>_R
                 ->_R <(:.:) f_XgjkQ g_XgjkS b>_R
                 ->_R Sym (GHC.Generics.N::.:[0]
                               <*>_N <*>_N <f_XgjkQ>_R <g_XgjkS>_N <a>_N)
                 :: (forall b a.
                     b -> (:.:) f_XgjkQ g_XgjkS b -> f_XgjkQ (g_XgjkS a) :: *)
                    ~R# (forall b a.
                         b -> (:.:) f_XgjkQ g_XgjkS b -> (:.:) f_XgjkQ g_XgjkS a :: *)))

-- RHS size: {terms: 20, types: 45, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariant:*:_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Contravariant f, Contravariant g) =>
     forall a b. (a -> b) -> (:*:) f g b -> (:*:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_agjfa :: * -> *))
                 (@ (g_agjfb :: * -> *))
                 ($dContravariant_agjfc [Occ=Once] :: Contravariant f_agjfa)
                 ($dContravariant1_agjfd [Occ=Once] :: Contravariant g_agjfb)
                 (@ a_agjfh)
                 (@ b_agjfi)
                 (f1_agiGV :: a_agjfh -> b_agjfi)
                 (ds_dgjsc [Occ=Once!] :: (:*:) f_agjfa g_agjfb b_agjfi) ->
                 case ds_dgjsc of { :*: xs_agiGW [Occ=Once] ys_agiGX [Occ=Once] ->
                 GHC.Generics.:*:
                   @ *
                   @ f_agjfa
                   @ g_agjfb
                   @ a_agjfh
                   (contramap
                      @ f_agjfa
                      $dContravariant_agjfc
                      @ a_agjfh
                      @ b_agjfi
                      f1_agiGV
                      xs_agiGW)
                   (contramap
                      @ g_agjfb
                      $dContravariant1_agjfd
                      @ a_agjfh
                      @ b_agjfi
                      f1_agiGV
                      ys_agiGX)
                 }}]
Data.Functor.Contravariant.$fContravariant:*:_$ccontramap
  = \ (@ (f_agjfa :: * -> *))
      (@ (g_agjfb :: * -> *))
      ($dContravariant_agjfc :: Contravariant f_agjfa)
      ($dContravariant1_agjfd :: Contravariant g_agjfb)
      (@ a_agjfh)
      (@ b_agjfi)
      (f1_agiGV :: a_agjfh -> b_agjfi)
      (ds_dgjsc :: (:*:) f_agjfa g_agjfb b_agjfi) ->
      case ds_dgjsc of { :*: xs_agiGW ys_agiGX ->
      GHC.Generics.:*:
        @ *
        @ f_agjfa
        @ g_agjfb
        @ a_agjfh
        (contramap
           @ f_agjfa
           $dContravariant_agjfc
           @ a_agjfh
           @ b_agjfi
           f1_agiGV
           xs_agiGW)
        (contramap
           @ g_agjfb
           $dContravariant1_agjfd
           @ a_agjfh
           @ b_agjfi
           f1_agiGV
           ys_agiGX)
      }

-- RHS size: {terms: 11, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariant:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Contravariant f, Contravariant g) =>
     Contravariant (f :*: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ (f_agiGT :: * -> *))
             (@ (g_agiGU :: * -> *))
             (v_X6C :: Contravariant f_agiGT)
             (v1_B2 :: Contravariant g_agiGU) ->
       Data.Functor.Contravariant.C:Contravariant TYPE: f_agiGT
                                                        :*: g_agiGU
                                                  Data.Functor.Contravariant.$fContravariant:*:_$ccontramap
                                                    @ f_agiGT @ g_agiGU v_X6C v1_B2
                                                  Data.Functor.Contravariant.$fContravariant:*:_$c>$
                                                    @ f_agiGT @ g_agiGU v_X6C v1_B2]
Data.Functor.Contravariant.$fContravariant:*:
  = \ (@ (f_agjfa :: * -> *))
      (@ (g_agjfb :: * -> *))
      ($dContravariant_agjfc :: Contravariant f_agjfa)
      ($dContravariant1_agjfd :: Contravariant g_agjfb) ->
      Data.Functor.Contravariant.C:Contravariant
        @ (f_agjfa :*: g_agjfb)
        (Data.Functor.Contravariant.$fContravariant:*:_$ccontramap
           @ f_agjfa @ g_agjfb $dContravariant_agjfc $dContravariant1_agjfd)
        (Data.Functor.Contravariant.$fContravariant:*:_$c>$
           @ f_agjfa @ g_agjfb $dContravariant_agjfc $dContravariant1_agjfd)

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantK3
  :: forall i c a b. (a -> b) -> K1 i c b -> K1 i c b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_agjfJ)
                 (@ c_agjfK)
                 (@ a_agjfO)
                 (@ b_agjfP)
                 _ [Occ=Dead]
                 (ds1_dgjsi [Occ=Once] :: K1 i_agjfJ c_agjfK b_agjfP) ->
                 ds1_dgjsi}]
Data.Functor.Contravariant.$fContravariantK3
  = \ (@ i_agjfJ)
      (@ c_agjfK)
      (@ a_agjfO)
      (@ b_agjfP)
      _ [Occ=Dead]
      (ds1_dgjsi :: K1 i_agjfJ c_agjfK b_agjfP) ->
      ds1_dgjsi

-- RHS size: {terms: 7, types: 17, coercions: 59, joins: 0/0}
Data.Functor.Contravariant.$fContravariantK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c. Contravariant (K1 i c)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ i_agiGY) (@ c_agiGZ) ->
       Data.Functor.Contravariant.C:Contravariant TYPE: K1 i_agiGY c_agiGZ
                                                  (Data.Functor.Contravariant.$fContravariantK3
                                                     @ i_agiGY @ c_agiGZ)
                                                  `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                                          <a -> b>_R
                                                          ->_R <K1 i_agiGY c_agiGZ b>_R
                                                          ->_R GHC.Generics.N:K1[0]
                                                                   <*>_N
                                                                   <i_agiGY>_P
                                                                   <c_agiGZ>_R
                                                                   <b>_P ; Sym (GHC.Generics.N:K1[0]
                                                                                    <*>_N
                                                                                    <i_agiGY>_P
                                                                                    <c_agiGZ>_R
                                                                                    <a>_P)
                                                          :: (forall a b.
                                                              (a -> b)
                                                              -> K1 i_agiGY c_agiGZ b
                                                              -> K1 i_agiGY c_agiGZ b :: *)
                                                             ~R# (forall a b.
                                                                  (a -> b)
                                                                  -> K1 i_agiGY c_agiGZ b
                                                                  -> K1 i_agiGY c_agiGZ a :: *))
                                                  (\ (@ b_agjfY) (@ a_agjfZ) ->
                                                     Data.Functor.Contravariant.$fContravariantK2
                                                       @ b_agjfY @ c_agiGZ @ i_agiGY)
                                                  `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                                          <b>_R
                                                          ->_R <K1 i_agiGY c_agiGZ b>_R
                                                          ->_R GHC.Generics.N:K1[0]
                                                                   <*>_N
                                                                   <i_agiGY>_P
                                                                   <c_agiGZ>_R
                                                                   <b>_P ; Sym (GHC.Generics.N:K1[0]
                                                                                    <*>_N
                                                                                    <i_agiGY>_P
                                                                                    <c_agiGZ>_R
                                                                                    <a>_P)
                                                          :: (forall b a.
                                                              b
                                                              -> K1 i_agiGY c_agiGZ b
                                                              -> K1 i_agiGY c_agiGZ b :: *)
                                                             ~R# (forall b a.
                                                                  b
                                                                  -> K1 i_agiGY c_agiGZ b
                                                                  -> K1 i_agiGY c_agiGZ a :: *))]
Data.Functor.Contravariant.$fContravariantK1
  = \ (@ i_Xgjm3) (@ c_Xgjm5) ->
      Data.Functor.Contravariant.C:Contravariant
        @ (K1 i_Xgjm3 c_Xgjm5)
        ((Data.Functor.Contravariant.$fContravariantK3 @ i_Xgjm3 @ c_Xgjm5)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <K1 i_Xgjm3 c_Xgjm5 b>_R
                 ->_R GHC.Generics.N:K1[0]
                          <*>_N <i_Xgjm3>_P <c_Xgjm5>_R <b>_P ; Sym (GHC.Generics.N:K1[0]
                                                                         <*>_N
                                                                         <i_Xgjm3>_P
                                                                         <c_Xgjm5>_R
                                                                         <a>_P)
                 :: (forall a b.
                     (a -> b) -> K1 i_Xgjm3 c_Xgjm5 b -> K1 i_Xgjm3 c_Xgjm5 b :: *)
                    ~R# (forall a b.
                         (a -> b) -> K1 i_Xgjm3 c_Xgjm5 b -> K1 i_Xgjm3 c_Xgjm5 a :: *)))
        ((\ (@ b_agjfY) (@ a_agjfZ) ->
            Data.Functor.Contravariant.$fContravariantK2
              @ b_agjfY @ c_Xgjm5 @ i_Xgjm3)
         `cast` (forall (b :: <*>_N) (a :: <*>_N).
                 <b>_R
                 ->_R <K1 i_Xgjm3 c_Xgjm5 b>_R
                 ->_R GHC.Generics.N:K1[0]
                          <*>_N <i_Xgjm3>_P <c_Xgjm5>_R <b>_P ; Sym (GHC.Generics.N:K1[0]
                                                                         <*>_N
                                                                         <i_Xgjm3>_P
                                                                         <c_Xgjm5>_R
                                                                         <a>_P)
                 :: (forall b a.
                     b -> K1 i_Xgjm3 c_Xgjm5 b -> K1 i_Xgjm3 c_Xgjm5 b :: *)
                    ~R# (forall b a.
                         b -> K1 i_Xgjm3 c_Xgjm5 b -> K1 i_Xgjm3 c_Xgjm5 a :: *)))

-- RHS size: {terms: 5, types: 13, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantU1_$ccontramap
  :: forall a b. (a -> b) -> U1 b -> U1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agjga) (@ b_agjgb) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Generics.U1 @ * @ a_agjga}]
Data.Functor.Contravariant.$fContravariantU1_$ccontramap
  = \ (@ a_agjga) (@ b_agjgb) _ [Occ=Dead] _ [Occ=Dead] ->
      GHC.Generics.U1 @ * @ a_agjga

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Contravariant U1
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Contravariant.C:Contravariant TYPE: U1
                                                  Data.Functor.Contravariant.$fContravariantU1_$ccontramap
                                                  Data.Functor.Contravariant.$fContravariantU1_$c>$]
Data.Functor.Contravariant.$fContravariantU1
  = Data.Functor.Contravariant.C:Contravariant
      @ U1
      Data.Functor.Contravariant.$fContravariantU1_$ccontramap
      Data.Functor.Contravariant.$fContravariantU1_$c>$

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantV1_$ccontramap
  :: forall a b. (a -> b) -> V1 b -> V1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agjgu)
                 (@ b_agjgv)
                 _ [Occ=Dead]
                 (x_agiH1 [Occ=Once] :: V1 b_agjgv) ->
                 case x_agiH1 of { }}]
Data.Functor.Contravariant.$fContravariantV1_$ccontramap
  = \ (@ a_agjgu) (@ b_agjgv) _ [Occ=Dead] (x_agiH1 :: V1 b_agjgv) ->
      case x_agiH1 of { }

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fContravariantV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Contravariant V1
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Contravariant.C:Contravariant TYPE: V1
                                                  Data.Functor.Contravariant.$fContravariantV1_$ccontramap
                                                  Data.Functor.Contravariant.$fContravariantV1_$c>$]
Data.Functor.Contravariant.$fContravariantV1
  = Data.Functor.Contravariant.C:Contravariant
      @ V1
      Data.Functor.Contravariant.$fContravariantV1_$ccontramap
      Data.Functor.Contravariant.$fContravariantV1_$c>$

-- RHS size: {terms: 11, types: 11, coercions: 0, joins: 0/0}
lvl2_rgjLt
  :: forall a b1.
     Integral b1 =>
     b1 -> (a -> Ordering) -> a -> Ordering
[GblId, Arity=4, Str=<L,U><L,U><L,1*C1(U)><L,U>, Unf=OtherCon []]
lvl2_rgjLt
  = \ (@ a_X9wn3)
      (@ b1_igjtM)
      ($dIntegral_igjtN :: Integral b1_igjtM)
      (n_igjtO :: b1_igjtM)
      (f_igjtP :: a_X9wn3 -> Ordering)
      (e_igjtQ :: a_X9wn3) ->
      GHC.Base.$fSemigroupOrdering_$cstimes
        @ b1_igjtM $dIntegral_igjtN n_igjtO (f_igjtP e_igjtQ)

-- RHS size: {terms: 9, types: 15, coercions: 0, joins: 0/0}
lvl3_rgjLu
  :: forall a. GHC.Base.NonEmpty (a -> Ordering) -> a -> Ordering
[GblId, Arity=1, Str=<S(LS),1*U(U,1*U)>, Unf=OtherCon []]
lvl3_rgjLu
  = \ (@ a_X9wn3)
      (w1_igjtU :: GHC.Base.NonEmpty (a_X9wn3 -> Ordering)) ->
      case w1_igjtU of { GHC.Base.:| ww1_igju0 ww2_igju1 ->
      GHC.Base.$w$csconcat3
        @ Ordering
        @ a_X9wn3
        GHC.Base.$fSemigroupOrdering
        ww1_igju0
        ww2_igju1
      }

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
lvl4_rgjLv
  :: forall a. (a -> Ordering) -> (a -> Ordering) -> a -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []]
lvl4_rgjLv
  = \ (@ a_X9wn3)
      (f_igju9 :: a_X9wn3 -> Ordering)
      (g_igjua :: a_X9wn3 -> Ordering)
      (x_igjub :: a_X9wn3) ->
      case f_igju9 x_igjub of {
        LT -> GHC.Types.LT;
        EQ -> g_igjua x_igjub;
        GT -> GHC.Types.GT
      }

-- RHS size: {terms: 5, types: 7, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup (a -> Ordering)
[GblId,
 Str=m,
 Unf=DFun: \ (@ a_i9wn0) ->
       GHC.Base.C:Semigroup TYPE: a_i9wn0 -> Ordering
                            \ (f_igju9 [Occ=Once!] :: a_i9wn0 -> Ordering)
                              (g_igjua [Occ=Once!] :: a_i9wn0 -> Ordering)
                              (x_igjub :: a_i9wn0) ->
                              case f_igju9 x_igjub of {
                                LT -> GHC.Types.LT;
                                EQ -> g_igjua x_igjub;
                                GT -> GHC.Types.GT
                              }
                            GHC.Base.$fSemigroup(->)_$csconcat
                              @ Ordering @ a_i9wn0 GHC.Base.$fSemigroupOrdering
                            \ (@ b1_igjtM)
                              ($dIntegral_igjtN [Occ=Once] :: Integral b1_igjtM)
                              (n_igjtO [Occ=Once] :: b1_igjtM)
                              (f_igjtP [Occ=Once!] :: a_i9wn0 -> Ordering)
                              (e_igjtQ [Occ=Once] :: a_i9wn0) ->
                              GHC.Base.$fSemigroupOrdering_$cstimes
                                @ b1_igjtM $dIntegral_igjtN n_igjtO (f_igjtP e_igjtQ)]
Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
  = \ (@ a_X9wn3) ->
      GHC.Base.C:Semigroup
        @ (a_X9wn3 -> Ordering)
        (lvl4_rgjLv @ a_X9wn3)
        (lvl3_rgjLu @ a_X9wn3)
        (lvl2_rgjLt @ a_X9wn3)

-- RHS size: {terms: 9, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fSemigroupComparison2
  :: forall a.
     GHC.Base.NonEmpty (a -> a -> Ordering) -> a -> a -> Ordering
[GblId,
 Arity=1,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xgj0o)
                 (w1_igjtU [Occ=Once!]
                    :: GHC.Base.NonEmpty (a_Xgj0o -> a_Xgj0o -> Ordering)) ->
                 case w1_igjtU of
                 { GHC.Base.:| ww1_igju0 [Occ=Once] ww2_igju1 [Occ=Once] ->
                 GHC.Base.$w$csconcat3
                   @ (a_Xgj0o -> Ordering)
                   @ a_Xgj0o
                   (Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
                      @ a_Xgj0o)
                   ww1_igju0
                   ww2_igju1
                 }}]
Data.Functor.Contravariant.$fSemigroupComparison2
  = \ (@ a_Xgj0o)
      (w1_igjtU :: GHC.Base.NonEmpty (a_Xgj0o -> a_Xgj0o -> Ordering)) ->
      case w1_igjtU of { GHC.Base.:| ww1_igju0 ww2_igju1 ->
      GHC.Base.$w$csconcat3
        @ (a_Xgj0o -> Ordering)
        @ a_Xgj0o
        (Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
           @ a_Xgj0o)
        ww1_igju0
        ww2_igju1
      }

-- RHS size: {terms: 5, types: 7, coercions: 34, joins: 0/0}
Data.Functor.Contravariant.$fSemigroupComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup (Comparison a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_agiHq) ->
       GHC.Base.C:Semigroup TYPE: Comparison a_agiHq
                            (Data.Functor.Contravariant.$fSemigroupComparison3 @ a_agiHq)
                            `cast` (Sym (Data.Functor.Contravariant.N:Comparison[0]
                                             <a_agiHq>_R)
                                    ->_R Sym (Data.Functor.Contravariant.N:Comparison[0]
                                                  <a_agiHq>_R)
                                    ->_R Sym (Data.Functor.Contravariant.N:Comparison[0]
                                                  <a_agiHq>_R)
                                    :: ((a_agiHq -> a_agiHq -> Ordering)
                                        -> (a_agiHq -> a_agiHq -> Ordering)
                                        -> a_agiHq
                                        -> a_agiHq
                                        -> Ordering :: *)
                                       ~R# (Comparison a_agiHq
                                            -> Comparison a_agiHq -> Comparison a_agiHq :: *))
                            (Data.Functor.Contravariant.$fSemigroupComparison2 @ a_agiHq)
                            `cast` ((GHC.Base.NonEmpty
                                       (Sym (Data.Functor.Contravariant.N:Comparison[0]
                                                 <a_agiHq>_R)))_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Comparison[0]
                                                  <a_agiHq>_R)
                                    :: (GHC.Base.NonEmpty (a_agiHq -> a_agiHq -> Ordering)
                                        -> a_agiHq -> a_agiHq -> Ordering :: *)
                                       ~R# (GHC.Base.NonEmpty (Comparison a_agiHq)
                                            -> Comparison a_agiHq :: *))
                            (Data.Functor.Contravariant.$fSemigroupComparison1 @ a_agiHq)
                            `cast` (forall (b :: <*>_N).
                                    <Integral b>_R
                                    ->_R <b>_R
                                    ->_R Sym (Data.Functor.Contravariant.N:Comparison[0]
                                                  <a_agiHq>_R)
                                    ->_R Sym (Data.Functor.Contravariant.N:Comparison[0]
                                                  <a_agiHq>_R)
                                    :: (forall b.
                                        Integral b =>
                                        b
                                        -> (a_agiHq -> a_agiHq -> Ordering)
                                        -> a_agiHq
                                        -> a_agiHq
                                        -> Ordering :: *)
                                       ~R# (forall b.
                                            Integral b =>
                                            b -> Comparison a_agiHq -> Comparison a_agiHq :: *))]
Data.Functor.Contravariant.$fSemigroupComparison
  = \ (@ a_Xgj0q) ->
      GHC.Base.C:Semigroup
        @ (Comparison a_Xgj0q)
        ((Data.Functor.Contravariant.$fSemigroupComparison3 @ a_Xgj0q)
         `cast` (Sym (Data.Functor.Contravariant.N:Comparison[0]
                          <a_Xgj0q>_R)
                 ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a_Xgj0q>_R)
                 ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a_Xgj0q>_R)
                 :: ((a_Xgj0q -> a_Xgj0q -> Ordering)
                     -> (a_Xgj0q -> a_Xgj0q -> Ordering)
                     -> a_Xgj0q
                     -> a_Xgj0q
                     -> Ordering :: *)
                    ~R# (Comparison a_Xgj0q
                         -> Comparison a_Xgj0q -> Comparison a_Xgj0q :: *)))
        ((Data.Functor.Contravariant.$fSemigroupComparison2 @ a_Xgj0q)
         `cast` ((GHC.Base.NonEmpty
                    (Sym (Data.Functor.Contravariant.N:Comparison[0] <a_Xgj0q>_R)))_R
                 ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a_Xgj0q>_R)
                 :: (GHC.Base.NonEmpty (a_Xgj0q -> a_Xgj0q -> Ordering)
                     -> a_Xgj0q -> a_Xgj0q -> Ordering :: *)
                    ~R# (GHC.Base.NonEmpty (Comparison a_Xgj0q)
                         -> Comparison a_Xgj0q :: *)))
        ((Data.Functor.Contravariant.$fSemigroupComparison1 @ a_Xgj0q)
         `cast` (forall (b :: <*>_N).
                 <Integral b>_R
                 ->_R <b>_R
                 ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a_Xgj0q>_R)
                 ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a_Xgj0q>_R)
                 :: (forall b.
                     Integral b =>
                     b
                     -> (a_Xgj0q -> a_Xgj0q -> Ordering)
                     -> a_Xgj0q
                     -> a_Xgj0q
                     -> Ordering :: *)
                    ~R# (forall b.
                         Integral b =>
                         b -> Comparison a_Xgj0q -> Comparison a_Xgj0q :: *)))

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
lvl5_rgjLw :: forall a. a -> Ordering
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []]
lvl5_rgjLw = \ (@ a_X9wjW) _ [Occ=Dead] -> GHC.Types.EQ

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl6_rgjLx :: forall a. [a -> Ordering] -> a -> Ordering
[GblId, Arity=2, Unf=OtherCon []]
lvl6_rgjLx
  = \ (@ a_X9wjW) ->
      GHC.Base.$fMonoid(->)_$cmconcat
        @ Ordering @ a_X9wjW GHC.Base.$fMonoidOrdering

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Monoid (a -> Ordering)
[GblId,
 Str=m,
 Unf=DFun: \ (@ a_i9wjU) ->
       GHC.Base.C:Monoid TYPE: a_i9wjU -> Ordering
                         Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
                           @ a_i9wjU
                         \ _ [Occ=Dead] -> GHC.Types.EQ
                         \ (f_igjuE [Occ=Once!] :: a_i9wjU -> Ordering)
                           (g_igjuF [Occ=Once!] :: a_i9wjU -> Ordering)
                           (x_igjuG :: a_i9wjU) ->
                           case f_igjuE x_igjuG of {
                             LT -> GHC.Types.LT;
                             EQ -> g_igjuF x_igjuG;
                             GT -> GHC.Types.GT
                           }
                         GHC.Base.$fMonoid(->)_$cmconcat
                           @ Ordering @ a_i9wjU GHC.Base.$fMonoidOrdering]
Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)
  = \ (@ a_X9wjW) ->
      GHC.Base.C:Monoid
        @ (a_X9wjW -> Ordering)
        (Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
           @ a_X9wjW)
        (lvl5_rgjLw @ a_X9wjW)
        (lvl4_rgjLv @ a_X9wjW)
        (lvl6_rgjLx @ a_X9wjW)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Contravariant.$fMonoidComparison1
  :: forall a. [a -> a -> Ordering] -> a -> a -> Ordering
[GblId,
 Arity=2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
Data.Functor.Contravariant.$fMonoidComparison1
  = \ (@ a_agiTx) ->
      GHC.Base.$fMonoid(->)_$cmconcat
        @ (a_agiTx -> Ordering)
        @ a_agiTx
        (Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)
           @ a_agiTx)

-- RHS size: {terms: 6, types: 8, coercions: 22, joins: 0/0}
Data.Functor.Contravariant.$fMonoidComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Monoid (Comparison a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_agiHp) ->
       GHC.Base.C:Monoid TYPE: Comparison a_agiHp
                         Data.Functor.Contravariant.$fSemigroupComparison @ a_agiHp
                         (Data.Functor.Contravariant.$fMonoidComparison3 @ a_agiHp)
                         `cast` (Sym (Data.Functor.Contravariant.N:Comparison[0]
                                          <a_agiHp>_R)
                                 :: (a_agiHp -> a_agiHp -> Ordering :: *)
                                    ~R# (Comparison a_agiHp :: *))
                         (Data.Functor.Contravariant.$fMonoidComparison2 @ a_agiHp)
                         `cast` (Sym (Data.Functor.Contravariant.N:Comparison[0]
                                          <a_agiHp>_R)
                                 ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a_agiHp>_R)
                                 ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a_agiHp>_R)
                                 :: ((a_agiHp -> a_agiHp -> Ordering)
                                     -> (a_agiHp -> a_agiHp -> Ordering)
                                     -> a_agiHp
                                     -> a_agiHp
                                     -> Ordering :: *)
                                    ~R# (Comparison a_agiHp
                                         -> Comparison a_agiHp -> Comparison a_agiHp :: *))
                         (Data.Functor.Contravariant.$fMonoidComparison1 @ a_agiHp)
                         `cast` (([Sym (Data.Functor.Contravariant.N:Comparison[0]
                                            <a_agiHp>_R)])_R
                                 ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a_agiHp>_R)
                                 :: ([a_agiHp -> a_agiHp -> Ordering]
                                     -> a_agiHp -> a_agiHp -> Ordering :: *)
                                    ~R# ([Comparison a_agiHp] -> Comparison a_agiHp :: *))]
Data.Functor.Contravariant.$fMonoidComparison
  = \ (@ a_agiTx) ->
      GHC.Base.C:Monoid
        @ (Comparison a_agiTx)
        (Data.Functor.Contravariant.$fSemigroupComparison @ a_agiTx)
        ((Data.Functor.Contravariant.$fMonoidComparison3 @ a_agiTx)
         `cast` (Sym (Data.Functor.Contravariant.N:Comparison[0]
                          <a_agiTx>_R)
                 :: (a_agiTx -> a_agiTx -> Ordering :: *)
                    ~R# (Comparison a_agiTx :: *)))
        ((Data.Functor.Contravariant.$fMonoidComparison2 @ a_agiTx)
         `cast` (Sym (Data.Functor.Contravariant.N:Comparison[0]
                          <a_agiTx>_R)
                 ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a_agiTx>_R)
                 ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a_agiTx>_R)
                 :: ((a_agiTx -> a_agiTx -> Ordering)
                     -> (a_agiTx -> a_agiTx -> Ordering)
                     -> a_agiTx
                     -> a_agiTx
                     -> Ordering :: *)
                    ~R# (Comparison a_agiTx
                         -> Comparison a_agiTx -> Comparison a_agiTx :: *)))
        ((Data.Functor.Contravariant.$fMonoidComparison1 @ a_agiTx)
         `cast` (([Sym (Data.Functor.Contravariant.N:Comparison[0]
                            <a_agiTx>_R)])_R
                 ->_R Sym (Data.Functor.Contravariant.N:Comparison[0] <a_agiTx>_R)
                 :: ([a_agiTx -> a_agiTx -> Ordering]
                     -> a_agiTx -> a_agiTx -> Ordering :: *)
                    ~R# ([Comparison a_agiTx] -> Comparison a_agiTx :: *)))


------ Local rules for imported ids --------
"SPEC/Data.Functor.Contravariant $fSemigroup(->) @ Ordering _"
    forall (@ a_i9wn0) (v_XgjFg :: Semigroup Ordering).
      GHC.Base.$fSemigroup(->) @ Ordering @ a_i9wn0 v_XgjFg
      = Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
          @ a_i9wn0
"SPEC/Data.Functor.Contravariant $fMonoid(->) @ Ordering _"
    forall (@ a_i9wjU) (v_sgjye :: Monoid Ordering).
      GHC.Base.$fMonoid(->) @ Ordering @ a_i9wjU v_sgjye
      = Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)
          @ a_i9wjU

