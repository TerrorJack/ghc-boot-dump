
==================== Output Cmm ====================
2018-03-16 16:12:13.271956307 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:13.27296259 UTC

[section ""data" . Data.Functor.Contravariant.contramap_closure" {
     Data.Functor.Contravariant.contramap_closure:
         const Data.Functor.Contravariant.contramap_info;
 },
 Data.Functor.Contravariant.contramap_entry() //  [R2]
         { info_tbl: [(cgjUh,
                       label: Data.Functor.Contravariant.contramap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjUh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgjUi; else goto cgjUj;
       cgjUi: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.contramap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgjUj: // global
           I64[Sp - 8] = block_cgjUe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugjUn; else goto cgjUf;
       ugjUn: // global
           call _cgjUe(R1) args: 0, res: 0, upd: 0;
       cgjUf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgjUe() //  [R1]
         { info_tbl: [(cgjUe,
                       label: block_cgjUe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjUe: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.274201818 UTC

[section ""data" . Data.Functor.Contravariant.>$_closure" {
     Data.Functor.Contravariant.>$_closure:
         const Data.Functor.Contravariant.>$_info;
 },
 Data.Functor.Contravariant.>$_entry() //  [R2]
         { info_tbl: [(cgjUv,
                       label: Data.Functor.Contravariant.>$_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjUv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgjUw; else goto cgjUx;
       cgjUw: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.>$_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgjUx: // global
           I64[Sp - 8] = block_cgjUs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugjUB; else goto cgjUt;
       ugjUB: // global
           call _cgjUs(R1) args: 0, res: 0, upd: 0;
       cgjUt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgjUs() //  [R1]
         { info_tbl: [(cgjUs,
                       label: block_cgjUs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjUs: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.275177151 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Op3_bytes" {
     Data.Functor.Contravariant.$tc'Op3_bytes:
         I8[] [39,79,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.275756794 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Op2_closure" {
     Data.Functor.Contravariant.$tc'Op2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Op3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.276340555 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcOp2_bytes" {
     Data.Functor.Contravariant.$tcOp2_bytes:
         I8[] [79,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.276924046 UTC

[section ""data" . Data.Functor.Contravariant.$tcOp1_closure" {
     Data.Functor.Contravariant.$tcOp1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcOp2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.277536243 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Equivalence3_bytes" {
     Data.Functor.Contravariant.$tc'Equivalence3_bytes:
         I8[] [39,69,113,117,105,118,97,108,101,110,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.278104339 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Equivalence2_closure" {
     Data.Functor.Contravariant.$tc'Equivalence2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Equivalence3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.278668113 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcEquivalence2_bytes" {
     Data.Functor.Contravariant.$tcEquivalence2_bytes:
         I8[] [69,113,117,105,118,97,108,101,110,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.279219649 UTC

[section ""data" . Data.Functor.Contravariant.$tcEquivalence1_closure" {
     Data.Functor.Contravariant.$tcEquivalence1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcEquivalence2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.27977335 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Comparison3_bytes" {
     Data.Functor.Contravariant.$tc'Comparison3_bytes:
         I8[] [39,67,111,109,112,97,114,105,115,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.280348301 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Comparison2_closure" {
     Data.Functor.Contravariant.$tc'Comparison2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Comparison3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.280908872 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcComparison2_bytes" {
     Data.Functor.Contravariant.$tcComparison2_bytes:
         I8[] [67,111,109,112,97,114,105,115,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.28150985 UTC

[section ""data" . Data.Functor.Contravariant.$tcComparison1_closure" {
     Data.Functor.Contravariant.$tcComparison1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcComparison2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.282093941 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Predicate3_bytes" {
     Data.Functor.Contravariant.$tc'Predicate3_bytes:
         I8[] [39,80,114,101,100,105,99,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.282649112 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Predicate2_closure" {
     Data.Functor.Contravariant.$tc'Predicate2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Predicate3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.283208994 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcPredicate2_bytes" {
     Data.Functor.Contravariant.$tcPredicate2_bytes:
         I8[] [80,114,101,100,105,99,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.283780547 UTC

[section ""data" . Data.Functor.Contravariant.$tcPredicate1_closure" {
     Data.Functor.Contravariant.$tcPredicate1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcPredicate2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.284369181 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcContravariant3_bytes" {
     Data.Functor.Contravariant.$tcContravariant3_bytes:
         I8[] [67,111,110,116,114,97,118,97,114,105,97,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.284925556 UTC

[section ""data" . Data.Functor.Contravariant.$tcContravariant2_closure" {
     Data.Functor.Contravariant.$tcContravariant2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcContravariant3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.285569323 UTC

[section ""data" . $krep_rgjLa_closure" {
     $krep_rgjLa_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.286142185 UTC

[section ""data" . $krep1_rgjLb_closure" {
     $krep1_rgjLb_closure:
         const :_con_info;
         const $krep_rgjLa_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.286720799 UTC

[section ""data" . $krep2_rgjLc_closure" {
     $krep2_rgjLc_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.287307512 UTC

[section ""data" . $krep3_rgjLd_closure" {
     $krep3_rgjLd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rgjLc_closure+2;
         const $krep_rgjLa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.287895148 UTC

[section ""data" . $krep4_rgjLe_closure" {
     $krep4_rgjLe_closure:
         const :_con_info;
         const $krep2_rgjLc_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.288463348 UTC

[section ""data" . $krep5_rgjLf_closure" {
     $krep5_rgjLf_closure:
         const :_con_info;
         const $krep_rgjLa_closure+2;
         const $krep4_rgjLe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.289029779 UTC

[section ""data" . $krep6_rgjLg_closure" {
     $krep6_rgjLg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.28963316 UTC

[section ""data" . $krep7_rgjLh_closure" {
     $krep7_rgjLh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep6_rgjLg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.290208549 UTC

[section ""data" . $krep8_rgjLi_closure" {
     $krep8_rgjLi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep7_rgjLh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.290828227 UTC

[section ""data" . $krep9_rgjLj_closure" {
     $krep9_rgjLj_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcOrdering_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.291477319 UTC

[section ""data" . $krep10_rgjLk_closure" {
     $krep10_rgjLk_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep9_rgjLj_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.292040491 UTC

[section ""data" . $krep11_rgjLl_closure" {
     $krep11_rgjLl_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep10_rgjLk_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.292663685 UTC

[section ""data" . $krep12_rgjLm_closure" {
     $krep12_rgjLm_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.29323682 UTC

[section ""data" . Data.Functor.Contravariant.$tcContravariant1_closure" {
     Data.Functor.Contravariant.$tcContravariant1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep12_rgjLm_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.293789802 UTC

[section ""cstring" . Data.Functor.Contravariant.$trModule2_bytes" {
     Data.Functor.Contravariant.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,110,116,114,97,118,97,114,105,97,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.294313702 UTC

[section ""data" . Data.Functor.Contravariant.$trModule1_closure" {
     Data.Functor.Contravariant.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.294877905 UTC

[section ""cstring" . Data.Functor.Contravariant.$trModule4_bytes" {
     Data.Functor.Contravariant.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.295414005 UTC

[section ""data" . Data.Functor.Contravariant.$trModule3_closure" {
     Data.Functor.Contravariant.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.295991305 UTC

[section ""data" . Data.Functor.Contravariant.$trModule_closure" {
     Data.Functor.Contravariant.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Contravariant.$trModule3_closure+1;
         const Data.Functor.Contravariant.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.298548853 UTC

[section ""data" . Data.Functor.Contravariant.$tcContravariant_closure" {
     Data.Functor.Contravariant.$tcContravariant_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcContravariant2_closure+1;
         const Data.Functor.Contravariant.$tcContravariant1_closure+4;
         const 1944710495430526909;
         const 15571985404928937498;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.299183294 UTC

[section ""data" . Data.Functor.Contravariant.$tcPredicate_closure" {
     Data.Functor.Contravariant.$tcPredicate_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcPredicate1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 9927645946720114643;
         const 17478425232619398566;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.299758401 UTC

[section ""data" . $krep13_rgjLn_closure" {
     $krep13_rgjLn_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcPredicate_closure+1;
         const $krep1_rgjLb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.300312629 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Predicate1_closure" {
     Data.Functor.Contravariant.$tc'Predicate1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rgjLh_closure+4;
         const $krep13_rgjLn_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.300873863 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Predicate_closure" {
     Data.Functor.Contravariant.$tc'Predicate_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Predicate2_closure+1;
         const Data.Functor.Contravariant.$tc'Predicate1_closure+4;
         const 10560326927625189840;
         const 8988710799443424590;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.301523632 UTC

[section ""data" . Data.Functor.Contravariant.$tcComparison_closure" {
     Data.Functor.Contravariant.$tcComparison_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcComparison1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 8128667979445988110;
         const 9034904213662261762;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.30212366 UTC

[section ""data" . $krep14_rgjLo_closure" {
     $krep14_rgjLo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcComparison_closure+1;
         const $krep1_rgjLb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.302690953 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Comparison1_closure" {
     Data.Functor.Contravariant.$tc'Comparison1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_rgjLl_closure+4;
         const $krep14_rgjLo_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.30329132 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Comparison_closure" {
     Data.Functor.Contravariant.$tc'Comparison_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Comparison2_closure+1;
         const Data.Functor.Contravariant.$tc'Comparison1_closure+4;
         const 11047345948274903716;
         const 12707949450550295743;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.303911362 UTC

[section ""data" . Data.Functor.Contravariant.$tcEquivalence_closure" {
     Data.Functor.Contravariant.$tcEquivalence_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcEquivalence1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 9646573079009549553;
         const 12303965936368510845;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.304523525 UTC

[section ""data" . $krep15_rgjLp_closure" {
     $krep15_rgjLp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcEquivalence_closure+1;
         const $krep1_rgjLb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.305071043 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Equivalence1_closure" {
     Data.Functor.Contravariant.$tc'Equivalence1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rgjLi_closure+4;
         const $krep15_rgjLp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.306158932 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Equivalence_closure" {
     Data.Functor.Contravariant.$tc'Equivalence_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Equivalence2_closure+1;
         const Data.Functor.Contravariant.$tc'Equivalence1_closure+4;
         const 5667737350508967909;
         const 15093804341312440267;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.306762303 UTC

[section ""data" . Data.Functor.Contravariant.$tcOp_closure" {
     Data.Functor.Contravariant.$tcOp_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcOp1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 13209106975460307324;
         const 7546944290236364550;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.307406082 UTC

[section ""data" . $krep16_rgjLq_closure" {
     $krep16_rgjLq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcOp_closure+1;
         const $krep5_rgjLf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.307956837 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Op1_closure" {
     Data.Functor.Contravariant.$tc'Op1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rgjLd_closure+4;
         const $krep16_rgjLq_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.308571823 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Op_closure" {
     Data.Functor.Contravariant.$tc'Op_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Op2_closure+1;
         const Data.Functor.Contravariant.$tc'Op1_closure+4;
         const 12479862397628491530;
         const 1381176546464080972;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.30961885 UTC

[section ""data" . Data.Functor.Contravariant.comparisonEquivalence1_closure" {
     Data.Functor.Contravariant.comparisonEquivalence1_closure:
         const Data.Functor.Contravariant.comparisonEquivalence1_info;
 },
 Data.Functor.Contravariant.comparisonEquivalence1_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cgjUM,
                       label: Data.Functor.Contravariant.comparisonEquivalence1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjUM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgjUN; else goto cgjUO;
       cgjUN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.comparisonEquivalence1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgjUO: // global
           I64[Sp - 8] = block_cgjUG_info;
           _sgjLI::P64 = R3;
           R3 = R4;
           _sgjLH::P64 = R2;
           R2 = _sgjLI::P64;
           R1 = _sgjLH::P64;
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgjUG() //  [R1]
         { info_tbl: [(cgjUG,
                       label: block_cgjUG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjUG: // global
           if (R1 & 7 == 2) goto cgjUK; else goto cgjUJ;
       cgjUK: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgjUJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.310834136 UTC

[section ""data" . Data.Functor.Contravariant.comparisonEquivalence_closure" {
     Data.Functor.Contravariant.comparisonEquivalence_closure:
         const Data.Functor.Contravariant.comparisonEquivalence_info;
 },
 Data.Functor.Contravariant.comparisonEquivalence_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgjUZ,
                       label: Data.Functor.Contravariant.comparisonEquivalence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjUZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Contravariant.comparisonEquivalence1_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.311697217 UTC

[section ""data" . Data.Functor.Contravariant.defaultEquivalence_closure" {
     Data.Functor.Contravariant.defaultEquivalence_closure:
         const Data.Functor.Contravariant.defaultEquivalence_info;
 },
 Data.Functor.Contravariant.defaultEquivalence_entry() //  [R2]
         { info_tbl: [(cgjV6,
                       label: Data.Functor.Contravariant.defaultEquivalence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjV6: // global
           R2 = R2;
           call GHC.Classes.==_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.31248752 UTC

[section ""data" . Data.Functor.Contravariant.defaultComparison_closure" {
     Data.Functor.Contravariant.defaultComparison_closure:
         const Data.Functor.Contravariant.defaultComparison_info;
 },
 Data.Functor.Contravariant.defaultComparison_entry() //  [R2]
         { info_tbl: [(cgjVd,
                       label: Data.Functor.Contravariant.defaultComparison_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjVd: // global
           R2 = R2;
           call GHC.Classes.compare_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.313278154 UTC

[section ""data" . Data.Functor.Contravariant.>$$<_closure" {
     Data.Functor.Contravariant.>$$<_closure:
         const Data.Functor.Contravariant.>$$<_info;
 },
 Data.Functor.Contravariant.>$$<_entry() //  [R2, R3, R4]
         { info_tbl: [(cgjVk,
                       label: Data.Functor.Contravariant.>$$<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjVk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgjVl; else goto cgjVm;
       cgjVl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.>$$<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgjVm: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.314198092 UTC

[section ""data" . Data.Functor.Contravariant.>$<_closure" {
     Data.Functor.Contravariant.>$<_closure:
         const Data.Functor.Contravariant.>$<_info;
 },
 Data.Functor.Contravariant.>$<_entry() //  [R2]
         { info_tbl: [(cgjVr,
                       label: Data.Functor.Contravariant.>$<_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjVr: // global
           R2 = R2;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.315230096 UTC

[section ""data" . Data.Functor.Contravariant.phantom_closure" {
     Data.Functor.Contravariant.phantom_closure:
         const Data.Functor.Contravariant.phantom_info;
 },
 sat_sgjLS_entry() //  [R1]
         { info_tbl: [(cgjVC,
                       label: sat_sgjLS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjVC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgjVD; else goto cgjVE;
       cgjVD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgjVE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Tuple.()_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.<$_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.phantom_entry() //  [R2, R3, R4]
         { info_tbl: [(cgjVF,
                       label: Data.Functor.Contravariant.phantom_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjVF: // global
           _sgjLR::P64 = R4;
           _sgjLQ::P64 = R3;
           _sgjLP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgjVG; else goto cgjVH;
       cgjVH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgjVJ; else goto cgjVI;
       cgjVJ: // global
           HpAlloc = 32;
           goto cgjVG;
       cgjVG: // global
           R4 = _sgjLR::P64;
           R3 = _sgjLQ::P64;
           R2 = _sgjLP::P64;
           R1 = Data.Functor.Contravariant.phantom_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgjVI: // global
           I64[Hp - 24] = sat_sgjLS_info;
           P64[Hp - 8] = _sgjLP::P64;
           P64[Hp] = _sgjLR::P64;
           R2 = _sgjLQ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = GHC.Tuple.()_closure+1;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Functor.Contravariant.>$_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.316544736 UTC

[section ""data" . Data.Functor.Contravariant.$<_closure" {
     Data.Functor.Contravariant.$<_closure:
         const Data.Functor.Contravariant.$<_info;
 },
 Data.Functor.Contravariant.$<_entry() //  [R2, R3, R4]
         { info_tbl: [(cgjVO,
                       label: Data.Functor.Contravariant.$<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjVO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgjVP; else goto cgjVQ;
       cgjVP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgjVQ: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Data.Functor.Contravariant.>$_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.317486034 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantOp1_closure" {
     Data.Functor.Contravariant.$fContravariantOp1_closure:
         const Data.Functor.Contravariant.$fContravariantOp1_info;
 },
 Data.Functor.Contravariant.$fContravariantOp1_entry() //  [R2, R3]
         { info_tbl: [(cgjVV,
                       label: Data.Functor.Contravariant.$fContravariantOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjVV: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.318326335 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantOp2_closure" {
     Data.Functor.Contravariant.$fContravariantOp2_closure:
         const Data.Functor.Contravariant.$fContravariantOp2_info;
 },
 Data.Functor.Contravariant.$fContravariantOp2_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgjW2,
                       label: Data.Functor.Contravariant.$fContravariantOp2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjW2: // global
           R4 = R4;
           _sgjM0::P64 = R3;
           R3 = R2;
           R2 = _sgjM0::P64;
           call GHC.Base.._entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.319029155 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantOp_closure" {
     Data.Functor.Contravariant.$fContravariantOp_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantOp2_closure+3;
         const Data.Functor.Contravariant.$fContravariantOp1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.31971532 UTC

[section ""data" . Data.Functor.Contravariant.getOp1_closure" {
     Data.Functor.Contravariant.getOp1_closure:
         const Data.Functor.Contravariant.getOp1_info;
 },
 Data.Functor.Contravariant.getOp1_entry() //  [R2]
         { info_tbl: [(cgjW9,
                       label: Data.Functor.Contravariant.getOp1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjW9: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.320523936 UTC

[section ""data" . Data.Functor.Contravariant.getOp_closure" {
     Data.Functor.Contravariant.getOp_closure:
         const Data.Functor.Contravariant.getOp_info;
 },
 Data.Functor.Contravariant.getOp_entry() //  [R2]
         { info_tbl: [(cgjWg,
                       label: Data.Functor.Contravariant.getOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjWg: // global
           R2 = R2;
           call Data.Functor.Contravariant.getOp1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.32200607 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantEquivalence1_closure" {
     Data.Functor.Contravariant.$fContravariantEquivalence1_closure:
         const Data.Functor.Contravariant.$fContravariantEquivalence1_info;
 },
 Data.Functor.Contravariant.$fContravariantEquivalence1_entry() //  [R2,
                                                                     R3]
         { info_tbl: [(cgjWn,
                       label: Data.Functor.Contravariant.$fContravariantEquivalence1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjWn: // global
           _sgjM3::P64 = R3;
           R3 = R2;
           R2 = R2;
           R1 = _sgjM3::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.322981586 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantEquivalence2_closure" {
     Data.Functor.Contravariant.$fContravariantEquivalence2_closure:
         const Data.Functor.Contravariant.$fContravariantEquivalence2_info;
 },
 Data.Functor.Contravariant.$fContravariantEquivalence2_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cgjWw,
                       label: Data.Functor.Contravariant.$fContravariantEquivalence2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjWw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgjWA; else goto cgjWz;
       cgjWA: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantEquivalence2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgjWz: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _sgjM7::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 24;
           R1 = _sgjM7::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.323843264 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantEquivalence_closure" {
     Data.Functor.Contravariant.$fContravariantEquivalence_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantEquivalence2_closure+4;
         const Data.Functor.Contravariant.$fContravariantEquivalence1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.324459811 UTC

[section ""data" . Data.Functor.Contravariant.getEquivalence1_closure" {
     Data.Functor.Contravariant.getEquivalence1_closure:
         const Data.Functor.Contravariant.getEquivalence1_info;
 },
 Data.Functor.Contravariant.getEquivalence1_entry() //  [R2]
         { info_tbl: [(cgjWF,
                       label: Data.Functor.Contravariant.getEquivalence1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjWF: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.325235623 UTC

[section ""data" . Data.Functor.Contravariant.getEquivalence_closure" {
     Data.Functor.Contravariant.getEquivalence_closure:
         const Data.Functor.Contravariant.getEquivalence_info;
 },
 Data.Functor.Contravariant.getEquivalence_entry() //  [R2]
         { info_tbl: [(cgjWM,
                       label: Data.Functor.Contravariant.getEquivalence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjWM: // global
           R2 = R2;
           call Data.Functor.Contravariant.getEquivalence1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.326071133 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantComparison1_closure" {
     Data.Functor.Contravariant.$fContravariantComparison1_closure:
         const Data.Functor.Contravariant.$fContravariantComparison1_info;
 },
 Data.Functor.Contravariant.$fContravariantComparison1_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cgjWT,
                       label: Data.Functor.Contravariant.$fContravariantComparison1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjWT: // global
           _sgjMe::P64 = R3;
           R3 = R2;
           R2 = R2;
           R1 = _sgjMe::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.327005625 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantComparison2_closure" {
     Data.Functor.Contravariant.$fContravariantComparison2_closure:
         const Data.Functor.Contravariant.$fContravariantComparison2_info;
 },
 Data.Functor.Contravariant.$fContravariantComparison2_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cgjX2,
                       label: Data.Functor.Contravariant.$fContravariantComparison2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjX2: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgjX6; else goto cgjX5;
       cgjX6: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantComparison2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgjX5: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _sgjMi::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 24;
           R1 = _sgjMi::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.327853715 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantComparison_closure" {
     Data.Functor.Contravariant.$fContravariantComparison_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantComparison2_closure+4;
         const Data.Functor.Contravariant.$fContravariantComparison1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.328485326 UTC

[section ""data" . Data.Functor.Contravariant.getComparison1_closure" {
     Data.Functor.Contravariant.getComparison1_closure:
         const Data.Functor.Contravariant.getComparison1_info;
 },
 Data.Functor.Contravariant.getComparison1_entry() //  [R2]
         { info_tbl: [(cgjXb,
                       label: Data.Functor.Contravariant.getComparison1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjXb: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.329311897 UTC

[section ""data" . Data.Functor.Contravariant.getComparison_closure" {
     Data.Functor.Contravariant.getComparison_closure:
         const Data.Functor.Contravariant.getComparison_info;
 },
 Data.Functor.Contravariant.getComparison_entry() //  [R2]
         { info_tbl: [(cgjXi,
                       label: Data.Functor.Contravariant.getComparison_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjXi: // global
           R2 = R2;
           call Data.Functor.Contravariant.getComparison1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.330117654 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantPredicate1_closure" {
     Data.Functor.Contravariant.$fContravariantPredicate1_closure:
         const Data.Functor.Contravariant.$fContravariantPredicate1_info;
 },
 Data.Functor.Contravariant.$fContravariantPredicate1_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cgjXp,
                       label: Data.Functor.Contravariant.$fContravariantPredicate1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjXp: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.330928165 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantPredicate2_closure" {
     Data.Functor.Contravariant.$fContravariantPredicate2_closure:
         const Data.Functor.Contravariant.$fContravariantPredicate2_info;
 },
 Data.Functor.Contravariant.$fContravariantPredicate2_entry() //  [R2,
                                                                   R3, R4]
         { info_tbl: [(cgjXw,
                       label: Data.Functor.Contravariant.$fContravariantPredicate2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjXw: // global
           R4 = R4;
           _sgjMs::P64 = R3;
           R3 = R2;
           R2 = _sgjMs::P64;
           call GHC.Base.._entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.332842849 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantPredicate_closure" {
     Data.Functor.Contravariant.$fContravariantPredicate_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantPredicate2_closure+3;
         const Data.Functor.Contravariant.$fContravariantPredicate1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.333606723 UTC

[section ""data" . Data.Functor.Contravariant.getPredicate1_closure" {
     Data.Functor.Contravariant.getPredicate1_closure:
         const Data.Functor.Contravariant.getPredicate1_info;
 },
 Data.Functor.Contravariant.getPredicate1_entry() //  [R2]
         { info_tbl: [(cgjXD,
                       label: Data.Functor.Contravariant.getPredicate1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjXD: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.334357096 UTC

[section ""data" . Data.Functor.Contravariant.getPredicate_closure" {
     Data.Functor.Contravariant.getPredicate_closure:
         const Data.Functor.Contravariant.getPredicate_info;
 },
 Data.Functor.Contravariant.getPredicate_entry() //  [R2]
         { info_tbl: [(cgjXK,
                       label: Data.Functor.Contravariant.getPredicate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjXK: // global
           R2 = R2;
           call Data.Functor.Contravariant.getPredicate1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.335144097 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantV1_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantV1_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantV1_$c>$_info;
 },
 Data.Functor.Contravariant.$fContravariantV1_$c>$_entry() //  [R3]
         { info_tbl: [(cgjXR,
                       label: Data.Functor.Contravariant.$fContravariantV1_$c>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjXR: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.335978016 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantU1_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantU1_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantU1_$c>$_info;
 },
 Data.Functor.Contravariant.$fContravariantU1_$c>$_entry() //  []
         { info_tbl: [(cgjXY,
                       label: Data.Functor.Contravariant.$fContravariantU1_$c>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjXY: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.336727452 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantK2_closure" {
     Data.Functor.Contravariant.$fContravariantK2_closure:
         const Data.Functor.Contravariant.$fContravariantK2_info;
 },
 Data.Functor.Contravariant.$fContravariantK2_entry() //  [R3]
         { info_tbl: [(cgjY5,
                       label: Data.Functor.Contravariant.$fContravariantK2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjY5: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.33864963 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:*:_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariant:*:_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariant:*:_$c>$_info;
 },
 f1_sgjMI_entry() //  [R1]
         { info_tbl: [(cgjYm,
                       label: f1_sgjMI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjYm: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjML_entry() //  [R1]
         { info_tbl: [(cgjYt,
                       label: sat_sgjML_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjYt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgjYu; else goto cgjYv;
       cgjYu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgjYv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjMK_entry() //  [R1]
         { info_tbl: [(cgjYA,
                       label: sat_sgjMK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjYA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgjYB; else goto cgjYC;
       cgjYB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgjYC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:*:_$c>$_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgjYD,
                       label: Data.Functor.Contravariant.$fContravariant:*:_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjYD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgjYF; else goto cgjYG;
       cgjYF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:*:_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgjYG: // global
           I64[Sp - 32] = block_cgjYc_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugjYK; else goto cgjYd;
       ugjYK: // global
           call _cgjYc(R1) args: 0, res: 0, upd: 0;
       cgjYd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgjYc() //  [R1]
         { info_tbl: [(cgjYc,
                       label: block_cgjYc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjYc: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cgjYJ; else goto cgjYI;
       cgjYJ: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgjYI: // global
           _sgjMG::P64 = P64[R1 + 7];
           _sgjMH::P64 = P64[R1 + 15];
           I64[Hp - 112] = f1_sgjMI_info;
           P64[Hp - 104] = P64[Sp + 24];
           I64[Hp - 96] = sat_sgjML_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sgjMH::P64;
           _cgjYh::P64 = Hp - 111;
           P64[Hp - 64] = _cgjYh::P64;
           I64[Hp - 56] = sat_sgjMK_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgjMG::P64;
           P64[Hp - 24] = _cgjYh::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.340964065 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:.:1_closure" {
     Data.Functor.Contravariant.$fContravariant:.:1_closure:
         const Data.Functor.Contravariant.$fContravariant:.:1_info;
 },
 sat_sgjMR_entry() //  [R1]
         { info_tbl: [(cgjYY,
                       label: sat_sgjMR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjYY: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjMS_entry() //  [R1]
         { info_tbl: [(cgjZ1,
                       label: sat_sgjMS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjZ1: // global
           _sgjMS::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgjZ2; else goto cgjZ3;
       cgjZ3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgjZ5; else goto cgjZ4;
       cgjZ5: // global
           HpAlloc = 16;
           goto cgjZ2;
       cgjZ2: // global
           R1 = _sgjMS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgjZ4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjMS::P64;
           _sgjMN::P64 = P64[_sgjMS::P64 + 16];
           _sgjMO::P64 = P64[_sgjMS::P64 + 24];
           I64[Hp - 8] = sat_sgjMR_info;
           P64[Hp] = _sgjMO::P64;
           R2 = _sgjMN::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:.:1_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cgjZ6,
                       label: Data.Functor.Contravariant.$fContravariant:.:1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjZ6: // global
           _sgjMP::P64 = R5;
           _sgjMO::P64 = R4;
           _sgjMN::P64 = R3;
           _sgjMM::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgjZ7; else goto cgjZ8;
       cgjZ8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgjZa; else goto cgjZ9;
       cgjZa: // global
           HpAlloc = 32;
           goto cgjZ7;
       cgjZ7: // global
           R5 = _sgjMP::P64;
           R4 = _sgjMO::P64;
           R3 = _sgjMN::P64;
           R2 = _sgjMM::P64;
           R1 = Data.Functor.Contravariant.$fContravariant:.:1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgjZ9: // global
           I64[Hp - 24] = sat_sgjMS_info;
           P64[Hp - 8] = _sgjMN::P64;
           P64[Hp] = _sgjMO::P64;
           R2 = _sgjMM::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgjMP::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.34317751 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProduct_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantProduct_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantProduct_$c>$_info;
 },
 f1_sgjN0_entry() //  [R1]
         { info_tbl: [(cgjZp,
                       label: f1_sgjN0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjZp: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjN3_entry() //  [R1]
         { info_tbl: [(cgjZw,
                       label: sat_sgjN3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjZw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgjZx; else goto cgjZy;
       cgjZx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgjZy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjN2_entry() //  [R1]
         { info_tbl: [(cgjZD,
                       label: sat_sgjN2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjZD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgjZE; else goto cgjZF;
       cgjZE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgjZF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantProduct_$c>$_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cgjZG,
                       label: Data.Functor.Contravariant.$fContravariantProduct_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjZG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgjZI; else goto cgjZJ;
       cgjZI: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantProduct_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgjZJ: // global
           I64[Sp - 32] = block_cgjZf_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugjZN; else goto cgjZg;
       ugjZN: // global
           call _cgjZf(R1) args: 0, res: 0, upd: 0;
       cgjZg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgjZf() //  [R1]
         { info_tbl: [(cgjZf,
                       label: block_cgjZf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjZf: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cgjZM; else goto cgjZL;
       cgjZM: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgjZL: // global
           _sgjMY::P64 = P64[R1 + 7];
           _sgjMZ::P64 = P64[R1 + 15];
           I64[Hp - 112] = f1_sgjN0_info;
           P64[Hp - 104] = P64[Sp + 24];
           I64[Hp - 96] = sat_sgjN3_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sgjMZ::P64;
           _cgjZk::P64 = Hp - 111;
           P64[Hp - 64] = _cgjZk::P64;
           I64[Hp - 56] = sat_sgjN2_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgjMY::P64;
           P64[Hp - 24] = _cgjZk::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.345198447 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantConst1_closure" {
     Data.Functor.Contravariant.$fContravariantConst1_closure:
         const Data.Functor.Contravariant.$fContravariantConst1_info;
 },
 Data.Functor.Contravariant.$fContravariantConst1_entry() //  [R3]
         { info_tbl: [(cgjZS,
                       label: Data.Functor.Contravariant.$fContravariantConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjZS: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.346359759 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantCompose1_closure" {
     Data.Functor.Contravariant.$fContravariantCompose1_closure:
         const Data.Functor.Contravariant.$fContravariantCompose1_info;
 },
 sat_sgjNb_entry() //  [R1]
         { info_tbl: [(cgk08,
                       label: sat_sgjNb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk08: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNc_entry() //  [R1]
         { info_tbl: [(cgk0b,
                       label: sat_sgjNc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk0b: // global
           _sgjNc::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgk0c; else goto cgk0d;
       cgk0d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgk0f; else goto cgk0e;
       cgk0f: // global
           HpAlloc = 16;
           goto cgk0c;
       cgk0c: // global
           R1 = _sgjNc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk0e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjNc::P64;
           _sgjN7::P64 = P64[_sgjNc::P64 + 16];
           _sgjN8::P64 = P64[_sgjNc::P64 + 24];
           I64[Hp - 8] = sat_sgjNb_info;
           P64[Hp] = _sgjN8::P64;
           R2 = _sgjN7::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantCompose1_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgk0g,
                       label: Data.Functor.Contravariant.$fContravariantCompose1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk0g: // global
           _sgjN9::P64 = R5;
           _sgjN8::P64 = R4;
           _sgjN7::P64 = R3;
           _sgjN6::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgk0h; else goto cgk0i;
       cgk0i: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgk0k; else goto cgk0j;
       cgk0k: // global
           HpAlloc = 32;
           goto cgk0h;
       cgk0h: // global
           R5 = _sgjN9::P64;
           R4 = _sgjN8::P64;
           R3 = _sgjN7::P64;
           R2 = _sgjN6::P64;
           R1 = Data.Functor.Contravariant.$fContravariantCompose1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk0j: // global
           I64[Hp - 24] = sat_sgjNc_info;
           P64[Hp - 8] = _sgjN7::P64;
           P64[Hp] = _sgjN8::P64;
           R2 = _sgjN6::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgjN9::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.347894666 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProxy_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantProxy_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantProxy_$c>$_info;
 },
 Data.Functor.Contravariant.$fContravariantProxy_$c>$_entry() //  []
         { info_tbl: [(cgk0p,
                       label: Data.Functor.Contravariant.$fContravariantProxy_$c>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk0p: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.348857837 UTC

[section ""data" . Data.Functor.Contravariant.$dm>$_closure" {
     Data.Functor.Contravariant.$dm>$_closure:
         const Data.Functor.Contravariant.$dm>$_info;
 },
 sat_sgjNi_entry() //  [R1]
         { info_tbl: [(cgk0B,
                       label: sat_sgjNi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk0B: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$dm>$_entry() //  [R2, R3]
         { info_tbl: [(cgk0E,
                       label: Data.Functor.Contravariant.$dm>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk0E: // global
           _sgjNg::P64 = R3;
           _sgjNf::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgk0F; else goto cgk0G;
       cgk0G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgk0I; else goto cgk0H;
       cgk0I: // global
           HpAlloc = 16;
           goto cgk0F;
       cgk0F: // global
           R3 = _sgjNg::P64;
           R2 = _sgjNf::P64;
           R1 = Data.Functor.Contravariant.$dm>$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk0H: // global
           I64[Hp - 8] = sat_sgjNi_info;
           P64[Hp] = _sgjNg::P64;
           R2 = _sgjNf::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.350424731 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupOp_closure" {
     Data.Functor.Contravariant.$fSemigroupOp_closure:
         const Data.Functor.Contravariant.$fSemigroupOp_info;
 },
 sat_sgjNm_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgk0S,
                       label: sat_sgjNm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk0S: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call GHC.Base.$fSemigroup(->)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNl_entry() //  [R1, R2]
         { info_tbl: [(cgk10,
                       label: sat_sgjNl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk10: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(->)_$csconcat_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgk18,
                       label: sat_sgjNk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk18: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(->)_$c<>_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupOp_entry() //  [R2]
         { info_tbl: [(cgk1c,
                       label: Data.Functor.Contravariant.$fSemigroupOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk1c: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgk1g; else goto cgk1f;
       cgk1g: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk1f: // global
           I64[Hp - 72] = sat_sgjNm_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgjNl_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgjNk_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 68;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.352072909 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_closure" {
     Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_closure:
         const Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_info;
 },
 sat_sgjNo_entry() //  [R1]
         { info_tbl: [(cgk1p,
                       label: sat_sgjNo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk1p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk1q; else goto cgk1r;
       cgk1q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk1r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cgk1s,
                       label: Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk1s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgk1w; else goto cgk1v;
       cgk1w: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk1v: // global
           I64[Hp - 16] = sat_sgjNo_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Contravariant.$fSemigroupOp_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.353858766 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidOp_closure" {
     Data.Functor.Contravariant.$fMonoidOp_closure:
         const Data.Functor.Contravariant.$fMonoidOp_info;
 },
 lvl7_sgjNq_entry() //  [R1]
         { info_tbl: [(cgk1F,
                       label: lvl7_sgjNq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk1F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk1G; else goto cgk1H;
       cgk1G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk1H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjNv_entry() //  [R1, R2, R3]
         { info_tbl: [(cgk1N,
                       label: sat_sgjNv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk1N: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNu_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgk1V,
                       label: sat_sgjNu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk1V: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoid(->)_$cmappend_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNt_entry() //  [R1]
         { info_tbl: [(cgk23,
                       label: sat_sgjNt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk23: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNr_entry() //  [R1]
         { info_tbl: [(cgk2a,
                       label: sat_sgjNr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk2a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk2b; else goto cgk2c;
       cgk2b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk2c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fMonoidOp_entry() //  [R2]
         { info_tbl: [(cgk2e,
                       label: Data.Functor.Contravariant.$fMonoidOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk2e: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cgk2i; else goto cgk2h;
       cgk2i: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk2h: // global
           I64[Hp - 128] = lvl7_sgjNq_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgjNv_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgjNu_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgjNt_info;
           P64[Hp - 64] = Hp - 128;
           I64[Hp - 56] = sat_sgjNr_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.355732158 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison3_closure" {
     Data.Functor.Contravariant.$fMonoidComparison3_closure:
         const Data.Functor.Contravariant.$fMonoidComparison3_info;
 },
 Data.Functor.Contravariant.$fMonoidComparison3_entry() //  []
         { info_tbl: [(cgk2n,
                       label: Data.Functor.Contravariant.$fMonoidComparison3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk2n: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.356985634 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison2_closure" {
     Data.Functor.Contravariant.$fMonoidComparison2_closure:
         const Data.Functor.Contravariant.$fMonoidComparison2_info;
 },
 sat_sgjNF_entry() //  [R1, R2]
         { info_tbl: [(cgk2I,
                       label: sat_sgjNF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk2I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgk2J; else goto cgk2K;
       cgk2J: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk2K: // global
           I64[Sp - 24] = block_cgk2B_info;
           _sgjND::P64 = R2;
           R2 = R2;
           _sgjNC::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sgjNC::P64;
           P64[Sp - 8] = _sgjND::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgk2B() //  [R1]
         { info_tbl: [(cgk2B,
                       label: block_cgk2B_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk2B: // global
           _cgk2H::P64 = R1 & 7;
           if (_cgk2H::P64 < 3) goto ugk2U; else goto cgk2G;
       ugk2U: // global
           if (_cgk2H::P64 < 2) goto cgk2E; else goto cgk2F;
       cgk2E: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgk2F: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cgk2G: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fMonoidComparison2_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cgk2V,
                       label: Data.Functor.Contravariant.$fMonoidComparison2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk2V: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgk2Z; else goto cgk2Y;
       cgk2Z: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidComparison2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk2Y: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgjNF_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.359382069 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison3_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison3_closure:
         const Data.Functor.Contravariant.$fSemigroupComparison3_info;
 },
 sat_sgjNN_entry() //  [R1, R2]
         { info_tbl: [(cgk3i,
                       label: sat_sgjNN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk3i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgk3j; else goto cgk3k;
       cgk3j: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk3k: // global
           I64[Sp - 24] = block_cgk3b_info;
           _sgjNL::P64 = R2;
           R2 = R2;
           _sgjNK::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sgjNK::P64;
           P64[Sp - 8] = _sgjNL::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgk3b() //  [R1]
         { info_tbl: [(cgk3b,
                       label: block_cgk3b_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk3b: // global
           _cgk3h::P64 = R1 & 7;
           if (_cgk3h::P64 < 3) goto ugk3u; else goto cgk3g;
       ugk3u: // global
           if (_cgk3h::P64 < 2) goto cgk3e; else goto cgk3f;
       cgk3e: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgk3f: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cgk3g: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupComparison3_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cgk3v,
                       label: Data.Functor.Contravariant.$fSemigroupComparison3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk3v: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgk3z; else goto cgk3y;
       cgk3z: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupComparison3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk3y: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgjNN_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.361382596 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison1_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison1_closure:
         const Data.Functor.Contravariant.$fSemigroupComparison1_info;
         const 0;
 },
 lvl7_sgjNT_entry() //  [R1]
         { info_tbl: [(cgk3J,
                       label: lvl7_sgjNT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk3J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk3K; else goto cgk3L;
       cgk3K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk3L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupOrdering_$cstimes_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjNW_entry() //  [R1, R2]
         { info_tbl: [(cgk3S,
                       label: sat_sgjNW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk3S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgk3W; else goto cgk3V;
       cgk3W: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk3V: // global
           _sgjNP::P64 = P64[R1 + 7];
           _sgjNS::P64 = P64[R1 + 15];
           _sgjNT::P64 = P64[R1 + 23];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjNS::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = _sgjNP::P64;
           R1 = _sgjNT::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupComparison1_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cgk3X,
                       label: Data.Functor.Contravariant.$fSemigroupComparison1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk3X: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgk41; else goto cgk40;
       cgk41: // global
           HpAlloc = 88;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupComparison1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk40: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = lvl7_sgjNT_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = sat_sgjNW_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.363238744 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantM1_closure" {
     Data.Functor.Contravariant.$fContravariantM1_closure:
         const Data.Functor.Contravariant.$fContravariantM1_info;
 },
 sat_sgjNZ_entry() //  [R1]
         { info_tbl: [(cgk4b,
                       label: sat_sgjNZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk4b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk4c; else goto cgk4d;
       cgk4c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk4d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.>$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjNY_entry() //  [R1]
         { info_tbl: [(cgk4i,
                       label: sat_sgjNY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk4i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk4j; else goto cgk4k;
       cgk4j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk4k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantM1_entry() //  [R2]
         { info_tbl: [(cgk4m,
                       label: Data.Functor.Contravariant.$fContravariantM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk4m: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgk4q; else goto cgk4p;
       cgk4q: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk4p: // global
           I64[Hp - 64] = sat_sgjNZ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgjNY_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.364850846 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantRec1_closure" {
     Data.Functor.Contravariant.$fContravariantRec1_closure:
         const Data.Functor.Contravariant.$fContravariantRec1_info;
 },
 sat_sgjO2_entry() //  [R1]
         { info_tbl: [(cgk4z,
                       label: sat_sgjO2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk4z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk4A; else goto cgk4B;
       cgk4A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk4B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.>$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjO1_entry() //  [R1]
         { info_tbl: [(cgk4G,
                       label: sat_sgjO1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk4G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk4H; else goto cgk4I;
       cgk4H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk4I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantRec1_entry() //  [R2]
         { info_tbl: [(cgk4K,
                       label: Data.Functor.Contravariant.$fContravariantRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk4K: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgk4O; else goto cgk4N;
       cgk4O: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk4N: // global
           I64[Hp - 64] = sat_sgjO2_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgjO1_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.366513158 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantAlt_closure" {
     Data.Functor.Contravariant.$fContravariantAlt_closure:
         const Data.Functor.Contravariant.$fContravariantAlt_info;
 },
 sat_sgjO5_entry() //  [R1]
         { info_tbl: [(cgk4X,
                       label: sat_sgjO5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk4X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk4Y; else goto cgk4Z;
       cgk4Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk4Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.>$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjO4_entry() //  [R1]
         { info_tbl: [(cgk54,
                       label: sat_sgjO4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk54: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk55; else goto cgk56;
       cgk55: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk56: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantAlt_entry() //  [R2]
         { info_tbl: [(cgk58,
                       label: Data.Functor.Contravariant.$fContravariantAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk58: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgk5c; else goto cgk5b;
       cgk5c: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk5b: // global
           I64[Hp - 64] = sat_sgjO5_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgjO4_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.367802045 UTC

[section ""data" . sat_sgjO6_closure" {
     sat_sgjO6_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.368378036 UTC

[section ""data" . sat_sgjO7_closure" {
     sat_sgjO7_closure:
         const :_con_info;
         const sat_sgjO6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.369138717 UTC

[section ""data" . lvl_rgjLr_closure" {
     lvl_rgjLr_closure:
         const lvl_rgjLr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rgjLr_entry() //  [R1]
         { info_tbl: [(cgk5j,
                       label: lvl_rgjLr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk5j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk5k; else goto cgk5l;
       cgk5k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk5l: // global
           (_cgk5g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgk5g::I64 == 0) goto cgk5i; else goto cgk5h;
       cgk5i: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgk5h: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgk5g::I64;
           R3 = sat_sgjO7_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.370498181 UTC

[section ""data" . lvl1_rgjLs_closure" {
     lvl1_rgjLs_closure:
         const lvl1_rgjLs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rgjLs_entry() //  [R1]
         { info_tbl: [(cgk5s,
                       label: lvl1_rgjLs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk5s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk5t; else goto cgk5u;
       cgk5t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk5u: // global
           (_cgk5p::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgk5p::I64 == 0) goto cgk5r; else goto cgk5q;
       cgk5r: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgk5q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgk5p::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.372669587 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_info;
         const 0;
 },
 $dFractional_sgjOa_entry() //  [R1]
         { info_tbl: [(cgk5D,
                       label: $dFractional_sgjOa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk5D: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgjOb_entry() //  [R1]
         { info_tbl: [(cgk5K,
                       label: $dNum_sgjOb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk5K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk5L; else goto cgk5M;
       cgk5L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk5M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgjOc_entry() //  [R1]
         { info_tbl: [(cgk5R,
                       label: x_sgjOc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk5R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgk5S; else goto cgk5T;
       cgk5S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk5T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl1_rgjLs_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 x1_sgjOd_entry() //  [R1]
         { info_tbl: [(cgk5Y,
                       label: x1_sgjOd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk5Y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgk5Z; else goto cgk60;
       cgk5Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk60: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOg_entry() //  [R1]
         { info_tbl: [(cgk6j,
                       label: sat_sgjOg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk6j: // global
           _sgjOg::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgk6k; else goto cgk6l;
       cgk6l: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgk6n; else goto cgk6m;
       cgk6n: // global
           HpAlloc = 32;
           goto cgk6k;
       cgk6k: // global
           R1 = _sgjOg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk6m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOg::P64;
           _sgjO8::P64 = P64[_sgjOg::P64 + 16];
           _sgjO9::P64 = P64[_sgjOg::P64 + 24];
           _sgjOe::P64 = P64[_sgjOg::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjO9::P64;
           P64[Hp] = _sgjOe::P64;
           R2 = _sgjO8::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Float.exp_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOh_entry() //  [R1]
         { info_tbl: [(cgk6o,
                       label: sat_sgjOh_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk6o: // global
           _sgjOh::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgk6p; else goto cgk6q;
       cgk6q: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgk6s; else goto cgk6r;
       cgk6s: // global
           HpAlloc = 40;
           goto cgk6p;
       cgk6p: // global
           R1 = _sgjOh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk6r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOh::P64;
           _sgjO8::P64 = P64[_sgjOh::P64 + 16];
           _sgjO9::P64 = P64[_sgjOh::P64 + 24];
           _sgjOb::P64 = P64[_sgjOh::P64 + 32];
           _sgjOc::P64 = P64[_sgjOh::P64 + 40];
           _sgjOe::P64 = P64[_sgjOh::P64 + 48];
           I64[Hp - 32] = sat_sgjOg_info;
           P64[Hp - 16] = _sgjO8::P64;
           P64[Hp - 8] = _sgjO9::P64;
           P64[Hp] = _sgjOe::P64;
           R2 = _sgjOb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgjOc::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjOi_entry() //  [R1]
         { info_tbl: [(cgk6t,
                       label: sat_sgjOi_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk6t: // global
           _sgjOi::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgk6u; else goto cgk6v;
       cgk6v: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgk6x; else goto cgk6w;
       cgk6x: // global
           HpAlloc = 56;
           goto cgk6u;
       cgk6u: // global
           R1 = _sgjOi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk6w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOi::P64;
           _sgjO8::P64 = P64[_sgjOi::P64 + 16];
           _sgjO9::P64 = P64[_sgjOi::P64 + 24];
           _sgjOb::P64 = P64[_sgjOi::P64 + 32];
           _sgjOc::P64 = P64[_sgjOi::P64 + 40];
           _sgjOd::P64 = P64[_sgjOi::P64 + 48];
           _sgjOe::P64 = P64[_sgjOi::P64 + 56];
           I64[Hp - 48] = sat_sgjOh_info;
           P64[Hp - 32] = _sgjO8::P64;
           P64[Hp - 24] = _sgjO9::P64;
           P64[Hp - 16] = _sgjOb::P64;
           P64[Hp - 8] = _sgjOc::P64;
           P64[Hp] = _sgjOe::P64;
           R2 = _sgjOb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgjOd::P64;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjOj_entry() //  [R1, R2]
         { info_tbl: [(cgk6y,
                       label: sat_sgjOj_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk6y: // global
           _sgjOe::P64 = R2;
           _sgjOj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgk6z; else goto cgk6A;
       cgk6A: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgk6C; else goto cgk6B;
       cgk6C: // global
           HpAlloc = 64;
           goto cgk6z;
       cgk6z: // global
           R2 = _sgjOe::P64;
           R1 = _sgjOj::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk6B: // global
           _sgjO8::P64 = P64[_sgjOj::P64 + 7];
           _sgjO9::P64 = P64[_sgjOj::P64 + 15];
           _sgjOb::P64 = P64[_sgjOj::P64 + 23];
           _sgjOc::P64 = P64[_sgjOj::P64 + 31];
           _sgjOd::P64 = P64[_sgjOj::P64 + 39];
           I64[Hp - 56] = sat_sgjOi_info;
           P64[Hp - 40] = _sgjO8::P64;
           P64[Hp - 32] = _sgjO9::P64;
           P64[Hp - 24] = _sgjOb::P64;
           P64[Hp - 16] = _sgjOc::P64;
           P64[Hp - 8] = _sgjOd::P64;
           P64[Hp] = _sgjOe::P64;
           R2 = _sgjO8::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cgk6D,
                       label: Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk6D: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgk6H; else goto cgk6G;
       cgk6H: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk6G: // global
           I64[Hp - 136] = $dFractional_sgjOa_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = $dNum_sgjOb_info;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = x_sgjOc_info;
           _cgk5G::P64 = Hp - 112;
           P64[Hp - 72] = _cgk5G::P64;
           I64[Hp - 64] = x1_sgjOd_info;
           P64[Hp - 48] = _cgk5G::P64;
           I64[Hp - 40] = sat_sgjOj_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = _cgk5G::P64;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = Hp - 64;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.376994258 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$cexpm1_info;
         const 0;
 },
 $dFractional_sgjOm_entry() //  [R1]
         { info_tbl: [(cgk6Q,
                       label: $dFractional_sgjOm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk6Q: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgjOn_entry() //  [R1]
         { info_tbl: [(cgk6X,
                       label: $dNum_sgjOn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk6X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk6Y; else goto cgk6Z;
       cgk6Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk6Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgjOo_entry() //  [R1]
         { info_tbl: [(cgk74,
                       label: x_sgjOo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk74: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgk75; else goto cgk76;
       cgk75: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk76: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOr_entry() //  [R1]
         { info_tbl: [(cgk7h,
                       label: sat_sgjOr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk7h: // global
           _sgjOr::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgk7i; else goto cgk7j;
       cgk7j: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgk7l; else goto cgk7k;
       cgk7l: // global
           HpAlloc = 32;
           goto cgk7i;
       cgk7i: // global
           R1 = _sgjOr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk7k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOr::P64;
           _sgjOk::P64 = P64[_sgjOr::P64 + 16];
           _sgjOl::P64 = P64[_sgjOr::P64 + 24];
           _sgjOp::P64 = P64[_sgjOr::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOl::P64;
           P64[Hp] = _sgjOp::P64;
           R2 = _sgjOk::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Float.exp_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOs_entry() //  [R1, R2]
         { info_tbl: [(cgk7m,
                       label: sat_sgjOs_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk7m: // global
           _sgjOp::P64 = R2;
           _sgjOs::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgk7n; else goto cgk7o;
       cgk7o: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgk7q; else goto cgk7p;
       cgk7q: // global
           HpAlloc = 40;
           goto cgk7n;
       cgk7n: // global
           R2 = _sgjOp::P64;
           R1 = _sgjOs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk7p: // global
           _sgjOk::P64 = P64[_sgjOs::P64 + 7];
           _sgjOl::P64 = P64[_sgjOs::P64 + 15];
           _sgjOn::P64 = P64[_sgjOs::P64 + 23];
           _sgjOo::P64 = P64[_sgjOs::P64 + 31];
           I64[Hp - 32] = sat_sgjOr_info;
           P64[Hp - 16] = _sgjOk::P64;
           P64[Hp - 8] = _sgjOl::P64;
           P64[Hp] = _sgjOp::P64;
           R2 = _sgjOn::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sgjOo::P64;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$cexpm1_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cgk7r,
                       label: Data.Functor.Contravariant.$fFloatingOp_$cexpm1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk7r: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgk7v; else goto cgk7u;
       cgk7v: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk7u: // global
           I64[Hp - 104] = $dFractional_sgjOm_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_sgjOn_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = x_sgjOo_info;
           _cgk6T::P64 = Hp - 80;
           P64[Hp - 40] = _cgk6T::P64;
           I64[Hp - 32] = sat_sgjOs_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cgk6T::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.380361452 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_info;
         const 0;
 },
 $dFractional_sgjOv_entry() //  [R1]
         { info_tbl: [(cgk7E,
                       label: $dFractional_sgjOv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk7E: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgjOw_entry() //  [R1]
         { info_tbl: [(cgk7L,
                       label: $dNum_sgjOw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk7L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk7M; else goto cgk7N;
       cgk7M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk7N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgjOx_entry() //  [R1]
         { info_tbl: [(cgk7S,
                       label: x_sgjOx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk7S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgk7T; else goto cgk7U;
       cgk7T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk7U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOA_entry() //  [R1]
         { info_tbl: [(cgk89,
                       label: sat_sgjOA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk89: // global
           _sgjOA::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgk8a; else goto cgk8b;
       cgk8b: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgk8d; else goto cgk8c;
       cgk8d: // global
           HpAlloc = 32;
           goto cgk8a;
       cgk8a: // global
           R1 = _sgjOA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk8c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOA::P64;
           _sgjOt::P64 = P64[_sgjOA::P64 + 16];
           _sgjOu::P64 = P64[_sgjOA::P64 + 24];
           _sgjOy::P64 = P64[_sgjOA::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOu::P64;
           P64[Hp] = _sgjOy::P64;
           R2 = _sgjOt::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Float.exp_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOB_entry() //  [R1]
         { info_tbl: [(cgk8e,
                       label: sat_sgjOB_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk8e: // global
           _sgjOB::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgk8f; else goto cgk8g;
       cgk8g: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgk8i; else goto cgk8h;
       cgk8i: // global
           HpAlloc = 40;
           goto cgk8f;
       cgk8f: // global
           R1 = _sgjOB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk8h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOB::P64;
           _sgjOt::P64 = P64[_sgjOB::P64 + 16];
           _sgjOu::P64 = P64[_sgjOB::P64 + 24];
           _sgjOw::P64 = P64[_sgjOB::P64 + 32];
           _sgjOx::P64 = P64[_sgjOB::P64 + 40];
           _sgjOy::P64 = P64[_sgjOB::P64 + 48];
           I64[Hp - 32] = sat_sgjOA_info;
           P64[Hp - 16] = _sgjOt::P64;
           P64[Hp - 8] = _sgjOu::P64;
           P64[Hp] = _sgjOy::P64;
           R2 = _sgjOw::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgjOx::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjOC_entry() //  [R1, R2]
         { info_tbl: [(cgk8j,
                       label: sat_sgjOC_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk8j: // global
           _sgjOy::P64 = R2;
           _sgjOC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgk8k; else goto cgk8l;
       cgk8l: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgk8n; else goto cgk8m;
       cgk8n: // global
           HpAlloc = 56;
           goto cgk8k;
       cgk8k: // global
           R2 = _sgjOy::P64;
           R1 = _sgjOC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk8m: // global
           _sgjOt::P64 = P64[_sgjOC::P64 + 7];
           _sgjOu::P64 = P64[_sgjOC::P64 + 15];
           _sgjOw::P64 = P64[_sgjOC::P64 + 23];
           _sgjOx::P64 = P64[_sgjOC::P64 + 31];
           I64[Hp - 48] = sat_sgjOB_info;
           P64[Hp - 32] = _sgjOt::P64;
           P64[Hp - 24] = _sgjOu::P64;
           P64[Hp - 16] = _sgjOw::P64;
           P64[Hp - 8] = _sgjOx::P64;
           P64[Hp] = _sgjOy::P64;
           R2 = _sgjOt::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cgk8o,
                       label: Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk8o: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgk8s; else goto cgk8r;
       cgk8s: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk8r: // global
           I64[Hp - 104] = $dFractional_sgjOv_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_sgjOw_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = x_sgjOx_info;
           _cgk7H::P64 = Hp - 80;
           P64[Hp - 40] = _cgk7H::P64;
           I64[Hp - 32] = sat_sgjOC_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cgk7H::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.383969084 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$clog1p_info;
         const 0;
 },
 $dFractional_sgjOF_entry() //  [R1]
         { info_tbl: [(cgk8B,
                       label: $dFractional_sgjOF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk8B: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgjOG_entry() //  [R1]
         { info_tbl: [(cgk8I,
                       label: $dNum_sgjOG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk8I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgk8J; else goto cgk8K;
       cgk8J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk8K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgjOH_entry() //  [R1]
         { info_tbl: [(cgk8P,
                       label: x_sgjOH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk8P: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgk8Q; else goto cgk8R;
       cgk8Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk8R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOK_entry() //  [R1]
         { info_tbl: [(cgk92,
                       label: sat_sgjOK_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk92: // global
           _sgjOK::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgk93; else goto cgk94;
       cgk94: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgk96; else goto cgk95;
       cgk96: // global
           HpAlloc = 32;
           goto cgk93;
       cgk93: // global
           R1 = _sgjOK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgk95: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOK::P64;
           _sgjOE::P64 = P64[_sgjOK::P64 + 16];
           _sgjOG::P64 = P64[_sgjOK::P64 + 24];
           _sgjOH::P64 = P64[_sgjOK::P64 + 32];
           _sgjOI::P64 = P64[_sgjOK::P64 + 40];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOE::P64;
           P64[Hp] = _sgjOI::P64;
           R2 = _sgjOG::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgjOH::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjOL_entry() //  [R1, R2]
         { info_tbl: [(cgk97,
                       label: sat_sgjOL_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk97: // global
           _sgjOI::P64 = R2;
           _sgjOL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgk98; else goto cgk99;
       cgk99: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgk9b; else goto cgk9a;
       cgk9b: // global
           HpAlloc = 48;
           goto cgk98;
       cgk98: // global
           R2 = _sgjOI::P64;
           R1 = _sgjOL::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgk9a: // global
           _sgjOD::P64 = P64[_sgjOL::P64 + 7];
           _sgjOE::P64 = P64[_sgjOL::P64 + 15];
           _sgjOG::P64 = P64[_sgjOL::P64 + 23];
           _sgjOH::P64 = P64[_sgjOL::P64 + 31];
           I64[Hp - 40] = sat_sgjOK_info;
           P64[Hp - 24] = _sgjOE::P64;
           P64[Hp - 16] = _sgjOG::P64;
           P64[Hp - 8] = _sgjOH::P64;
           P64[Hp] = _sgjOI::P64;
           R2 = _sgjOD::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$clog1p_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cgk9c,
                       label: Data.Functor.Contravariant.$fFloatingOp_$clog1p_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk9c: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgk9g; else goto cgk9f;
       cgk9g: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk9f: // global
           I64[Hp - 104] = $dFractional_sgjOF_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_sgjOG_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = x_sgjOH_info;
           _cgk8E::P64 = Hp - 80;
           P64[Hp - 40] = _cgk8E::P64;
           I64[Hp - 32] = sat_sgjOL_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cgk8E::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.386498856 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp17_closure" {
     Data.Functor.Contravariant.$fFloatingOp17_closure:
         const Data.Functor.Contravariant.$fFloatingOp17_info;
 },
 Data.Functor.Contravariant.$fFloatingOp17_entry() //  [R2, R3, R4]
         { info_tbl: [(cgk9m,
                       label: Data.Functor.Contravariant.$fFloatingOp17_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk9m: // global
           _sgjOO::P64 = R4;
           _sgjON::P64 = R3;
           _sgjOM::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgk9n; else goto cgk9o;
       cgk9o: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgk9q; else goto cgk9p;
       cgk9q: // global
           HpAlloc = 32;
           goto cgk9n;
       cgk9n: // global
           R4 = _sgjOO::P64;
           R3 = _sgjON::P64;
           R2 = _sgjOM::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk9p: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjON::P64;
           P64[Hp] = _sgjOO::P64;
           R2 = _sgjOM::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.exp_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.387601477 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp16_closure" {
     Data.Functor.Contravariant.$fFloatingOp16_closure:
         const Data.Functor.Contravariant.$fFloatingOp16_info;
 },
 Data.Functor.Contravariant.$fFloatingOp16_entry() //  [R2, R3, R4]
         { info_tbl: [(cgk9w,
                       label: Data.Functor.Contravariant.$fFloatingOp16_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk9w: // global
           _sgjOS::P64 = R4;
           _sgjOR::P64 = R3;
           _sgjOQ::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgk9x; else goto cgk9y;
       cgk9y: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgk9A; else goto cgk9z;
       cgk9A: // global
           HpAlloc = 32;
           goto cgk9x;
       cgk9x: // global
           R4 = _sgjOS::P64;
           R3 = _sgjOR::P64;
           R2 = _sgjOQ::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp16_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk9z: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOR::P64;
           P64[Hp] = _sgjOS::P64;
           R2 = _sgjOQ::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.388786512 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp15_closure" {
     Data.Functor.Contravariant.$fFloatingOp15_closure:
         const Data.Functor.Contravariant.$fFloatingOp15_info;
 },
 Data.Functor.Contravariant.$fFloatingOp15_entry() //  [R2, R3, R4]
         { info_tbl: [(cgk9G,
                       label: Data.Functor.Contravariant.$fFloatingOp15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk9G: // global
           _sgjOW::P64 = R4;
           _sgjOV::P64 = R3;
           _sgjOU::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgk9H; else goto cgk9I;
       cgk9I: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgk9K; else goto cgk9J;
       cgk9K: // global
           HpAlloc = 32;
           goto cgk9H;
       cgk9H: // global
           R4 = _sgjOW::P64;
           R3 = _sgjOV::P64;
           R2 = _sgjOU::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp15_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk9J: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOV::P64;
           P64[Hp] = _sgjOW::P64;
           R2 = _sgjOU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.sqrt_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.38999647 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp14_closure" {
     Data.Functor.Contravariant.$fFloatingOp14_closure:
         const Data.Functor.Contravariant.$fFloatingOp14_info;
 },
 Data.Functor.Contravariant.$fFloatingOp14_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cgk9R,
                       label: Data.Functor.Contravariant.$fFloatingOp14_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk9R: // global
           _sgjP1::P64 = R5;
           _sgjP0::P64 = R4;
           _sgjOZ::P64 = R3;
           _sgjOY::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgk9S; else goto cgk9T;
       cgk9T: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgk9V; else goto cgk9U;
       cgk9V: // global
           HpAlloc = 64;
           goto cgk9S;
       cgk9S: // global
           R5 = _sgjP1::P64;
           R4 = _sgjP0::P64;
           R3 = _sgjOZ::P64;
           R2 = _sgjOY::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp14_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgk9U: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjP0::P64;
           P64[Hp - 32] = _sgjP1::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOZ::P64;
           P64[Hp] = _sgjP1::P64;
           R2 = _sgjOY::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Float.**_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.391246361 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp13_closure" {
     Data.Functor.Contravariant.$fFloatingOp13_closure:
         const Data.Functor.Contravariant.$fFloatingOp13_info;
 },
 Data.Functor.Contravariant.$fFloatingOp13_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cgka2,
                       label: Data.Functor.Contravariant.$fFloatingOp13_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgka2: // global
           _sgjP7::P64 = R5;
           _sgjP6::P64 = R4;
           _sgjP5::P64 = R3;
           _sgjP4::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgka3; else goto cgka4;
       cgka4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgka6; else goto cgka5;
       cgka6: // global
           HpAlloc = 64;
           goto cgka3;
       cgka3: // global
           R5 = _sgjP7::P64;
           R4 = _sgjP6::P64;
           R3 = _sgjP5::P64;
           R2 = _sgjP4::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp13_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgka5: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjP6::P64;
           P64[Hp - 32] = _sgjP7::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjP5::P64;
           P64[Hp] = _sgjP7::P64;
           R2 = _sgjP4::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Float.logBase_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.392402704 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp12_closure" {
     Data.Functor.Contravariant.$fFloatingOp12_closure:
         const Data.Functor.Contravariant.$fFloatingOp12_info;
 },
 Data.Functor.Contravariant.$fFloatingOp12_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkac,
                       label: Data.Functor.Contravariant.$fFloatingOp12_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkac: // global
           _sgjPc::P64 = R4;
           _sgjPb::P64 = R3;
           _sgjPa::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkad; else goto cgkae;
       cgkae: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkag; else goto cgkaf;
       cgkag: // global
           HpAlloc = 32;
           goto cgkad;
       cgkad: // global
           R4 = _sgjPc::P64;
           R3 = _sgjPb::P64;
           R2 = _sgjPa::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp12_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkaf: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPb::P64;
           P64[Hp] = _sgjPc::P64;
           R2 = _sgjPa::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.sin_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.393774668 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp11_closure" {
     Data.Functor.Contravariant.$fFloatingOp11_closure:
         const Data.Functor.Contravariant.$fFloatingOp11_info;
 },
 Data.Functor.Contravariant.$fFloatingOp11_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkam,
                       label: Data.Functor.Contravariant.$fFloatingOp11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkam: // global
           _sgjPg::P64 = R4;
           _sgjPf::P64 = R3;
           _sgjPe::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkan; else goto cgkao;
       cgkao: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkaq; else goto cgkap;
       cgkaq: // global
           HpAlloc = 32;
           goto cgkan;
       cgkan: // global
           R4 = _sgjPg::P64;
           R3 = _sgjPf::P64;
           R2 = _sgjPe::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp11_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkap: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPf::P64;
           P64[Hp] = _sgjPg::P64;
           R2 = _sgjPe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.cos_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.394888848 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp10_closure" {
     Data.Functor.Contravariant.$fFloatingOp10_closure:
         const Data.Functor.Contravariant.$fFloatingOp10_info;
 },
 Data.Functor.Contravariant.$fFloatingOp10_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkaw,
                       label: Data.Functor.Contravariant.$fFloatingOp10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkaw: // global
           _sgjPk::P64 = R4;
           _sgjPj::P64 = R3;
           _sgjPi::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkax; else goto cgkay;
       cgkay: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkaA; else goto cgkaz;
       cgkaA: // global
           HpAlloc = 32;
           goto cgkax;
       cgkax: // global
           R4 = _sgjPk::P64;
           R3 = _sgjPj::P64;
           R2 = _sgjPi::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp10_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkaz: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPj::P64;
           P64[Hp] = _sgjPk::P64;
           R2 = _sgjPi::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.tan_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.395991598 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp9_closure" {
     Data.Functor.Contravariant.$fFloatingOp9_closure:
         const Data.Functor.Contravariant.$fFloatingOp9_info;
 },
 Data.Functor.Contravariant.$fFloatingOp9_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkaG,
                       label: Data.Functor.Contravariant.$fFloatingOp9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkaG: // global
           _sgjPo::P64 = R4;
           _sgjPn::P64 = R3;
           _sgjPm::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkaH; else goto cgkaI;
       cgkaI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkaK; else goto cgkaJ;
       cgkaK: // global
           HpAlloc = 32;
           goto cgkaH;
       cgkaH: // global
           R4 = _sgjPo::P64;
           R3 = _sgjPn::P64;
           R2 = _sgjPm::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp9_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkaJ: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPn::P64;
           P64[Hp] = _sgjPo::P64;
           R2 = _sgjPm::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.asin_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.397139805 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp8_closure" {
     Data.Functor.Contravariant.$fFloatingOp8_closure:
         const Data.Functor.Contravariant.$fFloatingOp8_info;
 },
 Data.Functor.Contravariant.$fFloatingOp8_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkaQ,
                       label: Data.Functor.Contravariant.$fFloatingOp8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkaQ: // global
           _sgjPs::P64 = R4;
           _sgjPr::P64 = R3;
           _sgjPq::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkaR; else goto cgkaS;
       cgkaS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkaU; else goto cgkaT;
       cgkaU: // global
           HpAlloc = 32;
           goto cgkaR;
       cgkaR: // global
           R4 = _sgjPs::P64;
           R3 = _sgjPr::P64;
           R2 = _sgjPq::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkaT: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPr::P64;
           P64[Hp] = _sgjPs::P64;
           R2 = _sgjPq::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.acos_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.398307649 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp7_closure" {
     Data.Functor.Contravariant.$fFloatingOp7_closure:
         const Data.Functor.Contravariant.$fFloatingOp7_info;
 },
 Data.Functor.Contravariant.$fFloatingOp7_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkb0,
                       label: Data.Functor.Contravariant.$fFloatingOp7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkb0: // global
           _sgjPw::P64 = R4;
           _sgjPv::P64 = R3;
           _sgjPu::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkb1; else goto cgkb2;
       cgkb2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkb4; else goto cgkb3;
       cgkb4: // global
           HpAlloc = 32;
           goto cgkb1;
       cgkb1: // global
           R4 = _sgjPw::P64;
           R3 = _sgjPv::P64;
           R2 = _sgjPu::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkb3: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPv::P64;
           P64[Hp] = _sgjPw::P64;
           R2 = _sgjPu::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.atan_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.399420991 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp6_closure" {
     Data.Functor.Contravariant.$fFloatingOp6_closure:
         const Data.Functor.Contravariant.$fFloatingOp6_info;
 },
 Data.Functor.Contravariant.$fFloatingOp6_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkba,
                       label: Data.Functor.Contravariant.$fFloatingOp6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkba: // global
           _sgjPA::P64 = R4;
           _sgjPz::P64 = R3;
           _sgjPy::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkbb; else goto cgkbc;
       cgkbc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkbe; else goto cgkbd;
       cgkbe: // global
           HpAlloc = 32;
           goto cgkbb;
       cgkbb: // global
           R4 = _sgjPA::P64;
           R3 = _sgjPz::P64;
           R2 = _sgjPy::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp6_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkbd: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPz::P64;
           P64[Hp] = _sgjPA::P64;
           R2 = _sgjPy::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.sinh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.402337727 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp5_closure" {
     Data.Functor.Contravariant.$fFloatingOp5_closure:
         const Data.Functor.Contravariant.$fFloatingOp5_info;
 },
 Data.Functor.Contravariant.$fFloatingOp5_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkbk,
                       label: Data.Functor.Contravariant.$fFloatingOp5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkbk: // global
           _sgjPE::P64 = R4;
           _sgjPD::P64 = R3;
           _sgjPC::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkbl; else goto cgkbm;
       cgkbm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkbo; else goto cgkbn;
       cgkbo: // global
           HpAlloc = 32;
           goto cgkbl;
       cgkbl: // global
           R4 = _sgjPE::P64;
           R3 = _sgjPD::P64;
           R2 = _sgjPC::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkbn: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPD::P64;
           P64[Hp] = _sgjPE::P64;
           R2 = _sgjPC::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.cosh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.403463161 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp4_closure" {
     Data.Functor.Contravariant.$fFloatingOp4_closure:
         const Data.Functor.Contravariant.$fFloatingOp4_info;
 },
 Data.Functor.Contravariant.$fFloatingOp4_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkbu,
                       label: Data.Functor.Contravariant.$fFloatingOp4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkbu: // global
           _sgjPI::P64 = R4;
           _sgjPH::P64 = R3;
           _sgjPG::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkbv; else goto cgkbw;
       cgkbw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkby; else goto cgkbx;
       cgkby: // global
           HpAlloc = 32;
           goto cgkbv;
       cgkbv: // global
           R4 = _sgjPI::P64;
           R3 = _sgjPH::P64;
           R2 = _sgjPG::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkbx: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPH::P64;
           P64[Hp] = _sgjPI::P64;
           R2 = _sgjPG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.tanh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.404596504 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp3_closure" {
     Data.Functor.Contravariant.$fFloatingOp3_closure:
         const Data.Functor.Contravariant.$fFloatingOp3_info;
 },
 Data.Functor.Contravariant.$fFloatingOp3_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkbE,
                       label: Data.Functor.Contravariant.$fFloatingOp3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkbE: // global
           _sgjPM::P64 = R4;
           _sgjPL::P64 = R3;
           _sgjPK::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkbF; else goto cgkbG;
       cgkbG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkbI; else goto cgkbH;
       cgkbI: // global
           HpAlloc = 32;
           goto cgkbF;
       cgkbF: // global
           R4 = _sgjPM::P64;
           R3 = _sgjPL::P64;
           R2 = _sgjPK::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkbH: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPL::P64;
           P64[Hp] = _sgjPM::P64;
           R2 = _sgjPK::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.asinh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.4057334 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp2_closure" {
     Data.Functor.Contravariant.$fFloatingOp2_closure:
         const Data.Functor.Contravariant.$fFloatingOp2_info;
 },
 Data.Functor.Contravariant.$fFloatingOp2_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkbO,
                       label: Data.Functor.Contravariant.$fFloatingOp2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkbO: // global
           _sgjPQ::P64 = R4;
           _sgjPP::P64 = R3;
           _sgjPO::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkbP; else goto cgkbQ;
       cgkbQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkbS; else goto cgkbR;
       cgkbS: // global
           HpAlloc = 32;
           goto cgkbP;
       cgkbP: // global
           R4 = _sgjPQ::P64;
           R3 = _sgjPP::P64;
           R2 = _sgjPO::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkbR: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPP::P64;
           P64[Hp] = _sgjPQ::P64;
           R2 = _sgjPO::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.acosh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.406868939 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp1_closure" {
     Data.Functor.Contravariant.$fFloatingOp1_closure:
         const Data.Functor.Contravariant.$fFloatingOp1_info;
 },
 Data.Functor.Contravariant.$fFloatingOp1_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkbY,
                       label: Data.Functor.Contravariant.$fFloatingOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkbY: // global
           _sgjPU::P64 = R4;
           _sgjPT::P64 = R3;
           _sgjPS::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkbZ; else goto cgkc0;
       cgkc0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkc2; else goto cgkc1;
       cgkc2: // global
           HpAlloc = 32;
           goto cgkbZ;
       cgkbZ: // global
           R4 = _sgjPU::P64;
           R3 = _sgjPT::P64;
           R2 = _sgjPS::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkc1: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPT::P64;
           P64[Hp] = _sgjPU::P64;
           R2 = _sgjPS::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.atanh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.408013417 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp2_closure" {
     Data.Functor.Contravariant.$fFractionalOp2_closure:
         const Data.Functor.Contravariant.$fFractionalOp2_info;
 },
 Data.Functor.Contravariant.$fFractionalOp2_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgkc9,
                       label: Data.Functor.Contravariant.$fFractionalOp2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkc9: // global
           _sgjPZ::P64 = R5;
           _sgjPY::P64 = R4;
           _sgjPX::P64 = R3;
           _sgjPW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkca; else goto cgkcb;
       cgkcb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkcd; else goto cgkcc;
       cgkcd: // global
           HpAlloc = 64;
           goto cgkca;
       cgkca: // global
           R5 = _sgjPZ::P64;
           R4 = _sgjPY::P64;
           R3 = _sgjPX::P64;
           R2 = _sgjPW::P64;
           R1 = Data.Functor.Contravariant.$fFractionalOp2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkcc: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjPY::P64;
           P64[Hp - 32] = _sgjPZ::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPX::P64;
           P64[Hp] = _sgjPZ::P64;
           R2 = _sgjPW::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Real./_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.409226852 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp1_closure" {
     Data.Functor.Contravariant.$fFractionalOp1_closure:
         const Data.Functor.Contravariant.$fFractionalOp1_info;
 },
 Data.Functor.Contravariant.$fFractionalOp1_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkcj,
                       label: Data.Functor.Contravariant.$fFractionalOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkcj: // global
           _sgjQ4::P64 = R4;
           _sgjQ3::P64 = R3;
           _sgjQ2::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkck; else goto cgkcl;
       cgkcl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkcn; else goto cgkcm;
       cgkcn: // global
           HpAlloc = 32;
           goto cgkck;
       cgkck: // global
           R4 = _sgjQ4::P64;
           R3 = _sgjQ3::P64;
           R2 = _sgjQ2::P64;
           R1 = Data.Functor.Contravariant.$fFractionalOp1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkcm: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQ3::P64;
           P64[Hp] = _sgjQ4::P64;
           R2 = _sgjQ2::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.41057504 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp_$cfromRational_closure" {
     Data.Functor.Contravariant.$fFractionalOp_$cfromRational_closure:
         const Data.Functor.Contravariant.$fFractionalOp_$cfromRational_info;
 },
 x_sgjQ8_entry() //  [R1]
         { info_tbl: [(cgkcw,
                       label: x_sgjQ8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkcw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkcx; else goto cgkcy;
       cgkcx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkcy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.fromRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjQa_entry() //  [R1]
         { info_tbl: [(cgkcE,
                       label: sat_sgjQa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkcE: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFractionalOp_$cfromRational_entry() //  [R2,
                                                                       R3]
         { info_tbl: [(cgkcH,
                       label: Data.Functor.Contravariant.$fFractionalOp_$cfromRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkcH: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgkcL; else goto cgkcK;
       cgkcL: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFractionalOp_$cfromRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkcK: // global
           I64[Hp - 40] = x_sgjQ8_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sgjQa_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.412239103 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp_$cnegate_closure" {
     Data.Functor.Contravariant.$fNumOp_$cnegate_closure:
         const Data.Functor.Contravariant.$fNumOp_$cnegate_info;
         const 0;
 },
 x_sgjQd_entry() //  [R1]
         { info_tbl: [(cgkcU,
                       label: x_sgjQd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkcU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkcV; else goto cgkcW;
       cgkcV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkcW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl1_rgjLs_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjQg_entry() //  [R1, R2]
         { info_tbl: [(cgkd3,
                       label: sat_sgjQg_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkd3: // global
           _sgjQe::P64 = R2;
           _sgjQg::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkd4; else goto cgkd5;
       cgkd5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkd7; else goto cgkd6;
       cgkd7: // global
           HpAlloc = 32;
           goto cgkd4;
       cgkd4: // global
           R2 = _sgjQe::P64;
           R1 = _sgjQg::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkd6: // global
           _sgjQb::P64 = P64[_sgjQg::P64 + 7];
           _sgjQc::P64 = P64[_sgjQg::P64 + 15];
           _sgjQd::P64 = P64[_sgjQg::P64 + 23];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQc::P64;
           P64[Hp] = _sgjQe::P64;
           R2 = _sgjQb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgjQd::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fNumOp_$cnegate_entry() //  [R2, R3]
         { info_tbl: [(cgkd8,
                       label: Data.Functor.Contravariant.$fNumOp_$cnegate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkd8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgkdc; else goto cgkdb;
       cgkdc: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fNumOp_$cnegate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkdb: // global
           I64[Hp - 48] = x_sgjQd_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = sat_sgjQg_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.414095526 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp5_closure" {
     Data.Functor.Contravariant.$fNumOp5_closure:
         const Data.Functor.Contravariant.$fNumOp5_info;
 },
 Data.Functor.Contravariant.$fNumOp5_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgkdj,
                       label: Data.Functor.Contravariant.$fNumOp5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkdj: // global
           _sgjQk::P64 = R5;
           _sgjQj::P64 = R4;
           _sgjQi::P64 = R3;
           _sgjQh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkdk; else goto cgkdl;
       cgkdl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkdn; else goto cgkdm;
       cgkdn: // global
           HpAlloc = 64;
           goto cgkdk;
       cgkdk: // global
           R5 = _sgjQk::P64;
           R4 = _sgjQj::P64;
           R3 = _sgjQi::P64;
           R2 = _sgjQh::P64;
           R1 = Data.Functor.Contravariant.$fNumOp5_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkdm: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjQj::P64;
           P64[Hp - 32] = _sgjQk::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQi::P64;
           P64[Hp] = _sgjQk::P64;
           R2 = _sgjQh::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.415278535 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp4_closure" {
     Data.Functor.Contravariant.$fNumOp4_closure:
         const Data.Functor.Contravariant.$fNumOp4_info;
 },
 Data.Functor.Contravariant.$fNumOp4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgkdu,
                       label: Data.Functor.Contravariant.$fNumOp4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkdu: // global
           _sgjQq::P64 = R5;
           _sgjQp::P64 = R4;
           _sgjQo::P64 = R3;
           _sgjQn::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkdv; else goto cgkdw;
       cgkdw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkdy; else goto cgkdx;
       cgkdy: // global
           HpAlloc = 64;
           goto cgkdv;
       cgkdv: // global
           R5 = _sgjQq::P64;
           R4 = _sgjQp::P64;
           R3 = _sgjQo::P64;
           R2 = _sgjQn::P64;
           R1 = Data.Functor.Contravariant.$fNumOp4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkdx: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjQp::P64;
           P64[Hp - 32] = _sgjQq::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQo::P64;
           P64[Hp] = _sgjQq::P64;
           R2 = _sgjQn::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.416509718 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp3_closure" {
     Data.Functor.Contravariant.$fNumOp3_closure:
         const Data.Functor.Contravariant.$fNumOp3_info;
 },
 Data.Functor.Contravariant.$fNumOp3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgkdF,
                       label: Data.Functor.Contravariant.$fNumOp3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkdF: // global
           _sgjQw::P64 = R5;
           _sgjQv::P64 = R4;
           _sgjQu::P64 = R3;
           _sgjQt::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkdG; else goto cgkdH;
       cgkdH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkdJ; else goto cgkdI;
       cgkdJ: // global
           HpAlloc = 64;
           goto cgkdG;
       cgkdG: // global
           R5 = _sgjQw::P64;
           R4 = _sgjQv::P64;
           R3 = _sgjQu::P64;
           R2 = _sgjQt::P64;
           R1 = Data.Functor.Contravariant.$fNumOp3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkdI: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjQv::P64;
           P64[Hp - 32] = _sgjQw::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQu::P64;
           P64[Hp] = _sgjQw::P64;
           R2 = _sgjQt::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.417696616 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp2_closure" {
     Data.Functor.Contravariant.$fNumOp2_closure:
         const Data.Functor.Contravariant.$fNumOp2_info;
 },
 Data.Functor.Contravariant.$fNumOp2_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkdP,
                       label: Data.Functor.Contravariant.$fNumOp2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkdP: // global
           _sgjQB::P64 = R4;
           _sgjQA::P64 = R3;
           _sgjQz::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkdQ; else goto cgkdR;
       cgkdR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkdT; else goto cgkdS;
       cgkdT: // global
           HpAlloc = 32;
           goto cgkdQ;
       cgkdQ: // global
           R4 = _sgjQB::P64;
           R3 = _sgjQA::P64;
           R2 = _sgjQz::P64;
           R1 = Data.Functor.Contravariant.$fNumOp2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkdS: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQA::P64;
           P64[Hp] = _sgjQB::P64;
           R2 = _sgjQz::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.418817082 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp1_closure" {
     Data.Functor.Contravariant.$fNumOp1_closure:
         const Data.Functor.Contravariant.$fNumOp1_info;
 },
 Data.Functor.Contravariant.$fNumOp1_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkdZ,
                       label: Data.Functor.Contravariant.$fNumOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkdZ: // global
           _sgjQF::P64 = R4;
           _sgjQE::P64 = R3;
           _sgjQD::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgke0; else goto cgke1;
       cgke1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgke3; else goto cgke2;
       cgke3: // global
           HpAlloc = 32;
           goto cgke0;
       cgke0: // global
           R4 = _sgjQF::P64;
           R3 = _sgjQE::P64;
           R2 = _sgjQD::P64;
           R1 = Data.Functor.Contravariant.$fNumOp1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgke2: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQE::P64;
           P64[Hp] = _sgjQF::P64;
           R2 = _sgjQD::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.420143921 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp_$cfromInteger_closure" {
     Data.Functor.Contravariant.$fNumOp_$cfromInteger_closure:
         const Data.Functor.Contravariant.$fNumOp_$cfromInteger_info;
 },
 x_sgjQJ_entry() //  [R1]
         { info_tbl: [(cgkec,
                       label: x_sgjQJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkec: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgked; else goto cgkee;
       cgked: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkee: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjQL_entry() //  [R1]
         { info_tbl: [(cgkek,
                       label: sat_sgjQL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkek: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fNumOp_$cfromInteger_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cgken,
                       label: Data.Functor.Contravariant.$fNumOp_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgken: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgker; else goto cgkeq;
       cgker: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fNumOp_$cfromInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkeq: // global
           I64[Hp - 40] = x_sgjQJ_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sgjQL_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.42234078 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp_closure" {
     Data.Functor.Contravariant.$fNumOp_closure:
         const Data.Functor.Contravariant.$fNumOp_info;
         const 0;
 },
 sat_sgjQT_entry() //  [R1, R2]
         { info_tbl: [(cgkeB,
                       label: sat_sgjQT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkeB: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fNumOp_$cfromInteger_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQS_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkeJ,
                       label: sat_sgjQS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkeJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fNumOp1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQR_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkeR,
                       label: sat_sgjQR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkeR: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fNumOp2_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQQ_entry() //  [R1, R2]
         { info_tbl: [(cgkeZ,
                       label: sat_sgjQQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkeZ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fNumOp_$cnegate_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQP_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkf7,
                       label: sat_sgjQP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkf7: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fNumOp3_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQO_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkff,
                       label: sat_sgjQO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkff: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fNumOp4_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQN_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkfn,
                       label: sat_sgjQN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkfn: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fNumOp5_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fNumOp_entry() //  [R2]
         { info_tbl: [(cgkfr,
                       label: Data.Functor.Contravariant.$fNumOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkfr: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto cgkfv; else goto cgkfu;
       cgkfv: // global
           HpAlloc = 176;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fNumOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkfu: // global
           I64[Hp - 168] = sat_sgjQT_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sgjQS_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sgjQR_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sgjQQ_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgjQP_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgjQO_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgjQN_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 69;
           P64[Hp - 40] = Hp - 85;
           P64[Hp - 32] = Hp - 101;
           P64[Hp - 24] = Hp - 119;
           P64[Hp - 16] = Hp - 134;
           P64[Hp - 8] = Hp - 150;
           P64[Hp] = Hp - 167;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.42476317 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure" {
     Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure:
         const Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_info;
         const 0;
 },
 sat_sgjQV_entry() //  [R1]
         { info_tbl: [(cgkfE,
                       label: sat_sgjQV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkfE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkfF; else goto cgkfG;
       cgkfF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkfG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_entry() //  [R2]
         { info_tbl: [(cgkfH,
                       label: Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkfH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgkfL; else goto cgkfK;
       cgkfL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkfK: // global
           I64[Hp - 16] = sat_sgjQV_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Contravariant.$fNumOp_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.426473101 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp_closure" {
     Data.Functor.Contravariant.$fFractionalOp_closure:
         const Data.Functor.Contravariant.$fFractionalOp_info;
         const 0;
 },
 sat_sgjR0_entry() //  [R1, R2]
         { info_tbl: [(cgkfV,
                       label: sat_sgjR0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkfV: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFractionalOp_$cfromRational_entry(R3,
                                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkg3,
                       label: sat_sgjQZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkg3: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFractionalOp1_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkgb,
                       label: sat_sgjQY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkgb: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fFractionalOp2_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQX_entry() //  [R1]
         { info_tbl: [(cgkgi,
                       label: sat_sgjQX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkgi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkgj; else goto cgkgk;
       cgkgj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkgk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFractionalOp_entry() //  [R2]
         { info_tbl: [(cgkgm,
                       label: Data.Functor.Contravariant.$fFractionalOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkgm: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgkgq; else goto cgkgp;
       cgkgq: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFractionalOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkgp: // global
           I64[Hp - 104] = sat_sgjR0_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgjQZ_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgjQY_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgjQX_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 69;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.428346418 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_info;
         const 0;
 },
 sat_sgjR2_entry() //  [R1]
         { info_tbl: [(cgkgz,
                       label: sat_sgjR2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkgz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkgA; else goto cgkgB;
       cgkgA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkgB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_entry() //  [R2]
         { info_tbl: [(cgkgC,
                       label: Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkgC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgkgG; else goto cgkgF;
       cgkgG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkgF: // global
           I64[Hp - 16] = sat_sgjR2_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Contravariant.$fFractionalOp_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.432284461 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_closure" {
     Data.Functor.Contravariant.$fFloatingOp_closure:
         const Data.Functor.Contravariant.$fFloatingOp_info;
         const 0;
 },
 lvl7_sgjR4_entry() //  [R1]
         { info_tbl: [(cgkgP,
                       label: lvl7_sgjR4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkgP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkgQ; else goto cgkgR;
       cgkgQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkgR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.pi_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjRs_entry() //  [R1, R2]
         { info_tbl: [(cgkgX,
                       label: sat_sgjRs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkgX: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRr_entry() //  [R1, R2]
         { info_tbl: [(cgkh5,
                       label: sat_sgjRr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkh5: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRq_entry() //  [R1, R2]
         { info_tbl: [(cgkhd,
                       label: sat_sgjRq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkhd: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$cexpm1_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRp_entry() //  [R1, R2]
         { info_tbl: [(cgkhl,
                       label: sat_sgjRp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkhl: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$clog1p_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRo_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkht,
                       label: sat_sgjRo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkht: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp1_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRn_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkhB,
                       label: sat_sgjRn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkhB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRm_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkhJ,
                       label: sat_sgjRm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkhJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp3_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRl_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkhR,
                       label: sat_sgjRl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkhR: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp4_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRk_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkhZ,
                       label: sat_sgjRk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkhZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp5_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRj_entry() //  [R1, R2, R3]
         { info_tbl: [(cgki7,
                       label: sat_sgjRj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgki7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp6_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRi_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkif,
                       label: sat_sgjRi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkif: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp7_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRh_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkin,
                       label: sat_sgjRh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkin: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp8_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRg_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkiv,
                       label: sat_sgjRg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkiv: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp9_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRf_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkiD,
                       label: sat_sgjRf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkiD: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp10_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRe_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkiL,
                       label: sat_sgjRe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkiL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp11_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRd_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkiT,
                       label: sat_sgjRd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkiT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp12_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRc_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkj1,
                       label: sat_sgjRc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkj1: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fFloatingOp13_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRb_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkj9,
                       label: sat_sgjRb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkj9: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fFloatingOp14_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRa_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkjh,
                       label: sat_sgjRa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkjh: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp15_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjR9_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkjp,
                       label: sat_sgjR9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkjp: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp16_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjR8_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkjx,
                       label: sat_sgjR8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkjx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp17_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjR7_entry() //  [R1]
         { info_tbl: [(cgkjF,
                       label: sat_sgjR7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkjF: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjR5_entry() //  [R1]
         { info_tbl: [(cgkjM,
                       label: sat_sgjR5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkjM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkjN; else goto cgkjO;
       cgkjN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkjO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_entry() //  [R2]
         { info_tbl: [(cgkjQ,
                       label: Data.Functor.Contravariant.$fFloatingOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkjQ: // global
           Hp = Hp + 592;
           if (Hp > HpLim) (likely: False) goto cgkjU; else goto cgkjT;
       cgkjU: // global
           HpAlloc = 592;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkjT: // global
           I64[Hp - 584] = lvl7_sgjR4_info;
           P64[Hp - 568] = R2;
           I64[Hp - 560] = sat_sgjRs_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_sgjRr_info;
           P64[Hp - 536] = R2;
           I64[Hp - 528] = sat_sgjRq_info;
           P64[Hp - 520] = R2;
           I64[Hp - 512] = sat_sgjRp_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_sgjRo_info;
           P64[Hp - 488] = R2;
           I64[Hp - 480] = sat_sgjRn_info;
           P64[Hp - 472] = R2;
           I64[Hp - 464] = sat_sgjRm_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_sgjRl_info;
           P64[Hp - 440] = R2;
           I64[Hp - 432] = sat_sgjRk_info;
           P64[Hp - 424] = R2;
           I64[Hp - 416] = sat_sgjRj_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_sgjRi_info;
           P64[Hp - 392] = R2;
           I64[Hp - 384] = sat_sgjRh_info;
           P64[Hp - 376] = R2;
           I64[Hp - 368] = sat_sgjRg_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_sgjRf_info;
           P64[Hp - 344] = R2;
           I64[Hp - 336] = sat_sgjRe_info;
           P64[Hp - 328] = R2;
           I64[Hp - 320] = sat_sgjRd_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_sgjRc_info;
           P64[Hp - 296] = R2;
           I64[Hp - 288] = sat_sgjRb_info;
           P64[Hp - 280] = R2;
           I64[Hp - 272] = sat_sgjRa_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_sgjR9_info;
           P64[Hp - 248] = R2;
           I64[Hp - 240] = sat_sgjR8_info;
           P64[Hp - 232] = R2;
           I64[Hp - 224] = sat_sgjR7_info;
           P64[Hp - 216] = Hp - 584;
           I64[Hp - 208] = sat_sgjR5_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = GHC.Float.C:Floating_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 223;
           P64[Hp - 160] = Hp - 238;
           P64[Hp - 152] = Hp - 254;
           P64[Hp - 144] = Hp - 270;
           P64[Hp - 136] = Hp - 285;
           P64[Hp - 128] = Hp - 301;
           P64[Hp - 120] = Hp - 318;
           P64[Hp - 112] = Hp - 334;
           P64[Hp - 104] = Hp - 350;
           P64[Hp - 96] = Hp - 366;
           P64[Hp - 88] = Hp - 382;
           P64[Hp - 80] = Hp - 398;
           P64[Hp - 72] = Hp - 414;
           P64[Hp - 64] = Hp - 430;
           P64[Hp - 56] = Hp - 446;
           P64[Hp - 48] = Hp - 462;
           P64[Hp - 40] = Hp - 478;
           P64[Hp - 32] = Hp - 494;
           P64[Hp - 24] = Hp - 511;
           P64[Hp - 16] = Hp - 527;
           P64[Hp - 8] = Hp - 543;
           P64[Hp] = Hp - 559;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.43790805 UTC

[section ""data" . Data.Functor.Contravariant.$fCategoryTYPEOp1_closure" {
     Data.Functor.Contravariant.$fCategoryTYPEOp1_closure:
         const Data.Functor.Contravariant.$fCategoryTYPEOp1_info;
 },
 Data.Functor.Contravariant.$fCategoryTYPEOp1_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cgkjZ,
                       label: Data.Functor.Contravariant.$fCategoryTYPEOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkjZ: // global
           R4 = R4;
           _sgjRu::P64 = R3;
           R3 = R2;
           R2 = _sgjRu::P64;
           call GHC.Base.._entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.438656749 UTC

[section ""data" . Data.Functor.Contravariant.$fCategoryTYPEOp_closure" {
     Data.Functor.Contravariant.$fCategoryTYPEOp_closure:
         const Control.Category.C:Category_con_info;
         const GHC.Base.id_closure+1;
         const Data.Functor.Contravariant.$fCategoryTYPEOp1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.439377423 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence3_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence3_closure:
         const Data.Functor.Contravariant.$fMonoidEquivalence3_info;
 },
 Data.Functor.Contravariant.$fMonoidEquivalence3_entry() //  []
         { info_tbl: [(cgkk6,
                       label: Data.Functor.Contravariant.$fMonoidEquivalence3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkk6: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.440919169 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence1_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence1_closure:
         const Data.Functor.Contravariant.$fSemigroupEquivalence1_info;
 },
 ds_sgjRC_entry() //  [R1]
         { info_tbl: [(cgkkn,
                       label: ds_sgjRC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkkn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkko; else goto cgkkp;
       cgkko: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkkp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fSemigroupEquivalence1_entry(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjRG_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkkB,
                       label: sat_sgjRG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkkB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkkC; else goto cgkkD;
       cgkkC: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkkD: // global
           I64[Sp - 32] = block_cgkkv_info;
           _sgjRE::P64 = R3;
           R3 = R3;
           _sgjRD::P64 = R2;
           R2 = R2;
           _sgjRC::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _sgjRC::P64;
           P64[Sp - 16] = _sgjRD::P64;
           P64[Sp - 8] = _sgjRE::P64;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkkv() //  [R1]
         { info_tbl: [(cgkkv,
                       label: block_cgkkv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkkv: // global
           if (R1 & 7 == 1) goto cgkky; else goto cgkkz;
       cgkky: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkkz: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupEquivalence1_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cgkkO,
                       label: Data.Functor.Contravariant.$fSemigroupEquivalence1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkkO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkkP; else goto cgkkQ;
       cgkkP: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupEquivalence1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkkQ: // global
           I64[Sp - 16] = block_cgkkd_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugkkW; else goto cgkke;
       ugkkW: // global
           call _cgkkd(R1) args: 0, res: 0, upd: 0;
       cgkke: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkkd() //  [R1]
         { info_tbl: [(cgkkd,
                       label: block_cgkkd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkkd: // global
           _sgjRx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgkkL; else goto cgkkM;
       cgkkL: // global
           R1 = _sgjRx::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgkkM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgkkV; else goto cgkkU;
       cgkkV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgkkU: // global
           _sgjRA::P64 = P64[R1 + 6];
           _sgjRB::P64 = P64[R1 + 14];
           I64[Hp - 48] = ds_sgjRC_info;
           P64[Hp - 32] = _sgjRA::P64;
           P64[Hp - 24] = _sgjRB::P64;
           I64[Hp - 16] = sat_sgjRG_info;
           P64[Hp - 8] = _sgjRx::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.443169469 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure:
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_info;
 },
 Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_entry() //  [R2]
         { info_tbl: [(cgkl4,
                       label: Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkl4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgkl5; else goto cgkl6;
       cgkl5: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkl6: // global
           I64[Sp - 8] = block_cgkl1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugkla; else goto cgkl2;
       ugkla: // global
           call _cgkl1(R1) args: 0, res: 0, upd: 0;
       cgkl2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkl1() //  [R1]
         { info_tbl: [(cgkl1,
                       label: block_cgkl1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkl1: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Contravariant.$fSemigroupEquivalence1_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.444449267 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence2_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence2_closure:
         const Data.Functor.Contravariant.$fMonoidEquivalence2_info;
 },
 Data.Functor.Contravariant.$fMonoidEquivalence2_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cgkll,
                       label: Data.Functor.Contravariant.$fMonoidEquivalence2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkll: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgklm; else goto cgkln;
       cgklm: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidEquivalence2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkln: // global
           I64[Sp - 32] = block_cgklf_info;
           _sgjRM::P64 = R3;
           R3 = R5;
           _sgjRL::P64 = R2;
           R2 = R4;
           R1 = _sgjRL::P64;
           P64[Sp - 24] = _sgjRM::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgklf() //  [R1]
         { info_tbl: [(cgklf,
                       label: block_cgklf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgklf: // global
           if (R1 & 7 == 1) goto cgkli; else goto cgklj;
       cgkli: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgklj: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.445670624 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Functor.Contravariant.$fMonoidEquivalence2_closure+4;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure+1;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_closure:
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_info;
         const 0;
 },
 Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_entry() //  [R2]
         { info_tbl: [(cgkly,
                       label: Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkly: // global
           R3 = Data.Functor.Contravariant.$fSemigroupEquivalence_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.446962139 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence1_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence1_closure:
         const Data.Functor.Contravariant.$fMonoidEquivalence1_info;
 },
 Data.Functor.Contravariant.$fMonoidEquivalence1_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cgklM,
                       label: Data.Functor.Contravariant.$fMonoidEquivalence1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgklM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgklN; else goto ugkm7;
       cgklN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidEquivalence1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ugkm7: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cgklC() args: 0, res: 0, upd: 0;
     }
 },
 _cgklC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgklC: // global
           _sgjRR::P64 = P64[Sp];
           I64[Sp] = block_cgklF_info;
           R1 = _sgjRR::P64;
           if (R1 & 7 != 0) goto ugkm9; else goto cgklG;
       ugkm9: // global
           call _cgklF(R1) args: 0, res: 0, upd: 0;
       cgklG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgklF() //  [R1]
         { info_tbl: [(cgklF,
                       label: block_cgklF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgklF: // global
           if (R1 & 7 == 1) goto cgklJ; else goto cgklK;
       cgklJ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgklK: // global
           I64[Sp - 8] = block_cgklU_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           _sgjRW::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sgjRW::P64;
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgklU() //  [R1]
         { info_tbl: [(cgklU,
                       label: block_cgklU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgklU: // global
           if (R1 & 7 == 1) goto cgkm1; else goto cgkm5;
       cgkm1: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkm5: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cgklC() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.448394246 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_closure+1;
         const Data.Functor.Contravariant.$fMonoidEquivalence3_closure+2;
         const Data.Functor.Contravariant.$fMonoidEquivalence2_closure+4;
         const Data.Functor.Contravariant.$fMonoidEquivalence1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.449104127 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate3_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate3_closure:
         const Data.Functor.Contravariant.$fMonoidPredicate3_info;
 },
 Data.Functor.Contravariant.$fMonoidPredicate3_entry() //  []
         { info_tbl: [(cgkmg,
                       label: Data.Functor.Contravariant.$fMonoidPredicate3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkmg: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.450604479 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate1_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate1_closure:
         const Data.Functor.Contravariant.$fSemigroupPredicate1_info;
 },
 ds_sgjS4_entry() //  [R1]
         { info_tbl: [(cgkmx,
                       label: ds_sgjS4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkmx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkmy; else goto cgkmz;
       cgkmy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkmz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fSemigroupPredicate1_entry(R3,
                                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjS7_entry() //  [R1, R2]
         { info_tbl: [(cgkmL,
                       label: sat_sgjS7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkmL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgkmM; else goto cgkmN;
       cgkmM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkmN: // global
           I64[Sp - 24] = block_cgkmF_info;
           _sgjS5::P64 = R2;
           R2 = R2;
           _sgjS4::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sgjS4::P64;
           P64[Sp - 8] = _sgjS5::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkmF() //  [R1]
         { info_tbl: [(cgkmF,
                       label: block_cgkmF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkmF: // global
           if (R1 & 7 == 1) goto cgkmI; else goto cgkmJ;
       cgkmI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkmJ: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupPredicate1_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cgkmY,
                       label: Data.Functor.Contravariant.$fSemigroupPredicate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkmY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkmZ; else goto cgkn0;
       cgkmZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupPredicate1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkn0: // global
           I64[Sp - 16] = block_cgkmn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugkn6; else goto cgkmo;
       ugkn6: // global
           call _cgkmn(R1) args: 0, res: 0, upd: 0;
       cgkmo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkmn() //  [R1]
         { info_tbl: [(cgkmn,
                       label: block_cgkmn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkmn: // global
           _sgjRZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgkmV; else goto cgkmW;
       cgkmV: // global
           R1 = _sgjRZ::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgkmW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgkn5; else goto cgkn4;
       cgkn5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgkn4: // global
           _sgjS2::P64 = P64[R1 + 6];
           _sgjS3::P64 = P64[R1 + 14];
           I64[Hp - 48] = ds_sgjS4_info;
           P64[Hp - 32] = _sgjS2::P64;
           P64[Hp - 24] = _sgjS3::P64;
           I64[Hp - 16] = sat_sgjS7_info;
           P64[Hp - 8] = _sgjRZ::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.452789486 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure:
         const Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_info;
 },
 Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_entry() //  [R2]
         { info_tbl: [(cgkne,
                       label: Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkne: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgknf; else goto cgkng;
       cgknf: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkng: // global
           I64[Sp - 8] = block_cgknb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugknk; else goto cgknc;
       ugknk: // global
           call _cgknb(R1) args: 0, res: 0, upd: 0;
       cgknc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgknb() //  [R1]
         { info_tbl: [(cgknb,
                       label: block_cgknb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgknb: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Contravariant.$fSemigroupPredicate1_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.45407428 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate2_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate2_closure:
         const Data.Functor.Contravariant.$fMonoidPredicate2_info;
 },
 Data.Functor.Contravariant.$fMonoidPredicate2_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgknv,
                       label: Data.Functor.Contravariant.$fMonoidPredicate2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgknv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgknw; else goto cgknx;
       cgknw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidPredicate2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgknx: // global
           I64[Sp - 24] = block_cgknp_info;
           _sgjSc::P64 = R2;
           R2 = R4;
           R1 = _sgjSc::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgknp() //  [R1]
         { info_tbl: [(cgknp,
                       label: block_cgknp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgknp: // global
           if (R1 & 7 == 1) goto cgkns; else goto cgknt;
       cgkns: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgknt: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.455242406 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Functor.Contravariant.$fMonoidPredicate2_closure+3;
         const Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure+1;
         const Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_closure:
         const Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_info;
         const 0;
 },
 Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_entry() //  [R2]
         { info_tbl: [(cgknI,
                       label: Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgknI: // global
           R3 = Data.Functor.Contravariant.$fSemigroupPredicate_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.456482168 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate1_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate1_closure:
         const Data.Functor.Contravariant.$fMonoidPredicate1_info;
 },
 Data.Functor.Contravariant.$fMonoidPredicate1_entry() //  [R2, R3]
         { info_tbl: [(cgknW,
                       label: Data.Functor.Contravariant.$fMonoidPredicate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgknW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgknX; else goto ugkoh;
       cgknX: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidPredicate1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ugkoh: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cgknM() args: 0, res: 0, upd: 0;
     }
 },
 _cgknM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgknM: // global
           _sgjSh::P64 = P64[Sp];
           I64[Sp] = block_cgknP_info;
           R1 = _sgjSh::P64;
           if (R1 & 7 != 0) goto ugkoj; else goto cgknQ;
       ugkoj: // global
           call _cgknP(R1) args: 0, res: 0, upd: 0;
       cgknQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgknP() //  [R1]
         { info_tbl: [(cgknP,
                       label: block_cgknP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgknP: // global
           if (R1 & 7 == 1) goto cgknT; else goto cgknU;
       cgknT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgknU: // global
           I64[Sp - 8] = block_cgko4_info;
           R2 = P64[Sp + 8];
           _sgjSl::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sgjSl::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgko4() //  [R1]
         { info_tbl: [(cgko4,
                       label: block_cgko4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgko4: // global
           if (R1 & 7 == 1) goto cgkob; else goto cgkof;
       cgkob: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkof: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cgknM() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.457874106 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fSemigroupPredicate_closure+1;
         const Data.Functor.Contravariant.$fMonoidPredicate3_closure+1;
         const Data.Functor.Contravariant.$fMonoidPredicate2_closure+3;
         const Data.Functor.Contravariant.$fMonoidPredicate1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.45857755 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_info;
 },
 Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_entry() //  []
         { info_tbl: [(cgkoq,
                       label: Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkoq: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.459293859 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProxy_closure" {
     Data.Functor.Contravariant.$fContravariantProxy_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_closure+2;
         const Data.Functor.Contravariant.$fContravariantProxy_$c>$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.460262238 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantCompose2_closure" {
     Data.Functor.Contravariant.$fContravariantCompose2_closure:
         const Data.Functor.Contravariant.$fContravariantCompose2_info;
 },
 sat_sgjSt_entry() //  [R1]
         { info_tbl: [(cgkoB,
                       label: sat_sgjSt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkoB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkoC; else goto cgkoD;
       cgkoC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkoD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantCompose2_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgkoE,
                       label: Data.Functor.Contravariant.$fContravariantCompose2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkoE: // global
           _sgjSs::P64 = R5;
           _sgjSr::P64 = R4;
           _sgjSq::P64 = R3;
           _sgjSp::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkoF; else goto cgkoG;
       cgkoG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkoI; else goto cgkoH;
       cgkoI: // global
           HpAlloc = 32;
           goto cgkoF;
       cgkoF: // global
           R5 = _sgjSs::P64;
           R4 = _sgjSr::P64;
           R3 = _sgjSq::P64;
           R2 = _sgjSp::P64;
           R1 = Data.Functor.Contravariant.$fContravariantCompose2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkoH: // global
           I64[Hp - 24] = sat_sgjSt_info;
           P64[Hp - 8] = _sgjSq::P64;
           P64[Hp] = _sgjSr::P64;
           R2 = _sgjSp::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgjSs::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.461962742 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantCompose_closure" {
     Data.Functor.Contravariant.$fContravariantCompose_closure:
         const Data.Functor.Contravariant.$fContravariantCompose_info;
 },
 sat_sgjSx_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkoS,
                       label: sat_sgjSx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkoS: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantCompose1_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjSw_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkp0,
                       label: sat_sgjSw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkp0: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantCompose2_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantCompose_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cgkp4,
                       label: Data.Functor.Contravariant.$fContravariantCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkp4: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgkp8; else goto cgkp7;
       cgkp8: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkp7: // global
           I64[Hp - 64] = sat_sgjSx_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjSw_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.463326791 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantConst2_closure" {
     Data.Functor.Contravariant.$fContravariantConst2_closure:
         const Data.Functor.Contravariant.$fContravariantConst2_info;
 },
 Data.Functor.Contravariant.$fContravariantConst2_entry() //  [R3]
         { info_tbl: [(cgkpd,
                       label: Data.Functor.Contravariant.$fContravariantConst2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkpd: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.464026258 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantConst_closure" {
     Data.Functor.Contravariant.$fContravariantConst_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantConst2_closure+2;
         const Data.Functor.Contravariant.$fContravariantConst1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.465236437 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_info;
 },
 sat_sgjSI_entry() //  [R1]
         { info_tbl: [(cgkpt,
                       label: sat_sgjSI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkpt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgkpu; else goto cgkpv;
       cgkpu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkpv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjSH_entry() //  [R1]
         { info_tbl: [(cgkpA,
                       label: sat_sgjSH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkpA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgkpB; else goto cgkpC;
       cgkpB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkpC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_entry() //  [R2,
                                                                            R3, R4, R5]
         { info_tbl: [(cgkpD,
                       label: Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkpD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkpF; else goto cgkpG;
       cgkpF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkpG: // global
           I64[Sp - 32] = block_cgkpk_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugkpK; else goto cgkpl;
       ugkpK: // global
           call _cgkpk(R1) args: 0, res: 0, upd: 0;
       cgkpl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkpk() //  [R1]
         { info_tbl: [(cgkpk,
                       label: block_cgkpk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkpk: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgkpJ; else goto cgkpI;
       cgkpJ: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgkpI: // global
           _sgjSF::P64 = P64[R1 + 7];
           _sgjSG::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgjSI_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sgjSC::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sgjSC::P64;
           P64[Hp - 64] = _sgjSG::P64;
           I64[Hp - 56] = sat_sgjSH_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgjSC::P64;
           P64[Hp - 24] = _sgjSF::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.469601032 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProduct_closure" {
     Data.Functor.Contravariant.$fContravariantProduct_closure:
         const Data.Functor.Contravariant.$fContravariantProduct_info;
 },
 sat_sgjSM_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkpU,
                       label: sat_sgjSM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkpU: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantProduct_$c>$_entry(R5,
                                                                             R4,
                                                                             R3,
                                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjSL_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkq2,
                       label: sat_sgjSL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkq2: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_entry(R5,
                                                                                    R4,
                                                                                    R3,
                                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantProduct_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cgkq6,
                       label: Data.Functor.Contravariant.$fContravariantProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkq6: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgkqa; else goto cgkq9;
       cgkqa: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkq9: // global
           I64[Hp - 64] = sat_sgjSM_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjSL_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.471677579 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantSum_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantSum_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantSum_$ccontramap_info;
 },
 sat_sgjST_entry() //  [R1]
         { info_tbl: [(cgkqo,
                       label: sat_sgjST_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkqo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgkqp; else goto cgkqq;
       cgkqp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkqq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjSV_entry() //  [R1]
         { info_tbl: [(cgkqx,
                       label: sat_sgjSV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkqx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgkqy; else goto cgkqz;
       cgkqy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkqz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantSum_$ccontramap_entry() //  [R2,
                                                                        R3, R4, R5]
         { info_tbl: [(cgkqE,
                       label: Data.Functor.Contravariant.$fContravariantSum_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkqE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkqF; else goto cgkqG;
       cgkqF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantSum_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkqG: // global
           I64[Sp - 32] = block_cgkqf_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugkqP; else goto cgkqg;
       ugkqP: // global
           call _cgkqf(R1) args: 0, res: 0, upd: 0;
       cgkqg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkqf() //  [R1]
         { info_tbl: [(cgkqf,
                       label: block_cgkqf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkqf: // global
           _sgjSP::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cgkqB; else goto cgkqC;
       cgkqB: // global
           Hp = Hp + 56;
           _sgjSR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgkqO; else goto cgkqJ;
       cgkqJ: // global
           _sgjSS::P64 = P64[_sgjSR::P64 + 7];
           I64[Hp - 48] = sat_sgjST_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgjSP::P64;
           P64[Hp - 16] = _sgjSS::P64;
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkqC: // global
           Hp = Hp + 56;
           _sgjSR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgkqO; else goto cgkqN;
       cgkqO: // global
           HpAlloc = 56;
           R1 = _sgjSR::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgkqN: // global
           _sgjSU::P64 = P64[_sgjSR::P64 + 6];
           I64[Hp - 48] = sat_sgjSV_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sgjSP::P64;
           P64[Hp - 16] = _sgjSU::P64;
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.47390479 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantSum_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantSum_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantSum_$c>$_info;
 },
 sat_sgjT1_entry() //  [R1]
         { info_tbl: [(cgkqZ,
                       label: sat_sgjT1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkqZ: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantSum_$c>$_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgkr2,
                       label: Data.Functor.Contravariant.$fContravariantSum_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkr2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgkr6; else goto cgkr5;
       cgkr6: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantSum_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkr5: // global
           I64[Hp - 8] = sat_sgjT1_info;
           P64[Hp] = R4;
           R5 = R5;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Contravariant.$fContravariantSum_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.475353977 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantSum_closure" {
     Data.Functor.Contravariant.$fContravariantSum_closure:
         const Data.Functor.Contravariant.$fContravariantSum_info;
 },
 sat_sgjT5_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkrg,
                       label: sat_sgjT5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkrg: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantSum_$c>$_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjT4_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkro,
                       label: sat_sgjT4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkro: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantSum_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantSum_entry() //  [R2, R3]
         { info_tbl: [(cgkrs,
                       label: Data.Functor.Contravariant.$fContravariantSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkrs: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgkrw; else goto cgkrv;
       cgkrw: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkrv: // global
           I64[Hp - 64] = sat_sgjT5_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjT4_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.477450664 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_info;
 },
 sat_sgjTc_entry() //  [R1]
         { info_tbl: [(cgkrK,
                       label: sat_sgjTc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkrK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgkrL; else goto cgkrM;
       cgkrL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkrM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjTe_entry() //  [R1]
         { info_tbl: [(cgkrT,
                       label: sat_sgjTe_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkrT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgkrU; else goto cgkrV;
       cgkrU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkrV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_entry() //  [R2,
                                                                        R3, R4, R5]
         { info_tbl: [(cgks0,
                       label: Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgks0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgks1; else goto cgks2;
       cgks1: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgks2: // global
           I64[Sp - 32] = block_cgkrB_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugksb; else goto cgkrC;
       ugksb: // global
           call _cgkrB(R1) args: 0, res: 0, upd: 0;
       cgkrC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkrB() //  [R1]
         { info_tbl: [(cgkrB,
                       label: block_cgkrB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkrB: // global
           _sgjT8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cgkrX; else goto cgkrY;
       cgkrX: // global
           Hp = Hp + 56;
           _sgjTa::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgksa; else goto cgks5;
       cgks5: // global
           _sgjTb::P64 = P64[_sgjTa::P64 + 7];
           I64[Hp - 48] = sat_sgjTc_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgjT8::P64;
           P64[Hp - 16] = _sgjTb::P64;
           I64[Hp - 8] = GHC.Generics.L1_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkrY: // global
           Hp = Hp + 56;
           _sgjTa::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgksa; else goto cgks9;
       cgksa: // global
           HpAlloc = 56;
           R1 = _sgjTa::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgks9: // global
           _sgjTd::P64 = P64[_sgjTa::P64 + 6];
           I64[Hp - 48] = sat_sgjTe_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sgjT8::P64;
           P64[Hp - 16] = _sgjTd::P64;
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.479670857 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:+:_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariant:+:_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariant:+:_$c>$_info;
 },
 sat_sgjTk_entry() //  [R1]
         { info_tbl: [(cgksl,
                       label: sat_sgjTk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgksl: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:+:_$c>$_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgkso,
                       label: Data.Functor.Contravariant.$fContravariant:+:_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkso: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgkss; else goto cgksr;
       cgkss: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:+:_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgksr: // global
           I64[Hp - 8] = sat_sgjTk_info;
           P64[Hp] = R4;
           R5 = R5;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.481108267 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:+:_closure" {
     Data.Functor.Contravariant.$fContravariant:+:_closure:
         const Data.Functor.Contravariant.$fContravariant:+:_info;
 },
 sat_sgjTo_entry() //  [R1, R2, R3]
         { info_tbl: [(cgksC,
                       label: sat_sgjTo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgksC: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:+:_$c>$_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjTn_entry() //  [R1, R2, R3]
         { info_tbl: [(cgksK,
                       label: sat_sgjTn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgksK: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:+:_entry() //  [R2, R3]
         { info_tbl: [(cgksO,
                       label: Data.Functor.Contravariant.$fContravariant:+:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgksO: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgksS; else goto cgksR;
       cgksS: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:+:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgksR: // global
           I64[Hp - 64] = sat_sgjTo_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjTn_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.482967341 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:.:2_closure" {
     Data.Functor.Contravariant.$fContravariant:.:2_closure:
         const Data.Functor.Contravariant.$fContravariant:.:2_info;
 },
 sat_sgjTt_entry() //  [R1]
         { info_tbl: [(cgkt1,
                       label: sat_sgjTt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkt1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkt2; else goto cgkt3;
       cgkt2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkt3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:.:2_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cgkt4,
                       label: Data.Functor.Contravariant.$fContravariant:.:2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkt4: // global
           _sgjTs::P64 = R5;
           _sgjTr::P64 = R4;
           _sgjTq::P64 = R3;
           _sgjTp::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkt5; else goto cgkt6;
       cgkt6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkt8; else goto cgkt7;
       cgkt8: // global
           HpAlloc = 32;
           goto cgkt5;
       cgkt5: // global
           R5 = _sgjTs::P64;
           R4 = _sgjTr::P64;
           R3 = _sgjTq::P64;
           R2 = _sgjTp::P64;
           R1 = Data.Functor.Contravariant.$fContravariant:.:2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkt7: // global
           I64[Hp - 24] = sat_sgjTt_info;
           P64[Hp - 8] = _sgjTq::P64;
           P64[Hp] = _sgjTr::P64;
           R2 = _sgjTp::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgjTs::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.484598083 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:.:_closure" {
     Data.Functor.Contravariant.$fContravariant:.:_closure:
         const Data.Functor.Contravariant.$fContravariant:.:_info;
 },
 sat_sgjTx_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkti,
                       label: sat_sgjTx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkti: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:.:1_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjTw_entry() //  [R1, R2, R3]
         { info_tbl: [(cgktq,
                       label: sat_sgjTw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgktq: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:.:2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:.:_entry() //  [R2, R3]
         { info_tbl: [(cgktu,
                       label: Data.Functor.Contravariant.$fContravariant:.:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgktu: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgkty; else goto cgktx;
       cgkty: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:.:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgktx: // global
           I64[Hp - 64] = sat_sgjTx_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjTw_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.486546737 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_info;
 },
 sat_sgjTG_entry() //  [R1]
         { info_tbl: [(cgktM,
                       label: sat_sgjTG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgktM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgktN; else goto cgktO;
       cgktN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgktO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjTF_entry() //  [R1]
         { info_tbl: [(cgktT,
                       label: sat_sgjTF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgktT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgktU; else goto cgktV;
       cgktU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgktV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_entry() //  [R2,
                                                                        R3, R4, R5]
         { info_tbl: [(cgktW,
                       label: Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgktW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgktY; else goto cgktZ;
       cgktY: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgktZ: // global
           I64[Sp - 32] = block_cgktD_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugku3; else goto cgktE;
       ugku3: // global
           call _cgktD(R1) args: 0, res: 0, upd: 0;
       cgktE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgktD() //  [R1]
         { info_tbl: [(cgktD,
                       label: block_cgktD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgktD: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgku2; else goto cgku1;
       cgku2: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgku1: // global
           _sgjTD::P64 = P64[R1 + 7];
           _sgjTE::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgjTG_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sgjTA::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sgjTA::P64;
           P64[Hp - 64] = _sgjTE::P64;
           I64[Hp - 56] = sat_sgjTF_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgjTA::P64;
           P64[Hp - 24] = _sgjTD::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.488711403 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:*:_closure" {
     Data.Functor.Contravariant.$fContravariant:*:_closure:
         const Data.Functor.Contravariant.$fContravariant:*:_info;
 },
 sat_sgjTK_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkud,
                       label: sat_sgjTK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkud: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:*:_$c>$_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjTJ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkul,
                       label: sat_sgjTJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkul: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:*:_entry() //  [R2, R3]
         { info_tbl: [(cgkup,
                       label: Data.Functor.Contravariant.$fContravariant:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkup: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgkut; else goto cgkus;
       cgkut: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkus: // global
           I64[Hp - 64] = sat_sgjTK_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjTJ_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.490121296 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantK3_closure" {
     Data.Functor.Contravariant.$fContravariantK3_closure:
         const Data.Functor.Contravariant.$fContravariantK3_info;
 },
 Data.Functor.Contravariant.$fContravariantK3_entry() //  [R3]
         { info_tbl: [(cgkuy,
                       label: Data.Functor.Contravariant.$fContravariantK3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkuy: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.490807869 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantK1_closure" {
     Data.Functor.Contravariant.$fContravariantK1_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantK3_closure+2;
         const Data.Functor.Contravariant.$fContravariantK2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.491484226 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantU1_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantU1_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantU1_$ccontramap_info;
 },
 Data.Functor.Contravariant.$fContravariantU1_$ccontramap_entry() //  []
         { info_tbl: [(cgkuF,
                       label: Data.Functor.Contravariant.$fContravariantU1_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkuF: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.492174672 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantU1_closure" {
     Data.Functor.Contravariant.$fContravariantU1_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantU1_$ccontramap_closure+2;
         const Data.Functor.Contravariant.$fContravariantU1_$c>$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.492888922 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantV1_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantV1_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantV1_$ccontramap_info;
 },
 Data.Functor.Contravariant.$fContravariantV1_$ccontramap_entry() //  [R3]
         { info_tbl: [(cgkuM,
                       label: Data.Functor.Contravariant.$fContravariantV1_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkuM: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.494265389 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantV1_closure" {
     Data.Functor.Contravariant.$fContravariantV1_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantV1_$ccontramap_closure+2;
         const Data.Functor.Contravariant.$fContravariantV1_$c>$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.49503208 UTC

[section ""data" . lvl2_rgjLt_closure" {
     lvl2_rgjLt_closure:
         const lvl2_rgjLt_info;
         const 0;
 },
 lvl2_rgjLt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgkuU,
                       label: lvl2_rgjLt_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkuU: // global
           _sgjTV::P64 = R5;
           _sgjTU::P64 = R4;
           _sgjTT::P64 = R3;
           _sgjTS::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkuV; else goto cgkuW;
       cgkuW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkuY; else goto cgkuX;
       cgkuY: // global
           HpAlloc = 32;
           goto cgkuV;
       cgkuV: // global
           R5 = _sgjTV::P64;
           R4 = _sgjTU::P64;
           R3 = _sgjTT::P64;
           R2 = _sgjTS::P64;
           R1 = lvl2_rgjLt_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkuX: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjTU::P64;
           P64[Hp] = _sgjTV::P64;
           R2 = _sgjTS::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgjTT::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.$fSemigroupOrdering_$cstimes_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.496283245 UTC

[section ""data" . lvl3_rgjLu_closure" {
     lvl3_rgjLu_closure:
         const lvl3_rgjLu_info;
         const 0;
 },
 lvl3_rgjLu_entry() //  [R2]
         { info_tbl: [(cgkv6,
                       label: lvl3_rgjLu_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkv6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgkv7; else goto cgkv8;
       cgkv7: // global
           R2 = R2;
           R1 = lvl3_rgjLu_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkv8: // global
           I64[Sp - 8] = block_cgkv3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugkvc; else goto cgkv4;
       ugkvc: // global
           call _cgkv3(R1) args: 0, res: 0, upd: 0;
       cgkv4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkv3() //  [R1]
         { info_tbl: [(cgkv3,
                       label: block_cgkv3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkv3: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = GHC.Base.$fSemigroupOrdering_closure;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.497648588 UTC

[section ""data" . lvl4_rgjLv_closure" {
     lvl4_rgjLv_closure:
         const lvl4_rgjLv_info;
 },
 lvl4_rgjLv_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkvo,
                       label: lvl4_rgjLv_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkvo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgkvp; else goto cgkvq;
       cgkvp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl4_rgjLv_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkvq: // global
           I64[Sp - 24] = block_cgkvh_info;
           _sgjU1::P64 = R2;
           R2 = R4;
           R1 = _sgjU1::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkvh() //  [R1]
         { info_tbl: [(cgkvh,
                       label: block_cgkvh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkvh: // global
           _cgkvn::P64 = R1 & 7;
           if (_cgkvn::P64 < 3) goto ugkvA; else goto cgkvm;
       ugkvA: // global
           if (_cgkvn::P64 < 2) goto cgkvk; else goto cgkvl;
       cgkvk: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkvl: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cgkvm: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.498755822 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure" {
     Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure:
         const GHC.Base.C:Semigroup_con_info;
         const lvl4_rgjLv_closure+3;
         const lvl3_rgjLu_closure+1;
         const lvl2_rgjLt_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.499543743 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison2_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison2_closure:
         const Data.Functor.Contravariant.$fSemigroupComparison2_info;
         const 0;
 },
 Data.Functor.Contravariant.$fSemigroupComparison2_entry() //  [R2]
         { info_tbl: [(cgkvI,
                       label: Data.Functor.Contravariant.$fSemigroupComparison2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkvI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgkvJ; else goto cgkvK;
       cgkvJ: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupComparison2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkvK: // global
           I64[Sp - 8] = block_cgkvF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugkvO; else goto cgkvG;
       ugkvO: // global
           call _cgkvF(R1) args: 0, res: 0, upd: 0;
       cgkvG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkvF() //  [R1]
         { info_tbl: [(cgkvF,
                       label: block_cgkvF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkvF: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure+1;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.500516964 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Functor.Contravariant.$fSemigroupComparison3_closure+3;
         const Data.Functor.Contravariant.$fSemigroupComparison2_closure+1;
         const Data.Functor.Contravariant.$fSemigroupComparison1_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.501176707 UTC

[section ""data" . lvl5_rgjLw_closure" {
     lvl5_rgjLw_closure:
         const lvl5_rgjLw_info;
 },
 lvl5_rgjLw_entry() //  []
         { info_tbl: [(cgkvT,
                       label: lvl5_rgjLw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkvT: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.502031424 UTC

[section ""data" . lvl6_rgjLx_closure" {
     lvl6_rgjLx_closure:
         const lvl6_rgjLx_info;
         const 0;
 },
 lvl6_rgjLx_entry() //  [R2, R3]
         { info_tbl: [(cgkw0,
                       label: lvl6_rgjLx_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkw0: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.$fMonoidOrdering_closure;
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.502766672 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure" {
     Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure+1;
         const lvl5_rgjLw_closure+1;
         const lvl4_rgjLv_closure+3;
         const lvl6_rgjLx_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.50342954 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison1_closure" {
     Data.Functor.Contravariant.$fMonoidComparison1_closure:
         const Data.Functor.Contravariant.$fMonoidComparison1_info;
         const 0;
 },
 Data.Functor.Contravariant.$fMonoidComparison1_entry() //  [R2, R3]
         { info_tbl: [(cgkw7,
                       label: Data.Functor.Contravariant.$fMonoidComparison1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkw7: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure+1;
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.50418155 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison_closure" {
     Data.Functor.Contravariant.$fMonoidComparison_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fSemigroupComparison_closure+1;
         const Data.Functor.Contravariant.$fMonoidComparison3_closure+2;
         const Data.Functor.Contravariant.$fMonoidComparison2_closure+3;
         const Data.Functor.Contravariant.$fMonoidComparison1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.504925213 UTC

[section ""data" . Data.Functor.Contravariant.C:Contravariant_closure" {
     Data.Functor.Contravariant.C:Contravariant_closure:
         const Data.Functor.Contravariant.C:Contravariant_info;
 },
 Data.Functor.Contravariant.C:Contravariant_entry() //  [R2, R3]
         { info_tbl: [(cgkwf,
                       label: Data.Functor.Contravariant.C:Contravariant_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkwf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgkwj; else goto cgkwi;
       cgkwj: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.C:Contravariant_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkwi: // global
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.506129579 UTC

[Data.Functor.Contravariant.C:Contravariant_con_entry() //  [R1]
         { info_tbl: [(cgkwk,
                       label: Data.Functor.Contravariant.C:Contravariant_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,110,116,114,97,118,97,114,105,97,110,116,46,67,58,67,111,110,116,114,97,118,97,114,105,97,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkwk: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.506796094 UTC

[section ""relreadonly" . Sgk42_srt" {
     Sgk42_srt:
         const GHC.Base.$fSemigroupOrdering_$cstimes_closure;
         const Data.Functor.Contravariant.$fSemigroupComparison1_closure;
         const sat_sgjO7_closure;
         const lvl1_rgjLs_closure;
         const lvl_rgjLr_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure;
         const Data.Functor.Contravariant.$fNumOp_$cnegate_closure;
         const Data.Functor.Contravariant.$fNumOp_closure;
         const Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure;
         const Data.Functor.Contravariant.$fFractionalOp_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure;
         const Data.Functor.Contravariant.$fFloatingOp_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_closure;
         const Data.Functor.Contravariant.$fSemigroupPredicate_closure;
         const lvl2_rgjLt_closure;
         const GHC.Base.$fSemigroupOrdering_closure;
         const lvl3_rgjLu_closure;
         const Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure;
         const Data.Functor.Contravariant.$fSemigroupComparison2_closure;
         const GHC.Base.$fMonoidOrdering_closure;
         const Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.507481103 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:13.508207651 UTC

[section ""data" . Data.Functor.Contravariant.contramap_closure" {
     Data.Functor.Contravariant.contramap_closure:
         const Data.Functor.Contravariant.contramap_info;
 },
 Data.Functor.Contravariant.contramap_entry() //  [R2]
         { info_tbl: [(cgkws,
                       label: Data.Functor.Contravariant.contramap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkws: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgkwt; else goto cgkwu;
       cgkwt: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.contramap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkwu: // global
           I64[Sp - 8] = block_cgkwp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugkwy; else goto cgkwq;
       ugkwy: // global
           call _cgkwp(R1) args: 0, res: 0, upd: 0;
       cgkwq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkwp() //  [R1]
         { info_tbl: [(cgkwp,
                       label: block_cgkwp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkwp: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.509462243 UTC

[section ""data" . Data.Functor.Contravariant.>$_closure" {
     Data.Functor.Contravariant.>$_closure:
         const Data.Functor.Contravariant.>$_info;
 },
 Data.Functor.Contravariant.>$_entry() //  [R2]
         { info_tbl: [(cgkwG,
                       label: Data.Functor.Contravariant.>$_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkwG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgkwH; else goto cgkwI;
       cgkwH: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.>$_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkwI: // global
           I64[Sp - 8] = block_cgkwD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugkwM; else goto cgkwE;
       ugkwM: // global
           call _cgkwD(R1) args: 0, res: 0, upd: 0;
       cgkwE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkwD() //  [R1]
         { info_tbl: [(cgkwD,
                       label: block_cgkwD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkwD: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.51042354 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Op3_bytes" {
     Data.Functor.Contravariant.$tc'Op3_bytes:
         I8[] [39,79,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.510975927 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Op2_closure" {
     Data.Functor.Contravariant.$tc'Op2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Op3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.511555884 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcOp2_bytes" {
     Data.Functor.Contravariant.$tcOp2_bytes:
         I8[] [79,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.512069666 UTC

[section ""data" . Data.Functor.Contravariant.$tcOp1_closure" {
     Data.Functor.Contravariant.$tcOp1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcOp2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.512639133 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Equivalence3_bytes" {
     Data.Functor.Contravariant.$tc'Equivalence3_bytes:
         I8[] [39,69,113,117,105,118,97,108,101,110,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.513205309 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Equivalence2_closure" {
     Data.Functor.Contravariant.$tc'Equivalence2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Equivalence3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.513780901 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcEquivalence2_bytes" {
     Data.Functor.Contravariant.$tcEquivalence2_bytes:
         I8[] [69,113,117,105,118,97,108,101,110,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.514346239 UTC

[section ""data" . Data.Functor.Contravariant.$tcEquivalence1_closure" {
     Data.Functor.Contravariant.$tcEquivalence1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcEquivalence2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.516425768 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Comparison3_bytes" {
     Data.Functor.Contravariant.$tc'Comparison3_bytes:
         I8[] [39,67,111,109,112,97,114,105,115,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.517008089 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Comparison2_closure" {
     Data.Functor.Contravariant.$tc'Comparison2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Comparison3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.517869056 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcComparison2_bytes" {
     Data.Functor.Contravariant.$tcComparison2_bytes:
         I8[] [67,111,109,112,97,114,105,115,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.518350497 UTC

[section ""data" . Data.Functor.Contravariant.$tcComparison1_closure" {
     Data.Functor.Contravariant.$tcComparison1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcComparison2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.51891382 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Predicate3_bytes" {
     Data.Functor.Contravariant.$tc'Predicate3_bytes:
         I8[] [39,80,114,101,100,105,99,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.519471574 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Predicate2_closure" {
     Data.Functor.Contravariant.$tc'Predicate2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Predicate3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.520094161 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcPredicate2_bytes" {
     Data.Functor.Contravariant.$tcPredicate2_bytes:
         I8[] [80,114,101,100,105,99,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.520659755 UTC

[section ""data" . Data.Functor.Contravariant.$tcPredicate1_closure" {
     Data.Functor.Contravariant.$tcPredicate1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcPredicate2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.521200014 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcContravariant3_bytes" {
     Data.Functor.Contravariant.$tcContravariant3_bytes:
         I8[] [67,111,110,116,114,97,118,97,114,105,97,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.521768704 UTC

[section ""data" . Data.Functor.Contravariant.$tcContravariant2_closure" {
     Data.Functor.Contravariant.$tcContravariant2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcContravariant3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.522273893 UTC

[section ""data" . $krep_rgjLa_closure" {
     $krep_rgjLa_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.522841535 UTC

[section ""data" . $krep1_rgjLb_closure" {
     $krep1_rgjLb_closure:
         const :_con_info;
         const $krep_rgjLa_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.523409946 UTC

[section ""data" . $krep2_rgjLc_closure" {
     $krep2_rgjLc_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.523991583 UTC

[section ""data" . $krep3_rgjLd_closure" {
     $krep3_rgjLd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rgjLc_closure+2;
         const $krep_rgjLa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.524579478 UTC

[section ""data" . $krep4_rgjLe_closure" {
     $krep4_rgjLe_closure:
         const :_con_info;
         const $krep2_rgjLc_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.525142684 UTC

[section ""data" . $krep5_rgjLf_closure" {
     $krep5_rgjLf_closure:
         const :_con_info;
         const $krep_rgjLa_closure+2;
         const $krep4_rgjLe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.52578863 UTC

[section ""data" . $krep6_rgjLg_closure" {
     $krep6_rgjLg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.526379499 UTC

[section ""data" . $krep7_rgjLh_closure" {
     $krep7_rgjLh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep6_rgjLg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.526958604 UTC

[section ""data" . $krep8_rgjLi_closure" {
     $krep8_rgjLi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep7_rgjLh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.527553834 UTC

[section ""data" . $krep9_rgjLj_closure" {
     $krep9_rgjLj_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcOrdering_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.528163143 UTC

[section ""data" . $krep10_rgjLk_closure" {
     $krep10_rgjLk_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep9_rgjLj_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.52878319 UTC

[section ""data" . $krep11_rgjLl_closure" {
     $krep11_rgjLl_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep10_rgjLk_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.529664395 UTC

[section ""data" . $krep12_rgjLm_closure" {
     $krep12_rgjLm_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.530227651 UTC

[section ""data" . Data.Functor.Contravariant.$tcContravariant1_closure" {
     Data.Functor.Contravariant.$tcContravariant1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep12_rgjLm_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.530784747 UTC

[section ""cstring" . Data.Functor.Contravariant.$trModule2_bytes" {
     Data.Functor.Contravariant.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,110,116,114,97,118,97,114,105,97,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.531376092 UTC

[section ""data" . Data.Functor.Contravariant.$trModule1_closure" {
     Data.Functor.Contravariant.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.5319659 UTC

[section ""cstring" . Data.Functor.Contravariant.$trModule4_bytes" {
     Data.Functor.Contravariant.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.532488809 UTC

[section ""data" . Data.Functor.Contravariant.$trModule3_closure" {
     Data.Functor.Contravariant.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.533106163 UTC

[section ""data" . Data.Functor.Contravariant.$trModule_closure" {
     Data.Functor.Contravariant.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Contravariant.$trModule3_closure+1;
         const Data.Functor.Contravariant.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.533704933 UTC

[section ""data" . Data.Functor.Contravariant.$tcContravariant_closure" {
     Data.Functor.Contravariant.$tcContravariant_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcContravariant2_closure+1;
         const Data.Functor.Contravariant.$tcContravariant1_closure+4;
         const 1944710495430526909;
         const 15571985404928937498;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.534333404 UTC

[section ""data" . Data.Functor.Contravariant.$tcPredicate_closure" {
     Data.Functor.Contravariant.$tcPredicate_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcPredicate1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 9927645946720114643;
         const 17478425232619398566;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.534937813 UTC

[section ""data" . $krep13_rgjLn_closure" {
     $krep13_rgjLn_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcPredicate_closure+1;
         const $krep1_rgjLb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.535533458 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Predicate1_closure" {
     Data.Functor.Contravariant.$tc'Predicate1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rgjLh_closure+4;
         const $krep13_rgjLn_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.53613838 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Predicate_closure" {
     Data.Functor.Contravariant.$tc'Predicate_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Predicate2_closure+1;
         const Data.Functor.Contravariant.$tc'Predicate1_closure+4;
         const 10560326927625189840;
         const 8988710799443424590;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.53675975 UTC

[section ""data" . Data.Functor.Contravariant.$tcComparison_closure" {
     Data.Functor.Contravariant.$tcComparison_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcComparison1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 8128667979445988110;
         const 9034904213662261762;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.537373625 UTC

[section ""data" . $krep14_rgjLo_closure" {
     $krep14_rgjLo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcComparison_closure+1;
         const $krep1_rgjLb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.537901264 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Comparison1_closure" {
     Data.Functor.Contravariant.$tc'Comparison1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_rgjLl_closure+4;
         const $krep14_rgjLo_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.538472684 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Comparison_closure" {
     Data.Functor.Contravariant.$tc'Comparison_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Comparison2_closure+1;
         const Data.Functor.Contravariant.$tc'Comparison1_closure+4;
         const 11047345948274903716;
         const 12707949450550295743;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.539038909 UTC

[section ""data" . Data.Functor.Contravariant.$tcEquivalence_closure" {
     Data.Functor.Contravariant.$tcEquivalence_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcEquivalence1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 9646573079009549553;
         const 12303965936368510845;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.539674849 UTC

[section ""data" . $krep15_rgjLp_closure" {
     $krep15_rgjLp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcEquivalence_closure+1;
         const $krep1_rgjLb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.540258631 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Equivalence1_closure" {
     Data.Functor.Contravariant.$tc'Equivalence1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rgjLi_closure+4;
         const $krep15_rgjLp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.540860698 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Equivalence_closure" {
     Data.Functor.Contravariant.$tc'Equivalence_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Equivalence2_closure+1;
         const Data.Functor.Contravariant.$tc'Equivalence1_closure+4;
         const 5667737350508967909;
         const 15093804341312440267;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.541814555 UTC

[section ""data" . Data.Functor.Contravariant.$tcOp_closure" {
     Data.Functor.Contravariant.$tcOp_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcOp1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 13209106975460307324;
         const 7546944290236364550;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.5432814 UTC

[section ""data" . $krep16_rgjLq_closure" {
     $krep16_rgjLq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcOp_closure+1;
         const $krep5_rgjLf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.543903675 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Op1_closure" {
     Data.Functor.Contravariant.$tc'Op1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rgjLd_closure+4;
         const $krep16_rgjLq_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.544478172 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Op_closure" {
     Data.Functor.Contravariant.$tc'Op_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Op2_closure+1;
         const Data.Functor.Contravariant.$tc'Op1_closure+4;
         const 12479862397628491530;
         const 1381176546464080972;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.54578619 UTC

[section ""data" . Data.Functor.Contravariant.comparisonEquivalence1_closure" {
     Data.Functor.Contravariant.comparisonEquivalence1_closure:
         const Data.Functor.Contravariant.comparisonEquivalence1_info;
 },
 Data.Functor.Contravariant.comparisonEquivalence1_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cgkwX,
                       label: Data.Functor.Contravariant.comparisonEquivalence1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkwX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgkwY; else goto cgkwZ;
       cgkwY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.comparisonEquivalence1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkwZ: // global
           I64[Sp - 8] = block_cgkwR_info;
           _sgjLI::P64 = R3;
           R3 = R4;
           _sgjLH::P64 = R2;
           R2 = _sgjLI::P64;
           R1 = _sgjLH::P64;
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkwR() //  [R1]
         { info_tbl: [(cgkwR,
                       label: block_cgkwR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkwR: // global
           if (R1 & 7 == 2) goto cgkwV; else goto cgkwU;
       cgkwV: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkwU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.546986917 UTC

[section ""data" . Data.Functor.Contravariant.comparisonEquivalence_closure" {
     Data.Functor.Contravariant.comparisonEquivalence_closure:
         const Data.Functor.Contravariant.comparisonEquivalence_info;
 },
 Data.Functor.Contravariant.comparisonEquivalence_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgkxa,
                       label: Data.Functor.Contravariant.comparisonEquivalence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkxa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Contravariant.comparisonEquivalence1_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.547868854 UTC

[section ""data" . Data.Functor.Contravariant.defaultEquivalence_closure" {
     Data.Functor.Contravariant.defaultEquivalence_closure:
         const Data.Functor.Contravariant.defaultEquivalence_info;
 },
 Data.Functor.Contravariant.defaultEquivalence_entry() //  [R2]
         { info_tbl: [(cgkxh,
                       label: Data.Functor.Contravariant.defaultEquivalence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkxh: // global
           R2 = R2;
           call GHC.Classes.==_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.548672253 UTC

[section ""data" . Data.Functor.Contravariant.defaultComparison_closure" {
     Data.Functor.Contravariant.defaultComparison_closure:
         const Data.Functor.Contravariant.defaultComparison_info;
 },
 Data.Functor.Contravariant.defaultComparison_entry() //  [R2]
         { info_tbl: [(cgkxo,
                       label: Data.Functor.Contravariant.defaultComparison_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkxo: // global
           R2 = R2;
           call GHC.Classes.compare_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.549546855 UTC

[section ""data" . Data.Functor.Contravariant.>$$<_closure" {
     Data.Functor.Contravariant.>$$<_closure:
         const Data.Functor.Contravariant.>$$<_info;
 },
 Data.Functor.Contravariant.>$$<_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkxv,
                       label: Data.Functor.Contravariant.>$$<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkxv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgkxw; else goto cgkxx;
       cgkxw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.>$$<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkxx: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.550425258 UTC

[section ""data" . Data.Functor.Contravariant.>$<_closure" {
     Data.Functor.Contravariant.>$<_closure:
         const Data.Functor.Contravariant.>$<_info;
 },
 Data.Functor.Contravariant.>$<_entry() //  [R2]
         { info_tbl: [(cgkxC,
                       label: Data.Functor.Contravariant.>$<_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkxC: // global
           R2 = R2;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.551434346 UTC

[section ""data" . Data.Functor.Contravariant.phantom_closure" {
     Data.Functor.Contravariant.phantom_closure:
         const Data.Functor.Contravariant.phantom_info;
 },
 sat_sgjLS_entry() //  [R1]
         { info_tbl: [(cgkxN,
                       label: sat_sgjLS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkxN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgkxO; else goto cgkxP;
       cgkxO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkxP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Tuple.()_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.<$_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.phantom_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkxQ,
                       label: Data.Functor.Contravariant.phantom_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkxQ: // global
           _sgjLR::P64 = R4;
           _sgjLQ::P64 = R3;
           _sgjLP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkxR; else goto cgkxS;
       cgkxS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkxU; else goto cgkxT;
       cgkxU: // global
           HpAlloc = 32;
           goto cgkxR;
       cgkxR: // global
           R4 = _sgjLR::P64;
           R3 = _sgjLQ::P64;
           R2 = _sgjLP::P64;
           R1 = Data.Functor.Contravariant.phantom_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkxT: // global
           I64[Hp - 24] = sat_sgjLS_info;
           P64[Hp - 8] = _sgjLP::P64;
           P64[Hp] = _sgjLR::P64;
           R2 = _sgjLQ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = GHC.Tuple.()_closure+1;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Functor.Contravariant.>$_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.552819056 UTC

[section ""data" . Data.Functor.Contravariant.$<_closure" {
     Data.Functor.Contravariant.$<_closure:
         const Data.Functor.Contravariant.$<_info;
 },
 Data.Functor.Contravariant.$<_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkxZ,
                       label: Data.Functor.Contravariant.$<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkxZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgky0; else goto cgky1;
       cgky0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgky1: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Data.Functor.Contravariant.>$_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.553788173 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantOp1_closure" {
     Data.Functor.Contravariant.$fContravariantOp1_closure:
         const Data.Functor.Contravariant.$fContravariantOp1_info;
 },
 Data.Functor.Contravariant.$fContravariantOp1_entry() //  [R2, R3]
         { info_tbl: [(cgky6,
                       label: Data.Functor.Contravariant.$fContravariantOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgky6: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.554600465 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantOp2_closure" {
     Data.Functor.Contravariant.$fContravariantOp2_closure:
         const Data.Functor.Contravariant.$fContravariantOp2_info;
 },
 Data.Functor.Contravariant.$fContravariantOp2_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgkyd,
                       label: Data.Functor.Contravariant.$fContravariantOp2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkyd: // global
           R4 = R4;
           _sgjM0::P64 = R3;
           R3 = R2;
           R2 = _sgjM0::P64;
           call GHC.Base.._entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.555342124 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantOp_closure" {
     Data.Functor.Contravariant.$fContravariantOp_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantOp2_closure+3;
         const Data.Functor.Contravariant.$fContravariantOp1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.55602572 UTC

[section ""data" . Data.Functor.Contravariant.getOp1_closure" {
     Data.Functor.Contravariant.getOp1_closure:
         const Data.Functor.Contravariant.getOp1_info;
 },
 Data.Functor.Contravariant.getOp1_entry() //  [R2]
         { info_tbl: [(cgkyk,
                       label: Data.Functor.Contravariant.getOp1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkyk: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.556818356 UTC

[section ""data" . Data.Functor.Contravariant.getOp_closure" {
     Data.Functor.Contravariant.getOp_closure:
         const Data.Functor.Contravariant.getOp_info;
 },
 Data.Functor.Contravariant.getOp_entry() //  [R2]
         { info_tbl: [(cgkyr,
                       label: Data.Functor.Contravariant.getOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkyr: // global
           R2 = R2;
           call Data.Functor.Contravariant.getOp1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.557638197 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantEquivalence1_closure" {
     Data.Functor.Contravariant.$fContravariantEquivalence1_closure:
         const Data.Functor.Contravariant.$fContravariantEquivalence1_info;
 },
 Data.Functor.Contravariant.$fContravariantEquivalence1_entry() //  [R2,
                                                                     R3]
         { info_tbl: [(cgkyy,
                       label: Data.Functor.Contravariant.$fContravariantEquivalence1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkyy: // global
           _sgjM3::P64 = R3;
           R3 = R2;
           R2 = R2;
           R1 = _sgjM3::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.558621347 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantEquivalence2_closure" {
     Data.Functor.Contravariant.$fContravariantEquivalence2_closure:
         const Data.Functor.Contravariant.$fContravariantEquivalence2_info;
 },
 Data.Functor.Contravariant.$fContravariantEquivalence2_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cgkyH,
                       label: Data.Functor.Contravariant.$fContravariantEquivalence2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkyH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkyL; else goto cgkyK;
       cgkyL: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantEquivalence2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkyK: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _sgjM7::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 24;
           R1 = _sgjM7::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.559536041 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantEquivalence_closure" {
     Data.Functor.Contravariant.$fContravariantEquivalence_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantEquivalence2_closure+4;
         const Data.Functor.Contravariant.$fContravariantEquivalence1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.560218608 UTC

[section ""data" . Data.Functor.Contravariant.getEquivalence1_closure" {
     Data.Functor.Contravariant.getEquivalence1_closure:
         const Data.Functor.Contravariant.getEquivalence1_info;
 },
 Data.Functor.Contravariant.getEquivalence1_entry() //  [R2]
         { info_tbl: [(cgkyQ,
                       label: Data.Functor.Contravariant.getEquivalence1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkyQ: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.561050342 UTC

[section ""data" . Data.Functor.Contravariant.getEquivalence_closure" {
     Data.Functor.Contravariant.getEquivalence_closure:
         const Data.Functor.Contravariant.getEquivalence_info;
 },
 Data.Functor.Contravariant.getEquivalence_entry() //  [R2]
         { info_tbl: [(cgkyX,
                       label: Data.Functor.Contravariant.getEquivalence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkyX: // global
           R2 = R2;
           call Data.Functor.Contravariant.getEquivalence1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.562262626 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantComparison1_closure" {
     Data.Functor.Contravariant.$fContravariantComparison1_closure:
         const Data.Functor.Contravariant.$fContravariantComparison1_info;
 },
 Data.Functor.Contravariant.$fContravariantComparison1_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cgkz4,
                       label: Data.Functor.Contravariant.$fContravariantComparison1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkz4: // global
           _sgjMe::P64 = R3;
           R3 = R2;
           R2 = R2;
           R1 = _sgjMe::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.563243782 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantComparison2_closure" {
     Data.Functor.Contravariant.$fContravariantComparison2_closure:
         const Data.Functor.Contravariant.$fContravariantComparison2_info;
 },
 Data.Functor.Contravariant.$fContravariantComparison2_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cgkzd,
                       label: Data.Functor.Contravariant.$fContravariantComparison2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkzd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkzh; else goto cgkzg;
       cgkzh: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantComparison2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkzg: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _sgjMi::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 24;
           R1 = _sgjMi::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.564178111 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantComparison_closure" {
     Data.Functor.Contravariant.$fContravariantComparison_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantComparison2_closure+4;
         const Data.Functor.Contravariant.$fContravariantComparison1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.564887189 UTC

[section ""data" . Data.Functor.Contravariant.getComparison1_closure" {
     Data.Functor.Contravariant.getComparison1_closure:
         const Data.Functor.Contravariant.getComparison1_info;
 },
 Data.Functor.Contravariant.getComparison1_entry() //  [R2]
         { info_tbl: [(cgkzm,
                       label: Data.Functor.Contravariant.getComparison1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkzm: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.56570739 UTC

[section ""data" . Data.Functor.Contravariant.getComparison_closure" {
     Data.Functor.Contravariant.getComparison_closure:
         const Data.Functor.Contravariant.getComparison_info;
 },
 Data.Functor.Contravariant.getComparison_entry() //  [R2]
         { info_tbl: [(cgkzt,
                       label: Data.Functor.Contravariant.getComparison_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkzt: // global
           R2 = R2;
           call Data.Functor.Contravariant.getComparison1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.566532577 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantPredicate1_closure" {
     Data.Functor.Contravariant.$fContravariantPredicate1_closure:
         const Data.Functor.Contravariant.$fContravariantPredicate1_info;
 },
 Data.Functor.Contravariant.$fContravariantPredicate1_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cgkzA,
                       label: Data.Functor.Contravariant.$fContravariantPredicate1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkzA: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.567423308 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantPredicate2_closure" {
     Data.Functor.Contravariant.$fContravariantPredicate2_closure:
         const Data.Functor.Contravariant.$fContravariantPredicate2_info;
 },
 Data.Functor.Contravariant.$fContravariantPredicate2_entry() //  [R2,
                                                                   R3, R4]
         { info_tbl: [(cgkzH,
                       label: Data.Functor.Contravariant.$fContravariantPredicate2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkzH: // global
           R4 = R4;
           _sgjMs::P64 = R3;
           R3 = R2;
           R2 = _sgjMs::P64;
           call GHC.Base.._entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.568160251 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantPredicate_closure" {
     Data.Functor.Contravariant.$fContravariantPredicate_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantPredicate2_closure+3;
         const Data.Functor.Contravariant.$fContravariantPredicate1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.568874142 UTC

[section ""data" . Data.Functor.Contravariant.getPredicate1_closure" {
     Data.Functor.Contravariant.getPredicate1_closure:
         const Data.Functor.Contravariant.getPredicate1_info;
 },
 Data.Functor.Contravariant.getPredicate1_entry() //  [R2]
         { info_tbl: [(cgkzO,
                       label: Data.Functor.Contravariant.getPredicate1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkzO: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.569876557 UTC

[section ""data" . Data.Functor.Contravariant.getPredicate_closure" {
     Data.Functor.Contravariant.getPredicate_closure:
         const Data.Functor.Contravariant.getPredicate_info;
 },
 Data.Functor.Contravariant.getPredicate_entry() //  [R2]
         { info_tbl: [(cgkzV,
                       label: Data.Functor.Contravariant.getPredicate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkzV: // global
           R2 = R2;
           call Data.Functor.Contravariant.getPredicate1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.570644038 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantV1_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantV1_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantV1_$c>$_info;
 },
 Data.Functor.Contravariant.$fContravariantV1_$c>$_entry() //  [R3]
         { info_tbl: [(cgkA2,
                       label: Data.Functor.Contravariant.$fContravariantV1_$c>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkA2: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.571440715 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantU1_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantU1_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantU1_$c>$_info;
 },
 Data.Functor.Contravariant.$fContravariantU1_$c>$_entry() //  []
         { info_tbl: [(cgkA9,
                       label: Data.Functor.Contravariant.$fContravariantU1_$c>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkA9: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.572222804 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantK2_closure" {
     Data.Functor.Contravariant.$fContravariantK2_closure:
         const Data.Functor.Contravariant.$fContravariantK2_info;
 },
 Data.Functor.Contravariant.$fContravariantK2_entry() //  [R3]
         { info_tbl: [(cgkAg,
                       label: Data.Functor.Contravariant.$fContravariantK2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkAg: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.57369727 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:*:_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariant:*:_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariant:*:_$c>$_info;
 },
 f1_sgjMI_entry() //  [R1]
         { info_tbl: [(cgkAx,
                       label: f1_sgjMI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkAx: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjML_entry() //  [R1]
         { info_tbl: [(cgkAE,
                       label: sat_sgjML_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkAE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgkAF; else goto cgkAG;
       cgkAF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkAG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjMK_entry() //  [R1]
         { info_tbl: [(cgkAL,
                       label: sat_sgjMK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkAL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgkAM; else goto cgkAN;
       cgkAM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkAN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:*:_$c>$_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgkAO,
                       label: Data.Functor.Contravariant.$fContravariant:*:_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkAO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkAQ; else goto cgkAR;
       cgkAQ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:*:_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkAR: // global
           I64[Sp - 32] = block_cgkAn_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugkAV; else goto cgkAo;
       ugkAV: // global
           call _cgkAn(R1) args: 0, res: 0, upd: 0;
       cgkAo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkAn() //  [R1]
         { info_tbl: [(cgkAn,
                       label: block_cgkAn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkAn: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cgkAU; else goto cgkAT;
       cgkAU: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgkAT: // global
           _sgjMG::P64 = P64[R1 + 7];
           _sgjMH::P64 = P64[R1 + 15];
           I64[Hp - 112] = f1_sgjMI_info;
           P64[Hp - 104] = P64[Sp + 24];
           I64[Hp - 96] = sat_sgjML_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sgjMH::P64;
           _cgkAs::P64 = Hp - 111;
           P64[Hp - 64] = _cgkAs::P64;
           I64[Hp - 56] = sat_sgjMK_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgjMG::P64;
           P64[Hp - 24] = _cgkAs::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.576063901 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:.:1_closure" {
     Data.Functor.Contravariant.$fContravariant:.:1_closure:
         const Data.Functor.Contravariant.$fContravariant:.:1_info;
 },
 sat_sgjMR_entry() //  [R1]
         { info_tbl: [(cgkB9,
                       label: sat_sgjMR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkB9: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjMS_entry() //  [R1]
         { info_tbl: [(cgkBc,
                       label: sat_sgjMS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkBc: // global
           _sgjMS::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgkBd; else goto cgkBe;
       cgkBe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgkBg; else goto cgkBf;
       cgkBg: // global
           HpAlloc = 16;
           goto cgkBd;
       cgkBd: // global
           R1 = _sgjMS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkBf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjMS::P64;
           _sgjMN::P64 = P64[_sgjMS::P64 + 16];
           _sgjMO::P64 = P64[_sgjMS::P64 + 24];
           I64[Hp - 8] = sat_sgjMR_info;
           P64[Hp] = _sgjMO::P64;
           R2 = _sgjMN::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:.:1_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cgkBh,
                       label: Data.Functor.Contravariant.$fContravariant:.:1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkBh: // global
           _sgjMP::P64 = R5;
           _sgjMO::P64 = R4;
           _sgjMN::P64 = R3;
           _sgjMM::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkBi; else goto cgkBj;
       cgkBj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkBl; else goto cgkBk;
       cgkBl: // global
           HpAlloc = 32;
           goto cgkBi;
       cgkBi: // global
           R5 = _sgjMP::P64;
           R4 = _sgjMO::P64;
           R3 = _sgjMN::P64;
           R2 = _sgjMM::P64;
           R1 = Data.Functor.Contravariant.$fContravariant:.:1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkBk: // global
           I64[Hp - 24] = sat_sgjMS_info;
           P64[Hp - 8] = _sgjMN::P64;
           P64[Hp] = _sgjMO::P64;
           R2 = _sgjMM::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgjMP::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.578289403 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProduct_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantProduct_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantProduct_$c>$_info;
 },
 f1_sgjN0_entry() //  [R1]
         { info_tbl: [(cgkBA,
                       label: f1_sgjN0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkBA: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjN3_entry() //  [R1]
         { info_tbl: [(cgkBH,
                       label: sat_sgjN3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkBH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgkBI; else goto cgkBJ;
       cgkBI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkBJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjN2_entry() //  [R1]
         { info_tbl: [(cgkBO,
                       label: sat_sgjN2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkBO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgkBP; else goto cgkBQ;
       cgkBP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkBQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantProduct_$c>$_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cgkBR,
                       label: Data.Functor.Contravariant.$fContravariantProduct_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkBR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkBT; else goto cgkBU;
       cgkBT: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantProduct_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkBU: // global
           I64[Sp - 32] = block_cgkBq_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugkBY; else goto cgkBr;
       ugkBY: // global
           call _cgkBq(R1) args: 0, res: 0, upd: 0;
       cgkBr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkBq() //  [R1]
         { info_tbl: [(cgkBq,
                       label: block_cgkBq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkBq: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cgkBX; else goto cgkBW;
       cgkBX: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgkBW: // global
           _sgjMY::P64 = P64[R1 + 7];
           _sgjMZ::P64 = P64[R1 + 15];
           I64[Hp - 112] = f1_sgjN0_info;
           P64[Hp - 104] = P64[Sp + 24];
           I64[Hp - 96] = sat_sgjN3_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sgjMZ::P64;
           _cgkBv::P64 = Hp - 111;
           P64[Hp - 64] = _cgkBv::P64;
           I64[Hp - 56] = sat_sgjN2_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgjMY::P64;
           P64[Hp - 24] = _cgkBv::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.580383979 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantConst1_closure" {
     Data.Functor.Contravariant.$fContravariantConst1_closure:
         const Data.Functor.Contravariant.$fContravariantConst1_info;
 },
 Data.Functor.Contravariant.$fContravariantConst1_entry() //  [R3]
         { info_tbl: [(cgkC3,
                       label: Data.Functor.Contravariant.$fContravariantConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkC3: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.581584309 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantCompose1_closure" {
     Data.Functor.Contravariant.$fContravariantCompose1_closure:
         const Data.Functor.Contravariant.$fContravariantCompose1_info;
 },
 sat_sgjNb_entry() //  [R1]
         { info_tbl: [(cgkCj,
                       label: sat_sgjNb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkCj: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNc_entry() //  [R1]
         { info_tbl: [(cgkCm,
                       label: sat_sgjNc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkCm: // global
           _sgjNc::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgkCn; else goto cgkCo;
       cgkCo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgkCq; else goto cgkCp;
       cgkCq: // global
           HpAlloc = 16;
           goto cgkCn;
       cgkCn: // global
           R1 = _sgjNc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkCp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjNc::P64;
           _sgjN7::P64 = P64[_sgjNc::P64 + 16];
           _sgjN8::P64 = P64[_sgjNc::P64 + 24];
           I64[Hp - 8] = sat_sgjNb_info;
           P64[Hp] = _sgjN8::P64;
           R2 = _sgjN7::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantCompose1_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgkCr,
                       label: Data.Functor.Contravariant.$fContravariantCompose1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkCr: // global
           _sgjN9::P64 = R5;
           _sgjN8::P64 = R4;
           _sgjN7::P64 = R3;
           _sgjN6::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkCs; else goto cgkCt;
       cgkCt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkCv; else goto cgkCu;
       cgkCv: // global
           HpAlloc = 32;
           goto cgkCs;
       cgkCs: // global
           R5 = _sgjN9::P64;
           R4 = _sgjN8::P64;
           R3 = _sgjN7::P64;
           R2 = _sgjN6::P64;
           R1 = Data.Functor.Contravariant.$fContravariantCompose1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkCu: // global
           I64[Hp - 24] = sat_sgjNc_info;
           P64[Hp - 8] = _sgjN7::P64;
           P64[Hp] = _sgjN8::P64;
           R2 = _sgjN6::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgjN9::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.583125714 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProxy_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantProxy_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantProxy_$c>$_info;
 },
 Data.Functor.Contravariant.$fContravariantProxy_$c>$_entry() //  []
         { info_tbl: [(cgkCA,
                       label: Data.Functor.Contravariant.$fContravariantProxy_$c>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkCA: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.584085189 UTC

[section ""data" . Data.Functor.Contravariant.$dm>$_closure" {
     Data.Functor.Contravariant.$dm>$_closure:
         const Data.Functor.Contravariant.$dm>$_info;
 },
 sat_sgjNi_entry() //  [R1]
         { info_tbl: [(cgkCM,
                       label: sat_sgjNi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkCM: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$dm>$_entry() //  [R2, R3]
         { info_tbl: [(cgkCP,
                       label: Data.Functor.Contravariant.$dm>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkCP: // global
           _sgjNg::P64 = R3;
           _sgjNf::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkCQ; else goto cgkCR;
       cgkCR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgkCT; else goto cgkCS;
       cgkCT: // global
           HpAlloc = 16;
           goto cgkCQ;
       cgkCQ: // global
           R3 = _sgjNg::P64;
           R2 = _sgjNf::P64;
           R1 = Data.Functor.Contravariant.$dm>$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkCS: // global
           I64[Hp - 8] = sat_sgjNi_info;
           P64[Hp] = _sgjNg::P64;
           R2 = _sgjNf::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.585723076 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupOp_closure" {
     Data.Functor.Contravariant.$fSemigroupOp_closure:
         const Data.Functor.Contravariant.$fSemigroupOp_info;
 },
 sat_sgjNm_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgkD3,
                       label: sat_sgjNm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkD3: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call GHC.Base.$fSemigroup(->)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNl_entry() //  [R1, R2]
         { info_tbl: [(cgkDb,
                       label: sat_sgjNl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkDb: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(->)_$csconcat_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkDj,
                       label: sat_sgjNk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkDj: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(->)_$c<>_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupOp_entry() //  [R2]
         { info_tbl: [(cgkDn,
                       label: Data.Functor.Contravariant.$fSemigroupOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkDn: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgkDr; else goto cgkDq;
       cgkDr: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkDq: // global
           I64[Hp - 72] = sat_sgjNm_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgjNl_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgjNk_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 68;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.587401527 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_closure" {
     Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_closure:
         const Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_info;
 },
 sat_sgjNo_entry() //  [R1]
         { info_tbl: [(cgkDA,
                       label: sat_sgjNo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkDA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkDB; else goto cgkDC;
       cgkDB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkDC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cgkDD,
                       label: Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkDD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgkDH; else goto cgkDG;
       cgkDH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkDG: // global
           I64[Hp - 16] = sat_sgjNo_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Contravariant.$fSemigroupOp_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.590342609 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidOp_closure" {
     Data.Functor.Contravariant.$fMonoidOp_closure:
         const Data.Functor.Contravariant.$fMonoidOp_info;
 },
 lvl7_sgjNq_entry() //  [R1]
         { info_tbl: [(cgkDQ,
                       label: lvl7_sgjNq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkDQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkDR; else goto cgkDS;
       cgkDR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkDS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjNv_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkDY,
                       label: sat_sgjNv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkDY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNu_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkE6,
                       label: sat_sgjNu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkE6: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoid(->)_$cmappend_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNt_entry() //  [R1]
         { info_tbl: [(cgkEe,
                       label: sat_sgjNt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkEe: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNr_entry() //  [R1]
         { info_tbl: [(cgkEl,
                       label: sat_sgjNr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkEl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkEm; else goto cgkEn;
       cgkEm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkEn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fMonoidOp_entry() //  [R2]
         { info_tbl: [(cgkEp,
                       label: Data.Functor.Contravariant.$fMonoidOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkEp: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cgkEt; else goto cgkEs;
       cgkEt: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkEs: // global
           I64[Hp - 128] = lvl7_sgjNq_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgjNv_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgjNu_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgjNt_info;
           P64[Hp - 64] = Hp - 128;
           I64[Hp - 56] = sat_sgjNr_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.592289921 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison3_closure" {
     Data.Functor.Contravariant.$fMonoidComparison3_closure:
         const Data.Functor.Contravariant.$fMonoidComparison3_info;
 },
 Data.Functor.Contravariant.$fMonoidComparison3_entry() //  []
         { info_tbl: [(cgkEy,
                       label: Data.Functor.Contravariant.$fMonoidComparison3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkEy: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.593876747 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison2_closure" {
     Data.Functor.Contravariant.$fMonoidComparison2_closure:
         const Data.Functor.Contravariant.$fMonoidComparison2_info;
 },
 sat_sgjNF_entry() //  [R1, R2]
         { info_tbl: [(cgkET,
                       label: sat_sgjNF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkET: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgkEU; else goto cgkEV;
       cgkEU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkEV: // global
           I64[Sp - 24] = block_cgkEM_info;
           _sgjND::P64 = R2;
           R2 = R2;
           _sgjNC::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sgjNC::P64;
           P64[Sp - 8] = _sgjND::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkEM() //  [R1]
         { info_tbl: [(cgkEM,
                       label: block_cgkEM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkEM: // global
           _cgkES::P64 = R1 & 7;
           if (_cgkES::P64 < 3) goto ugkF5; else goto cgkER;
       ugkF5: // global
           if (_cgkES::P64 < 2) goto cgkEP; else goto cgkEQ;
       cgkEP: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkEQ: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cgkER: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fMonoidComparison2_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cgkF6,
                       label: Data.Functor.Contravariant.$fMonoidComparison2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkF6: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgkFa; else goto cgkF9;
       cgkFa: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidComparison2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkF9: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgjNF_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.595874433 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison3_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison3_closure:
         const Data.Functor.Contravariant.$fSemigroupComparison3_info;
 },
 sat_sgjNN_entry() //  [R1, R2]
         { info_tbl: [(cgkFt,
                       label: sat_sgjNN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkFt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgkFu; else goto cgkFv;
       cgkFu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkFv: // global
           I64[Sp - 24] = block_cgkFm_info;
           _sgjNL::P64 = R2;
           R2 = R2;
           _sgjNK::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sgjNK::P64;
           P64[Sp - 8] = _sgjNL::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkFm() //  [R1]
         { info_tbl: [(cgkFm,
                       label: block_cgkFm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkFm: // global
           _cgkFs::P64 = R1 & 7;
           if (_cgkFs::P64 < 3) goto ugkFF; else goto cgkFr;
       ugkFF: // global
           if (_cgkFs::P64 < 2) goto cgkFp; else goto cgkFq;
       cgkFp: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkFq: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cgkFr: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupComparison3_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cgkFG,
                       label: Data.Functor.Contravariant.$fSemigroupComparison3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkFG: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgkFK; else goto cgkFJ;
       cgkFK: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupComparison3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkFJ: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgjNN_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.597948696 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison1_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison1_closure:
         const Data.Functor.Contravariant.$fSemigroupComparison1_info;
         const 0;
 },
 lvl7_sgjNT_entry() //  [R1]
         { info_tbl: [(cgkFU,
                       label: lvl7_sgjNT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkFU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkFV; else goto cgkFW;
       cgkFV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkFW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupOrdering_$cstimes_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjNW_entry() //  [R1, R2]
         { info_tbl: [(cgkG3,
                       label: sat_sgjNW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkG3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkG7; else goto cgkG6;
       cgkG7: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkG6: // global
           _sgjNP::P64 = P64[R1 + 7];
           _sgjNS::P64 = P64[R1 + 15];
           _sgjNT::P64 = P64[R1 + 23];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjNS::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = _sgjNP::P64;
           R1 = _sgjNT::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupComparison1_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cgkG8,
                       label: Data.Functor.Contravariant.$fSemigroupComparison1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkG8: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgkGc; else goto cgkGb;
       cgkGc: // global
           HpAlloc = 88;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupComparison1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkGb: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = lvl7_sgjNT_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = sat_sgjNW_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.59978289 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantM1_closure" {
     Data.Functor.Contravariant.$fContravariantM1_closure:
         const Data.Functor.Contravariant.$fContravariantM1_info;
 },
 sat_sgjNZ_entry() //  [R1]
         { info_tbl: [(cgkGl,
                       label: sat_sgjNZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkGl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkGm; else goto cgkGn;
       cgkGm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkGn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.>$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjNY_entry() //  [R1]
         { info_tbl: [(cgkGs,
                       label: sat_sgjNY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkGs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkGt; else goto cgkGu;
       cgkGt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkGu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantM1_entry() //  [R2]
         { info_tbl: [(cgkGw,
                       label: Data.Functor.Contravariant.$fContravariantM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkGw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgkGA; else goto cgkGz;
       cgkGA: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkGz: // global
           I64[Hp - 64] = sat_sgjNZ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgjNY_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.601479262 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantRec1_closure" {
     Data.Functor.Contravariant.$fContravariantRec1_closure:
         const Data.Functor.Contravariant.$fContravariantRec1_info;
 },
 sat_sgjO2_entry() //  [R1]
         { info_tbl: [(cgkGJ,
                       label: sat_sgjO2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkGJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkGK; else goto cgkGL;
       cgkGK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkGL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.>$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjO1_entry() //  [R1]
         { info_tbl: [(cgkGQ,
                       label: sat_sgjO1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkGQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkGR; else goto cgkGS;
       cgkGR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkGS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantRec1_entry() //  [R2]
         { info_tbl: [(cgkGU,
                       label: Data.Functor.Contravariant.$fContravariantRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkGU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgkGY; else goto cgkGX;
       cgkGY: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkGX: // global
           I64[Hp - 64] = sat_sgjO2_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgjO1_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.603140653 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantAlt_closure" {
     Data.Functor.Contravariant.$fContravariantAlt_closure:
         const Data.Functor.Contravariant.$fContravariantAlt_info;
 },
 sat_sgjO5_entry() //  [R1]
         { info_tbl: [(cgkH7,
                       label: sat_sgjO5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkH7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkH8; else goto cgkH9;
       cgkH8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkH9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.>$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjO4_entry() //  [R1]
         { info_tbl: [(cgkHe,
                       label: sat_sgjO4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkHe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkHf; else goto cgkHg;
       cgkHf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkHg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantAlt_entry() //  [R2]
         { info_tbl: [(cgkHi,
                       label: Data.Functor.Contravariant.$fContravariantAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkHi: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgkHm; else goto cgkHl;
       cgkHm: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkHl: // global
           I64[Hp - 64] = sat_sgjO5_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgjO4_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.604994537 UTC

[section ""data" . sat_sgjO6_closure" {
     sat_sgjO6_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.605875802 UTC

[section ""data" . sat_sgjO7_closure" {
     sat_sgjO7_closure:
         const :_con_info;
         const sat_sgjO6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.607032348 UTC

[section ""data" . lvl_rgjLr_closure" {
     lvl_rgjLr_closure:
         const lvl_rgjLr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rgjLr_entry() //  [R1]
         { info_tbl: [(cgkHt,
                       label: lvl_rgjLr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkHt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkHu; else goto cgkHv;
       cgkHu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkHv: // global
           (_cgkHq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgkHq::I64 == 0) goto cgkHs; else goto cgkHr;
       cgkHs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgkHr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgkHq::I64;
           R3 = sat_sgjO7_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.608149687 UTC

[section ""data" . lvl1_rgjLs_closure" {
     lvl1_rgjLs_closure:
         const lvl1_rgjLs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rgjLs_entry() //  [R1]
         { info_tbl: [(cgkHC,
                       label: lvl1_rgjLs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkHC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkHD; else goto cgkHE;
       cgkHD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkHE: // global
           (_cgkHz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgkHz::I64 == 0) goto cgkHB; else goto cgkHA;
       cgkHB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgkHA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgkHz::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.610562472 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_info;
         const 0;
 },
 $dFractional_sgjOa_entry() //  [R1]
         { info_tbl: [(cgkHN,
                       label: $dFractional_sgjOa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkHN: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgjOb_entry() //  [R1]
         { info_tbl: [(cgkHU,
                       label: $dNum_sgjOb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkHU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkHV; else goto cgkHW;
       cgkHV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkHW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgjOc_entry() //  [R1]
         { info_tbl: [(cgkI1,
                       label: x_sgjOc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkI1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkI2; else goto cgkI3;
       cgkI2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkI3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl1_rgjLs_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 x1_sgjOd_entry() //  [R1]
         { info_tbl: [(cgkI8,
                       label: x1_sgjOd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkI8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkI9; else goto cgkIa;
       cgkI9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkIa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOg_entry() //  [R1]
         { info_tbl: [(cgkIt,
                       label: sat_sgjOg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkIt: // global
           _sgjOg::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgkIu; else goto cgkIv;
       cgkIv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkIx; else goto cgkIw;
       cgkIx: // global
           HpAlloc = 32;
           goto cgkIu;
       cgkIu: // global
           R1 = _sgjOg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkIw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOg::P64;
           _sgjO8::P64 = P64[_sgjOg::P64 + 16];
           _sgjO9::P64 = P64[_sgjOg::P64 + 24];
           _sgjOe::P64 = P64[_sgjOg::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjO9::P64;
           P64[Hp] = _sgjOe::P64;
           R2 = _sgjO8::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Float.exp_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOh_entry() //  [R1]
         { info_tbl: [(cgkIy,
                       label: sat_sgjOh_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkIy: // global
           _sgjOh::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgkIz; else goto cgkIA;
       cgkIA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgkIC; else goto cgkIB;
       cgkIC: // global
           HpAlloc = 40;
           goto cgkIz;
       cgkIz: // global
           R1 = _sgjOh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkIB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOh::P64;
           _sgjO8::P64 = P64[_sgjOh::P64 + 16];
           _sgjO9::P64 = P64[_sgjOh::P64 + 24];
           _sgjOb::P64 = P64[_sgjOh::P64 + 32];
           _sgjOc::P64 = P64[_sgjOh::P64 + 40];
           _sgjOe::P64 = P64[_sgjOh::P64 + 48];
           I64[Hp - 32] = sat_sgjOg_info;
           P64[Hp - 16] = _sgjO8::P64;
           P64[Hp - 8] = _sgjO9::P64;
           P64[Hp] = _sgjOe::P64;
           R2 = _sgjOb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgjOc::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjOi_entry() //  [R1]
         { info_tbl: [(cgkID,
                       label: sat_sgjOi_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkID: // global
           _sgjOi::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgkIE; else goto cgkIF;
       cgkIF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgkIH; else goto cgkIG;
       cgkIH: // global
           HpAlloc = 56;
           goto cgkIE;
       cgkIE: // global
           R1 = _sgjOi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkIG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOi::P64;
           _sgjO8::P64 = P64[_sgjOi::P64 + 16];
           _sgjO9::P64 = P64[_sgjOi::P64 + 24];
           _sgjOb::P64 = P64[_sgjOi::P64 + 32];
           _sgjOc::P64 = P64[_sgjOi::P64 + 40];
           _sgjOd::P64 = P64[_sgjOi::P64 + 48];
           _sgjOe::P64 = P64[_sgjOi::P64 + 56];
           I64[Hp - 48] = sat_sgjOh_info;
           P64[Hp - 32] = _sgjO8::P64;
           P64[Hp - 24] = _sgjO9::P64;
           P64[Hp - 16] = _sgjOb::P64;
           P64[Hp - 8] = _sgjOc::P64;
           P64[Hp] = _sgjOe::P64;
           R2 = _sgjOb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgjOd::P64;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjOj_entry() //  [R1, R2]
         { info_tbl: [(cgkII,
                       label: sat_sgjOj_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkII: // global
           _sgjOe::P64 = R2;
           _sgjOj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkIJ; else goto cgkIK;
       cgkIK: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkIM; else goto cgkIL;
       cgkIM: // global
           HpAlloc = 64;
           goto cgkIJ;
       cgkIJ: // global
           R2 = _sgjOe::P64;
           R1 = _sgjOj::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkIL: // global
           _sgjO8::P64 = P64[_sgjOj::P64 + 7];
           _sgjO9::P64 = P64[_sgjOj::P64 + 15];
           _sgjOb::P64 = P64[_sgjOj::P64 + 23];
           _sgjOc::P64 = P64[_sgjOj::P64 + 31];
           _sgjOd::P64 = P64[_sgjOj::P64 + 39];
           I64[Hp - 56] = sat_sgjOi_info;
           P64[Hp - 40] = _sgjO8::P64;
           P64[Hp - 32] = _sgjO9::P64;
           P64[Hp - 24] = _sgjOb::P64;
           P64[Hp - 16] = _sgjOc::P64;
           P64[Hp - 8] = _sgjOd::P64;
           P64[Hp] = _sgjOe::P64;
           R2 = _sgjO8::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cgkIN,
                       label: Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkIN: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgkIR; else goto cgkIQ;
       cgkIR: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkIQ: // global
           I64[Hp - 136] = $dFractional_sgjOa_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = $dNum_sgjOb_info;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = x_sgjOc_info;
           _cgkHQ::P64 = Hp - 112;
           P64[Hp - 72] = _cgkHQ::P64;
           I64[Hp - 64] = x1_sgjOd_info;
           P64[Hp - 48] = _cgkHQ::P64;
           I64[Hp - 40] = sat_sgjOj_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = _cgkHQ::P64;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = Hp - 64;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.614871549 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$cexpm1_info;
         const 0;
 },
 $dFractional_sgjOm_entry() //  [R1]
         { info_tbl: [(cgkJ0,
                       label: $dFractional_sgjOm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkJ0: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgjOn_entry() //  [R1]
         { info_tbl: [(cgkJ7,
                       label: $dNum_sgjOn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkJ7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkJ8; else goto cgkJ9;
       cgkJ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkJ9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgjOo_entry() //  [R1]
         { info_tbl: [(cgkJe,
                       label: x_sgjOo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkJe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkJf; else goto cgkJg;
       cgkJf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkJg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOr_entry() //  [R1]
         { info_tbl: [(cgkJr,
                       label: sat_sgjOr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkJr: // global
           _sgjOr::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgkJs; else goto cgkJt;
       cgkJt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkJv; else goto cgkJu;
       cgkJv: // global
           HpAlloc = 32;
           goto cgkJs;
       cgkJs: // global
           R1 = _sgjOr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkJu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOr::P64;
           _sgjOk::P64 = P64[_sgjOr::P64 + 16];
           _sgjOl::P64 = P64[_sgjOr::P64 + 24];
           _sgjOp::P64 = P64[_sgjOr::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOl::P64;
           P64[Hp] = _sgjOp::P64;
           R2 = _sgjOk::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Float.exp_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOs_entry() //  [R1, R2]
         { info_tbl: [(cgkJw,
                       label: sat_sgjOs_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkJw: // global
           _sgjOp::P64 = R2;
           _sgjOs::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkJx; else goto cgkJy;
       cgkJy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgkJA; else goto cgkJz;
       cgkJA: // global
           HpAlloc = 40;
           goto cgkJx;
       cgkJx: // global
           R2 = _sgjOp::P64;
           R1 = _sgjOs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkJz: // global
           _sgjOk::P64 = P64[_sgjOs::P64 + 7];
           _sgjOl::P64 = P64[_sgjOs::P64 + 15];
           _sgjOn::P64 = P64[_sgjOs::P64 + 23];
           _sgjOo::P64 = P64[_sgjOs::P64 + 31];
           I64[Hp - 32] = sat_sgjOr_info;
           P64[Hp - 16] = _sgjOk::P64;
           P64[Hp - 8] = _sgjOl::P64;
           P64[Hp] = _sgjOp::P64;
           R2 = _sgjOn::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sgjOo::P64;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$cexpm1_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cgkJB,
                       label: Data.Functor.Contravariant.$fFloatingOp_$cexpm1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkJB: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgkJF; else goto cgkJE;
       cgkJF: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkJE: // global
           I64[Hp - 104] = $dFractional_sgjOm_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_sgjOn_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = x_sgjOo_info;
           _cgkJ3::P64 = Hp - 80;
           P64[Hp - 40] = _cgkJ3::P64;
           I64[Hp - 32] = sat_sgjOs_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cgkJ3::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.618207709 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_info;
         const 0;
 },
 $dFractional_sgjOv_entry() //  [R1]
         { info_tbl: [(cgkJO,
                       label: $dFractional_sgjOv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkJO: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgjOw_entry() //  [R1]
         { info_tbl: [(cgkJV,
                       label: $dNum_sgjOw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkJV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkJW; else goto cgkJX;
       cgkJW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkJX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgjOx_entry() //  [R1]
         { info_tbl: [(cgkK2,
                       label: x_sgjOx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkK2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkK3; else goto cgkK4;
       cgkK3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkK4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOA_entry() //  [R1]
         { info_tbl: [(cgkKj,
                       label: sat_sgjOA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkKj: // global
           _sgjOA::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgkKk; else goto cgkKl;
       cgkKl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkKn; else goto cgkKm;
       cgkKn: // global
           HpAlloc = 32;
           goto cgkKk;
       cgkKk: // global
           R1 = _sgjOA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkKm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOA::P64;
           _sgjOt::P64 = P64[_sgjOA::P64 + 16];
           _sgjOu::P64 = P64[_sgjOA::P64 + 24];
           _sgjOy::P64 = P64[_sgjOA::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOu::P64;
           P64[Hp] = _sgjOy::P64;
           R2 = _sgjOt::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Float.exp_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOB_entry() //  [R1]
         { info_tbl: [(cgkKo,
                       label: sat_sgjOB_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkKo: // global
           _sgjOB::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgkKp; else goto cgkKq;
       cgkKq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgkKs; else goto cgkKr;
       cgkKs: // global
           HpAlloc = 40;
           goto cgkKp;
       cgkKp: // global
           R1 = _sgjOB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkKr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOB::P64;
           _sgjOt::P64 = P64[_sgjOB::P64 + 16];
           _sgjOu::P64 = P64[_sgjOB::P64 + 24];
           _sgjOw::P64 = P64[_sgjOB::P64 + 32];
           _sgjOx::P64 = P64[_sgjOB::P64 + 40];
           _sgjOy::P64 = P64[_sgjOB::P64 + 48];
           I64[Hp - 32] = sat_sgjOA_info;
           P64[Hp - 16] = _sgjOt::P64;
           P64[Hp - 8] = _sgjOu::P64;
           P64[Hp] = _sgjOy::P64;
           R2 = _sgjOw::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgjOx::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjOC_entry() //  [R1, R2]
         { info_tbl: [(cgkKt,
                       label: sat_sgjOC_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkKt: // global
           _sgjOy::P64 = R2;
           _sgjOC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkKu; else goto cgkKv;
       cgkKv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgkKx; else goto cgkKw;
       cgkKx: // global
           HpAlloc = 56;
           goto cgkKu;
       cgkKu: // global
           R2 = _sgjOy::P64;
           R1 = _sgjOC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkKw: // global
           _sgjOt::P64 = P64[_sgjOC::P64 + 7];
           _sgjOu::P64 = P64[_sgjOC::P64 + 15];
           _sgjOw::P64 = P64[_sgjOC::P64 + 23];
           _sgjOx::P64 = P64[_sgjOC::P64 + 31];
           I64[Hp - 48] = sat_sgjOB_info;
           P64[Hp - 32] = _sgjOt::P64;
           P64[Hp - 24] = _sgjOu::P64;
           P64[Hp - 16] = _sgjOw::P64;
           P64[Hp - 8] = _sgjOx::P64;
           P64[Hp] = _sgjOy::P64;
           R2 = _sgjOt::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cgkKy,
                       label: Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkKy: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgkKC; else goto cgkKB;
       cgkKC: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkKB: // global
           I64[Hp - 104] = $dFractional_sgjOv_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_sgjOw_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = x_sgjOx_info;
           _cgkJR::P64 = Hp - 80;
           P64[Hp - 40] = _cgkJR::P64;
           I64[Hp - 32] = sat_sgjOC_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cgkJR::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.621859257 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$clog1p_info;
         const 0;
 },
 $dFractional_sgjOF_entry() //  [R1]
         { info_tbl: [(cgkKL,
                       label: $dFractional_sgjOF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkKL: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgjOG_entry() //  [R1]
         { info_tbl: [(cgkKS,
                       label: $dNum_sgjOG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkKS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkKT; else goto cgkKU;
       cgkKT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkKU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgjOH_entry() //  [R1]
         { info_tbl: [(cgkKZ,
                       label: x_sgjOH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkKZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkL0; else goto cgkL1;
       cgkL0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkL1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOK_entry() //  [R1]
         { info_tbl: [(cgkLc,
                       label: sat_sgjOK_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkLc: // global
           _sgjOK::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgkLd; else goto cgkLe;
       cgkLe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkLg; else goto cgkLf;
       cgkLg: // global
           HpAlloc = 32;
           goto cgkLd;
       cgkLd: // global
           R1 = _sgjOK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkLf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOK::P64;
           _sgjOE::P64 = P64[_sgjOK::P64 + 16];
           _sgjOG::P64 = P64[_sgjOK::P64 + 24];
           _sgjOH::P64 = P64[_sgjOK::P64 + 32];
           _sgjOI::P64 = P64[_sgjOK::P64 + 40];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOE::P64;
           P64[Hp] = _sgjOI::P64;
           R2 = _sgjOG::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgjOH::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjOL_entry() //  [R1, R2]
         { info_tbl: [(cgkLh,
                       label: sat_sgjOL_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkLh: // global
           _sgjOI::P64 = R2;
           _sgjOL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkLi; else goto cgkLj;
       cgkLj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgkLl; else goto cgkLk;
       cgkLl: // global
           HpAlloc = 48;
           goto cgkLi;
       cgkLi: // global
           R2 = _sgjOI::P64;
           R1 = _sgjOL::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkLk: // global
           _sgjOD::P64 = P64[_sgjOL::P64 + 7];
           _sgjOE::P64 = P64[_sgjOL::P64 + 15];
           _sgjOG::P64 = P64[_sgjOL::P64 + 23];
           _sgjOH::P64 = P64[_sgjOL::P64 + 31];
           I64[Hp - 40] = sat_sgjOK_info;
           P64[Hp - 24] = _sgjOE::P64;
           P64[Hp - 16] = _sgjOG::P64;
           P64[Hp - 8] = _sgjOH::P64;
           P64[Hp] = _sgjOI::P64;
           R2 = _sgjOD::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$clog1p_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cgkLm,
                       label: Data.Functor.Contravariant.$fFloatingOp_$clog1p_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkLm: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgkLq; else goto cgkLp;
       cgkLq: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkLp: // global
           I64[Hp - 104] = $dFractional_sgjOF_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_sgjOG_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = x_sgjOH_info;
           _cgkKO::P64 = Hp - 80;
           P64[Hp - 40] = _cgkKO::P64;
           I64[Hp - 32] = sat_sgjOL_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cgkKO::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.624377652 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp17_closure" {
     Data.Functor.Contravariant.$fFloatingOp17_closure:
         const Data.Functor.Contravariant.$fFloatingOp17_info;
 },
 Data.Functor.Contravariant.$fFloatingOp17_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkLw,
                       label: Data.Functor.Contravariant.$fFloatingOp17_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkLw: // global
           _sgjOO::P64 = R4;
           _sgjON::P64 = R3;
           _sgjOM::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkLx; else goto cgkLy;
       cgkLy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkLA; else goto cgkLz;
       cgkLA: // global
           HpAlloc = 32;
           goto cgkLx;
       cgkLx: // global
           R4 = _sgjOO::P64;
           R3 = _sgjON::P64;
           R2 = _sgjOM::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkLz: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjON::P64;
           P64[Hp] = _sgjOO::P64;
           R2 = _sgjOM::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.exp_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.625911536 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp16_closure" {
     Data.Functor.Contravariant.$fFloatingOp16_closure:
         const Data.Functor.Contravariant.$fFloatingOp16_info;
 },
 Data.Functor.Contravariant.$fFloatingOp16_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkLG,
                       label: Data.Functor.Contravariant.$fFloatingOp16_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkLG: // global
           _sgjOS::P64 = R4;
           _sgjOR::P64 = R3;
           _sgjOQ::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkLH; else goto cgkLI;
       cgkLI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkLK; else goto cgkLJ;
       cgkLK: // global
           HpAlloc = 32;
           goto cgkLH;
       cgkLH: // global
           R4 = _sgjOS::P64;
           R3 = _sgjOR::P64;
           R2 = _sgjOQ::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp16_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkLJ: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOR::P64;
           P64[Hp] = _sgjOS::P64;
           R2 = _sgjOQ::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.627039599 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp15_closure" {
     Data.Functor.Contravariant.$fFloatingOp15_closure:
         const Data.Functor.Contravariant.$fFloatingOp15_info;
 },
 Data.Functor.Contravariant.$fFloatingOp15_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkLQ,
                       label: Data.Functor.Contravariant.$fFloatingOp15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkLQ: // global
           _sgjOW::P64 = R4;
           _sgjOV::P64 = R3;
           _sgjOU::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkLR; else goto cgkLS;
       cgkLS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkLU; else goto cgkLT;
       cgkLU: // global
           HpAlloc = 32;
           goto cgkLR;
       cgkLR: // global
           R4 = _sgjOW::P64;
           R3 = _sgjOV::P64;
           R2 = _sgjOU::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp15_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkLT: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOV::P64;
           P64[Hp] = _sgjOW::P64;
           R2 = _sgjOU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.sqrt_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.628140702 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp14_closure" {
     Data.Functor.Contravariant.$fFloatingOp14_closure:
         const Data.Functor.Contravariant.$fFloatingOp14_info;
 },
 Data.Functor.Contravariant.$fFloatingOp14_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cgkM1,
                       label: Data.Functor.Contravariant.$fFloatingOp14_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkM1: // global
           _sgjP1::P64 = R5;
           _sgjP0::P64 = R4;
           _sgjOZ::P64 = R3;
           _sgjOY::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkM2; else goto cgkM3;
       cgkM3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkM5; else goto cgkM4;
       cgkM5: // global
           HpAlloc = 64;
           goto cgkM2;
       cgkM2: // global
           R5 = _sgjP1::P64;
           R4 = _sgjP0::P64;
           R3 = _sgjOZ::P64;
           R2 = _sgjOY::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp14_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkM4: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjP0::P64;
           P64[Hp - 32] = _sgjP1::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOZ::P64;
           P64[Hp] = _sgjP1::P64;
           R2 = _sgjOY::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Float.**_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.629341337 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp13_closure" {
     Data.Functor.Contravariant.$fFloatingOp13_closure:
         const Data.Functor.Contravariant.$fFloatingOp13_info;
 },
 Data.Functor.Contravariant.$fFloatingOp13_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cgkMc,
                       label: Data.Functor.Contravariant.$fFloatingOp13_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkMc: // global
           _sgjP7::P64 = R5;
           _sgjP6::P64 = R4;
           _sgjP5::P64 = R3;
           _sgjP4::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkMd; else goto cgkMe;
       cgkMe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkMg; else goto cgkMf;
       cgkMg: // global
           HpAlloc = 64;
           goto cgkMd;
       cgkMd: // global
           R5 = _sgjP7::P64;
           R4 = _sgjP6::P64;
           R3 = _sgjP5::P64;
           R2 = _sgjP4::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp13_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkMf: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjP6::P64;
           P64[Hp - 32] = _sgjP7::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjP5::P64;
           P64[Hp] = _sgjP7::P64;
           R2 = _sgjP4::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Float.logBase_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.630537443 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp12_closure" {
     Data.Functor.Contravariant.$fFloatingOp12_closure:
         const Data.Functor.Contravariant.$fFloatingOp12_info;
 },
 Data.Functor.Contravariant.$fFloatingOp12_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkMm,
                       label: Data.Functor.Contravariant.$fFloatingOp12_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkMm: // global
           _sgjPc::P64 = R4;
           _sgjPb::P64 = R3;
           _sgjPa::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkMn; else goto cgkMo;
       cgkMo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkMq; else goto cgkMp;
       cgkMq: // global
           HpAlloc = 32;
           goto cgkMn;
       cgkMn: // global
           R4 = _sgjPc::P64;
           R3 = _sgjPb::P64;
           R2 = _sgjPa::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp12_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkMp: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPb::P64;
           P64[Hp] = _sgjPc::P64;
           R2 = _sgjPa::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.sin_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.631643768 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp11_closure" {
     Data.Functor.Contravariant.$fFloatingOp11_closure:
         const Data.Functor.Contravariant.$fFloatingOp11_info;
 },
 Data.Functor.Contravariant.$fFloatingOp11_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkMw,
                       label: Data.Functor.Contravariant.$fFloatingOp11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkMw: // global
           _sgjPg::P64 = R4;
           _sgjPf::P64 = R3;
           _sgjPe::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkMx; else goto cgkMy;
       cgkMy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkMA; else goto cgkMz;
       cgkMA: // global
           HpAlloc = 32;
           goto cgkMx;
       cgkMx: // global
           R4 = _sgjPg::P64;
           R3 = _sgjPf::P64;
           R2 = _sgjPe::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp11_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkMz: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPf::P64;
           P64[Hp] = _sgjPg::P64;
           R2 = _sgjPe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.cos_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.632749096 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp10_closure" {
     Data.Functor.Contravariant.$fFloatingOp10_closure:
         const Data.Functor.Contravariant.$fFloatingOp10_info;
 },
 Data.Functor.Contravariant.$fFloatingOp10_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkMG,
                       label: Data.Functor.Contravariant.$fFloatingOp10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkMG: // global
           _sgjPk::P64 = R4;
           _sgjPj::P64 = R3;
           _sgjPi::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkMH; else goto cgkMI;
       cgkMI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkMK; else goto cgkMJ;
       cgkMK: // global
           HpAlloc = 32;
           goto cgkMH;
       cgkMH: // global
           R4 = _sgjPk::P64;
           R3 = _sgjPj::P64;
           R2 = _sgjPi::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp10_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkMJ: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPj::P64;
           P64[Hp] = _sgjPk::P64;
           R2 = _sgjPi::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.tan_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.633917711 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp9_closure" {
     Data.Functor.Contravariant.$fFloatingOp9_closure:
         const Data.Functor.Contravariant.$fFloatingOp9_info;
 },
 Data.Functor.Contravariant.$fFloatingOp9_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkMQ,
                       label: Data.Functor.Contravariant.$fFloatingOp9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkMQ: // global
           _sgjPo::P64 = R4;
           _sgjPn::P64 = R3;
           _sgjPm::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkMR; else goto cgkMS;
       cgkMS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkMU; else goto cgkMT;
       cgkMU: // global
           HpAlloc = 32;
           goto cgkMR;
       cgkMR: // global
           R4 = _sgjPo::P64;
           R3 = _sgjPn::P64;
           R2 = _sgjPm::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp9_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkMT: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPn::P64;
           P64[Hp] = _sgjPo::P64;
           R2 = _sgjPm::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.asin_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.63505212 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp8_closure" {
     Data.Functor.Contravariant.$fFloatingOp8_closure:
         const Data.Functor.Contravariant.$fFloatingOp8_info;
 },
 Data.Functor.Contravariant.$fFloatingOp8_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkN0,
                       label: Data.Functor.Contravariant.$fFloatingOp8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkN0: // global
           _sgjPs::P64 = R4;
           _sgjPr::P64 = R3;
           _sgjPq::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkN1; else goto cgkN2;
       cgkN2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkN4; else goto cgkN3;
       cgkN4: // global
           HpAlloc = 32;
           goto cgkN1;
       cgkN1: // global
           R4 = _sgjPs::P64;
           R3 = _sgjPr::P64;
           R2 = _sgjPq::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkN3: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPr::P64;
           P64[Hp] = _sgjPs::P64;
           R2 = _sgjPq::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.acos_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.636174037 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp7_closure" {
     Data.Functor.Contravariant.$fFloatingOp7_closure:
         const Data.Functor.Contravariant.$fFloatingOp7_info;
 },
 Data.Functor.Contravariant.$fFloatingOp7_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkNa,
                       label: Data.Functor.Contravariant.$fFloatingOp7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkNa: // global
           _sgjPw::P64 = R4;
           _sgjPv::P64 = R3;
           _sgjPu::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkNb; else goto cgkNc;
       cgkNc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkNe; else goto cgkNd;
       cgkNe: // global
           HpAlloc = 32;
           goto cgkNb;
       cgkNb: // global
           R4 = _sgjPw::P64;
           R3 = _sgjPv::P64;
           R2 = _sgjPu::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkNd: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPv::P64;
           P64[Hp] = _sgjPw::P64;
           R2 = _sgjPu::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.atan_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.637292356 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp6_closure" {
     Data.Functor.Contravariant.$fFloatingOp6_closure:
         const Data.Functor.Contravariant.$fFloatingOp6_info;
 },
 Data.Functor.Contravariant.$fFloatingOp6_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkNk,
                       label: Data.Functor.Contravariant.$fFloatingOp6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkNk: // global
           _sgjPA::P64 = R4;
           _sgjPz::P64 = R3;
           _sgjPy::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkNl; else goto cgkNm;
       cgkNm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkNo; else goto cgkNn;
       cgkNo: // global
           HpAlloc = 32;
           goto cgkNl;
       cgkNl: // global
           R4 = _sgjPA::P64;
           R3 = _sgjPz::P64;
           R2 = _sgjPy::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp6_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkNn: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPz::P64;
           P64[Hp] = _sgjPA::P64;
           R2 = _sgjPy::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.sinh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.638408448 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp5_closure" {
     Data.Functor.Contravariant.$fFloatingOp5_closure:
         const Data.Functor.Contravariant.$fFloatingOp5_info;
 },
 Data.Functor.Contravariant.$fFloatingOp5_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkNu,
                       label: Data.Functor.Contravariant.$fFloatingOp5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkNu: // global
           _sgjPE::P64 = R4;
           _sgjPD::P64 = R3;
           _sgjPC::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkNv; else goto cgkNw;
       cgkNw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkNy; else goto cgkNx;
       cgkNy: // global
           HpAlloc = 32;
           goto cgkNv;
       cgkNv: // global
           R4 = _sgjPE::P64;
           R3 = _sgjPD::P64;
           R2 = _sgjPC::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkNx: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPD::P64;
           P64[Hp] = _sgjPE::P64;
           R2 = _sgjPC::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.cosh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.639491138 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp4_closure" {
     Data.Functor.Contravariant.$fFloatingOp4_closure:
         const Data.Functor.Contravariant.$fFloatingOp4_info;
 },
 Data.Functor.Contravariant.$fFloatingOp4_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkNE,
                       label: Data.Functor.Contravariant.$fFloatingOp4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkNE: // global
           _sgjPI::P64 = R4;
           _sgjPH::P64 = R3;
           _sgjPG::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkNF; else goto cgkNG;
       cgkNG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkNI; else goto cgkNH;
       cgkNI: // global
           HpAlloc = 32;
           goto cgkNF;
       cgkNF: // global
           R4 = _sgjPI::P64;
           R3 = _sgjPH::P64;
           R2 = _sgjPG::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkNH: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPH::P64;
           P64[Hp] = _sgjPI::P64;
           R2 = _sgjPG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.tanh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.640654294 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp3_closure" {
     Data.Functor.Contravariant.$fFloatingOp3_closure:
         const Data.Functor.Contravariant.$fFloatingOp3_info;
 },
 Data.Functor.Contravariant.$fFloatingOp3_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkNO,
                       label: Data.Functor.Contravariant.$fFloatingOp3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkNO: // global
           _sgjPM::P64 = R4;
           _sgjPL::P64 = R3;
           _sgjPK::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkNP; else goto cgkNQ;
       cgkNQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkNS; else goto cgkNR;
       cgkNS: // global
           HpAlloc = 32;
           goto cgkNP;
       cgkNP: // global
           R4 = _sgjPM::P64;
           R3 = _sgjPL::P64;
           R2 = _sgjPK::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkNR: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPL::P64;
           P64[Hp] = _sgjPM::P64;
           R2 = _sgjPK::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.asinh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.641906362 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp2_closure" {
     Data.Functor.Contravariant.$fFloatingOp2_closure:
         const Data.Functor.Contravariant.$fFloatingOp2_info;
 },
 Data.Functor.Contravariant.$fFloatingOp2_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkNY,
                       label: Data.Functor.Contravariant.$fFloatingOp2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkNY: // global
           _sgjPQ::P64 = R4;
           _sgjPP::P64 = R3;
           _sgjPO::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkNZ; else goto cgkO0;
       cgkO0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkO2; else goto cgkO1;
       cgkO2: // global
           HpAlloc = 32;
           goto cgkNZ;
       cgkNZ: // global
           R4 = _sgjPQ::P64;
           R3 = _sgjPP::P64;
           R2 = _sgjPO::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkO1: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPP::P64;
           P64[Hp] = _sgjPQ::P64;
           R2 = _sgjPO::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.acosh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.643026441 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp1_closure" {
     Data.Functor.Contravariant.$fFloatingOp1_closure:
         const Data.Functor.Contravariant.$fFloatingOp1_info;
 },
 Data.Functor.Contravariant.$fFloatingOp1_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkO8,
                       label: Data.Functor.Contravariant.$fFloatingOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkO8: // global
           _sgjPU::P64 = R4;
           _sgjPT::P64 = R3;
           _sgjPS::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkO9; else goto cgkOa;
       cgkOa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkOc; else goto cgkOb;
       cgkOc: // global
           HpAlloc = 32;
           goto cgkO9;
       cgkO9: // global
           R4 = _sgjPU::P64;
           R3 = _sgjPT::P64;
           R2 = _sgjPS::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkOb: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPT::P64;
           P64[Hp] = _sgjPU::P64;
           R2 = _sgjPS::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.atanh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.644132258 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp2_closure" {
     Data.Functor.Contravariant.$fFractionalOp2_closure:
         const Data.Functor.Contravariant.$fFractionalOp2_info;
 },
 Data.Functor.Contravariant.$fFractionalOp2_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgkOj,
                       label: Data.Functor.Contravariant.$fFractionalOp2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkOj: // global
           _sgjPZ::P64 = R5;
           _sgjPY::P64 = R4;
           _sgjPX::P64 = R3;
           _sgjPW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkOk; else goto cgkOl;
       cgkOl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkOn; else goto cgkOm;
       cgkOn: // global
           HpAlloc = 64;
           goto cgkOk;
       cgkOk: // global
           R5 = _sgjPZ::P64;
           R4 = _sgjPY::P64;
           R3 = _sgjPX::P64;
           R2 = _sgjPW::P64;
           R1 = Data.Functor.Contravariant.$fFractionalOp2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkOm: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjPY::P64;
           P64[Hp - 32] = _sgjPZ::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPX::P64;
           P64[Hp] = _sgjPZ::P64;
           R2 = _sgjPW::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Real./_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.645333251 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp1_closure" {
     Data.Functor.Contravariant.$fFractionalOp1_closure:
         const Data.Functor.Contravariant.$fFractionalOp1_info;
 },
 Data.Functor.Contravariant.$fFractionalOp1_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkOt,
                       label: Data.Functor.Contravariant.$fFractionalOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkOt: // global
           _sgjQ4::P64 = R4;
           _sgjQ3::P64 = R3;
           _sgjQ2::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkOu; else goto cgkOv;
       cgkOv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkOx; else goto cgkOw;
       cgkOx: // global
           HpAlloc = 32;
           goto cgkOu;
       cgkOu: // global
           R4 = _sgjQ4::P64;
           R3 = _sgjQ3::P64;
           R2 = _sgjQ2::P64;
           R1 = Data.Functor.Contravariant.$fFractionalOp1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkOw: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQ3::P64;
           P64[Hp] = _sgjQ4::P64;
           R2 = _sgjQ2::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.646684759 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp_$cfromRational_closure" {
     Data.Functor.Contravariant.$fFractionalOp_$cfromRational_closure:
         const Data.Functor.Contravariant.$fFractionalOp_$cfromRational_info;
 },
 x_sgjQ8_entry() //  [R1]
         { info_tbl: [(cgkOG,
                       label: x_sgjQ8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkOG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkOH; else goto cgkOI;
       cgkOH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkOI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.fromRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjQa_entry() //  [R1]
         { info_tbl: [(cgkOO,
                       label: sat_sgjQa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkOO: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFractionalOp_$cfromRational_entry() //  [R2,
                                                                       R3]
         { info_tbl: [(cgkOR,
                       label: Data.Functor.Contravariant.$fFractionalOp_$cfromRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkOR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgkOV; else goto cgkOU;
       cgkOV: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFractionalOp_$cfromRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkOU: // global
           I64[Hp - 40] = x_sgjQ8_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sgjQa_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.648425266 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp_$cnegate_closure" {
     Data.Functor.Contravariant.$fNumOp_$cnegate_closure:
         const Data.Functor.Contravariant.$fNumOp_$cnegate_info;
         const 0;
 },
 x_sgjQd_entry() //  [R1]
         { info_tbl: [(cgkP4,
                       label: x_sgjQd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkP4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkP5; else goto cgkP6;
       cgkP5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkP6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl1_rgjLs_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjQg_entry() //  [R1, R2]
         { info_tbl: [(cgkPd,
                       label: sat_sgjQg_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkPd: // global
           _sgjQe::P64 = R2;
           _sgjQg::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkPe; else goto cgkPf;
       cgkPf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkPh; else goto cgkPg;
       cgkPh: // global
           HpAlloc = 32;
           goto cgkPe;
       cgkPe: // global
           R2 = _sgjQe::P64;
           R1 = _sgjQg::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkPg: // global
           _sgjQb::P64 = P64[_sgjQg::P64 + 7];
           _sgjQc::P64 = P64[_sgjQg::P64 + 15];
           _sgjQd::P64 = P64[_sgjQg::P64 + 23];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQc::P64;
           P64[Hp] = _sgjQe::P64;
           R2 = _sgjQb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgjQd::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fNumOp_$cnegate_entry() //  [R2, R3]
         { info_tbl: [(cgkPi,
                       label: Data.Functor.Contravariant.$fNumOp_$cnegate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkPi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgkPm; else goto cgkPl;
       cgkPm: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fNumOp_$cnegate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkPl: // global
           I64[Hp - 48] = x_sgjQd_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = sat_sgjQg_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.650203343 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp5_closure" {
     Data.Functor.Contravariant.$fNumOp5_closure:
         const Data.Functor.Contravariant.$fNumOp5_info;
 },
 Data.Functor.Contravariant.$fNumOp5_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgkPt,
                       label: Data.Functor.Contravariant.$fNumOp5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkPt: // global
           _sgjQk::P64 = R5;
           _sgjQj::P64 = R4;
           _sgjQi::P64 = R3;
           _sgjQh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkPu; else goto cgkPv;
       cgkPv: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkPx; else goto cgkPw;
       cgkPx: // global
           HpAlloc = 64;
           goto cgkPu;
       cgkPu: // global
           R5 = _sgjQk::P64;
           R4 = _sgjQj::P64;
           R3 = _sgjQi::P64;
           R2 = _sgjQh::P64;
           R1 = Data.Functor.Contravariant.$fNumOp5_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkPw: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjQj::P64;
           P64[Hp - 32] = _sgjQk::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQi::P64;
           P64[Hp] = _sgjQk::P64;
           R2 = _sgjQh::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.65143452 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp4_closure" {
     Data.Functor.Contravariant.$fNumOp4_closure:
         const Data.Functor.Contravariant.$fNumOp4_info;
 },
 Data.Functor.Contravariant.$fNumOp4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgkPE,
                       label: Data.Functor.Contravariant.$fNumOp4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkPE: // global
           _sgjQq::P64 = R5;
           _sgjQp::P64 = R4;
           _sgjQo::P64 = R3;
           _sgjQn::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkPF; else goto cgkPG;
       cgkPG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkPI; else goto cgkPH;
       cgkPI: // global
           HpAlloc = 64;
           goto cgkPF;
       cgkPF: // global
           R5 = _sgjQq::P64;
           R4 = _sgjQp::P64;
           R3 = _sgjQo::P64;
           R2 = _sgjQn::P64;
           R1 = Data.Functor.Contravariant.$fNumOp4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkPH: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjQp::P64;
           P64[Hp - 32] = _sgjQq::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQo::P64;
           P64[Hp] = _sgjQq::P64;
           R2 = _sgjQn::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.652643487 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp3_closure" {
     Data.Functor.Contravariant.$fNumOp3_closure:
         const Data.Functor.Contravariant.$fNumOp3_info;
 },
 Data.Functor.Contravariant.$fNumOp3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgkPP,
                       label: Data.Functor.Contravariant.$fNumOp3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkPP: // global
           _sgjQw::P64 = R5;
           _sgjQv::P64 = R4;
           _sgjQu::P64 = R3;
           _sgjQt::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgkPQ; else goto cgkPR;
       cgkPR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgkPT; else goto cgkPS;
       cgkPT: // global
           HpAlloc = 64;
           goto cgkPQ;
       cgkPQ: // global
           R5 = _sgjQw::P64;
           R4 = _sgjQv::P64;
           R3 = _sgjQu::P64;
           R2 = _sgjQt::P64;
           R1 = Data.Functor.Contravariant.$fNumOp3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkPS: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjQv::P64;
           P64[Hp - 32] = _sgjQw::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQu::P64;
           P64[Hp] = _sgjQw::P64;
           R2 = _sgjQt::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.653860372 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp2_closure" {
     Data.Functor.Contravariant.$fNumOp2_closure:
         const Data.Functor.Contravariant.$fNumOp2_info;
 },
 Data.Functor.Contravariant.$fNumOp2_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkPZ,
                       label: Data.Functor.Contravariant.$fNumOp2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkPZ: // global
           _sgjQB::P64 = R4;
           _sgjQA::P64 = R3;
           _sgjQz::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkQ0; else goto cgkQ1;
       cgkQ1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkQ3; else goto cgkQ2;
       cgkQ3: // global
           HpAlloc = 32;
           goto cgkQ0;
       cgkQ0: // global
           R4 = _sgjQB::P64;
           R3 = _sgjQA::P64;
           R2 = _sgjQz::P64;
           R1 = Data.Functor.Contravariant.$fNumOp2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkQ2: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQA::P64;
           P64[Hp] = _sgjQB::P64;
           R2 = _sgjQz::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.654974047 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp1_closure" {
     Data.Functor.Contravariant.$fNumOp1_closure:
         const Data.Functor.Contravariant.$fNumOp1_info;
 },
 Data.Functor.Contravariant.$fNumOp1_entry() //  [R2, R3, R4]
         { info_tbl: [(cgkQ9,
                       label: Data.Functor.Contravariant.$fNumOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkQ9: // global
           _sgjQF::P64 = R4;
           _sgjQE::P64 = R3;
           _sgjQD::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgkQa; else goto cgkQb;
       cgkQb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgkQd; else goto cgkQc;
       cgkQd: // global
           HpAlloc = 32;
           goto cgkQa;
       cgkQa: // global
           R4 = _sgjQF::P64;
           R3 = _sgjQE::P64;
           R2 = _sgjQD::P64;
           R1 = Data.Functor.Contravariant.$fNumOp1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkQc: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQE::P64;
           P64[Hp] = _sgjQF::P64;
           R2 = _sgjQD::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.658481406 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp_$cfromInteger_closure" {
     Data.Functor.Contravariant.$fNumOp_$cfromInteger_closure:
         const Data.Functor.Contravariant.$fNumOp_$cfromInteger_info;
 },
 x_sgjQJ_entry() //  [R1]
         { info_tbl: [(cgkQm,
                       label: x_sgjQJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkQm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkQn; else goto cgkQo;
       cgkQn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkQo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjQL_entry() //  [R1]
         { info_tbl: [(cgkQu,
                       label: sat_sgjQL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkQu: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fNumOp_$cfromInteger_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cgkQx,
                       label: Data.Functor.Contravariant.$fNumOp_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkQx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgkQB; else goto cgkQA;
       cgkQB: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fNumOp_$cfromInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkQA: // global
           I64[Hp - 40] = x_sgjQJ_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sgjQL_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.660711132 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp_closure" {
     Data.Functor.Contravariant.$fNumOp_closure:
         const Data.Functor.Contravariant.$fNumOp_info;
         const 0;
 },
 sat_sgjQT_entry() //  [R1, R2]
         { info_tbl: [(cgkQL,
                       label: sat_sgjQT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkQL: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fNumOp_$cfromInteger_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQS_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkQT,
                       label: sat_sgjQS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkQT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fNumOp1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQR_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkR1,
                       label: sat_sgjQR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkR1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fNumOp2_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQQ_entry() //  [R1, R2]
         { info_tbl: [(cgkR9,
                       label: sat_sgjQQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkR9: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fNumOp_$cnegate_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQP_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkRh,
                       label: sat_sgjQP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkRh: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fNumOp3_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQO_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkRp,
                       label: sat_sgjQO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkRp: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fNumOp4_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQN_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkRx,
                       label: sat_sgjQN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkRx: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fNumOp5_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fNumOp_entry() //  [R2]
         { info_tbl: [(cgkRB,
                       label: Data.Functor.Contravariant.$fNumOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkRB: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto cgkRF; else goto cgkRE;
       cgkRF: // global
           HpAlloc = 176;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fNumOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkRE: // global
           I64[Hp - 168] = sat_sgjQT_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sgjQS_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sgjQR_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sgjQQ_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgjQP_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgjQO_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgjQN_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 69;
           P64[Hp - 40] = Hp - 85;
           P64[Hp - 32] = Hp - 101;
           P64[Hp - 24] = Hp - 119;
           P64[Hp - 16] = Hp - 134;
           P64[Hp - 8] = Hp - 150;
           P64[Hp] = Hp - 167;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.663159598 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure" {
     Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure:
         const Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_info;
         const 0;
 },
 sat_sgjQV_entry() //  [R1]
         { info_tbl: [(cgkRO,
                       label: sat_sgjQV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkRO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkRP; else goto cgkRQ;
       cgkRP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkRQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_entry() //  [R2]
         { info_tbl: [(cgkRR,
                       label: Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkRR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgkRV; else goto cgkRU;
       cgkRV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkRU: // global
           I64[Hp - 16] = sat_sgjQV_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Contravariant.$fNumOp_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.664813569 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp_closure" {
     Data.Functor.Contravariant.$fFractionalOp_closure:
         const Data.Functor.Contravariant.$fFractionalOp_info;
         const 0;
 },
 sat_sgjR0_entry() //  [R1, R2]
         { info_tbl: [(cgkS5,
                       label: sat_sgjR0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkS5: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFractionalOp_$cfromRational_entry(R3,
                                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkSd,
                       label: sat_sgjQZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkSd: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFractionalOp1_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkSl,
                       label: sat_sgjQY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkSl: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fFractionalOp2_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQX_entry() //  [R1]
         { info_tbl: [(cgkSs,
                       label: sat_sgjQX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkSs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkSt; else goto cgkSu;
       cgkSt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkSu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFractionalOp_entry() //  [R2]
         { info_tbl: [(cgkSw,
                       label: Data.Functor.Contravariant.$fFractionalOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkSw: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgkSA; else goto cgkSz;
       cgkSA: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFractionalOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkSz: // global
           I64[Hp - 104] = sat_sgjR0_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgjQZ_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgjQY_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgjQX_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 69;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.666919592 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_info;
         const 0;
 },
 sat_sgjR2_entry() //  [R1]
         { info_tbl: [(cgkSJ,
                       label: sat_sgjR2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkSJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkSK; else goto cgkSL;
       cgkSK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkSL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_entry() //  [R2]
         { info_tbl: [(cgkSM,
                       label: Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkSM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgkSQ; else goto cgkSP;
       cgkSQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkSP: // global
           I64[Hp - 16] = sat_sgjR2_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Contravariant.$fFractionalOp_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.670790988 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_closure" {
     Data.Functor.Contravariant.$fFloatingOp_closure:
         const Data.Functor.Contravariant.$fFloatingOp_info;
         const 0;
 },
 lvl7_sgjR4_entry() //  [R1]
         { info_tbl: [(cgkSZ,
                       label: lvl7_sgjR4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkSZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkT0; else goto cgkT1;
       cgkT0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkT1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.pi_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjRs_entry() //  [R1, R2]
         { info_tbl: [(cgkT7,
                       label: sat_sgjRs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkT7: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRr_entry() //  [R1, R2]
         { info_tbl: [(cgkTf,
                       label: sat_sgjRr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkTf: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRq_entry() //  [R1, R2]
         { info_tbl: [(cgkTn,
                       label: sat_sgjRq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkTn: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$cexpm1_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRp_entry() //  [R1, R2]
         { info_tbl: [(cgkTv,
                       label: sat_sgjRp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkTv: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$clog1p_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRo_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkTD,
                       label: sat_sgjRo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkTD: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp1_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRn_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkTL,
                       label: sat_sgjRn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkTL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRm_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkTT,
                       label: sat_sgjRm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkTT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp3_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRl_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkU1,
                       label: sat_sgjRl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkU1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp4_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRk_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkU9,
                       label: sat_sgjRk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkU9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp5_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRj_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkUh,
                       label: sat_sgjRj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkUh: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp6_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRi_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkUp,
                       label: sat_sgjRi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkUp: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp7_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRh_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkUx,
                       label: sat_sgjRh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkUx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp8_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRg_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkUF,
                       label: sat_sgjRg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkUF: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp9_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRf_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkUN,
                       label: sat_sgjRf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkUN: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp10_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRe_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkUV,
                       label: sat_sgjRe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkUV: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp11_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRd_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkV3,
                       label: sat_sgjRd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkV3: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp12_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRc_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkVb,
                       label: sat_sgjRc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkVb: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fFloatingOp13_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRb_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgkVj,
                       label: sat_sgjRb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkVj: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fFloatingOp14_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRa_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkVr,
                       label: sat_sgjRa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkVr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp15_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjR9_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkVz,
                       label: sat_sgjR9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkVz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp16_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjR8_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkVH,
                       label: sat_sgjR8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkVH: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp17_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjR7_entry() //  [R1]
         { info_tbl: [(cgkVP,
                       label: sat_sgjR7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkVP: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjR5_entry() //  [R1]
         { info_tbl: [(cgkVW,
                       label: sat_sgjR5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkVW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkVX; else goto cgkVY;
       cgkVX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkVY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_entry() //  [R2]
         { info_tbl: [(cgkW0,
                       label: Data.Functor.Contravariant.$fFloatingOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkW0: // global
           Hp = Hp + 592;
           if (Hp > HpLim) (likely: False) goto cgkW4; else goto cgkW3;
       cgkW4: // global
           HpAlloc = 592;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkW3: // global
           I64[Hp - 584] = lvl7_sgjR4_info;
           P64[Hp - 568] = R2;
           I64[Hp - 560] = sat_sgjRs_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_sgjRr_info;
           P64[Hp - 536] = R2;
           I64[Hp - 528] = sat_sgjRq_info;
           P64[Hp - 520] = R2;
           I64[Hp - 512] = sat_sgjRp_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_sgjRo_info;
           P64[Hp - 488] = R2;
           I64[Hp - 480] = sat_sgjRn_info;
           P64[Hp - 472] = R2;
           I64[Hp - 464] = sat_sgjRm_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_sgjRl_info;
           P64[Hp - 440] = R2;
           I64[Hp - 432] = sat_sgjRk_info;
           P64[Hp - 424] = R2;
           I64[Hp - 416] = sat_sgjRj_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_sgjRi_info;
           P64[Hp - 392] = R2;
           I64[Hp - 384] = sat_sgjRh_info;
           P64[Hp - 376] = R2;
           I64[Hp - 368] = sat_sgjRg_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_sgjRf_info;
           P64[Hp - 344] = R2;
           I64[Hp - 336] = sat_sgjRe_info;
           P64[Hp - 328] = R2;
           I64[Hp - 320] = sat_sgjRd_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_sgjRc_info;
           P64[Hp - 296] = R2;
           I64[Hp - 288] = sat_sgjRb_info;
           P64[Hp - 280] = R2;
           I64[Hp - 272] = sat_sgjRa_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_sgjR9_info;
           P64[Hp - 248] = R2;
           I64[Hp - 240] = sat_sgjR8_info;
           P64[Hp - 232] = R2;
           I64[Hp - 224] = sat_sgjR7_info;
           P64[Hp - 216] = Hp - 584;
           I64[Hp - 208] = sat_sgjR5_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = GHC.Float.C:Floating_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 223;
           P64[Hp - 160] = Hp - 238;
           P64[Hp - 152] = Hp - 254;
           P64[Hp - 144] = Hp - 270;
           P64[Hp - 136] = Hp - 285;
           P64[Hp - 128] = Hp - 301;
           P64[Hp - 120] = Hp - 318;
           P64[Hp - 112] = Hp - 334;
           P64[Hp - 104] = Hp - 350;
           P64[Hp - 96] = Hp - 366;
           P64[Hp - 88] = Hp - 382;
           P64[Hp - 80] = Hp - 398;
           P64[Hp - 72] = Hp - 414;
           P64[Hp - 64] = Hp - 430;
           P64[Hp - 56] = Hp - 446;
           P64[Hp - 48] = Hp - 462;
           P64[Hp - 40] = Hp - 478;
           P64[Hp - 32] = Hp - 494;
           P64[Hp - 24] = Hp - 511;
           P64[Hp - 16] = Hp - 527;
           P64[Hp - 8] = Hp - 543;
           P64[Hp] = Hp - 559;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.676475496 UTC

[section ""data" . Data.Functor.Contravariant.$fCategoryTYPEOp1_closure" {
     Data.Functor.Contravariant.$fCategoryTYPEOp1_closure:
         const Data.Functor.Contravariant.$fCategoryTYPEOp1_info;
 },
 Data.Functor.Contravariant.$fCategoryTYPEOp1_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cgkW9,
                       label: Data.Functor.Contravariant.$fCategoryTYPEOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkW9: // global
           R4 = R4;
           _sgjRu::P64 = R3;
           R3 = R2;
           R2 = _sgjRu::P64;
           call GHC.Base.._entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.677218346 UTC

[section ""data" . Data.Functor.Contravariant.$fCategoryTYPEOp_closure" {
     Data.Functor.Contravariant.$fCategoryTYPEOp_closure:
         const Control.Category.C:Category_con_info;
         const GHC.Base.id_closure+1;
         const Data.Functor.Contravariant.$fCategoryTYPEOp1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.677930601 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence3_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence3_closure:
         const Data.Functor.Contravariant.$fMonoidEquivalence3_info;
 },
 Data.Functor.Contravariant.$fMonoidEquivalence3_entry() //  []
         { info_tbl: [(cgkWg,
                       label: Data.Functor.Contravariant.$fMonoidEquivalence3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkWg: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.679463595 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence1_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence1_closure:
         const Data.Functor.Contravariant.$fSemigroupEquivalence1_info;
 },
 ds_sgjRC_entry() //  [R1]
         { info_tbl: [(cgkWx,
                       label: ds_sgjRC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkWx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkWy; else goto cgkWz;
       cgkWy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkWz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fSemigroupEquivalence1_entry(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjRG_entry() //  [R1, R2, R3]
         { info_tbl: [(cgkWL,
                       label: sat_sgjRG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkWL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkWM; else goto cgkWN;
       cgkWM: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkWN: // global
           I64[Sp - 32] = block_cgkWF_info;
           _sgjRE::P64 = R3;
           R3 = R3;
           _sgjRD::P64 = R2;
           R2 = R2;
           _sgjRC::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _sgjRC::P64;
           P64[Sp - 16] = _sgjRD::P64;
           P64[Sp - 8] = _sgjRE::P64;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkWF() //  [R1]
         { info_tbl: [(cgkWF,
                       label: block_cgkWF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkWF: // global
           if (R1 & 7 == 1) goto cgkWI; else goto cgkWJ;
       cgkWI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkWJ: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupEquivalence1_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cgkWY,
                       label: Data.Functor.Contravariant.$fSemigroupEquivalence1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkWY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkWZ; else goto cgkX0;
       cgkWZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupEquivalence1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkX0: // global
           I64[Sp - 16] = block_cgkWn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugkX6; else goto cgkWo;
       ugkX6: // global
           call _cgkWn(R1) args: 0, res: 0, upd: 0;
       cgkWo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkWn() //  [R1]
         { info_tbl: [(cgkWn,
                       label: block_cgkWn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkWn: // global
           _sgjRx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgkWV; else goto cgkWW;
       cgkWV: // global
           R1 = _sgjRx::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgkWW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgkX5; else goto cgkX4;
       cgkX5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgkX4: // global
           _sgjRA::P64 = P64[R1 + 6];
           _sgjRB::P64 = P64[R1 + 14];
           I64[Hp - 48] = ds_sgjRC_info;
           P64[Hp - 32] = _sgjRA::P64;
           P64[Hp - 24] = _sgjRB::P64;
           I64[Hp - 16] = sat_sgjRG_info;
           P64[Hp - 8] = _sgjRx::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.681681811 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure:
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_info;
 },
 Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_entry() //  [R2]
         { info_tbl: [(cgkXe,
                       label: Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkXe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgkXf; else goto cgkXg;
       cgkXf: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkXg: // global
           I64[Sp - 8] = block_cgkXb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugkXk; else goto cgkXc;
       ugkXk: // global
           call _cgkXb(R1) args: 0, res: 0, upd: 0;
       cgkXc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkXb() //  [R1]
         { info_tbl: [(cgkXb,
                       label: block_cgkXb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkXb: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Contravariant.$fSemigroupEquivalence1_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.682950082 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence2_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence2_closure:
         const Data.Functor.Contravariant.$fMonoidEquivalence2_info;
 },
 Data.Functor.Contravariant.$fMonoidEquivalence2_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cgkXv,
                       label: Data.Functor.Contravariant.$fMonoidEquivalence2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkXv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkXw; else goto cgkXx;
       cgkXw: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidEquivalence2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkXx: // global
           I64[Sp - 32] = block_cgkXp_info;
           _sgjRM::P64 = R3;
           R3 = R5;
           _sgjRL::P64 = R2;
           R2 = R4;
           R1 = _sgjRL::P64;
           P64[Sp - 24] = _sgjRM::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkXp() //  [R1]
         { info_tbl: [(cgkXp,
                       label: block_cgkXp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkXp: // global
           if (R1 & 7 == 1) goto cgkXs; else goto cgkXt;
       cgkXs: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkXt: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.684150489 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Functor.Contravariant.$fMonoidEquivalence2_closure+4;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure+1;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_closure:
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_info;
         const 0;
 },
 Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_entry() //  [R2]
         { info_tbl: [(cgkXI,
                       label: Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkXI: // global
           R3 = Data.Functor.Contravariant.$fSemigroupEquivalence_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.685477623 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence1_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence1_closure:
         const Data.Functor.Contravariant.$fMonoidEquivalence1_info;
 },
 Data.Functor.Contravariant.$fMonoidEquivalence1_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cgkXW,
                       label: Data.Functor.Contravariant.$fMonoidEquivalence1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkXW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgkXX; else goto ugkYh;
       cgkXX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidEquivalence1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ugkYh: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cgkXM() args: 0, res: 0, upd: 0;
     }
 },
 _cgkXM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkXM: // global
           _sgjRR::P64 = P64[Sp];
           I64[Sp] = block_cgkXP_info;
           R1 = _sgjRR::P64;
           if (R1 & 7 != 0) goto ugkYj; else goto cgkXQ;
       ugkYj: // global
           call _cgkXP(R1) args: 0, res: 0, upd: 0;
       cgkXQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkXP() //  [R1]
         { info_tbl: [(cgkXP,
                       label: block_cgkXP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkXP: // global
           if (R1 & 7 == 1) goto cgkXT; else goto cgkXU;
       cgkXT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkXU: // global
           I64[Sp - 8] = block_cgkY4_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           _sgjRW::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sgjRW::P64;
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkY4() //  [R1]
         { info_tbl: [(cgkY4,
                       label: block_cgkY4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkY4: // global
           if (R1 & 7 == 1) goto cgkYb; else goto cgkYf;
       cgkYb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkYf: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cgkXM() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.686916851 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_closure+1;
         const Data.Functor.Contravariant.$fMonoidEquivalence3_closure+2;
         const Data.Functor.Contravariant.$fMonoidEquivalence2_closure+4;
         const Data.Functor.Contravariant.$fMonoidEquivalence1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.687618848 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate3_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate3_closure:
         const Data.Functor.Contravariant.$fMonoidPredicate3_info;
 },
 Data.Functor.Contravariant.$fMonoidPredicate3_entry() //  []
         { info_tbl: [(cgkYq,
                       label: Data.Functor.Contravariant.$fMonoidPredicate3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkYq: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.689019336 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate1_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate1_closure:
         const Data.Functor.Contravariant.$fSemigroupPredicate1_info;
 },
 ds_sgjS4_entry() //  [R1]
         { info_tbl: [(cgkYH,
                       label: ds_sgjS4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkYH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkYI; else goto cgkYJ;
       cgkYI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkYJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fSemigroupPredicate1_entry(R3,
                                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjS7_entry() //  [R1, R2]
         { info_tbl: [(cgkYV,
                       label: sat_sgjS7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkYV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgkYW; else goto cgkYX;
       cgkYW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkYX: // global
           I64[Sp - 24] = block_cgkYP_info;
           _sgjS5::P64 = R2;
           R2 = R2;
           _sgjS4::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sgjS4::P64;
           P64[Sp - 8] = _sgjS5::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkYP() //  [R1]
         { info_tbl: [(cgkYP,
                       label: block_cgkYP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkYP: // global
           if (R1 & 7 == 1) goto cgkYS; else goto cgkYT;
       cgkYS: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkYT: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupPredicate1_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cgkZ8,
                       label: Data.Functor.Contravariant.$fSemigroupPredicate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkZ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkZ9; else goto cgkZa;
       cgkZ9: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupPredicate1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkZa: // global
           I64[Sp - 16] = block_cgkYx_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugkZg; else goto cgkYy;
       ugkZg: // global
           call _cgkYx(R1) args: 0, res: 0, upd: 0;
       cgkYy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkYx() //  [R1]
         { info_tbl: [(cgkYx,
                       label: block_cgkYx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkYx: // global
           _sgjRZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgkZ5; else goto cgkZ6;
       cgkZ5: // global
           R1 = _sgjRZ::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgkZ6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgkZf; else goto cgkZe;
       cgkZf: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgkZe: // global
           _sgjS2::P64 = P64[R1 + 6];
           _sgjS3::P64 = P64[R1 + 14];
           I64[Hp - 48] = ds_sgjS4_info;
           P64[Hp - 32] = _sgjS2::P64;
           P64[Hp - 24] = _sgjS3::P64;
           I64[Hp - 16] = sat_sgjS7_info;
           P64[Hp - 8] = _sgjRZ::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.691207701 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure:
         const Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_info;
 },
 Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_entry() //  [R2]
         { info_tbl: [(cgkZo,
                       label: Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkZo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgkZp; else goto cgkZq;
       cgkZp: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgkZq: // global
           I64[Sp - 8] = block_cgkZl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugkZu; else goto cgkZm;
       ugkZu: // global
           call _cgkZl(R1) args: 0, res: 0, upd: 0;
       cgkZm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkZl() //  [R1]
         { info_tbl: [(cgkZl,
                       label: block_cgkZl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkZl: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Contravariant.$fSemigroupPredicate1_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.692476597 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate2_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate2_closure:
         const Data.Functor.Contravariant.$fMonoidPredicate2_info;
 },
 Data.Functor.Contravariant.$fMonoidPredicate2_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgkZF,
                       label: Data.Functor.Contravariant.$fMonoidPredicate2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkZF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgkZG; else goto cgkZH;
       cgkZG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidPredicate2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkZH: // global
           I64[Sp - 24] = block_cgkZz_info;
           _sgjSc::P64 = R2;
           R2 = R4;
           R1 = _sgjSc::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkZz() //  [R1]
         { info_tbl: [(cgkZz,
                       label: block_cgkZz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkZz: // global
           if (R1 & 7 == 1) goto cgkZC; else goto cgkZD;
       cgkZC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgkZD: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.693772585 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Functor.Contravariant.$fMonoidPredicate2_closure+3;
         const Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure+1;
         const Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_closure:
         const Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_info;
         const 0;
 },
 Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_entry() //  [R2]
         { info_tbl: [(cgkZS,
                       label: Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkZS: // global
           R3 = Data.Functor.Contravariant.$fSemigroupPredicate_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.695063475 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate1_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate1_closure:
         const Data.Functor.Contravariant.$fMonoidPredicate1_info;
 },
 Data.Functor.Contravariant.$fMonoidPredicate1_entry() //  [R2, R3]
         { info_tbl: [(cgl06,
                       label: Data.Functor.Contravariant.$fMonoidPredicate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl06: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgl07; else goto ugl0r;
       cgl07: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidPredicate1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ugl0r: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cgkZW() args: 0, res: 0, upd: 0;
     }
 },
 _cgkZW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkZW: // global
           _sgjSh::P64 = P64[Sp];
           I64[Sp] = block_cgkZZ_info;
           R1 = _sgjSh::P64;
           if (R1 & 7 != 0) goto ugl0t; else goto cgl00;
       ugl0t: // global
           call _cgkZZ(R1) args: 0, res: 0, upd: 0;
       cgl00: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgkZZ() //  [R1]
         { info_tbl: [(cgkZZ,
                       label: block_cgkZZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkZZ: // global
           if (R1 & 7 == 1) goto cgl03; else goto cgl04;
       cgl03: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgl04: // global
           I64[Sp - 8] = block_cgl0e_info;
           R2 = P64[Sp + 8];
           _sgjSl::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sgjSl::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgl0e() //  [R1]
         { info_tbl: [(cgl0e,
                       label: block_cgl0e_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl0e: // global
           if (R1 & 7 == 1) goto cgl0l; else goto cgl0p;
       cgl0l: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgl0p: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cgkZW() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.696484429 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fSemigroupPredicate_closure+1;
         const Data.Functor.Contravariant.$fMonoidPredicate3_closure+1;
         const Data.Functor.Contravariant.$fMonoidPredicate2_closure+3;
         const Data.Functor.Contravariant.$fMonoidPredicate1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.697227613 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_info;
 },
 Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_entry() //  []
         { info_tbl: [(cgl0A,
                       label: Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl0A: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.697979416 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProxy_closure" {
     Data.Functor.Contravariant.$fContravariantProxy_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_closure+2;
         const Data.Functor.Contravariant.$fContravariantProxy_$c>$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.698937684 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantCompose2_closure" {
     Data.Functor.Contravariant.$fContravariantCompose2_closure:
         const Data.Functor.Contravariant.$fContravariantCompose2_info;
 },
 sat_sgjSt_entry() //  [R1]
         { info_tbl: [(cgl0L,
                       label: sat_sgjSt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl0L: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgl0M; else goto cgl0N;
       cgl0M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgl0N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantCompose2_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgl0O,
                       label: Data.Functor.Contravariant.$fContravariantCompose2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl0O: // global
           _sgjSs::P64 = R5;
           _sgjSr::P64 = R4;
           _sgjSq::P64 = R3;
           _sgjSp::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgl0P; else goto cgl0Q;
       cgl0Q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgl0S; else goto cgl0R;
       cgl0S: // global
           HpAlloc = 32;
           goto cgl0P;
       cgl0P: // global
           R5 = _sgjSs::P64;
           R4 = _sgjSr::P64;
           R3 = _sgjSq::P64;
           R2 = _sgjSp::P64;
           R1 = Data.Functor.Contravariant.$fContravariantCompose2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl0R: // global
           I64[Hp - 24] = sat_sgjSt_info;
           P64[Hp - 8] = _sgjSq::P64;
           P64[Hp] = _sgjSr::P64;
           R2 = _sgjSp::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgjSs::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.700578818 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantCompose_closure" {
     Data.Functor.Contravariant.$fContravariantCompose_closure:
         const Data.Functor.Contravariant.$fContravariantCompose_info;
 },
 sat_sgjSx_entry() //  [R1, R2, R3]
         { info_tbl: [(cgl12,
                       label: sat_sgjSx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl12: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantCompose1_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjSw_entry() //  [R1, R2, R3]
         { info_tbl: [(cgl1a,
                       label: sat_sgjSw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl1a: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantCompose2_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantCompose_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cgl1e,
                       label: Data.Functor.Contravariant.$fContravariantCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl1e: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgl1i; else goto cgl1h;
       cgl1i: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl1h: // global
           I64[Hp - 64] = sat_sgjSx_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjSw_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.702099176 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantConst2_closure" {
     Data.Functor.Contravariant.$fContravariantConst2_closure:
         const Data.Functor.Contravariant.$fContravariantConst2_info;
 },
 Data.Functor.Contravariant.$fContravariantConst2_entry() //  [R3]
         { info_tbl: [(cgl1n,
                       label: Data.Functor.Contravariant.$fContravariantConst2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl1n: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.7028115 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantConst_closure" {
     Data.Functor.Contravariant.$fContravariantConst_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantConst2_closure+2;
         const Data.Functor.Contravariant.$fContravariantConst1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.704023209 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_info;
 },
 sat_sgjSI_entry() //  [R1]
         { info_tbl: [(cgl1D,
                       label: sat_sgjSI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl1D: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgl1E; else goto cgl1F;
       cgl1E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgl1F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjSH_entry() //  [R1]
         { info_tbl: [(cgl1K,
                       label: sat_sgjSH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl1K: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgl1L; else goto cgl1M;
       cgl1L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgl1M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_entry() //  [R2,
                                                                            R3, R4, R5]
         { info_tbl: [(cgl1N,
                       label: Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl1N: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgl1P; else goto cgl1Q;
       cgl1P: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl1Q: // global
           I64[Sp - 32] = block_cgl1u_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugl1U; else goto cgl1v;
       ugl1U: // global
           call _cgl1u(R1) args: 0, res: 0, upd: 0;
       cgl1v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgl1u() //  [R1]
         { info_tbl: [(cgl1u,
                       label: block_cgl1u_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl1u: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgl1T; else goto cgl1S;
       cgl1T: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgl1S: // global
           _sgjSF::P64 = P64[R1 + 7];
           _sgjSG::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgjSI_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sgjSC::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sgjSC::P64;
           P64[Hp - 64] = _sgjSG::P64;
           I64[Hp - 56] = sat_sgjSH_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgjSC::P64;
           P64[Hp - 24] = _sgjSF::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.706312122 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProduct_closure" {
     Data.Functor.Contravariant.$fContravariantProduct_closure:
         const Data.Functor.Contravariant.$fContravariantProduct_info;
 },
 sat_sgjSM_entry() //  [R1, R2, R3]
         { info_tbl: [(cgl24,
                       label: sat_sgjSM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl24: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantProduct_$c>$_entry(R5,
                                                                             R4,
                                                                             R3,
                                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjSL_entry() //  [R1, R2, R3]
         { info_tbl: [(cgl2c,
                       label: sat_sgjSL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl2c: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_entry(R5,
                                                                                    R4,
                                                                                    R3,
                                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantProduct_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cgl2g,
                       label: Data.Functor.Contravariant.$fContravariantProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl2g: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgl2k; else goto cgl2j;
       cgl2k: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl2j: // global
           I64[Hp - 64] = sat_sgjSM_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjSL_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.708357578 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantSum_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantSum_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantSum_$ccontramap_info;
 },
 sat_sgjST_entry() //  [R1]
         { info_tbl: [(cgl2y,
                       label: sat_sgjST_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl2y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgl2z; else goto cgl2A;
       cgl2z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgl2A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjSV_entry() //  [R1]
         { info_tbl: [(cgl2H,
                       label: sat_sgjSV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl2H: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgl2I; else goto cgl2J;
       cgl2I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgl2J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantSum_$ccontramap_entry() //  [R2,
                                                                        R3, R4, R5]
         { info_tbl: [(cgl2O,
                       label: Data.Functor.Contravariant.$fContravariantSum_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl2O: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgl2P; else goto cgl2Q;
       cgl2P: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantSum_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl2Q: // global
           I64[Sp - 32] = block_cgl2p_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugl2Z; else goto cgl2q;
       ugl2Z: // global
           call _cgl2p(R1) args: 0, res: 0, upd: 0;
       cgl2q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgl2p() //  [R1]
         { info_tbl: [(cgl2p,
                       label: block_cgl2p_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl2p: // global
           _sgjSP::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cgl2L; else goto cgl2M;
       cgl2L: // global
           Hp = Hp + 56;
           _sgjSR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgl2Y; else goto cgl2T;
       cgl2T: // global
           _sgjSS::P64 = P64[_sgjSR::P64 + 7];
           I64[Hp - 48] = sat_sgjST_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgjSP::P64;
           P64[Hp - 16] = _sgjSS::P64;
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgl2M: // global
           Hp = Hp + 56;
           _sgjSR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgl2Y; else goto cgl2X;
       cgl2Y: // global
           HpAlloc = 56;
           R1 = _sgjSR::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgl2X: // global
           _sgjSU::P64 = P64[_sgjSR::P64 + 6];
           I64[Hp - 48] = sat_sgjSV_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sgjSP::P64;
           P64[Hp - 16] = _sgjSU::P64;
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.71063095 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantSum_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantSum_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantSum_$c>$_info;
 },
 sat_sgjT1_entry() //  [R1]
         { info_tbl: [(cgl39,
                       label: sat_sgjT1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl39: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantSum_$c>$_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgl3c,
                       label: Data.Functor.Contravariant.$fContravariantSum_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl3c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgl3g; else goto cgl3f;
       cgl3g: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantSum_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl3f: // global
           I64[Hp - 8] = sat_sgjT1_info;
           P64[Hp] = R4;
           R5 = R5;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Contravariant.$fContravariantSum_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.712066635 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantSum_closure" {
     Data.Functor.Contravariant.$fContravariantSum_closure:
         const Data.Functor.Contravariant.$fContravariantSum_info;
 },
 sat_sgjT5_entry() //  [R1, R2, R3]
         { info_tbl: [(cgl3q,
                       label: sat_sgjT5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl3q: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantSum_$c>$_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjT4_entry() //  [R1, R2, R3]
         { info_tbl: [(cgl3y,
                       label: sat_sgjT4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl3y: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantSum_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantSum_entry() //  [R2, R3]
         { info_tbl: [(cgl3C,
                       label: Data.Functor.Contravariant.$fContravariantSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl3C: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgl3G; else goto cgl3F;
       cgl3G: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl3F: // global
           I64[Hp - 64] = sat_sgjT5_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjT4_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.714314052 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_info;
 },
 sat_sgjTc_entry() //  [R1]
         { info_tbl: [(cgl3U,
                       label: sat_sgjTc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl3U: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgl3V; else goto cgl3W;
       cgl3V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgl3W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjTe_entry() //  [R1]
         { info_tbl: [(cgl43,
                       label: sat_sgjTe_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl43: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgl44; else goto cgl45;
       cgl44: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgl45: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_entry() //  [R2,
                                                                        R3, R4, R5]
         { info_tbl: [(cgl4a,
                       label: Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl4a: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgl4b; else goto cgl4c;
       cgl4b: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl4c: // global
           I64[Sp - 32] = block_cgl3L_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugl4l; else goto cgl3M;
       ugl4l: // global
           call _cgl3L(R1) args: 0, res: 0, upd: 0;
       cgl3M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgl3L() //  [R1]
         { info_tbl: [(cgl3L,
                       label: block_cgl3L_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl3L: // global
           _sgjT8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cgl47; else goto cgl48;
       cgl47: // global
           Hp = Hp + 56;
           _sgjTa::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgl4k; else goto cgl4f;
       cgl4f: // global
           _sgjTb::P64 = P64[_sgjTa::P64 + 7];
           I64[Hp - 48] = sat_sgjTc_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgjT8::P64;
           P64[Hp - 16] = _sgjTb::P64;
           I64[Hp - 8] = GHC.Generics.L1_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgl48: // global
           Hp = Hp + 56;
           _sgjTa::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgl4k; else goto cgl4j;
       cgl4k: // global
           HpAlloc = 56;
           R1 = _sgjTa::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgl4j: // global
           _sgjTd::P64 = P64[_sgjTa::P64 + 6];
           I64[Hp - 48] = sat_sgjTe_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sgjT8::P64;
           P64[Hp - 16] = _sgjTd::P64;
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.716470656 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:+:_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariant:+:_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariant:+:_$c>$_info;
 },
 sat_sgjTk_entry() //  [R1]
         { info_tbl: [(cgl4v,
                       label: sat_sgjTk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl4v: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:+:_$c>$_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgl4y,
                       label: Data.Functor.Contravariant.$fContravariant:+:_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl4y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgl4C; else goto cgl4B;
       cgl4C: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:+:_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl4B: // global
           I64[Hp - 8] = sat_sgjTk_info;
           P64[Hp] = R4;
           R5 = R5;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.717883927 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:+:_closure" {
     Data.Functor.Contravariant.$fContravariant:+:_closure:
         const Data.Functor.Contravariant.$fContravariant:+:_info;
 },
 sat_sgjTo_entry() //  [R1, R2, R3]
         { info_tbl: [(cgl4M,
                       label: sat_sgjTo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl4M: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:+:_$c>$_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjTn_entry() //  [R1, R2, R3]
         { info_tbl: [(cgl4U,
                       label: sat_sgjTn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl4U: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:+:_entry() //  [R2, R3]
         { info_tbl: [(cgl4Y,
                       label: Data.Functor.Contravariant.$fContravariant:+:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl4Y: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgl52; else goto cgl51;
       cgl52: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:+:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl51: // global
           I64[Hp - 64] = sat_sgjTo_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjTn_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.719484989 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:.:2_closure" {
     Data.Functor.Contravariant.$fContravariant:.:2_closure:
         const Data.Functor.Contravariant.$fContravariant:.:2_info;
 },
 sat_sgjTt_entry() //  [R1]
         { info_tbl: [(cgl5b,
                       label: sat_sgjTt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl5b: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgl5c; else goto cgl5d;
       cgl5c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgl5d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:.:2_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cgl5e,
                       label: Data.Functor.Contravariant.$fContravariant:.:2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl5e: // global
           _sgjTs::P64 = R5;
           _sgjTr::P64 = R4;
           _sgjTq::P64 = R3;
           _sgjTp::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgl5f; else goto cgl5g;
       cgl5g: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgl5i; else goto cgl5h;
       cgl5i: // global
           HpAlloc = 32;
           goto cgl5f;
       cgl5f: // global
           R5 = _sgjTs::P64;
           R4 = _sgjTr::P64;
           R3 = _sgjTq::P64;
           R2 = _sgjTp::P64;
           R1 = Data.Functor.Contravariant.$fContravariant:.:2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl5h: // global
           I64[Hp - 24] = sat_sgjTt_info;
           P64[Hp - 8] = _sgjTq::P64;
           P64[Hp] = _sgjTr::P64;
           R2 = _sgjTp::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgjTs::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.721167388 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:.:_closure" {
     Data.Functor.Contravariant.$fContravariant:.:_closure:
         const Data.Functor.Contravariant.$fContravariant:.:_info;
 },
 sat_sgjTx_entry() //  [R1, R2, R3]
         { info_tbl: [(cgl5s,
                       label: sat_sgjTx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl5s: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:.:1_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjTw_entry() //  [R1, R2, R3]
         { info_tbl: [(cgl5A,
                       label: sat_sgjTw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl5A: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:.:2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:.:_entry() //  [R2, R3]
         { info_tbl: [(cgl5E,
                       label: Data.Functor.Contravariant.$fContravariant:.:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl5E: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgl5I; else goto cgl5H;
       cgl5I: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:.:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl5H: // global
           I64[Hp - 64] = sat_sgjTx_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjTw_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.723095882 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_info;
 },
 sat_sgjTG_entry() //  [R1]
         { info_tbl: [(cgl5W,
                       label: sat_sgjTG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl5W: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgl5X; else goto cgl5Y;
       cgl5X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgl5Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjTF_entry() //  [R1]
         { info_tbl: [(cgl63,
                       label: sat_sgjTF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl63: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgl64; else goto cgl65;
       cgl64: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgl65: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_entry() //  [R2,
                                                                        R3, R4, R5]
         { info_tbl: [(cgl66,
                       label: Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl66: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgl68; else goto cgl69;
       cgl68: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl69: // global
           I64[Sp - 32] = block_cgl5N_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugl6d; else goto cgl5O;
       ugl6d: // global
           call _cgl5N(R1) args: 0, res: 0, upd: 0;
       cgl5O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgl5N() //  [R1]
         { info_tbl: [(cgl5N,
                       label: block_cgl5N_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl5N: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgl6c; else goto cgl6b;
       cgl6c: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgl6b: // global
           _sgjTD::P64 = P64[R1 + 7];
           _sgjTE::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgjTG_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sgjTA::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sgjTA::P64;
           P64[Hp - 64] = _sgjTE::P64;
           I64[Hp - 56] = sat_sgjTF_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgjTA::P64;
           P64[Hp - 24] = _sgjTD::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.725521594 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:*:_closure" {
     Data.Functor.Contravariant.$fContravariant:*:_closure:
         const Data.Functor.Contravariant.$fContravariant:*:_info;
 },
 sat_sgjTK_entry() //  [R1, R2, R3]
         { info_tbl: [(cgl6n,
                       label: sat_sgjTK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl6n: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:*:_$c>$_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjTJ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgl6v,
                       label: sat_sgjTJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl6v: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:*:_entry() //  [R2, R3]
         { info_tbl: [(cgl6z,
                       label: Data.Functor.Contravariant.$fContravariant:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl6z: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgl6D; else goto cgl6C;
       cgl6D: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl6C: // global
           I64[Hp - 64] = sat_sgjTK_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjTJ_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.726890957 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantK3_closure" {
     Data.Functor.Contravariant.$fContravariantK3_closure:
         const Data.Functor.Contravariant.$fContravariantK3_info;
 },
 Data.Functor.Contravariant.$fContravariantK3_entry() //  [R3]
         { info_tbl: [(cgl6I,
                       label: Data.Functor.Contravariant.$fContravariantK3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl6I: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.727582019 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantK1_closure" {
     Data.Functor.Contravariant.$fContravariantK1_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantK3_closure+2;
         const Data.Functor.Contravariant.$fContravariantK2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.728278351 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantU1_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantU1_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantU1_$ccontramap_info;
 },
 Data.Functor.Contravariant.$fContravariantU1_$ccontramap_entry() //  []
         { info_tbl: [(cgl6P,
                       label: Data.Functor.Contravariant.$fContravariantU1_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl6P: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.731354471 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantU1_closure" {
     Data.Functor.Contravariant.$fContravariantU1_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantU1_$ccontramap_closure+2;
         const Data.Functor.Contravariant.$fContravariantU1_$c>$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.732071478 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantV1_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantV1_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantV1_$ccontramap_info;
 },
 Data.Functor.Contravariant.$fContravariantV1_$ccontramap_entry() //  [R3]
         { info_tbl: [(cgl6W,
                       label: Data.Functor.Contravariant.$fContravariantV1_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl6W: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.732805633 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantV1_closure" {
     Data.Functor.Contravariant.$fContravariantV1_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantV1_$ccontramap_closure+2;
         const Data.Functor.Contravariant.$fContravariantV1_$c>$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.733674258 UTC

[section ""data" . lvl2_rgjLt_closure" {
     lvl2_rgjLt_closure:
         const lvl2_rgjLt_info;
         const 0;
 },
 lvl2_rgjLt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgl74,
                       label: lvl2_rgjLt_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl74: // global
           _sgjTV::P64 = R5;
           _sgjTU::P64 = R4;
           _sgjTT::P64 = R3;
           _sgjTS::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgl75; else goto cgl76;
       cgl76: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgl78; else goto cgl77;
       cgl78: // global
           HpAlloc = 32;
           goto cgl75;
       cgl75: // global
           R5 = _sgjTV::P64;
           R4 = _sgjTU::P64;
           R3 = _sgjTT::P64;
           R2 = _sgjTS::P64;
           R1 = lvl2_rgjLt_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl77: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjTU::P64;
           P64[Hp] = _sgjTV::P64;
           R2 = _sgjTS::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgjTT::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.$fSemigroupOrdering_$cstimes_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.73493548 UTC

[section ""data" . lvl3_rgjLu_closure" {
     lvl3_rgjLu_closure:
         const lvl3_rgjLu_info;
         const 0;
 },
 lvl3_rgjLu_entry() //  [R2]
         { info_tbl: [(cgl7g,
                       label: lvl3_rgjLu_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl7g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgl7h; else goto cgl7i;
       cgl7h: // global
           R2 = R2;
           R1 = lvl3_rgjLu_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgl7i: // global
           I64[Sp - 8] = block_cgl7d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugl7m; else goto cgl7e;
       ugl7m: // global
           call _cgl7d(R1) args: 0, res: 0, upd: 0;
       cgl7e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgl7d() //  [R1]
         { info_tbl: [(cgl7d,
                       label: block_cgl7d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl7d: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = GHC.Base.$fSemigroupOrdering_closure;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.736233432 UTC

[section ""data" . lvl4_rgjLv_closure" {
     lvl4_rgjLv_closure:
         const lvl4_rgjLv_info;
 },
 lvl4_rgjLv_entry() //  [R2, R3, R4]
         { info_tbl: [(cgl7y,
                       label: lvl4_rgjLv_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl7y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgl7z; else goto cgl7A;
       cgl7z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl4_rgjLv_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl7A: // global
           I64[Sp - 24] = block_cgl7r_info;
           _sgjU1::P64 = R2;
           R2 = R4;
           R1 = _sgjU1::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgl7r() //  [R1]
         { info_tbl: [(cgl7r,
                       label: block_cgl7r_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl7r: // global
           _cgl7x::P64 = R1 & 7;
           if (_cgl7x::P64 < 3) goto ugl7K; else goto cgl7w;
       ugl7K: // global
           if (_cgl7x::P64 < 2) goto cgl7u; else goto cgl7v;
       cgl7u: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgl7v: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cgl7w: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.737390705 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure" {
     Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure:
         const GHC.Base.C:Semigroup_con_info;
         const lvl4_rgjLv_closure+3;
         const lvl3_rgjLu_closure+1;
         const lvl2_rgjLt_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.738341968 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison2_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison2_closure:
         const Data.Functor.Contravariant.$fSemigroupComparison2_info;
         const 0;
 },
 Data.Functor.Contravariant.$fSemigroupComparison2_entry() //  [R2]
         { info_tbl: [(cgl7S,
                       label: Data.Functor.Contravariant.$fSemigroupComparison2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl7S: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgl7T; else goto cgl7U;
       cgl7T: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupComparison2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgl7U: // global
           I64[Sp - 8] = block_cgl7P_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugl7Y; else goto cgl7Q;
       ugl7Y: // global
           call _cgl7P(R1) args: 0, res: 0, upd: 0;
       cgl7Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgl7P() //  [R1]
         { info_tbl: [(cgl7P,
                       label: block_cgl7P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl7P: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure+1;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.73955587 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Functor.Contravariant.$fSemigroupComparison3_closure+3;
         const Data.Functor.Contravariant.$fSemigroupComparison2_closure+1;
         const Data.Functor.Contravariant.$fSemigroupComparison1_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.740262595 UTC

[section ""data" . lvl5_rgjLw_closure" {
     lvl5_rgjLw_closure:
         const lvl5_rgjLw_info;
 },
 lvl5_rgjLw_entry() //  []
         { info_tbl: [(cgl83,
                       label: lvl5_rgjLw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl83: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.741164469 UTC

[section ""data" . lvl6_rgjLx_closure" {
     lvl6_rgjLx_closure:
         const lvl6_rgjLx_info;
         const 0;
 },
 lvl6_rgjLx_entry() //  [R2, R3]
         { info_tbl: [(cgl8a,
                       label: lvl6_rgjLx_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl8a: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.$fMonoidOrdering_closure;
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.742095309 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure" {
     Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure+1;
         const lvl5_rgjLw_closure+1;
         const lvl4_rgjLv_closure+3;
         const lvl6_rgjLx_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.742838062 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison1_closure" {
     Data.Functor.Contravariant.$fMonoidComparison1_closure:
         const Data.Functor.Contravariant.$fMonoidComparison1_info;
         const 0;
 },
 Data.Functor.Contravariant.$fMonoidComparison1_entry() //  [R2, R3]
         { info_tbl: [(cgl8h,
                       label: Data.Functor.Contravariant.$fMonoidComparison1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl8h: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure+1;
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.743568691 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison_closure" {
     Data.Functor.Contravariant.$fMonoidComparison_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fSemigroupComparison_closure+1;
         const Data.Functor.Contravariant.$fMonoidComparison3_closure+2;
         const Data.Functor.Contravariant.$fMonoidComparison2_closure+3;
         const Data.Functor.Contravariant.$fMonoidComparison1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.744351734 UTC

[section ""data" . Data.Functor.Contravariant.C:Contravariant_closure" {
     Data.Functor.Contravariant.C:Contravariant_closure:
         const Data.Functor.Contravariant.C:Contravariant_info;
 },
 Data.Functor.Contravariant.C:Contravariant_entry() //  [R2, R3]
         { info_tbl: [(cgl8p,
                       label: Data.Functor.Contravariant.C:Contravariant_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl8p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgl8t; else goto cgl8s;
       cgl8t: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.C:Contravariant_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgl8s: // global
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.745289592 UTC

[Data.Functor.Contravariant.C:Contravariant_con_entry() //  [R1]
         { info_tbl: [(cgl8u,
                       label: Data.Functor.Contravariant.C:Contravariant_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,110,116,114,97,118,97,114,105,97,110,116,46,67,58,67,111,110,116,114,97,118,97,114,105,97,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl8u: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.745970756 UTC

[section ""relreadonly" . Sgk42_srt" {
     Sgk42_srt:
         const GHC.Base.$fSemigroupOrdering_$cstimes_closure;
         const Data.Functor.Contravariant.$fSemigroupComparison1_closure;
         const sat_sgjO7_closure;
         const lvl1_rgjLs_closure;
         const lvl_rgjLr_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure;
         const Data.Functor.Contravariant.$fNumOp_$cnegate_closure;
         const Data.Functor.Contravariant.$fNumOp_closure;
         const Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure;
         const Data.Functor.Contravariant.$fFractionalOp_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure;
         const Data.Functor.Contravariant.$fFloatingOp_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_closure;
         const Data.Functor.Contravariant.$fSemigroupPredicate_closure;
         const lvl2_rgjLt_closure;
         const GHC.Base.$fSemigroupOrdering_closure;
         const lvl3_rgjLu_closure;
         const Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure;
         const Data.Functor.Contravariant.$fSemigroupComparison2_closure;
         const GHC.Base.$fMonoidOrdering_closure;
         const Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.746925566 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:13.748275229 UTC

[section ""data" . Data.Functor.Contravariant.contramap_closure" {
     Data.Functor.Contravariant.contramap_closure:
         const Data.Functor.Contravariant.contramap_info;
 },
 Data.Functor.Contravariant.contramap_entry() //  [R2]
         { info_tbl: [(cgl8D,
                       label: Data.Functor.Contravariant.contramap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl8D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgl8E; else goto cgl8F;
       cgl8E: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.contramap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgl8F: // global
           I64[Sp - 8] = block_cgl8A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugl8J; else goto cgl8B;
       ugl8J: // global
           call _cgl8A(R1) args: 0, res: 0, upd: 0;
       cgl8B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgl8A() //  [R1]
         { info_tbl: [(cgl8A,
                       label: block_cgl8A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl8A: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.753980858 UTC

[section ""data" . Data.Functor.Contravariant.>$_closure" {
     Data.Functor.Contravariant.>$_closure:
         const Data.Functor.Contravariant.>$_info;
 },
 Data.Functor.Contravariant.>$_entry() //  [R2]
         { info_tbl: [(cgl90,
                       label: Data.Functor.Contravariant.>$_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl90: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgl91; else goto cgl92;
       cgl91: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.>$_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgl92: // global
           I64[Sp - 8] = block_cgl8X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugl96; else goto cgl8Y;
       ugl96: // global
           call _cgl8X(R1) args: 0, res: 0, upd: 0;
       cgl8Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgl8X() //  [R1]
         { info_tbl: [(cgl8X,
                       label: block_cgl8X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgl8X: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.759187519 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Op3_bytes" {
     Data.Functor.Contravariant.$tc'Op3_bytes:
         I8[] [39,79,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.760879417 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Op2_closure" {
     Data.Functor.Contravariant.$tc'Op2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Op3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.762580347 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcOp2_bytes" {
     Data.Functor.Contravariant.$tcOp2_bytes:
         I8[] [79,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.765761548 UTC

[section ""data" . Data.Functor.Contravariant.$tcOp1_closure" {
     Data.Functor.Contravariant.$tcOp1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcOp2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.767498402 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Equivalence3_bytes" {
     Data.Functor.Contravariant.$tc'Equivalence3_bytes:
         I8[] [39,69,113,117,105,118,97,108,101,110,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.769209645 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Equivalence2_closure" {
     Data.Functor.Contravariant.$tc'Equivalence2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Equivalence3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.770886281 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcEquivalence2_bytes" {
     Data.Functor.Contravariant.$tcEquivalence2_bytes:
         I8[] [69,113,117,105,118,97,108,101,110,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.772554134 UTC

[section ""data" . Data.Functor.Contravariant.$tcEquivalence1_closure" {
     Data.Functor.Contravariant.$tcEquivalence1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcEquivalence2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.774372899 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Comparison3_bytes" {
     Data.Functor.Contravariant.$tc'Comparison3_bytes:
         I8[] [39,67,111,109,112,97,114,105,115,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.776029828 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Comparison2_closure" {
     Data.Functor.Contravariant.$tc'Comparison2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Comparison3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.777755461 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcComparison2_bytes" {
     Data.Functor.Contravariant.$tcComparison2_bytes:
         I8[] [67,111,109,112,97,114,105,115,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.779422692 UTC

[section ""data" . Data.Functor.Contravariant.$tcComparison1_closure" {
     Data.Functor.Contravariant.$tcComparison1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcComparison2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.78117056 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Predicate3_bytes" {
     Data.Functor.Contravariant.$tc'Predicate3_bytes:
         I8[] [39,80,114,101,100,105,99,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.783025763 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Predicate2_closure" {
     Data.Functor.Contravariant.$tc'Predicate2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Predicate3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.784817099 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcPredicate2_bytes" {
     Data.Functor.Contravariant.$tcPredicate2_bytes:
         I8[] [80,114,101,100,105,99,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.786543027 UTC

[section ""data" . Data.Functor.Contravariant.$tcPredicate1_closure" {
     Data.Functor.Contravariant.$tcPredicate1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcPredicate2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.788257744 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcContravariant3_bytes" {
     Data.Functor.Contravariant.$tcContravariant3_bytes:
         I8[] [67,111,110,116,114,97,118,97,114,105,97,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.790319578 UTC

[section ""data" . Data.Functor.Contravariant.$tcContravariant2_closure" {
     Data.Functor.Contravariant.$tcContravariant2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcContravariant3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.792669788 UTC

[section ""data" . $krep_rgjLa_closure" {
     $krep_rgjLa_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.794330388 UTC

[section ""data" . $krep1_rgjLb_closure" {
     $krep1_rgjLb_closure:
         const :_con_info;
         const $krep_rgjLa_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.796068569 UTC

[section ""data" . $krep2_rgjLc_closure" {
     $krep2_rgjLc_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.79781971 UTC

[section ""data" . $krep3_rgjLd_closure" {
     $krep3_rgjLd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rgjLc_closure+2;
         const $krep_rgjLa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.799565427 UTC

[section ""data" . $krep4_rgjLe_closure" {
     $krep4_rgjLe_closure:
         const :_con_info;
         const $krep2_rgjLc_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.801269065 UTC

[section ""data" . $krep5_rgjLf_closure" {
     $krep5_rgjLf_closure:
         const :_con_info;
         const $krep_rgjLa_closure+2;
         const $krep4_rgjLe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.8030041 UTC

[section ""data" . $krep6_rgjLg_closure" {
     $krep6_rgjLg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.804760064 UTC

[section ""data" . $krep7_rgjLh_closure" {
     $krep7_rgjLh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep6_rgjLg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.806953178 UTC

[section ""data" . $krep8_rgjLi_closure" {
     $krep8_rgjLi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep7_rgjLh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.808582141 UTC

[section ""data" . $krep9_rgjLj_closure" {
     $krep9_rgjLj_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcOrdering_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.810397243 UTC

[section ""data" . $krep10_rgjLk_closure" {
     $krep10_rgjLk_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep9_rgjLj_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.812129159 UTC

[section ""data" . $krep11_rgjLl_closure" {
     $krep11_rgjLl_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep10_rgjLk_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.813908148 UTC

[section ""data" . $krep12_rgjLm_closure" {
     $krep12_rgjLm_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.815646848 UTC

[section ""data" . Data.Functor.Contravariant.$tcContravariant1_closure" {
     Data.Functor.Contravariant.$tcContravariant1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep12_rgjLm_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.817981596 UTC

[section ""cstring" . Data.Functor.Contravariant.$trModule2_bytes" {
     Data.Functor.Contravariant.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,110,116,114,97,118,97,114,105,97,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.819659532 UTC

[section ""data" . Data.Functor.Contravariant.$trModule1_closure" {
     Data.Functor.Contravariant.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.821680833 UTC

[section ""cstring" . Data.Functor.Contravariant.$trModule4_bytes" {
     Data.Functor.Contravariant.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.82335008 UTC

[section ""data" . Data.Functor.Contravariant.$trModule3_closure" {
     Data.Functor.Contravariant.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.824995275 UTC

[section ""data" . Data.Functor.Contravariant.$trModule_closure" {
     Data.Functor.Contravariant.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Contravariant.$trModule3_closure+1;
         const Data.Functor.Contravariant.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.82675335 UTC

[section ""data" . Data.Functor.Contravariant.$tcContravariant_closure" {
     Data.Functor.Contravariant.$tcContravariant_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcContravariant2_closure+1;
         const Data.Functor.Contravariant.$tcContravariant1_closure+4;
         const 1944710495430526909;
         const 15571985404928937498;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.8286484 UTC

[section ""data" . Data.Functor.Contravariant.$tcPredicate_closure" {
     Data.Functor.Contravariant.$tcPredicate_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcPredicate1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 9927645946720114643;
         const 17478425232619398566;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.830516501 UTC

[section ""data" . $krep13_rgjLn_closure" {
     $krep13_rgjLn_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcPredicate_closure+1;
         const $krep1_rgjLb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.832248988 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Predicate1_closure" {
     Data.Functor.Contravariant.$tc'Predicate1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rgjLh_closure+4;
         const $krep13_rgjLn_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.834473568 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Predicate_closure" {
     Data.Functor.Contravariant.$tc'Predicate_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Predicate2_closure+1;
         const Data.Functor.Contravariant.$tc'Predicate1_closure+4;
         const 10560326927625189840;
         const 8988710799443424590;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.836248075 UTC

[section ""data" . Data.Functor.Contravariant.$tcComparison_closure" {
     Data.Functor.Contravariant.$tcComparison_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcComparison1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 8128667979445988110;
         const 9034904213662261762;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.83809585 UTC

[section ""data" . $krep14_rgjLo_closure" {
     $krep14_rgjLo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcComparison_closure+1;
         const $krep1_rgjLb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.839739177 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Comparison1_closure" {
     Data.Functor.Contravariant.$tc'Comparison1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_rgjLl_closure+4;
         const $krep14_rgjLo_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.841491785 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Comparison_closure" {
     Data.Functor.Contravariant.$tc'Comparison_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Comparison2_closure+1;
         const Data.Functor.Contravariant.$tc'Comparison1_closure+4;
         const 11047345948274903716;
         const 12707949450550295743;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.843831051 UTC

[section ""data" . Data.Functor.Contravariant.$tcEquivalence_closure" {
     Data.Functor.Contravariant.$tcEquivalence_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcEquivalence1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 9646573079009549553;
         const 12303965936368510845;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.846128483 UTC

[section ""data" . $krep15_rgjLp_closure" {
     $krep15_rgjLp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcEquivalence_closure+1;
         const $krep1_rgjLb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.847818813 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Equivalence1_closure" {
     Data.Functor.Contravariant.$tc'Equivalence1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rgjLi_closure+4;
         const $krep15_rgjLp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.849578821 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Equivalence_closure" {
     Data.Functor.Contravariant.$tc'Equivalence_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Equivalence2_closure+1;
         const Data.Functor.Contravariant.$tc'Equivalence1_closure+4;
         const 5667737350508967909;
         const 15093804341312440267;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.851437311 UTC

[section ""data" . Data.Functor.Contravariant.$tcOp_closure" {
     Data.Functor.Contravariant.$tcOp_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcOp1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 13209106975460307324;
         const 7546944290236364550;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.853223827 UTC

[section ""data" . $krep16_rgjLq_closure" {
     $krep16_rgjLq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcOp_closure+1;
         const $krep5_rgjLf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.855262844 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Op1_closure" {
     Data.Functor.Contravariant.$tc'Op1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rgjLd_closure+4;
         const $krep16_rgjLq_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.856902279 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Op_closure" {
     Data.Functor.Contravariant.$tc'Op_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Op2_closure+1;
         const Data.Functor.Contravariant.$tc'Op1_closure+4;
         const 12479862397628491530;
         const 1381176546464080972;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.859123018 UTC

[section ""data" . Data.Functor.Contravariant.comparisonEquivalence1_closure" {
     Data.Functor.Contravariant.comparisonEquivalence1_closure:
         const Data.Functor.Contravariant.comparisonEquivalence1_info;
 },
 Data.Functor.Contravariant.comparisonEquivalence1_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cglai,
                       label: Data.Functor.Contravariant.comparisonEquivalence1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglai: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cglaj; else goto cglak;
       cglaj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.comparisonEquivalence1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglak: // global
           I64[Sp - 8] = block_cglac_info;
           _sgjLI::P64 = R3;
           R3 = R4;
           _sgjLH::P64 = R2;
           R2 = _sgjLI::P64;
           R1 = _sgjLH::P64;
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglac() //  [R1]
         { info_tbl: [(cglac,
                       label: block_cglac_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglac: // global
           if (R1 & 7 == 2) goto cglag; else goto cglaf;
       cglag: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cglaf: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.864797196 UTC

[section ""data" . Data.Functor.Contravariant.comparisonEquivalence_closure" {
     Data.Functor.Contravariant.comparisonEquivalence_closure:
         const Data.Functor.Contravariant.comparisonEquivalence_info;
 },
 Data.Functor.Contravariant.comparisonEquivalence_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cglaH,
                       label: Data.Functor.Contravariant.comparisonEquivalence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglaH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Contravariant.comparisonEquivalence1_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.868096952 UTC

[section ""data" . Data.Functor.Contravariant.defaultEquivalence_closure" {
     Data.Functor.Contravariant.defaultEquivalence_closure:
         const Data.Functor.Contravariant.defaultEquivalence_info;
 },
 Data.Functor.Contravariant.defaultEquivalence_entry() //  [R2]
         { info_tbl: [(cglaS,
                       label: Data.Functor.Contravariant.defaultEquivalence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglaS: // global
           R2 = R2;
           call GHC.Classes.==_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.87187171 UTC

[section ""data" . Data.Functor.Contravariant.defaultComparison_closure" {
     Data.Functor.Contravariant.defaultComparison_closure:
         const Data.Functor.Contravariant.defaultComparison_info;
 },
 Data.Functor.Contravariant.defaultComparison_entry() //  [R2]
         { info_tbl: [(cglb3,
                       label: Data.Functor.Contravariant.defaultComparison_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglb3: // global
           R2 = R2;
           call GHC.Classes.compare_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.875700965 UTC

[section ""data" . Data.Functor.Contravariant.>$$<_closure" {
     Data.Functor.Contravariant.>$$<_closure:
         const Data.Functor.Contravariant.>$$<_info;
 },
 Data.Functor.Contravariant.>$$<_entry() //  [R2, R3, R4]
         { info_tbl: [(cglbe,
                       label: Data.Functor.Contravariant.>$$<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglbe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cglbf; else goto cglbg;
       cglbf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.>$$<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglbg: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.879486156 UTC

[section ""data" . Data.Functor.Contravariant.>$<_closure" {
     Data.Functor.Contravariant.>$<_closure:
         const Data.Functor.Contravariant.>$<_info;
 },
 Data.Functor.Contravariant.>$<_entry() //  [R2]
         { info_tbl: [(cglbq,
                       label: Data.Functor.Contravariant.>$<_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglbq: // global
           R2 = R2;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.882951429 UTC

[section ""data" . Data.Functor.Contravariant.phantom_closure" {
     Data.Functor.Contravariant.phantom_closure:
         const Data.Functor.Contravariant.phantom_info;
 },
 sat_sgjLS_entry() //  [R1]
         { info_tbl: [(cglbF,
                       label: sat_sgjLS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglbF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cglbG; else goto cglbH;
       cglbG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglbH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Tuple.()_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.<$_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.phantom_entry() //  [R2, R3, R4]
         { info_tbl: [(cglbI,
                       label: Data.Functor.Contravariant.phantom_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglbI: // global
           _sgjLR::P64 = R4;
           _sgjLQ::P64 = R3;
           _sgjLP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cglbJ; else goto cglbK;
       cglbK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglbM; else goto cglbL;
       cglbM: // global
           HpAlloc = 32;
           goto cglbJ;
       cglbJ: // global
           R4 = _sgjLR::P64;
           R3 = _sgjLQ::P64;
           R2 = _sgjLP::P64;
           R1 = Data.Functor.Contravariant.phantom_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglbL: // global
           I64[Hp - 24] = sat_sgjLS_info;
           P64[Hp - 8] = _sgjLP::P64;
           P64[Hp] = _sgjLR::P64;
           R2 = _sgjLQ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = GHC.Tuple.()_closure+1;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Functor.Contravariant.>$_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.889383586 UTC

[section ""data" . Data.Functor.Contravariant.$<_closure" {
     Data.Functor.Contravariant.$<_closure:
         const Data.Functor.Contravariant.$<_info;
 },
 Data.Functor.Contravariant.$<_entry() //  [R2, R3, R4]
         { info_tbl: [(cglc2,
                       label: Data.Functor.Contravariant.$<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglc2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cglc3; else goto cglc4;
       cglc3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglc4: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Data.Functor.Contravariant.>$_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.893128112 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantOp1_closure" {
     Data.Functor.Contravariant.$fContravariantOp1_closure:
         const Data.Functor.Contravariant.$fContravariantOp1_info;
 },
 Data.Functor.Contravariant.$fContravariantOp1_entry() //  [R2, R3]
         { info_tbl: [(cglce,
                       label: Data.Functor.Contravariant.$fContravariantOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglce: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.896367375 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantOp2_closure" {
     Data.Functor.Contravariant.$fContravariantOp2_closure:
         const Data.Functor.Contravariant.$fContravariantOp2_info;
 },
 Data.Functor.Contravariant.$fContravariantOp2_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cglcp,
                       label: Data.Functor.Contravariant.$fContravariantOp2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglcp: // global
           R4 = R4;
           _sgjM0::P64 = R3;
           R3 = R2;
           R2 = _sgjM0::P64;
           call GHC.Base.._entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.900060311 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantOp_closure" {
     Data.Functor.Contravariant.$fContravariantOp_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantOp2_closure+3;
         const Data.Functor.Contravariant.$fContravariantOp1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.901989007 UTC

[section ""data" . Data.Functor.Contravariant.getOp1_closure" {
     Data.Functor.Contravariant.getOp1_closure:
         const Data.Functor.Contravariant.getOp1_info;
 },
 Data.Functor.Contravariant.getOp1_entry() //  [R2]
         { info_tbl: [(cglcB,
                       label: Data.Functor.Contravariant.getOp1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglcB: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.905945013 UTC

[section ""data" . Data.Functor.Contravariant.getOp_closure" {
     Data.Functor.Contravariant.getOp_closure:
         const Data.Functor.Contravariant.getOp_info;
 },
 Data.Functor.Contravariant.getOp_entry() //  [R2]
         { info_tbl: [(cglcM,
                       label: Data.Functor.Contravariant.getOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglcM: // global
           R2 = R2;
           call Data.Functor.Contravariant.getOp1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.909347318 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantEquivalence1_closure" {
     Data.Functor.Contravariant.$fContravariantEquivalence1_closure:
         const Data.Functor.Contravariant.$fContravariantEquivalence1_info;
 },
 Data.Functor.Contravariant.$fContravariantEquivalence1_entry() //  [R2,
                                                                     R3]
         { info_tbl: [(cglcX,
                       label: Data.Functor.Contravariant.$fContravariantEquivalence1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglcX: // global
           _sgjM3::P64 = R3;
           R3 = R2;
           R2 = R2;
           R1 = _sgjM3::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.912727199 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantEquivalence2_closure" {
     Data.Functor.Contravariant.$fContravariantEquivalence2_closure:
         const Data.Functor.Contravariant.$fContravariantEquivalence2_info;
 },
 Data.Functor.Contravariant.$fContravariantEquivalence2_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cglda,
                       label: Data.Functor.Contravariant.$fContravariantEquivalence2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglda: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cglde; else goto cgldd;
       cglde: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantEquivalence2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgldd: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _sgjM7::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 24;
           R1 = _sgjM7::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.916877889 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantEquivalence_closure" {
     Data.Functor.Contravariant.$fContravariantEquivalence_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantEquivalence2_closure+4;
         const Data.Functor.Contravariant.$fContravariantEquivalence1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.918794246 UTC

[section ""data" . Data.Functor.Contravariant.getEquivalence1_closure" {
     Data.Functor.Contravariant.getEquivalence1_closure:
         const Data.Functor.Contravariant.getEquivalence1_info;
 },
 Data.Functor.Contravariant.getEquivalence1_entry() //  [R2]
         { info_tbl: [(cgldo,
                       label: Data.Functor.Contravariant.getEquivalence1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgldo: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.922118818 UTC

[section ""data" . Data.Functor.Contravariant.getEquivalence_closure" {
     Data.Functor.Contravariant.getEquivalence_closure:
         const Data.Functor.Contravariant.getEquivalence_info;
 },
 Data.Functor.Contravariant.getEquivalence_entry() //  [R2]
         { info_tbl: [(cgldz,
                       label: Data.Functor.Contravariant.getEquivalence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgldz: // global
           R2 = R2;
           call Data.Functor.Contravariant.getEquivalence1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.925294585 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantComparison1_closure" {
     Data.Functor.Contravariant.$fContravariantComparison1_closure:
         const Data.Functor.Contravariant.$fContravariantComparison1_info;
 },
 Data.Functor.Contravariant.$fContravariantComparison1_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cgldK,
                       label: Data.Functor.Contravariant.$fContravariantComparison1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgldK: // global
           _sgjMe::P64 = R3;
           R3 = R2;
           R2 = R2;
           R1 = _sgjMe::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.928764537 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantComparison2_closure" {
     Data.Functor.Contravariant.$fContravariantComparison2_closure:
         const Data.Functor.Contravariant.$fContravariantComparison2_info;
 },
 Data.Functor.Contravariant.$fContravariantComparison2_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cgldX,
                       label: Data.Functor.Contravariant.$fContravariantComparison2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgldX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgle1; else goto cgle0;
       cgle1: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantComparison2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgle0: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _sgjMi::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 24;
           R1 = _sgjMi::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.933103935 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantComparison_closure" {
     Data.Functor.Contravariant.$fContravariantComparison_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantComparison2_closure+4;
         const Data.Functor.Contravariant.$fContravariantComparison1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.935550403 UTC

[section ""data" . Data.Functor.Contravariant.getComparison1_closure" {
     Data.Functor.Contravariant.getComparison1_closure:
         const Data.Functor.Contravariant.getComparison1_info;
 },
 Data.Functor.Contravariant.getComparison1_entry() //  [R2]
         { info_tbl: [(cgleb,
                       label: Data.Functor.Contravariant.getComparison1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgleb: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.939168122 UTC

[section ""data" . Data.Functor.Contravariant.getComparison_closure" {
     Data.Functor.Contravariant.getComparison_closure:
         const Data.Functor.Contravariant.getComparison_info;
 },
 Data.Functor.Contravariant.getComparison_entry() //  [R2]
         { info_tbl: [(cglem,
                       label: Data.Functor.Contravariant.getComparison_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglem: // global
           R2 = R2;
           call Data.Functor.Contravariant.getComparison1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.94240235 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantPredicate1_closure" {
     Data.Functor.Contravariant.$fContravariantPredicate1_closure:
         const Data.Functor.Contravariant.$fContravariantPredicate1_info;
 },
 Data.Functor.Contravariant.$fContravariantPredicate1_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cglex,
                       label: Data.Functor.Contravariant.$fContravariantPredicate1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglex: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.945734412 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantPredicate2_closure" {
     Data.Functor.Contravariant.$fContravariantPredicate2_closure:
         const Data.Functor.Contravariant.$fContravariantPredicate2_info;
 },
 Data.Functor.Contravariant.$fContravariantPredicate2_entry() //  [R2,
                                                                   R3, R4]
         { info_tbl: [(cgleI,
                       label: Data.Functor.Contravariant.$fContravariantPredicate2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgleI: // global
           R4 = R4;
           _sgjMs::P64 = R3;
           R3 = R2;
           R2 = _sgjMs::P64;
           call GHC.Base.._entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.948982103 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantPredicate_closure" {
     Data.Functor.Contravariant.$fContravariantPredicate_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantPredicate2_closure+3;
         const Data.Functor.Contravariant.$fContravariantPredicate1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.950850545 UTC

[section ""data" . Data.Functor.Contravariant.getPredicate1_closure" {
     Data.Functor.Contravariant.getPredicate1_closure:
         const Data.Functor.Contravariant.getPredicate1_info;
 },
 Data.Functor.Contravariant.getPredicate1_entry() //  [R2]
         { info_tbl: [(cgleU,
                       label: Data.Functor.Contravariant.getPredicate1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgleU: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.954463168 UTC

[section ""data" . Data.Functor.Contravariant.getPredicate_closure" {
     Data.Functor.Contravariant.getPredicate_closure:
         const Data.Functor.Contravariant.getPredicate_info;
 },
 Data.Functor.Contravariant.getPredicate_entry() //  [R2]
         { info_tbl: [(cglf5,
                       label: Data.Functor.Contravariant.getPredicate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglf5: // global
           R2 = R2;
           call Data.Functor.Contravariant.getPredicate1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.957630912 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantV1_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantV1_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantV1_$c>$_info;
 },
 Data.Functor.Contravariant.$fContravariantV1_$c>$_entry() //  [R3]
         { info_tbl: [(cglfg,
                       label: Data.Functor.Contravariant.$fContravariantV1_$c>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglfg: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.960931714 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantU1_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantU1_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantU1_$c>$_info;
 },
 Data.Functor.Contravariant.$fContravariantU1_$c>$_entry() //  []
         { info_tbl: [(cglft,
                       label: Data.Functor.Contravariant.$fContravariantU1_$c>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglft: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.964819055 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantK2_closure" {
     Data.Functor.Contravariant.$fContravariantK2_closure:
         const Data.Functor.Contravariant.$fContravariantK2_info;
 },
 Data.Functor.Contravariant.$fContravariantK2_entry() //  [R3]
         { info_tbl: [(cglfF,
                       label: Data.Functor.Contravariant.$fContravariantK2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglfF: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.9692942 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:*:_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariant:*:_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariant:*:_$c>$_info;
 },
 f1_sgjMI_entry() //  [R1]
         { info_tbl: [(cglg0,
                       label: f1_sgjMI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglg0: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjML_entry() //  [R1]
         { info_tbl: [(cglg7,
                       label: sat_sgjML_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglg7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cglg8; else goto cglg9;
       cglg8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglg9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjMK_entry() //  [R1]
         { info_tbl: [(cglge,
                       label: sat_sgjMK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglge: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cglgf; else goto cglgg;
       cglgf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglgg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:*:_$c>$_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cglgh,
                       label: Data.Functor.Contravariant.$fContravariant:*:_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglgh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglgj; else goto cglgk;
       cglgj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:*:_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglgk: // global
           I64[Sp - 32] = block_cglfQ_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uglgo; else goto cglfR;
       uglgo: // global
           call _cglfQ(R1) args: 0, res: 0, upd: 0;
       cglfR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglfQ() //  [R1]
         { info_tbl: [(cglfQ,
                       label: block_cglfQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglfQ: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cglgn; else goto cglgm;
       cglgn: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cglgm: // global
           _sgjMG::P64 = P64[R1 + 7];
           _sgjMH::P64 = P64[R1 + 15];
           I64[Hp - 112] = f1_sgjMI_info;
           P64[Hp - 104] = P64[Sp + 24];
           I64[Hp - 96] = sat_sgjML_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sgjMH::P64;
           _cglfV::P64 = Hp - 111;
           P64[Hp - 64] = _cglfV::P64;
           I64[Hp - 56] = sat_sgjMK_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgjMG::P64;
           P64[Hp - 24] = _cglfV::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.981204891 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:.:1_closure" {
     Data.Functor.Contravariant.$fContravariant:.:1_closure:
         const Data.Functor.Contravariant.$fContravariant:.:1_info;
 },
 sat_sgjMR_entry() //  [R1]
         { info_tbl: [(cglh6,
                       label: sat_sgjMR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglh6: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjMS_entry() //  [R1]
         { info_tbl: [(cglh9,
                       label: sat_sgjMS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglh9: // global
           _sgjMS::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cglha; else goto cglhb;
       cglhb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cglhd; else goto cglhc;
       cglhd: // global
           HpAlloc = 16;
           goto cglha;
       cglha: // global
           R1 = _sgjMS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglhc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjMS::P64;
           _sgjMN::P64 = P64[_sgjMS::P64 + 16];
           _sgjMO::P64 = P64[_sgjMS::P64 + 24];
           I64[Hp - 8] = sat_sgjMR_info;
           P64[Hp] = _sgjMO::P64;
           R2 = _sgjMN::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:.:1_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cglhe,
                       label: Data.Functor.Contravariant.$fContravariant:.:1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglhe: // global
           _sgjMP::P64 = R5;
           _sgjMO::P64 = R4;
           _sgjMN::P64 = R3;
           _sgjMM::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cglhf; else goto cglhg;
       cglhg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglhi; else goto cglhh;
       cglhi: // global
           HpAlloc = 32;
           goto cglhf;
       cglhf: // global
           R5 = _sgjMP::P64;
           R4 = _sgjMO::P64;
           R3 = _sgjMN::P64;
           R2 = _sgjMM::P64;
           R1 = Data.Functor.Contravariant.$fContravariant:.:1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglhh: // global
           I64[Hp - 24] = sat_sgjMS_info;
           P64[Hp - 8] = _sgjMN::P64;
           P64[Hp] = _sgjMO::P64;
           R2 = _sgjMM::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgjMP::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:13.99014767 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProduct_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantProduct_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantProduct_$c>$_info;
 },
 f1_sgjN0_entry() //  [R1]
         { info_tbl: [(cglhL,
                       label: f1_sgjN0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglhL: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjN3_entry() //  [R1]
         { info_tbl: [(cglhS,
                       label: sat_sgjN3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglhS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cglhT; else goto cglhU;
       cglhT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglhU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjN2_entry() //  [R1]
         { info_tbl: [(cglhZ,
                       label: sat_sgjN2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglhZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgli0; else goto cgli1;
       cgli0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgli1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantProduct_$c>$_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cgli2,
                       label: Data.Functor.Contravariant.$fContravariantProduct_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgli2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgli4; else goto cgli5;
       cgli4: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantProduct_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgli5: // global
           I64[Sp - 32] = block_cglhB_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugli9; else goto cglhC;
       ugli9: // global
           call _cglhB(R1) args: 0, res: 0, upd: 0;
       cglhC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglhB() //  [R1]
         { info_tbl: [(cglhB,
                       label: block_cglhB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglhB: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cgli8; else goto cgli7;
       cgli8: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgli7: // global
           _sgjMY::P64 = P64[R1 + 7];
           _sgjMZ::P64 = P64[R1 + 15];
           I64[Hp - 112] = f1_sgjN0_info;
           P64[Hp - 104] = P64[Sp + 24];
           I64[Hp - 96] = sat_sgjN3_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sgjMZ::P64;
           _cglhG::P64 = Hp - 111;
           P64[Hp - 64] = _cglhG::P64;
           I64[Hp - 56] = sat_sgjN2_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgjMY::P64;
           P64[Hp - 24] = _cglhG::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.001896612 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantConst1_closure" {
     Data.Functor.Contravariant.$fContravariantConst1_closure:
         const Data.Functor.Contravariant.$fContravariantConst1_info;
 },
 Data.Functor.Contravariant.$fContravariantConst1_entry() //  [R3]
         { info_tbl: [(cgliI,
                       label: Data.Functor.Contravariant.$fContravariantConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgliI: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.00612747 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantCompose1_closure" {
     Data.Functor.Contravariant.$fContravariantCompose1_closure:
         const Data.Functor.Contravariant.$fContravariantCompose1_info;
 },
 sat_sgjNb_entry() //  [R1]
         { info_tbl: [(cglj2,
                       label: sat_sgjNb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglj2: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNc_entry() //  [R1]
         { info_tbl: [(cglj5,
                       label: sat_sgjNc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglj5: // global
           _sgjNc::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cglj6; else goto cglj7;
       cglj7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cglj9; else goto cglj8;
       cglj9: // global
           HpAlloc = 16;
           goto cglj6;
       cglj6: // global
           R1 = _sgjNc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglj8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjNc::P64;
           _sgjN7::P64 = P64[_sgjNc::P64 + 16];
           _sgjN8::P64 = P64[_sgjNc::P64 + 24];
           I64[Hp - 8] = sat_sgjNb_info;
           P64[Hp] = _sgjN8::P64;
           R2 = _sgjN7::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantCompose1_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cglja,
                       label: Data.Functor.Contravariant.$fContravariantCompose1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglja: // global
           _sgjN9::P64 = R5;
           _sgjN8::P64 = R4;
           _sgjN7::P64 = R3;
           _sgjN6::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgljb; else goto cgljc;
       cgljc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglje; else goto cgljd;
       cglje: // global
           HpAlloc = 32;
           goto cgljb;
       cgljb: // global
           R5 = _sgjN9::P64;
           R4 = _sgjN8::P64;
           R3 = _sgjN7::P64;
           R2 = _sgjN6::P64;
           R1 = Data.Functor.Contravariant.$fContravariantCompose1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgljd: // global
           I64[Hp - 24] = sat_sgjNc_info;
           P64[Hp - 8] = _sgjN7::P64;
           P64[Hp] = _sgjN8::P64;
           R2 = _sgjN6::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgjN9::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.013901265 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProxy_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantProxy_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantProxy_$c>$_info;
 },
 Data.Functor.Contravariant.$fContravariantProxy_$c>$_entry() //  []
         { info_tbl: [(cgljx,
                       label: Data.Functor.Contravariant.$fContravariantProxy_$c>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgljx: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.017406994 UTC

[section ""data" . Data.Functor.Contravariant.$dm>$_closure" {
     Data.Functor.Contravariant.$dm>$_closure:
         const Data.Functor.Contravariant.$dm>$_info;
 },
 sat_sgjNi_entry() //  [R1]
         { info_tbl: [(cgljO,
                       label: sat_sgjNi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgljO: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$dm>$_entry() //  [R2, R3]
         { info_tbl: [(cgljR,
                       label: Data.Functor.Contravariant.$dm>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgljR: // global
           _sgjNg::P64 = R3;
           _sgjNf::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgljS; else goto cgljT;
       cgljT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgljV; else goto cgljU;
       cgljV: // global
           HpAlloc = 16;
           goto cgljS;
       cgljS: // global
           R3 = _sgjNg::P64;
           R2 = _sgjNf::P64;
           R1 = Data.Functor.Contravariant.$dm>$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgljU: // global
           I64[Hp - 8] = sat_sgjNi_info;
           P64[Hp] = _sgjNg::P64;
           R2 = _sgjNf::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.023330103 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupOp_closure" {
     Data.Functor.Contravariant.$fSemigroupOp_closure:
         const Data.Functor.Contravariant.$fSemigroupOp_info;
 },
 sat_sgjNm_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cglke,
                       label: sat_sgjNm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglke: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call GHC.Base.$fSemigroup(->)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNl_entry() //  [R1, R2]
         { info_tbl: [(cglkm,
                       label: sat_sgjNl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglkm: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(->)_$csconcat_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cglku,
                       label: sat_sgjNk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglku: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(->)_$c<>_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupOp_entry() //  [R2]
         { info_tbl: [(cglky,
                       label: Data.Functor.Contravariant.$fSemigroupOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglky: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cglkC; else goto cglkB;
       cglkC: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglkB: // global
           I64[Hp - 72] = sat_sgjNm_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgjNl_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgjNk_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 68;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.032768696 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_closure" {
     Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_closure:
         const Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_info;
 },
 sat_sgjNo_entry() //  [R1]
         { info_tbl: [(cgll2,
                       label: sat_sgjNo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgll2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgll3; else goto cgll4;
       cgll3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgll4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cgll5,
                       label: Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgll5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgll9; else goto cgll8;
       cgll9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgll8: // global
           I64[Hp - 16] = sat_sgjNo_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Contravariant.$fSemigroupOp_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.039370854 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidOp_closure" {
     Data.Functor.Contravariant.$fMonoidOp_closure:
         const Data.Functor.Contravariant.$fMonoidOp_info;
 },
 lvl7_sgjNq_entry() //  [R1]
         { info_tbl: [(cgllq,
                       label: lvl7_sgjNq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgllq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgllr; else goto cglls;
       cgllr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglls: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjNv_entry() //  [R1, R2, R3]
         { info_tbl: [(cglly,
                       label: sat_sgjNv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglly: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNu_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgllG,
                       label: sat_sgjNu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgllG: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoid(->)_$cmappend_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNt_entry() //  [R1]
         { info_tbl: [(cgllO,
                       label: sat_sgjNt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgllO: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjNr_entry() //  [R1]
         { info_tbl: [(cgllV,
                       label: sat_sgjNr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgllV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgllW; else goto cgllX;
       cgllW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgllX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fMonoidOp_entry() //  [R2]
         { info_tbl: [(cgllZ,
                       label: Data.Functor.Contravariant.$fMonoidOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgllZ: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cglm3; else goto cglm2;
       cglm3: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglm2: // global
           I64[Hp - 128] = lvl7_sgjNq_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgjNv_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgjNu_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgjNt_info;
           P64[Hp - 64] = Hp - 128;
           I64[Hp - 56] = sat_sgjNr_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.052277246 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison3_closure" {
     Data.Functor.Contravariant.$fMonoidComparison3_closure:
         const Data.Functor.Contravariant.$fMonoidComparison3_info;
 },
 Data.Functor.Contravariant.$fMonoidComparison3_entry() //  []
         { info_tbl: [(cglmz,
                       label: Data.Functor.Contravariant.$fMonoidComparison3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglmz: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.056133559 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison2_closure" {
     Data.Functor.Contravariant.$fMonoidComparison2_closure:
         const Data.Functor.Contravariant.$fMonoidComparison2_info;
 },
 sat_sgjNF_entry() //  [R1, R2]
         { info_tbl: [(cglmZ,
                       label: sat_sgjNF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglmZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgln0; else goto cgln1;
       cgln0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgln1: // global
           I64[Sp - 24] = block_cglmS_info;
           _sgjND::P64 = R2;
           R2 = R2;
           _sgjNC::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sgjNC::P64;
           P64[Sp - 8] = _sgjND::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglmS() //  [R1]
         { info_tbl: [(cglmS,
                       label: block_cglmS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglmS: // global
           _cglmY::P64 = R1 & 7;
           if (_cglmY::P64 < 3) goto uglnb; else goto cglmX;
       uglnb: // global
           if (_cglmY::P64 < 2) goto cglmV; else goto cglmW;
       cglmV: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cglmW: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cglmX: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fMonoidComparison2_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cglnc,
                       label: Data.Functor.Contravariant.$fMonoidComparison2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglnc: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cglng; else goto cglnf;
       cglng: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidComparison2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglnf: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgjNF_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.064766108 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison3_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison3_closure:
         const Data.Functor.Contravariant.$fSemigroupComparison3_info;
 },
 sat_sgjNN_entry() //  [R1, R2]
         { info_tbl: [(cglnQ,
                       label: sat_sgjNN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglnQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cglnR; else goto cglnS;
       cglnR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglnS: // global
           I64[Sp - 24] = block_cglnJ_info;
           _sgjNL::P64 = R2;
           R2 = R2;
           _sgjNK::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sgjNK::P64;
           P64[Sp - 8] = _sgjNL::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglnJ() //  [R1]
         { info_tbl: [(cglnJ,
                       label: block_cglnJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglnJ: // global
           _cglnP::P64 = R1 & 7;
           if (_cglnP::P64 < 3) goto uglo2; else goto cglnO;
       uglo2: // global
           if (_cglnP::P64 < 2) goto cglnM; else goto cglnN;
       cglnM: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cglnN: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cglnO: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupComparison3_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cglo3,
                       label: Data.Functor.Contravariant.$fSemigroupComparison3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglo3: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cglo7; else goto cglo6;
       cglo7: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupComparison3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglo6: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgjNN_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.0733257 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison1_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison1_closure:
         const Data.Functor.Contravariant.$fSemigroupComparison1_info;
         const 0;
 },
 lvl7_sgjNT_entry() //  [R1]
         { info_tbl: [(cgloy,
                       label: lvl7_sgjNT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgloy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgloz; else goto cgloA;
       cgloz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgloA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupOrdering_$cstimes_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjNW_entry() //  [R1, R2]
         { info_tbl: [(cgloH,
                       label: sat_sgjNW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgloH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgloL; else goto cgloK;
       cgloL: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgloK: // global
           _sgjNP::P64 = P64[R1 + 7];
           _sgjNS::P64 = P64[R1 + 15];
           _sgjNT::P64 = P64[R1 + 23];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjNS::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = _sgjNP::P64;
           R1 = _sgjNT::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupComparison1_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cgloM,
                       label: Data.Functor.Contravariant.$fSemigroupComparison1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgloM: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgloQ; else goto cgloP;
       cgloQ: // global
           HpAlloc = 88;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupComparison1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgloP: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = lvl7_sgjNT_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = sat_sgjNW_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.08243233 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantM1_closure" {
     Data.Functor.Contravariant.$fContravariantM1_closure:
         const Data.Functor.Contravariant.$fContravariantM1_info;
 },
 sat_sgjNZ_entry() //  [R1]
         { info_tbl: [(cglpd,
                       label: sat_sgjNZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglpd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglpe; else goto cglpf;
       cglpe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglpf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.>$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjNY_entry() //  [R1]
         { info_tbl: [(cglpk,
                       label: sat_sgjNY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglpk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglpl; else goto cglpm;
       cglpl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglpm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantM1_entry() //  [R2]
         { info_tbl: [(cglpo,
                       label: Data.Functor.Contravariant.$fContravariantM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglpo: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cglps; else goto cglpr;
       cglps: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglpr: // global
           I64[Hp - 64] = sat_sgjNZ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgjNY_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.090148703 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantRec1_closure" {
     Data.Functor.Contravariant.$fContravariantRec1_closure:
         const Data.Functor.Contravariant.$fContravariantRec1_info;
 },
 sat_sgjO2_entry() //  [R1]
         { info_tbl: [(cglpQ,
                       label: sat_sgjO2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglpQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglpR; else goto cglpS;
       cglpR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglpS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.>$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjO1_entry() //  [R1]
         { info_tbl: [(cglpX,
                       label: sat_sgjO1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglpX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglpY; else goto cglpZ;
       cglpY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglpZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantRec1_entry() //  [R2]
         { info_tbl: [(cglq1,
                       label: Data.Functor.Contravariant.$fContravariantRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglq1: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cglq5; else goto cglq4;
       cglq5: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglq4: // global
           I64[Hp - 64] = sat_sgjO2_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgjO1_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.098297105 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantAlt_closure" {
     Data.Functor.Contravariant.$fContravariantAlt_closure:
         const Data.Functor.Contravariant.$fContravariantAlt_info;
 },
 sat_sgjO5_entry() //  [R1]
         { info_tbl: [(cglqt,
                       label: sat_sgjO5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglqt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglqu; else goto cglqv;
       cglqu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglqv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.>$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjO4_entry() //  [R1]
         { info_tbl: [(cglqA,
                       label: sat_sgjO4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglqA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglqB; else goto cglqC;
       cglqB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglqC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantAlt_entry() //  [R2]
         { info_tbl: [(cglqE,
                       label: Data.Functor.Contravariant.$fContravariantAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglqE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cglqI; else goto cglqH;
       cglqI: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglqH: // global
           I64[Hp - 64] = sat_sgjO5_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgjO4_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.105709714 UTC

[section ""data" . sat_sgjO6_closure" {
     sat_sgjO6_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.107360723 UTC

[section ""data" . sat_sgjO7_closure" {
     sat_sgjO7_closure:
         const :_con_info;
         const sat_sgjO6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.109372578 UTC

[section ""data" . lvl_rgjLr_closure" {
     lvl_rgjLr_closure:
         const lvl_rgjLr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rgjLr_entry() //  [R1]
         { info_tbl: [(cglr6,
                       label: lvl_rgjLr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglr6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglr7; else goto cglr8;
       cglr7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglr8: // global
           (_cglr3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cglr3::I64 == 0) goto cglr5; else goto cglr4;
       cglr5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cglr4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cglr3::I64;
           R3 = sat_sgjO7_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.113447881 UTC

[section ""data" . lvl1_rgjLs_closure" {
     lvl1_rgjLs_closure:
         const lvl1_rgjLs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rgjLs_entry() //  [R1]
         { info_tbl: [(cglrm,
                       label: lvl1_rgjLs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglrm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglrn; else goto cglro;
       cglrn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglro: // global
           (_cglrj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cglrj::I64 == 0) goto cglrl; else goto cglrk;
       cglrl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cglrk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cglrj::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.119223292 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_info;
         const 0;
 },
 $dFractional_sgjOa_entry() //  [R1]
         { info_tbl: [(cglrE,
                       label: $dFractional_sgjOa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglrE: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgjOb_entry() //  [R1]
         { info_tbl: [(cglrL,
                       label: $dNum_sgjOb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglrL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglrM; else goto cglrN;
       cglrM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglrN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgjOc_entry() //  [R1]
         { info_tbl: [(cglrS,
                       label: x_sgjOc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglrS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglrT; else goto cglrU;
       cglrT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglrU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl1_rgjLs_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 x1_sgjOd_entry() //  [R1]
         { info_tbl: [(cglrZ,
                       label: x1_sgjOd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglrZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgls0; else goto cgls1;
       cgls0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgls1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOg_entry() //  [R1]
         { info_tbl: [(cglsk,
                       label: sat_sgjOg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglsk: // global
           _sgjOg::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cglsl; else goto cglsm;
       cglsm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglso; else goto cglsn;
       cglso: // global
           HpAlloc = 32;
           goto cglsl;
       cglsl: // global
           R1 = _sgjOg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglsn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOg::P64;
           _sgjO8::P64 = P64[_sgjOg::P64 + 16];
           _sgjO9::P64 = P64[_sgjOg::P64 + 24];
           _sgjOe::P64 = P64[_sgjOg::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjO9::P64;
           P64[Hp] = _sgjOe::P64;
           R2 = _sgjO8::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Float.exp_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOh_entry() //  [R1]
         { info_tbl: [(cglsp,
                       label: sat_sgjOh_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglsp: // global
           _sgjOh::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cglsq; else goto cglsr;
       cglsr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cglst; else goto cglss;
       cglst: // global
           HpAlloc = 40;
           goto cglsq;
       cglsq: // global
           R1 = _sgjOh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglss: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOh::P64;
           _sgjO8::P64 = P64[_sgjOh::P64 + 16];
           _sgjO9::P64 = P64[_sgjOh::P64 + 24];
           _sgjOb::P64 = P64[_sgjOh::P64 + 32];
           _sgjOc::P64 = P64[_sgjOh::P64 + 40];
           _sgjOe::P64 = P64[_sgjOh::P64 + 48];
           I64[Hp - 32] = sat_sgjOg_info;
           P64[Hp - 16] = _sgjO8::P64;
           P64[Hp - 8] = _sgjO9::P64;
           P64[Hp] = _sgjOe::P64;
           R2 = _sgjOb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgjOc::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjOi_entry() //  [R1]
         { info_tbl: [(cglsu,
                       label: sat_sgjOi_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglsu: // global
           _sgjOi::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cglsv; else goto cglsw;
       cglsw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cglsy; else goto cglsx;
       cglsy: // global
           HpAlloc = 56;
           goto cglsv;
       cglsv: // global
           R1 = _sgjOi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglsx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOi::P64;
           _sgjO8::P64 = P64[_sgjOi::P64 + 16];
           _sgjO9::P64 = P64[_sgjOi::P64 + 24];
           _sgjOb::P64 = P64[_sgjOi::P64 + 32];
           _sgjOc::P64 = P64[_sgjOi::P64 + 40];
           _sgjOd::P64 = P64[_sgjOi::P64 + 48];
           _sgjOe::P64 = P64[_sgjOi::P64 + 56];
           I64[Hp - 48] = sat_sgjOh_info;
           P64[Hp - 32] = _sgjO8::P64;
           P64[Hp - 24] = _sgjO9::P64;
           P64[Hp - 16] = _sgjOb::P64;
           P64[Hp - 8] = _sgjOc::P64;
           P64[Hp] = _sgjOe::P64;
           R2 = _sgjOb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgjOd::P64;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjOj_entry() //  [R1, R2]
         { info_tbl: [(cglsz,
                       label: sat_sgjOj_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglsz: // global
           _sgjOe::P64 = R2;
           _sgjOj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cglsA; else goto cglsB;
       cglsB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cglsD; else goto cglsC;
       cglsD: // global
           HpAlloc = 64;
           goto cglsA;
       cglsA: // global
           R2 = _sgjOe::P64;
           R1 = _sgjOj::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglsC: // global
           _sgjO8::P64 = P64[_sgjOj::P64 + 7];
           _sgjO9::P64 = P64[_sgjOj::P64 + 15];
           _sgjOb::P64 = P64[_sgjOj::P64 + 23];
           _sgjOc::P64 = P64[_sgjOj::P64 + 31];
           _sgjOd::P64 = P64[_sgjOj::P64 + 39];
           I64[Hp - 56] = sat_sgjOi_info;
           P64[Hp - 40] = _sgjO8::P64;
           P64[Hp - 32] = _sgjO9::P64;
           P64[Hp - 24] = _sgjOb::P64;
           P64[Hp - 16] = _sgjOc::P64;
           P64[Hp - 8] = _sgjOd::P64;
           P64[Hp] = _sgjOe::P64;
           R2 = _sgjO8::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cglsE,
                       label: Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglsE: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cglsI; else goto cglsH;
       cglsI: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglsH: // global
           I64[Hp - 136] = $dFractional_sgjOa_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = $dNum_sgjOb_info;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = x_sgjOc_info;
           _cglrH::P64 = Hp - 112;
           P64[Hp - 72] = _cglrH::P64;
           I64[Hp - 64] = x1_sgjOd_info;
           P64[Hp - 48] = _cglrH::P64;
           I64[Hp - 40] = sat_sgjOj_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = _cglrH::P64;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = Hp - 64;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.141023253 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$cexpm1_info;
         const 0;
 },
 $dFractional_sgjOm_entry() //  [R1]
         { info_tbl: [(cglty,
                       label: $dFractional_sgjOm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglty: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgjOn_entry() //  [R1]
         { info_tbl: [(cgltF,
                       label: $dNum_sgjOn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgltF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgltG; else goto cgltH;
       cgltG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgltH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgjOo_entry() //  [R1]
         { info_tbl: [(cgltM,
                       label: x_sgjOo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgltM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgltN; else goto cgltO;
       cgltN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgltO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOr_entry() //  [R1]
         { info_tbl: [(cgltZ,
                       label: sat_sgjOr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgltZ: // global
           _sgjOr::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cglu0; else goto cglu1;
       cglu1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglu3; else goto cglu2;
       cglu3: // global
           HpAlloc = 32;
           goto cglu0;
       cglu0: // global
           R1 = _sgjOr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglu2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOr::P64;
           _sgjOk::P64 = P64[_sgjOr::P64 + 16];
           _sgjOl::P64 = P64[_sgjOr::P64 + 24];
           _sgjOp::P64 = P64[_sgjOr::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOl::P64;
           P64[Hp] = _sgjOp::P64;
           R2 = _sgjOk::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Float.exp_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOs_entry() //  [R1, R2]
         { info_tbl: [(cglu4,
                       label: sat_sgjOs_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglu4: // global
           _sgjOp::P64 = R2;
           _sgjOs::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cglu5; else goto cglu6;
       cglu6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cglu8; else goto cglu7;
       cglu8: // global
           HpAlloc = 40;
           goto cglu5;
       cglu5: // global
           R2 = _sgjOp::P64;
           R1 = _sgjOs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglu7: // global
           _sgjOk::P64 = P64[_sgjOs::P64 + 7];
           _sgjOl::P64 = P64[_sgjOs::P64 + 15];
           _sgjOn::P64 = P64[_sgjOs::P64 + 23];
           _sgjOo::P64 = P64[_sgjOs::P64 + 31];
           I64[Hp - 32] = sat_sgjOr_info;
           P64[Hp - 16] = _sgjOk::P64;
           P64[Hp - 8] = _sgjOl::P64;
           P64[Hp] = _sgjOp::P64;
           R2 = _sgjOn::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sgjOo::P64;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$cexpm1_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cglu9,
                       label: Data.Functor.Contravariant.$fFloatingOp_$cexpm1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglu9: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cglud; else goto cgluc;
       cglud: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgluc: // global
           I64[Hp - 104] = $dFractional_sgjOm_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_sgjOn_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = x_sgjOo_info;
           _cgltB::P64 = Hp - 80;
           P64[Hp - 40] = _cgltB::P64;
           I64[Hp - 32] = sat_sgjOs_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cgltB::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.155852182 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_info;
         const 0;
 },
 $dFractional_sgjOv_entry() //  [R1]
         { info_tbl: [(cgluO,
                       label: $dFractional_sgjOv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgluO: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgjOw_entry() //  [R1]
         { info_tbl: [(cgluV,
                       label: $dNum_sgjOw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgluV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgluW; else goto cgluX;
       cgluW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgluX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgjOx_entry() //  [R1]
         { info_tbl: [(cglv2,
                       label: x_sgjOx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglv2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglv3; else goto cglv4;
       cglv3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglv4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOA_entry() //  [R1]
         { info_tbl: [(cglvj,
                       label: sat_sgjOA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglvj: // global
           _sgjOA::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cglvk; else goto cglvl;
       cglvl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglvn; else goto cglvm;
       cglvn: // global
           HpAlloc = 32;
           goto cglvk;
       cglvk: // global
           R1 = _sgjOA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglvm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOA::P64;
           _sgjOt::P64 = P64[_sgjOA::P64 + 16];
           _sgjOu::P64 = P64[_sgjOA::P64 + 24];
           _sgjOy::P64 = P64[_sgjOA::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOu::P64;
           P64[Hp] = _sgjOy::P64;
           R2 = _sgjOt::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Float.exp_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOB_entry() //  [R1]
         { info_tbl: [(cglvo,
                       label: sat_sgjOB_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglvo: // global
           _sgjOB::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cglvp; else goto cglvq;
       cglvq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cglvs; else goto cglvr;
       cglvs: // global
           HpAlloc = 40;
           goto cglvp;
       cglvp: // global
           R1 = _sgjOB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglvr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOB::P64;
           _sgjOt::P64 = P64[_sgjOB::P64 + 16];
           _sgjOu::P64 = P64[_sgjOB::P64 + 24];
           _sgjOw::P64 = P64[_sgjOB::P64 + 32];
           _sgjOx::P64 = P64[_sgjOB::P64 + 40];
           _sgjOy::P64 = P64[_sgjOB::P64 + 48];
           I64[Hp - 32] = sat_sgjOA_info;
           P64[Hp - 16] = _sgjOt::P64;
           P64[Hp - 8] = _sgjOu::P64;
           P64[Hp] = _sgjOy::P64;
           R2 = _sgjOw::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgjOx::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjOC_entry() //  [R1, R2]
         { info_tbl: [(cglvt,
                       label: sat_sgjOC_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglvt: // global
           _sgjOy::P64 = R2;
           _sgjOC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cglvu; else goto cglvv;
       cglvv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cglvx; else goto cglvw;
       cglvx: // global
           HpAlloc = 56;
           goto cglvu;
       cglvu: // global
           R2 = _sgjOy::P64;
           R1 = _sgjOC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglvw: // global
           _sgjOt::P64 = P64[_sgjOC::P64 + 7];
           _sgjOu::P64 = P64[_sgjOC::P64 + 15];
           _sgjOw::P64 = P64[_sgjOC::P64 + 23];
           _sgjOx::P64 = P64[_sgjOC::P64 + 31];
           I64[Hp - 48] = sat_sgjOB_info;
           P64[Hp - 32] = _sgjOt::P64;
           P64[Hp - 24] = _sgjOu::P64;
           P64[Hp - 16] = _sgjOw::P64;
           P64[Hp - 8] = _sgjOx::P64;
           P64[Hp] = _sgjOy::P64;
           R2 = _sgjOt::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cglvy,
                       label: Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglvy: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cglvC; else goto cglvB;
       cglvC: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglvB: // global
           I64[Hp - 104] = $dFractional_sgjOv_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_sgjOw_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = x_sgjOx_info;
           _cgluR::P64 = Hp - 80;
           P64[Hp - 40] = _cgluR::P64;
           I64[Hp - 32] = sat_sgjOC_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cgluR::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.174164407 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$clog1p_info;
         const 0;
 },
 $dFractional_sgjOF_entry() //  [R1]
         { info_tbl: [(cglwi,
                       label: $dFractional_sgjOF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglwi: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgjOG_entry() //  [R1]
         { info_tbl: [(cglwp,
                       label: $dNum_sgjOG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglwp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglwq; else goto cglwr;
       cglwq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglwr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgjOH_entry() //  [R1]
         { info_tbl: [(cglww,
                       label: x_sgjOH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglww: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglwx; else goto cglwy;
       cglwx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglwy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjOK_entry() //  [R1]
         { info_tbl: [(cglwJ,
                       label: sat_sgjOK_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglwJ: // global
           _sgjOK::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cglwK; else goto cglwL;
       cglwL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglwN; else goto cglwM;
       cglwN: // global
           HpAlloc = 32;
           goto cglwK;
       cglwK: // global
           R1 = _sgjOK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglwM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgjOK::P64;
           _sgjOE::P64 = P64[_sgjOK::P64 + 16];
           _sgjOG::P64 = P64[_sgjOK::P64 + 24];
           _sgjOH::P64 = P64[_sgjOK::P64 + 32];
           _sgjOI::P64 = P64[_sgjOK::P64 + 40];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOE::P64;
           P64[Hp] = _sgjOI::P64;
           R2 = _sgjOG::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgjOH::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjOL_entry() //  [R1, R2]
         { info_tbl: [(cglwO,
                       label: sat_sgjOL_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglwO: // global
           _sgjOI::P64 = R2;
           _sgjOL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cglwP; else goto cglwQ;
       cglwQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cglwS; else goto cglwR;
       cglwS: // global
           HpAlloc = 48;
           goto cglwP;
       cglwP: // global
           R2 = _sgjOI::P64;
           R1 = _sgjOL::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglwR: // global
           _sgjOD::P64 = P64[_sgjOL::P64 + 7];
           _sgjOE::P64 = P64[_sgjOL::P64 + 15];
           _sgjOG::P64 = P64[_sgjOL::P64 + 23];
           _sgjOH::P64 = P64[_sgjOL::P64 + 31];
           I64[Hp - 40] = sat_sgjOK_info;
           P64[Hp - 24] = _sgjOE::P64;
           P64[Hp - 16] = _sgjOG::P64;
           P64[Hp - 8] = _sgjOH::P64;
           P64[Hp] = _sgjOI::P64;
           R2 = _sgjOD::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$clog1p_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cglwT,
                       label: Data.Functor.Contravariant.$fFloatingOp_$clog1p_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglwT: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cglwX; else goto cglwW;
       cglwX: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglwW: // global
           I64[Hp - 104] = $dFractional_sgjOF_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_sgjOG_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = x_sgjOH_info;
           _cglwl::P64 = Hp - 80;
           P64[Hp - 40] = _cglwl::P64;
           I64[Hp - 32] = sat_sgjOL_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cglwl::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.188364496 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp17_closure" {
     Data.Functor.Contravariant.$fFloatingOp17_closure:
         const Data.Functor.Contravariant.$fFloatingOp17_info;
 },
 Data.Functor.Contravariant.$fFloatingOp17_entry() //  [R2, R3, R4]
         { info_tbl: [(cglxv,
                       label: Data.Functor.Contravariant.$fFloatingOp17_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglxv: // global
           _sgjOO::P64 = R4;
           _sgjON::P64 = R3;
           _sgjOM::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglxw; else goto cglxx;
       cglxx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglxz; else goto cglxy;
       cglxz: // global
           HpAlloc = 32;
           goto cglxw;
       cglxw: // global
           R4 = _sgjOO::P64;
           R3 = _sgjON::P64;
           R2 = _sgjOM::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglxy: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjON::P64;
           P64[Hp] = _sgjOO::P64;
           R2 = _sgjOM::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.exp_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.19278101 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp16_closure" {
     Data.Functor.Contravariant.$fFloatingOp16_closure:
         const Data.Functor.Contravariant.$fFloatingOp16_info;
 },
 Data.Functor.Contravariant.$fFloatingOp16_entry() //  [R2, R3, R4]
         { info_tbl: [(cglxL,
                       label: Data.Functor.Contravariant.$fFloatingOp16_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglxL: // global
           _sgjOS::P64 = R4;
           _sgjOR::P64 = R3;
           _sgjOQ::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglxM; else goto cglxN;
       cglxN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglxP; else goto cglxO;
       cglxP: // global
           HpAlloc = 32;
           goto cglxM;
       cglxM: // global
           R4 = _sgjOS::P64;
           R3 = _sgjOR::P64;
           R2 = _sgjOQ::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp16_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglxO: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOR::P64;
           P64[Hp] = _sgjOS::P64;
           R2 = _sgjOQ::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.197187866 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp15_closure" {
     Data.Functor.Contravariant.$fFloatingOp15_closure:
         const Data.Functor.Contravariant.$fFloatingOp15_info;
 },
 Data.Functor.Contravariant.$fFloatingOp15_entry() //  [R2, R3, R4]
         { info_tbl: [(cgly1,
                       label: Data.Functor.Contravariant.$fFloatingOp15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgly1: // global
           _sgjOW::P64 = R4;
           _sgjOV::P64 = R3;
           _sgjOU::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgly2; else goto cgly3;
       cgly3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgly5; else goto cgly4;
       cgly5: // global
           HpAlloc = 32;
           goto cgly2;
       cgly2: // global
           R4 = _sgjOW::P64;
           R3 = _sgjOV::P64;
           R2 = _sgjOU::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp15_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgly4: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOV::P64;
           P64[Hp] = _sgjOW::P64;
           R2 = _sgjOU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.sqrt_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.201968673 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp14_closure" {
     Data.Functor.Contravariant.$fFloatingOp14_closure:
         const Data.Functor.Contravariant.$fFloatingOp14_info;
 },
 Data.Functor.Contravariant.$fFloatingOp14_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cglyi,
                       label: Data.Functor.Contravariant.$fFloatingOp14_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglyi: // global
           _sgjP1::P64 = R5;
           _sgjP0::P64 = R4;
           _sgjOZ::P64 = R3;
           _sgjOY::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cglyj; else goto cglyk;
       cglyk: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cglym; else goto cglyl;
       cglym: // global
           HpAlloc = 64;
           goto cglyj;
       cglyj: // global
           R5 = _sgjP1::P64;
           R4 = _sgjP0::P64;
           R3 = _sgjOZ::P64;
           R2 = _sgjOY::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp14_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglyl: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjP0::P64;
           P64[Hp - 32] = _sgjP1::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjOZ::P64;
           P64[Hp] = _sgjP1::P64;
           R2 = _sgjOY::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Float.**_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.206461946 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp13_closure" {
     Data.Functor.Contravariant.$fFloatingOp13_closure:
         const Data.Functor.Contravariant.$fFloatingOp13_info;
 },
 Data.Functor.Contravariant.$fFloatingOp13_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cglyA,
                       label: Data.Functor.Contravariant.$fFloatingOp13_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglyA: // global
           _sgjP7::P64 = R5;
           _sgjP6::P64 = R4;
           _sgjP5::P64 = R3;
           _sgjP4::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cglyB; else goto cglyC;
       cglyC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cglyE; else goto cglyD;
       cglyE: // global
           HpAlloc = 64;
           goto cglyB;
       cglyB: // global
           R5 = _sgjP7::P64;
           R4 = _sgjP6::P64;
           R3 = _sgjP5::P64;
           R2 = _sgjP4::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp13_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglyD: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjP6::P64;
           P64[Hp - 32] = _sgjP7::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjP5::P64;
           P64[Hp] = _sgjP7::P64;
           R2 = _sgjP4::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Float.logBase_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.210755387 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp12_closure" {
     Data.Functor.Contravariant.$fFloatingOp12_closure:
         const Data.Functor.Contravariant.$fFloatingOp12_info;
 },
 Data.Functor.Contravariant.$fFloatingOp12_entry() //  [R2, R3, R4]
         { info_tbl: [(cglyR,
                       label: Data.Functor.Contravariant.$fFloatingOp12_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglyR: // global
           _sgjPc::P64 = R4;
           _sgjPb::P64 = R3;
           _sgjPa::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglyS; else goto cglyT;
       cglyT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglyV; else goto cglyU;
       cglyV: // global
           HpAlloc = 32;
           goto cglyS;
       cglyS: // global
           R4 = _sgjPc::P64;
           R3 = _sgjPb::P64;
           R2 = _sgjPa::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp12_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglyU: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPb::P64;
           P64[Hp] = _sgjPc::P64;
           R2 = _sgjPa::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.sin_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.214961106 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp11_closure" {
     Data.Functor.Contravariant.$fFloatingOp11_closure:
         const Data.Functor.Contravariant.$fFloatingOp11_info;
 },
 Data.Functor.Contravariant.$fFloatingOp11_entry() //  [R2, R3, R4]
         { info_tbl: [(cglz7,
                       label: Data.Functor.Contravariant.$fFloatingOp11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglz7: // global
           _sgjPg::P64 = R4;
           _sgjPf::P64 = R3;
           _sgjPe::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglz8; else goto cglz9;
       cglz9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglzb; else goto cglza;
       cglzb: // global
           HpAlloc = 32;
           goto cglz8;
       cglz8: // global
           R4 = _sgjPg::P64;
           R3 = _sgjPf::P64;
           R2 = _sgjPe::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp11_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglza: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPf::P64;
           P64[Hp] = _sgjPg::P64;
           R2 = _sgjPe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.cos_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.219784407 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp10_closure" {
     Data.Functor.Contravariant.$fFloatingOp10_closure:
         const Data.Functor.Contravariant.$fFloatingOp10_info;
 },
 Data.Functor.Contravariant.$fFloatingOp10_entry() //  [R2, R3, R4]
         { info_tbl: [(cglzn,
                       label: Data.Functor.Contravariant.$fFloatingOp10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglzn: // global
           _sgjPk::P64 = R4;
           _sgjPj::P64 = R3;
           _sgjPi::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglzo; else goto cglzp;
       cglzp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglzr; else goto cglzq;
       cglzr: // global
           HpAlloc = 32;
           goto cglzo;
       cglzo: // global
           R4 = _sgjPk::P64;
           R3 = _sgjPj::P64;
           R2 = _sgjPi::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp10_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglzq: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPj::P64;
           P64[Hp] = _sgjPk::P64;
           R2 = _sgjPi::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.tan_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.224223761 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp9_closure" {
     Data.Functor.Contravariant.$fFloatingOp9_closure:
         const Data.Functor.Contravariant.$fFloatingOp9_info;
 },
 Data.Functor.Contravariant.$fFloatingOp9_entry() //  [R2, R3, R4]
         { info_tbl: [(cglzD,
                       label: Data.Functor.Contravariant.$fFloatingOp9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglzD: // global
           _sgjPo::P64 = R4;
           _sgjPn::P64 = R3;
           _sgjPm::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglzE; else goto cglzF;
       cglzF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglzH; else goto cglzG;
       cglzH: // global
           HpAlloc = 32;
           goto cglzE;
       cglzE: // global
           R4 = _sgjPo::P64;
           R3 = _sgjPn::P64;
           R2 = _sgjPm::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp9_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglzG: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPn::P64;
           P64[Hp] = _sgjPo::P64;
           R2 = _sgjPm::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.asin_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.228823131 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp8_closure" {
     Data.Functor.Contravariant.$fFloatingOp8_closure:
         const Data.Functor.Contravariant.$fFloatingOp8_info;
 },
 Data.Functor.Contravariant.$fFloatingOp8_entry() //  [R2, R3, R4]
         { info_tbl: [(cglzT,
                       label: Data.Functor.Contravariant.$fFloatingOp8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglzT: // global
           _sgjPs::P64 = R4;
           _sgjPr::P64 = R3;
           _sgjPq::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglzU; else goto cglzV;
       cglzV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglzX; else goto cglzW;
       cglzX: // global
           HpAlloc = 32;
           goto cglzU;
       cglzU: // global
           R4 = _sgjPs::P64;
           R3 = _sgjPr::P64;
           R2 = _sgjPq::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglzW: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPr::P64;
           P64[Hp] = _sgjPs::P64;
           R2 = _sgjPq::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.acos_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.233219728 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp7_closure" {
     Data.Functor.Contravariant.$fFloatingOp7_closure:
         const Data.Functor.Contravariant.$fFloatingOp7_info;
 },
 Data.Functor.Contravariant.$fFloatingOp7_entry() //  [R2, R3, R4]
         { info_tbl: [(cglA9,
                       label: Data.Functor.Contravariant.$fFloatingOp7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglA9: // global
           _sgjPw::P64 = R4;
           _sgjPv::P64 = R3;
           _sgjPu::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglAa; else goto cglAb;
       cglAb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglAd; else goto cglAc;
       cglAd: // global
           HpAlloc = 32;
           goto cglAa;
       cglAa: // global
           R4 = _sgjPw::P64;
           R3 = _sgjPv::P64;
           R2 = _sgjPu::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglAc: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPv::P64;
           P64[Hp] = _sgjPw::P64;
           R2 = _sgjPu::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.atan_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.237849015 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp6_closure" {
     Data.Functor.Contravariant.$fFloatingOp6_closure:
         const Data.Functor.Contravariant.$fFloatingOp6_info;
 },
 Data.Functor.Contravariant.$fFloatingOp6_entry() //  [R2, R3, R4]
         { info_tbl: [(cglAp,
                       label: Data.Functor.Contravariant.$fFloatingOp6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglAp: // global
           _sgjPA::P64 = R4;
           _sgjPz::P64 = R3;
           _sgjPy::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglAq; else goto cglAr;
       cglAr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglAt; else goto cglAs;
       cglAt: // global
           HpAlloc = 32;
           goto cglAq;
       cglAq: // global
           R4 = _sgjPA::P64;
           R3 = _sgjPz::P64;
           R2 = _sgjPy::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp6_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglAs: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPz::P64;
           P64[Hp] = _sgjPA::P64;
           R2 = _sgjPy::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.sinh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.242744173 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp5_closure" {
     Data.Functor.Contravariant.$fFloatingOp5_closure:
         const Data.Functor.Contravariant.$fFloatingOp5_info;
 },
 Data.Functor.Contravariant.$fFloatingOp5_entry() //  [R2, R3, R4]
         { info_tbl: [(cglAF,
                       label: Data.Functor.Contravariant.$fFloatingOp5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglAF: // global
           _sgjPE::P64 = R4;
           _sgjPD::P64 = R3;
           _sgjPC::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglAG; else goto cglAH;
       cglAH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglAJ; else goto cglAI;
       cglAJ: // global
           HpAlloc = 32;
           goto cglAG;
       cglAG: // global
           R4 = _sgjPE::P64;
           R3 = _sgjPD::P64;
           R2 = _sgjPC::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglAI: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPD::P64;
           P64[Hp] = _sgjPE::P64;
           R2 = _sgjPC::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.cosh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.247036067 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp4_closure" {
     Data.Functor.Contravariant.$fFloatingOp4_closure:
         const Data.Functor.Contravariant.$fFloatingOp4_info;
 },
 Data.Functor.Contravariant.$fFloatingOp4_entry() //  [R2, R3, R4]
         { info_tbl: [(cglAV,
                       label: Data.Functor.Contravariant.$fFloatingOp4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglAV: // global
           _sgjPI::P64 = R4;
           _sgjPH::P64 = R3;
           _sgjPG::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglAW; else goto cglAX;
       cglAX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglAZ; else goto cglAY;
       cglAZ: // global
           HpAlloc = 32;
           goto cglAW;
       cglAW: // global
           R4 = _sgjPI::P64;
           R3 = _sgjPH::P64;
           R2 = _sgjPG::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglAY: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPH::P64;
           P64[Hp] = _sgjPI::P64;
           R2 = _sgjPG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.tanh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.251273624 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp3_closure" {
     Data.Functor.Contravariant.$fFloatingOp3_closure:
         const Data.Functor.Contravariant.$fFloatingOp3_info;
 },
 Data.Functor.Contravariant.$fFloatingOp3_entry() //  [R2, R3, R4]
         { info_tbl: [(cglBb,
                       label: Data.Functor.Contravariant.$fFloatingOp3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglBb: // global
           _sgjPM::P64 = R4;
           _sgjPL::P64 = R3;
           _sgjPK::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglBc; else goto cglBd;
       cglBd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglBf; else goto cglBe;
       cglBf: // global
           HpAlloc = 32;
           goto cglBc;
       cglBc: // global
           R4 = _sgjPM::P64;
           R3 = _sgjPL::P64;
           R2 = _sgjPK::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglBe: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPL::P64;
           P64[Hp] = _sgjPM::P64;
           R2 = _sgjPK::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.asinh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.255511865 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp2_closure" {
     Data.Functor.Contravariant.$fFloatingOp2_closure:
         const Data.Functor.Contravariant.$fFloatingOp2_info;
 },
 Data.Functor.Contravariant.$fFloatingOp2_entry() //  [R2, R3, R4]
         { info_tbl: [(cglBr,
                       label: Data.Functor.Contravariant.$fFloatingOp2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglBr: // global
           _sgjPQ::P64 = R4;
           _sgjPP::P64 = R3;
           _sgjPO::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglBs; else goto cglBt;
       cglBt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglBv; else goto cglBu;
       cglBv: // global
           HpAlloc = 32;
           goto cglBs;
       cglBs: // global
           R4 = _sgjPQ::P64;
           R3 = _sgjPP::P64;
           R2 = _sgjPO::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglBu: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPP::P64;
           P64[Hp] = _sgjPQ::P64;
           R2 = _sgjPO::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.acosh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.259937152 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp1_closure" {
     Data.Functor.Contravariant.$fFloatingOp1_closure:
         const Data.Functor.Contravariant.$fFloatingOp1_info;
 },
 Data.Functor.Contravariant.$fFloatingOp1_entry() //  [R2, R3, R4]
         { info_tbl: [(cglBH,
                       label: Data.Functor.Contravariant.$fFloatingOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglBH: // global
           _sgjPU::P64 = R4;
           _sgjPT::P64 = R3;
           _sgjPS::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglBI; else goto cglBJ;
       cglBJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglBL; else goto cglBK;
       cglBL: // global
           HpAlloc = 32;
           goto cglBI;
       cglBI: // global
           R4 = _sgjPU::P64;
           R3 = _sgjPT::P64;
           R2 = _sgjPS::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglBK: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPT::P64;
           P64[Hp] = _sgjPU::P64;
           R2 = _sgjPS::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.atanh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.264162521 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp2_closure" {
     Data.Functor.Contravariant.$fFractionalOp2_closure:
         const Data.Functor.Contravariant.$fFractionalOp2_info;
 },
 Data.Functor.Contravariant.$fFractionalOp2_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cglBY,
                       label: Data.Functor.Contravariant.$fFractionalOp2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglBY: // global
           _sgjPZ::P64 = R5;
           _sgjPY::P64 = R4;
           _sgjPX::P64 = R3;
           _sgjPW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cglBZ; else goto cglC0;
       cglC0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cglC2; else goto cglC1;
       cglC2: // global
           HpAlloc = 64;
           goto cglBZ;
       cglBZ: // global
           R5 = _sgjPZ::P64;
           R4 = _sgjPY::P64;
           R3 = _sgjPX::P64;
           R2 = _sgjPW::P64;
           R1 = Data.Functor.Contravariant.$fFractionalOp2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglC1: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjPY::P64;
           P64[Hp - 32] = _sgjPZ::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjPX::P64;
           P64[Hp] = _sgjPZ::P64;
           R2 = _sgjPW::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Real./_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.268640153 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp1_closure" {
     Data.Functor.Contravariant.$fFractionalOp1_closure:
         const Data.Functor.Contravariant.$fFractionalOp1_info;
 },
 Data.Functor.Contravariant.$fFractionalOp1_entry() //  [R2, R3, R4]
         { info_tbl: [(cglCf,
                       label: Data.Functor.Contravariant.$fFractionalOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglCf: // global
           _sgjQ4::P64 = R4;
           _sgjQ3::P64 = R3;
           _sgjQ2::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglCg; else goto cglCh;
       cglCh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglCj; else goto cglCi;
       cglCj: // global
           HpAlloc = 32;
           goto cglCg;
       cglCg: // global
           R4 = _sgjQ4::P64;
           R3 = _sgjQ3::P64;
           R2 = _sgjQ2::P64;
           R1 = Data.Functor.Contravariant.$fFractionalOp1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglCi: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQ3::P64;
           P64[Hp] = _sgjQ4::P64;
           R2 = _sgjQ2::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.273402791 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp_$cfromRational_closure" {
     Data.Functor.Contravariant.$fFractionalOp_$cfromRational_closure:
         const Data.Functor.Contravariant.$fFractionalOp_$cfromRational_info;
 },
 x_sgjQ8_entry() //  [R1]
         { info_tbl: [(cglCy,
                       label: x_sgjQ8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglCy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglCz; else goto cglCA;
       cglCz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglCA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.fromRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjQa_entry() //  [R1]
         { info_tbl: [(cglCG,
                       label: sat_sgjQa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglCG: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFractionalOp_$cfromRational_entry() //  [R2,
                                                                       R3]
         { info_tbl: [(cglCJ,
                       label: Data.Functor.Contravariant.$fFractionalOp_$cfromRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglCJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cglCN; else goto cglCM;
       cglCN: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFractionalOp_$cfromRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglCM: // global
           I64[Hp - 40] = x_sgjQ8_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sgjQa_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.281581267 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp_$cnegate_closure" {
     Data.Functor.Contravariant.$fNumOp_$cnegate_closure:
         const Data.Functor.Contravariant.$fNumOp_$cnegate_info;
         const 0;
 },
 x_sgjQd_entry() //  [R1]
         { info_tbl: [(cglDa,
                       label: x_sgjQd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglDa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglDb; else goto cglDc;
       cglDb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglDc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl1_rgjLs_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjQg_entry() //  [R1, R2]
         { info_tbl: [(cglDj,
                       label: sat_sgjQg_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglDj: // global
           _sgjQe::P64 = R2;
           _sgjQg::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cglDk; else goto cglDl;
       cglDl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglDn; else goto cglDm;
       cglDn: // global
           HpAlloc = 32;
           goto cglDk;
       cglDk: // global
           R2 = _sgjQe::P64;
           R1 = _sgjQg::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglDm: // global
           _sgjQb::P64 = P64[_sgjQg::P64 + 7];
           _sgjQc::P64 = P64[_sgjQg::P64 + 15];
           _sgjQd::P64 = P64[_sgjQg::P64 + 23];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQc::P64;
           P64[Hp] = _sgjQe::P64;
           R2 = _sgjQb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgjQd::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fNumOp_$cnegate_entry() //  [R2, R3]
         { info_tbl: [(cglDo,
                       label: Data.Functor.Contravariant.$fNumOp_$cnegate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglDo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cglDs; else goto cglDr;
       cglDs: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fNumOp_$cnegate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglDr: // global
           I64[Hp - 48] = x_sgjQd_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = sat_sgjQg_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.290206378 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp5_closure" {
     Data.Functor.Contravariant.$fNumOp5_closure:
         const Data.Functor.Contravariant.$fNumOp5_info;
 },
 Data.Functor.Contravariant.$fNumOp5_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cglDO,
                       label: Data.Functor.Contravariant.$fNumOp5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglDO: // global
           _sgjQk::P64 = R5;
           _sgjQj::P64 = R4;
           _sgjQi::P64 = R3;
           _sgjQh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cglDP; else goto cglDQ;
       cglDQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cglDS; else goto cglDR;
       cglDS: // global
           HpAlloc = 64;
           goto cglDP;
       cglDP: // global
           R5 = _sgjQk::P64;
           R4 = _sgjQj::P64;
           R3 = _sgjQi::P64;
           R2 = _sgjQh::P64;
           R1 = Data.Functor.Contravariant.$fNumOp5_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglDR: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjQj::P64;
           P64[Hp - 32] = _sgjQk::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQi::P64;
           P64[Hp] = _sgjQk::P64;
           R2 = _sgjQh::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.294480316 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp4_closure" {
     Data.Functor.Contravariant.$fNumOp4_closure:
         const Data.Functor.Contravariant.$fNumOp4_info;
 },
 Data.Functor.Contravariant.$fNumOp4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cglE6,
                       label: Data.Functor.Contravariant.$fNumOp4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglE6: // global
           _sgjQq::P64 = R5;
           _sgjQp::P64 = R4;
           _sgjQo::P64 = R3;
           _sgjQn::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cglE7; else goto cglE8;
       cglE8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cglEa; else goto cglE9;
       cglEa: // global
           HpAlloc = 64;
           goto cglE7;
       cglE7: // global
           R5 = _sgjQq::P64;
           R4 = _sgjQp::P64;
           R3 = _sgjQo::P64;
           R2 = _sgjQn::P64;
           R1 = Data.Functor.Contravariant.$fNumOp4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglE9: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjQp::P64;
           P64[Hp - 32] = _sgjQq::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQo::P64;
           P64[Hp] = _sgjQq::P64;
           R2 = _sgjQn::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.298825077 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp3_closure" {
     Data.Functor.Contravariant.$fNumOp3_closure:
         const Data.Functor.Contravariant.$fNumOp3_info;
 },
 Data.Functor.Contravariant.$fNumOp3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cglEo,
                       label: Data.Functor.Contravariant.$fNumOp3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglEo: // global
           _sgjQw::P64 = R5;
           _sgjQv::P64 = R4;
           _sgjQu::P64 = R3;
           _sgjQt::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cglEp; else goto cglEq;
       cglEq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cglEs; else goto cglEr;
       cglEs: // global
           HpAlloc = 64;
           goto cglEp;
       cglEp: // global
           R5 = _sgjQw::P64;
           R4 = _sgjQv::P64;
           R3 = _sgjQu::P64;
           R2 = _sgjQt::P64;
           R1 = Data.Functor.Contravariant.$fNumOp3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglEr: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgjQv::P64;
           P64[Hp - 32] = _sgjQw::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQu::P64;
           P64[Hp] = _sgjQw::P64;
           R2 = _sgjQt::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.303432964 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp2_closure" {
     Data.Functor.Contravariant.$fNumOp2_closure:
         const Data.Functor.Contravariant.$fNumOp2_info;
 },
 Data.Functor.Contravariant.$fNumOp2_entry() //  [R2, R3, R4]
         { info_tbl: [(cglEF,
                       label: Data.Functor.Contravariant.$fNumOp2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglEF: // global
           _sgjQB::P64 = R4;
           _sgjQA::P64 = R3;
           _sgjQz::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglEG; else goto cglEH;
       cglEH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglEJ; else goto cglEI;
       cglEJ: // global
           HpAlloc = 32;
           goto cglEG;
       cglEG: // global
           R4 = _sgjQB::P64;
           R3 = _sgjQA::P64;
           R2 = _sgjQz::P64;
           R1 = Data.Functor.Contravariant.$fNumOp2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglEI: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQA::P64;
           P64[Hp] = _sgjQB::P64;
           R2 = _sgjQz::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.307526667 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp1_closure" {
     Data.Functor.Contravariant.$fNumOp1_closure:
         const Data.Functor.Contravariant.$fNumOp1_info;
 },
 Data.Functor.Contravariant.$fNumOp1_entry() //  [R2, R3, R4]
         { info_tbl: [(cglEV,
                       label: Data.Functor.Contravariant.$fNumOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglEV: // global
           _sgjQF::P64 = R4;
           _sgjQE::P64 = R3;
           _sgjQD::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cglEW; else goto cglEX;
       cglEX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglEZ; else goto cglEY;
       cglEZ: // global
           HpAlloc = 32;
           goto cglEW;
       cglEW: // global
           R4 = _sgjQF::P64;
           R3 = _sgjQE::P64;
           R2 = _sgjQD::P64;
           R1 = Data.Functor.Contravariant.$fNumOp1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglEY: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjQE::P64;
           P64[Hp] = _sgjQF::P64;
           R2 = _sgjQD::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.31186928 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp_$cfromInteger_closure" {
     Data.Functor.Contravariant.$fNumOp_$cfromInteger_closure:
         const Data.Functor.Contravariant.$fNumOp_$cfromInteger_info;
 },
 x_sgjQJ_entry() //  [R1]
         { info_tbl: [(cglFe,
                       label: x_sgjQJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglFe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglFf; else goto cglFg;
       cglFf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglFg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgjQL_entry() //  [R1]
         { info_tbl: [(cglFm,
                       label: sat_sgjQL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglFm: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fNumOp_$cfromInteger_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cglFp,
                       label: Data.Functor.Contravariant.$fNumOp_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglFp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cglFt; else goto cglFs;
       cglFt: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fNumOp_$cfromInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglFs: // global
           I64[Hp - 40] = x_sgjQJ_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sgjQL_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.320800099 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp_closure" {
     Data.Functor.Contravariant.$fNumOp_closure:
         const Data.Functor.Contravariant.$fNumOp_info;
         const 0;
 },
 sat_sgjQT_entry() //  [R1, R2]
         { info_tbl: [(cglFR,
                       label: sat_sgjQT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglFR: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fNumOp_$cfromInteger_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQS_entry() //  [R1, R2, R3]
         { info_tbl: [(cglFZ,
                       label: sat_sgjQS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglFZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fNumOp1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQR_entry() //  [R1, R2, R3]
         { info_tbl: [(cglG7,
                       label: sat_sgjQR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglG7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fNumOp2_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQQ_entry() //  [R1, R2]
         { info_tbl: [(cglGf,
                       label: sat_sgjQQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglGf: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fNumOp_$cnegate_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQP_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cglGn,
                       label: sat_sgjQP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglGn: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fNumOp3_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQO_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cglGv,
                       label: sat_sgjQO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglGv: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fNumOp4_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQN_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cglGD,
                       label: sat_sgjQN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglGD: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fNumOp5_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fNumOp_entry() //  [R2]
         { info_tbl: [(cglGH,
                       label: Data.Functor.Contravariant.$fNumOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglGH: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto cglGL; else goto cglGK;
       cglGL: // global
           HpAlloc = 176;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fNumOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglGK: // global
           I64[Hp - 168] = sat_sgjQT_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sgjQS_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sgjQR_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sgjQQ_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgjQP_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgjQO_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgjQN_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 69;
           P64[Hp - 40] = Hp - 85;
           P64[Hp - 32] = Hp - 101;
           P64[Hp - 24] = Hp - 119;
           P64[Hp - 16] = Hp - 134;
           P64[Hp - 8] = Hp - 150;
           P64[Hp] = Hp - 167;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.33622431 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure" {
     Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure:
         const Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_info;
         const 0;
 },
 sat_sgjQV_entry() //  [R1]
         { info_tbl: [(cglHr,
                       label: sat_sgjQV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglHr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglHs; else goto cglHt;
       cglHs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglHt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_entry() //  [R2]
         { info_tbl: [(cglHu,
                       label: Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglHu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cglHy; else goto cglHx;
       cglHy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglHx: // global
           I64[Hp - 16] = sat_sgjQV_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Contravariant.$fNumOp_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.342488058 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp_closure" {
     Data.Functor.Contravariant.$fFractionalOp_closure:
         const Data.Functor.Contravariant.$fFractionalOp_info;
         const 0;
 },
 sat_sgjR0_entry() //  [R1, R2]
         { info_tbl: [(cglHQ,
                       label: sat_sgjR0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglHQ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFractionalOp_$cfromRational_entry(R3,
                                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cglHY,
                       label: sat_sgjQZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglHY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFractionalOp1_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cglI6,
                       label: sat_sgjQY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglI6: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fFractionalOp2_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjQX_entry() //  [R1]
         { info_tbl: [(cglId,
                       label: sat_sgjQX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglId: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglIe; else goto cglIf;
       cglIe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglIf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFractionalOp_entry() //  [R2]
         { info_tbl: [(cglIh,
                       label: Data.Functor.Contravariant.$fFractionalOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglIh: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cglIl; else goto cglIk;
       cglIl: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFractionalOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglIk: // global
           I64[Hp - 104] = sat_sgjR0_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgjQZ_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgjQY_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgjQX_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 69;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.353720697 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_info;
         const 0;
 },
 sat_sgjR2_entry() //  [R1]
         { info_tbl: [(cglIQ,
                       label: sat_sgjR2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglIQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglIR; else goto cglIS;
       cglIR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglIS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_entry() //  [R2]
         { info_tbl: [(cglIT,
                       label: Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglIT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cglIX; else goto cglIW;
       cglIX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglIW: // global
           I64[Hp - 16] = sat_sgjR2_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Contravariant.$fFractionalOp_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.362731994 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_closure" {
     Data.Functor.Contravariant.$fFloatingOp_closure:
         const Data.Functor.Contravariant.$fFloatingOp_info;
         const 0;
 },
 lvl7_sgjR4_entry() //  [R1]
         { info_tbl: [(cglJe,
                       label: lvl7_sgjR4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglJe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglJf; else goto cglJg;
       cglJf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglJg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.pi_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjRs_entry() //  [R1, R2]
         { info_tbl: [(cglJm,
                       label: sat_sgjRs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglJm: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRr_entry() //  [R1, R2]
         { info_tbl: [(cglJu,
                       label: sat_sgjRr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglJu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRq_entry() //  [R1, R2]
         { info_tbl: [(cglJC,
                       label: sat_sgjRq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglJC: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$cexpm1_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRp_entry() //  [R1, R2]
         { info_tbl: [(cglJK,
                       label: sat_sgjRp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglJK: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$clog1p_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRo_entry() //  [R1, R2, R3]
         { info_tbl: [(cglJS,
                       label: sat_sgjRo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglJS: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp1_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRn_entry() //  [R1, R2, R3]
         { info_tbl: [(cglK0,
                       label: sat_sgjRn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglK0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRm_entry() //  [R1, R2, R3]
         { info_tbl: [(cglK8,
                       label: sat_sgjRm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglK8: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp3_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRl_entry() //  [R1, R2, R3]
         { info_tbl: [(cglKg,
                       label: sat_sgjRl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglKg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp4_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRk_entry() //  [R1, R2, R3]
         { info_tbl: [(cglKo,
                       label: sat_sgjRk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglKo: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp5_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRj_entry() //  [R1, R2, R3]
         { info_tbl: [(cglKw,
                       label: sat_sgjRj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglKw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp6_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRi_entry() //  [R1, R2, R3]
         { info_tbl: [(cglKE,
                       label: sat_sgjRi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglKE: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp7_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRh_entry() //  [R1, R2, R3]
         { info_tbl: [(cglKM,
                       label: sat_sgjRh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglKM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp8_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRg_entry() //  [R1, R2, R3]
         { info_tbl: [(cglKU,
                       label: sat_sgjRg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglKU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp9_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRf_entry() //  [R1, R2, R3]
         { info_tbl: [(cglL2,
                       label: sat_sgjRf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglL2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp10_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRe_entry() //  [R1, R2, R3]
         { info_tbl: [(cglLa,
                       label: sat_sgjRe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglLa: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp11_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRd_entry() //  [R1, R2, R3]
         { info_tbl: [(cglLi,
                       label: sat_sgjRd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglLi: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp12_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRc_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cglLq,
                       label: sat_sgjRc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglLq: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fFloatingOp13_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRb_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cglLy,
                       label: sat_sgjRb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglLy: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fFloatingOp14_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjRa_entry() //  [R1, R2, R3]
         { info_tbl: [(cglLG,
                       label: sat_sgjRa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglLG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp15_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjR9_entry() //  [R1, R2, R3]
         { info_tbl: [(cglLO,
                       label: sat_sgjR9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglLO: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp16_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjR8_entry() //  [R1, R2, R3]
         { info_tbl: [(cglLW,
                       label: sat_sgjR8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglLW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp17_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjR7_entry() //  [R1]
         { info_tbl: [(cglM4,
                       label: sat_sgjR7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglM4: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjR5_entry() //  [R1]
         { info_tbl: [(cglMb,
                       label: sat_sgjR5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglMb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglMc; else goto cglMd;
       cglMc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglMd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_entry() //  [R2]
         { info_tbl: [(cglMf,
                       label: Data.Functor.Contravariant.$fFloatingOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglMf: // global
           Hp = Hp + 592;
           if (Hp > HpLim) (likely: False) goto cglMj; else goto cglMi;
       cglMj: // global
           HpAlloc = 592;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglMi: // global
           I64[Hp - 584] = lvl7_sgjR4_info;
           P64[Hp - 568] = R2;
           I64[Hp - 560] = sat_sgjRs_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_sgjRr_info;
           P64[Hp - 536] = R2;
           I64[Hp - 528] = sat_sgjRq_info;
           P64[Hp - 520] = R2;
           I64[Hp - 512] = sat_sgjRp_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_sgjRo_info;
           P64[Hp - 488] = R2;
           I64[Hp - 480] = sat_sgjRn_info;
           P64[Hp - 472] = R2;
           I64[Hp - 464] = sat_sgjRm_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_sgjRl_info;
           P64[Hp - 440] = R2;
           I64[Hp - 432] = sat_sgjRk_info;
           P64[Hp - 424] = R2;
           I64[Hp - 416] = sat_sgjRj_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_sgjRi_info;
           P64[Hp - 392] = R2;
           I64[Hp - 384] = sat_sgjRh_info;
           P64[Hp - 376] = R2;
           I64[Hp - 368] = sat_sgjRg_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_sgjRf_info;
           P64[Hp - 344] = R2;
           I64[Hp - 336] = sat_sgjRe_info;
           P64[Hp - 328] = R2;
           I64[Hp - 320] = sat_sgjRd_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_sgjRc_info;
           P64[Hp - 296] = R2;
           I64[Hp - 288] = sat_sgjRb_info;
           P64[Hp - 280] = R2;
           I64[Hp - 272] = sat_sgjRa_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_sgjR9_info;
           P64[Hp - 248] = R2;
           I64[Hp - 240] = sat_sgjR8_info;
           P64[Hp - 232] = R2;
           I64[Hp - 224] = sat_sgjR7_info;
           P64[Hp - 216] = Hp - 584;
           I64[Hp - 208] = sat_sgjR5_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = GHC.Float.C:Floating_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 223;
           P64[Hp - 160] = Hp - 238;
           P64[Hp - 152] = Hp - 254;
           P64[Hp - 144] = Hp - 270;
           P64[Hp - 136] = Hp - 285;
           P64[Hp - 128] = Hp - 301;
           P64[Hp - 120] = Hp - 318;
           P64[Hp - 112] = Hp - 334;
           P64[Hp - 104] = Hp - 350;
           P64[Hp - 96] = Hp - 366;
           P64[Hp - 88] = Hp - 382;
           P64[Hp - 80] = Hp - 398;
           P64[Hp - 72] = Hp - 414;
           P64[Hp - 64] = Hp - 430;
           P64[Hp - 56] = Hp - 446;
           P64[Hp - 48] = Hp - 462;
           P64[Hp - 40] = Hp - 478;
           P64[Hp - 32] = Hp - 494;
           P64[Hp - 24] = Hp - 511;
           P64[Hp - 16] = Hp - 527;
           P64[Hp - 8] = Hp - 543;
           P64[Hp] = Hp - 559;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.40694224 UTC

[section ""data" . Data.Functor.Contravariant.$fCategoryTYPEOp1_closure" {
     Data.Functor.Contravariant.$fCategoryTYPEOp1_closure:
         const Data.Functor.Contravariant.$fCategoryTYPEOp1_info;
 },
 Data.Functor.Contravariant.$fCategoryTYPEOp1_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cglO3,
                       label: Data.Functor.Contravariant.$fCategoryTYPEOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglO3: // global
           R4 = R4;
           _sgjRu::P64 = R3;
           R3 = R2;
           R2 = _sgjRu::P64;
           call GHC.Base.._entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.4106903 UTC

[section ""data" . Data.Functor.Contravariant.$fCategoryTYPEOp_closure" {
     Data.Functor.Contravariant.$fCategoryTYPEOp_closure:
         const Control.Category.C:Category_con_info;
         const GHC.Base.id_closure+1;
         const Data.Functor.Contravariant.$fCategoryTYPEOp1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.412526576 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence3_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence3_closure:
         const Data.Functor.Contravariant.$fMonoidEquivalence3_info;
 },
 Data.Functor.Contravariant.$fMonoidEquivalence3_entry() //  []
         { info_tbl: [(cglOf,
                       label: Data.Functor.Contravariant.$fMonoidEquivalence3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglOf: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.41668479 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence1_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence1_closure:
         const Data.Functor.Contravariant.$fSemigroupEquivalence1_info;
 },
 ds_sgjRC_entry() //  [R1]
         { info_tbl: [(cglOB,
                       label: ds_sgjRC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglOB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglOC; else goto cglOD;
       cglOC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglOD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fSemigroupEquivalence1_entry(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjRG_entry() //  [R1, R2, R3]
         { info_tbl: [(cglOP,
                       label: sat_sgjRG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglOP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglOQ; else goto cglOR;
       cglOQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglOR: // global
           I64[Sp - 32] = block_cglOJ_info;
           _sgjRE::P64 = R3;
           R3 = R3;
           _sgjRD::P64 = R2;
           R2 = R2;
           _sgjRC::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _sgjRC::P64;
           P64[Sp - 16] = _sgjRD::P64;
           P64[Sp - 8] = _sgjRE::P64;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglOJ() //  [R1]
         { info_tbl: [(cglOJ,
                       label: block_cglOJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglOJ: // global
           if (R1 & 7 == 1) goto cglOM; else goto cglON;
       cglOM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cglON: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupEquivalence1_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cglP2,
                       label: Data.Functor.Contravariant.$fSemigroupEquivalence1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglP2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglP3; else goto cglP4;
       cglP3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupEquivalence1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglP4: // global
           I64[Sp - 16] = block_cglOr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uglPa; else goto cglOs;
       uglPa: // global
           call _cglOr(R1) args: 0, res: 0, upd: 0;
       cglOs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglOr() //  [R1]
         { info_tbl: [(cglOr,
                       label: block_cglOr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglOr: // global
           _sgjRx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cglOZ; else goto cglP0;
       cglOZ: // global
           R1 = _sgjRx::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cglP0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cglP9; else goto cglP8;
       cglP9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cglP8: // global
           _sgjRA::P64 = P64[R1 + 6];
           _sgjRB::P64 = P64[R1 + 14];
           I64[Hp - 48] = ds_sgjRC_info;
           P64[Hp - 32] = _sgjRA::P64;
           P64[Hp - 24] = _sgjRB::P64;
           I64[Hp - 16] = sat_sgjRG_info;
           P64[Hp - 8] = _sgjRx::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.429498507 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure:
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_info;
 },
 Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_entry() //  [R2]
         { info_tbl: [(cglPJ,
                       label: Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglPJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cglPK; else goto cglPL;
       cglPK: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglPL: // global
           I64[Sp - 8] = block_cglPG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uglPP; else goto cglPH;
       uglPP: // global
           call _cglPG(R1) args: 0, res: 0, upd: 0;
       cglPH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglPG() //  [R1]
         { info_tbl: [(cglPG,
                       label: block_cglPG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglPG: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Contravariant.$fSemigroupEquivalence1_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.435054012 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence2_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence2_closure:
         const Data.Functor.Contravariant.$fMonoidEquivalence2_info;
 },
 Data.Functor.Contravariant.$fMonoidEquivalence2_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cglQ9,
                       label: Data.Functor.Contravariant.$fMonoidEquivalence2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglQ9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglQa; else goto cglQb;
       cglQa: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidEquivalence2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglQb: // global
           I64[Sp - 32] = block_cglQ3_info;
           _sgjRM::P64 = R3;
           R3 = R5;
           _sgjRL::P64 = R2;
           R2 = R4;
           R1 = _sgjRL::P64;
           P64[Sp - 24] = _sgjRM::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglQ3() //  [R1]
         { info_tbl: [(cglQ3,
                       label: block_cglQ3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglQ3: // global
           if (R1 & 7 == 1) goto cglQ6; else goto cglQ7;
       cglQ6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cglQ7: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.44099771 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Functor.Contravariant.$fMonoidEquivalence2_closure+4;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure+1;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_closure:
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_info;
         const 0;
 },
 Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_entry() //  [R2]
         { info_tbl: [(cglQx,
                       label: Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglQx: // global
           R3 = Data.Functor.Contravariant.$fSemigroupEquivalence_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.445554238 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence1_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence1_closure:
         const Data.Functor.Contravariant.$fMonoidEquivalence1_info;
 },
 Data.Functor.Contravariant.$fMonoidEquivalence1_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cglQQ,
                       label: Data.Functor.Contravariant.$fMonoidEquivalence1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglQQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglQR; else goto uglRb;
       cglQR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidEquivalence1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uglRb: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cglQG() args: 0, res: 0, upd: 0;
     }
 },
 _cglQG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglQG: // global
           _sgjRR::P64 = P64[Sp];
           I64[Sp] = block_cglQJ_info;
           R1 = _sgjRR::P64;
           if (R1 & 7 != 0) goto uglRd; else goto cglQK;
       uglRd: // global
           call _cglQJ(R1) args: 0, res: 0, upd: 0;
       cglQK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglQJ() //  [R1]
         { info_tbl: [(cglQJ,
                       label: block_cglQJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglQJ: // global
           if (R1 & 7 == 1) goto cglQN; else goto cglQO;
       cglQN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cglQO: // global
           I64[Sp - 8] = block_cglQY_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           _sgjRW::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sgjRW::P64;
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglQY() //  [R1]
         { info_tbl: [(cglQY,
                       label: block_cglQY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglQY: // global
           if (R1 & 7 == 1) goto cglR5; else goto cglR9;
       cglR5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cglR9: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cglQG() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.454228989 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_closure+1;
         const Data.Functor.Contravariant.$fMonoidEquivalence3_closure+2;
         const Data.Functor.Contravariant.$fMonoidEquivalence2_closure+4;
         const Data.Functor.Contravariant.$fMonoidEquivalence1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.456252933 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate3_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate3_closure:
         const Data.Functor.Contravariant.$fMonoidPredicate3_info;
 },
 Data.Functor.Contravariant.$fMonoidPredicate3_entry() //  []
         { info_tbl: [(cglRI,
                       label: Data.Functor.Contravariant.$fMonoidPredicate3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglRI: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.460502644 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate1_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate1_closure:
         const Data.Functor.Contravariant.$fSemigroupPredicate1_info;
 },
 ds_sgjS4_entry() //  [R1]
         { info_tbl: [(cglS4,
                       label: ds_sgjS4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglS4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglS5; else goto cglS6;
       cglS5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglS6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fSemigroupPredicate1_entry(R3,
                                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgjS7_entry() //  [R1, R2]
         { info_tbl: [(cglSi,
                       label: sat_sgjS7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglSi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cglSj; else goto cglSk;
       cglSj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglSk: // global
           I64[Sp - 24] = block_cglSc_info;
           _sgjS5::P64 = R2;
           R2 = R2;
           _sgjS4::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sgjS4::P64;
           P64[Sp - 8] = _sgjS5::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglSc() //  [R1]
         { info_tbl: [(cglSc,
                       label: block_cglSc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglSc: // global
           if (R1 & 7 == 1) goto cglSf; else goto cglSg;
       cglSf: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cglSg: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupPredicate1_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cglSv,
                       label: Data.Functor.Contravariant.$fSemigroupPredicate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglSv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglSw; else goto cglSx;
       cglSw: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupPredicate1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglSx: // global
           I64[Sp - 16] = block_cglRU_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uglSD; else goto cglRV;
       uglSD: // global
           call _cglRU(R1) args: 0, res: 0, upd: 0;
       cglRV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglRU() //  [R1]
         { info_tbl: [(cglRU,
                       label: block_cglRU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglRU: // global
           _sgjRZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cglSs; else goto cglSt;
       cglSs: // global
           R1 = _sgjRZ::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cglSt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cglSC; else goto cglSB;
       cglSC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cglSB: // global
           _sgjS2::P64 = P64[R1 + 6];
           _sgjS3::P64 = P64[R1 + 14];
           I64[Hp - 48] = ds_sgjS4_info;
           P64[Hp - 32] = _sgjS2::P64;
           P64[Hp - 24] = _sgjS3::P64;
           I64[Hp - 16] = sat_sgjS7_info;
           P64[Hp - 8] = _sgjRZ::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.472938818 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure:
         const Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_info;
 },
 Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_entry() //  [R2]
         { info_tbl: [(cglTc,
                       label: Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglTc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cglTd; else goto cglTe;
       cglTd: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cglTe: // global
           I64[Sp - 8] = block_cglT9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uglTi; else goto cglTa;
       uglTi: // global
           call _cglT9(R1) args: 0, res: 0, upd: 0;
       cglTa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglT9() //  [R1]
         { info_tbl: [(cglT9,
                       label: block_cglT9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglT9: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Contravariant.$fSemigroupPredicate1_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.478656905 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate2_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate2_closure:
         const Data.Functor.Contravariant.$fMonoidPredicate2_info;
 },
 Data.Functor.Contravariant.$fMonoidPredicate2_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cglTC,
                       label: Data.Functor.Contravariant.$fMonoidPredicate2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglTC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cglTD; else goto cglTE;
       cglTD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidPredicate2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglTE: // global
           I64[Sp - 24] = block_cglTw_info;
           _sgjSc::P64 = R2;
           R2 = R4;
           R1 = _sgjSc::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglTw() //  [R1]
         { info_tbl: [(cglTw,
                       label: block_cglTw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglTw: // global
           if (R1 & 7 == 1) goto cglTz; else goto cglTA;
       cglTz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cglTA: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.484055994 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Functor.Contravariant.$fMonoidPredicate2_closure+3;
         const Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure+1;
         const Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_closure:
         const Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_info;
         const 0;
 },
 Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_entry() //  [R2]
         { info_tbl: [(cglU0,
                       label: Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglU0: // global
           R3 = Data.Functor.Contravariant.$fSemigroupPredicate_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.488804724 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate1_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate1_closure:
         const Data.Functor.Contravariant.$fMonoidPredicate1_info;
 },
 Data.Functor.Contravariant.$fMonoidPredicate1_entry() //  [R2, R3]
         { info_tbl: [(cglUj,
                       label: Data.Functor.Contravariant.$fMonoidPredicate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglUj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cglUk; else goto uglUE;
       cglUk: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidPredicate1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uglUE: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cglU9() args: 0, res: 0, upd: 0;
     }
 },
 _cglU9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglU9: // global
           _sgjSh::P64 = P64[Sp];
           I64[Sp] = block_cglUc_info;
           R1 = _sgjSh::P64;
           if (R1 & 7 != 0) goto uglUG; else goto cglUd;
       uglUG: // global
           call _cglUc(R1) args: 0, res: 0, upd: 0;
       cglUd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglUc() //  [R1]
         { info_tbl: [(cglUc,
                       label: block_cglUc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglUc: // global
           if (R1 & 7 == 1) goto cglUg; else goto cglUh;
       cglUg: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cglUh: // global
           I64[Sp - 8] = block_cglUr_info;
           R2 = P64[Sp + 8];
           _sgjSl::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sgjSl::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglUr() //  [R1]
         { info_tbl: [(cglUr,
                       label: block_cglUr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglUr: // global
           if (R1 & 7 == 1) goto cglUy; else goto cglUC;
       cglUy: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cglUC: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cglU9() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.496809272 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fSemigroupPredicate_closure+1;
         const Data.Functor.Contravariant.$fMonoidPredicate3_closure+1;
         const Data.Functor.Contravariant.$fMonoidPredicate2_closure+3;
         const Data.Functor.Contravariant.$fMonoidPredicate1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.499608471 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_info;
 },
 Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_entry() //  []
         { info_tbl: [(cglVa,
                       label: Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglVa: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.502845143 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProxy_closure" {
     Data.Functor.Contravariant.$fContravariantProxy_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_closure+2;
         const Data.Functor.Contravariant.$fContravariantProxy_$c>$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.504884735 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantCompose2_closure" {
     Data.Functor.Contravariant.$fContravariantCompose2_closure:
         const Data.Functor.Contravariant.$fContravariantCompose2_info;
 },
 sat_sgjSt_entry() //  [R1]
         { info_tbl: [(cglVr,
                       label: sat_sgjSt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglVr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglVs; else goto cglVt;
       cglVs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglVt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantCompose2_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cglVu,
                       label: Data.Functor.Contravariant.$fContravariantCompose2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglVu: // global
           _sgjSs::P64 = R5;
           _sgjSr::P64 = R4;
           _sgjSq::P64 = R3;
           _sgjSp::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cglVv; else goto cglVw;
       cglVw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cglVy; else goto cglVx;
       cglVy: // global
           HpAlloc = 32;
           goto cglVv;
       cglVv: // global
           R5 = _sgjSs::P64;
           R4 = _sgjSr::P64;
           R3 = _sgjSq::P64;
           R2 = _sgjSp::P64;
           R1 = Data.Functor.Contravariant.$fContravariantCompose2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglVx: // global
           I64[Hp - 24] = sat_sgjSt_info;
           P64[Hp - 8] = _sgjSq::P64;
           P64[Hp] = _sgjSr::P64;
           R2 = _sgjSp::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgjSs::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.51145793 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantCompose_closure" {
     Data.Functor.Contravariant.$fContravariantCompose_closure:
         const Data.Functor.Contravariant.$fContravariantCompose_info;
 },
 sat_sgjSx_entry() //  [R1, R2, R3]
         { info_tbl: [(cglVT,
                       label: sat_sgjSx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglVT: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantCompose1_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjSw_entry() //  [R1, R2, R3]
         { info_tbl: [(cglW1,
                       label: sat_sgjSw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglW1: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantCompose2_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantCompose_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cglW5,
                       label: Data.Functor.Contravariant.$fContravariantCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglW5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cglW9; else goto cglW8;
       cglW9: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglW8: // global
           I64[Hp - 64] = sat_sgjSx_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjSw_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.518820142 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantConst2_closure" {
     Data.Functor.Contravariant.$fContravariantConst2_closure:
         const Data.Functor.Contravariant.$fContravariantConst2_info;
 },
 Data.Functor.Contravariant.$fContravariantConst2_entry() //  [R3]
         { info_tbl: [(cglWr,
                       label: Data.Functor.Contravariant.$fContravariantConst2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglWr: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.52210922 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantConst_closure" {
     Data.Functor.Contravariant.$fContravariantConst_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantConst2_closure+2;
         const Data.Functor.Contravariant.$fContravariantConst1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.524519968 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_info;
 },
 sat_sgjSI_entry() //  [R1]
         { info_tbl: [(cglWM,
                       label: sat_sgjSI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglWM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cglWN; else goto cglWO;
       cglWN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglWO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjSH_entry() //  [R1]
         { info_tbl: [(cglWT,
                       label: sat_sgjSH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglWT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cglWU; else goto cglWV;
       cglWU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglWV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_entry() //  [R2,
                                                                            R3, R4, R5]
         { info_tbl: [(cglWW,
                       label: Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglWW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglWY; else goto cglWZ;
       cglWY: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglWZ: // global
           I64[Sp - 32] = block_cglWD_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uglX3; else goto cglWE;
       uglX3: // global
           call _cglWD(R1) args: 0, res: 0, upd: 0;
       cglWE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglWD() //  [R1]
         { info_tbl: [(cglWD,
                       label: block_cglWD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglWD: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cglX2; else goto cglX1;
       cglX2: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cglX1: // global
           _sgjSF::P64 = P64[R1 + 7];
           _sgjSG::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgjSI_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sgjSC::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sgjSC::P64;
           P64[Hp - 64] = _sgjSG::P64;
           I64[Hp - 56] = sat_sgjSH_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgjSC::P64;
           P64[Hp - 24] = _sgjSF::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.535483244 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProduct_closure" {
     Data.Functor.Contravariant.$fContravariantProduct_closure:
         const Data.Functor.Contravariant.$fContravariantProduct_info;
 },
 sat_sgjSM_entry() //  [R1, R2, R3]
         { info_tbl: [(cglXD,
                       label: sat_sgjSM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglXD: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantProduct_$c>$_entry(R5,
                                                                             R4,
                                                                             R3,
                                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjSL_entry() //  [R1, R2, R3]
         { info_tbl: [(cglXL,
                       label: sat_sgjSL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglXL: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_entry(R5,
                                                                                    R4,
                                                                                    R3,
                                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantProduct_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cglXP,
                       label: Data.Functor.Contravariant.$fContravariantProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglXP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cglXT; else goto cglXS;
       cglXT: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglXS: // global
           I64[Hp - 64] = sat_sgjSM_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjSL_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.544070427 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantSum_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantSum_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantSum_$ccontramap_info;
 },
 sat_sgjST_entry() //  [R1]
         { info_tbl: [(cglYk,
                       label: sat_sgjST_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglYk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cglYl; else goto cglYm;
       cglYl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglYm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjSV_entry() //  [R1]
         { info_tbl: [(cglYt,
                       label: sat_sgjSV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglYt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cglYu; else goto cglYv;
       cglYu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglYv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantSum_$ccontramap_entry() //  [R2,
                                                                        R3, R4, R5]
         { info_tbl: [(cglYA,
                       label: Data.Functor.Contravariant.$fContravariantSum_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglYA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cglYB; else goto cglYC;
       cglYB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantSum_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglYC: // global
           I64[Sp - 32] = block_cglYb_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uglYL; else goto cglYc;
       uglYL: // global
           call _cglYb(R1) args: 0, res: 0, upd: 0;
       cglYc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cglYb() //  [R1]
         { info_tbl: [(cglYb,
                       label: block_cglYb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglYb: // global
           _sgjSP::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cglYx; else goto cglYy;
       cglYx: // global
           Hp = Hp + 56;
           _sgjSR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cglYK; else goto cglYF;
       cglYF: // global
           _sgjSS::P64 = P64[_sgjSR::P64 + 7];
           I64[Hp - 48] = sat_sgjST_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgjSP::P64;
           P64[Hp - 16] = _sgjSS::P64;
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cglYy: // global
           Hp = Hp + 56;
           _sgjSR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cglYK; else goto cglYJ;
       cglYK: // global
           HpAlloc = 56;
           R1 = _sgjSR::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cglYJ: // global
           _sgjSU::P64 = P64[_sgjSR::P64 + 6];
           I64[Hp - 48] = sat_sgjSV_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sgjSP::P64;
           P64[Hp - 16] = _sgjSU::P64;
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.555032684 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantSum_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantSum_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantSum_$c>$_info;
 },
 sat_sgjT1_entry() //  [R1]
         { info_tbl: [(cglZo,
                       label: sat_sgjT1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglZo: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantSum_$c>$_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cglZr,
                       label: Data.Functor.Contravariant.$fContravariantSum_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglZr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cglZv; else goto cglZu;
       cglZv: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantSum_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cglZu: // global
           I64[Hp - 8] = sat_sgjT1_info;
           P64[Hp] = R4;
           R5 = R5;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Contravariant.$fContravariantSum_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.560857168 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantSum_closure" {
     Data.Functor.Contravariant.$fContravariantSum_closure:
         const Data.Functor.Contravariant.$fContravariantSum_info;
 },
 sat_sgjT5_entry() //  [R1, R2, R3]
         { info_tbl: [(cglZM,
                       label: sat_sgjT5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglZM: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantSum_$c>$_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjT4_entry() //  [R1, R2, R3]
         { info_tbl: [(cglZU,
                       label: sat_sgjT4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglZU: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantSum_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantSum_entry() //  [R2, R3]
         { info_tbl: [(cglZY,
                       label: Data.Functor.Contravariant.$fContravariantSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglZY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgm02; else goto cgm01;
       cgm02: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgm01: // global
           I64[Hp - 64] = sat_sgjT5_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjT4_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.568926532 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_info;
 },
 sat_sgjTc_entry() //  [R1]
         { info_tbl: [(cgm0t,
                       label: sat_sgjTc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm0t: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgm0u; else goto cgm0v;
       cgm0u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgm0v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjTe_entry() //  [R1]
         { info_tbl: [(cgm0C,
                       label: sat_sgjTe_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm0C: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgm0D; else goto cgm0E;
       cgm0D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgm0E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_entry() //  [R2,
                                                                        R3, R4, R5]
         { info_tbl: [(cgm0J,
                       label: Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm0J: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgm0K; else goto cgm0L;
       cgm0K: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgm0L: // global
           I64[Sp - 32] = block_cgm0k_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugm0U; else goto cgm0l;
       ugm0U: // global
           call _cgm0k(R1) args: 0, res: 0, upd: 0;
       cgm0l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgm0k() //  [R1]
         { info_tbl: [(cgm0k,
                       label: block_cgm0k_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm0k: // global
           _sgjT8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cgm0G; else goto cgm0H;
       cgm0G: // global
           Hp = Hp + 56;
           _sgjTa::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgm0T; else goto cgm0O;
       cgm0O: // global
           _sgjTb::P64 = P64[_sgjTa::P64 + 7];
           I64[Hp - 48] = sat_sgjTc_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgjT8::P64;
           P64[Hp - 16] = _sgjTb::P64;
           I64[Hp - 8] = GHC.Generics.L1_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgm0H: // global
           Hp = Hp + 56;
           _sgjTa::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgm0T; else goto cgm0S;
       cgm0T: // global
           HpAlloc = 56;
           R1 = _sgjTa::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgm0S: // global
           _sgjTd::P64 = P64[_sgjTa::P64 + 6];
           I64[Hp - 48] = sat_sgjTe_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sgjT8::P64;
           P64[Hp - 16] = _sgjTd::P64;
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.580677501 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:+:_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariant:+:_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariant:+:_$c>$_info;
 },
 sat_sgjTk_entry() //  [R1]
         { info_tbl: [(cgm1x,
                       label: sat_sgjTk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm1x: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:+:_$c>$_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgm1A,
                       label: Data.Functor.Contravariant.$fContravariant:+:_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm1A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgm1E; else goto cgm1D;
       cgm1E: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:+:_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgm1D: // global
           I64[Hp - 8] = sat_sgjTk_info;
           P64[Hp] = R4;
           R5 = R5;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.586459413 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:+:_closure" {
     Data.Functor.Contravariant.$fContravariant:+:_closure:
         const Data.Functor.Contravariant.$fContravariant:+:_info;
 },
 sat_sgjTo_entry() //  [R1, R2, R3]
         { info_tbl: [(cgm1V,
                       label: sat_sgjTo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm1V: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:+:_$c>$_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjTn_entry() //  [R1, R2, R3]
         { info_tbl: [(cgm23,
                       label: sat_sgjTn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm23: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:+:_entry() //  [R2, R3]
         { info_tbl: [(cgm27,
                       label: Data.Functor.Contravariant.$fContravariant:+:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm27: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgm2b; else goto cgm2a;
       cgm2b: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:+:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgm2a: // global
           I64[Hp - 64] = sat_sgjTo_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjTn_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.594239782 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:.:2_closure" {
     Data.Functor.Contravariant.$fContravariant:.:2_closure:
         const Data.Functor.Contravariant.$fContravariant:.:2_info;
 },
 sat_sgjTt_entry() //  [R1]
         { info_tbl: [(cgm2x,
                       label: sat_sgjTt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm2x: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgm2y; else goto cgm2z;
       cgm2y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgm2z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:.:2_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cgm2A,
                       label: Data.Functor.Contravariant.$fContravariant:.:2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm2A: // global
           _sgjTs::P64 = R5;
           _sgjTr::P64 = R4;
           _sgjTq::P64 = R3;
           _sgjTp::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgm2B; else goto cgm2C;
       cgm2C: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgm2E; else goto cgm2D;
       cgm2E: // global
           HpAlloc = 32;
           goto cgm2B;
       cgm2B: // global
           R5 = _sgjTs::P64;
           R4 = _sgjTr::P64;
           R3 = _sgjTq::P64;
           R2 = _sgjTp::P64;
           R1 = Data.Functor.Contravariant.$fContravariant:.:2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgm2D: // global
           I64[Hp - 24] = sat_sgjTt_info;
           P64[Hp - 8] = _sgjTq::P64;
           P64[Hp] = _sgjTr::P64;
           R2 = _sgjTp::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgjTs::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.60052673 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:.:_closure" {
     Data.Functor.Contravariant.$fContravariant:.:_closure:
         const Data.Functor.Contravariant.$fContravariant:.:_info;
 },
 sat_sgjTx_entry() //  [R1, R2, R3]
         { info_tbl: [(cgm2Z,
                       label: sat_sgjTx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm2Z: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:.:1_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjTw_entry() //  [R1, R2, R3]
         { info_tbl: [(cgm37,
                       label: sat_sgjTw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm37: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:.:2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:.:_entry() //  [R2, R3]
         { info_tbl: [(cgm3b,
                       label: Data.Functor.Contravariant.$fContravariant:.:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm3b: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgm3f; else goto cgm3e;
       cgm3f: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:.:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgm3e: // global
           I64[Hp - 64] = sat_sgjTx_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjTw_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.608580829 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_info;
 },
 sat_sgjTG_entry() //  [R1]
         { info_tbl: [(cgm3G,
                       label: sat_sgjTG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm3G: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgm3H; else goto cgm3I;
       cgm3H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgm3I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgjTF_entry() //  [R1]
         { info_tbl: [(cgm3N,
                       label: sat_sgjTF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm3N: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgm3O; else goto cgm3P;
       cgm3O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgm3P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_entry() //  [R2,
                                                                        R3, R4, R5]
         { info_tbl: [(cgm3Q,
                       label: Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm3Q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgm3S; else goto cgm3T;
       cgm3S: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgm3T: // global
           I64[Sp - 32] = block_cgm3x_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugm3X; else goto cgm3y;
       ugm3X: // global
           call _cgm3x(R1) args: 0, res: 0, upd: 0;
       cgm3y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgm3x() //  [R1]
         { info_tbl: [(cgm3x,
                       label: block_cgm3x_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm3x: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgm3W; else goto cgm3V;
       cgm3W: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgm3V: // global
           _sgjTD::P64 = P64[R1 + 7];
           _sgjTE::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgjTG_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sgjTA::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sgjTA::P64;
           P64[Hp - 64] = _sgjTE::P64;
           I64[Hp - 56] = sat_sgjTF_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgjTA::P64;
           P64[Hp - 24] = _sgjTD::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.619790194 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:*:_closure" {
     Data.Functor.Contravariant.$fContravariant:*:_closure:
         const Data.Functor.Contravariant.$fContravariant:*:_info;
 },
 sat_sgjTK_entry() //  [R1, R2, R3]
         { info_tbl: [(cgm4x,
                       label: sat_sgjTK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm4x: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:*:_$c>$_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgjTJ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgm4F,
                       label: sat_sgjTJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm4F: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:*:_entry() //  [R2, R3]
         { info_tbl: [(cgm4J,
                       label: Data.Functor.Contravariant.$fContravariant:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm4J: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgm4N; else goto cgm4M;
       cgm4N: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgm4M: // global
           I64[Hp - 64] = sat_sgjTK_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgjTJ_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.627198936 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantK3_closure" {
     Data.Functor.Contravariant.$fContravariantK3_closure:
         const Data.Functor.Contravariant.$fContravariantK3_info;
 },
 Data.Functor.Contravariant.$fContravariantK3_entry() //  [R3]
         { info_tbl: [(cgm55,
                       label: Data.Functor.Contravariant.$fContravariantK3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm55: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.63042644 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantK1_closure" {
     Data.Functor.Contravariant.$fContravariantK1_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantK3_closure+2;
         const Data.Functor.Contravariant.$fContravariantK2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.632351358 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantU1_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantU1_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantU1_$ccontramap_info;
 },
 Data.Functor.Contravariant.$fContravariantU1_$ccontramap_entry() //  []
         { info_tbl: [(cgm5h,
                       label: Data.Functor.Contravariant.$fContravariantU1_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm5h: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.635797012 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantU1_closure" {
     Data.Functor.Contravariant.$fContravariantU1_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantU1_$ccontramap_closure+2;
         const Data.Functor.Contravariant.$fContravariantU1_$c>$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.637656597 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantV1_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantV1_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantV1_$ccontramap_info;
 },
 Data.Functor.Contravariant.$fContravariantV1_$ccontramap_entry() //  [R3]
         { info_tbl: [(cgm5u,
                       label: Data.Functor.Contravariant.$fContravariantV1_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm5u: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.640892908 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantV1_closure" {
     Data.Functor.Contravariant.$fContravariantV1_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantV1_$ccontramap_closure+2;
         const Data.Functor.Contravariant.$fContravariantV1_$c>$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.642894767 UTC

[section ""data" . lvl2_rgjLt_closure" {
     lvl2_rgjLt_closure:
         const lvl2_rgjLt_info;
         const 0;
 },
 lvl2_rgjLt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgm5J,
                       label: lvl2_rgjLt_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm5J: // global
           _sgjTV::P64 = R5;
           _sgjTU::P64 = R4;
           _sgjTT::P64 = R3;
           _sgjTS::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgm5K; else goto cgm5L;
       cgm5L: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgm5N; else goto cgm5M;
       cgm5N: // global
           HpAlloc = 32;
           goto cgm5K;
       cgm5K: // global
           R5 = _sgjTV::P64;
           R4 = _sgjTU::P64;
           R3 = _sgjTT::P64;
           R2 = _sgjTS::P64;
           R1 = lvl2_rgjLt_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgm5M: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgjTU::P64;
           P64[Hp] = _sgjTV::P64;
           R2 = _sgjTS::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgjTT::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.$fSemigroupOrdering_$cstimes_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.648003402 UTC

[section ""data" . lvl3_rgjLu_closure" {
     lvl3_rgjLu_closure:
         const lvl3_rgjLu_info;
         const 0;
 },
 lvl3_rgjLu_entry() //  [R2]
         { info_tbl: [(cgm61,
                       label: lvl3_rgjLu_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm61: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgm62; else goto cgm63;
       cgm62: // global
           R2 = R2;
           R1 = lvl3_rgjLu_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgm63: // global
           I64[Sp - 8] = block_cgm5Y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugm67; else goto cgm5Z;
       ugm67: // global
           call _cgm5Y(R1) args: 0, res: 0, upd: 0;
       cgm5Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgm5Y() //  [R1]
         { info_tbl: [(cgm5Y,
                       label: block_cgm5Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm5Y: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = GHC.Base.$fSemigroupOrdering_closure;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.654409167 UTC

[section ""data" . lvl4_rgjLv_closure" {
     lvl4_rgjLv_closure:
         const lvl4_rgjLv_info;
 },
 lvl4_rgjLv_entry() //  [R2, R3, R4]
         { info_tbl: [(cgm6s,
                       label: lvl4_rgjLv_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm6s: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgm6t; else goto cgm6u;
       cgm6t: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl4_rgjLv_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgm6u: // global
           I64[Sp - 24] = block_cgm6l_info;
           _sgjU1::P64 = R2;
           R2 = R4;
           R1 = _sgjU1::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgm6l() //  [R1]
         { info_tbl: [(cgm6l,
                       label: block_cgm6l_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm6l: // global
           _cgm6r::P64 = R1 & 7;
           if (_cgm6r::P64 < 3) goto ugm6E; else goto cgm6q;
       ugm6E: // global
           if (_cgm6r::P64 < 2) goto cgm6o; else goto cgm6p;
       cgm6o: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgm6p: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cgm6q: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.659954518 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure" {
     Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure:
         const GHC.Base.C:Semigroup_con_info;
         const lvl4_rgjLv_closure+3;
         const lvl3_rgjLu_closure+1;
         const lvl2_rgjLt_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.662321208 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison2_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison2_closure:
         const Data.Functor.Contravariant.$fSemigroupComparison2_info;
         const 0;
 },
 Data.Functor.Contravariant.$fSemigroupComparison2_entry() //  [R2]
         { info_tbl: [(cgm6Y,
                       label: Data.Functor.Contravariant.$fSemigroupComparison2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm6Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgm6Z; else goto cgm70;
       cgm6Z: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupComparison2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgm70: // global
           I64[Sp - 8] = block_cgm6V_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugm74; else goto cgm6W;
       ugm74: // global
           call _cgm6V(R1) args: 0, res: 0, upd: 0;
       cgm6W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgm6V() //  [R1]
         { info_tbl: [(cgm6V,
                       label: block_cgm6V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm6V: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure+1;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.667440942 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Functor.Contravariant.$fSemigroupComparison3_closure+3;
         const Data.Functor.Contravariant.$fSemigroupComparison2_closure+1;
         const Data.Functor.Contravariant.$fSemigroupComparison1_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.669420822 UTC

[section ""data" . lvl5_rgjLw_closure" {
     lvl5_rgjLw_closure:
         const lvl5_rgjLw_info;
 },
 lvl5_rgjLw_entry() //  []
         { info_tbl: [(cgm7j,
                       label: lvl5_rgjLw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm7j: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.672581423 UTC

[section ""data" . lvl6_rgjLx_closure" {
     lvl6_rgjLx_closure:
         const lvl6_rgjLx_info;
         const 0;
 },
 lvl6_rgjLx_entry() //  [R2, R3]
         { info_tbl: [(cgm7v,
                       label: lvl6_rgjLx_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm7v: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.$fMonoidOrdering_closure;
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.675829041 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure" {
     Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure+1;
         const lvl5_rgjLw_closure+1;
         const lvl4_rgjLv_closure+3;
         const lvl6_rgjLx_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.677753739 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison1_closure" {
     Data.Functor.Contravariant.$fMonoidComparison1_closure:
         const Data.Functor.Contravariant.$fMonoidComparison1_info;
         const 0;
 },
 Data.Functor.Contravariant.$fMonoidComparison1_entry() //  [R2, R3]
         { info_tbl: [(cgm7H,
                       label: Data.Functor.Contravariant.$fMonoidComparison1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm7H: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure+1;
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.681701637 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison_closure" {
     Data.Functor.Contravariant.$fMonoidComparison_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fSemigroupComparison_closure+1;
         const Data.Functor.Contravariant.$fMonoidComparison3_closure+2;
         const Data.Functor.Contravariant.$fMonoidComparison2_closure+3;
         const Data.Functor.Contravariant.$fMonoidComparison1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.683764285 UTC

[section ""data" . Data.Functor.Contravariant.C:Contravariant_closure" {
     Data.Functor.Contravariant.C:Contravariant_closure:
         const Data.Functor.Contravariant.C:Contravariant_info;
 },
 Data.Functor.Contravariant.C:Contravariant_entry() //  [R2, R3]
         { info_tbl: [(cgm7U,
                       label: Data.Functor.Contravariant.C:Contravariant_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm7U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgm7Y; else goto cgm7X;
       cgm7Y: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.C:Contravariant_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgm7X: // global
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.687842844 UTC

[Data.Functor.Contravariant.C:Contravariant_con_entry() //  [R1]
         { info_tbl: [(cgm84,
                       label: Data.Functor.Contravariant.C:Contravariant_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,110,116,114,97,118,97,114,105,97,110,116,46,67,58,67,111,110,116,114,97,118,97,114,105,97,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm84: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:14.690979053 UTC

[section ""relreadonly" . Sgk42_srt" {
     Sgk42_srt:
         const GHC.Base.$fSemigroupOrdering_$cstimes_closure;
         const Data.Functor.Contravariant.$fSemigroupComparison1_closure;
         const sat_sgjO7_closure;
         const lvl1_rgjLs_closure;
         const lvl_rgjLr_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure;
         const Data.Functor.Contravariant.$fNumOp_$cnegate_closure;
         const Data.Functor.Contravariant.$fNumOp_closure;
         const Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure;
         const Data.Functor.Contravariant.$fFractionalOp_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure;
         const Data.Functor.Contravariant.$fFloatingOp_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_closure;
         const Data.Functor.Contravariant.$fSemigroupPredicate_closure;
         const lvl2_rgjLt_closure;
         const GHC.Base.$fSemigroupOrdering_closure;
         const lvl3_rgjLu_closure;
         const Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure;
         const Data.Functor.Contravariant.$fSemigroupComparison2_closure;
         const GHC.Base.$fMonoidOrdering_closure;
         const Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.687599839 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:16.689084151 UTC

[section ""data" . Data.Functor.Contravariant.contramap_closure" {
     Data.Functor.Contravariant.contramap_closure:
         const Data.Functor.Contravariant.contramap_info;
 },
 Data.Functor.Contravariant.contramap_entry() //  [R2]
         { info_tbl: [(cgmgT,
                       label: Data.Functor.Contravariant.contramap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmgT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgmgU; else goto cgmgV;
       cgmgU: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.contramap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmgV: // global
           I64[Sp - 8] = block_cgmgQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugmgZ; else goto cgmgR;
       ugmgZ: // global
           call _cgmgQ(R1) args: 0, res: 0, upd: 0;
       cgmgR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgmgQ() //  [R1]
         { info_tbl: [(cgmgQ,
                       label: block_cgmgQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmgQ: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.69501447 UTC

[section ""data" . Data.Functor.Contravariant.>$_closure" {
     Data.Functor.Contravariant.>$_closure:
         const Data.Functor.Contravariant.>$_info;
 },
 Data.Functor.Contravariant.>$_entry() //  [R2]
         { info_tbl: [(cgmhh,
                       label: Data.Functor.Contravariant.>$_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmhh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgmhi; else goto cgmhj;
       cgmhi: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.>$_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmhj: // global
           I64[Sp - 8] = block_cgmhe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugmhn; else goto cgmhf;
       ugmhn: // global
           call _cgmhe(R1) args: 0, res: 0, upd: 0;
       cgmhf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgmhe() //  [R1]
         { info_tbl: [(cgmhe,
                       label: block_cgmhe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmhe: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.700584865 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Op3_bytes" {
     Data.Functor.Contravariant.$tc'Op3_bytes:
         I8[] [39,79,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.702401248 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Op2_closure" {
     Data.Functor.Contravariant.$tc'Op2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Op3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.704355611 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcOp2_bytes" {
     Data.Functor.Contravariant.$tcOp2_bytes:
         I8[] [79,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.706279543 UTC

[section ""data" . Data.Functor.Contravariant.$tcOp1_closure" {
     Data.Functor.Contravariant.$tcOp1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcOp2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.708084135 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Equivalence3_bytes" {
     Data.Functor.Contravariant.$tc'Equivalence3_bytes:
         I8[] [39,69,113,117,105,118,97,108,101,110,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.710963063 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Equivalence2_closure" {
     Data.Functor.Contravariant.$tc'Equivalence2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Equivalence3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.712723885 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcEquivalence2_bytes" {
     Data.Functor.Contravariant.$tcEquivalence2_bytes:
         I8[] [69,113,117,105,118,97,108,101,110,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.714512763 UTC

[section ""data" . Data.Functor.Contravariant.$tcEquivalence1_closure" {
     Data.Functor.Contravariant.$tcEquivalence1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcEquivalence2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.71624133 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Comparison3_bytes" {
     Data.Functor.Contravariant.$tc'Comparison3_bytes:
         I8[] [39,67,111,109,112,97,114,105,115,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.718379631 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Comparison2_closure" {
     Data.Functor.Contravariant.$tc'Comparison2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Comparison3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.720132673 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcComparison2_bytes" {
     Data.Functor.Contravariant.$tcComparison2_bytes:
         I8[] [67,111,109,112,97,114,105,115,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.721954266 UTC

[section ""data" . Data.Functor.Contravariant.$tcComparison1_closure" {
     Data.Functor.Contravariant.$tcComparison1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcComparison2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.723792537 UTC

[section ""cstring" . Data.Functor.Contravariant.$tc'Predicate3_bytes" {
     Data.Functor.Contravariant.$tc'Predicate3_bytes:
         I8[] [39,80,114,101,100,105,99,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.725821122 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Predicate2_closure" {
     Data.Functor.Contravariant.$tc'Predicate2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tc'Predicate3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.727603598 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcPredicate2_bytes" {
     Data.Functor.Contravariant.$tcPredicate2_bytes:
         I8[] [80,114,101,100,105,99,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.729371337 UTC

[section ""data" . Data.Functor.Contravariant.$tcPredicate1_closure" {
     Data.Functor.Contravariant.$tcPredicate1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcPredicate2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.731170144 UTC

[section ""cstring" . Data.Functor.Contravariant.$tcContravariant3_bytes" {
     Data.Functor.Contravariant.$tcContravariant3_bytes:
         I8[] [67,111,110,116,114,97,118,97,114,105,97,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.732926318 UTC

[section ""data" . Data.Functor.Contravariant.$tcContravariant2_closure" {
     Data.Functor.Contravariant.$tcContravariant2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$tcContravariant3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.734749532 UTC

[section ""data" . $krep_rgjLa_closure" {
     $krep_rgjLa_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.736999567 UTC

[section ""data" . $krep1_rgjLb_closure" {
     $krep1_rgjLb_closure:
         const :_con_info;
         const $krep_rgjLa_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.739085267 UTC

[section ""data" . $krep2_rgjLc_closure" {
     $krep2_rgjLc_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.740865463 UTC

[section ""data" . $krep3_rgjLd_closure" {
     $krep3_rgjLd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rgjLc_closure+2;
         const $krep_rgjLa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.742645961 UTC

[section ""data" . $krep4_rgjLe_closure" {
     $krep4_rgjLe_closure:
         const :_con_info;
         const $krep2_rgjLc_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.744406862 UTC

[section ""data" . $krep5_rgjLf_closure" {
     $krep5_rgjLf_closure:
         const :_con_info;
         const $krep_rgjLa_closure+2;
         const $krep4_rgjLe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.746242605 UTC

[section ""data" . $krep6_rgjLg_closure" {
     $krep6_rgjLg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.7480178 UTC

[section ""data" . $krep7_rgjLh_closure" {
     $krep7_rgjLh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep6_rgjLg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.75014544 UTC

[section ""data" . $krep8_rgjLi_closure" {
     $krep8_rgjLi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep7_rgjLh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.75187784 UTC

[section ""data" . $krep9_rgjLj_closure" {
     $krep9_rgjLj_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcOrdering_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.75358765 UTC

[section ""data" . $krep10_rgjLk_closure" {
     $krep10_rgjLk_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep9_rgjLj_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.755367265 UTC

[section ""data" . $krep11_rgjLl_closure" {
     $krep11_rgjLl_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgjLa_closure+2;
         const $krep10_rgjLk_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.757103062 UTC

[section ""data" . $krep12_rgjLm_closure" {
     $krep12_rgjLm_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.758923839 UTC

[section ""data" . Data.Functor.Contravariant.$tcContravariant1_closure" {
     Data.Functor.Contravariant.$tcContravariant1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep12_rgjLm_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.760775898 UTC

[section ""cstring" . Data.Functor.Contravariant.$trModule2_bytes" {
     Data.Functor.Contravariant.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,110,116,114,97,118,97,114,105,97,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.763098545 UTC

[section ""data" . Data.Functor.Contravariant.$trModule1_closure" {
     Data.Functor.Contravariant.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.764770209 UTC

[section ""cstring" . Data.Functor.Contravariant.$trModule4_bytes" {
     Data.Functor.Contravariant.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.766489169 UTC

[section ""data" . Data.Functor.Contravariant.$trModule3_closure" {
     Data.Functor.Contravariant.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Contravariant.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.768262176 UTC

[section ""data" . Data.Functor.Contravariant.$trModule_closure" {
     Data.Functor.Contravariant.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Contravariant.$trModule3_closure+1;
         const Data.Functor.Contravariant.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.7700957 UTC

[section ""data" . Data.Functor.Contravariant.$tcContravariant_closure" {
     Data.Functor.Contravariant.$tcContravariant_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcContravariant2_closure+1;
         const Data.Functor.Contravariant.$tcContravariant1_closure+4;
         const 1944710495430526909;
         const 15571985404928937498;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.772032728 UTC

[section ""data" . Data.Functor.Contravariant.$tcPredicate_closure" {
     Data.Functor.Contravariant.$tcPredicate_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcPredicate1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 9927645946720114643;
         const 17478425232619398566;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.774022095 UTC

[section ""data" . $krep13_rgjLn_closure" {
     $krep13_rgjLn_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcPredicate_closure+1;
         const $krep1_rgjLb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.775820651 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Predicate1_closure" {
     Data.Functor.Contravariant.$tc'Predicate1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rgjLh_closure+4;
         const $krep13_rgjLn_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.778046299 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Predicate_closure" {
     Data.Functor.Contravariant.$tc'Predicate_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Predicate2_closure+1;
         const Data.Functor.Contravariant.$tc'Predicate1_closure+4;
         const 10560326927625189840;
         const 8988710799443424590;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.779986305 UTC

[section ""data" . Data.Functor.Contravariant.$tcComparison_closure" {
     Data.Functor.Contravariant.$tcComparison_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcComparison1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 8128667979445988110;
         const 9034904213662261762;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.781896129 UTC

[section ""data" . $krep14_rgjLo_closure" {
     $krep14_rgjLo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcComparison_closure+1;
         const $krep1_rgjLb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.783687842 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Comparison1_closure" {
     Data.Functor.Contravariant.$tc'Comparison1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_rgjLl_closure+4;
         const $krep14_rgjLo_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.785915331 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Comparison_closure" {
     Data.Functor.Contravariant.$tc'Comparison_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Comparison2_closure+1;
         const Data.Functor.Contravariant.$tc'Comparison1_closure+4;
         const 11047345948274903716;
         const 12707949450550295743;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.787893125 UTC

[section ""data" . Data.Functor.Contravariant.$tcEquivalence_closure" {
     Data.Functor.Contravariant.$tcEquivalence_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcEquivalence1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 9646573079009549553;
         const 12303965936368510845;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.789873218 UTC

[section ""data" . $krep15_rgjLp_closure" {
     $krep15_rgjLp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcEquivalence_closure+1;
         const $krep1_rgjLb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.792159271 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Equivalence1_closure" {
     Data.Functor.Contravariant.$tc'Equivalence1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rgjLi_closure+4;
         const $krep15_rgjLp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.793944416 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Equivalence_closure" {
     Data.Functor.Contravariant.$tc'Equivalence_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Equivalence2_closure+1;
         const Data.Functor.Contravariant.$tc'Equivalence1_closure+4;
         const 5667737350508967909;
         const 15093804341312440267;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.795820319 UTC

[section ""data" . Data.Functor.Contravariant.$tcOp_closure" {
     Data.Functor.Contravariant.$tcOp_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tcOp1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 13209106975460307324;
         const 7546944290236364550;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.798803986 UTC

[section ""data" . $krep16_rgjLq_closure" {
     $krep16_rgjLq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Contravariant.$tcOp_closure+1;
         const $krep5_rgjLf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.800526528 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Op1_closure" {
     Data.Functor.Contravariant.$tc'Op1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rgjLd_closure+4;
         const $krep16_rgjLq_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.802250224 UTC

[section ""data" . Data.Functor.Contravariant.$tc'Op_closure" {
     Data.Functor.Contravariant.$tc'Op_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Contravariant.$trModule_closure+1;
         const Data.Functor.Contravariant.$tc'Op2_closure+1;
         const Data.Functor.Contravariant.$tc'Op1_closure+4;
         const 12479862397628491530;
         const 1381176546464080972;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.804471288 UTC

[section ""data" . Data.Functor.Contravariant.comparisonEquivalence1_closure" {
     Data.Functor.Contravariant.comparisonEquivalence1_closure:
         const Data.Functor.Contravariant.comparisonEquivalence1_info;
 },
 Data.Functor.Contravariant.comparisonEquivalence1_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cgmiA,
                       label: Data.Functor.Contravariant.comparisonEquivalence1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmiA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgmiB; else goto cgmiC;
       cgmiB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.comparisonEquivalence1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmiC: // global
           I64[Sp - 8] = block_cgmiu_info;
           _sgm8k::P64 = R3;
           R3 = R4;
           _sgm8j::P64 = R2;
           R2 = _sgm8k::P64;
           R1 = _sgm8j::P64;
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgmiu() //  [R1]
         { info_tbl: [(cgmiu,
                       label: block_cgmiu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmiu: // global
           if (R1 & 7 == 2) goto cgmiy; else goto cgmix;
       cgmiy: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgmix: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.810265492 UTC

[section ""data" . Data.Functor.Contravariant.comparisonEquivalence_closure" {
     Data.Functor.Contravariant.comparisonEquivalence_closure:
         const Data.Functor.Contravariant.comparisonEquivalence_info;
 },
 Data.Functor.Contravariant.comparisonEquivalence_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgmj2,
                       label: Data.Functor.Contravariant.comparisonEquivalence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmj2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Contravariant.comparisonEquivalence1_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.81399424 UTC

[section ""data" . Data.Functor.Contravariant.defaultEquivalence_closure" {
     Data.Functor.Contravariant.defaultEquivalence_closure:
         const Data.Functor.Contravariant.defaultEquivalence_info;
 },
 Data.Functor.Contravariant.defaultEquivalence_entry() //  [R2]
         { info_tbl: [(cgmjd,
                       label: Data.Functor.Contravariant.defaultEquivalence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmjd: // global
           R2 = R2;
           call GHC.Classes.==_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.817380349 UTC

[section ""data" . Data.Functor.Contravariant.defaultComparison_closure" {
     Data.Functor.Contravariant.defaultComparison_closure:
         const Data.Functor.Contravariant.defaultComparison_info;
 },
 Data.Functor.Contravariant.defaultComparison_entry() //  [R2]
         { info_tbl: [(cgmjo,
                       label: Data.Functor.Contravariant.defaultComparison_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmjo: // global
           R2 = R2;
           call GHC.Classes.compare_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.821520393 UTC

[section ""data" . Data.Functor.Contravariant.>$$<_closure" {
     Data.Functor.Contravariant.>$$<_closure:
         const Data.Functor.Contravariant.>$$<_info;
 },
 Data.Functor.Contravariant.>$$<_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmjz,
                       label: Data.Functor.Contravariant.>$$<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmjz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgmjA; else goto cgmjB;
       cgmjA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.>$$<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmjB: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.825522543 UTC

[section ""data" . Data.Functor.Contravariant.>$<_closure" {
     Data.Functor.Contravariant.>$<_closure:
         const Data.Functor.Contravariant.>$<_info;
 },
 Data.Functor.Contravariant.>$<_entry() //  [R2]
         { info_tbl: [(cgmjM,
                       label: Data.Functor.Contravariant.>$<_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmjM: // global
           R2 = R2;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.829155582 UTC

[section ""data" . Data.Functor.Contravariant.phantom_closure" {
     Data.Functor.Contravariant.phantom_closure:
         const Data.Functor.Contravariant.phantom_info;
 },
 sat_sgm8u_entry() //  [R1]
         { info_tbl: [(cgmk1,
                       label: sat_sgm8u_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmk1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgmk2; else goto cgmk3;
       cgmk2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmk3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Tuple.()_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.<$_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.phantom_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmk4,
                       label: Data.Functor.Contravariant.phantom_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmk4: // global
           _sgm8t::P64 = R4;
           _sgm8s::P64 = R3;
           _sgm8r::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgmk5; else goto cgmk6;
       cgmk6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmk8; else goto cgmk7;
       cgmk8: // global
           HpAlloc = 32;
           goto cgmk5;
       cgmk5: // global
           R4 = _sgm8t::P64;
           R3 = _sgm8s::P64;
           R2 = _sgm8r::P64;
           R1 = Data.Functor.Contravariant.phantom_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmk7: // global
           I64[Hp - 24] = sat_sgm8u_info;
           P64[Hp - 8] = _sgm8r::P64;
           P64[Hp] = _sgm8t::P64;
           R2 = _sgm8s::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = GHC.Tuple.()_closure+1;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Functor.Contravariant.>$_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.835529829 UTC

[section ""data" . Data.Functor.Contravariant.$<_closure" {
     Data.Functor.Contravariant.$<_closure:
         const Data.Functor.Contravariant.$<_info;
 },
 Data.Functor.Contravariant.$<_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmkw,
                       label: Data.Functor.Contravariant.$<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmkw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgmkx; else goto cgmky;
       cgmkx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmky: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Data.Functor.Contravariant.>$_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.839863813 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantOp1_closure" {
     Data.Functor.Contravariant.$fContravariantOp1_closure:
         const Data.Functor.Contravariant.$fContravariantOp1_info;
 },
 Data.Functor.Contravariant.$fContravariantOp1_entry() //  [R2, R3]
         { info_tbl: [(cgmkJ,
                       label: Data.Functor.Contravariant.$fContravariantOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmkJ: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.843259183 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantOp2_closure" {
     Data.Functor.Contravariant.$fContravariantOp2_closure:
         const Data.Functor.Contravariant.$fContravariantOp2_info;
 },
 Data.Functor.Contravariant.$fContravariantOp2_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgmkU,
                       label: Data.Functor.Contravariant.$fContravariantOp2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmkU: // global
           R4 = R4;
           _sgm8C::P64 = R3;
           R3 = R2;
           R2 = _sgm8C::P64;
           call GHC.Base.._entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.846730988 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantOp_closure" {
     Data.Functor.Contravariant.$fContravariantOp_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantOp2_closure+3;
         const Data.Functor.Contravariant.$fContravariantOp1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.848695027 UTC

[section ""data" . Data.Functor.Contravariant.getOp1_closure" {
     Data.Functor.Contravariant.getOp1_closure:
         const Data.Functor.Contravariant.getOp1_info;
 },
 Data.Functor.Contravariant.getOp1_entry() //  [R2]
         { info_tbl: [(cgml6,
                       label: Data.Functor.Contravariant.getOp1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgml6: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.852613111 UTC

[section ""data" . Data.Functor.Contravariant.getOp_closure" {
     Data.Functor.Contravariant.getOp_closure:
         const Data.Functor.Contravariant.getOp_info;
 },
 Data.Functor.Contravariant.getOp_entry() //  [R2]
         { info_tbl: [(cgmlh,
                       label: Data.Functor.Contravariant.getOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmlh: // global
           R2 = R2;
           call Data.Functor.Contravariant.getOp1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.856526877 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantEquivalence1_closure" {
     Data.Functor.Contravariant.$fContravariantEquivalence1_closure:
         const Data.Functor.Contravariant.$fContravariantEquivalence1_info;
 },
 Data.Functor.Contravariant.$fContravariantEquivalence1_entry() //  [R2,
                                                                     R3]
         { info_tbl: [(cgmls,
                       label: Data.Functor.Contravariant.$fContravariantEquivalence1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmls: // global
           _sgm8F::P64 = R3;
           R3 = R2;
           R2 = R2;
           R1 = _sgm8F::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.860116038 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantEquivalence2_closure" {
     Data.Functor.Contravariant.$fContravariantEquivalence2_closure:
         const Data.Functor.Contravariant.$fContravariantEquivalence2_info;
 },
 Data.Functor.Contravariant.$fContravariantEquivalence2_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cgmlF,
                       label: Data.Functor.Contravariant.$fContravariantEquivalence2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmlF: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgmlJ; else goto cgmlI;
       cgmlJ: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantEquivalence2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmlI: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _sgm8J::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 24;
           R1 = _sgm8J::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.864184848 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantEquivalence_closure" {
     Data.Functor.Contravariant.$fContravariantEquivalence_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantEquivalence2_closure+4;
         const Data.Functor.Contravariant.$fContravariantEquivalence1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.866578225 UTC

[section ""data" . Data.Functor.Contravariant.getEquivalence1_closure" {
     Data.Functor.Contravariant.getEquivalence1_closure:
         const Data.Functor.Contravariant.getEquivalence1_info;
 },
 Data.Functor.Contravariant.getEquivalence1_entry() //  [R2]
         { info_tbl: [(cgmlV,
                       label: Data.Functor.Contravariant.getEquivalence1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmlV: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.869949043 UTC

[section ""data" . Data.Functor.Contravariant.getEquivalence_closure" {
     Data.Functor.Contravariant.getEquivalence_closure:
         const Data.Functor.Contravariant.getEquivalence_info;
 },
 Data.Functor.Contravariant.getEquivalence_entry() //  [R2]
         { info_tbl: [(cgmm6,
                       label: Data.Functor.Contravariant.getEquivalence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmm6: // global
           R2 = R2;
           call Data.Functor.Contravariant.getEquivalence1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.873689185 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantComparison1_closure" {
     Data.Functor.Contravariant.$fContravariantComparison1_closure:
         const Data.Functor.Contravariant.$fContravariantComparison1_info;
 },
 Data.Functor.Contravariant.$fContravariantComparison1_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cgmmh,
                       label: Data.Functor.Contravariant.$fContravariantComparison1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmmh: // global
           _sgm8Q::P64 = R3;
           R3 = R2;
           R2 = R2;
           R1 = _sgm8Q::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.877168811 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantComparison2_closure" {
     Data.Functor.Contravariant.$fContravariantComparison2_closure:
         const Data.Functor.Contravariant.$fContravariantComparison2_info;
 },
 Data.Functor.Contravariant.$fContravariantComparison2_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cgmmu,
                       label: Data.Functor.Contravariant.$fContravariantComparison2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmmu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgmmy; else goto cgmmx;
       cgmmy: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantComparison2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmmx: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _sgm8U::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 24;
           R1 = _sgm8U::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.881163491 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantComparison_closure" {
     Data.Functor.Contravariant.$fContravariantComparison_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantComparison2_closure+4;
         const Data.Functor.Contravariant.$fContravariantComparison1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.883178228 UTC

[section ""data" . Data.Functor.Contravariant.getComparison1_closure" {
     Data.Functor.Contravariant.getComparison1_closure:
         const Data.Functor.Contravariant.getComparison1_info;
 },
 Data.Functor.Contravariant.getComparison1_entry() //  [R2]
         { info_tbl: [(cgmmK,
                       label: Data.Functor.Contravariant.getComparison1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmmK: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.887305674 UTC

[section ""data" . Data.Functor.Contravariant.getComparison_closure" {
     Data.Functor.Contravariant.getComparison_closure:
         const Data.Functor.Contravariant.getComparison_info;
 },
 Data.Functor.Contravariant.getComparison_entry() //  [R2]
         { info_tbl: [(cgmmV,
                       label: Data.Functor.Contravariant.getComparison_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmmV: // global
           R2 = R2;
           call Data.Functor.Contravariant.getComparison1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.890542403 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantPredicate1_closure" {
     Data.Functor.Contravariant.$fContravariantPredicate1_closure:
         const Data.Functor.Contravariant.$fContravariantPredicate1_info;
 },
 Data.Functor.Contravariant.$fContravariantPredicate1_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cgmn6,
                       label: Data.Functor.Contravariant.$fContravariantPredicate1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmn6: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.893981873 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantPredicate2_closure" {
     Data.Functor.Contravariant.$fContravariantPredicate2_closure:
         const Data.Functor.Contravariant.$fContravariantPredicate2_info;
 },
 Data.Functor.Contravariant.$fContravariantPredicate2_entry() //  [R2,
                                                                   R3, R4]
         { info_tbl: [(cgmnh,
                       label: Data.Functor.Contravariant.$fContravariantPredicate2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmnh: // global
           R4 = R4;
           _sgm94::P64 = R3;
           R3 = R2;
           R2 = _sgm94::P64;
           call GHC.Base.._entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.897459005 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantPredicate_closure" {
     Data.Functor.Contravariant.$fContravariantPredicate_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantPredicate2_closure+3;
         const Data.Functor.Contravariant.$fContravariantPredicate1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.899442932 UTC

[section ""data" . Data.Functor.Contravariant.getPredicate1_closure" {
     Data.Functor.Contravariant.getPredicate1_closure:
         const Data.Functor.Contravariant.getPredicate1_info;
 },
 Data.Functor.Contravariant.getPredicate1_entry() //  [R2]
         { info_tbl: [(cgmnt,
                       label: Data.Functor.Contravariant.getPredicate1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmnt: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.90297207 UTC

[section ""data" . Data.Functor.Contravariant.getPredicate_closure" {
     Data.Functor.Contravariant.getPredicate_closure:
         const Data.Functor.Contravariant.getPredicate_info;
 },
 Data.Functor.Contravariant.getPredicate_entry() //  [R2]
         { info_tbl: [(cgmnE,
                       label: Data.Functor.Contravariant.getPredicate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmnE: // global
           R2 = R2;
           call Data.Functor.Contravariant.getPredicate1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.90639308 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantV1_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantV1_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantV1_$c>$_info;
 },
 Data.Functor.Contravariant.$fContravariantV1_$c>$_entry() //  [R3]
         { info_tbl: [(cgmnP,
                       label: Data.Functor.Contravariant.$fContravariantV1_$c>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmnP: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.909757593 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantU1_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantU1_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantU1_$c>$_info;
 },
 Data.Functor.Contravariant.$fContravariantU1_$c>$_entry() //  []
         { info_tbl: [(cgmo2,
                       label: Data.Functor.Contravariant.$fContravariantU1_$c>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmo2: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.913200689 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantK2_closure" {
     Data.Functor.Contravariant.$fContravariantK2_closure:
         const Data.Functor.Contravariant.$fContravariantK2_info;
 },
 Data.Functor.Contravariant.$fContravariantK2_entry() //  [R3]
         { info_tbl: [(cgmof,
                       label: Data.Functor.Contravariant.$fContravariantK2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmof: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.917739491 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:*:_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariant:*:_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariant:*:_$c>$_info;
 },
 f1_sgm9k_entry() //  [R1]
         { info_tbl: [(cgmoA,
                       label: f1_sgm9k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmoA: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgm9n_entry() //  [R1]
         { info_tbl: [(cgmoH,
                       label: sat_sgm9n_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmoH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgmoI; else goto cgmoJ;
       cgmoI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmoJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgm9m_entry() //  [R1]
         { info_tbl: [(cgmoO,
                       label: sat_sgm9m_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmoO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgmoP; else goto cgmoQ;
       cgmoP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmoQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:*:_$c>$_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgmoR,
                       label: Data.Functor.Contravariant.$fContravariant:*:_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmoR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgmoT; else goto cgmoU;
       cgmoT: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:*:_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmoU: // global
           I64[Sp - 32] = block_cgmoq_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugmoY; else goto cgmor;
       ugmoY: // global
           call _cgmoq(R1) args: 0, res: 0, upd: 0;
       cgmor: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgmoq() //  [R1]
         { info_tbl: [(cgmoq,
                       label: block_cgmoq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmoq: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cgmoX; else goto cgmoW;
       cgmoX: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgmoW: // global
           _sgm9i::P64 = P64[R1 + 7];
           _sgm9j::P64 = P64[R1 + 15];
           I64[Hp - 112] = f1_sgm9k_info;
           P64[Hp - 104] = P64[Sp + 24];
           I64[Hp - 96] = sat_sgm9n_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sgm9j::P64;
           _cgmov::P64 = Hp - 111;
           P64[Hp - 64] = _cgmov::P64;
           I64[Hp - 56] = sat_sgm9m_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgm9i::P64;
           P64[Hp - 24] = _cgmov::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.930525105 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:.:1_closure" {
     Data.Functor.Contravariant.$fContravariant:.:1_closure:
         const Data.Functor.Contravariant.$fContravariant:.:1_info;
 },
 sat_sgm9t_entry() //  [R1]
         { info_tbl: [(cgmpP,
                       label: sat_sgm9t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmpP: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgm9u_entry() //  [R1]
         { info_tbl: [(cgmpS,
                       label: sat_sgm9u_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmpS: // global
           _sgm9u::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgmpT; else goto cgmpU;
       cgmpU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgmpW; else goto cgmpV;
       cgmpW: // global
           HpAlloc = 16;
           goto cgmpT;
       cgmpT: // global
           R1 = _sgm9u::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmpV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgm9u::P64;
           _sgm9p::P64 = P64[_sgm9u::P64 + 16];
           _sgm9q::P64 = P64[_sgm9u::P64 + 24];
           I64[Hp - 8] = sat_sgm9t_info;
           P64[Hp] = _sgm9q::P64;
           R2 = _sgm9p::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:.:1_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cgmpX,
                       label: Data.Functor.Contravariant.$fContravariant:.:1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmpX: // global
           _sgm9r::P64 = R5;
           _sgm9q::P64 = R4;
           _sgm9p::P64 = R3;
           _sgm9o::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgmpY; else goto cgmpZ;
       cgmpZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmq1; else goto cgmq0;
       cgmq1: // global
           HpAlloc = 32;
           goto cgmpY;
       cgmpY: // global
           R5 = _sgm9r::P64;
           R4 = _sgm9q::P64;
           R3 = _sgm9p::P64;
           R2 = _sgm9o::P64;
           R1 = Data.Functor.Contravariant.$fContravariant:.:1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmq0: // global
           I64[Hp - 24] = sat_sgm9u_info;
           P64[Hp - 8] = _sgm9p::P64;
           P64[Hp] = _sgm9q::P64;
           R2 = _sgm9o::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgm9r::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.939229377 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProduct_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantProduct_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantProduct_$c>$_info;
 },
 f1_sgm9C_entry() //  [R1]
         { info_tbl: [(cgmqz,
                       label: f1_sgm9C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmqz: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgm9F_entry() //  [R1]
         { info_tbl: [(cgmqG,
                       label: sat_sgm9F_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmqG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgmqH; else goto cgmqI;
       cgmqH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmqI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgm9E_entry() //  [R1]
         { info_tbl: [(cgmqN,
                       label: sat_sgm9E_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmqN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgmqO; else goto cgmqP;
       cgmqO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmqP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantProduct_$c>$_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cgmqQ,
                       label: Data.Functor.Contravariant.$fContravariantProduct_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmqQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgmqS; else goto cgmqT;
       cgmqS: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantProduct_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmqT: // global
           I64[Sp - 32] = block_cgmqp_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugmqX; else goto cgmqq;
       ugmqX: // global
           call _cgmqp(R1) args: 0, res: 0, upd: 0;
       cgmqq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgmqp() //  [R1]
         { info_tbl: [(cgmqp,
                       label: block_cgmqp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmqp: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cgmqW; else goto cgmqV;
       cgmqW: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgmqV: // global
           _sgm9A::P64 = P64[R1 + 7];
           _sgm9B::P64 = P64[R1 + 15];
           I64[Hp - 112] = f1_sgm9C_info;
           P64[Hp - 104] = P64[Sp + 24];
           I64[Hp - 96] = sat_sgm9F_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sgm9B::P64;
           _cgmqu::P64 = Hp - 111;
           P64[Hp - 64] = _cgmqu::P64;
           I64[Hp - 56] = sat_sgm9E_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgm9A::P64;
           P64[Hp - 24] = _cgmqu::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.952086007 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantConst1_closure" {
     Data.Functor.Contravariant.$fContravariantConst1_closure:
         const Data.Functor.Contravariant.$fContravariantConst1_info;
 },
 Data.Functor.Contravariant.$fContravariantConst1_entry() //  [R3]
         { info_tbl: [(cgmrF,
                       label: Data.Functor.Contravariant.$fContravariantConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmrF: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.956006197 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantCompose1_closure" {
     Data.Functor.Contravariant.$fContravariantCompose1_closure:
         const Data.Functor.Contravariant.$fContravariantCompose1_info;
 },
 sat_sgm9N_entry() //  [R1]
         { info_tbl: [(cgmrZ,
                       label: sat_sgm9N_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmrZ: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgm9O_entry() //  [R1]
         { info_tbl: [(cgms2,
                       label: sat_sgm9O_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgms2: // global
           _sgm9O::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgms3; else goto cgms4;
       cgms4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgms6; else goto cgms5;
       cgms6: // global
           HpAlloc = 16;
           goto cgms3;
       cgms3: // global
           R1 = _sgm9O::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgms5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgm9O::P64;
           _sgm9J::P64 = P64[_sgm9O::P64 + 16];
           _sgm9K::P64 = P64[_sgm9O::P64 + 24];
           I64[Hp - 8] = sat_sgm9N_info;
           P64[Hp] = _sgm9K::P64;
           R2 = _sgm9J::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantCompose1_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgms7,
                       label: Data.Functor.Contravariant.$fContravariantCompose1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgms7: // global
           _sgm9L::P64 = R5;
           _sgm9K::P64 = R4;
           _sgm9J::P64 = R3;
           _sgm9I::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgms8; else goto cgms9;
       cgms9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmsb; else goto cgmsa;
       cgmsb: // global
           HpAlloc = 32;
           goto cgms8;
       cgms8: // global
           R5 = _sgm9L::P64;
           R4 = _sgm9K::P64;
           R3 = _sgm9J::P64;
           R2 = _sgm9I::P64;
           R1 = Data.Functor.Contravariant.$fContravariantCompose1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmsa: // global
           I64[Hp - 24] = sat_sgm9O_info;
           P64[Hp - 8] = _sgm9J::P64;
           P64[Hp] = _sgm9K::P64;
           R2 = _sgm9I::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgm9L::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.9649424 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProxy_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantProxy_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantProxy_$c>$_info;
 },
 Data.Functor.Contravariant.$fContravariantProxy_$c>$_entry() //  []
         { info_tbl: [(cgmsz,
                       label: Data.Functor.Contravariant.$fContravariantProxy_$c>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmsz: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.968453888 UTC

[section ""data" . Data.Functor.Contravariant.$dm>$_closure" {
     Data.Functor.Contravariant.$dm>$_closure:
         const Data.Functor.Contravariant.$dm>$_info;
 },
 sat_sgm9U_entry() //  [R1]
         { info_tbl: [(cgmsR,
                       label: sat_sgm9U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmsR: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$dm>$_entry() //  [R2, R3]
         { info_tbl: [(cgmsU,
                       label: Data.Functor.Contravariant.$dm>$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmsU: // global
           _sgm9S::P64 = R3;
           _sgm9R::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmsV; else goto cgmsW;
       cgmsW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgmsY; else goto cgmsX;
       cgmsY: // global
           HpAlloc = 16;
           goto cgmsV;
       cgmsV: // global
           R3 = _sgm9S::P64;
           R2 = _sgm9R::P64;
           R1 = Data.Functor.Contravariant.$dm>$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmsX: // global
           I64[Hp - 8] = sat_sgm9U_info;
           P64[Hp] = _sgm9S::P64;
           R2 = _sgm9R::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.97458629 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupOp_closure" {
     Data.Functor.Contravariant.$fSemigroupOp_closure:
         const Data.Functor.Contravariant.$fSemigroupOp_info;
 },
 sat_sgm9Y_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgmtj,
                       label: sat_sgm9Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmtj: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call GHC.Base.$fSemigroup(->)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgm9X_entry() //  [R1, R2]
         { info_tbl: [(cgmtr,
                       label: sat_sgm9X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmtr: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(->)_$csconcat_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgm9W_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgmtz,
                       label: sat_sgm9W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmtz: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(->)_$c<>_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupOp_entry() //  [R2]
         { info_tbl: [(cgmtD,
                       label: Data.Functor.Contravariant.$fSemigroupOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmtD: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgmtH; else goto cgmtG;
       cgmtH: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmtG: // global
           I64[Hp - 72] = sat_sgm9Y_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgm9X_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgm9W_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 68;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.983697731 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_closure" {
     Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_closure:
         const Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_info;
 },
 sat_sgma0_entry() //  [R1]
         { info_tbl: [(cgmub,
                       label: sat_sgma0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmub: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmuc; else goto cgmud;
       cgmuc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmud: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cgmue,
                       label: Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmue: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgmui; else goto cgmuh;
       cgmui: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmuh: // global
           I64[Hp - 16] = sat_sgma0_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Contravariant.$fSemigroupOp_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:16.990409805 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidOp_closure" {
     Data.Functor.Contravariant.$fMonoidOp_closure:
         const Data.Functor.Contravariant.$fMonoidOp_info;
 },
 lvl7_sgma2_entry() //  [R1]
         { info_tbl: [(cgmuB,
                       label: lvl7_sgma2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmuB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmuC; else goto cgmuD;
       cgmuC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmuD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgma7_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmuJ,
                       label: sat_sgma7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmuJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgma6_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgmuR,
                       label: sat_sgma6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmuR: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoid(->)_$cmappend_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgma5_entry() //  [R1]
         { info_tbl: [(cgmuZ,
                       label: sat_sgma5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmuZ: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgma3_entry() //  [R1]
         { info_tbl: [(cgmv6,
                       label: sat_sgma3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmv6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmv7; else goto cgmv8;
       cgmv7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmv8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fMonoidOp_entry() //  [R2]
         { info_tbl: [(cgmva,
                       label: Data.Functor.Contravariant.$fMonoidOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmva: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cgmve; else goto cgmvd;
       cgmve: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmvd: // global
           I64[Hp - 128] = lvl7_sgma2_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgma7_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgma6_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgma5_info;
           P64[Hp - 64] = Hp - 128;
           I64[Hp - 56] = sat_sgma3_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.003805206 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison3_closure" {
     Data.Functor.Contravariant.$fMonoidComparison3_closure:
         const Data.Functor.Contravariant.$fMonoidComparison3_info;
 },
 Data.Functor.Contravariant.$fMonoidComparison3_entry() //  []
         { info_tbl: [(cgmvS,
                       label: Data.Functor.Contravariant.$fMonoidComparison3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmvS: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.00765086 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison2_closure" {
     Data.Functor.Contravariant.$fMonoidComparison2_closure:
         const Data.Functor.Contravariant.$fMonoidComparison2_info;
 },
 sat_sgmah_entry() //  [R1, R2]
         { info_tbl: [(cgmwj,
                       label: sat_sgmah_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmwj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgmwk; else goto cgmwl;
       cgmwk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmwl: // global
           I64[Sp - 24] = block_cgmwc_info;
           _sgmaf::P64 = R2;
           R2 = R2;
           _sgmae::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sgmae::P64;
           P64[Sp - 8] = _sgmaf::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgmwc() //  [R1]
         { info_tbl: [(cgmwc,
                       label: block_cgmwc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmwc: // global
           _cgmwi::P64 = R1 & 7;
           if (_cgmwi::P64 < 3) goto ugmwv; else goto cgmwh;
       ugmwv: // global
           if (_cgmwi::P64 < 2) goto cgmwf; else goto cgmwg;
       cgmwf: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgmwg: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cgmwh: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fMonoidComparison2_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cgmww,
                       label: Data.Functor.Contravariant.$fMonoidComparison2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmww: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgmwA; else goto cgmwz;
       cgmwA: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidComparison2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmwz: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgmah_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.016405464 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison3_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison3_closure:
         const Data.Functor.Contravariant.$fSemigroupComparison3_info;
 },
 sat_sgmap_entry() //  [R1, R2]
         { info_tbl: [(cgmxg,
                       label: sat_sgmap_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmxg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgmxh; else goto cgmxi;
       cgmxh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmxi: // global
           I64[Sp - 24] = block_cgmx9_info;
           _sgman::P64 = R2;
           R2 = R2;
           _sgmam::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sgmam::P64;
           P64[Sp - 8] = _sgman::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgmx9() //  [R1]
         { info_tbl: [(cgmx9,
                       label: block_cgmx9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmx9: // global
           _cgmxf::P64 = R1 & 7;
           if (_cgmxf::P64 < 3) goto ugmxs; else goto cgmxe;
       ugmxs: // global
           if (_cgmxf::P64 < 2) goto cgmxc; else goto cgmxd;
       cgmxc: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgmxd: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cgmxe: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupComparison3_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cgmxt,
                       label: Data.Functor.Contravariant.$fSemigroupComparison3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmxt: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgmxx; else goto cgmxw;
       cgmxx: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupComparison3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmxw: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgmap_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.025134814 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison1_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison1_closure:
         const Data.Functor.Contravariant.$fSemigroupComparison1_info;
         const 0;
 },
 lvl7_sgmav_entry() //  [R1]
         { info_tbl: [(cgmy4,
                       label: lvl7_sgmav_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmy4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmy5; else goto cgmy6;
       cgmy5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmy6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupOrdering_$cstimes_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgmay_entry() //  [R1, R2]
         { info_tbl: [(cgmyd,
                       label: sat_sgmay_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmyd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmyh; else goto cgmyg;
       cgmyh: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmyg: // global
           _sgmar::P64 = P64[R1 + 7];
           _sgmau::P64 = P64[R1 + 15];
           _sgmav::P64 = P64[R1 + 23];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmau::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = _sgmar::P64;
           R1 = _sgmav::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupComparison1_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cgmyi,
                       label: Data.Functor.Contravariant.$fSemigroupComparison1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmyi: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgmym; else goto cgmyl;
       cgmym: // global
           HpAlloc = 88;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupComparison1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmyl: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = lvl7_sgmav_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = sat_sgmay_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.033920207 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantM1_closure" {
     Data.Functor.Contravariant.$fContravariantM1_closure:
         const Data.Functor.Contravariant.$fContravariantM1_info;
 },
 sat_sgmaB_entry() //  [R1]
         { info_tbl: [(cgmyP,
                       label: sat_sgmaB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmyP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmyQ; else goto cgmyR;
       cgmyQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmyR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.>$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgmaA_entry() //  [R1]
         { info_tbl: [(cgmyW,
                       label: sat_sgmaA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmyW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmyX; else goto cgmyY;
       cgmyX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmyY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantM1_entry() //  [R2]
         { info_tbl: [(cgmz0,
                       label: Data.Functor.Contravariant.$fContravariantM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmz0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgmz4; else goto cgmz3;
       cgmz4: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmz3: // global
           I64[Hp - 64] = sat_sgmaB_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgmaA_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.04252308 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantRec1_closure" {
     Data.Functor.Contravariant.$fContravariantRec1_closure:
         const Data.Functor.Contravariant.$fContravariantRec1_info;
 },
 sat_sgmaE_entry() //  [R1]
         { info_tbl: [(cgmzx,
                       label: sat_sgmaE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmzx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmzy; else goto cgmzz;
       cgmzy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmzz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.>$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgmaD_entry() //  [R1]
         { info_tbl: [(cgmzE,
                       label: sat_sgmaD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmzE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmzF; else goto cgmzG;
       cgmzF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmzG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantRec1_entry() //  [R2]
         { info_tbl: [(cgmzI,
                       label: Data.Functor.Contravariant.$fContravariantRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmzI: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgmzM; else goto cgmzL;
       cgmzM: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmzL: // global
           I64[Hp - 64] = sat_sgmaE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgmaD_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.050804437 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantAlt_closure" {
     Data.Functor.Contravariant.$fContravariantAlt_closure:
         const Data.Functor.Contravariant.$fContravariantAlt_info;
 },
 sat_sgmaH_entry() //  [R1]
         { info_tbl: [(cgmAf,
                       label: sat_sgmaH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmAf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmAg; else goto cgmAh;
       cgmAg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmAh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.>$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgmaG_entry() //  [R1]
         { info_tbl: [(cgmAm,
                       label: sat_sgmaG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmAm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmAn; else goto cgmAo;
       cgmAn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmAo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantAlt_entry() //  [R2]
         { info_tbl: [(cgmAq,
                       label: Data.Functor.Contravariant.$fContravariantAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmAq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgmAu; else goto cgmAt;
       cgmAu: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmAt: // global
           I64[Hp - 64] = sat_sgmaH_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgmaG_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.058376057 UTC

[section ""data" . sat_sgmaI_closure" {
     sat_sgmaI_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.060061456 UTC

[section ""data" . sat_sgmaJ_closure" {
     sat_sgmaJ_closure:
         const :_con_info;
         const sat_sgmaI_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.062324253 UTC

[section ""data" . lvl_rgjLr_closure" {
     lvl_rgjLr_closure:
         const lvl_rgjLr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rgjLr_entry() //  [R1]
         { info_tbl: [(cgmAX,
                       label: lvl_rgjLr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmAX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmAY; else goto cgmAZ;
       cgmAY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmAZ: // global
           (_cgmAU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgmAU::I64 == 0) goto cgmAW; else goto cgmAV;
       cgmAW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgmAV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgmAU::I64;
           R3 = sat_sgmaJ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.066768074 UTC

[section ""data" . lvl1_rgjLs_closure" {
     lvl1_rgjLs_closure:
         const lvl1_rgjLs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rgjLs_entry() //  [R1]
         { info_tbl: [(cgmBf,
                       label: lvl1_rgjLs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmBf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmBg; else goto cgmBh;
       cgmBg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmBh: // global
           (_cgmBc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgmBc::I64 == 0) goto cgmBe; else goto cgmBd;
       cgmBe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgmBd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgmBc::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.072314862 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_info;
         const 0;
 },
 $dFractional_sgmaM_entry() //  [R1]
         { info_tbl: [(cgmBA,
                       label: $dFractional_sgmaM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmBA: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgmaN_entry() //  [R1]
         { info_tbl: [(cgmBH,
                       label: $dNum_sgmaN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmBH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmBI; else goto cgmBJ;
       cgmBI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmBJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgmaO_entry() //  [R1]
         { info_tbl: [(cgmBO,
                       label: x_sgmaO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmBO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgmBP; else goto cgmBQ;
       cgmBP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmBQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl1_rgjLs_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 x1_sgmaP_entry() //  [R1]
         { info_tbl: [(cgmBV,
                       label: x1_sgmaP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmBV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgmBW; else goto cgmBX;
       cgmBW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmBX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgmaS_entry() //  [R1]
         { info_tbl: [(cgmCg,
                       label: sat_sgmaS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmCg: // global
           _sgmaS::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgmCh; else goto cgmCi;
       cgmCi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmCk; else goto cgmCj;
       cgmCk: // global
           HpAlloc = 32;
           goto cgmCh;
       cgmCh: // global
           R1 = _sgmaS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmCj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgmaS::P64;
           _sgmaK::P64 = P64[_sgmaS::P64 + 16];
           _sgmaL::P64 = P64[_sgmaS::P64 + 24];
           _sgmaQ::P64 = P64[_sgmaS::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmaL::P64;
           P64[Hp] = _sgmaQ::P64;
           R2 = _sgmaK::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Float.exp_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgmaT_entry() //  [R1]
         { info_tbl: [(cgmCl,
                       label: sat_sgmaT_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmCl: // global
           _sgmaT::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgmCm; else goto cgmCn;
       cgmCn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgmCp; else goto cgmCo;
       cgmCp: // global
           HpAlloc = 40;
           goto cgmCm;
       cgmCm: // global
           R1 = _sgmaT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmCo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgmaT::P64;
           _sgmaK::P64 = P64[_sgmaT::P64 + 16];
           _sgmaL::P64 = P64[_sgmaT::P64 + 24];
           _sgmaN::P64 = P64[_sgmaT::P64 + 32];
           _sgmaO::P64 = P64[_sgmaT::P64 + 40];
           _sgmaQ::P64 = P64[_sgmaT::P64 + 48];
           I64[Hp - 32] = sat_sgmaS_info;
           P64[Hp - 16] = _sgmaK::P64;
           P64[Hp - 8] = _sgmaL::P64;
           P64[Hp] = _sgmaQ::P64;
           R2 = _sgmaN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgmaO::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgmaU_entry() //  [R1]
         { info_tbl: [(cgmCq,
                       label: sat_sgmaU_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmCq: // global
           _sgmaU::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgmCr; else goto cgmCs;
       cgmCs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgmCu; else goto cgmCt;
       cgmCu: // global
           HpAlloc = 56;
           goto cgmCr;
       cgmCr: // global
           R1 = _sgmaU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmCt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgmaU::P64;
           _sgmaK::P64 = P64[_sgmaU::P64 + 16];
           _sgmaL::P64 = P64[_sgmaU::P64 + 24];
           _sgmaN::P64 = P64[_sgmaU::P64 + 32];
           _sgmaO::P64 = P64[_sgmaU::P64 + 40];
           _sgmaP::P64 = P64[_sgmaU::P64 + 48];
           _sgmaQ::P64 = P64[_sgmaU::P64 + 56];
           I64[Hp - 48] = sat_sgmaT_info;
           P64[Hp - 32] = _sgmaK::P64;
           P64[Hp - 24] = _sgmaL::P64;
           P64[Hp - 16] = _sgmaN::P64;
           P64[Hp - 8] = _sgmaO::P64;
           P64[Hp] = _sgmaQ::P64;
           R2 = _sgmaN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgmaP::P64;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgmaV_entry() //  [R1, R2]
         { info_tbl: [(cgmCv,
                       label: sat_sgmaV_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmCv: // global
           _sgmaQ::P64 = R2;
           _sgmaV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmCw; else goto cgmCx;
       cgmCx: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgmCz; else goto cgmCy;
       cgmCz: // global
           HpAlloc = 64;
           goto cgmCw;
       cgmCw: // global
           R2 = _sgmaQ::P64;
           R1 = _sgmaV::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmCy: // global
           _sgmaK::P64 = P64[_sgmaV::P64 + 7];
           _sgmaL::P64 = P64[_sgmaV::P64 + 15];
           _sgmaN::P64 = P64[_sgmaV::P64 + 23];
           _sgmaO::P64 = P64[_sgmaV::P64 + 31];
           _sgmaP::P64 = P64[_sgmaV::P64 + 39];
           I64[Hp - 56] = sat_sgmaU_info;
           P64[Hp - 40] = _sgmaK::P64;
           P64[Hp - 32] = _sgmaL::P64;
           P64[Hp - 24] = _sgmaN::P64;
           P64[Hp - 16] = _sgmaO::P64;
           P64[Hp - 8] = _sgmaP::P64;
           P64[Hp] = _sgmaQ::P64;
           R2 = _sgmaK::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cgmCA,
                       label: Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmCA: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgmCE; else goto cgmCD;
       cgmCE: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmCD: // global
           I64[Hp - 136] = $dFractional_sgmaM_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = $dNum_sgmaN_info;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = x_sgmaO_info;
           _cgmBD::P64 = Hp - 112;
           P64[Hp - 72] = _cgmBD::P64;
           I64[Hp - 64] = x1_sgmaP_info;
           P64[Hp - 48] = _cgmBD::P64;
           I64[Hp - 40] = sat_sgmaV_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = _cgmBD::P64;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = Hp - 64;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.095544062 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$cexpm1_info;
         const 0;
 },
 $dFractional_sgmaY_entry() //  [R1]
         { info_tbl: [(cgmDR,
                       label: $dFractional_sgmaY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmDR: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgmaZ_entry() //  [R1]
         { info_tbl: [(cgmDY,
                       label: $dNum_sgmaZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmDY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmDZ; else goto cgmE0;
       cgmDZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmE0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgmb0_entry() //  [R1]
         { info_tbl: [(cgmE5,
                       label: x_sgmb0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmE5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgmE6; else goto cgmE7;
       cgmE6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmE7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgmb3_entry() //  [R1]
         { info_tbl: [(cgmEi,
                       label: sat_sgmb3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmEi: // global
           _sgmb3::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgmEj; else goto cgmEk;
       cgmEk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmEm; else goto cgmEl;
       cgmEm: // global
           HpAlloc = 32;
           goto cgmEj;
       cgmEj: // global
           R1 = _sgmb3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmEl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgmb3::P64;
           _sgmaW::P64 = P64[_sgmb3::P64 + 16];
           _sgmaX::P64 = P64[_sgmb3::P64 + 24];
           _sgmb1::P64 = P64[_sgmb3::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmaX::P64;
           P64[Hp] = _sgmb1::P64;
           R2 = _sgmaW::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Float.exp_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgmb4_entry() //  [R1, R2]
         { info_tbl: [(cgmEn,
                       label: sat_sgmb4_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmEn: // global
           _sgmb1::P64 = R2;
           _sgmb4::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgmEo; else goto cgmEp;
       cgmEp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgmEr; else goto cgmEq;
       cgmEr: // global
           HpAlloc = 40;
           goto cgmEo;
       cgmEo: // global
           R2 = _sgmb1::P64;
           R1 = _sgmb4::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmEq: // global
           _sgmaW::P64 = P64[_sgmb4::P64 + 7];
           _sgmaX::P64 = P64[_sgmb4::P64 + 15];
           _sgmaZ::P64 = P64[_sgmb4::P64 + 23];
           _sgmb0::P64 = P64[_sgmb4::P64 + 31];
           I64[Hp - 32] = sat_sgmb3_info;
           P64[Hp - 16] = _sgmaW::P64;
           P64[Hp - 8] = _sgmaX::P64;
           P64[Hp] = _sgmb1::P64;
           R2 = _sgmaZ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sgmb0::P64;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$cexpm1_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cgmEs,
                       label: Data.Functor.Contravariant.$fFloatingOp_$cexpm1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmEs: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgmEw; else goto cgmEv;
       cgmEw: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmEv: // global
           I64[Hp - 104] = $dFractional_sgmaY_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_sgmaZ_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = x_sgmb0_info;
           _cgmDU::P64 = Hp - 80;
           P64[Hp - 40] = _cgmDU::P64;
           I64[Hp - 32] = sat_sgmb4_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cgmDU::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.111079246 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_info;
         const 0;
 },
 $dFractional_sgmb7_entry() //  [R1]
         { info_tbl: [(cgmFk,
                       label: $dFractional_sgmb7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmFk: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgmb8_entry() //  [R1]
         { info_tbl: [(cgmFr,
                       label: $dNum_sgmb8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmFr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmFs; else goto cgmFt;
       cgmFs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmFt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgmb9_entry() //  [R1]
         { info_tbl: [(cgmFy,
                       label: x_sgmb9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmFy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgmFz; else goto cgmFA;
       cgmFz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmFA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgmbc_entry() //  [R1]
         { info_tbl: [(cgmFP,
                       label: sat_sgmbc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmFP: // global
           _sgmbc::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgmFQ; else goto cgmFR;
       cgmFR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmFT; else goto cgmFS;
       cgmFT: // global
           HpAlloc = 32;
           goto cgmFQ;
       cgmFQ: // global
           R1 = _sgmbc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmFS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgmbc::P64;
           _sgmb5::P64 = P64[_sgmbc::P64 + 16];
           _sgmb6::P64 = P64[_sgmbc::P64 + 24];
           _sgmba::P64 = P64[_sgmbc::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmb6::P64;
           P64[Hp] = _sgmba::P64;
           R2 = _sgmb5::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Float.exp_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgmbd_entry() //  [R1]
         { info_tbl: [(cgmFU,
                       label: sat_sgmbd_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmFU: // global
           _sgmbd::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgmFV; else goto cgmFW;
       cgmFW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgmFY; else goto cgmFX;
       cgmFY: // global
           HpAlloc = 40;
           goto cgmFV;
       cgmFV: // global
           R1 = _sgmbd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmFX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgmbd::P64;
           _sgmb5::P64 = P64[_sgmbd::P64 + 16];
           _sgmb6::P64 = P64[_sgmbd::P64 + 24];
           _sgmb8::P64 = P64[_sgmbd::P64 + 32];
           _sgmb9::P64 = P64[_sgmbd::P64 + 40];
           _sgmba::P64 = P64[_sgmbd::P64 + 48];
           I64[Hp - 32] = sat_sgmbc_info;
           P64[Hp - 16] = _sgmb5::P64;
           P64[Hp - 8] = _sgmb6::P64;
           P64[Hp] = _sgmba::P64;
           R2 = _sgmb8::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgmb9::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgmbe_entry() //  [R1, R2]
         { info_tbl: [(cgmFZ,
                       label: sat_sgmbe_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmFZ: // global
           _sgmba::P64 = R2;
           _sgmbe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmG0; else goto cgmG1;
       cgmG1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgmG3; else goto cgmG2;
       cgmG3: // global
           HpAlloc = 56;
           goto cgmG0;
       cgmG0: // global
           R2 = _sgmba::P64;
           R1 = _sgmbe::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmG2: // global
           _sgmb5::P64 = P64[_sgmbe::P64 + 7];
           _sgmb6::P64 = P64[_sgmbe::P64 + 15];
           _sgmb8::P64 = P64[_sgmbe::P64 + 23];
           _sgmb9::P64 = P64[_sgmbe::P64 + 31];
           I64[Hp - 48] = sat_sgmbd_info;
           P64[Hp - 32] = _sgmb5::P64;
           P64[Hp - 24] = _sgmb6::P64;
           P64[Hp - 16] = _sgmb8::P64;
           P64[Hp - 8] = _sgmb9::P64;
           P64[Hp] = _sgmba::P64;
           R2 = _sgmb5::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cgmG4,
                       label: Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmG4: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgmG8; else goto cgmG7;
       cgmG8: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmG7: // global
           I64[Hp - 104] = $dFractional_sgmb7_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_sgmb8_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = x_sgmb9_info;
           _cgmFn::P64 = Hp - 80;
           P64[Hp - 40] = _cgmFn::P64;
           I64[Hp - 32] = sat_sgmbe_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cgmFn::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.130255847 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$clog1p_info;
         const 0;
 },
 $dFractional_sgmbh_entry() //  [R1]
         { info_tbl: [(cgmH4,
                       label: $dFractional_sgmbh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmH4: // global
           R2 = P64[R1 + 16];
           call GHC.Float.$p1Floating_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dNum_sgmbi_entry() //  [R1]
         { info_tbl: [(cgmHb,
                       label: $dNum_sgmbi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmHb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmHc; else goto cgmHd;
       cgmHc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmHd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sgmbj_entry() //  [R1]
         { info_tbl: [(cgmHi,
                       label: x_sgmbj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmHi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgmHj; else goto cgmHk;
       cgmHj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmHk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rgjLr_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgmbm_entry() //  [R1]
         { info_tbl: [(cgmHv,
                       label: sat_sgmbm_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmHv: // global
           _sgmbm::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgmHw; else goto cgmHx;
       cgmHx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmHz; else goto cgmHy;
       cgmHz: // global
           HpAlloc = 32;
           goto cgmHw;
       cgmHw: // global
           R1 = _sgmbm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmHy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgmbm::P64;
           _sgmbg::P64 = P64[_sgmbm::P64 + 16];
           _sgmbi::P64 = P64[_sgmbm::P64 + 24];
           _sgmbj::P64 = P64[_sgmbm::P64 + 32];
           _sgmbk::P64 = P64[_sgmbm::P64 + 40];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmbg::P64;
           P64[Hp] = _sgmbk::P64;
           R2 = _sgmbi::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgmbj::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Num.+_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgmbn_entry() //  [R1, R2]
         { info_tbl: [(cgmHA,
                       label: sat_sgmbn_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmHA: // global
           _sgmbk::P64 = R2;
           _sgmbn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmHB; else goto cgmHC;
       cgmHC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgmHE; else goto cgmHD;
       cgmHE: // global
           HpAlloc = 48;
           goto cgmHB;
       cgmHB: // global
           R2 = _sgmbk::P64;
           R1 = _sgmbn::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmHD: // global
           _sgmbf::P64 = P64[_sgmbn::P64 + 7];
           _sgmbg::P64 = P64[_sgmbn::P64 + 15];
           _sgmbi::P64 = P64[_sgmbn::P64 + 23];
           _sgmbj::P64 = P64[_sgmbn::P64 + 31];
           I64[Hp - 40] = sat_sgmbm_info;
           P64[Hp - 24] = _sgmbg::P64;
           P64[Hp - 16] = _sgmbi::P64;
           P64[Hp - 8] = _sgmbj::P64;
           P64[Hp] = _sgmbk::P64;
           R2 = _sgmbf::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$clog1p_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cgmHF,
                       label: Data.Functor.Contravariant.$fFloatingOp_$clog1p_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmHF: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgmHJ; else goto cgmHI;
       cgmHJ: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmHI: // global
           I64[Hp - 104] = $dFractional_sgmbh_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = $dNum_sgmbi_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = x_sgmbj_info;
           _cgmH7::P64 = Hp - 80;
           P64[Hp - 40] = _cgmH7::P64;
           I64[Hp - 32] = sat_sgmbn_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cgmH7::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.144378499 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp17_closure" {
     Data.Functor.Contravariant.$fFloatingOp17_closure:
         const Data.Functor.Contravariant.$fFloatingOp17_info;
 },
 Data.Functor.Contravariant.$fFloatingOp17_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmIu,
                       label: Data.Functor.Contravariant.$fFloatingOp17_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmIu: // global
           _sgmbq::P64 = R4;
           _sgmbp::P64 = R3;
           _sgmbo::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmIv; else goto cgmIw;
       cgmIw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmIy; else goto cgmIx;
       cgmIy: // global
           HpAlloc = 32;
           goto cgmIv;
       cgmIv: // global
           R4 = _sgmbq::P64;
           R3 = _sgmbp::P64;
           R2 = _sgmbo::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmIx: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmbp::P64;
           P64[Hp] = _sgmbq::P64;
           R2 = _sgmbo::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.exp_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.148598089 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp16_closure" {
     Data.Functor.Contravariant.$fFloatingOp16_closure:
         const Data.Functor.Contravariant.$fFloatingOp16_info;
 },
 Data.Functor.Contravariant.$fFloatingOp16_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmIM,
                       label: Data.Functor.Contravariant.$fFloatingOp16_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmIM: // global
           _sgmbu::P64 = R4;
           _sgmbt::P64 = R3;
           _sgmbs::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmIN; else goto cgmIO;
       cgmIO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmIQ; else goto cgmIP;
       cgmIQ: // global
           HpAlloc = 32;
           goto cgmIN;
       cgmIN: // global
           R4 = _sgmbu::P64;
           R3 = _sgmbt::P64;
           R2 = _sgmbs::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp16_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmIP: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmbt::P64;
           P64[Hp] = _sgmbu::P64;
           R2 = _sgmbs::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.15334885 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp15_closure" {
     Data.Functor.Contravariant.$fFloatingOp15_closure:
         const Data.Functor.Contravariant.$fFloatingOp15_info;
 },
 Data.Functor.Contravariant.$fFloatingOp15_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmJ4,
                       label: Data.Functor.Contravariant.$fFloatingOp15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmJ4: // global
           _sgmby::P64 = R4;
           _sgmbx::P64 = R3;
           _sgmbw::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmJ5; else goto cgmJ6;
       cgmJ6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmJ8; else goto cgmJ7;
       cgmJ8: // global
           HpAlloc = 32;
           goto cgmJ5;
       cgmJ5: // global
           R4 = _sgmby::P64;
           R3 = _sgmbx::P64;
           R2 = _sgmbw::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp15_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmJ7: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmbx::P64;
           P64[Hp] = _sgmby::P64;
           R2 = _sgmbw::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.sqrt_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.157914773 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp14_closure" {
     Data.Functor.Contravariant.$fFloatingOp14_closure:
         const Data.Functor.Contravariant.$fFloatingOp14_info;
 },
 Data.Functor.Contravariant.$fFloatingOp14_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cgmJn,
                       label: Data.Functor.Contravariant.$fFloatingOp14_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmJn: // global
           _sgmbD::P64 = R5;
           _sgmbC::P64 = R4;
           _sgmbB::P64 = R3;
           _sgmbA::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgmJo; else goto cgmJp;
       cgmJp: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgmJr; else goto cgmJq;
       cgmJr: // global
           HpAlloc = 64;
           goto cgmJo;
       cgmJo: // global
           R5 = _sgmbD::P64;
           R4 = _sgmbC::P64;
           R3 = _sgmbB::P64;
           R2 = _sgmbA::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp14_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmJq: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgmbC::P64;
           P64[Hp - 32] = _sgmbD::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmbB::P64;
           P64[Hp] = _sgmbD::P64;
           R2 = _sgmbA::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Float.**_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.163675154 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp13_closure" {
     Data.Functor.Contravariant.$fFloatingOp13_closure:
         const Data.Functor.Contravariant.$fFloatingOp13_info;
 },
 Data.Functor.Contravariant.$fFloatingOp13_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cgmJI,
                       label: Data.Functor.Contravariant.$fFloatingOp13_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmJI: // global
           _sgmbJ::P64 = R5;
           _sgmbI::P64 = R4;
           _sgmbH::P64 = R3;
           _sgmbG::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgmJJ; else goto cgmJK;
       cgmJK: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgmJM; else goto cgmJL;
       cgmJM: // global
           HpAlloc = 64;
           goto cgmJJ;
       cgmJJ: // global
           R5 = _sgmbJ::P64;
           R4 = _sgmbI::P64;
           R3 = _sgmbH::P64;
           R2 = _sgmbG::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp13_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmJL: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgmbI::P64;
           P64[Hp - 32] = _sgmbJ::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmbH::P64;
           P64[Hp] = _sgmbJ::P64;
           R2 = _sgmbG::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Float.logBase_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.168160152 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp12_closure" {
     Data.Functor.Contravariant.$fFloatingOp12_closure:
         const Data.Functor.Contravariant.$fFloatingOp12_info;
 },
 Data.Functor.Contravariant.$fFloatingOp12_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmK2,
                       label: Data.Functor.Contravariant.$fFloatingOp12_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmK2: // global
           _sgmbO::P64 = R4;
           _sgmbN::P64 = R3;
           _sgmbM::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmK3; else goto cgmK4;
       cgmK4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmK6; else goto cgmK5;
       cgmK6: // global
           HpAlloc = 32;
           goto cgmK3;
       cgmK3: // global
           R4 = _sgmbO::P64;
           R3 = _sgmbN::P64;
           R2 = _sgmbM::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp12_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmK5: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmbN::P64;
           P64[Hp] = _sgmbO::P64;
           R2 = _sgmbM::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.sin_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.172438107 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp11_closure" {
     Data.Functor.Contravariant.$fFloatingOp11_closure:
         const Data.Functor.Contravariant.$fFloatingOp11_info;
 },
 Data.Functor.Contravariant.$fFloatingOp11_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmKk,
                       label: Data.Functor.Contravariant.$fFloatingOp11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmKk: // global
           _sgmbS::P64 = R4;
           _sgmbR::P64 = R3;
           _sgmbQ::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmKl; else goto cgmKm;
       cgmKm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmKo; else goto cgmKn;
       cgmKo: // global
           HpAlloc = 32;
           goto cgmKl;
       cgmKl: // global
           R4 = _sgmbS::P64;
           R3 = _sgmbR::P64;
           R2 = _sgmbQ::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp11_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmKn: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmbR::P64;
           P64[Hp] = _sgmbS::P64;
           R2 = _sgmbQ::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.cos_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.176706753 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp10_closure" {
     Data.Functor.Contravariant.$fFloatingOp10_closure:
         const Data.Functor.Contravariant.$fFloatingOp10_info;
 },
 Data.Functor.Contravariant.$fFloatingOp10_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmKC,
                       label: Data.Functor.Contravariant.$fFloatingOp10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmKC: // global
           _sgmbW::P64 = R4;
           _sgmbV::P64 = R3;
           _sgmbU::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmKD; else goto cgmKE;
       cgmKE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmKG; else goto cgmKF;
       cgmKG: // global
           HpAlloc = 32;
           goto cgmKD;
       cgmKD: // global
           R4 = _sgmbW::P64;
           R3 = _sgmbV::P64;
           R2 = _sgmbU::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp10_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmKF: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmbV::P64;
           P64[Hp] = _sgmbW::P64;
           R2 = _sgmbU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.tan_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.180975935 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp9_closure" {
     Data.Functor.Contravariant.$fFloatingOp9_closure:
         const Data.Functor.Contravariant.$fFloatingOp9_info;
 },
 Data.Functor.Contravariant.$fFloatingOp9_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmKU,
                       label: Data.Functor.Contravariant.$fFloatingOp9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmKU: // global
           _sgmc0::P64 = R4;
           _sgmbZ::P64 = R3;
           _sgmbY::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmKV; else goto cgmKW;
       cgmKW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmKY; else goto cgmKX;
       cgmKY: // global
           HpAlloc = 32;
           goto cgmKV;
       cgmKV: // global
           R4 = _sgmc0::P64;
           R3 = _sgmbZ::P64;
           R2 = _sgmbY::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp9_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmKX: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmbZ::P64;
           P64[Hp] = _sgmc0::P64;
           R2 = _sgmbY::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.asin_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.185369031 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp8_closure" {
     Data.Functor.Contravariant.$fFloatingOp8_closure:
         const Data.Functor.Contravariant.$fFloatingOp8_info;
 },
 Data.Functor.Contravariant.$fFloatingOp8_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmLc,
                       label: Data.Functor.Contravariant.$fFloatingOp8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmLc: // global
           _sgmc4::P64 = R4;
           _sgmc3::P64 = R3;
           _sgmc2::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmLd; else goto cgmLe;
       cgmLe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmLg; else goto cgmLf;
       cgmLg: // global
           HpAlloc = 32;
           goto cgmLd;
       cgmLd: // global
           R4 = _sgmc4::P64;
           R3 = _sgmc3::P64;
           R2 = _sgmc2::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmLf: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmc3::P64;
           P64[Hp] = _sgmc4::P64;
           R2 = _sgmc2::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.acos_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.189612057 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp7_closure" {
     Data.Functor.Contravariant.$fFloatingOp7_closure:
         const Data.Functor.Contravariant.$fFloatingOp7_info;
 },
 Data.Functor.Contravariant.$fFloatingOp7_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmLu,
                       label: Data.Functor.Contravariant.$fFloatingOp7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmLu: // global
           _sgmc8::P64 = R4;
           _sgmc7::P64 = R3;
           _sgmc6::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmLv; else goto cgmLw;
       cgmLw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmLy; else goto cgmLx;
       cgmLy: // global
           HpAlloc = 32;
           goto cgmLv;
       cgmLv: // global
           R4 = _sgmc8::P64;
           R3 = _sgmc7::P64;
           R2 = _sgmc6::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmLx: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmc7::P64;
           P64[Hp] = _sgmc8::P64;
           R2 = _sgmc6::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.atan_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.193838592 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp6_closure" {
     Data.Functor.Contravariant.$fFloatingOp6_closure:
         const Data.Functor.Contravariant.$fFloatingOp6_info;
 },
 Data.Functor.Contravariant.$fFloatingOp6_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmLM,
                       label: Data.Functor.Contravariant.$fFloatingOp6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmLM: // global
           _sgmcc::P64 = R4;
           _sgmcb::P64 = R3;
           _sgmca::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmLN; else goto cgmLO;
       cgmLO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmLQ; else goto cgmLP;
       cgmLQ: // global
           HpAlloc = 32;
           goto cgmLN;
       cgmLN: // global
           R4 = _sgmcc::P64;
           R3 = _sgmcb::P64;
           R2 = _sgmca::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp6_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmLP: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmcb::P64;
           P64[Hp] = _sgmcc::P64;
           R2 = _sgmca::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.sinh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.198127605 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp5_closure" {
     Data.Functor.Contravariant.$fFloatingOp5_closure:
         const Data.Functor.Contravariant.$fFloatingOp5_info;
 },
 Data.Functor.Contravariant.$fFloatingOp5_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmM4,
                       label: Data.Functor.Contravariant.$fFloatingOp5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmM4: // global
           _sgmcg::P64 = R4;
           _sgmcf::P64 = R3;
           _sgmce::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmM5; else goto cgmM6;
       cgmM6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmM8; else goto cgmM7;
       cgmM8: // global
           HpAlloc = 32;
           goto cgmM5;
       cgmM5: // global
           R4 = _sgmcg::P64;
           R3 = _sgmcf::P64;
           R2 = _sgmce::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmM7: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmcf::P64;
           P64[Hp] = _sgmcg::P64;
           R2 = _sgmce::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.cosh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.20328916 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp4_closure" {
     Data.Functor.Contravariant.$fFloatingOp4_closure:
         const Data.Functor.Contravariant.$fFloatingOp4_info;
 },
 Data.Functor.Contravariant.$fFloatingOp4_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmMm,
                       label: Data.Functor.Contravariant.$fFloatingOp4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmMm: // global
           _sgmck::P64 = R4;
           _sgmcj::P64 = R3;
           _sgmci::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmMn; else goto cgmMo;
       cgmMo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmMq; else goto cgmMp;
       cgmMq: // global
           HpAlloc = 32;
           goto cgmMn;
       cgmMn: // global
           R4 = _sgmck::P64;
           R3 = _sgmcj::P64;
           R2 = _sgmci::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmMp: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmcj::P64;
           P64[Hp] = _sgmck::P64;
           R2 = _sgmci::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.tanh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.207479713 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp3_closure" {
     Data.Functor.Contravariant.$fFloatingOp3_closure:
         const Data.Functor.Contravariant.$fFloatingOp3_info;
 },
 Data.Functor.Contravariant.$fFloatingOp3_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmME,
                       label: Data.Functor.Contravariant.$fFloatingOp3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmME: // global
           _sgmco::P64 = R4;
           _sgmcn::P64 = R3;
           _sgmcm::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmMF; else goto cgmMG;
       cgmMG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmMI; else goto cgmMH;
       cgmMI: // global
           HpAlloc = 32;
           goto cgmMF;
       cgmMF: // global
           R4 = _sgmco::P64;
           R3 = _sgmcn::P64;
           R2 = _sgmcm::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmMH: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmcn::P64;
           P64[Hp] = _sgmco::P64;
           R2 = _sgmcm::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.asinh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.211734821 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp2_closure" {
     Data.Functor.Contravariant.$fFloatingOp2_closure:
         const Data.Functor.Contravariant.$fFloatingOp2_info;
 },
 Data.Functor.Contravariant.$fFloatingOp2_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmMW,
                       label: Data.Functor.Contravariant.$fFloatingOp2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmMW: // global
           _sgmcs::P64 = R4;
           _sgmcr::P64 = R3;
           _sgmcq::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmMX; else goto cgmMY;
       cgmMY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmN0; else goto cgmMZ;
       cgmN0: // global
           HpAlloc = 32;
           goto cgmMX;
       cgmMX: // global
           R4 = _sgmcs::P64;
           R3 = _sgmcr::P64;
           R2 = _sgmcq::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmMZ: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmcr::P64;
           P64[Hp] = _sgmcs::P64;
           R2 = _sgmcq::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.acosh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.215948425 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp1_closure" {
     Data.Functor.Contravariant.$fFloatingOp1_closure:
         const Data.Functor.Contravariant.$fFloatingOp1_info;
 },
 Data.Functor.Contravariant.$fFloatingOp1_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmNe,
                       label: Data.Functor.Contravariant.$fFloatingOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmNe: // global
           _sgmcw::P64 = R4;
           _sgmcv::P64 = R3;
           _sgmcu::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmNf; else goto cgmNg;
       cgmNg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmNi; else goto cgmNh;
       cgmNi: // global
           HpAlloc = 32;
           goto cgmNf;
       cgmNf: // global
           R4 = _sgmcw::P64;
           R3 = _sgmcv::P64;
           R2 = _sgmcu::P64;
           R1 = Data.Functor.Contravariant.$fFloatingOp1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmNh: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmcv::P64;
           P64[Hp] = _sgmcw::P64;
           R2 = _sgmcu::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Float.atanh_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.220191002 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp2_closure" {
     Data.Functor.Contravariant.$fFractionalOp2_closure:
         const Data.Functor.Contravariant.$fFractionalOp2_info;
 },
 Data.Functor.Contravariant.$fFractionalOp2_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgmNx,
                       label: Data.Functor.Contravariant.$fFractionalOp2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmNx: // global
           _sgmcB::P64 = R5;
           _sgmcA::P64 = R4;
           _sgmcz::P64 = R3;
           _sgmcy::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgmNy; else goto cgmNz;
       cgmNz: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgmNB; else goto cgmNA;
       cgmNB: // global
           HpAlloc = 64;
           goto cgmNy;
       cgmNy: // global
           R5 = _sgmcB::P64;
           R4 = _sgmcA::P64;
           R3 = _sgmcz::P64;
           R2 = _sgmcy::P64;
           R1 = Data.Functor.Contravariant.$fFractionalOp2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmNA: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgmcA::P64;
           P64[Hp - 32] = _sgmcB::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmcz::P64;
           P64[Hp] = _sgmcB::P64;
           R2 = _sgmcy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Real./_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.225068509 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp1_closure" {
     Data.Functor.Contravariant.$fFractionalOp1_closure:
         const Data.Functor.Contravariant.$fFractionalOp1_info;
 },
 Data.Functor.Contravariant.$fFractionalOp1_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmNR,
                       label: Data.Functor.Contravariant.$fFractionalOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmNR: // global
           _sgmcG::P64 = R4;
           _sgmcF::P64 = R3;
           _sgmcE::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmNS; else goto cgmNT;
       cgmNT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmNV; else goto cgmNU;
       cgmNV: // global
           HpAlloc = 32;
           goto cgmNS;
       cgmNS: // global
           R4 = _sgmcG::P64;
           R3 = _sgmcF::P64;
           R2 = _sgmcE::P64;
           R1 = Data.Functor.Contravariant.$fFractionalOp1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmNU: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmcF::P64;
           P64[Hp] = _sgmcG::P64;
           R2 = _sgmcE::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.229868065 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp_$cfromRational_closure" {
     Data.Functor.Contravariant.$fFractionalOp_$cfromRational_closure:
         const Data.Functor.Contravariant.$fFractionalOp_$cfromRational_info;
 },
 x_sgmcK_entry() //  [R1]
         { info_tbl: [(cgmOc,
                       label: x_sgmcK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmOc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgmOd; else goto cgmOe;
       cgmOd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmOe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.fromRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgmcM_entry() //  [R1]
         { info_tbl: [(cgmOk,
                       label: sat_sgmcM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmOk: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fFractionalOp_$cfromRational_entry() //  [R2,
                                                                       R3]
         { info_tbl: [(cgmOn,
                       label: Data.Functor.Contravariant.$fFractionalOp_$cfromRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmOn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgmOr; else goto cgmOq;
       cgmOr: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFractionalOp_$cfromRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmOq: // global
           I64[Hp - 40] = x_sgmcK_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sgmcM_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.238344589 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp_$cnegate_closure" {
     Data.Functor.Contravariant.$fNumOp_$cnegate_closure:
         const Data.Functor.Contravariant.$fNumOp_$cnegate_info;
         const 0;
 },
 x_sgmcP_entry() //  [R1]
         { info_tbl: [(cgmOS,
                       label: x_sgmcP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmOS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgmOT; else goto cgmOU;
       cgmOT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmOU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl1_rgjLs_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgmcS_entry() //  [R1, R2]
         { info_tbl: [(cgmP1,
                       label: sat_sgmcS_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmP1: // global
           _sgmcQ::P64 = R2;
           _sgmcS::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgmP2; else goto cgmP3;
       cgmP3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmP5; else goto cgmP4;
       cgmP5: // global
           HpAlloc = 32;
           goto cgmP2;
       cgmP2: // global
           R2 = _sgmcQ::P64;
           R1 = _sgmcS::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmP4: // global
           _sgmcN::P64 = P64[_sgmcS::P64 + 7];
           _sgmcO::P64 = P64[_sgmcS::P64 + 15];
           _sgmcP::P64 = P64[_sgmcS::P64 + 23];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmcO::P64;
           P64[Hp] = _sgmcQ::P64;
           R2 = _sgmcN::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgmcP::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fNumOp_$cnegate_entry() //  [R2, R3]
         { info_tbl: [(cgmP6,
                       label: Data.Functor.Contravariant.$fNumOp_$cnegate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmP6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgmPa; else goto cgmP9;
       cgmPa: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fNumOp_$cnegate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmP9: // global
           I64[Hp - 48] = x_sgmcP_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = sat_sgmcS_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.247182299 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp5_closure" {
     Data.Functor.Contravariant.$fNumOp5_closure:
         const Data.Functor.Contravariant.$fNumOp5_info;
 },
 Data.Functor.Contravariant.$fNumOp5_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgmPD,
                       label: Data.Functor.Contravariant.$fNumOp5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmPD: // global
           _sgmcW::P64 = R5;
           _sgmcV::P64 = R4;
           _sgmcU::P64 = R3;
           _sgmcT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgmPE; else goto cgmPF;
       cgmPF: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgmPH; else goto cgmPG;
       cgmPH: // global
           HpAlloc = 64;
           goto cgmPE;
       cgmPE: // global
           R5 = _sgmcW::P64;
           R4 = _sgmcV::P64;
           R3 = _sgmcU::P64;
           R2 = _sgmcT::P64;
           R1 = Data.Functor.Contravariant.$fNumOp5_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmPG: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgmcV::P64;
           P64[Hp - 32] = _sgmcW::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmcU::P64;
           P64[Hp] = _sgmcW::P64;
           R2 = _sgmcT::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.251652508 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp4_closure" {
     Data.Functor.Contravariant.$fNumOp4_closure:
         const Data.Functor.Contravariant.$fNumOp4_info;
 },
 Data.Functor.Contravariant.$fNumOp4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgmPY,
                       label: Data.Functor.Contravariant.$fNumOp4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmPY: // global
           _sgmd2::P64 = R5;
           _sgmd1::P64 = R4;
           _sgmd0::P64 = R3;
           _sgmcZ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgmPZ; else goto cgmQ0;
       cgmQ0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgmQ2; else goto cgmQ1;
       cgmQ2: // global
           HpAlloc = 64;
           goto cgmPZ;
       cgmPZ: // global
           R5 = _sgmd2::P64;
           R4 = _sgmd1::P64;
           R3 = _sgmd0::P64;
           R2 = _sgmcZ::P64;
           R1 = Data.Functor.Contravariant.$fNumOp4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmQ1: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgmd1::P64;
           P64[Hp - 32] = _sgmd2::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmd0::P64;
           P64[Hp] = _sgmd2::P64;
           R2 = _sgmcZ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.25613805 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp3_closure" {
     Data.Functor.Contravariant.$fNumOp3_closure:
         const Data.Functor.Contravariant.$fNumOp3_info;
 },
 Data.Functor.Contravariant.$fNumOp3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgmQj,
                       label: Data.Functor.Contravariant.$fNumOp3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmQj: // global
           _sgmd8::P64 = R5;
           _sgmd7::P64 = R4;
           _sgmd6::P64 = R3;
           _sgmd5::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgmQk; else goto cgmQl;
       cgmQl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgmQn; else goto cgmQm;
       cgmQn: // global
           HpAlloc = 64;
           goto cgmQk;
       cgmQk: // global
           R5 = _sgmd8::P64;
           R4 = _sgmd7::P64;
           R3 = _sgmd6::P64;
           R2 = _sgmd5::P64;
           R1 = Data.Functor.Contravariant.$fNumOp3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmQm: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgmd7::P64;
           P64[Hp - 32] = _sgmd8::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmd6::P64;
           P64[Hp] = _sgmd8::P64;
           R2 = _sgmd5::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.260892987 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp2_closure" {
     Data.Functor.Contravariant.$fNumOp2_closure:
         const Data.Functor.Contravariant.$fNumOp2_info;
 },
 Data.Functor.Contravariant.$fNumOp2_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmQD,
                       label: Data.Functor.Contravariant.$fNumOp2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmQD: // global
           _sgmdd::P64 = R4;
           _sgmdc::P64 = R3;
           _sgmdb::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmQE; else goto cgmQF;
       cgmQF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmQH; else goto cgmQG;
       cgmQH: // global
           HpAlloc = 32;
           goto cgmQE;
       cgmQE: // global
           R4 = _sgmdd::P64;
           R3 = _sgmdc::P64;
           R2 = _sgmdb::P64;
           R1 = Data.Functor.Contravariant.$fNumOp2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmQG: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmdc::P64;
           P64[Hp] = _sgmdd::P64;
           R2 = _sgmdb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.265337804 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp1_closure" {
     Data.Functor.Contravariant.$fNumOp1_closure:
         const Data.Functor.Contravariant.$fNumOp1_info;
 },
 Data.Functor.Contravariant.$fNumOp1_entry() //  [R2, R3, R4]
         { info_tbl: [(cgmQV,
                       label: Data.Functor.Contravariant.$fNumOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmQV: // global
           _sgmdh::P64 = R4;
           _sgmdg::P64 = R3;
           _sgmdf::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgmQW; else goto cgmQX;
       cgmQX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgmQZ; else goto cgmQY;
       cgmQZ: // global
           HpAlloc = 32;
           goto cgmQW;
       cgmQW: // global
           R4 = _sgmdh::P64;
           R3 = _sgmdg::P64;
           R2 = _sgmdf::P64;
           R1 = Data.Functor.Contravariant.$fNumOp1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmQY: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmdg::P64;
           P64[Hp] = _sgmdh::P64;
           R2 = _sgmdf::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.2701957 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp_$cfromInteger_closure" {
     Data.Functor.Contravariant.$fNumOp_$cfromInteger_closure:
         const Data.Functor.Contravariant.$fNumOp_$cfromInteger_info;
 },
 x_sgmdl_entry() //  [R1]
         { info_tbl: [(cgmRg,
                       label: x_sgmdl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmRg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgmRh; else goto cgmRi;
       cgmRh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmRi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgmdn_entry() //  [R1]
         { info_tbl: [(cgmRo,
                       label: sat_sgmdn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmRo: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fNumOp_$cfromInteger_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cgmRr,
                       label: Data.Functor.Contravariant.$fNumOp_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmRr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgmRv; else goto cgmRu;
       cgmRv: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fNumOp_$cfromInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmRu: // global
           I64[Hp - 40] = x_sgmdl_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sgmdn_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.279121379 UTC

[section ""data" . Data.Functor.Contravariant.$fNumOp_closure" {
     Data.Functor.Contravariant.$fNumOp_closure:
         const Data.Functor.Contravariant.$fNumOp_info;
         const 0;
 },
 sat_sgmdv_entry() //  [R1, R2]
         { info_tbl: [(cgmRX,
                       label: sat_sgmdv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmRX: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fNumOp_$cfromInteger_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdu_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmS5,
                       label: sat_sgmdu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmS5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fNumOp1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdt_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmSd,
                       label: sat_sgmdt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmSd: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fNumOp2_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmds_entry() //  [R1, R2]
         { info_tbl: [(cgmSl,
                       label: sat_sgmds_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmSl: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fNumOp_$cnegate_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdr_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgmSt,
                       label: sat_sgmdr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmSt: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fNumOp3_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdq_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgmSB,
                       label: sat_sgmdq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmSB: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fNumOp4_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdp_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgmSJ,
                       label: sat_sgmdp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmSJ: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fNumOp5_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fNumOp_entry() //  [R2]
         { info_tbl: [(cgmSN,
                       label: Data.Functor.Contravariant.$fNumOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmSN: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto cgmSR; else goto cgmSQ;
       cgmSR: // global
           HpAlloc = 176;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fNumOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmSQ: // global
           I64[Hp - 168] = sat_sgmdv_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sgmdu_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sgmdt_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sgmds_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgmdr_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgmdq_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgmdp_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 69;
           P64[Hp - 40] = Hp - 85;
           P64[Hp - 32] = Hp - 101;
           P64[Hp - 24] = Hp - 119;
           P64[Hp - 16] = Hp - 134;
           P64[Hp - 8] = Hp - 150;
           P64[Hp] = Hp - 167;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.295492397 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure" {
     Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure:
         const Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_info;
         const 0;
 },
 sat_sgmdx_entry() //  [R1]
         { info_tbl: [(cgmTF,
                       label: sat_sgmdx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmTF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmTG; else goto cgmTH;
       cgmTG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmTH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_entry() //  [R2]
         { info_tbl: [(cgmTI,
                       label: Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmTI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgmTM; else goto cgmTL;
       cgmTM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmTL: // global
           I64[Hp - 16] = sat_sgmdx_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Contravariant.$fNumOp_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.301653351 UTC

[section ""data" . Data.Functor.Contravariant.$fFractionalOp_closure" {
     Data.Functor.Contravariant.$fFractionalOp_closure:
         const Data.Functor.Contravariant.$fFractionalOp_info;
         const 0;
 },
 sat_sgmdC_entry() //  [R1, R2]
         { info_tbl: [(cgmU6,
                       label: sat_sgmdC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmU6: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFractionalOp_$cfromRational_entry(R3,
                                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdB_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmUe,
                       label: sat_sgmdB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmUe: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFractionalOp1_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdA_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgmUm,
                       label: sat_sgmdA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmUm: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fFractionalOp2_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdz_entry() //  [R1]
         { info_tbl: [(cgmUt,
                       label: sat_sgmdz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmUt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmUu; else goto cgmUv;
       cgmUu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmUv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFractionalOp_entry() //  [R2]
         { info_tbl: [(cgmUx,
                       label: Data.Functor.Contravariant.$fFractionalOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmUx: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgmUB; else goto cgmUA;
       cgmUB: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFractionalOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmUA: // global
           I64[Hp - 104] = sat_sgmdC_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgmdB_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgmdA_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgmdz_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 69;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.313126289 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure" {
     Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure:
         const Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_info;
         const 0;
 },
 sat_sgmdE_entry() //  [R1]
         { info_tbl: [(cgmVc,
                       label: sat_sgmdE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmVc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmVd; else goto cgmVe;
       cgmVd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmVe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_entry() //  [R2]
         { info_tbl: [(cgmVf,
                       label: Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmVf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgmVj; else goto cgmVi;
       cgmVj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmVi: // global
           I64[Hp - 16] = sat_sgmdE_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Contravariant.$fFractionalOp_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.322271329 UTC

[section ""data" . Data.Functor.Contravariant.$fFloatingOp_closure" {
     Data.Functor.Contravariant.$fFloatingOp_closure:
         const Data.Functor.Contravariant.$fFloatingOp_info;
         const 0;
 },
 lvl7_sgmdG_entry() //  [R1]
         { info_tbl: [(cgmVC,
                       label: lvl7_sgmdG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmVC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmVD; else goto cgmVE;
       cgmVD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmVE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.pi_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgme4_entry() //  [R1, R2]
         { info_tbl: [(cgmVK,
                       label: sat_sgme4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmVK: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgme3_entry() //  [R1, R2]
         { info_tbl: [(cgmVS,
                       label: sat_sgme3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmVS: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgme2_entry() //  [R1, R2]
         { info_tbl: [(cgmW0,
                       label: sat_sgme2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmW0: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$cexpm1_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgme1_entry() //  [R1, R2]
         { info_tbl: [(cgmW8,
                       label: sat_sgme1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmW8: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Contravariant.$fFloatingOp_$clog1p_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgme0_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmWg,
                       label: sat_sgme0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmWg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp1_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmWo,
                       label: sat_sgmdZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmWo: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdY_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmWw,
                       label: sat_sgmdY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmWw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp3_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdX_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmWE,
                       label: sat_sgmdX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmWE: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp4_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdW_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmWM,
                       label: sat_sgmdW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmWM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp5_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdV_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmWU,
                       label: sat_sgmdV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmWU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp6_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdU_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmX2,
                       label: sat_sgmdU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmX2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp7_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdT_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmXa,
                       label: sat_sgmdT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmXa: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp8_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdS_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmXi,
                       label: sat_sgmdS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmXi: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp9_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdR_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmXq,
                       label: sat_sgmdR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmXq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp10_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmXy,
                       label: sat_sgmdQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmXy: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp11_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdP_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmXG,
                       label: sat_sgmdP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmXG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp12_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdO_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgmXO,
                       label: sat_sgmdO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmXO: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fFloatingOp13_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdN_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgmXW,
                       label: sat_sgmdN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmXW: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Contravariant.$fFloatingOp14_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdM_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmY4,
                       label: sat_sgmdM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmY4: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp15_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdL_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmYc,
                       label: sat_sgmdL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmYc: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp16_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdK_entry() //  [R1, R2, R3]
         { info_tbl: [(cgmYk,
                       label: sat_sgmdK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmYk: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fFloatingOp17_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdJ_entry() //  [R1]
         { info_tbl: [(cgmYs,
                       label: sat_sgmdJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmYs: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmdH_entry() //  [R1]
         { info_tbl: [(cgmYz,
                       label: sat_sgmdH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmYz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgmYA; else goto cgmYB;
       cgmYA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgmYB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fFloatingOp_entry() //  [R2]
         { info_tbl: [(cgmYD,
                       label: Data.Functor.Contravariant.$fFloatingOp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmYD: // global
           Hp = Hp + 592;
           if (Hp > HpLim) (likely: False) goto cgmYH; else goto cgmYG;
       cgmYH: // global
           HpAlloc = 592;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fFloatingOp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgmYG: // global
           I64[Hp - 584] = lvl7_sgmdG_info;
           P64[Hp - 568] = R2;
           I64[Hp - 560] = sat_sgme4_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_sgme3_info;
           P64[Hp - 536] = R2;
           I64[Hp - 528] = sat_sgme2_info;
           P64[Hp - 520] = R2;
           I64[Hp - 512] = sat_sgme1_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_sgme0_info;
           P64[Hp - 488] = R2;
           I64[Hp - 480] = sat_sgmdZ_info;
           P64[Hp - 472] = R2;
           I64[Hp - 464] = sat_sgmdY_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_sgmdX_info;
           P64[Hp - 440] = R2;
           I64[Hp - 432] = sat_sgmdW_info;
           P64[Hp - 424] = R2;
           I64[Hp - 416] = sat_sgmdV_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_sgmdU_info;
           P64[Hp - 392] = R2;
           I64[Hp - 384] = sat_sgmdT_info;
           P64[Hp - 376] = R2;
           I64[Hp - 368] = sat_sgmdS_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_sgmdR_info;
           P64[Hp - 344] = R2;
           I64[Hp - 336] = sat_sgmdQ_info;
           P64[Hp - 328] = R2;
           I64[Hp - 320] = sat_sgmdP_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_sgmdO_info;
           P64[Hp - 296] = R2;
           I64[Hp - 288] = sat_sgmdN_info;
           P64[Hp - 280] = R2;
           I64[Hp - 272] = sat_sgmdM_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_sgmdL_info;
           P64[Hp - 248] = R2;
           I64[Hp - 240] = sat_sgmdK_info;
           P64[Hp - 232] = R2;
           I64[Hp - 224] = sat_sgmdJ_info;
           P64[Hp - 216] = Hp - 584;
           I64[Hp - 208] = sat_sgmdH_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = GHC.Float.C:Floating_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 223;
           P64[Hp - 160] = Hp - 238;
           P64[Hp - 152] = Hp - 254;
           P64[Hp - 144] = Hp - 270;
           P64[Hp - 136] = Hp - 285;
           P64[Hp - 128] = Hp - 301;
           P64[Hp - 120] = Hp - 318;
           P64[Hp - 112] = Hp - 334;
           P64[Hp - 104] = Hp - 350;
           P64[Hp - 96] = Hp - 366;
           P64[Hp - 88] = Hp - 382;
           P64[Hp - 80] = Hp - 398;
           P64[Hp - 72] = Hp - 414;
           P64[Hp - 64] = Hp - 430;
           P64[Hp - 56] = Hp - 446;
           P64[Hp - 48] = Hp - 462;
           P64[Hp - 40] = Hp - 478;
           P64[Hp - 32] = Hp - 494;
           P64[Hp - 24] = Hp - 511;
           P64[Hp - 16] = Hp - 527;
           P64[Hp - 8] = Hp - 543;
           P64[Hp] = Hp - 559;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.367685357 UTC

[section ""data" . Data.Functor.Contravariant.$fCategoryTYPEOp1_closure" {
     Data.Functor.Contravariant.$fCategoryTYPEOp1_closure:
         const Data.Functor.Contravariant.$fCategoryTYPEOp1_info;
 },
 Data.Functor.Contravariant.$fCategoryTYPEOp1_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cgn0S,
                       label: Data.Functor.Contravariant.$fCategoryTYPEOp1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn0S: // global
           R4 = R4;
           _sgme6::P64 = R3;
           R3 = R2;
           R2 = _sgme6::P64;
           call GHC.Base.._entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.371599948 UTC

[section ""data" . Data.Functor.Contravariant.$fCategoryTYPEOp_closure" {
     Data.Functor.Contravariant.$fCategoryTYPEOp_closure:
         const Control.Category.C:Category_con_info;
         const GHC.Base.id_closure+1;
         const Data.Functor.Contravariant.$fCategoryTYPEOp1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.373651999 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence3_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence3_closure:
         const Data.Functor.Contravariant.$fMonoidEquivalence3_info;
 },
 Data.Functor.Contravariant.$fMonoidEquivalence3_entry() //  []
         { info_tbl: [(cgn14,
                       label: Data.Functor.Contravariant.$fMonoidEquivalence3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn14: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.377929337 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence1_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence1_closure:
         const Data.Functor.Contravariant.$fSemigroupEquivalence1_info;
 },
 ds_sgmee_entry() //  [R1]
         { info_tbl: [(cgn1r,
                       label: ds_sgmee_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn1r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgn1s; else goto cgn1t;
       cgn1s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgn1t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fSemigroupEquivalence1_entry(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgmei_entry() //  [R1, R2, R3]
         { info_tbl: [(cgn1F,
                       label: sat_sgmei_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn1F: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgn1G; else goto cgn1H;
       cgn1G: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgn1H: // global
           I64[Sp - 32] = block_cgn1z_info;
           _sgmeg::P64 = R3;
           R3 = R3;
           _sgmef::P64 = R2;
           R2 = R2;
           _sgmee::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _sgmee::P64;
           P64[Sp - 16] = _sgmef::P64;
           P64[Sp - 8] = _sgmeg::P64;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgn1z() //  [R1]
         { info_tbl: [(cgn1z,
                       label: block_cgn1z_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn1z: // global
           if (R1 & 7 == 1) goto cgn1C; else goto cgn1D;
       cgn1C: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgn1D: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupEquivalence1_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cgn1S,
                       label: Data.Functor.Contravariant.$fSemigroupEquivalence1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn1S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgn1T; else goto cgn1U;
       cgn1T: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupEquivalence1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgn1U: // global
           I64[Sp - 16] = block_cgn1h_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugn20; else goto cgn1i;
       ugn20: // global
           call _cgn1h(R1) args: 0, res: 0, upd: 0;
       cgn1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgn1h() //  [R1]
         { info_tbl: [(cgn1h,
                       label: block_cgn1h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn1h: // global
           _sgme9::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgn1P; else goto cgn1Q;
       cgn1P: // global
           R1 = _sgme9::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgn1Q: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgn1Z; else goto cgn1Y;
       cgn1Z: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgn1Y: // global
           _sgmec::P64 = P64[R1 + 6];
           _sgmed::P64 = P64[R1 + 14];
           I64[Hp - 48] = ds_sgmee_info;
           P64[Hp - 32] = _sgmec::P64;
           P64[Hp - 24] = _sgmed::P64;
           I64[Hp - 16] = sat_sgmei_info;
           P64[Hp - 8] = _sgme9::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.390523813 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure:
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_info;
 },
 Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_entry() //  [R2]
         { info_tbl: [(cgn2F,
                       label: Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn2F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgn2G; else goto cgn2H;
       cgn2G: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgn2H: // global
           I64[Sp - 8] = block_cgn2C_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugn2L; else goto cgn2D;
       ugn2L: // global
           call _cgn2C(R1) args: 0, res: 0, upd: 0;
       cgn2D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgn2C() //  [R1]
         { info_tbl: [(cgn2C,
                       label: block_cgn2C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn2C: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Contravariant.$fSemigroupEquivalence1_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.396798674 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence2_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence2_closure:
         const Data.Functor.Contravariant.$fMonoidEquivalence2_info;
 },
 Data.Functor.Contravariant.$fMonoidEquivalence2_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cgn36,
                       label: Data.Functor.Contravariant.$fMonoidEquivalence2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn36: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgn37; else goto cgn38;
       cgn37: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidEquivalence2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgn38: // global
           I64[Sp - 32] = block_cgn30_info;
           _sgmeo::P64 = R3;
           R3 = R5;
           _sgmen::P64 = R2;
           R2 = R4;
           R1 = _sgmen::P64;
           P64[Sp - 24] = _sgmeo::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgn30() //  [R1]
         { info_tbl: [(cgn30,
                       label: block_cgn30_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn30: // global
           if (R1 & 7 == 1) goto cgn33; else goto cgn34;
       cgn33: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgn34: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.402990908 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Functor.Contravariant.$fMonoidEquivalence2_closure+4;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat_closure+1;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_closure" {
     Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_closure:
         const Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_info;
         const 0;
 },
 Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_entry() //  [R2]
         { info_tbl: [(cgn3w,
                       label: Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn3w: // global
           R3 = Data.Functor.Contravariant.$fSemigroupEquivalence_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.407630842 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence1_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence1_closure:
         const Data.Functor.Contravariant.$fMonoidEquivalence1_info;
 },
 Data.Functor.Contravariant.$fMonoidEquivalence1_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cgn3Q,
                       label: Data.Functor.Contravariant.$fMonoidEquivalence1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn3Q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgn3R; else goto ugn4b;
       cgn3R: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidEquivalence1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ugn4b: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cgn3G() args: 0, res: 0, upd: 0;
     }
 },
 _cgn3G() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn3G: // global
           _sgmet::P64 = P64[Sp];
           I64[Sp] = block_cgn3J_info;
           R1 = _sgmet::P64;
           if (R1 & 7 != 0) goto ugn4d; else goto cgn3K;
       ugn4d: // global
           call _cgn3J(R1) args: 0, res: 0, upd: 0;
       cgn3K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgn3J() //  [R1]
         { info_tbl: [(cgn3J,
                       label: block_cgn3J_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn3J: // global
           if (R1 & 7 == 1) goto cgn3N; else goto cgn3O;
       cgn3N: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgn3O: // global
           I64[Sp - 8] = block_cgn3Y_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           _sgmey::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sgmey::P64;
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgn3Y() //  [R1]
         { info_tbl: [(cgn3Y,
                       label: block_cgn3Y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn3Y: // global
           if (R1 & 7 == 1) goto cgn45; else goto cgn49;
       cgn45: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgn49: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cgn3G() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.416275794 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidEquivalence_closure" {
     Data.Functor.Contravariant.$fMonoidEquivalence_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_closure+1;
         const Data.Functor.Contravariant.$fMonoidEquivalence3_closure+2;
         const Data.Functor.Contravariant.$fMonoidEquivalence2_closure+4;
         const Data.Functor.Contravariant.$fMonoidEquivalence1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.418305205 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate3_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate3_closure:
         const Data.Functor.Contravariant.$fMonoidPredicate3_info;
 },
 Data.Functor.Contravariant.$fMonoidPredicate3_entry() //  []
         { info_tbl: [(cgn4M,
                       label: Data.Functor.Contravariant.$fMonoidPredicate3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn4M: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.422508322 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate1_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate1_closure:
         const Data.Functor.Contravariant.$fSemigroupPredicate1_info;
 },
 ds_sgmeG_entry() //  [R1]
         { info_tbl: [(cgn59,
                       label: ds_sgmeG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn59: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgn5a; else goto cgn5b;
       cgn5a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgn5b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Contravariant.$fSemigroupPredicate1_entry(R3,
                                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgmeJ_entry() //  [R1, R2]
         { info_tbl: [(cgn5n,
                       label: sat_sgmeJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn5n: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgn5o; else goto cgn5p;
       cgn5o: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgn5p: // global
           I64[Sp - 24] = block_cgn5h_info;
           _sgmeH::P64 = R2;
           R2 = R2;
           _sgmeG::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sgmeG::P64;
           P64[Sp - 8] = _sgmeH::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgn5h() //  [R1]
         { info_tbl: [(cgn5h,
                       label: block_cgn5h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn5h: // global
           if (R1 & 7 == 1) goto cgn5k; else goto cgn5l;
       cgn5k: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgn5l: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fSemigroupPredicate1_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cgn5A,
                       label: Data.Functor.Contravariant.$fSemigroupPredicate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn5A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgn5B; else goto cgn5C;
       cgn5B: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupPredicate1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgn5C: // global
           I64[Sp - 16] = block_cgn4Z_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugn5I; else goto cgn50;
       ugn5I: // global
           call _cgn4Z(R1) args: 0, res: 0, upd: 0;
       cgn50: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgn4Z() //  [R1]
         { info_tbl: [(cgn4Z,
                       label: block_cgn4Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn4Z: // global
           _sgmeB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgn5x; else goto cgn5y;
       cgn5x: // global
           R1 = _sgmeB::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgn5y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgn5H; else goto cgn5G;
       cgn5H: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgn5G: // global
           _sgmeE::P64 = P64[R1 + 6];
           _sgmeF::P64 = P64[R1 + 14];
           I64[Hp - 48] = ds_sgmeG_info;
           P64[Hp - 32] = _sgmeE::P64;
           P64[Hp - 24] = _sgmeF::P64;
           I64[Hp - 16] = sat_sgmeJ_info;
           P64[Hp - 8] = _sgmeB::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.435580207 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure:
         const Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_info;
 },
 Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_entry() //  [R2]
         { info_tbl: [(cgn6n,
                       label: Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn6n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgn6o; else goto cgn6p;
       cgn6o: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgn6p: // global
           I64[Sp - 8] = block_cgn6k_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugn6t; else goto cgn6l;
       ugn6t: // global
           call _cgn6k(R1) args: 0, res: 0, upd: 0;
       cgn6l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgn6k() //  [R1]
         { info_tbl: [(cgn6k,
                       label: block_cgn6k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn6k: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Functor.Contravariant.$fSemigroupPredicate1_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.442018239 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate2_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate2_closure:
         const Data.Functor.Contravariant.$fMonoidPredicate2_info;
 },
 Data.Functor.Contravariant.$fMonoidPredicate2_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgn6O,
                       label: Data.Functor.Contravariant.$fMonoidPredicate2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn6O: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgn6P; else goto cgn6Q;
       cgn6P: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidPredicate2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgn6Q: // global
           I64[Sp - 24] = block_cgn6I_info;
           _sgmeO::P64 = R2;
           R2 = R4;
           R1 = _sgmeO::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgn6I() //  [R1]
         { info_tbl: [(cgn6I,
                       label: block_cgn6I_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn6I: // global
           if (R1 & 7 == 1) goto cgn6L; else goto cgn6M;
       cgn6L: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgn6M: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.447884563 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Functor.Contravariant.$fMonoidPredicate2_closure+3;
         const Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat_closure+1;
         const Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_closure" {
     Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_closure:
         const Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_info;
         const 0;
 },
 Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_entry() //  [R2]
         { info_tbl: [(cgn7e,
                       label: Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn7e: // global
           R3 = Data.Functor.Contravariant.$fSemigroupPredicate_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.452705766 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate1_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate1_closure:
         const Data.Functor.Contravariant.$fMonoidPredicate1_info;
 },
 Data.Functor.Contravariant.$fMonoidPredicate1_entry() //  [R2, R3]
         { info_tbl: [(cgn7y,
                       label: Data.Functor.Contravariant.$fMonoidPredicate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn7y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgn7z; else goto ugn7T;
       cgn7z: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fMonoidPredicate1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ugn7T: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cgn7o() args: 0, res: 0, upd: 0;
     }
 },
 _cgn7o() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn7o: // global
           _sgmeT::P64 = P64[Sp];
           I64[Sp] = block_cgn7r_info;
           R1 = _sgmeT::P64;
           if (R1 & 7 != 0) goto ugn7V; else goto cgn7s;
       ugn7V: // global
           call _cgn7r(R1) args: 0, res: 0, upd: 0;
       cgn7s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgn7r() //  [R1]
         { info_tbl: [(cgn7r,
                       label: block_cgn7r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn7r: // global
           if (R1 & 7 == 1) goto cgn7v; else goto cgn7w;
       cgn7v: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgn7w: // global
           I64[Sp - 8] = block_cgn7G_info;
           R2 = P64[Sp + 8];
           _sgmeX::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sgmeX::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgn7G() //  [R1]
         { info_tbl: [(cgn7G,
                       label: block_cgn7G_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn7G: // global
           if (R1 & 7 == 1) goto cgn7N; else goto cgn7R;
       cgn7N: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgn7R: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cgn7o() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.46154291 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidPredicate_closure" {
     Data.Functor.Contravariant.$fMonoidPredicate_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fSemigroupPredicate_closure+1;
         const Data.Functor.Contravariant.$fMonoidPredicate3_closure+1;
         const Data.Functor.Contravariant.$fMonoidPredicate2_closure+3;
         const Data.Functor.Contravariant.$fMonoidPredicate1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.4635254 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_info;
 },
 Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_entry() //  []
         { info_tbl: [(cgn8t,
                       label: Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn8t: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.467730877 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProxy_closure" {
     Data.Functor.Contravariant.$fContravariantProxy_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantProxy_$ccontramap_closure+2;
         const Data.Functor.Contravariant.$fContravariantProxy_$c>$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.469928786 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantCompose2_closure" {
     Data.Functor.Contravariant.$fContravariantCompose2_closure:
         const Data.Functor.Contravariant.$fContravariantCompose2_info;
 },
 sat_sgmf5_entry() //  [R1]
         { info_tbl: [(cgn8L,
                       label: sat_sgmf5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn8L: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgn8M; else goto cgn8N;
       cgn8M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgn8N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantCompose2_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgn8O,
                       label: Data.Functor.Contravariant.$fContravariantCompose2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn8O: // global
           _sgmf4::P64 = R5;
           _sgmf3::P64 = R4;
           _sgmf2::P64 = R3;
           _sgmf1::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgn8P; else goto cgn8Q;
       cgn8Q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgn8S; else goto cgn8R;
       cgn8S: // global
           HpAlloc = 32;
           goto cgn8P;
       cgn8P: // global
           R5 = _sgmf4::P64;
           R4 = _sgmf3::P64;
           R3 = _sgmf2::P64;
           R2 = _sgmf1::P64;
           R1 = Data.Functor.Contravariant.$fContravariantCompose2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgn8R: // global
           I64[Hp - 24] = sat_sgmf5_info;
           P64[Hp - 8] = _sgmf2::P64;
           P64[Hp] = _sgmf3::P64;
           R2 = _sgmf1::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgmf4::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.476597621 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantCompose_closure" {
     Data.Functor.Contravariant.$fContravariantCompose_closure:
         const Data.Functor.Contravariant.$fContravariantCompose_info;
 },
 sat_sgmf9_entry() //  [R1, R2, R3]
         { info_tbl: [(cgn9h,
                       label: sat_sgmf9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn9h: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantCompose1_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmf8_entry() //  [R1, R2, R3]
         { info_tbl: [(cgn9p,
                       label: sat_sgmf8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn9p: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantCompose2_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantCompose_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cgn9t,
                       label: Data.Functor.Contravariant.$fContravariantCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn9t: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgn9x; else goto cgn9w;
       cgn9x: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgn9w: // global
           I64[Hp - 64] = sat_sgmf9_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgmf8_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.484561141 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantConst2_closure" {
     Data.Functor.Contravariant.$fContravariantConst2_closure:
         const Data.Functor.Contravariant.$fContravariantConst2_info;
 },
 Data.Functor.Contravariant.$fContravariantConst2_entry() //  [R3]
         { info_tbl: [(cgn9S,
                       label: Data.Functor.Contravariant.$fContravariantConst2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn9S: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.487877122 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantConst_closure" {
     Data.Functor.Contravariant.$fContravariantConst_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantConst2_closure+2;
         const Data.Functor.Contravariant.$fContravariantConst1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.490644006 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_info;
 },
 sat_sgmfk_entry() //  [R1]
         { info_tbl: [(cgnad,
                       label: sat_sgmfk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnad: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgnae; else goto cgnaf;
       cgnae: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgnaf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgmfj_entry() //  [R1]
         { info_tbl: [(cgnak,
                       label: sat_sgmfj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnak: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgnal; else goto cgnam;
       cgnal: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgnam: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_entry() //  [R2,
                                                                            R3, R4, R5]
         { info_tbl: [(cgnan,
                       label: Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnan: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgnap; else goto cgnaq;
       cgnap: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgnaq: // global
           I64[Sp - 32] = block_cgna4_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugnau; else goto cgna5;
       ugnau: // global
           call _cgna4(R1) args: 0, res: 0, upd: 0;
       cgna5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgna4() //  [R1]
         { info_tbl: [(cgna4,
                       label: block_cgna4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgna4: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgnat; else goto cgnas;
       cgnat: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgnas: // global
           _sgmfh::P64 = P64[R1 + 7];
           _sgmfi::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgmfk_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sgmfe::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sgmfe::P64;
           P64[Hp - 64] = _sgmfi::P64;
           I64[Hp - 56] = sat_sgmfj_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgmfe::P64;
           P64[Hp - 24] = _sgmfh::P64;
           I64[Hp - 16] = Data.Functor.Product.Pair_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.501759772 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantProduct_closure" {
     Data.Functor.Contravariant.$fContravariantProduct_closure:
         const Data.Functor.Contravariant.$fContravariantProduct_info;
 },
 sat_sgmfo_entry() //  [R1, R2, R3]
         { info_tbl: [(cgnbc,
                       label: sat_sgmfo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnbc: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantProduct_$c>$_entry(R5,
                                                                             R4,
                                                                             R3,
                                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmfn_entry() //  [R1, R2, R3]
         { info_tbl: [(cgnbk,
                       label: sat_sgmfn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnbk: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantProduct_$ccontramap_entry(R5,
                                                                                    R4,
                                                                                    R3,
                                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantProduct_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cgnbo,
                       label: Data.Functor.Contravariant.$fContravariantProduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnbo: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgnbs; else goto cgnbr;
       cgnbs: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantProduct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgnbr: // global
           I64[Hp - 64] = sat_sgmfo_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgmfn_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.510803986 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantSum_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantSum_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantSum_$ccontramap_info;
 },
 sat_sgmfv_entry() //  [R1]
         { info_tbl: [(cgnbW,
                       label: sat_sgmfv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnbW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgnbX; else goto cgnbY;
       cgnbX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgnbY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgmfx_entry() //  [R1]
         { info_tbl: [(cgnc5,
                       label: sat_sgmfx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnc5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgnc6; else goto cgnc7;
       cgnc6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgnc7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariantSum_$ccontramap_entry() //  [R2,
                                                                        R3, R4, R5]
         { info_tbl: [(cgncc,
                       label: Data.Functor.Contravariant.$fContravariantSum_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgncc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgncd; else goto cgnce;
       cgncd: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantSum_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgnce: // global
           I64[Sp - 32] = block_cgnbN_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugncn; else goto cgnbO;
       ugncn: // global
           call _cgnbN(R1) args: 0, res: 0, upd: 0;
       cgnbO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgnbN() //  [R1]
         { info_tbl: [(cgnbN,
                       label: block_cgnbN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnbN: // global
           _sgmfr::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cgnc9; else goto cgnca;
       cgnc9: // global
           Hp = Hp + 56;
           _sgmft::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgncm; else goto cgnch;
       cgnch: // global
           _sgmfu::P64 = P64[_sgmft::P64 + 7];
           I64[Hp - 48] = sat_sgmfv_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgmfr::P64;
           P64[Hp - 16] = _sgmfu::P64;
           I64[Hp - 8] = Data.Functor.Sum.InL_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgnca: // global
           Hp = Hp + 56;
           _sgmft::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgncm; else goto cgncl;
       cgncm: // global
           HpAlloc = 56;
           R1 = _sgmft::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgncl: // global
           _sgmfw::P64 = P64[_sgmft::P64 + 6];
           I64[Hp - 48] = sat_sgmfx_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sgmfr::P64;
           P64[Hp - 16] = _sgmfw::P64;
           I64[Hp - 8] = Data.Functor.Sum.InR_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.522064189 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantSum_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariantSum_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariantSum_$c>$_info;
 },
 sat_sgmfD_entry() //  [R1]
         { info_tbl: [(cgnd9,
                       label: sat_sgmfD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnd9: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantSum_$c>$_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgndc,
                       label: Data.Functor.Contravariant.$fContravariantSum_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgndc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgndg; else goto cgndf;
       cgndg: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantSum_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgndf: // global
           I64[Hp - 8] = sat_sgmfD_info;
           P64[Hp] = R4;
           R5 = R5;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Contravariant.$fContravariantSum_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.527852837 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantSum_closure" {
     Data.Functor.Contravariant.$fContravariantSum_closure:
         const Data.Functor.Contravariant.$fContravariantSum_info;
 },
 sat_sgmfH_entry() //  [R1, R2, R3]
         { info_tbl: [(cgndy,
                       label: sat_sgmfH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgndy: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantSum_$c>$_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmfG_entry() //  [R1, R2, R3]
         { info_tbl: [(cgndG,
                       label: sat_sgmfG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgndG: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariantSum_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariantSum_entry() //  [R2, R3]
         { info_tbl: [(cgndK,
                       label: Data.Functor.Contravariant.$fContravariantSum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgndK: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgndO; else goto cgndN;
       cgndO: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariantSum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgndN: // global
           I64[Hp - 64] = sat_sgmfH_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgmfG_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.536174953 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_info;
 },
 sat_sgmfO_entry() //  [R1]
         { info_tbl: [(cgnei,
                       label: sat_sgmfO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnei: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgnej; else goto cgnek;
       cgnej: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgnek: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgmfQ_entry() //  [R1]
         { info_tbl: [(cgner,
                       label: sat_sgmfQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgner: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgnes; else goto cgnet;
       cgnes: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgnet: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_entry() //  [R2,
                                                                        R3, R4, R5]
         { info_tbl: [(cgney,
                       label: Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgney: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgnez; else goto cgneA;
       cgnez: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgneA: // global
           I64[Sp - 32] = block_cgne9_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugneJ; else goto cgnea;
       ugneJ: // global
           call _cgne9(R1) args: 0, res: 0, upd: 0;
       cgnea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgne9() //  [R1]
         { info_tbl: [(cgne9,
                       label: block_cgne9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgne9: // global
           _sgmfK::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cgnev; else goto cgnew;
       cgnev: // global
           Hp = Hp + 56;
           _sgmfM::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgneI; else goto cgneD;
       cgneD: // global
           _sgmfN::P64 = P64[_sgmfM::P64 + 7];
           I64[Hp - 48] = sat_sgmfO_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgmfK::P64;
           P64[Hp - 16] = _sgmfN::P64;
           I64[Hp - 8] = GHC.Generics.L1_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgnew: // global
           Hp = Hp + 56;
           _sgmfM::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cgneI; else goto cgneH;
       cgneI: // global
           HpAlloc = 56;
           R1 = _sgmfM::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgneH: // global
           _sgmfP::P64 = P64[_sgmfM::P64 + 6];
           I64[Hp - 48] = sat_sgmfQ_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sgmfK::P64;
           P64[Hp - 16] = _sgmfP::P64;
           I64[Hp - 8] = GHC.Generics.R1_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.548051243 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:+:_$c>$_closure" {
     Data.Functor.Contravariant.$fContravariant:+:_$c>$_closure:
         const Data.Functor.Contravariant.$fContravariant:+:_$c>$_info;
 },
 sat_sgmfW_entry() //  [R1]
         { info_tbl: [(cgnfv,
                       label: sat_sgmfW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnfv: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:+:_$c>$_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgnfy,
                       label: Data.Functor.Contravariant.$fContravariant:+:_$c>$_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnfy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgnfC; else goto cgnfB;
       cgnfC: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:+:_$c>$_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgnfB: // global
           I64[Hp - 8] = sat_sgmfW_info;
           P64[Hp] = R4;
           R5 = R5;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.554446304 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:+:_closure" {
     Data.Functor.Contravariant.$fContravariant:+:_closure:
         const Data.Functor.Contravariant.$fContravariant:+:_info;
 },
 sat_sgmg0_entry() //  [R1, R2, R3]
         { info_tbl: [(cgnfU,
                       label: sat_sgmg0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnfU: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:+:_$c>$_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmfZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgng2,
                       label: sat_sgmfZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgng2: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:+:_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:+:_entry() //  [R2, R3]
         { info_tbl: [(cgng6,
                       label: Data.Functor.Contravariant.$fContravariant:+:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgng6: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgnga; else goto cgng9;
       cgnga: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:+:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgng9: // global
           I64[Hp - 64] = sat_sgmg0_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgmfZ_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.562553825 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:.:2_closure" {
     Data.Functor.Contravariant.$fContravariant:.:2_closure:
         const Data.Functor.Contravariant.$fContravariant:.:2_info;
 },
 sat_sgmg5_entry() //  [R1]
         { info_tbl: [(cgngz,
                       label: sat_sgmg5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgngz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgngA; else goto cgngB;
       cgngA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgngB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:.:2_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cgngC,
                       label: Data.Functor.Contravariant.$fContravariant:.:2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgngC: // global
           _sgmg4::P64 = R5;
           _sgmg3::P64 = R4;
           _sgmg2::P64 = R3;
           _sgmg1::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgngD; else goto cgngE;
       cgngE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgngG; else goto cgngF;
       cgngG: // global
           HpAlloc = 32;
           goto cgngD;
       cgngD: // global
           R5 = _sgmg4::P64;
           R4 = _sgmg3::P64;
           R3 = _sgmg2::P64;
           R2 = _sgmg1::P64;
           R1 = Data.Functor.Contravariant.$fContravariant:.:2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgngF: // global
           I64[Hp - 24] = sat_sgmg5_info;
           P64[Hp - 8] = _sgmg2::P64;
           P64[Hp] = _sgmg3::P64;
           R2 = _sgmg1::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgmg4::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.569359533 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:.:_closure" {
     Data.Functor.Contravariant.$fContravariant:.:_closure:
         const Data.Functor.Contravariant.$fContravariant:.:_info;
 },
 sat_sgmg9_entry() //  [R1, R2, R3]
         { info_tbl: [(cgnh5,
                       label: sat_sgmg9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnh5: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:.:1_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmg8_entry() //  [R1, R2, R3]
         { info_tbl: [(cgnhd,
                       label: sat_sgmg8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnhd: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:.:2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:.:_entry() //  [R2, R3]
         { info_tbl: [(cgnhh,
                       label: Data.Functor.Contravariant.$fContravariant:.:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnhh: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgnhl; else goto cgnhk;
       cgnhl: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:.:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgnhk: // global
           I64[Hp - 64] = sat_sgmg9_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgmg8_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.577872888 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_info;
 },
 sat_sgmgi_entry() //  [R1]
         { info_tbl: [(cgnhP,
                       label: sat_sgmgi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnhP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgnhQ; else goto cgnhR;
       cgnhQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgnhR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgmgh_entry() //  [R1]
         { info_tbl: [(cgnhW,
                       label: sat_sgmgh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnhW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgnhX; else goto cgnhY;
       cgnhX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgnhY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Contravariant.contramap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_entry() //  [R2,
                                                                        R3, R4, R5]
         { info_tbl: [(cgnhZ,
                       label: Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnhZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgni1; else goto cgni2;
       cgni1: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgni2: // global
           I64[Sp - 32] = block_cgnhG_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugni6; else goto cgnhH;
       ugni6: // global
           call _cgnhG(R1) args: 0, res: 0, upd: 0;
       cgnhH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgnhG() //  [R1]
         { info_tbl: [(cgnhG,
                       label: block_cgnhG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnhG: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgni5; else goto cgni4;
       cgni5: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgni4: // global
           _sgmgf::P64 = P64[R1 + 7];
           _sgmgg::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgmgi_info;
           P64[Hp - 80] = P64[Sp + 16];
           _sgmgc::P64 = P64[Sp + 24];
           P64[Hp - 72] = _sgmgc::P64;
           P64[Hp - 64] = _sgmgg::P64;
           I64[Hp - 56] = sat_sgmgh_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sgmgc::P64;
           P64[Hp - 24] = _sgmgf::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.590021029 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariant:*:_closure" {
     Data.Functor.Contravariant.$fContravariant:*:_closure:
         const Data.Functor.Contravariant.$fContravariant:*:_info;
 },
 sat_sgmgm_entry() //  [R1, R2, R3]
         { info_tbl: [(cgniO,
                       label: sat_sgmgm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgniO: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:*:_$c>$_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgmgl_entry() //  [R1, R2, R3]
         { info_tbl: [(cgniW,
                       label: sat_sgmgl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgniW: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Contravariant.$fContravariant:*:_$ccontramap_entry(R5,
                                                                                R4,
                                                                                R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Contravariant.$fContravariant:*:_entry() //  [R2, R3]
         { info_tbl: [(cgnj0,
                       label: Data.Functor.Contravariant.$fContravariant:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnj0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgnj4; else goto cgnj3;
       cgnj4: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fContravariant:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgnj3: // global
           I64[Hp - 64] = sat_sgmgm_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgmgl_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.597604565 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantK3_closure" {
     Data.Functor.Contravariant.$fContravariantK3_closure:
         const Data.Functor.Contravariant.$fContravariantK3_info;
 },
 Data.Functor.Contravariant.$fContravariantK3_entry() //  [R3]
         { info_tbl: [(cgnjp,
                       label: Data.Functor.Contravariant.$fContravariantK3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnjp: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.600863146 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantK1_closure" {
     Data.Functor.Contravariant.$fContravariantK1_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantK3_closure+2;
         const Data.Functor.Contravariant.$fContravariantK2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.603008526 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantU1_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantU1_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantU1_$ccontramap_info;
 },
 Data.Functor.Contravariant.$fContravariantU1_$ccontramap_entry() //  []
         { info_tbl: [(cgnjB,
                       label: Data.Functor.Contravariant.$fContravariantU1_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnjB: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.606495123 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantU1_closure" {
     Data.Functor.Contravariant.$fContravariantU1_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantU1_$ccontramap_closure+2;
         const Data.Functor.Contravariant.$fContravariantU1_$c>$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.608455386 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantV1_$ccontramap_closure" {
     Data.Functor.Contravariant.$fContravariantV1_$ccontramap_closure:
         const Data.Functor.Contravariant.$fContravariantV1_$ccontramap_info;
 },
 Data.Functor.Contravariant.$fContravariantV1_$ccontramap_entry() //  [R3]
         { info_tbl: [(cgnjP,
                       label: Data.Functor.Contravariant.$fContravariantV1_$ccontramap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnjP: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.612101636 UTC

[section ""data" . Data.Functor.Contravariant.$fContravariantV1_closure" {
     Data.Functor.Contravariant.$fContravariantV1_closure:
         const Data.Functor.Contravariant.C:Contravariant_con_info;
         const Data.Functor.Contravariant.$fContravariantV1_$ccontramap_closure+2;
         const Data.Functor.Contravariant.$fContravariantV1_$c>$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.614324327 UTC

[section ""data" . lvl2_rgjLt_closure" {
     lvl2_rgjLt_closure:
         const lvl2_rgjLt_info;
         const 0;
 },
 lvl2_rgjLt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgnk4,
                       label: lvl2_rgjLt_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnk4: // global
           _sgmgx::P64 = R5;
           _sgmgw::P64 = R4;
           _sgmgv::P64 = R3;
           _sgmgu::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgnk5; else goto cgnk6;
       cgnk6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgnk8; else goto cgnk7;
       cgnk8: // global
           HpAlloc = 32;
           goto cgnk5;
       cgnk5: // global
           R5 = _sgmgx::P64;
           R4 = _sgmgw::P64;
           R3 = _sgmgv::P64;
           R2 = _sgmgu::P64;
           R1 = lvl2_rgjLt_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgnk7: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgmgw::P64;
           P64[Hp] = _sgmgx::P64;
           R2 = _sgmgu::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgmgv::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.$fSemigroupOrdering_$cstimes_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.619280268 UTC

[section ""data" . lvl3_rgjLu_closure" {
     lvl3_rgjLu_closure:
         const lvl3_rgjLu_info;
         const 0;
 },
 lvl3_rgjLu_entry() //  [R2]
         { info_tbl: [(cgnko,
                       label: lvl3_rgjLu_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnko: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgnkp; else goto cgnkq;
       cgnkp: // global
           R2 = R2;
           R1 = lvl3_rgjLu_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgnkq: // global
           I64[Sp - 8] = block_cgnkl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugnku; else goto cgnkm;
       ugnku: // global
           call _cgnkl(R1) args: 0, res: 0, upd: 0;
       cgnkm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgnkl() //  [R1]
         { info_tbl: [(cgnkl,
                       label: block_cgnkl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnkl: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = GHC.Base.$fSemigroupOrdering_closure;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.625778159 UTC

[section ""data" . lvl4_rgjLv_closure" {
     lvl4_rgjLv_closure:
         const lvl4_rgjLv_info;
 },
 lvl4_rgjLv_entry() //  [R2, R3, R4]
         { info_tbl: [(cgnkQ,
                       label: lvl4_rgjLv_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnkQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgnkR; else goto cgnkS;
       cgnkR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl4_rgjLv_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgnkS: // global
           I64[Sp - 24] = block_cgnkJ_info;
           _sgmgD::P64 = R2;
           R2 = R4;
           R1 = _sgmgD::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgnkJ() //  [R1]
         { info_tbl: [(cgnkJ,
                       label: block_cgnkJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnkJ: // global
           _cgnkP::P64 = R1 & 7;
           if (_cgnkP::P64 < 3) goto ugnl2; else goto cgnkO;
       ugnl2: // global
           if (_cgnkP::P64 < 2) goto cgnkM; else goto cgnkN;
       cgnkM: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgnkN: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cgnkO: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.631612244 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure" {
     Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure:
         const GHC.Base.C:Semigroup_con_info;
         const lvl4_rgjLv_closure+3;
         const lvl3_rgjLu_closure+1;
         const lvl2_rgjLt_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.633716348 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison2_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison2_closure:
         const Data.Functor.Contravariant.$fSemigroupComparison2_info;
         const 0;
 },
 Data.Functor.Contravariant.$fSemigroupComparison2_entry() //  [R2]
         { info_tbl: [(cgnlp,
                       label: Data.Functor.Contravariant.$fSemigroupComparison2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnlp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgnlq; else goto cgnlr;
       cgnlq: // global
           R2 = R2;
           R1 = Data.Functor.Contravariant.$fSemigroupComparison2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgnlr: // global
           I64[Sp - 8] = block_cgnlm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugnlv; else goto cgnln;
       ugnlv: // global
           call _cgnlm(R1) args: 0, res: 0, upd: 0;
       cgnln: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgnlm() //  [R1]
         { info_tbl: [(cgnlm,
                       label: block_cgnlm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnlm: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure+1;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.639360708 UTC

[section ""data" . Data.Functor.Contravariant.$fSemigroupComparison_closure" {
     Data.Functor.Contravariant.$fSemigroupComparison_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Functor.Contravariant.$fSemigroupComparison3_closure+3;
         const Data.Functor.Contravariant.$fSemigroupComparison2_closure+1;
         const Data.Functor.Contravariant.$fSemigroupComparison1_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.641353371 UTC

[section ""data" . lvl5_rgjLw_closure" {
     lvl5_rgjLw_closure:
         const lvl5_rgjLw_info;
 },
 lvl5_rgjLw_entry() //  []
         { info_tbl: [(cgnlL,
                       label: lvl5_rgjLw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnlL: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.644761605 UTC

[section ""data" . lvl6_rgjLx_closure" {
     lvl6_rgjLx_closure:
         const lvl6_rgjLx_info;
         const 0;
 },
 lvl6_rgjLx_entry() //  [R2, R3]
         { info_tbl: [(cgnlY,
                       label: lvl6_rgjLx_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnlY: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.$fMonoidOrdering_closure;
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.648127643 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure" {
     Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure+1;
         const lvl5_rgjLw_closure+1;
         const lvl4_rgjLv_closure+3;
         const lvl6_rgjLx_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.650674851 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison1_closure" {
     Data.Functor.Contravariant.$fMonoidComparison1_closure:
         const Data.Functor.Contravariant.$fMonoidComparison1_info;
         const 0;
 },
 Data.Functor.Contravariant.$fMonoidComparison1_entry() //  [R2, R3]
         { info_tbl: [(cgnma,
                       label: Data.Functor.Contravariant.$fMonoidComparison1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnma: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure+1;
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.654259869 UTC

[section ""data" . Data.Functor.Contravariant.$fMonoidComparison_closure" {
     Data.Functor.Contravariant.$fMonoidComparison_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Functor.Contravariant.$fSemigroupComparison_closure+1;
         const Data.Functor.Contravariant.$fMonoidComparison3_closure+2;
         const Data.Functor.Contravariant.$fMonoidComparison2_closure+3;
         const Data.Functor.Contravariant.$fMonoidComparison1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.656962706 UTC

[section ""data" . Data.Functor.Contravariant.C:Contravariant_closure" {
     Data.Functor.Contravariant.C:Contravariant_closure:
         const Data.Functor.Contravariant.C:Contravariant_info;
 },
 Data.Functor.Contravariant.C:Contravariant_entry() //  [R2, R3]
         { info_tbl: [(cgnmn,
                       label: Data.Functor.Contravariant.C:Contravariant_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnmn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgnmr; else goto cgnmq;
       cgnmr: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Contravariant.C:Contravariant_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgnmq: // global
           I64[Hp - 16] = Data.Functor.Contravariant.C:Contravariant_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.660808278 UTC

[Data.Functor.Contravariant.C:Contravariant_con_entry() //  [R1]
         { info_tbl: [(cgnmy,
                       label: Data.Functor.Contravariant.C:Contravariant_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,110,116,114,97,118,97,114,105,97,110,116,46,67,58,67,111,110,116,114,97,118,97,114,105,97,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnmy: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:17.664400877 UTC

[section ""relreadonly" . Sgmyn_srt" {
     Sgmyn_srt:
         const GHC.Base.$fSemigroupOrdering_$cstimes_closure;
         const Data.Functor.Contravariant.$fSemigroupComparison1_closure;
         const sat_sgmaJ_closure;
         const lvl1_rgjLs_closure;
         const lvl_rgjLr_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$clog1mexp_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$cexpm1_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$clog1pexp_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$clog1p_closure;
         const Data.Functor.Contravariant.$fNumOp_$cnegate_closure;
         const Data.Functor.Contravariant.$fNumOp_closure;
         const Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional_closure;
         const Data.Functor.Contravariant.$fFractionalOp_closure;
         const Data.Functor.Contravariant.$fFloatingOp_$cp1Floating_closure;
         const Data.Functor.Contravariant.$fFloatingOp_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const Data.Functor.Contravariant.$fSemigroupEquivalence_closure;
         const Data.Functor.Contravariant.$fSemigroupPredicate_closure;
         const lvl2_rgjLt_closure;
         const GHC.Base.$fSemigroupOrdering_closure;
         const lvl3_rgjLu_closure;
         const Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)_closure;
         const Data.Functor.Contravariant.$fSemigroupComparison2_closure;
         const GHC.Base.$fMonoidOrdering_closure;
         const Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)_closure;
 }]

