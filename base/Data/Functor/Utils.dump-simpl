
==================== Tidy Core ====================
2018-03-16 15:56:19.940038525 UTC

Result size of Tidy Core
  = {terms: 820, types: 1,313, coercions: 441, joins: 0/18}

-- RHS size: {terms: 23, types: 16, coercions: 13, joins: 0/0}
Data.Functor.Utils.$fMonoidMax_$c<> [InlPrag=INLINE (sat-args=2)]
  :: forall a. Ord a => Max a -> Max a -> Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a1xV2)
                 ($dOrd_a1xV3 [Occ=Once] :: Ord a_a1xV2)
                 (m_a1xKp [Occ=Once*] :: Max a_a1xV2)
                 (ds_d1y0s [Occ=Once] :: Max a_a1xV2) ->
                 case ds_d1y0s
                      `cast` (Data.Functor.Utils.N:Max[0] <a_a1xV2>_N
                              :: (Max a_a1xV2 :: *) ~R# (Maybe a_a1xV2 :: *))
                 of wild_X14 {
                   Nothing -> m_a1xKp;
                   Just ipv_s1y0X [Occ=Once] ->
                     case m_a1xKp
                          `cast` (Data.Functor.Utils.N:Max[0] <a_a1xV2>_N
                                  :: (Max a_a1xV2 :: *) ~R# (Maybe a_a1xV2 :: *))
                     of wild1_X6 {
                       Nothing ->
                         wild_X14
                         `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_a1xV2>_N
                                 :: (Maybe a_a1xV2 :: *) ~R# (Max a_a1xV2 :: *));
                       Just x_a1xKs [Occ=Once] ->
                         case >= @ a_a1xV2 $dOrd_a1xV3 x_a1xKs ipv_s1y0X of {
                           GHC.Types.False ->
                             wild_X14
                             `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_a1xV2>_N
                                     :: (Maybe a_a1xV2 :: *) ~R# (Max a_a1xV2 :: *));
                           GHC.Types.True ->
                             wild1_X6
                             `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_a1xV2>_N
                                     :: (Maybe a_a1xV2 :: *) ~R# (Max a_a1xV2 :: *))
                         }
                     }
                 }}]
Data.Functor.Utils.$fMonoidMax_$c<>
  = \ (@ a_a1xV2)
      ($dOrd_a1xV3 :: Ord a_a1xV2)
      (eta_B2 :: Max a_a1xV2)
      (eta1_B1 :: Max a_a1xV2) ->
      case eta1_B1
           `cast` (Data.Functor.Utils.N:Max[0] <a_a1xV2>_N
                   :: (Max a_a1xV2 :: *) ~R# (Maybe a_a1xV2 :: *))
      of wild_X14 {
        Nothing -> eta_B2;
        Just ipv_s1y0S ->
          case eta_B2
               `cast` (Data.Functor.Utils.N:Max[0] <a_a1xV2>_N
                       :: (Max a_a1xV2 :: *) ~R# (Maybe a_a1xV2 :: *))
          of wild1_X6 {
            Nothing ->
              wild_X14
              `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_a1xV2>_N
                      :: (Maybe a_a1xV2 :: *) ~R# (Max a_a1xV2 :: *));
            Just x_a1xKs ->
              case >= @ a_a1xV2 $dOrd_a1xV3 x_a1xKs ipv_s1y0S of {
                GHC.Types.False ->
                  wild_X14
                  `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_a1xV2>_N
                          :: (Maybe a_a1xV2 :: *) ~R# (Max a_a1xV2 :: *));
                GHC.Types.True ->
                  wild1_X6
                  `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_a1xV2>_N
                          :: (Maybe a_a1xV2 :: *) ~R# (Max a_a1xV2 :: *))
              }
          }
      }

-- RHS size: {terms: 36, types: 37, coercions: 13, joins: 0/1}
Data.Functor.Utils.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => Max a -> [Max a] -> Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 210 0}]
Data.Functor.Utils.$w$csconcat
  = \ (@ a_s1ydG)
      (w_s1ydH :: Ord a_s1ydG)
      (ww_s1ydL :: Max a_s1ydG)
      (ww1_s1ydM :: [Max a_s1ydG]) ->
      letrec {
        go_s1y7i [Occ=LoopBreaker]
          :: Max a_s1ydG -> [Max a_s1ydG] -> Max a_s1ydG
        [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
        go_s1y7i
          = \ (b_i1y06 :: Max a_s1ydG) (ds1_i1y07 :: [Max a_s1ydG]) ->
              case ds1_i1y07 of {
                [] -> b_i1y06;
                : c_i1y0f cs_i1y0g ->
                  case (go_s1y7i c_i1y0f cs_i1y0g)
                       `cast` (Data.Functor.Utils.N:Max[0] <a_s1ydG>_N
                               :: (Max a_s1ydG :: *) ~R# (Maybe a_s1ydG :: *))
                  of wild_X14 {
                    Nothing -> b_i1y06;
                    Just ipv_s1y0X ->
                      case b_i1y06
                           `cast` (Data.Functor.Utils.N:Max[0] <a_s1ydG>_N
                                   :: (Max a_s1ydG :: *) ~R# (Maybe a_s1ydG :: *))
                      of wild2_X6 {
                        Nothing ->
                          wild_X14
                          `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_s1ydG>_N
                                  :: (Maybe a_s1ydG :: *) ~R# (Max a_s1ydG :: *));
                        Just x_a1xKs ->
                          case >= @ a_s1ydG w_s1ydH x_a1xKs ipv_s1y0X of {
                            GHC.Types.False ->
                              wild_X14
                              `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_s1ydG>_N
                                      :: (Maybe a_s1ydG :: *) ~R# (Max a_s1ydG :: *));
                            GHC.Types.True ->
                              wild2_X6
                              `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_s1ydG>_N
                                      :: (Maybe a_s1ydG :: *) ~R# (Max a_s1ydG :: *))
                          }
                      }
                  }
              }; } in
      go_s1y7i ww_s1ydL ww1_s1ydM

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Utils.$fSemigroupMax_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => GHC.Base.NonEmpty (Max a) -> Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1ydG)
                 (w_s1ydH [Occ=Once] :: Ord a_s1ydG)
                 (w1_s1ydI [Occ=Once!] :: GHC.Base.NonEmpty (Max a_s1ydG)) ->
                 case w1_s1ydI of
                 { GHC.Base.:| ww1_s1ydL [Occ=Once] ww2_s1ydM [Occ=Once] ->
                 Data.Functor.Utils.$w$csconcat
                   @ a_s1ydG w_s1ydH ww1_s1ydL ww2_s1ydM
                 }}]
Data.Functor.Utils.$fSemigroupMax_$csconcat
  = \ (@ a_s1ydG)
      (w_s1ydH :: Ord a_s1ydG)
      (w1_s1ydI :: GHC.Base.NonEmpty (Max a_s1ydG)) ->
      case w1_s1ydI of { GHC.Base.:| ww1_s1ydL ww2_s1ydM ->
      Data.Functor.Utils.$w$csconcat
        @ a_s1ydG w_s1ydH ww1_s1ydL ww2_s1ydM
      }

Rec {
-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Utils.$fSemigroupMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Semigroup (Max a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)>m,
 Unf=DFun: \ (@ a_a1xKo) (v_B1 :: Ord a_a1xKo) ->
       GHC.Base.C:Semigroup TYPE: Max a_a1xKo
                            Data.Functor.Utils.$fMonoidMax_$c<> @ a_a1xKo v_B1
                            Data.Functor.Utils.$fSemigroupMax_$csconcat @ a_a1xKo v_B1
                            Data.Functor.Utils.$fSemigroupMax_$cstimes @ a_a1xKo v_B1]
Data.Functor.Utils.$fSemigroupMax
  = \ (@ a_a1xV2) ($dOrd_a1xV3 :: Ord a_a1xV2) ->
      GHC.Base.C:Semigroup
        @ (Max a_a1xV2)
        (Data.Functor.Utils.$fMonoidMax_$c<> @ a_a1xV2 $dOrd_a1xV3)
        (Data.Functor.Utils.$fSemigroupMax_$csconcat @ a_a1xV2 $dOrd_a1xV3)
        (Data.Functor.Utils.$fSemigroupMax_$cstimes @ a_a1xV2 $dOrd_a1xV3)

-- RHS size: {terms: 9, types: 23, coercions: 0, joins: 0/0}
Data.Functor.Utils.$fSemigroupMax_$cstimes [Occ=LoopBreaker]
  :: forall a.
     Ord a =>
     forall b. GHC.Real.Integral b => b -> Max a -> Max a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []]
Data.Functor.Utils.$fSemigroupMax_$cstimes
  = \ (@ a_a1xV2)
      ($dOrd_a1xV3 :: Ord a_a1xV2)
      (@ b_a1xVk)
      ($dIntegral_a1xVm :: GHC.Real.Integral b_a1xVk) ->
      GHC.Magic.noinline
        @ (forall b1 a1.
           (GHC.Real.Integral b1, Semigroup a1) =>
           b1 -> a1 -> a1)
        Data.Semigroup.Internal.stimesDefault
        @ b_a1xVk
        @ (Max a_a1xV2)
        $dIntegral_a1xVm
        (Data.Functor.Utils.$fSemigroupMax @ a_a1xV2 $dOrd_a1xV3)
end Rec }

-- RHS size: {terms: 32, types: 32, coercions: 16, joins: 0/1}
Data.Functor.Utils.$fMonoidMax_$cmconcat
  :: forall a. Ord a => [Max a] -> Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 180 0}]
Data.Functor.Utils.$fMonoidMax_$cmconcat
  = \ (@ a_X1xVO)
      ($dOrd_X1xVQ :: Ord a_X1xVO)
      (eta_B1 :: [Max a_X1xVO]) ->
      letrec {
        go_i1y1b [Occ=LoopBreaker] :: [Max a_X1xVO] -> Max a_X1xVO
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i1y1b
          = \ (ds_i1y1c :: [Max a_X1xVO]) ->
              case ds_i1y1c of {
                [] ->
                  (GHC.Base.Nothing @ a_X1xVO)
                  `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_X1xVO>_N
                          :: (Maybe a_X1xVO :: *) ~R# (Max a_X1xVO :: *));
                : y_i1y1h ys_i1y1i ->
                  case (go_i1y1b ys_i1y1i)
                       `cast` (Data.Functor.Utils.N:Max[0] <a_X1xVO>_N
                               :: (Max a_X1xVO :: *) ~R# (Maybe a_X1xVO :: *))
                  of wild1_X14 {
                    Nothing -> y_i1y1h;
                    Just ipv_s1y0X ->
                      case y_i1y1h
                           `cast` (Data.Functor.Utils.N:Max[0] <a_X1xVO>_N
                                   :: (Max a_X1xVO :: *) ~R# (Maybe a_X1xVO :: *))
                      of wild2_X6 {
                        Nothing ->
                          wild1_X14
                          `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_X1xVO>_N
                                  :: (Maybe a_X1xVO :: *) ~R# (Max a_X1xVO :: *));
                        Just x_a1xKs ->
                          case >= @ a_X1xVO $dOrd_X1xVQ x_a1xKs ipv_s1y0X of {
                            GHC.Types.False ->
                              wild1_X14
                              `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_X1xVO>_N
                                      :: (Maybe a_X1xVO :: *) ~R# (Max a_X1xVO :: *));
                            GHC.Types.True ->
                              wild2_X6
                              `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_X1xVO>_N
                                      :: (Maybe a_X1xVO :: *) ~R# (Max a_X1xVO :: *))
                          }
                      }
                  }
              }; } in
      go_i1y1b eta_B1

-- RHS size: {terms: 10, types: 10, coercions: 3, joins: 0/0}
Data.Functor.Utils.$fMonoidMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Monoid (Max a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)>m,
 Unf=DFun: \ (@ a_a1xKn) (v_B1 :: Ord a_a1xKn) ->
       GHC.Base.C:Monoid TYPE: Max a_a1xKn
                         Data.Functor.Utils.$fSemigroupMax @ a_a1xKn v_B1
                         (GHC.Base.Nothing @ a_a1xKn)
                         `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_a1xKn>_N
                                 :: (Maybe a_a1xKn :: *) ~R# (Max a_a1xKn :: *))
                         Data.Functor.Utils.$fMonoidMax_$c<> @ a_a1xKn v_B1
                         Data.Functor.Utils.$fMonoidMax_$cmconcat @ a_a1xKn v_B1]
Data.Functor.Utils.$fMonoidMax
  = \ (@ a_X1xVM) ($dOrd_X1xVO :: Ord a_X1xVM) ->
      GHC.Base.C:Monoid
        @ (Max a_X1xVM)
        (Data.Functor.Utils.$fSemigroupMax @ a_X1xVM $dOrd_X1xVO)
        ((GHC.Base.Nothing @ a_X1xVM)
         `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_X1xVM>_N
                 :: (Maybe a_X1xVM :: *) ~R# (Max a_X1xVM :: *)))
        (Data.Functor.Utils.$fMonoidMax_$c<> @ a_X1xVM $dOrd_X1xVO)
        (Data.Functor.Utils.$fMonoidMax_$cmconcat @ a_X1xVM $dOrd_X1xVO)

-- RHS size: {terms: 23, types: 16, coercions: 13, joins: 0/0}
Data.Functor.Utils.$fMonoidMin_$c<> [InlPrag=INLINE (sat-args=2)]
  :: forall a. Ord a => Min a -> Min a -> Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a1xTV)
                 ($dOrd_a1xTW [Occ=Once] :: Ord a_a1xTV)
                 (m_a1xKh [Occ=Once*] :: Min a_a1xTV)
                 (ds_d1xZC [Occ=Once] :: Min a_a1xTV) ->
                 case ds_d1xZC
                      `cast` (Data.Functor.Utils.N:Min[0] <a_a1xTV>_N
                              :: (Min a_a1xTV :: *) ~R# (Maybe a_a1xTV :: *))
                 of wild_X1f {
                   Nothing -> m_a1xKh;
                   Just ipv_s1y2e [Occ=Once] ->
                     case m_a1xKh
                          `cast` (Data.Functor.Utils.N:Min[0] <a_a1xTV>_N
                                  :: (Min a_a1xTV :: *) ~R# (Maybe a_a1xTV :: *))
                     of wild1_X6 {
                       Nothing ->
                         wild_X1f
                         `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_a1xTV>_N
                                 :: (Maybe a_a1xTV :: *) ~R# (Min a_a1xTV :: *));
                       Just x_a1xKk [Occ=Once] ->
                         case <= @ a_a1xTV $dOrd_a1xTW x_a1xKk ipv_s1y2e of {
                           GHC.Types.False ->
                             wild_X1f
                             `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_a1xTV>_N
                                     :: (Maybe a_a1xTV :: *) ~R# (Min a_a1xTV :: *));
                           GHC.Types.True ->
                             wild1_X6
                             `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_a1xTV>_N
                                     :: (Maybe a_a1xTV :: *) ~R# (Min a_a1xTV :: *))
                         }
                     }
                 }}]
Data.Functor.Utils.$fMonoidMin_$c<>
  = \ (@ a_a1xTV)
      ($dOrd_a1xTW :: Ord a_a1xTV)
      (eta_B2 :: Min a_a1xTV)
      (eta1_B1 :: Min a_a1xTV) ->
      case eta1_B1
           `cast` (Data.Functor.Utils.N:Min[0] <a_a1xTV>_N
                   :: (Min a_a1xTV :: *) ~R# (Maybe a_a1xTV :: *))
      of wild_X1f {
        Nothing -> eta_B2;
        Just ipv_s1y29 ->
          case eta_B2
               `cast` (Data.Functor.Utils.N:Min[0] <a_a1xTV>_N
                       :: (Min a_a1xTV :: *) ~R# (Maybe a_a1xTV :: *))
          of wild1_Xe {
            Nothing ->
              wild_X1f
              `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_a1xTV>_N
                      :: (Maybe a_a1xTV :: *) ~R# (Min a_a1xTV :: *));
            Just x_a1xKk ->
              case <= @ a_a1xTV $dOrd_a1xTW x_a1xKk ipv_s1y29 of {
                GHC.Types.False ->
                  wild_X1f
                  `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_a1xTV>_N
                          :: (Maybe a_a1xTV :: *) ~R# (Min a_a1xTV :: *));
                GHC.Types.True ->
                  wild1_Xe
                  `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_a1xTV>_N
                          :: (Maybe a_a1xTV :: *) ~R# (Min a_a1xTV :: *))
              }
          }
      }

-- RHS size: {terms: 36, types: 37, coercions: 13, joins: 0/1}
Data.Functor.Utils.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => Min a -> [Min a] -> Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 210 0}]
Data.Functor.Utils.$w$csconcat1
  = \ (@ a_s1ydZ)
      (w_s1ye0 :: Ord a_s1ydZ)
      (ww_s1ye4 :: Min a_s1ydZ)
      (ww1_s1ye5 :: [Min a_s1ydZ]) ->
      letrec {
        go_s1y7g [Occ=LoopBreaker]
          :: Min a_s1ydZ -> [Min a_s1ydZ] -> Min a_s1ydZ
        [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
        go_s1y7g
          = \ (b_i1y06 :: Min a_s1ydZ) (ds1_i1y07 :: [Min a_s1ydZ]) ->
              case ds1_i1y07 of {
                [] -> b_i1y06;
                : c_i1y0f cs_i1y0g ->
                  case (go_s1y7g c_i1y0f cs_i1y0g)
                       `cast` (Data.Functor.Utils.N:Min[0] <a_s1ydZ>_N
                               :: (Min a_s1ydZ :: *) ~R# (Maybe a_s1ydZ :: *))
                  of wild_X1f {
                    Nothing -> b_i1y06;
                    Just ipv_s1y2e ->
                      case b_i1y06
                           `cast` (Data.Functor.Utils.N:Min[0] <a_s1ydZ>_N
                                   :: (Min a_s1ydZ :: *) ~R# (Maybe a_s1ydZ :: *))
                      of wild2_X6 {
                        Nothing ->
                          wild_X1f
                          `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_s1ydZ>_N
                                  :: (Maybe a_s1ydZ :: *) ~R# (Min a_s1ydZ :: *));
                        Just x_a1xKk ->
                          case <= @ a_s1ydZ w_s1ye0 x_a1xKk ipv_s1y2e of {
                            GHC.Types.False ->
                              wild_X1f
                              `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_s1ydZ>_N
                                      :: (Maybe a_s1ydZ :: *) ~R# (Min a_s1ydZ :: *));
                            GHC.Types.True ->
                              wild2_X6
                              `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_s1ydZ>_N
                                      :: (Maybe a_s1ydZ :: *) ~R# (Min a_s1ydZ :: *))
                          }
                      }
                  }
              }; } in
      go_s1y7g ww_s1ye4 ww1_s1ye5

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Utils.$fSemigroupMin_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => GHC.Base.NonEmpty (Min a) -> Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1ydZ)
                 (w_s1ye0 [Occ=Once] :: Ord a_s1ydZ)
                 (w1_s1ye1 [Occ=Once!] :: GHC.Base.NonEmpty (Min a_s1ydZ)) ->
                 case w1_s1ye1 of
                 { GHC.Base.:| ww1_s1ye4 [Occ=Once] ww2_s1ye5 [Occ=Once] ->
                 Data.Functor.Utils.$w$csconcat1
                   @ a_s1ydZ w_s1ye0 ww1_s1ye4 ww2_s1ye5
                 }}]
Data.Functor.Utils.$fSemigroupMin_$csconcat
  = \ (@ a_s1ydZ)
      (w_s1ye0 :: Ord a_s1ydZ)
      (w1_s1ye1 :: GHC.Base.NonEmpty (Min a_s1ydZ)) ->
      case w1_s1ye1 of { GHC.Base.:| ww1_s1ye4 ww2_s1ye5 ->
      Data.Functor.Utils.$w$csconcat1
        @ a_s1ydZ w_s1ye0 ww1_s1ye4 ww2_s1ye5
      }

Rec {
-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Utils.$fSemigroupMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Semigroup (Min a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)>m,
 Unf=DFun: \ (@ a_a1xKg) (v_B1 :: Ord a_a1xKg) ->
       GHC.Base.C:Semigroup TYPE: Min a_a1xKg
                            Data.Functor.Utils.$fMonoidMin_$c<> @ a_a1xKg v_B1
                            Data.Functor.Utils.$fSemigroupMin_$csconcat @ a_a1xKg v_B1
                            Data.Functor.Utils.$fSemigroupMin_$cstimes @ a_a1xKg v_B1]
Data.Functor.Utils.$fSemigroupMin
  = \ (@ a_a1xTV) ($dOrd_a1xTW :: Ord a_a1xTV) ->
      GHC.Base.C:Semigroup
        @ (Min a_a1xTV)
        (Data.Functor.Utils.$fMonoidMin_$c<> @ a_a1xTV $dOrd_a1xTW)
        (Data.Functor.Utils.$fSemigroupMin_$csconcat @ a_a1xTV $dOrd_a1xTW)
        (Data.Functor.Utils.$fSemigroupMin_$cstimes @ a_a1xTV $dOrd_a1xTW)

-- RHS size: {terms: 9, types: 23, coercions: 0, joins: 0/0}
Data.Functor.Utils.$fSemigroupMin_$cstimes [Occ=LoopBreaker]
  :: forall a.
     Ord a =>
     forall b. GHC.Real.Integral b => b -> Min a -> Min a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U>,
 Unf=OtherCon []]
Data.Functor.Utils.$fSemigroupMin_$cstimes
  = \ (@ a_a1xTV)
      ($dOrd_a1xTW :: Ord a_a1xTV)
      (@ b_a1xUv)
      ($dIntegral_a1xUx :: GHC.Real.Integral b_a1xUv) ->
      GHC.Magic.noinline
        @ (forall b1 a1.
           (GHC.Real.Integral b1, Semigroup a1) =>
           b1 -> a1 -> a1)
        Data.Semigroup.Internal.stimesDefault
        @ b_a1xUv
        @ (Min a_a1xTV)
        $dIntegral_a1xUx
        (Data.Functor.Utils.$fSemigroupMin @ a_a1xTV $dOrd_a1xTW)
end Rec }

-- RHS size: {terms: 32, types: 32, coercions: 16, joins: 0/1}
Data.Functor.Utils.$fMonoidMin_$cmconcat
  :: forall a. Ord a => [Min a] -> Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 180 0}]
Data.Functor.Utils.$fMonoidMin_$cmconcat
  = \ (@ a_X1xUO)
      ($dOrd_X1xUQ :: Ord a_X1xUO)
      (eta_B1 :: [Min a_X1xUO]) ->
      letrec {
        go_i1y1b [Occ=LoopBreaker] :: [Min a_X1xUO] -> Min a_X1xUO
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i1y1b
          = \ (ds_i1y1c :: [Min a_X1xUO]) ->
              case ds_i1y1c of {
                [] ->
                  (GHC.Base.Nothing @ a_X1xUO)
                  `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_X1xUO>_N
                          :: (Maybe a_X1xUO :: *) ~R# (Min a_X1xUO :: *));
                : y_i1y1h ys_i1y1i ->
                  case (go_i1y1b ys_i1y1i)
                       `cast` (Data.Functor.Utils.N:Min[0] <a_X1xUO>_N
                               :: (Min a_X1xUO :: *) ~R# (Maybe a_X1xUO :: *))
                  of wild1_X1f {
                    Nothing -> y_i1y1h;
                    Just ipv_s1y2e ->
                      case y_i1y1h
                           `cast` (Data.Functor.Utils.N:Min[0] <a_X1xUO>_N
                                   :: (Min a_X1xUO :: *) ~R# (Maybe a_X1xUO :: *))
                      of wild2_X6 {
                        Nothing ->
                          wild1_X1f
                          `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_X1xUO>_N
                                  :: (Maybe a_X1xUO :: *) ~R# (Min a_X1xUO :: *));
                        Just x_a1xKk ->
                          case <= @ a_X1xUO $dOrd_X1xUQ x_a1xKk ipv_s1y2e of {
                            GHC.Types.False ->
                              wild1_X1f
                              `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_X1xUO>_N
                                      :: (Maybe a_X1xUO :: *) ~R# (Min a_X1xUO :: *));
                            GHC.Types.True ->
                              wild2_X6
                              `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_X1xUO>_N
                                      :: (Maybe a_X1xUO :: *) ~R# (Min a_X1xUO :: *))
                          }
                      }
                  }
              }; } in
      go_i1y1b eta_B1

-- RHS size: {terms: 10, types: 10, coercions: 3, joins: 0/0}
Data.Functor.Utils.$fMonoidMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Monoid (Min a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)>m,
 Unf=DFun: \ (@ a_a1xKf) (v_B1 :: Ord a_a1xKf) ->
       GHC.Base.C:Monoid TYPE: Min a_a1xKf
                         Data.Functor.Utils.$fSemigroupMin @ a_a1xKf v_B1
                         (GHC.Base.Nothing @ a_a1xKf)
                         `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_a1xKf>_N
                                 :: (Maybe a_a1xKf :: *) ~R# (Min a_a1xKf :: *))
                         Data.Functor.Utils.$fMonoidMin_$c<> @ a_a1xKf v_B1
                         Data.Functor.Utils.$fMonoidMin_$cmconcat @ a_a1xKf v_B1]
Data.Functor.Utils.$fMonoidMin
  = \ (@ a_X1xUM) ($dOrd_X1xUO :: Ord a_X1xUM) ->
      GHC.Base.C:Monoid
        @ (Min a_X1xUM)
        (Data.Functor.Utils.$fSemigroupMin @ a_X1xUM $dOrd_X1xUO)
        ((GHC.Base.Nothing @ a_X1xUM)
         `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_X1xUM>_N
                 :: (Maybe a_X1xUM :: *) ~R# (Min a_X1xUM :: *)))
        (Data.Functor.Utils.$fMonoidMin_$c<> @ a_X1xUM $dOrd_X1xUO)
        (Data.Functor.Utils.$fMonoidMin_$cmconcat @ a_X1xUM $dOrd_X1xUO)

-- RHS size: {terms: 19, types: 27, coercions: 3, joins: 0/1}
Data.Functor.Utils.$fFunctorStateL2
  :: forall s a b. (a -> b) -> StateL s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ s_a1xSQ)
                 (@ a_a1xSU)
                 (@ b_a1xSV)
                 (f_a1xKa [Occ=Once!] :: a_a1xSU -> b_a1xSV)
                 (ds_d1xZe :: StateL s_a1xSQ a_a1xSU)
                 (s1_a1xKc [Occ=Once] :: s_a1xSQ) ->
                 let {
                   ds1_s1y7e :: (s_a1xSQ, a_a1xSU)
                   [LclId]
                   ds1_s1y7e
                     = (ds_d1xZe
                        `cast` (Data.Functor.Utils.N:StateL[0] <s_a1xSQ>_R <a_a1xSU>_R
                                :: (StateL s_a1xSQ a_a1xSU :: *)
                                   ~R# (s_a1xSQ -> (s_a1xSQ, a_a1xSU) :: *)))
                         s1_a1xKc } in
                 (case ds1_s1y7e of { (s'_a1xT7 [Occ=Once], _ [Occ=Dead]) ->
                  s'_a1xT7
                  },
                  f_a1xKa
                    (case ds1_s1y7e of { (_ [Occ=Dead], v_a1xT9 [Occ=Once]) ->
                     v_a1xT9
                     }))}]
Data.Functor.Utils.$fFunctorStateL2
  = \ (@ s_a1xSQ)
      (@ a_a1xSU)
      (@ b_a1xSV)
      (f_a1xKa :: a_a1xSU -> b_a1xSV)
      (ds_d1xZe :: StateL s_a1xSQ a_a1xSU)
      (s1_a1xKc :: s_a1xSQ) ->
      let {
        ds1_s1y7e [Dmd=<L,U(1*U,1*U)>] :: (s_a1xSQ, a_a1xSU)
        [LclId]
        ds1_s1y7e
          = (ds_d1xZe
             `cast` (Data.Functor.Utils.N:StateL[0] <s_a1xSQ>_R <a_a1xSU>_R
                     :: (StateL s_a1xSQ a_a1xSU :: *)
                        ~R# (s_a1xSQ -> (s_a1xSQ, a_a1xSU) :: *)))
              s1_a1xKc } in
      (case ds1_s1y7e of { (s'_a1xT7, v_a1xT9) -> s'_a1xT7 },
       f_a1xKa (case ds1_s1y7e of { (s'_a1xT7, v_a1xT9) -> v_a1xT9 }))

-- RHS size: {terms: 13, types: 18, coercions: 3, joins: 0/0}
Data.Functor.Utils.$fFunctorStateL1
  :: forall b s a. a -> StateL s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(U(1*U,A))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a1xTl)
                 (@ s_X1xUk)
                 (@ a_a1xTk)
                 (x_X1xZR [Occ=Once] :: a_a1xTk)
                 (ds_X1y0O [Occ=Once] :: StateL s_X1xUk b_a1xTl)
                 (s1_a1xKc [Occ=Once] :: s_X1xUk) ->
                 (case (ds_X1y0O
                        `cast` (Data.Functor.Utils.N:StateL[0] <s_X1xUk>_R <b_a1xTl>_R
                                :: (StateL s_X1xUk b_a1xTl :: *)
                                   ~R# (s_X1xUk -> (s_X1xUk, b_a1xTl) :: *)))
                         s1_a1xKc
                  of
                  { (s'_a1xT7 [Occ=Once], _ [Occ=Dead]) ->
                  s'_a1xT7
                  },
                  x_X1xZR)}]
Data.Functor.Utils.$fFunctorStateL1
  = \ (@ b_a1xTl)
      (@ s_X1xUk)
      (@ a_a1xTk)
      (x_X1xZR :: a_a1xTk)
      (ds_X1y0O :: StateL s_X1xUk b_a1xTl)
      (s1_a1xKc :: s_X1xUk) ->
      (case (ds_X1y0O
             `cast` (Data.Functor.Utils.N:StateL[0] <s_X1xUk>_R <b_a1xTl>_R
                     :: (StateL s_X1xUk b_a1xTl :: *)
                        ~R# (s_X1xUk -> (s_X1xUk, b_a1xTl) :: *)))
              s1_a1xKc
       of
       { (s'_a1xT7, v_a1xT9) ->
       s'_a1xT7
       },
       x_X1xZR)

-- RHS size: {terms: 6, types: 12, coercions: 33, joins: 0/0}
Data.Functor.Utils.$fFunctorStateL [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. Functor (StateL s)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ s_a1xK9) ->
       GHC.Base.C:Functor TYPE: StateL s_a1xK9
                          (Data.Functor.Utils.$fFunctorStateL2 @ s_a1xK9)
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R
                                  ->_R <StateL s_a1xK9 a>_R
                                  ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_a1xK9>_R <b>_R)
                                  :: (forall a b.
                                      (a -> b) -> StateL s_a1xK9 a -> s_a1xK9 -> (s_a1xK9, b) :: *)
                                     ~R# (forall a b.
                                          (a -> b) -> StateL s_a1xK9 a -> StateL s_a1xK9 b :: *))
                          (\ (@ a_a1xTk) (@ b_a1xTl) ->
                             Data.Functor.Utils.$fFunctorStateL1 @ b_a1xTl @ s_a1xK9 @ a_a1xTk)
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R
                                  ->_R <StateL s_a1xK9 b>_R
                                  ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_a1xK9>_R <a>_R)
                                  :: (forall a b.
                                      a -> StateL s_a1xK9 b -> s_a1xK9 -> (s_a1xK9, a) :: *)
                                     ~R# (forall a b.
                                          a -> StateL s_a1xK9 b -> StateL s_a1xK9 a :: *))]
Data.Functor.Utils.$fFunctorStateL
  = \ (@ s_X1xUj) ->
      GHC.Base.C:Functor
        @ (StateL s_X1xUj)
        ((Data.Functor.Utils.$fFunctorStateL2 @ s_X1xUj)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <StateL s_X1xUj a>_R
                 ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_X1xUj>_R <b>_R)
                 :: (forall a b.
                     (a -> b) -> StateL s_X1xUj a -> s_X1xUj -> (s_X1xUj, b) :: *)
                    ~R# (forall a b.
                         (a -> b) -> StateL s_X1xUj a -> StateL s_X1xUj b :: *)))
        ((\ (@ a_a1xTk) (@ b_a1xTl) ->
            Data.Functor.Utils.$fFunctorStateL1 @ b_a1xTl @ s_X1xUj @ a_a1xTk)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R
                 ->_R <StateL s_X1xUj b>_R
                 ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_X1xUj>_R <a>_R)
                 :: (forall a b.
                     a -> StateL s_X1xUj b -> s_X1xUj -> (s_X1xUj, a) :: *)
                    ~R# (forall a b. a -> StateL s_X1xUj b -> StateL s_X1xUj a :: *)))

-- RHS size: {terms: 31, types: 46, coercions: 6, joins: 0/2}
Data.Functor.Utils.$fApplicativeStateL3 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b c.
     (a -> b -> c) -> StateL s a -> StateL s b -> s -> (s, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ s_s1yeg)
                 (@ a_s1yeh)
                 (@ b_s1yei)
                 (@ c_s1yej)
                 (w_s1yek [Occ=Once!] :: a_s1yeh -> b_s1yei -> c_s1yej)
                 (w1_s1yel :: StateL s_s1yeg a_s1yeh)
                 (w2_s1yem :: StateL s_s1yeg b_s1yei)
                 (w3_s1yen [Occ=Once] :: s_s1yeg) ->
                 let {
                   ds_s1y7c [Dmd=<L,U(U,U)>] :: (s_s1yeg, a_s1yeh)
                   [LclId]
                   ds_s1y7c
                     = (w1_s1yel
                        `cast` (Data.Functor.Utils.N:StateL[0] <s_s1yeg>_R <a_s1yeh>_R
                                :: (StateL s_s1yeg a_s1yeh :: *)
                                   ~R# (s_s1yeg -> (s_s1yeg, a_s1yeh) :: *)))
                         w3_s1yen } in
                 let {
                   ds1_s1y7b [Dmd=<L,U(U,U)>] :: (s_s1yeg, b_s1yei)
                   [LclId]
                   ds1_s1y7b
                     = (w2_s1yem
                        `cast` (Data.Functor.Utils.N:StateL[0] <s_s1yeg>_R <b_s1yei>_R
                                :: (StateL s_s1yeg b_s1yei :: *)
                                   ~R# (s_s1yeg -> (s_s1yeg, b_s1yei) :: *)))
                         (case ds_s1y7c of { (s'_a1xS7 [Occ=Once], _ [Occ=Dead]) ->
                          s'_a1xS7
                          }) } in
                 (case ds1_s1y7b of { (s''_a1xSm [Occ=Once], _ [Occ=Dead]) ->
                  s''_a1xSm
                  },
                  w_s1yek
                    (case ds_s1y7c of { (_ [Occ=Dead], x_a1xS9 [Occ=Once]) ->
                     x_a1xS9
                     })
                    (case ds1_s1y7b of { (_ [Occ=Dead], y_a1xSo [Occ=Once]) ->
                     y_a1xSo
                     }))}]
Data.Functor.Utils.$fApplicativeStateL3
  = \ (@ s_s1yeg)
      (@ a_s1yeh)
      (@ b_s1yei)
      (@ c_s1yej)
      (w_s1yek :: a_s1yeh -> b_s1yei -> c_s1yej)
      (w1_s1yel :: StateL s_s1yeg a_s1yeh)
      (w2_s1yem :: StateL s_s1yeg b_s1yei)
      (w3_s1yen :: s_s1yeg) ->
      let {
        ds_s1y7c [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeg, a_s1yeh)
        [LclId]
        ds_s1y7c
          = (w1_s1yel
             `cast` (Data.Functor.Utils.N:StateL[0] <s_s1yeg>_R <a_s1yeh>_R
                     :: (StateL s_s1yeg a_s1yeh :: *)
                        ~R# (s_s1yeg -> (s_s1yeg, a_s1yeh) :: *)))
              w3_s1yen } in
      let {
        ds1_s1y7b [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeg, b_s1yei)
        [LclId]
        ds1_s1y7b
          = (w2_s1yem
             `cast` (Data.Functor.Utils.N:StateL[0] <s_s1yeg>_R <b_s1yei>_R
                     :: (StateL s_s1yeg b_s1yei :: *)
                        ~R# (s_s1yeg -> (s_s1yeg, b_s1yei) :: *)))
              (case ds_s1y7c of { (s'_a1xS7, x_a1xS9) -> s'_a1xS7 }) } in
      (case ds1_s1y7b of { (s''_a1xSm, y_a1xSo) -> s''_a1xSm },
       w_s1yek
         (case ds_s1y7c of { (s'_a1xS7, x_a1xS9) -> x_a1xS9 })
         (case ds1_s1y7b of { (s''_a1xSm, y_a1xSo) -> y_a1xSo }))

-- RHS size: {terms: 28, types: 47, coercions: 7, joins: 0/2}
Data.Functor.Utils.$fApplicativeStateL4 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b. StateL s (a -> b) -> StateL s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*C1(U)))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ s_s1yes)
                 (@ a_s1yet)
                 (@ b_s1yeu)
                 (w_s1yev :: StateL s_s1yes (a_s1yet -> b_s1yeu))
                 (w1_s1yew :: StateL s_s1yes a_s1yet)
                 (w2_s1yex [Occ=Once] :: s_s1yes) ->
                 let {
                   ds_s1y78 [Dmd=<L,U(U,C1(U))>] :: (s_s1yes, a_s1yet -> b_s1yeu)
                   [LclId]
                   ds_s1y78
                     = (w_s1yev
                        `cast` (Data.Functor.Utils.N:StateL[0]
                                    <s_s1yes>_R <a_s1yet -> b_s1yeu>_R
                                :: (StateL s_s1yes (a_s1yet -> b_s1yeu) :: *)
                                   ~R# (s_s1yes -> (s_s1yes, a_s1yet -> b_s1yeu) :: *)))
                         w2_s1yex } in
                 let {
                   ds1_s1y77 [Dmd=<L,U(U,U)>] :: (s_s1yes, a_s1yet)
                   [LclId]
                   ds1_s1y77
                     = (w1_s1yew
                        `cast` (Data.Functor.Utils.N:StateL[0] <s_s1yes>_R <a_s1yet>_R
                                :: (StateL s_s1yes a_s1yet :: *)
                                   ~R# (s_s1yes -> (s_s1yes, a_s1yet) :: *)))
                         (case ds_s1y78 of { (s'_a1xRt [Occ=Once], _ [Occ=Dead]) ->
                          s'_a1xRt
                          }) } in
                 (case ds1_s1y77 of { (s''_a1xRI [Occ=Once], _ [Occ=Dead]) ->
                  s''_a1xRI
                  },
                  case ds_s1y78 of { (_ [Occ=Dead], f_a1xRv [Occ=Once!]) ->
                  f_a1xRv
                    (case ds1_s1y77 of { (_ [Occ=Dead], v_a1xRK [Occ=Once]) ->
                     v_a1xRK
                     })
                  })}]
Data.Functor.Utils.$fApplicativeStateL4
  = \ (@ s_s1yes)
      (@ a_s1yet)
      (@ b_s1yeu)
      (w_s1yev :: StateL s_s1yes (a_s1yet -> b_s1yeu))
      (w1_s1yew :: StateL s_s1yes a_s1yet)
      (w2_s1yex :: s_s1yes) ->
      let {
        ds_s1y78 [Dmd=<L,U(1*U,1*C1(U))>] :: (s_s1yes, a_s1yet -> b_s1yeu)
        [LclId]
        ds_s1y78
          = (w_s1yev
             `cast` (Data.Functor.Utils.N:StateL[0]
                         <s_s1yes>_R <a_s1yet -> b_s1yeu>_R
                     :: (StateL s_s1yes (a_s1yet -> b_s1yeu) :: *)
                        ~R# (s_s1yes -> (s_s1yes, a_s1yet -> b_s1yeu) :: *)))
              w2_s1yex } in
      let {
        ds1_s1y77 [Dmd=<L,U(1*U,1*U)>] :: (s_s1yes, a_s1yet)
        [LclId]
        ds1_s1y77
          = (w1_s1yew
             `cast` (Data.Functor.Utils.N:StateL[0] <s_s1yes>_R <a_s1yet>_R
                     :: (StateL s_s1yes a_s1yet :: *)
                        ~R# (s_s1yes -> (s_s1yes, a_s1yet) :: *)))
              (case ds_s1y78 of { (s'_a1xRt, f_a1xRv) -> s'_a1xRt }) } in
      (case ds1_s1y77 of { (s''_a1xRI, v_a1xRK) -> s''_a1xRI },
       case ds_s1y78 of { (s'_a1xRt, f_a1xRv) ->
       f_a1xRv (case ds1_s1y77 of { (s''_a1xRI, v_a1xRK) -> v_a1xRK })
       })

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
Data.Functor.Utils.$fApplicativeStateL5
  :: forall s a. a -> s -> (s, a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ s_X1xSN)
                 (@ a_a1xR9)
                 (x_a1xJS [Occ=Once] :: a_a1xR9)
                 (s1_a1xJT [Occ=Once] :: s_X1xSN) ->
                 (s1_a1xJT, x_a1xJS)}]
Data.Functor.Utils.$fApplicativeStateL5
  = \ (@ s_X1xSN)
      (@ a_a1xR9)
      (x_a1xJS :: a_a1xR9)
      (s1_a1xJT :: s_X1xSN) ->
      (s1_a1xJT, x_a1xJS)

-- RHS size: {terms: 22, types: 33, coercions: 6, joins: 0/1}
Data.Functor.Utils.$fApplicativeStateL2
  :: forall b a s. StateL s a -> StateL s b -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,A))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a1xSy)
                 (@ a_a1xSx)
                 (@ s_X1xSV)
                 (a1_X1xZN [Occ=Once] :: StateL s_X1xSV a_a1xSx)
                 (a2_X1xZP :: StateL s_X1xSV b_a1xSy)
                 (eta_B1 [Occ=Once] :: s_X1xSV) ->
                 let {
                   ds_s1y74 :: (s_X1xSV, b_a1xSy)
                   [LclId]
                   ds_s1y74
                     = (a2_X1xZP
                        `cast` (Data.Functor.Utils.N:StateL[0] <s_X1xSV>_R <b_a1xSy>_R
                                :: (StateL s_X1xSV b_a1xSy :: *)
                                   ~R# (s_X1xSV -> (s_X1xSV, b_a1xSy) :: *)))
                         (case (a1_X1xZN
                                `cast` (Data.Functor.Utils.N:StateL[0] <s_X1xSV>_R <a_a1xSx>_R
                                        :: (StateL s_X1xSV a_a1xSx :: *)
                                           ~R# (s_X1xSV -> (s_X1xSV, a_a1xSx) :: *)))
                                 eta_B1
                          of
                          { (s'_a1xT7 [Occ=Once], _ [Occ=Dead]) ->
                          s'_a1xT7
                          }) } in
                 (case ds_s1y74 of { (s''_a1xRI [Occ=Once], _ [Occ=Dead]) ->
                  s''_a1xRI
                  },
                  case ds_s1y74 of { (_ [Occ=Dead], v_a1xRK [Occ=Once]) ->
                  v_a1xRK
                  })}]
Data.Functor.Utils.$fApplicativeStateL2
  = \ (@ b_a1xSy)
      (@ a_a1xSx)
      (@ s_X1xSV)
      (a1_X1xZN :: StateL s_X1xSV a_a1xSx)
      (a2_X1xZP :: StateL s_X1xSV b_a1xSy)
      (eta_B1 :: s_X1xSV) ->
      let {
        ds_s1y74 [Dmd=<L,U(1*U,1*U)>] :: (s_X1xSV, b_a1xSy)
        [LclId]
        ds_s1y74
          = (a2_X1xZP
             `cast` (Data.Functor.Utils.N:StateL[0] <s_X1xSV>_R <b_a1xSy>_R
                     :: (StateL s_X1xSV b_a1xSy :: *)
                        ~R# (s_X1xSV -> (s_X1xSV, b_a1xSy) :: *)))
              (case (a1_X1xZN
                     `cast` (Data.Functor.Utils.N:StateL[0] <s_X1xSV>_R <a_a1xSx>_R
                             :: (StateL s_X1xSV a_a1xSx :: *)
                                ~R# (s_X1xSV -> (s_X1xSV, a_a1xSx) :: *)))
                      eta_B1
               of
               { (s'_a1xT7, v_a1xT9) ->
               s'_a1xT7
               }) } in
      (case ds_s1y74 of { (s''_a1xRI, v_a1xRK) -> s''_a1xRI },
       case ds_s1y74 of { (s''_a1xRI, v_a1xRK) -> v_a1xRK })

-- RHS size: {terms: 22, types: 33, coercions: 6, joins: 0/1}
Data.Functor.Utils.$fApplicativeStateL1
  :: forall a s b. StateL s a -> StateL s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,A))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1xSH)
                 (@ s_X1xST)
                 (@ b_a1xSI)
                 (ds_X1y2I :: StateL s_X1xST a_a1xSH)
                 (ds1_X1y2L [Occ=Once] :: StateL s_X1xST b_a1xSI)
                 (s1_X1xM6 [Occ=Once] :: s_X1xST) ->
                 let {
                   ds2_s1y72 :: (s_X1xST, a_a1xSH)
                   [LclId]
                   ds2_s1y72
                     = (ds_X1y2I
                        `cast` (Data.Functor.Utils.N:StateL[0] <s_X1xST>_R <a_a1xSH>_R
                                :: (StateL s_X1xST a_a1xSH :: *)
                                   ~R# (s_X1xST -> (s_X1xST, a_a1xSH) :: *)))
                         s1_X1xM6 } in
                 (case (ds1_X1y2L
                        `cast` (Data.Functor.Utils.N:StateL[0] <s_X1xST>_R <b_a1xSI>_R
                                :: (StateL s_X1xST b_a1xSI :: *)
                                   ~R# (s_X1xST -> (s_X1xST, b_a1xSI) :: *)))
                         (case ds2_s1y72 of { (s'_a1xS7 [Occ=Once], _ [Occ=Dead]) ->
                          s'_a1xS7
                          })
                  of
                  { (s''_a1xSm [Occ=Once], _ [Occ=Dead]) ->
                  s''_a1xSm
                  },
                  case ds2_s1y72 of { (_ [Occ=Dead], x_a1xS9 [Occ=Once]) ->
                  x_a1xS9
                  })}]
Data.Functor.Utils.$fApplicativeStateL1
  = \ (@ a_a1xSH)
      (@ s_X1xST)
      (@ b_a1xSI)
      (ds_X1y2I :: StateL s_X1xST a_a1xSH)
      (ds1_X1y2L :: StateL s_X1xST b_a1xSI)
      (s1_X1xM6 :: s_X1xST) ->
      let {
        ds2_s1y72 [Dmd=<L,U(1*U,1*U)>] :: (s_X1xST, a_a1xSH)
        [LclId]
        ds2_s1y72
          = (ds_X1y2I
             `cast` (Data.Functor.Utils.N:StateL[0] <s_X1xST>_R <a_a1xSH>_R
                     :: (StateL s_X1xST a_a1xSH :: *)
                        ~R# (s_X1xST -> (s_X1xST, a_a1xSH) :: *)))
              s1_X1xM6 } in
      (case (ds1_X1y2L
             `cast` (Data.Functor.Utils.N:StateL[0] <s_X1xST>_R <b_a1xSI>_R
                     :: (StateL s_X1xST b_a1xSI :: *)
                        ~R# (s_X1xST -> (s_X1xST, b_a1xSI) :: *)))
              (case ds2_s1y72 of { (s'_a1xS7, x_a1xS9) -> s'_a1xS7 })
       of
       { (s''_a1xSm, y_a1xSo) ->
       s''_a1xSm
       },
       case ds2_s1y72 of { (s'_a1xS7, x_a1xS9) -> x_a1xS9 })

-- RHS size: {terms: 12, types: 22, coercions: 89, joins: 0/0}
Data.Functor.Utils.$fApplicativeStateL [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. Applicative (StateL s)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ s_a1xJR) ->
       GHC.Base.C:Applicative TYPE: StateL s_a1xJR
                              Data.Functor.Utils.$fFunctorStateL @ s_a1xJR
                              (Data.Functor.Utils.$fApplicativeStateL5 @ s_a1xJR)
                              `cast` (forall (a :: <*>_N).
                                      <a>_R
                                      ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_a1xJR>_R <a>_R)
                                      :: (forall a. a -> s_a1xJR -> (s_a1xJR, a) :: *)
                                         ~R# (forall a. a -> StateL s_a1xJR a :: *))
                              (Data.Functor.Utils.$fApplicativeStateL4 @ s_a1xJR)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <StateL s_a1xJR (a -> b)>_R
                                      ->_R <StateL s_a1xJR a>_R
                                      ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_a1xJR>_R <b>_R)
                                      :: (forall a b.
                                          StateL s_a1xJR (a -> b)
                                          -> StateL s_a1xJR a -> s_a1xJR -> (s_a1xJR, b) :: *)
                                         ~R# (forall a b.
                                              StateL s_a1xJR (a -> b)
                                              -> StateL s_a1xJR a -> StateL s_a1xJR b :: *))
                              (Data.Functor.Utils.$fApplicativeStateL3 @ s_a1xJR)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R <StateL s_a1xJR a>_R
                                      ->_R <StateL s_a1xJR b>_R
                                      ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_a1xJR>_R <c>_R)
                                      :: (forall a b c.
                                          (a -> b -> c)
                                          -> StateL s_a1xJR a
                                          -> StateL s_a1xJR b
                                          -> s_a1xJR
                                          -> (s_a1xJR, c) :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c)
                                              -> StateL s_a1xJR a
                                              -> StateL s_a1xJR b
                                              -> StateL s_a1xJR c :: *))
                              (\ (@ a_a1xSx) (@ b_a1xSy) ->
                                 Data.Functor.Utils.$fApplicativeStateL2
                                   @ b_a1xSy @ a_a1xSx @ s_a1xJR)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <StateL s_a1xJR a>_R
                                      ->_R <StateL s_a1xJR b>_R
                                      ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_a1xJR>_R <b>_R)
                                      :: (forall a b.
                                          StateL s_a1xJR a
                                          -> StateL s_a1xJR b -> s_a1xJR -> (s_a1xJR, b) :: *)
                                         ~R# (forall a b.
                                              StateL s_a1xJR a
                                              -> StateL s_a1xJR b -> StateL s_a1xJR b :: *))
                              (\ (@ a_a1xSH) (@ b_a1xSI) ->
                                 Data.Functor.Utils.$fApplicativeStateL1
                                   @ a_a1xSH @ s_a1xJR @ b_a1xSI)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <StateL s_a1xJR a>_R
                                      ->_R <StateL s_a1xJR b>_R
                                      ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_a1xJR>_R <a>_R)
                                      :: (forall a b.
                                          StateL s_a1xJR a
                                          -> StateL s_a1xJR b -> s_a1xJR -> (s_a1xJR, a) :: *)
                                         ~R# (forall a b.
                                              StateL s_a1xJR a
                                              -> StateL s_a1xJR b -> StateL s_a1xJR a :: *))]
Data.Functor.Utils.$fApplicativeStateL
  = \ (@ s_X1xSS) ->
      GHC.Base.C:Applicative
        @ (StateL s_X1xSS)
        (Data.Functor.Utils.$fFunctorStateL @ s_X1xSS)
        ((Data.Functor.Utils.$fApplicativeStateL5 @ s_X1xSS)
         `cast` (forall (a :: <*>_N).
                 <a>_R ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_X1xSS>_R <a>_R)
                 :: (forall a. a -> s_X1xSS -> (s_X1xSS, a) :: *)
                    ~R# (forall a. a -> StateL s_X1xSS a :: *)))
        ((Data.Functor.Utils.$fApplicativeStateL4 @ s_X1xSS)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <StateL s_X1xSS (a -> b)>_R
                 ->_R <StateL s_X1xSS a>_R
                 ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_X1xSS>_R <b>_R)
                 :: (forall a b.
                     StateL s_X1xSS (a -> b)
                     -> StateL s_X1xSS a -> s_X1xSS -> (s_X1xSS, b) :: *)
                    ~R# (forall a b.
                         StateL s_X1xSS (a -> b)
                         -> StateL s_X1xSS a -> StateL s_X1xSS b :: *)))
        ((Data.Functor.Utils.$fApplicativeStateL3 @ s_X1xSS)
         `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                 <a -> b -> c>_R
                 ->_R <StateL s_X1xSS a>_R
                 ->_R <StateL s_X1xSS b>_R
                 ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_X1xSS>_R <c>_R)
                 :: (forall a b c.
                     (a -> b -> c)
                     -> StateL s_X1xSS a
                     -> StateL s_X1xSS b
                     -> s_X1xSS
                     -> (s_X1xSS, c) :: *)
                    ~R# (forall a b c.
                         (a -> b -> c)
                         -> StateL s_X1xSS a -> StateL s_X1xSS b -> StateL s_X1xSS c :: *)))
        ((\ (@ a_a1xSx) (@ b_a1xSy) ->
            Data.Functor.Utils.$fApplicativeStateL2
              @ b_a1xSy @ a_a1xSx @ s_X1xSS)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <StateL s_X1xSS a>_R
                 ->_R <StateL s_X1xSS b>_R
                 ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_X1xSS>_R <b>_R)
                 :: (forall a b.
                     StateL s_X1xSS a
                     -> StateL s_X1xSS b -> s_X1xSS -> (s_X1xSS, b) :: *)
                    ~R# (forall a b.
                         StateL s_X1xSS a -> StateL s_X1xSS b -> StateL s_X1xSS b :: *)))
        ((\ (@ a_a1xSH) (@ b_a1xSI) ->
            Data.Functor.Utils.$fApplicativeStateL1
              @ a_a1xSH @ s_X1xSS @ b_a1xSI)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <StateL s_X1xSS a>_R
                 ->_R <StateL s_X1xSS b>_R
                 ->_R Sym (Data.Functor.Utils.N:StateL[0] <s_X1xSS>_R <a>_R)
                 :: (forall a b.
                     StateL s_X1xSS a
                     -> StateL s_X1xSS b -> s_X1xSS -> (s_X1xSS, a) :: *)
                    ~R# (forall a b.
                         StateL s_X1xSS a -> StateL s_X1xSS b -> StateL s_X1xSS a :: *)))

-- RHS size: {terms: 19, types: 27, coercions: 3, joins: 0/1}
Data.Functor.Utils.$fFunctorStateR2
  :: forall s a b. (a -> b) -> StateR s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ s_a1xQk)
                 (@ a_a1xQo)
                 (@ b_a1xQp)
                 (f_a1xJM [Occ=Once!] :: a_a1xQo -> b_a1xQp)
                 (ds_d1xXW :: StateR s_a1xQk a_a1xQo)
                 (s1_a1xJO [Occ=Once] :: s_a1xQk) ->
                 let {
                   ds1_s1y70 :: (s_a1xQk, a_a1xQo)
                   [LclId]
                   ds1_s1y70
                     = (ds_d1xXW
                        `cast` (Data.Functor.Utils.N:StateR[0] <s_a1xQk>_R <a_a1xQo>_R
                                :: (StateR s_a1xQk a_a1xQo :: *)
                                   ~R# (s_a1xQk -> (s_a1xQk, a_a1xQo) :: *)))
                         s1_a1xJO } in
                 (case ds1_s1y70 of { (s'_a1xQB [Occ=Once], _ [Occ=Dead]) ->
                  s'_a1xQB
                  },
                  f_a1xJM
                    (case ds1_s1y70 of { (_ [Occ=Dead], v_a1xQD [Occ=Once]) ->
                     v_a1xQD
                     }))}]
Data.Functor.Utils.$fFunctorStateR2
  = \ (@ s_a1xQk)
      (@ a_a1xQo)
      (@ b_a1xQp)
      (f_a1xJM :: a_a1xQo -> b_a1xQp)
      (ds_d1xXW :: StateR s_a1xQk a_a1xQo)
      (s1_a1xJO :: s_a1xQk) ->
      let {
        ds1_s1y70 [Dmd=<L,U(1*U,1*U)>] :: (s_a1xQk, a_a1xQo)
        [LclId]
        ds1_s1y70
          = (ds_d1xXW
             `cast` (Data.Functor.Utils.N:StateR[0] <s_a1xQk>_R <a_a1xQo>_R
                     :: (StateR s_a1xQk a_a1xQo :: *)
                        ~R# (s_a1xQk -> (s_a1xQk, a_a1xQo) :: *)))
              s1_a1xJO } in
      (case ds1_s1y70 of { (s'_a1xQB, v_a1xQD) -> s'_a1xQB },
       f_a1xJM (case ds1_s1y70 of { (s'_a1xQB, v_a1xQD) -> v_a1xQD }))

-- RHS size: {terms: 13, types: 18, coercions: 3, joins: 0/0}
Data.Functor.Utils.$fFunctorStateR1
  :: forall b s a. a -> StateR s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(U(1*U,A))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a1xQT)
                 (@ s_X1xSo)
                 (@ a_a1xQS)
                 (x_X1y0r [Occ=Once] :: a_a1xQS)
                 (ds_X1y06 [Occ=Once] :: StateR s_X1xSo b_a1xQT)
                 (s1_a1xJO [Occ=Once] :: s_X1xSo) ->
                 (case (ds_X1y06
                        `cast` (Data.Functor.Utils.N:StateR[0] <s_X1xSo>_R <b_a1xQT>_R
                                :: (StateR s_X1xSo b_a1xQT :: *)
                                   ~R# (s_X1xSo -> (s_X1xSo, b_a1xQT) :: *)))
                         s1_a1xJO
                  of
                  { (s'_a1xQB [Occ=Once], _ [Occ=Dead]) ->
                  s'_a1xQB
                  },
                  x_X1y0r)}]
Data.Functor.Utils.$fFunctorStateR1
  = \ (@ b_a1xQT)
      (@ s_X1xSo)
      (@ a_a1xQS)
      (x_X1y0r :: a_a1xQS)
      (ds_X1y06 :: StateR s_X1xSo b_a1xQT)
      (s1_a1xJO :: s_X1xSo) ->
      (case (ds_X1y06
             `cast` (Data.Functor.Utils.N:StateR[0] <s_X1xSo>_R <b_a1xQT>_R
                     :: (StateR s_X1xSo b_a1xQT :: *)
                        ~R# (s_X1xSo -> (s_X1xSo, b_a1xQT) :: *)))
              s1_a1xJO
       of
       { (s'_a1xQB, v_a1xQD) ->
       s'_a1xQB
       },
       x_X1y0r)

-- RHS size: {terms: 6, types: 12, coercions: 33, joins: 0/0}
Data.Functor.Utils.$fFunctorStateR [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. Functor (StateR s)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ s_a1xJL) ->
       GHC.Base.C:Functor TYPE: StateR s_a1xJL
                          (Data.Functor.Utils.$fFunctorStateR2 @ s_a1xJL)
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R
                                  ->_R <StateR s_a1xJL a>_R
                                  ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_a1xJL>_R <b>_R)
                                  :: (forall a b.
                                      (a -> b) -> StateR s_a1xJL a -> s_a1xJL -> (s_a1xJL, b) :: *)
                                     ~R# (forall a b.
                                          (a -> b) -> StateR s_a1xJL a -> StateR s_a1xJL b :: *))
                          (\ (@ a_a1xQS) (@ b_a1xQT) ->
                             Data.Functor.Utils.$fFunctorStateR1 @ b_a1xQT @ s_a1xJL @ a_a1xQS)
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R
                                  ->_R <StateR s_a1xJL b>_R
                                  ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_a1xJL>_R <a>_R)
                                  :: (forall a b.
                                      a -> StateR s_a1xJL b -> s_a1xJL -> (s_a1xJL, a) :: *)
                                     ~R# (forall a b.
                                          a -> StateR s_a1xJL b -> StateR s_a1xJL a :: *))]
Data.Functor.Utils.$fFunctorStateR
  = \ (@ s_X1xSn) ->
      GHC.Base.C:Functor
        @ (StateR s_X1xSn)
        ((Data.Functor.Utils.$fFunctorStateR2 @ s_X1xSn)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <StateR s_X1xSn a>_R
                 ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_X1xSn>_R <b>_R)
                 :: (forall a b.
                     (a -> b) -> StateR s_X1xSn a -> s_X1xSn -> (s_X1xSn, b) :: *)
                    ~R# (forall a b.
                         (a -> b) -> StateR s_X1xSn a -> StateR s_X1xSn b :: *)))
        ((\ (@ a_a1xQS) (@ b_a1xQT) ->
            Data.Functor.Utils.$fFunctorStateR1 @ b_a1xQT @ s_X1xSn @ a_a1xQS)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R
                 ->_R <StateR s_X1xSn b>_R
                 ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_X1xSn>_R <a>_R)
                 :: (forall a b.
                     a -> StateR s_X1xSn b -> s_X1xSn -> (s_X1xSn, a) :: *)
                    ~R# (forall a b. a -> StateR s_X1xSn b -> StateR s_X1xSn a :: *)))

-- RHS size: {terms: 31, types: 46, coercions: 6, joins: 0/2}
Data.Functor.Utils.$fApplicativeStateR3 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b c.
     (a -> b -> c) -> StateR s a -> StateR s b -> s -> (s, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ s_s1yeC)
                 (@ a_s1yeD)
                 (@ b_s1yeE)
                 (@ c_s1yeF)
                 (w_s1yeG [Occ=Once!] :: a_s1yeD -> b_s1yeE -> c_s1yeF)
                 (w1_s1yeH :: StateR s_s1yeC a_s1yeD)
                 (w2_s1yeI :: StateR s_s1yeC b_s1yeE)
                 (w3_s1yeJ [Occ=Once] :: s_s1yeC) ->
                 let {
                   ds_s1y6Y [Dmd=<L,U(U,U)>] :: (s_s1yeC, b_s1yeE)
                   [LclId]
                   ds_s1y6Y
                     = (w2_s1yeI
                        `cast` (Data.Functor.Utils.N:StateR[0] <s_s1yeC>_R <b_s1yeE>_R
                                :: (StateR s_s1yeC b_s1yeE :: *)
                                   ~R# (s_s1yeC -> (s_s1yeC, b_s1yeE) :: *)))
                         w3_s1yeJ } in
                 let {
                   ds1_s1y6X [Dmd=<L,U(U,U)>] :: (s_s1yeC, a_s1yeD)
                   [LclId]
                   ds1_s1y6X
                     = (w1_s1yeH
                        `cast` (Data.Functor.Utils.N:StateR[0] <s_s1yeC>_R <a_s1yeD>_R
                                :: (StateR s_s1yeC a_s1yeD :: *)
                                   ~R# (s_s1yeC -> (s_s1yeC, a_s1yeD) :: *)))
                         (case ds_s1y6Y of { (s'_a1xPp [Occ=Once], _ [Occ=Dead]) ->
                          s'_a1xPp
                          }) } in
                 (case ds1_s1y6X of { (s''_a1xPE [Occ=Once], _ [Occ=Dead]) ->
                  s''_a1xPE
                  },
                  w_s1yeG
                    (case ds1_s1y6X of { (_ [Occ=Dead], x_a1xPG [Occ=Once]) ->
                     x_a1xPG
                     })
                    (case ds_s1y6Y of { (_ [Occ=Dead], y_a1xPr [Occ=Once]) ->
                     y_a1xPr
                     }))}]
Data.Functor.Utils.$fApplicativeStateR3
  = \ (@ s_s1yeC)
      (@ a_s1yeD)
      (@ b_s1yeE)
      (@ c_s1yeF)
      (w_s1yeG :: a_s1yeD -> b_s1yeE -> c_s1yeF)
      (w1_s1yeH :: StateR s_s1yeC a_s1yeD)
      (w2_s1yeI :: StateR s_s1yeC b_s1yeE)
      (w3_s1yeJ :: s_s1yeC) ->
      let {
        ds_s1y6Y [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeC, b_s1yeE)
        [LclId]
        ds_s1y6Y
          = (w2_s1yeI
             `cast` (Data.Functor.Utils.N:StateR[0] <s_s1yeC>_R <b_s1yeE>_R
                     :: (StateR s_s1yeC b_s1yeE :: *)
                        ~R# (s_s1yeC -> (s_s1yeC, b_s1yeE) :: *)))
              w3_s1yeJ } in
      let {
        ds1_s1y6X [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeC, a_s1yeD)
        [LclId]
        ds1_s1y6X
          = (w1_s1yeH
             `cast` (Data.Functor.Utils.N:StateR[0] <s_s1yeC>_R <a_s1yeD>_R
                     :: (StateR s_s1yeC a_s1yeD :: *)
                        ~R# (s_s1yeC -> (s_s1yeC, a_s1yeD) :: *)))
              (case ds_s1y6Y of { (s'_a1xPp, y_a1xPr) -> s'_a1xPp }) } in
      (case ds1_s1y6X of { (s''_a1xPE, x_a1xPG) -> s''_a1xPE },
       w_s1yeG
         (case ds1_s1y6X of { (s''_a1xPE, x_a1xPG) -> x_a1xPG })
         (case ds_s1y6Y of { (s'_a1xPp, y_a1xPr) -> y_a1xPr }))

-- RHS size: {terms: 28, types: 47, coercions: 7, joins: 0/2}
Data.Functor.Utils.$fApplicativeStateR4 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b. StateR s (a -> b) -> StateR s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*C1(U)))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ s_s1yeO)
                 (@ a_s1yeP)
                 (@ b_s1yeQ)
                 (w_s1yeR :: StateR s_s1yeO (a_s1yeP -> b_s1yeQ))
                 (w1_s1yeS :: StateR s_s1yeO a_s1yeP)
                 (w2_s1yeT [Occ=Once] :: s_s1yeO) ->
                 let {
                   ds_s1y6U [Dmd=<L,U(U,U)>] :: (s_s1yeO, a_s1yeP)
                   [LclId]
                   ds_s1y6U
                     = (w1_s1yeS
                        `cast` (Data.Functor.Utils.N:StateR[0] <s_s1yeO>_R <a_s1yeP>_R
                                :: (StateR s_s1yeO a_s1yeP :: *)
                                   ~R# (s_s1yeO -> (s_s1yeO, a_s1yeP) :: *)))
                         w2_s1yeT } in
                 let {
                   ds1_s1y6T [Dmd=<L,U(U,C1(U))>] :: (s_s1yeO, a_s1yeP -> b_s1yeQ)
                   [LclId]
                   ds1_s1y6T
                     = (w_s1yeR
                        `cast` (Data.Functor.Utils.N:StateR[0]
                                    <s_s1yeO>_R <a_s1yeP -> b_s1yeQ>_R
                                :: (StateR s_s1yeO (a_s1yeP -> b_s1yeQ) :: *)
                                   ~R# (s_s1yeO -> (s_s1yeO, a_s1yeP -> b_s1yeQ) :: *)))
                         (case ds_s1y6U of { (s'_a1xOE [Occ=Once], _ [Occ=Dead]) ->
                          s'_a1xOE
                          }) } in
                 (case ds1_s1y6T of { (s''_a1xOT [Occ=Once], _ [Occ=Dead]) ->
                  s''_a1xOT
                  },
                  case ds1_s1y6T of { (_ [Occ=Dead], f_a1xOV [Occ=Once!]) ->
                  f_a1xOV
                    (case ds_s1y6U of { (_ [Occ=Dead], v_a1xOG [Occ=Once]) ->
                     v_a1xOG
                     })
                  })}]
Data.Functor.Utils.$fApplicativeStateR4
  = \ (@ s_s1yeO)
      (@ a_s1yeP)
      (@ b_s1yeQ)
      (w_s1yeR :: StateR s_s1yeO (a_s1yeP -> b_s1yeQ))
      (w1_s1yeS :: StateR s_s1yeO a_s1yeP)
      (w2_s1yeT :: s_s1yeO) ->
      let {
        ds_s1y6U [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeO, a_s1yeP)
        [LclId]
        ds_s1y6U
          = (w1_s1yeS
             `cast` (Data.Functor.Utils.N:StateR[0] <s_s1yeO>_R <a_s1yeP>_R
                     :: (StateR s_s1yeO a_s1yeP :: *)
                        ~R# (s_s1yeO -> (s_s1yeO, a_s1yeP) :: *)))
              w2_s1yeT } in
      let {
        ds1_s1y6T [Dmd=<L,U(1*U,1*C1(U))>] :: (s_s1yeO, a_s1yeP -> b_s1yeQ)
        [LclId]
        ds1_s1y6T
          = (w_s1yeR
             `cast` (Data.Functor.Utils.N:StateR[0]
                         <s_s1yeO>_R <a_s1yeP -> b_s1yeQ>_R
                     :: (StateR s_s1yeO (a_s1yeP -> b_s1yeQ) :: *)
                        ~R# (s_s1yeO -> (s_s1yeO, a_s1yeP -> b_s1yeQ) :: *)))
              (case ds_s1y6U of { (s'_a1xOE, v_a1xOG) -> s'_a1xOE }) } in
      (case ds1_s1y6T of { (s''_a1xOT, f_a1xOV) -> s''_a1xOT },
       case ds1_s1y6T of { (s''_a1xOT, f_a1xOV) ->
       f_a1xOV (case ds_s1y6U of { (s'_a1xOE, v_a1xOG) -> v_a1xOG })
       })

-- RHS size: {terms: 22, types: 33, coercions: 6, joins: 0/1}
Data.Functor.Utils.$fApplicativeStateR2
  :: forall b a s. StateR s a -> StateR s b -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,A))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a1xPW)
                 (@ a_a1xPV)
                 (@ s_X1xQD)
                 (a1_X1y0n [Occ=Once] :: StateR s_X1xQD a_a1xPV)
                 (a2_X1y0p :: StateR s_X1xQD b_a1xPW)
                 (eta_B1 [Occ=Once] :: s_X1xQD) ->
                 let {
                   ds_s1y6Q :: (s_X1xQD, b_a1xPW)
                   [LclId]
                   ds_s1y6Q
                     = (a2_X1y0p
                        `cast` (Data.Functor.Utils.N:StateR[0] <s_X1xQD>_R <b_a1xPW>_R
                                :: (StateR s_X1xQD b_a1xPW :: *)
                                   ~R# (s_X1xQD -> (s_X1xQD, b_a1xPW) :: *)))
                         eta_B1 } in
                 (case (a1_X1y0n
                        `cast` (Data.Functor.Utils.N:StateR[0] <s_X1xQD>_R <a_a1xPV>_R
                                :: (StateR s_X1xQD a_a1xPV :: *)
                                   ~R# (s_X1xQD -> (s_X1xQD, a_a1xPV) :: *)))
                         (case ds_s1y6Q of { (s'_a1xOE [Occ=Once], _ [Occ=Dead]) ->
                          s'_a1xOE
                          })
                  of
                  { (s'_a1xQB [Occ=Once], _ [Occ=Dead]) ->
                  s'_a1xQB
                  },
                  case ds_s1y6Q of { (_ [Occ=Dead], v_a1xOG [Occ=Once]) ->
                  v_a1xOG
                  })}]
Data.Functor.Utils.$fApplicativeStateR2
  = \ (@ b_a1xPW)
      (@ a_a1xPV)
      (@ s_X1xQD)
      (a1_X1y0n :: StateR s_X1xQD a_a1xPV)
      (a2_X1y0p :: StateR s_X1xQD b_a1xPW)
      (eta_B1 :: s_X1xQD) ->
      let {
        ds_s1y6Q [Dmd=<L,U(1*U,1*U)>] :: (s_X1xQD, b_a1xPW)
        [LclId]
        ds_s1y6Q
          = (a2_X1y0p
             `cast` (Data.Functor.Utils.N:StateR[0] <s_X1xQD>_R <b_a1xPW>_R
                     :: (StateR s_X1xQD b_a1xPW :: *)
                        ~R# (s_X1xQD -> (s_X1xQD, b_a1xPW) :: *)))
              eta_B1 } in
      (case (a1_X1y0n
             `cast` (Data.Functor.Utils.N:StateR[0] <s_X1xQD>_R <a_a1xPV>_R
                     :: (StateR s_X1xQD a_a1xPV :: *)
                        ~R# (s_X1xQD -> (s_X1xQD, a_a1xPV) :: *)))
              (case ds_s1y6Q of { (s'_a1xOE, v_a1xOG) -> s'_a1xOE })
       of
       { (s'_a1xQB, v_a1xQD) ->
       s'_a1xQB
       },
       case ds_s1y6Q of { (s'_a1xOE, v_a1xOG) -> v_a1xOG })

-- RHS size: {terms: 22, types: 33, coercions: 6, joins: 0/1}
Data.Functor.Utils.$fApplicativeStateR1
  :: forall a s b. StateR s a -> StateR s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,A))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1xQb)
                 (@ s_X1xQB)
                 (@ b_a1xQc)
                 (ds_X1y2k :: StateR s_X1xQB a_a1xQb)
                 (ds1_X1y2n [Occ=Once] :: StateR s_X1xQB b_a1xQc)
                 (s1_X1xMi [Occ=Once] :: s_X1xQB) ->
                 let {
                   ds2_s1y6O :: (s_X1xQB, a_a1xQb)
                   [LclId]
                   ds2_s1y6O
                     = (ds_X1y2k
                        `cast` (Data.Functor.Utils.N:StateR[0] <s_X1xQB>_R <a_a1xQb>_R
                                :: (StateR s_X1xQB a_a1xQb :: *)
                                   ~R# (s_X1xQB -> (s_X1xQB, a_a1xQb) :: *)))
                         (case (ds1_X1y2n
                                `cast` (Data.Functor.Utils.N:StateR[0] <s_X1xQB>_R <b_a1xQc>_R
                                        :: (StateR s_X1xQB b_a1xQc :: *)
                                           ~R# (s_X1xQB -> (s_X1xQB, b_a1xQc) :: *)))
                                 s1_X1xMi
                          of
                          { (s'_a1xPp [Occ=Once], _ [Occ=Dead]) ->
                          s'_a1xPp
                          }) } in
                 (case ds2_s1y6O of { (s''_a1xPE [Occ=Once], _ [Occ=Dead]) ->
                  s''_a1xPE
                  },
                  case ds2_s1y6O of { (_ [Occ=Dead], x_a1xPG [Occ=Once]) ->
                  x_a1xPG
                  })}]
Data.Functor.Utils.$fApplicativeStateR1
  = \ (@ a_a1xQb)
      (@ s_X1xQB)
      (@ b_a1xQc)
      (ds_X1y2k :: StateR s_X1xQB a_a1xQb)
      (ds1_X1y2n :: StateR s_X1xQB b_a1xQc)
      (s1_X1xMi :: s_X1xQB) ->
      let {
        ds2_s1y6O [Dmd=<L,U(1*U,1*U)>] :: (s_X1xQB, a_a1xQb)
        [LclId]
        ds2_s1y6O
          = (ds_X1y2k
             `cast` (Data.Functor.Utils.N:StateR[0] <s_X1xQB>_R <a_a1xQb>_R
                     :: (StateR s_X1xQB a_a1xQb :: *)
                        ~R# (s_X1xQB -> (s_X1xQB, a_a1xQb) :: *)))
              (case (ds1_X1y2n
                     `cast` (Data.Functor.Utils.N:StateR[0] <s_X1xQB>_R <b_a1xQc>_R
                             :: (StateR s_X1xQB b_a1xQc :: *)
                                ~R# (s_X1xQB -> (s_X1xQB, b_a1xQc) :: *)))
                      s1_X1xMi
               of
               { (s'_a1xPp, y_a1xPr) ->
               s'_a1xPp
               }) } in
      (case ds2_s1y6O of { (s''_a1xPE, x_a1xPG) -> s''_a1xPE },
       case ds2_s1y6O of { (s''_a1xPE, x_a1xPG) -> x_a1xPG })

-- RHS size: {terms: 12, types: 22, coercions: 89, joins: 0/0}
Data.Functor.Utils.$fApplicativeStateR [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. Applicative (StateR s)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ s_a1xJt) ->
       GHC.Base.C:Applicative TYPE: StateR s_a1xJt
                              Data.Functor.Utils.$fFunctorStateR @ s_a1xJt
                              (Data.Functor.Utils.$fApplicativeStateL5 @ s_a1xJt)
                              `cast` (forall (a :: <*>_N).
                                      <a>_R
                                      ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_a1xJt>_R <a>_R)
                                      :: (forall a. a -> s_a1xJt -> (s_a1xJt, a) :: *)
                                         ~R# (forall a. a -> StateR s_a1xJt a :: *))
                              (Data.Functor.Utils.$fApplicativeStateR4 @ s_a1xJt)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <StateR s_a1xJt (a -> b)>_R
                                      ->_R <StateR s_a1xJt a>_R
                                      ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_a1xJt>_R <b>_R)
                                      :: (forall a b.
                                          StateR s_a1xJt (a -> b)
                                          -> StateR s_a1xJt a -> s_a1xJt -> (s_a1xJt, b) :: *)
                                         ~R# (forall a b.
                                              StateR s_a1xJt (a -> b)
                                              -> StateR s_a1xJt a -> StateR s_a1xJt b :: *))
                              (Data.Functor.Utils.$fApplicativeStateR3 @ s_a1xJt)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R <StateR s_a1xJt a>_R
                                      ->_R <StateR s_a1xJt b>_R
                                      ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_a1xJt>_R <c>_R)
                                      :: (forall a b c.
                                          (a -> b -> c)
                                          -> StateR s_a1xJt a
                                          -> StateR s_a1xJt b
                                          -> s_a1xJt
                                          -> (s_a1xJt, c) :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c)
                                              -> StateR s_a1xJt a
                                              -> StateR s_a1xJt b
                                              -> StateR s_a1xJt c :: *))
                              (\ (@ a_a1xPV) (@ b_a1xPW) ->
                                 Data.Functor.Utils.$fApplicativeStateR2
                                   @ b_a1xPW @ a_a1xPV @ s_a1xJt)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <StateR s_a1xJt a>_R
                                      ->_R <StateR s_a1xJt b>_R
                                      ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_a1xJt>_R <b>_R)
                                      :: (forall a b.
                                          StateR s_a1xJt a
                                          -> StateR s_a1xJt b -> s_a1xJt -> (s_a1xJt, b) :: *)
                                         ~R# (forall a b.
                                              StateR s_a1xJt a
                                              -> StateR s_a1xJt b -> StateR s_a1xJt b :: *))
                              (\ (@ a_a1xQb) (@ b_a1xQc) ->
                                 Data.Functor.Utils.$fApplicativeStateR1
                                   @ a_a1xQb @ s_a1xJt @ b_a1xQc)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <StateR s_a1xJt a>_R
                                      ->_R <StateR s_a1xJt b>_R
                                      ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_a1xJt>_R <a>_R)
                                      :: (forall a b.
                                          StateR s_a1xJt a
                                          -> StateR s_a1xJt b -> s_a1xJt -> (s_a1xJt, a) :: *)
                                         ~R# (forall a b.
                                              StateR s_a1xJt a
                                              -> StateR s_a1xJt b -> StateR s_a1xJt a :: *))]
Data.Functor.Utils.$fApplicativeStateR
  = \ (@ s_X1xQA) ->
      GHC.Base.C:Applicative
        @ (StateR s_X1xQA)
        (Data.Functor.Utils.$fFunctorStateR @ s_X1xQA)
        ((Data.Functor.Utils.$fApplicativeStateL5 @ s_X1xQA)
         `cast` (forall (a :: <*>_N).
                 <a>_R ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_X1xQA>_R <a>_R)
                 :: (forall a. a -> s_X1xQA -> (s_X1xQA, a) :: *)
                    ~R# (forall a. a -> StateR s_X1xQA a :: *)))
        ((Data.Functor.Utils.$fApplicativeStateR4 @ s_X1xQA)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <StateR s_X1xQA (a -> b)>_R
                 ->_R <StateR s_X1xQA a>_R
                 ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_X1xQA>_R <b>_R)
                 :: (forall a b.
                     StateR s_X1xQA (a -> b)
                     -> StateR s_X1xQA a -> s_X1xQA -> (s_X1xQA, b) :: *)
                    ~R# (forall a b.
                         StateR s_X1xQA (a -> b)
                         -> StateR s_X1xQA a -> StateR s_X1xQA b :: *)))
        ((Data.Functor.Utils.$fApplicativeStateR3 @ s_X1xQA)
         `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                 <a -> b -> c>_R
                 ->_R <StateR s_X1xQA a>_R
                 ->_R <StateR s_X1xQA b>_R
                 ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_X1xQA>_R <c>_R)
                 :: (forall a b c.
                     (a -> b -> c)
                     -> StateR s_X1xQA a
                     -> StateR s_X1xQA b
                     -> s_X1xQA
                     -> (s_X1xQA, c) :: *)
                    ~R# (forall a b c.
                         (a -> b -> c)
                         -> StateR s_X1xQA a -> StateR s_X1xQA b -> StateR s_X1xQA c :: *)))
        ((\ (@ a_a1xPV) (@ b_a1xPW) ->
            Data.Functor.Utils.$fApplicativeStateR2
              @ b_a1xPW @ a_a1xPV @ s_X1xQA)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <StateR s_X1xQA a>_R
                 ->_R <StateR s_X1xQA b>_R
                 ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_X1xQA>_R <b>_R)
                 :: (forall a b.
                     StateR s_X1xQA a
                     -> StateR s_X1xQA b -> s_X1xQA -> (s_X1xQA, b) :: *)
                    ~R# (forall a b.
                         StateR s_X1xQA a -> StateR s_X1xQA b -> StateR s_X1xQA b :: *)))
        ((\ (@ a_a1xQb) (@ b_a1xQc) ->
            Data.Functor.Utils.$fApplicativeStateR1
              @ a_a1xQb @ s_X1xQA @ b_a1xQc)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <StateR s_X1xQA a>_R
                 ->_R <StateR s_X1xQA b>_R
                 ->_R Sym (Data.Functor.Utils.N:StateR[0] <s_X1xQA>_R <a>_R)
                 :: (forall a b.
                     StateR s_X1xQA a
                     -> StateR s_X1xQA b -> s_X1xQA -> (s_X1xQA, a) :: *)
                    ~R# (forall a b.
                         StateR s_X1xQA a -> StateR s_X1xQA b -> StateR s_X1xQA a :: *)))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Utils.getMax1 :: forall a. Max a -> Max a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a1xKU) (ds_d1xWD [Occ=Once] :: Max a_a1xKU) ->
                 ds_d1xWD}]
Data.Functor.Utils.getMax1
  = \ (@ a_a1xKU) (ds_d1xWD :: Max a_a1xKU) -> ds_d1xWD

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getMax :: forall a. Max a -> Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Utils.getMax1
               `cast` (forall (a :: <*>_N).
                       <Max a>_R ->_R Data.Functor.Utils.N:Max[0] <a>_N
                       :: (forall a. Max a -> Max a :: *)
                          ~R# (forall a. Max a -> Maybe a :: *))}]
getMax
  = Data.Functor.Utils.getMax1
    `cast` (forall (a :: <*>_N).
            <Max a>_R ->_R Data.Functor.Utils.N:Max[0] <a>_N
            :: (forall a. Max a -> Max a :: *)
               ~R# (forall a. Max a -> Maybe a :: *))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Utils.getMin1 :: forall a. Min a -> Min a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a1xLR) (ds_d1xWB [Occ=Once] :: Min a_a1xLR) ->
                 ds_d1xWB}]
Data.Functor.Utils.getMin1
  = \ (@ a_a1xLR) (ds_d1xWB :: Min a_a1xLR) -> ds_d1xWB

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getMin :: forall a. Min a -> Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Utils.getMin1
               `cast` (forall (a :: <*>_N).
                       <Min a>_R ->_R Data.Functor.Utils.N:Min[0] <a>_N
                       :: (forall a. Min a -> Min a :: *)
                          ~R# (forall a. Min a -> Maybe a :: *))}]
getMin
  = Data.Functor.Utils.getMin1
    `cast` (forall (a :: <*>_N).
            <Min a>_R ->_R Data.Functor.Utils.N:Min[0] <a>_N
            :: (forall a. Min a -> Min a :: *)
               ~R# (forall a. Min a -> Maybe a :: *))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Functor.Utils.runStateL1
  :: forall s a. StateL s a -> StateL s a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ s_a1xMv)
                 (@ a_a1xMw)
                 (ds_d1xWz [Occ=Once] :: StateL s_a1xMv a_a1xMw) ->
                 ds_d1xWz}]
Data.Functor.Utils.runStateL1
  = \ (@ s_a1xMv) (@ a_a1xMw) (ds_d1xWz :: StateL s_a1xMv a_a1xMw) ->
      ds_d1xWz

-- RHS size: {terms: 1, types: 0, coercions: 13, joins: 0/0}
runStateL :: forall s a. StateL s a -> s -> (s, a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Utils.runStateL1
               `cast` (forall (s :: <*>_N) (a :: <*>_N).
                       <StateL s a>_R ->_R Data.Functor.Utils.N:StateL[0] <s>_R <a>_R
                       :: (forall s a. StateL s a -> StateL s a :: *)
                          ~R# (forall s a. StateL s a -> s -> (s, a) :: *))}]
runStateL
  = Data.Functor.Utils.runStateL1
    `cast` (forall (s :: <*>_N) (a :: <*>_N).
            <StateL s a>_R ->_R Data.Functor.Utils.N:StateL[0] <s>_R <a>_R
            :: (forall s a. StateL s a -> StateL s a :: *)
               ~R# (forall s a. StateL s a -> s -> (s, a) :: *))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Functor.Utils.runStateR1
  :: forall s a. StateR s a -> StateR s a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ s_a1xNi)
                 (@ a_a1xNj)
                 (ds_d1xWx [Occ=Once] :: StateR s_a1xNi a_a1xNj) ->
                 ds_d1xWx}]
Data.Functor.Utils.runStateR1
  = \ (@ s_a1xNi) (@ a_a1xNj) (ds_d1xWx :: StateR s_a1xNi a_a1xNj) ->
      ds_d1xWx

-- RHS size: {terms: 1, types: 0, coercions: 13, joins: 0/0}
runStateR :: forall s a. StateR s a -> s -> (s, a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Utils.runStateR1
               `cast` (forall (s :: <*>_N) (a :: <*>_N).
                       <StateR s a>_R ->_R Data.Functor.Utils.N:StateR[0] <s>_R <a>_R
                       :: (forall s a. StateR s a -> StateR s a :: *)
                          ~R# (forall s a. StateR s a -> s -> (s, a) :: *))}]
runStateR
  = Data.Functor.Utils.runStateR1
    `cast` (forall (s :: <*>_N) (a :: <*>_N).
            <StateR s a>_R ->_R Data.Functor.Utils.N:StateR[0] <s>_R <a>_R
            :: (forall s a. StateR s a -> StateR s a :: *)
               ~R# (forall s a. StateR s a -> s -> (s, a) :: *))

-- RHS size: {terms: 11, types: 26, coercions: 3, joins: 0/0}
#. [InlPrag=INLINE (sat-args=1)]
  :: forall b c a. Coercible b c => (b -> c) -> (a -> b) -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ b_a1xO0)
                 (@ c_a1xO1)
                 (@ a_a1xO2)
                 ($dCoercible_a1xO4 [Occ=Once] :: Coercible b_a1xO0 c_a1xO1) ->
                 case GHC.Types.coercible_sel
                        @ * @ b_a1xO0 @ c_a1xO1 $dCoercible_a1xO4
                 of co_a1xVu
                 { __DEFAULT ->
                 (\ _ [Occ=Dead] (v_B2 [Occ=Once] :: a_a1xO2 -> b_a1xO0) -> v_B2)
                 `cast` (<b_a1xO0 -> c_a1xO1>_R
                         ->_R <a_a1xO2 -> b_a1xO0>_R
                         ->_R <a_a1xO2>_R
                         ->_R co_a1xVu
                         :: ((b_a1xO0 -> c_a1xO1)
                             -> (a_a1xO2 -> b_a1xO0) -> a_a1xO2 -> b_a1xO0 :: *)
                            ~R# ((b_a1xO0 -> c_a1xO1)
                                 -> (a_a1xO2 -> b_a1xO0) -> a_a1xO2 -> c_a1xO1 :: *))
                 }}]
#.
  = \ (@ b_a1xO0)
      (@ c_a1xO1)
      (@ a_a1xO2)
      ($dCoercible_a1xO4 :: Coercible b_a1xO0 c_a1xO1)
      _ [Occ=Dead]
      (eta1_X2r :: a_a1xO2 -> b_a1xO0) ->
      case GHC.Types.coercible_sel
             @ * @ b_a1xO0 @ c_a1xO1 $dCoercible_a1xO4
      of co_a1xVu
      { __DEFAULT ->
      eta1_X2r
      `cast` (<a_a1xO2>_R ->_R co_a1xVu
              :: (a_a1xO2 -> b_a1xO0 :: *) ~R# (a_a1xO2 -> c_a1xO1 :: *))
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Utils.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Utils.$trModule3
  = GHC.Types.TrNameS Data.Functor.Utils.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
Data.Functor.Utils.$trModule2 = "Data.Functor.Utils"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Utils.$trModule1
  = GHC.Types.TrNameS Data.Functor.Utils.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Functor.Utils.$trModule
  = GHC.Types.Module
      Data.Functor.Utils.$trModule3 Data.Functor.Utils.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep_r1ynX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep_r1ynX = GHC.Types.KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep1_r1ynY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep1_r1ynY = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep2_r1ynZ :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep2_r1ynZ
  = GHC.Types.:
      @ GHC.Types.KindRep $krep_r1ynX (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3_r1yo0 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep3_r1yo0
  = GHC.Types.: @ GHC.Types.KindRep $krep1_r1ynY $krep2_r1ynZ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4_r1yo1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_r1yo1
  = GHC.Types.KindRepTyConApp GHC.Tuple.$tc(,) $krep3_r1yo0

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5_r1yo2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep5_r1yo2 = GHC.Types.KindRepFun $krep1_r1ynY $krep4_r1yo1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep6_r1yo3 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep6_r1yo3
  = GHC.Types.:
      @ GHC.Types.KindRep $krep1_r1ynY (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7_r1yo4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep7_r1yo4
  = GHC.Types.KindRepTyConApp GHC.Base.$tcMaybe $krep6_r1yo3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tcMax2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Utils.$tcMax2 = "Max"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tcMax1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Utils.$tcMax1
  = GHC.Types.TrNameS Data.Functor.Utils.$tcMax2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tcMax :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Utils.$tcMax
  = GHC.Types.TyCon
      17055998897267803697##
      13070619747111935994##
      Data.Functor.Utils.$trModule
      Data.Functor.Utils.$tcMax1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8_r1yo5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep8_r1yo5
  = GHC.Types.KindRepTyConApp Data.Functor.Utils.$tcMax $krep6_r1yo3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'Max1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Utils.$tc'Max1
  = GHC.Types.KindRepFun $krep7_r1yo4 $krep8_r1yo5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'Max3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Utils.$tc'Max3 = "'Max"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'Max2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Utils.$tc'Max2
  = GHC.Types.TrNameS Data.Functor.Utils.$tc'Max3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'Max :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Utils.$tc'Max
  = GHC.Types.TyCon
      16178335003924091205##
      10384293407056089504##
      Data.Functor.Utils.$trModule
      Data.Functor.Utils.$tc'Max2
      1#
      Data.Functor.Utils.$tc'Max1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tcMin2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Utils.$tcMin2 = "Min"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tcMin1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Utils.$tcMin1
  = GHC.Types.TrNameS Data.Functor.Utils.$tcMin2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tcMin :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Utils.$tcMin
  = GHC.Types.TyCon
      13719831963261617173##
      12509304105097421826##
      Data.Functor.Utils.$trModule
      Data.Functor.Utils.$tcMin1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9_r1yo6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep9_r1yo6
  = GHC.Types.KindRepTyConApp Data.Functor.Utils.$tcMin $krep6_r1yo3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'Min1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Utils.$tc'Min1
  = GHC.Types.KindRepFun $krep7_r1yo4 $krep9_r1yo6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'Min3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Utils.$tc'Min3 = "'Min"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'Min2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Utils.$tc'Min2
  = GHC.Types.TrNameS Data.Functor.Utils.$tc'Min3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'Min :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Utils.$tc'Min
  = GHC.Types.TyCon
      3497961960072019520##
      14191657227527039212##
      Data.Functor.Utils.$trModule
      Data.Functor.Utils.$tc'Min2
      1#
      Data.Functor.Utils.$tc'Min1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tcStateL2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Utils.$tcStateL2 = "StateL"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tcStateL1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Utils.$tcStateL1
  = GHC.Types.TrNameS Data.Functor.Utils.$tcStateL2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tcStateL :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Utils.$tcStateL
  = GHC.Types.TyCon
      8498227433031831307##
      6442648285908986693##
      Data.Functor.Utils.$trModule
      Data.Functor.Utils.$tcStateL1
      0#
      GHC.Types.krep$*->*->*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10_r1yo7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep10_r1yo7
  = GHC.Types.KindRepTyConApp
      Data.Functor.Utils.$tcStateL $krep3_r1yo0

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'StateL1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Utils.$tc'StateL1
  = GHC.Types.KindRepFun $krep5_r1yo2 $krep10_r1yo7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'StateL3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Utils.$tc'StateL3 = "'StateL"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'StateL2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Utils.$tc'StateL2
  = GHC.Types.TrNameS Data.Functor.Utils.$tc'StateL3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'StateL :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Utils.$tc'StateL
  = GHC.Types.TyCon
      8965240648136302046##
      8498113279827793106##
      Data.Functor.Utils.$trModule
      Data.Functor.Utils.$tc'StateL2
      2#
      Data.Functor.Utils.$tc'StateL1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tcStateR2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Utils.$tcStateR2 = "StateR"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tcStateR1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Utils.$tcStateR1
  = GHC.Types.TrNameS Data.Functor.Utils.$tcStateR2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tcStateR :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Utils.$tcStateR
  = GHC.Types.TyCon
      10049146831422350196##
      16883721947448934294##
      Data.Functor.Utils.$trModule
      Data.Functor.Utils.$tcStateR1
      0#
      GHC.Types.krep$*->*->*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep11_r1yo8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep11_r1yo8
  = GHC.Types.KindRepTyConApp
      Data.Functor.Utils.$tcStateR $krep3_r1yo0

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'StateR1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Utils.$tc'StateR1
  = GHC.Types.KindRepFun $krep5_r1yo2 $krep11_r1yo8

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'StateR3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Utils.$tc'StateR3 = "'StateR"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'StateR2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Utils.$tc'StateR2
  = GHC.Types.TrNameS Data.Functor.Utils.$tc'StateR3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Utils.$tc'StateR :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Utils.$tc'StateR
  = GHC.Types.TyCon
      13798701525568783897##
      17913645303573466967##
      Data.Functor.Utils.$trModule
      Data.Functor.Utils.$tc'StateR2
      2#
      Data.Functor.Utils.$tc'StateR1


